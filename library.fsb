( Solo Forth library )

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

  \ This file is the library of Solo Forth,
  \ and the skeleton to build applications in Solo Forth.

  \ XXX UNDER DEVELOPMENT

\ Last modified: 201509250513

  \ ------------------------------------------------------------
  \ Acknowledgements

\ See <AKNOWLEDGMENTS.adoc>.

  \ ------------------------------------------------------------
  \ License

\ You may do whatever you want with this work, so long as you
\ retain all copyright notices, all credit notices, and this
\ license in all redistributed copies and derived works. There
\ is no warranty.

  \ ------------------------------------------------------------
  \ History

  \ http://programandala.net/en.program.solo_forth.history.html

( ) \ scr 1 -- testing load screen

: number?   ( ca len -- 0 | n 1 | d 2 )

	dup 0= if 2drop 0 exit then   \ any chars?

	over c@ [char] - = \ minus sign at the start?
	dup >r  abs /string

	dpl on  0 0 2swap >number dup
	if
		1 = swap c@ [char] . =  and
		if    r@ if  dnegate  then  dpl off  2
		else  2drop 0  then
	else
		2drop drop r@ if  negate  then  1
	then  rdrop  ;

  \ }}} =======================================================
  \ Need {{{

( need ) \ scr 2

  \ This screen must be at a fixed location.

: reload  ( -- )  scr @ load  ;

  \ XXX TMP
  \ XXX INFORMER
  \ : contains  ( ca1 len1 ca2 len2 -- f )  2dup cr type ." in"
  \ 2over -trailing cr type ." ?" cr .s key drop search nip nip ;
: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
  \ Does the string ca1 len1 contains the string ca2 len2?

variable default-first-locatable  variable first-locatable
8 dup default-first-locatable !  first-locatable !
variable last-locatable  scr/disk 1- last-locatable !

: located  ( ca len -- screen | false )
  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do   0 i (line) 2over contains if  2drop i unloop exit  then
    \ break-key? ?exhaust \ XXX TODO not in the kernel
  loop  2drop false  ;

: locate  ( "name" -- screen | false )
  parse-name save-string located  ;

-->

( need ) \ scr 3

: ?located  ( screen | false -- )  dup 0= #-268 ?error  ;

: from  ( "name" -- )  locate ?located first-locatable !  ;
  \ Locate the given _name_ and set its screen the first one
  \ `require` will search from.

: reneeded  ( ca len -- )  located ?located load  ;

: reneed  ( "name" -- )  parse-name save-string reneeded  ;

: needed  ( ca len -- )

  \ XXX FIXME usually the final check fails because the saved
  \ string has been overwritten. the only solution is to store
  \ the string apart, in an ad hoc zone.

  \ XXX OLD
  \ 2dup undefined?
  \   if  2dup reneeded  then
  \ 2dup undefined? warnings @ and
  \   if  type 28 warning exit  then  2drop  ;

  \ XXX TMP
  \ 2dup undefined?  if  reneeded  else  2drop  then  ;
  \ undefined?  if  parsed-name 2@ reneeded  then  ;

  2dup save-string undefined?
    \ a copy of the string is used because `undefined?`
    \ converts it to uppercase
  if  reneeded  else  2drop  then  ;

: need  ( "name" -- )  parse-name save-string needed  ;

  \ }}} =======================================================
  \ Error codes {{{

( Standard error codes -01..-15 )  \ scr 4

\ #-01 ABORT
\ #-02 ABORT"
\ #-03 stack overflow
\ #-04 stack underflow
\ #-05 return stack overflow
\ #-06 return stack underflow
\ #-07 do-loops nested too deeply during execution
\ #-08 dictionary overflow
\ #-09 invalid memory address
\ #-10 division by zero
\ #-11 result out of range
\ #-12 argument type mismatch
\ #-13 undefined word
\ #-14 interpreting a compile-only word
\ #-15 invalid FORGET

( Standard error codes -16..-30 )

\ #-16 attempt to use zero-length string as a name
\ #-17 pictured numeric output string overflow
\ #-18 parsed string overflow
\ #-19 definition name too long
\ #-20 write to a read-only location
\ #-21 unsupported operation
\ #-22 control structure mismatch
\ #-23 address alignment exception
\ #-24 invalid numeric argument
\ #-25 return stack imbalance
\ #-26 loop parameters unavailable
\ #-27 invalid recursion
\ #-28 user interrupt
\ #-29 compiler nesting
\ #-30 obsolescent feature

( Standard error codes -31..-45 )

\ #-31 >BODY used on non-CREATEd definition
\ #-32 invalid name argument
\ #-33 block read exception
\ #-34 block write exception
\ #-35 invalid block number
\ #-36 invalid file position
\ #-37 file I/O exception
\ #-38 non-existent file
\ #-39 unexpected end of file
\ #-40 invalid BASE for floating point conversion
\ #-41 loss of precision
\ #-42 floating-point divide by zero
\ #-43 floating-point result out of range
\ #-44 floating-point stack overflow
\ #-45 floating-point stack underflow

( Standard error codes -46..-60 )

\ #-46 floating-point invalid argument
\ #-47 compilation word list deleted
\ #-48 invalid POSTPONE
\ #-49 search-order overflow
\ #-50 search-order underflow
\ #-51 compilation word list changed
\ #-52 control-flow stack overflow
\ #-53 exception stack overflow
\ #-54 floating-point underflow
\ #-55 floating-point unidentified fault
\ #-56 QUIT
\ #-57 exception in sending or receiving a character
\ #-58 [IF], [ELSE], or [THEN] exception
\ #-59 ALLOCATE
\ #-60 FREE

( Standard error codes -61..-75 )

\ #-61 RESIZE
\ #-62 CLOSE-FILE
\ #-63 CREATE-FILE
\ #-64 DELETE-FILE
\ #-65 FILE-POSITION
\ #-66 FILE-SIZE
\ #-67 FILE-STATUS
\ #-68 FLUSH-FILE
\ #-69 OPEN-FILE
\ #-70 READ-FILE
\ #-71 READ-LINE
\ #-72 RENAME-FILE
\ #-73 REPOSITION-FILE
\ #-74 RESIZE-FILE
\ #-75 WRITE-FILE

( Standard error codes -76..-79 )

\ #-76 WRITE-LINE
\ #-77 malformed xchar
\ #-78 SUBSTITUTE
\ #-79 REPLACES
\ #-80
\ #-81
\ #-82
\ #-83
\ #-84
\ #-85
\ #-86
\ #-87
\ #-88
\ #-89
\ #-90

( System error codes -256..-270 )

\ #-256 not a word nor a number
\ #-257 warning: is not unique
\ #-258 stack imbalance
\ #-259 trying to load from screen 0
\ #-260 wrong digit
\ #-261 deferred word is uninitialized
\ #-262 assertion failed
\ #-263 execution only
\ #-264 definition not finished
\ #-265 loading only
\ #-266 off current editing screen
\ #-267 warning: not present, though required
\ #-268 required, but not located
\ #-269 relative jump too long
\ #-270 text not found

( System error codes -271..-286 )

\ #-271
\ #-272
\ #-273
\ #-274
\ #-275
\ #-276
\ #-277
\ #-278
\ #-279
\ #-281
\ #-282
\ #-283
\ #-284
\ #-285
\ #-286

( G+DOS error codes -1000..-1014 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1000 G+DOS: Nonsense in G+DOS
\ #-1001 G+DOS: Nonsense in GNOS
\ #-1002 G+DOS: Statement end error
\ #-1003 G+DOS: Break requested
\ #-1004 G+DOS: Sector error
\ #-1005 G+DOS: Format data lost
\ #-1006 G+DOS: Check disk in drive
\ #-1007 G+DOS: No +SYS file
\ #-1008 G+DOS: Invalid file name
\ #-1009 G+DOS: Invalid station
\ #-1010 G+DOS: Invalid device
\ #-1011 G+DOS: Variable not found
\ #-1012 G+DOS: Verify failed
\ #-1013 G+DOS: Wrong file type
\ #-1014 G+DOS: Merge error

( G+DOS error codes -1015..-1029 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1015 G+DOS: Code error
\ #-1016 G+DOS: Pupil set
\ #-1017 G+DOS: Invalid code
\ #-1018 G+DOS: Reading a write file
\ #-1019 G+DOS: Writing a read file
\ #-1020 G+DOS: O.K. G+DOS
\ #-1021 G+DOS: Network off
\ #-1022 G+DOS: Wrong drive
\ #-1023 G+DOS: Disk write protected
\ #-1024 G+DOS: Not enough space on disk
\ #-1025 G+DOS: Directory full
\ #-1026 G+DOS: File not found
\ #-1027 G+DOS: End of file
\ #-1028 G+DOS: File name used
\ #-1029 G+DOS: No G+DOS loaded

( G+DOS error codes -1030..-1031 )

\ #-1030 G+DOS: STREAM used
\ #-1031 G+DOS: CHANNEL used

( OS error codes -1128..-1142 )

  \ XXX TODO -- it seems OS error codes (there are 28 of them)
  \ may be returned by G+DOS.  they are detected and converted
  \ by `ior>error`.

\ #-1128 OS:
\ #-1129 OS:
\ #-1130 OS:
\ #-1131 OS:
\ #-1132 OS:
\ #-1133 OS:
\ #-1134 OS:
\ #-1135 OS:
\ #-1136 OS:
\ #-1137 OS:
\ #-1138 OS:
\ #-1139 OS:
\ #-1140 OS:
\ #-1141 OS:
\ #-1142 OS:

( OS error codes -1143..-1154 )

\ #-1143 OS:
\ #-1144 OS:
\ #-1145 OS:
\ #-1146 OS:
\ #-1147 OS:
\ #-1148 OS:
\ #-1149 OS:
\ #-1150 OS:
\ #-1151 OS:
\ #-1151 OS:
\ #-1152 OS:
\ #-1153 OS:
\ #-1154 OS:

  \ }}} =======================================================
  \ Code under development {{{

( err>lin )

  \ XXX FIXME -- fixed version of `error>line`

: err>lin  ( n1 -- n2 )
  error>ordinal dup 1+ 1
  do  cr i . ." 16 mod . " 16 mod . key drop
    i 16 mod 0= abs +  loop  ;

( number? )

: sign?  ( ca len -- ca' len' f )
  \ get optional sign
  \ ca len = number
  \ ca' len' = number without the minus sign
  \ f = negative number?
  over c@ [char] - = dup >r abs /string r>  ;


: number?  ( ca len -- n tf | ff )
  
  base @ >r  number-base base !
  0 0 2swap
  sign? >r  >number nip
  if    2drop rdrop false
  else  r> if negate then  true
  then  r> base !  ;

( number? )

: number?  ( ca len -- n tf | ff )

  \ first version
  
  base @ >r  number-base base !
  0 0 2swap
  sign? >r  >number nip
  if    2drop rdrop false
  else  r> if negate then  true
  then  r> base !  ;

( error>line error>ordinal )

  \ XXX TODO -- new versions under development, adapted to
  \ Forth-2012 codes

: error>ordinal  ( -n1 -- +n2 )
  \ Convert an error code to its ordinal position in the
  \ library.
  \ -n1 =  -90..-1        \ Forth-2012 error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146

  \ XXX TODE -- this word is finished and already in the
  \ kernel, but it should be a library option, using a defered
  \ word in `message`.

  abs
  dup 256 < if  exit  then
  dup 1000 < if  [ 255 091 - ] literal - exit  then
  [ 1000 286 - 255 091 - + ] literal -   ;

: error>line  ( -n1 -- +n2 )
  error>ordinal  dup 1+ 1 do  i 16 mod 0= abs +  loop  ;

  \ }}} =======================================================
  \ Development benchmarks and tests {{{

( fill-bench )

  \ 2015-09-25: Benchmark three implementations of `fill`:
  \
  \ `fill` is the original implementation from Abersoft Forth
  \ `fill2` is a modified version
  \ `fill88` is the code adapted from Z88 CamelForth

need frames@  need frames0  need rnd

defer (fill)

: (fill-bench)  ( n cfa -- )
  ['] (fill) defer!
  frames0  0
  do  16384 6144 rnd (fill)  loop
  \ do  16384 1 rnd (fill)  loop
  \ do  16384 0 rnd (fill)  loop
  \ do  16384 2048 rnd (fill)  loop
  frames@ cr d.
  key drop
  ;

: fill-bench  ( n -- )
  dup ['] fill (fill-bench)
  dup ['] fill2 (fill-bench)
      ['] fill88 (fill-bench)  ;

  \ Kernel code: `16384 6144 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010   10    10      5
  \ 00100  491   522    252 
  \ 01000 4909  5218   2524
 
  \ Kernel code: `16384 1 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    9     8      8
  \ 01000   85    84     84
  \ 05000  425   423    422
  \ 10000  850   846    845
 
  \ Kernel code: `16384 0 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    8     8      8
  \ 01000   84    83     84
  \ 05000  421   418    421
  \ 10000  842   837    842

  \ Kernel code: `16384 2048 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill  fill2 fill88
  \       ----- ----- ------
  \ 00010    17    18      9
  \ 00100   169   180     89
  \ 01000  1693  1795    898
  \ 30000 50770 53863  26933

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( /-bench )

  \ 2015-09-22: This bench compares the execution speed of
  \ Abersoft Forth's `m/` and Z88 CamelForth's `sm/rem`. Both
  \ words are equivalent.  Abersoft Forth's `m/` is much
  \ faster.

need frames@  need frames0  need rnd

: drnd  ( -- d )  rnd rnd  ;

[defined] (/)  ?\ defer (/)

: (/-bench)  ( n -- )
  frames0  1+ 1 do  drnd i (/) 2drop  loop  frames@ cr d.  ;

: /-bench  ( n -- )
  dup ['] m/ ['] (/) defer! (/-bench)
      ['] sm/rem ['] (/) defer! (/-bench)  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       m/    sm/rem
  \       ----- ------
  \ 00010     3      4
  \ 00100    33     44
  \ 01000   326    442

  \ m/     = word from Abersoft Forth
  \ sm/rem = word from Z88 Camel Forth

( um*-bench )

need frames@  need frames0

: um*-bench  ( n -- )
  frames0  0 do  i i um* 2drop  loop  frames@ d.  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       DZX   hForth R hForth A Z88 R Z88 A
  \       ----- -------- -------- ----- -----
  \ 00100     3        3        3     3     3
  \ 01000    29       32       31    32    31
  \ 10000   297      328      319   323   316
  \ 20000   598      659      643   647   633
  \ 32000   961     1060     1037  1037  1016

  \            Bytes free Code from
  \            ---------- ---------
  \ DZX      = 33783      DZX-Forth
  \ hForth R = 33787      hForth, with relative jumps
  \ hForth A = 33784      hForth, with absolute jumps
  \ Z88 R    = 33786      Z88 CamelForth, with relative jumps
  \ Z88 A    = 33784      Z88 CamelForth, with absolute jumps

  \ }}} =======================================================
  \ Parsing {{{

( evaluate )

  \ XXX TODO

  \ XXX Gforth:

: evaluate  ( ca len -- )  ['] interpret execute-parsing  ;

( parse-char )

: parse-char  ( "c"  -- c )  stream c@ 0 parsed  ;
  \ Parse the next char in the input stream and return its
  \ code.
  \
  \ Note: `0 parsed` increments `>in` because `parsed` adds 1
  \ to its parameter (to include the delimiter).

  \ }}} =======================================================
  \ Strings {{{

( s\" )  \ ==strings==

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` contains the words whose names are
  \ characters that must be escaped after a backslash. Their
  \ execution returns the new character(s) on the stack (the
  \ first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?error  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( s\" )

only forth definitions

need char>string   need search-wordlist
need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: (s\")  ( "text<quote>"  -- ca len )
  pad 0  \ empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

: s\"  ( "text<quote>"  - ca len )  \ Forth-2012
  (s\")  comp? if  postpone sliteral  then  ; immediate

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credits:
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credits:
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;

( s' )

  \ Credits:
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( compilation: "text<'>" -- ) ( run-time:  -- ca len )
  \
  \ }doc

: s'  ( compilation: "ccc<'>" -- ) ( run-time:  -- ca len )
  [char] ' (s)  ; immediate

  \ }}} =======================================================
  \ Data stack {{{

( -rot )  \ ==datastack==

  \ Credits:
  \ Code adapted from Afera.

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,      \ pop hl / pop de
  E3 c,            \ ex (sp),hl
  EB c,            \ ex de,hl
  C3 c, pushhlde , \ jp pushhlde

  end-code

( 2nip )

  \ Credits:
  \ Code from Afera; original code from DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ }}} =======================================================
  \ Return stack {{{

( n>r )  \ ==returnstack==

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  pushhl jp
  end-code

need n>r

( rdepth )

  \ Credits:
  \ Code from Afera.

: rdepth  ( -- n )  rp@ r0 @ - -2 /  ;

  \ }}} =======================================================
  \ User variables {{{

  \ XXX TODO

: uallot ( n -- )  udp @ swap udp +!  ;
  \ XXX from Gforth

: user  ( "name" -- )  create cell uallot , does> @ up @ +  ;

: user  ( "name" -- )  create cell uallot c, does> c@ up @ +  ;


  \ }}} =======================================================
  \ Screen modes {{{

( mode32 )  \ ==screenmodes==

[defined] sys-chans ?\ 23631 constant sys-chans
[defined] sys-chars ?\ 23606 constant sys-chars

: mode-output  ( a -- )
  \ Associate the output
  \ routine at _a_ to the system channels "K", "S" and "P".
  sys-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

: set-mode  ( a1 a2 -- )
  \ Set the system font to _a1_ and associate the output
  \ routine at _a2_ to the system channels.
  sys-chars !  mode-output  ;

: mode32  ( -- )
  [ latest nfa>cfa ] literal current-mode !
  2548 15360 set-mode
  ['] (mode32-xy) ['] xy defer!
  ['] (mode32-at-xy) ['] at-xy defer!  ;
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).

' mode32  dup current-mode !
' bye cfa>pfa !  \ patch `bye` to execute `mode32`

( mode42 )

  \ Credits:
  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published in Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ XXX TODO -- integrate the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

need mode32  need <file-as-is

drive@ 1 drive!
s" print-42" <file-as-is ?error
s" ea5aky.f42" <file-as-is ?error
drive!
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode42-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode42  ( -- )
  [ latest nfa>cfa ] literal current-mode !
  63900 [ 64600 256 - ] literal set-mode
  ['] (mode42-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ Credits:
  \ Author of the original code: Andrew Owen.
  \ Published in the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1
  \ Modified and adapted to Solo Forth by Marcos Cruz.

  \ XXX OLD temporary first version
  \ First the driver and the font were in a disk file
  \ that is loaded at 60000. Later the font was compiled
  \ into the dictionary.

need mode32  need <file-as-is  need 4x8font

drive@ 1 drive!
s" 4x8fd.tap" <file-as-is ?error
drive!
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode64-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latest nfa>cfa ] literal current-mode !
  60000 4x8font set-mode
  ['] (mode64-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

code (mode64-emit)  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if
    FF a ld#
  then
  \ check_cr

  end-code

: mode64  ( -- )  (mode64-emit) mode64-chars @ set-mode
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credits:
  \ Author of the font: Andrew Owen.
  \ Published in the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

( spectrum-mode )

  \ XXX OLD

: spectrum-mode  ( -- )
  \ Set the Spectrum printing mode. This is the default.
  ['] (emit) ['] emit defer!
  ['] (at-xy) ['] at-xy defer!
  ['] (home) ['] home defer!
  ['] (cr) ['] cr defer!  ;

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 drive!  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) cfa>pfa hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( xc yc -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credits:
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    \ now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  l add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) cfa>pfa call
  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Decompressor {{{

( zx7 )

  \ XXX TODO  -- adapt

  \ }}} =======================================================
  \ Graphics {{{

( udg! udg: )  \ ==graphics==

[defined] udg
  ?\  : udg  ( -- a )  23675 @  ;
      \ Address of the User Defined Graphics.

: udg!  ( b0..b7 c -- )
  128 - 8 * udg + 1 - dup 8 + do  i c!  -1 +loop  ;
  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;
  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \ 
  \ Create a constant called "name" for the UDG char _c_.
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

( xy-emit-udg )

need (xy-emit)  need z80-asm

code xy-emit-udg  ( x y b -- )

  \ Display the used graphic character _b_ (0..255) at graphic
  \ coordinates _x y_. The system variable "UDG" is supossed to
  \ hold the address of a graphic charset (the address of the
  \ char 0 bitmap).
  \
  \ The UDG character will be printed with overwritting
  \ (equivalent to `1 overwritte`).

  hl pop  l a ld
  de pop  hl pop  bc push  e b ld  l c ld
  5C7B de ftp  \ system variable UDG
  (xy-emit) call
  bc pop  next ix ldp#  jpnext
  end-code

\ (xy-emit) \

need z80-asm  need (pixel-addr)

  \ Credits:
  \ Code Adapted from "SMOOTH MOVE",
  \ written by Simon N.  Goodwin,
  \ published in Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create (xy-emit)  ( -- a )

  \ XXX TODO rename all "xy-emit" to "hires-emit"

  \ Print a 8x8 bits char at high resolution coordinates.

  \ Input:
  \   DE = address of the first char (0) bitmap in a charset
  \   A = char code (0..255)
  \   B = y coordinate
  \   C = x coordinate
  \ Modifies:
  \   AF BC HL IX DE

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

( ocr )

  \ Credits:
  \ Adapted from anonymous code published in Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  pushhl jp  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  23606 @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ charset pointed by the system variable UDG.
  23675 @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

( (pixel-addr) )

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( xc yc -- )

  D9 c,               \ exx
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credits:
  \ Author of the original code: José Manuel Lazo.
  \ Published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( xc yc -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credits:
  \ Based on code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credits:
  \ Based on code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( pixel? )

need (pixel-addr)  need z80-asm

code pixel?  ( xc yc -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true cfa>pfa jpnz
  ' false cfa>pfa jp
  end-code

( rdraw )

  \ Credits:
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( x y -- )

  \ Draw a line relative to the current coordinates.
  \
  \ x y = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

( adraw ) \ from Abersoft Forth

  \ Credits:
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot

2variable x1  2variable incx  2variable y1  2variable incy

  \ System variables used:
  \   23677 = COORDX
  \   23678 = COORDY

: adraw  ( x y -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  23678 c@ ( y0 ) dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )
  23677 c@ ( x0 ) dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )
  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ m/mod dnegate
  else  0 swap r@ m/mod  then
  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ m/mod dnegate
  else  0 swap r@ m/mod  then
  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

( attr )

need z80-asm need (attr-addr)

code attr ( col line -- b )

  \ Return the color attribute of the given cursor coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  pushhl jp

  end-code

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col line -- a )

  \ Return the color attribute address of the given cursor
  \ coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  pushhl jp

  end-code

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  \ Address of a Z80 routine that calculates the color
  \ attribute address of a cursor position.  This is a modified
  \ version of the ROM routine at 0x2583.

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

( circle )


  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

  \ XXX TODO

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot cfa>pfa call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( x y radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credits:
  \ Code adapted from a routine written by Pablo Ariza,
  \ published in Microhobby Especial, issue 7 (1987-12), page 46:
  \ <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credits:
  \ Code adapted from a routine written by Javier Granadino,
  \ published in Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credits:
  \ Code adapted from a routine written by Juan JosÃ© Rivas,
  \ published in Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
            begin   m rrc  hl decp  h 6 bit  z until
            step

  bc pop  jpnext

  end-code

( clsx )

  \ Clear the screen by rotating all bytes
  \ of the bitmap.

  \ Credits:
  \ Code adapted from a routine written by Anselmo Moreno Lorente,
  \ published in Microhobby, issue 121 (1987-03), page 7:
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code clsx  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( scroll-1px-right )

  \ Credits:
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

  \ XXX FIXME

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
          m srl  hl incp  \ first char column
          1F b ld#  \ remaining columns
          begin   m rr  hl incp  step
          c dec
          z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credits:
  \ Code adapted from a routine written by IvÃ¡n Sansa,
  \ published in Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

( xy-scroll )

  \ Credits:
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

  \ XXX FIXME

need z80-asm

code xy-scroll  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin

      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
      z until

    step

  bc pop  end-code

( horizontal-curtain )

  \ Credits:
  \ Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the top and bottom
  \ rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credits:
  \ Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  \ XXX FIXME crash!

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ }}} =======================================================
  \ Sound 128 {{{

( !sound vol shutup noise )  \ ==sound128==

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  vocabulary music  current @  also music definitions

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b

-->

( music )

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l  ( n -- )  len !  ;
: o+  ( -- )  octave @ 2 * octave !  ;
: o-  ( -- )  octave @ 2 / octave !  ;
: r  ( -- )  tempo @ len @ * ms  ;
: >>  ( -- )  1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )  1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: )

  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan JosÃ© Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

  \ XXX TODO

: sound:  ( b0 ... b13 "name" -- )
  create  here 1- 14 allot here -1 do  i c!  -1 +loop  ;

( play )

  \ Z80 version of the previous `play`.

need z80-asm

[defined] sound-register-port
?\ 65533 constant sound-register-port
[defined] sound-write-port
?\ 49149 constant sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter train )

  \ Sounds to be played with `play`.

  \ Credits:
  \ `waves` and `shoot` are
  \ adapted from code written by Juan JosÃ© Ruiz,
  \ published in Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

create waves  ( -- a )
  0 c,  0 c,  0 c,  0 c,  0 c,  0 c,  7 c,
  71 c,  20 c,  20 c,  20 c,  0 c,  38 c,  14 c,

create shoot  ( -- a )
  10 c,  0 c,  177 c,  0 c,  191 c,  0 c,  31 c,
  71 c,  20 c,  20 c,  20 c,  92 c,  28 c,  3 c,

  \ Credits:
  \ `helicopter` and `train` are
  \ adapted from code written by JosÃ© Ãngel MartÃ­n,
  \ published in Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

create helicopter  ( -- a )
  200 c,  15 c,  200 c,  15 c,  200 c,  15 c,  0 c,
  7 c, 23 c,  23 c,  23 c,  255 c,  1 c,  12 c,

create train  ( -- a )
  100 c,  120 c,  48 c,  97 c,  12 c,  200 c,  55 c,
  15 c,  9 c,  11 c,  55 c,  180 c,  4 c,  8 c,

( sound effects )

  \ Sounds to be played with `play`.

  \ Data extracted a program written by Juan JosÃ© Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop

  decimal

( rain water-drops )

  \ Sounds to be played with `play`.

  \ Data extracted from a program written by Carlos Ventura,
  \ published in Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX this effects don't sound fine, but the data is right

create rain  ( -- a )
  44 c, 24 c, 6 c, 6 c, 7 c, 3 c, 3 c,
  5 c, 44 c, 6 c, 3 c, 5 c, 3 c, 3 c,

create water-drop  ( -- a )
  20 c, 83 c, 94 c, 39 c, 0 c, 8 c, 31 c,
  71 c, 23 c, 23 c, 22 c, 90 c, 0 c, 0 c,

  \ }}} =======================================================
  \ Sound 48 {{{

( bleep )  \ ==sound48==

  \ Credits:
  \ Code modified from Abersoft Forth.

code bleep  ( n1 n2 -- )
  \ Produce a tone in the noise maker.
  \ n1 = duration
  \ n2 = pitch
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5 ,        \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)
  end-code

( beep>bleep )

  \ Credits:
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( freq duration -- n1 n2 )
  \ n1 = duration
  \ n2 = pitch
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: Ãlvaro Corredor Lanas.
  \ Published in Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published in Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: LÃ­der Software.
  \ Published in Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Memory access {{{

( exchange )  \  ==memoryaccess==

: exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

( command )

  \ XXX OLD -- 2015-09-13: moved to kernel
  \ : source  ( -- a len )  \ Forth-94
  \   blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

need source  need /string

: command  ( "text<eol>" -- ca len )
  source span @ min c/l min  >in @ span @ min /string
  dup >in +! save-string  ;
  \ Get the text string until the end of line.
  \ Note: this is possibly useful factor of the editor's
  \ `text`.

( c@+ )

need z80-asm

  \ Credits:
  \ Code adapted from Pygmy Forth.

code c@+  ( ca - ca+1 c )

  \ First version
  \ de pop  de ftap  de incp  0 h ld# a l ld  pushhlde jp

  \ Second version
  hl pop  m a ld  hl incp  hl push  pusha jp

  end-code

  \ doc{
  \
  \ code c@+  ( ca - ca+1 c )
  \
  \ Fetch the byte at _ca_ a and increments the address.
  \ This is handy for stepping through byte arrays.
  \
  \ }doc

  \ }}} =======================================================
  \ Operators {{{

( under+ )  \ ==operators==

: under+  ( n1 n2 n3 -- n4 n3 )  >r + r>  ;

( within between )

  \ Credits:
  \ Code from DZX-Forth.

: within  ( n1|u1 n2|u2 n3|u3 -- f )
  over - >r - r> u<  ;

need -rot

: between  ( n1|u1 n2|u2 n3|u3 -- f )
  over - -rot - u< 0=  ;

( d0= d0< d< du< dmin dmax )

  \ Credits:
  \ Code from DZX-Forth.

: d0=  ( d -- f )  or 0=  ;

: d0<  ( d -- f )  nip 0<  ;

; d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;

: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;

: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;

( lshift )

  \ Credits:
  \ Code from DZX-Forth.

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

  \ XXX TODO

code rshift  ( x1 u -- x2 )

  \ Credits:
  \ Code from DZX-Forth.

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  \ or a
  \ ld a,h
  \ call sra_hl.1 ; XXX TODO this is in the kernel
  C3 c, ,         \ jp begin

  end-code

( sm/rem )

  \ Credits:
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credits:
  \ Forth-94 documentation.

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Standard: Forth-94.
  \
  \ }doc

  \ Credits:
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ From the Forth-94 documentation:

     \ Table 3.3 - Floored Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7       4               -2
     \ 10                -7      -4               -2
     \ -10               -7      -3                1

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

need fm/mod

  \ Credits:
  \ Forth-94 documentation.

: /_mod  ( n1 n2 -- n3 n4)  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3)  /_mod nip  ;

: _mod  ( n1 n2 -- n3)  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5)  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? )

  \ XXX TODO -- from F83

: any?  ( n1..nn n n0 -- f )
  \ Is any number _n1..nn_ equal to _n0_?
  ;

  \ }}} =======================================================
  \ Conditional compilation {{{

( [if] [else] [then] )  \ ==conditionalcompilation==

[defined] s=  ?\  : s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

: [else]  ( "..." -- )

  1 begin   parse-name 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

  \ }}} =======================================================
  \ G+DOS {{{

( ufia )  \ ==g+dos==

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1 \ drive: 1 or 2
ufia 1+   constant fstr1 \ program number
ufia 2+   constant sstr1 \ stream number
ufia 3 +  constant device \ device: "D" or "d"
ufia 4 +  constant nstr1 \ directory description
ufia 5 +  constant nstr2 \ file name
ufia 15 + constant hd00  \ file type
ufia 16 + constant hd0b  \ file length
ufia 18 + constant hd0d  \ file start address
  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

char d device c! \ "d" or "D"
2 sstr1 c! \ stream 2
1 dstr1 c! \ drive 1

  \ These variables hold a copy of the HD0B and HD0D UFIA
  \ fields. They are used by `(<DISK)`.
variable file-length
variable file-address

( File types and directory descriptions)

  \ File types

0 constant basic-filetype  1 constant data-array-filetype
2 constant string-array-filetype  3 constant code-filetype

  \ Directory descriptions

  01 constant basic-file      02 constant data-array
  03 constant string-array    04 constant code-file
  05 constant snapshot-48k    06 constant microdrive-file
  07 constant screens$-file   08 constant special-file
  09 constant snapshot-128k   10 constant opentype-file
  11 constant execute-file

( --hook-codes-- )

hex

33 constant hxfer  34 constant ofsm  35 constant hofile
36 constant sbyte  37 constant hsvbk 38 constant cfsm
39 constant pntp   3A constant cops  3B constant hgfile
3C constant lbyte  3D constant hldbk 3E constant wsad
3F constant sad    40 constant rest  41 constant heraz
42 constant cops2  43 constant pcat  44 constant hrsad
45 constant hwsad  46 constant otfoc 47 constant patch

decimal

: --hook-codes--  ;

( ior>error ?dos-error )

: ior>error  ( ior -- f n )

  \ Convert a DOS ior to a Forth error number.

  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: ZX Spectrum error; unset: DOS error
  \ f = error?
  \ n = error number:
  \     n>999 = DOS error number
  \     n>1127 = OS error number

  \ XXX OLD
  \ dup 128 and       \ ZX Spectrum error?
  \ \ XXX FIXME -- BASIC errors are not properly calculated
  \ if  negate  else  31 +  then   ;

  1000 +  ;

: ?dos-error  ( ior -- )
  \ ior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: ZX Spectrum error; unset: DOS error
  ior>error ?error  ;

( drive@ drive! )

need z80-asm  need --hook-codes--

code drive@  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  \ save the Forth registers
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp  end-code

code drive!  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  \ save the Forth registers
  l a ld  21 hook   \ select drive in a
  bc pop   next ix ldp#  \ restore the Forth registers
  jpnext  end-code

( -file )

need z80-asm  need ufia  need --hook-codes--

code (-file)  ( -- ior )

  \ Delete a disk file using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  heraz hook \ erase the file
  bc pop  next ix ldp#  \ restore the Forth registers
  af push
  jpnext
  end-code

need ior>error

: -file  ( ca len -- f n )
  \ Delete a disk file.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  filename>ufia (-file) ior>error  ;

( -filename filename! >ufia filename>ufia )

need ufia  need drive@

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  drive@ dstr1 c!  ;

1 drive!  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  bc pop  next ix ldp#  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) ior>error  ;

( <file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) ior>error  ;

( <file-as-is )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file-as-is)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    hd0d de ftp  hd0b bc ftp  hldbk hook
      \ Use the address and length from the header.
      \ Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file-as-is  ( ca len -- f n )
  \ Load a file from disk.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2swap >ufia (<file-as-is) ior>error  ;

( file? )

need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )

  bc push  \ save the Forth IP
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  ' true cfa>pfa jpz
  ' false cfa>pfa jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ hex 3E01 constant ufia1 decimal
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  exx
    \ Get the parameter in hl' and save the Forth IP

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  exx  l a ld  24B5 call  168E call
    \ 24B5 = CAT_RUN (input: cat type in the a register)
    \ 168E = BORD_REST (restore the border)

  E7 out  bc pop  next ix ldp#  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( ca len -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( ca len -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need z80-asm  need --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

need z80-asm  need --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

need z80-asm  need --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( !dos )

need z80-asm  need --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  \ save the Forth IP
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ bc pop  next ix ldp#  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

  \ }}} =======================================================
  \ Disk blocks {{{

( update flush continued ?load thru +load +thru )

: update  ( -- )

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the most recently referenced block as altered. The
  \ block will subsequently be transferred automatically to
  \ disk should its buffer be required for storage of a
  \ different block.
  \
  \ }doc

  disk-buffer @
  [ base @ hex ] 8000 [ base ! ] or
  disk-buffer !  ;

: flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ }doc

: continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at screen _u_.
  \
  \ Standard: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

: ?load  ( scr f -)  if  dup load  then  drop  ;

  \ doc{
  \
  \ ?load  ( u f -- )
  \
  \ Load screen _u_ if flag _f_ is true.
  \
  \ }doc

  \ Credits:
  \ `?load` from Pygmy Forth.

: thru  ( u1 u2 -- )  1+ swap do  i load  loop  ;
: +load  ( n -- )  blk @ b/scr / + load  ;
: +thru  ( u1 u2 -- )  1+ swap do  i +load  loop  ;

  \ Credits:
  \ `thru`, `+load` and `+thru` from Afera.

  \ }}} =======================================================
  \ Tape files {{{

  \ XXX TODO From Afera.

  \ }}} =======================================================
  \ Tools {{{

( transient[ )  \ ==tools==

  \ XXX TODO -- Finish.

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  \ Start transient code, reserving u bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - dp !  ;

: ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.

  old-dp @ dp !  old-np @ np !  ;

: -transient  ( -- )

  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.

  old-voc-link @ voc-link !

  \ Store the nfa of the latest word created before compiling
  \ the transient code, into the lfa of the first word created
  \ after the transient code was finished by `]transient`.

  \ XXX TODO

  old-latest @ old-np @ cfap>lfa !n  ;

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( hex. hexb. dhex. <hex hex> )

  \ Credits:
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: dhex.    ( d -- )  8 (dhex.)  ;
: hex.     ( n -- )  s>d 4 (dhex.)  ;
: hexb.    ( b -- )  s>d 2 (dhex.)  ;

( binary bin. binb. dbin. <bin bin> )

[defined] base'  ?\ variable base'

base @ decimal
[defined] binary  ?\ : binary  ( -- )  2 base !  ;
base !

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  bin{ (d.) }bin type space  ;
: dbin.    ( d -- )  32 (dbin.)  ;
: bin.     ( n -- )  s>d 16 (dbin.)  ;
: binb.    ( b -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  \ XXX TODO use `?do` instead of `if` when available
  dup if
    bounds do
      i c@ 127 and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

( dump )

need break-key?  need hex.  need ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: dump  ( a len -- )
  7 + -8 and 8 / 0
  \ XXX TODO use `?do` instead of `if` when available
  2dup <> if
    do
      cr dup hex.
      8 0 do  i over + @ flip hex.  2 +loop
      \ 16 0 do  i over + c@ hexb.  loop
      dup bs 8 ascii-type
      break-key? if  exhaust  then
    8 + loop
  else  2drop  then  drop  ;

( decode )

  \ Credits:
  \ Code adapted and improved from Afera's `DECODE`.

  \ Variables, indentation and pause control

forth definitions decimal

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-compile    ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal    ( a1 -- a2 )  2+ dup @ .  ;

: decode-cliteral   ( a1 -- a2 )  2+ dup c@ . 1-  ;

: decode-branch     ( a1 -- a2 )  2+ dup @ u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode )

  \ Special cases dispatcher

need case

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-dot-quote  endof
  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] ;s =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  pfa>cfa @ ['] : @ =  ;

-->

( decode )

  \ Main code

: (decode)  ( pfa --- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>cfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp0 @ sp! quit  endof \ q
                      bl  of  drop            endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined if  cfa>pfa  0 decode-level !  (decode)
          else  drop  -13 error  then  ;

( list )

need break-key?

: list  ( n -- )

  \ List screen number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    break-key? ?exhaust
  loop cr  ;

( break-key? )

code break-key?  ( -- f )

  \ Is the Break key pressed?

  CD c, 1F54 ,              \ call rom_break_key
  D2 c, ' true cfa>pfa ,    \ jp nc,true
  C3 c, ' false cfa>pfa ,   \ jp false

  end-code

( index .index )

need break-key?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the screen _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each screen over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap do
    cr i 3 .r space 0 i .line
    break-key? if  exhaust  then
  loop  ;

( index-like )

need break-key?  need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each screen over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap do
    0 i (line) 2over contains if  i .index  then
    break-key? if  exhaust  then
  loop  2drop  ;

( index-ilike )

need break-key?  need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each screen over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap do
    save-string  0 i (line) save-string 2dup uppers
    2over contains if  i .index  then
    break-key? if  exhaust  then
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

( words )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

need break-key?

[defined] tab ?\  : tab  ( -- )  6 emit  ;

: words  ( -- )
  trail
  begin  dup 0<> break-key? 0= and  while
    dup id. tab  nfa>lfa @n
  repeat drop  ;

( words-like )

  \ Credits:
  \ Code adapted from pForth.

need break-key?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

[defined] tab
  ?\  : tab  ( -- )  6 emit  ;

: words-like  ( "name" -- )
  \ Print all words (from the `context` vocabulary) containing a substring.
  parse-name 2dup uppers trail  ( ca len nfa )
  begin  dup 0<> break-key? 0= and  while
    dup >r
    nfa>string 2over contains if  r@ id. tab  then
    r> nfa>lfa @n
  repeat drop 2drop  ;

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the screen of the last error is shown insted

: where  ( -- )
  \ Print screen and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup b/scr / dup scr !
    ." Scr # " decimal . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s u.s )

  \ Credits:
  \ Code from Afera. Original algorithm from v.Forth.

: .depth  ( n -- )
  s>d <# [char] > hold #s [char] < hold #> type space  ;

: .s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ . -2 +loop  then  ;

: u.s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ u. -2 +loop  then  ;

( marker ) \ 2nd approach

  \ XXX TODO

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r
  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  set-order 0 do  2@ !  loop  ;

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".


( marker )

  \ XXX TODO

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ dp !  ;

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( assert( )

  \ Credits:
  \ Code from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?error ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

  \ }}} =======================================================
  \ Misc {{{

  \ XXX TODO -- move to other sections

( source )  \ ==misc==

: source  ( -- ca len )  \ Forth-94
  \ XXX TODO
  blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

( call )

code call  ( a -- )
  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next
  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

  \ }}} =======================================================
  \ Keyboard {{{

( xaccept )  \ ==keyboard==

  \ XXX TODO -- accept

  \ Credits:
  \ Code adapted from eForth.

  \ XXX TODO show cursor
  \
  \ XXX TODO compare with the kernel version and move the best
  \ version to the kernel (probably this one)

: xaccept ( ca len -- len )
  over + over ( bot eot cur )
  begin xkey dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;

( inkey )

  \ Credits:
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous screen works fine.
  \ Anyway this version is smaller and can be useful.

  di
  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  ei
  pusha jp

  end-code

( key?? )

  \ An alternative to `key?` that works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true cfa>pfa jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false cfa>pfa jp

  end-code

( key?? )

  \ An alternative to `key?` that works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true cfa>pfa jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false cfa>pfa jp

  end-code

  \ }}} =======================================================
  \ Hardware {{{

( @p )  \ ==hardware==

code @p  ( ca -- c )

  \ Input char _c_ from port _ca_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  C3 c, pushhl ,  \ jp pushhl
  end-code

( !p )

code !p  ( c ca -- )

  \ Output char _c_ to port _ca_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  End-code

  \ }}} =======================================================
  \ Turnkey {{{

( extend size system turnkey )  \ ==turnkey==

  \ XXX OLD
  \
  \ XXX WARNING -- Since name field addresses are saved in a
  \ memory bank, the best way to save a modified Forth system
  \ is to make a snapshot with the ZX Spectrum emulator;
  \ otherwise a multipart saving and loading would be needed.
  \ Anyway, these words are meant to save a Forth program, not
  \ the Forth system.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 22 +origin !  \ `fence` init value \ XXX OLD obsolete
  here 24 +origin !   \ `dp` init value
  \ XXX TODO -- update also the names pointer
  \ `voc-link` init value:
  [ ' forth cfa>pfa 8 + ] literal 26 +origin !  ;

  \ size  ( -- u )
  \
  \ Size of the system.

: size  ( -- u )  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.

: turnkey  ( cfa -- a len )  boot defer! system  ;

  \ }}} =======================================================
  \ Double numbers {{{

( du.r u.r du. )  \ ==doublenumbers==

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

: du.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;
\ : u.r  ( n1 n2 -- )  >r 0 r> du.r  ;
: du.  ( d -- )  0 du.r space  ;

( d- )

need z80-asm

  \ Credits:
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  pushhl jp
  end-code

  \ }}} =======================================================
  \ Number conversion and notation {{{

( >number )  ==numberconversion==

need /string

  \ Credits:
  \ Code from DZX-Forth.

  \ XXX TODO -- Move to the kernel.

: >number  ( d1 ca1 len1 -- d2 ca2 len2 )
  begin   dup
  while   over c@ base @ digit?
  while   >r 2swap r> swap base @ um* drop rot base @
          um* d+ 2swap 1 /string 1 dpl +!
  repeat then  ;

( number? )

  \ Credits:
  \ Code from DZX-Forth.

  \ XXX TODO -- adapt

  \ XXX FIXME -- it compiles (with compiler security off) but
  \ crashes

: number?  ( ca len -- d true | false )
  \ Convert a string to a double number.
  over c@ [char] - = over 0> and dup >r 1
  and /string over c@ [char] . > and 0 0
  2swap ?dup
  if
    >number dpl on dup
    if  1- over c@ [char] . - or  dpl off  then
    while
    then r> 2drop 2drop false
    else drop r> if  dnegate  then true
  then  ;

( b# d# h# )

  \ Credits:
  \ Code adapted from eForth.

  \ XXX TODO -- finish the conversion

: x# ( -- ) ( "ccc" -- n | d )
  does> c@              \  new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate

( c# )

: c#  ( "name" -- c )
  parse-name drop c@ postpone literal  ; immediate
  \ Parse a name and return the code of the its first
  \ character.
  \ Note: This word depends on the fig-Forth's `literal`.
  \ XXX TODO change when `literal` is updated.

( .b .d .h )

  \ Credits:
  \ Code copied from eForth and modified.

: base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

create bin.  ( n -- )   2 c, base.
create dec.  ( n -- )  10 c, base.
create hex.  ( n -- )  16 c, base.

( c>hex )

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex

: c>hex  ( c -- n )
  \ Convert a character to its hexadecimal value.
  30 - dup 9 > if  7 -  then  ;

decimal

( '. ) \ character prefix

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 1 width !

: '.  ( -- n )
  \ leave ascii character; example: 'a leaves 0x41
  here 2 + c@ postpone literal  ; immediate

width ! decimal

( $.. $.... ) \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

need c>hex

hex width @  1 width !

: $..  ( -- n )
  \ leave hex number; example: $0a leaves 0x0A
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: $....  ( -- n )
  \ leave 16-bit hex number; example: $0aff leaves 0x0AFF
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( 0x.. 0x.... )  \ hex prefixes

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

need c>hex

hex  width @ 2 width !

: 0x..  ( -- n )
  \ Leave hex number; example: 0x0A.
  here 3 + c@ c>hex 10 * here 4 + c@ c>hex +
  postpone literal  ; immediate

: 0x....  ( -- n )
  \ Leave hex number; example: 0x0AFF.
  0 here 7 + here 3 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( #... #..... ) \ hex prefixes

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Inspired by code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX TODO

need c>hex

width @  1 width !

: #...  ( -- n )
  \ leave decimal number
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: #.....  ( -- n )
  \ leave 16-bit decimal number
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width !

  \ }}} =======================================================
  \ Control structures {{{

( unless )

  \ Equivalent to `0= if`, but faster.

: unless  ( f -- )  postpone ?branch >mark 2  ; immediate

  \ XXX TODO Alternative for when compiler security is removed:
  \ : unless  ( f -- )  postpone ?branch >mark  ; immediate

( don't )  \ ==controlstructures==

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ;

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

( >l l> )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

  \ XXX TODO create the leave stack; create the leave stack
  \ pointer as a user variable

code >l  ( x -- ) ( L: -- x )
  \ Move to leave stack.
  de pop
  lp hl fthl
  e m ld  hl incp  d m ld  hl incp
  hl lp sthl
  jpnext
  end-code

code l>  ( -- x ) ( L: x -- )
  \ Move from leave stack.
  lp hl fthl
  hl decp  m d ld  hl decp  m e ld
  hl lp sthl
  pushhl jp
  next

( do )

  \ XXX TODO adapt from hForth
hex
 
: (do)  ( n1|u1 n2|u2 -- ) ( R: -- n1 n2-n1-0x8000 )
  >r 8000 + r> over - swap r> swap >r swap >r >r ;

  \ (do)  ( n1|u1 n2|u2 -- ) ( R: -- n1 n2-n1-0x8000 )
  \
  \ Run-time funtion of `do`.
  \
  \ 0x8000 is the maximum negative.

: do	  ( n1|u1 n2|u2 -- )
  ?comp  0 rakevar !  0			\ ?do-orig is 0 for do
  postpone (do)  here  bal+	\ do-dest
  ; immediate

  \ doc{
  \
  \ do
  \
  \ Compilation: ( C: -- do-sys )
  \
  \	Run-time: ( n1|u1 n2|u2 -- ) ( R: -- loop-sys )
  \
  \	Start a DO-LOOP structure in a colon definition. Place do-sys
  \	on control-flow stack, which will be resolved by `loop` or
  \	`+loop`.
  \
  \	Standard: Forth-94, Forth-2012
  \
  \	}doc

code (loop)  ( -- ) ( R: loop-sys1 -- | loop-sys2 )

    \ rp fthl
    \ m inc
    \ ; jr z,doloop2  ;12/7t a fast dec is ok, only
    \ db  doloop2-doloop1   ;      failed every 255 time
  \ doloop1   db  01ah  ; ld  a,(de)  ; 7t go back to the loop
    \ a l ld
    \ bc incp
    \ de ftap \ ld  a,(de)  ; 7t
    \ a h ld  \ db  067h  ; ld  h,a ; 4t
    \ next2 jp  \ $nexthl
 \ doloop2   db  023h  ; inc hl  ; 6t
    \ db  034h  ; inc (hl)  ;11t
    \ db  0e2h  ; jp po,doloop1 ;10/7t ?loop end
    \ dw  doloop1
    \ db  0ebh  ; ex  de,hl ; 4t yes,continue past the branch offset
    \ db  011h  ; ld  de,4  ;10t clear return stack
    \ dw  4
    \ db  0ddh,019h ; add ix,de ;15h
    \ db  023h  ; inc hl  ; 6t
    \ db  023h  ; inc hl  ; 6t
    \ next2 jp  \ $nexthl
    end-code

: loop  ?comp postpone (loop) rake  ; immediate

  \ loop
  \
  \ Compilation: ( C: do-sys -- )
  \ Run-time: ( -- ) ( R: loop-sys1 -- loop-sys2 )
  \ Terminate a DO|?DO ... LOOP structure. Resolve the destination
  \ of all unresolved occurences of LEAVE.
  \
  \ Standard: Forth-83, Forth-94, Forth-2012.

: +loop  ?comp postpone (+loop) rake  ; immediate

  \ +loop
  \
  \ Compilation: ( C: do-sys -- )
  \ Run-time: ( n -- ) ( R: loop-sys1 -- | loop-sys2 )
  \
  \ Terminate a `do +loop` structure. Resolve the destination of all
  \ unresolved occurences of `leave`.
  \ On execution add _n_ to the loop index. If loop index did not
  \ cross the boundary between loop_limit-1 and loop_limit,
  \ continue execution at the beginning of the loop. Otherwise,
  \ finish the loop.
  \
  \ Standard: Forth-83, Forth-94, Forth-2012.

( ?do )

  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ
  \ Draft by Rod Pemberton

  \ XXX TODO

: (do)  ( n1 n2 -- )  2>r  ;

: (?do) 2dup = if 2drop r> drop then  ;
  \ exit the calling word

: (loop)  ;
  ( increments index -2nd item- on return stack)
  ( calculates flag for until )

: (+loop)  ;

: do      postpone (do) postpone begin
  ; immediate

: ?do     postpone (?do) postpone (do) postpone begin
  ; immediate

: loop    postpone (loop) postpone until postpone unloop
  ; immediate

: +loop   postpone (+loop) postpone until postpone unloop
  ; immediate



  \ : unloop
  \   ( removes 2nd and 3rd return stack items )
  \   ( 1st return stack item is itc saved ip for unloop )  ;
  \ : i ( gets 2nd return stack item to data stack )  ;
  \ : j ( gets 4th ... )  ;
  \ : k ( gets 6th ... )  ;

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ Draft by Elisabeth Rather.

: do ( -- flag addr)
  postpone (do) 0   postpone begin ;   immediate

: ?do ( -- addr1 flag addr2)
    postpone (?do) postpone begin
    postpone (do) 1   postpone begin ;   immediate

  \ ...where (DO) and (?DO) are the run-time actions. (?DO)
  \ contains a forward branch which compile-time LOOP or +LOOP
  \ must resolve.    (BEGIN) leaves on the compile-time stack an
  \ address for LOOP or +LOOP to branch back to, and a flag.

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX TODO

variable ?do?

: exchange ( x1 addr -- x2 ) dup @ rot rot !  ;
: 2dup<> ( x1 x2 -- x1 x2 flag ) 2dup = 0=  ;

: do
  postpone 2>r 0 ?do? exchange here
  ; immediate
: ?do
  postpone 2dup<> postpone if postpone do ?do? on
  ; immediate
: loop
  postpone (loop) , ?do? exchange if postpone then then
  ; immediate
: +loop
  postpone (+loop) , ?do? exchange if postpone then then
  ; immediate

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX TODO

variable ?do?

: 2dup= ( x1 x2 -- x1 x2 flag ) 2dup =  ;

: do
  ?do? @ ?do? off [compile] (do) here 0 ,  ; immediate

: ?do
  postpone 2dup= postpone if postpone do ?do? on
  ; immediate

: complete-?do ( x dest | x -- )
  ?do? @ if postpone then then ?do? !  ;

: loop postpone (loop) , complete-?do  ; immediate

: +loop postpone (+loop) , complete-?do  ; immediate

( j )

code j
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 2 cells , \ ld de,2*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( k )

code k
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the third loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 4 cells , \ ld de,4*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( i' )

code i'  ( -- x )
         ( R: loop-sys -- loop-sys )

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,        \ ld hl,(return_stack_pointer)
  23 c,             \ inc hl
  23 c,             \ inc hl
  C3 c, fetchhl ,   \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 3 cells , \ ld de,3*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( for step )

  \ Credits:
  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch cfa>pfa ,
    \ jp nz,branch_pfa ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( u -- )
  \
  \ Start of a `for step` loop, that will iterate _u+1_ times,
  \ starting with _u_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `i`.a
  \
  \ }doc

: step  ( -- )  postpone (step) <resolve  ; immediate

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

( case )  \ Forth-94 version

  \ Credits:
  \ Code copied from the example provided in the Forth-94
  \ documentation.

0 constant case immediate  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( -- )
  \ XXX TODO use `?do` when available
  postpone drop  \ discard case value
  0 do  postpone then  loop  ; immediate

( case )  \ fig-Forth version with compiler security

  \ This is the fig-Forth `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, adapted and commented.
  \
  \ Note: this version only works when the compiler security
  \ check config option is activated in the kernel.

: case
  \ Compilation: ( -- a case-id )
  \ Runtime: ( x -- )
  ?comp csp @ !csp 4  ; immediate

: of
  \ Compilation: ( case-id -- of-id )
  \ Run-time: ( x -- )
  \ Note: `postpone 0branch >mark` is used instead of `postpone
  \ if` because `if` leaves its id on the stack when compiler
  \ security is activated.
  \ XXX TODO use `if` when compiler security is removed.
  4 ?pairs
  postpone over  postpone =  postpone 0branch >mark
  postpone drop 5  ; immediate

: endof
  \ Compilation: ( of-id -- case-id )
  \ Run-time: ( -- )
  5 ?pairs  postpone branch >mark
            swap 2  postpone then  4  ; immediate

: endcase
  \ Compilation: ( a orig1..orign case-id -- 3
  \ Run-time: ( x -- )
  4 ?pairs
  postpone drop
  begin  sp@ csp @ <>  while  2 postpone then  repeat
  csp !  ;  immediate

( case )  \ fig-Forth version without compiler security

  \ This is the fig-Forth `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (no compiler
  \ security checks) and commented.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( ?dov dov loopv +loopv )

  \ Credits:
  \ Code from v.Forth.

  \ XXX TODO adapt

: dov  compile (do) csp @ !csp here 3  ;

: ?dov
  compile 2dup  compile (do)  compile <>
  postpone if
  2drop here swap 1 6  ; immediate

: (resolve)
  begin  sp@ csp @ -  while  2 postpone then  repeat  csp !  ;

: loopv
  postpone loop (resolve)  ;

: +loopv
  postpone +loop (resolve)  ;

( case: )

: case:  ( -- )
  \ Create a positional case word.
  create  ]
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;
  \ A positional case statement.  At runtime, the n-th word is
  \ executed, depending upon the value on the stack. No error
  \ checking.

( test-case: )

  \ XXX TMP

need case:

: zx0 ." zero"  ;
: zx1 ." one"  ;
: zx2 ." two"  ;

case: zx  ( n -- )  zx0 zx1 zx2  ;

3 associative: unzx  ( value -- n )  ' zx0 , ' zx1 , ' zx2 ,

  \ }}} =======================================================
  \ Data structures {{{

( associative: )  \ ==datastructures==

  \ Credits:
  \ Code adapted from F83.

need -rot

: associative:  ( n -- )
  \ Create a table lookup word.
  \ n = number of entries in the table
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

( value )

  \ `value` with parsing and state-smart `to`

  \ This implementation conforms to Forth-94.
  \ Forth-94 explicitly requires that `to` must parse.

  \ Adapted from Afera.
  \ http://programandala.net/en.program.afera.html

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' cfa>pfa comp? if    postpone literal postpone !
                  else  !  then  ; immediate

( value )

  \ XXX TMP

  \ `value` with non-parsing `to` -- version with flag

  \ This non-parsing alternative implementation is adapted from
  \ lina: Copyright (c) 2000-2004 Albert van der Horst, The
  \ Netherlands

variable to-message
: from  ( -- )  to-message off  ;  from
: to    ( -- )  to-message on  ;
: value  ( n "name" -- )
  create ,  does>  to-message @ if  !  else  @  then  from  ;

( value )

  \ XXX TMP

  \ `value` with non-parsing `to` -- version with `execute`

  \ This non-parsing alternative implementation is a modified
  \ version of the lina implementation above.

variable (value)
: from  ( -- )  ['] @ (value) !  ;  from
: to    ( -- )  ['] ! (value) !  ;
: value  ( n "name" -- )
  create ,  does>   (value) @ execute  from  ;

( value )

  \ XXX TMP

  \ `value` with non-parsing `to` -- version with `defer`

  \ This non-parsing alternative implementation is a modified
  \ version of the lina implementation above.

defer (value)
: from  ( -- )  ['] @ ['] (value) defer!  ;  from
: to    ( -- )  ['] ! ['] (value) defer!  ;
: value  ( n "name" -- )
  create ,  does>  (value) from  ;

( set )

  \ From: Forth-83 (Appendix B. Uncontrolled Reference Words).

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

( user )

  \ XXX TODO -- improved version, that uses the first free
  \ offset.

  \ doc{
  \
  \ user  ( +n "name" -- )
  \
  \ Create a user variable _name_.  _+n_ is the offset within
  \ the user area where the value for _name_ is stored.
  \ Execution of _name_ leaves its absolute user area storage
  \ address.
  \
  \ Standard: Forth-79, Forth-83.
  \
  \ }doc

: user  ( n "name -- )
  create c,  does>  c@ up @ +  ;

;s

: user  ( n "name -- )
  cconstant
  ;code asm
  de incp  \ de=pfa
  exde
  m e ld
  00 d ld#  \ de = index of the user variable
  up fthl \ ld hl,(user_variables_pointer) \ XXX FIXME
  de addp  \ hl= address of the user variable
  pushhl jp end-asm

  \ }}} =======================================================
  \ Multitask {{{

( jiffy! jiffy@ -jiffy )

  \ Credits:
  \ Idea inspired by an article by Paul King, published in
  \ Format, vol. 2 no. 3 (1988-10).
  \ XXX TODO link to the WoS archive ftp, when available

need !dosvar  need @dosvar

: jiffy!  ( a -- )  16 !dosvar  ;
  \ Set the Z80 routine to be called by G+DOS after the OS
  \ interrupts routine, every 50th of a second.

: jiffy@  ( -- a )  16 @dosvar  ;
  \ Get the current Z80 routine that is called by G+DOS after
  \ the OS interrupts routine, every 50th of a second.

: -jiffy  ( -- )  8335 jiffy!  ;
  \ Deactivate the jiffy call, setting its default value
  \ (a noop routine in the RAM of the +D interface).

  \ }}} =======================================================
  \ Time {{{

( ms )  \ ==time==

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( n -- )
  \ Wait n ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth:
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( frames@ frames! frames0 )

[defined] sys-frames ?\ 23672 constant sys-frames

: frames@  ( -- d )
  sys-frames @ [ sys-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ sys-frames 2+ ] literal c! sys-frames !  ;
  \ Set the system frames counter.

: frames0  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-cfa  need execute-hl

code pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-cfa  hl pop  execute-hl
      \ execute the cfa hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-cfa

defer (wait)  ' noop ' (wait) defer!

code pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-cfa
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but it's current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) cfa>pfa fthl  execute-hl
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm

variable (wait)  ' noop (wait) !

code pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the cfa hold in `(wait)`:

    ' (wait) cfa>pfa fthl
    here 6 + bc ldp# \ point IP to phony_compiled_word
    next2 jp  \ execute the cfa in `(wait)`
    \ phony_compiled_word:
    here cell+ ,  \ point to the phony cfa following
    here cell+ ,  \ phony cfa, point to the code following

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `pause` has to be modified.

( just-pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u --- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ }}} =======================================================
  \ Vocabularies {{{

( .context .current order vocs )  \ ==vocabularies==

  \ Credits:
  \ Code adapted from F83.

: .context  ( -- )  context #vocs 0 do
  \ XXX FIXME
                      dup @ ?dup if  pfa>nfa id.  then  cell+
                    loop drop  ;
  \ Display the search order currently in effect.

: .current  ( -- )  current @ pfa>nfa id.  ;
  \ Display the name of the `current` vocabulary.

: order  ( -- )
  cr ." context: " .context cr ." current: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

: vocs  ( -- )
  voc-link @
  begin  dup cell - pfa>nfa id.  @ dup 0= until  drop  ;
  \ List all of the vocabularies that have been defined so
  \ far, in the order of their definition (more recent first).

( get-order set-order )

  \ XXX TODO use the actual number of vocs in context, not
  \ the maximum

: (get-order)  ( n -- widn..wid1 n)
  \ Do get the search order.
  1- -1 swap do  context i cells + @  -1 +loop  ;

: get-order  ( -- 0 | widn..wid1 n)
  \ Get the search order.
  #vocs ?dup if  (get-order)  then  #vocs  ;

: (set-order)  ( widn..wid1 n -- )
  \ Do set a search order.
  0 do  context i cells + !  loop  ;

: set-order  ( -1 | 0 | widn..wid1 n -- )
  \ Set a search order.
  dup -1 =  if  drop only exit  then  -order
  ?dup if  (set-order)  then  ;


  \ doc{
  \
  \ set-order  ( -1 | 0 | widn..wid1 n -- )
  \
  \ Set the search order to the word lists identified by
  \ _widn..wid1_. Subsequently, word list _wid1_ will be
  \ searched first, and word list _widn_ searched last. If _n_
  \ is zero, empty the search order. If _n_ is minus one, set
  \ the search order to the implementation-defined minimum
  \ search order.
  \
  \ This word is defined in Forth-94 but its implementation in
  \ Solo Forth is not fully Forth-94 compliant.
  \
  \ }doc

( wid-of )

  \ Credits:
  \ Code adapted from eForth's `widof`.

: wid-of  ( "name" -- wid )  ' cfa>pfa  ;

( search-wordlist )

: search-wordlist ( ca len wid -- 0 | xt 1 | xt -1 )
  >r 2dup uppers r>
  @ (find-name) dup ?exit  nip  ;

  \ doc{
  \
  \ search-wordlist  ( ca len wid -- 0 | cfa 1 | cfa -1 )
  \
  \ Find the definition identified by the string _ca len_ in
  \ the word list identified by _wid_. If the definition is not
  \ found, return zero. If the definition is found, return its
  \ _cfa_ and one (1) if the definition is immediate, minus-one
  \ (-1) otherwise.
  \
  \ The search is case-insensitive.
  \
  \ Standard: Forth-94, Forth-2012.
  \
  \ }doc

  \ }}} =======================================================
  \ Random number generators {{{

( seed rnd random randomize )  \ ==rng==

  \ Credits:
  \ Code adapted from Leo Brodie's code and Gforth.

[defined] seed ?\ 23670 constant seed  \ system variable

: rnd  ( -- n )  seed @ 31421 * 6927 + dup seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

: randomize  ( n -- )  seed !  ;

( random-b )

code random-b  ( -- b )
  \ XXX FIXME this returns patterns; see `random-b-test`
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

( ace-rnd )

  \ Credits:
  \ Adapted from ACE Forth, as of the Jupiter ACE manual.

[defined] seed        ?\ 23670 constant seed
[defined] sys-frames  ?\ 23672 constant sys-frames
  \ system variables

: seedon  ( -- n )
  \ XXX FIXME
  seed @ 75 um* d>s 75 0 d+ 2dup u< - - 1- dup seed !  ;

: rnd  ( n1 -- n2 )  seedon um* d>s swap drop  ;

: randomize  ( n -- )
  ?dup 0=  if  sys-frames @  then  seed !  ;

( v.Forth pseudo random number generator )

  \ Credits:
  \ Code from v.Forth.

  \ XXX TODO adapt and try

[defined] seed ?\ 23670 constant seed

  : vrnd  ( n1 -- n2 )
    1+ 8195 23672 @ um* 1 0 d+
    16383 u/ drop dup seed !
    swap mod  ;

( random-n )

  \ Credits:
  \ Adapted from code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

[defined] seed
?\ 23670 constant seed  \ system variable

code random-n  ( -- x )

  \ Return a random number (0000..FFFF)

  \ XXX FIXME this returns patterns; see `random-n-test`

  seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  seed sthl
  pushhl jp
  end-code

( z88random )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

[defined] seed
?\ 23670 constant seed  \ system variable

  \ XXX TODO adapt.
: z88random  ( u1 -- u2 )
  20077 16838 seed @
  ud* 12345 0 d+ over seed !
  rot ud/mod 2drop  ;

( random-test random-b-test random-n-test )

need set-pixel

need random

: random-test  ( n -- )
  cls  0 do  256 random 193 random set-pixel  loop  ;

need random-b

: random-b-test  ( n -- )
  cls  0 do  random-b random-b 192 min set-pixel  loop  ;

need random-n

: random-n-test  ( n -- )
  cls
  0 do  random-n 255 and
        random-n 255 and 192 umin set-pixel
  loop  ;

  \ }}} =======================================================
  \ Deferred words {{{

( defers action-of )  \ ==deferredwords==

  \ Credits:
  \ Code adapted from the Afera library.

: defers  ( "name" -- )  ' defer@ ,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.

: action-of  ( Interpretation: "name" -- cfa )
             ( Compilation:    "name" -- )
             ( Runtime:        -- cfa )
  ' comp? if    postpone literal postpone defer@
          else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.

( <is> [is] is  )

  \ Credits:
  \ Code adapted from the Afera library.

: <is>  ( cfa "name" -- )  ' defer!  ;

: [is]  ( cfa "name" -- )
  ' postpone literal postpone defer!  ; immediate

: is  ( cfa "name" -- )
  comp? if  postpone [is]  else  <is>  then  ; immediate

  \ }}} =======================================================
  \ Assembler {{{

( z80-asm )

\ Z80 assembler for Solo Forth

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).


  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?error  ;
  \ Branch too long?

-->

( z80-asm -- words for defining the z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- words for defining the z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- words for defining the z80 instructions)

need -rot

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm -- opcodes)

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook \ rst 0x08
D7 m1 prt  \ rst 0x16

-->

( z80-asm -- index register opcodes)

need -rot
[defined] 3dup
?\ : 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;

: again  (  dest cs-id -- )  18 until  ;  \ compile `jr`

: step    ( dest cs-id -- )  10 until  ;  \ compile `djnz`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

-->

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the compiler security that
  \ checks the stack is balanced at the end of the definition.

only forth definitions also assembler

: macro  ( "name" -- )  postpone : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( calc end-calc )

need z80-asm

current @  also assembler definitions

macro calc  ( -- )  exx EF c,  endm
  \ 0xEF = `rst 0x28`, call the ROM calculator

macro end-calc  ( -- )  38 c, exx  next ix ldp  endm
  \ 0x38 = ROM calculator `end-calc` command
  \
  \ XXX TODO It seems IX is not used by the calculator,
  \ so this code will work:
  \ macro end-calc  ( -- )  38 c, exx  endm

current !  previous

( << >> )

  \ For dumping assembled code to screen.

  \ Credits:
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?error cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

( execute-hl call-cfa )

  \ Assembler macros to call any Forth word from code words.

  \ Credits:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call a cfa hold in a
  \ variable. The code has been converted from DTC to ITC and
  \ factored to two assembler macros in order to make it
  \ reusable.

macro execute-hl  ( -- )
  \ Compile an `execute` with the cfa hold in HL.
  here 6 + bc ldp# \ point IP to phony_compiled_word
  next2 jp  \ execute the cfa in HL
  \ phony_compiled_word:
  here cell+ ,  \ point to the phony cfa following
  here cell+ ,  \ phony cfa, point to the code following
  endm

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `execute-hl` has to be modified.

macro call-cfa  ( cfa -- )
  \ Compile a call to _cfa_.
  \ This is the low-level equivalent of `execute`.
  hl ldp#  execute-hl
  endm

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test cfa>pfa 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test cfa>pfa dup here swap - dump

  \ }}} =======================================================
  \ Address register {{{

( a! a@ )  \ ==addressregister==

  \ Address register store and fetch words.

  \ Credits:
  \ Code adapted from Z88 CamelForth.

  \ Note by Gary Lancaster in the Z88 CamelForth source file:
  \ Sadly, there aren't any spare registers to make this as
  \ efficient as it could be. However, it can still give a
  \ useful improvement in loops, and in many cases also results
  \ in cleaner-looking code.

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,                 \ pop hl
  22 c, a ,             \ ld (a),hl
  jpnext                \ jp (ix)
  end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,             \ ld hl,(a)
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a @a )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,                          \ pop de
  2A c, a ,                      \ ld hl,(a)
  70 03 + c,  23 c,  70 04 + c,  \ ld (hl),e  inc hl  ld (hl),d
  jpnext                         \ jp (ix)
  end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,             \ ld hl,(a)
  5E c,                 \ ld e,(hl)
  23 c,                 \ inc hl
  66 c,                 \ ld h,(hl)
  68 03 + c,            \ ld l,e
  C3 c, pushhl ,        \ jp pushhl
  end-code

( c!a c@a )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  jpnext                \ jp (ix)
  end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a+ @a+ )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code @a+  ( -- u )      \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

( c!a+ c@a+ )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

  \ }}} =======================================================
  \ Common heap {{{

.( heap 0)

  \ An implementation of the Forth-94 Memory-Allocation Word
  \ Set.

  \ Adapted from code written by Gordon Charlton, 1994:
  \
  \ XXX TODO adapt

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, ALLOCATE, FREE,
  \ and RESIZE which give the minimum functionality required to
  \ use the heap. These are given in areas 3, 4 and 5
  \ respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant HEAPSIZE. The constant HYSTERESIS
  \ controls the amount of spare space that is added to an
  \ allocation, to reduce the need for block moves during
  \ resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

also forth definitions
vocabulary heap-voc  heap-voc definitions

  \ **1** General Purpose Extensions

: unique (  )  VARIABLE  ;

  \ Defining word. Each child returns a different non-zero
  \ number. The standard introduces the need for unique
  \ identifiers in the form of IORs and THROW codes, but
  \ provides no means for generating them. This does the trick.

0 1 2 UM/MOD NIP 1- CONSTANT maxpos

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  ---  Constants

256 CELLS CONSTANT heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 CELLS 1- CONSTANT hysteresis

  \ Node lengths are rounded up according to the value of
  \ HYSTERESIS to reduce the number of block moves during
  \ RESIZE operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

unique allocationerror

  \ Indicates there is less contiguous heap space available
  \ than required.

3 CELLS CONSTANT headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis OR  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize CONSTANT overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  ---  Structure

CREATE sentinel  HERE CELL+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

CREATE heap  heapsize ALLOT

  \ The heap is as described in HEADSIZE.

VARIABLE nextnode  -->

  \ Searching is done using a "nextfit" algorithm. NEXTNODE
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

.( heap 1)

: >size ( addr -- addr)  CELL+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr -- addr)  2 CELLS +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )  heap DUP nextnode !
  DUP DUP !
  DUP heapsize  OVER >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does NEXTNODE.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  ---  List Searching

: attach ( addr)
  >prev @  DUP sentinel ROT !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (addr) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >R BEGIN 2@ SWAP R@ < INVERT UNTIL
  R> DROP  >prev @  ;

  \ Search the nodelist, starting at the node specified (addr),
  \ for a free node larger than or equal to the specified size.
  \ Return the address of the first node that matches, or zero
  \ for no match. The heap structure is set up to make this a
  \ near optimal search loop. The "size" field is next to the
  \ "next" field so that both can be collected in a single
  \ operation (2@). Nodes in use have negated sizes so they
  \ never match the search. The "previous" field is included to
  \ allow the search to overshoot the match by one node and
  \ then link back outside the loop, rather than remembering
  \ the address of the node just examined. The sentinel removes
  \ the need for a separate test for failure. SEARCH assumes
  \ the sentinel is in place.

: detach ( addr)  DUP >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

.( heap 2)

: findspace ( size -- addr|0)  nextnode @
           DUP      attach
           DUP ROT  search
           SWAP     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ NEXTNODE, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  ---  Head Creation

: fits ( size addr -- flag)  >size @ SWAP -  overhead  <  ;

  \ Returns TRUE if the size of the node specified is the same
  \ as the specified size, or larger than it by less than the
  \ size of the smallest possible node. Returns FALSE
  \ otherwise.

: togglesize ( addr)  >size DUP @  NEGATE SWAP !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2DUP + >R  >size 2DUP @ SWAP -
  R@ >size !   SWAP NEGATE SWAP !  R>  ;

  \ Given a free node (addr), reduce its size to that specified
  \ and mark it as in use. Start to construct a new node within
  \ the specified node beyond its new length, by storing the
  \ length of the remainder of the node in the size field of
  \ the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2DUP SWAP @  2DUP  SWAP !  >prev !
  2DUP >prev !   SWAP !  ;


  \ Addr1 is an existing node. Addr2 is the address of a new
  \ node just above the existing node. Break the links from the
  \ existing node to the next node and from the next node to
  \ the existing node and join the new node to them.


  \ ANSI heap  ---  Node Construction  ALLOCATE

: newnode ( size addr)  TUCK sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

.( heap 3)

: makenode ( size addr)
  2DUP fits IF  togglesize DROP  ELSE  newnode  THEN  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

: set-current  ( wid -- )  current !  ; \ XXX TMP
FORTH-WORDLIST SET-CURRENT
: ALLOCATE ( u -- addr ior)
  DUP 0< IF  allocationerror
       ELSE  adjustsize
       DUP findspace
       DUP IF  DUP next!
         TUCK makenode
         headsize +  0
         ELSE  DROP allocationerror
         THEN
       THEN  ;
MEMORY-ALLOC-WORDLIST SET-CURRENT  -->

  \ Make an in-use node with a data field at least u address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and an ior equal to the
  \ constant ALLOCATIONERROR. The standard specifies that the
  \ argument to ALLOCATE is unsigned. As the implementation
  \ uses the sign bit of the size field for its own purposes
  \ any request for an amount of space greater than MAXPOS must
  \ fail. As this would be a request for half the addressable
  \ memory or more this is not unreasonable.

.( heap 4)

  \ **4** Releasing Space

  \ ANSI heap  ---  Head Destruction

: mergesizes ( addr addr)
  >size @ SWAP >size +!  ;

  \ Make the size field of the node at addr1 equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at addr2 will be the one immediately above addr1.

: mergelinks ( addr addr)
  @ 2DUP SWAP !  >prev !  ;

  \ The node at addr2 is removed from the node list. As with
  \ MERGESIZES the node at addr2 will be immediately above that
  \ at addr1. Destroy the link from node1 to node2 and relink
  \ node1 to the node above node2. Destroy the backward link
  \ from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that NEXTNODE may point to it. This is cured by making
  \ it point to the node prior to the one removed. We do not
  \ want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically NEXTNODE is set to point
  \ to the node pointed to by the "previous" field of the node
  \ pointed to in the "next" field of the node pointed to by
  \ NEXTNODE. Ordinarily this is a no-op (ie I am my father's
  \ son) but when the node has had its links merged it sets
  \ NEXTNODE to point to the node prior to the node it pointed
  \ to (ie when I died my father adopted my son, so now my son
  \ is my father's son).

: merge ( addr)
  DUP @ 2DUP mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  ---  Node Removal    FREE

: ?merge ( addr1 addr2)  >size @
  0> IF
    DUP DUP @
    U< IF  DUP merge  THEN
  THEN  DROP  ;  -->

  \ Merge the node at addr1 with the one above it on two
  \ conditions, firstly that the node at addr2 is free, and
  \ secondly that the node pointed to by the next field in
  \ addr1 is actually above addr1 (ie that it does not wrap
  \ around because it is the topmost node). In usage addr2 will
  \ be either addr1 or the node above it. In each instance the
  \ other affected node (either the node above addr1 or addr1)
  \ is known to be free, so no test is needed for this.

.( heap 5)

: ?mergenext ( addr)  DUP @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ DUP ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

FORTH-WORDLIST SET-CURRENT
: FREE ( addr -- ior)
  headsize -  DUP togglesize  DUP ?mergenext  ?mergeprev  0  ;

MEMORY-ALLOC-WORDLIST SET-CURRENT

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  ---  Node Repairing

VARIABLE stash

  \ The RESIZE algorithm is simplified and made faster by
  \ assuming that it will always succeed. STASH holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ Saves the contents of the >NEXT field of the node being
  \ RESIZEd in STASH (above).

: restorelink ( addr)  stash @  SWAP !  ;

  \ Converse operation to SAVELINK (above).

: fixprev ( addr)  DUP >prev @ !  ;

  \ The >NEXT field of the node prior to the node being RESIZEd
  \ should point to the node being RESIZEd. It may very well do
  \ already, but this makes sure.

: fixnext ( addr)  DUP @ >prev !  ;

  \ The >PREV field of the node after the node resized may need
  \ correcting.  This corrects it whether it needs it or not.
  \ (Its quicker just to do it than to check first.)

: fixlinks ( addr)  DUP fixprev  DUP fixnext  @ fixnext  ;

  \ RESIZE may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of JIGGLE (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

.( heap 6)

: fixsize ( addr)
  DUP >size @ 0>
  IF  DUP @  2DUP <
      IF    OVER - SWAP >size !  ELSE  2DROP  THEN
  ELSE  DROP  THEN  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the >NEXT field provided that
  \ the node is free and it is not the topmost node in the heap
  \ (ie there is no wraparound). Both these conditions need to
  \ be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  DUP fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to RESIZE (damaged by ?MERGENEXT)
  \ and its predecessor (damaged by ?MERGEPREV).

: repair ( addr)
  DUP restorelink
  DUP fixlinks  DUP fixsizes
  togglesize  ;

  \ Make good the damage done by RESIZE. Restore the >next
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer NEXTNODE may
  \ have moved back one or two nodes by virtue of having been
  \ JIGGLEd about if it happened to be pointing to the wrong
  \ node. This is not serious, so I have chosen to ignore it.


  \ ANSI Heap  ---  Node Movement

: toobig? ( addr size -- flag)
  SWAP  >size @  >  ;

  \ Flag is true if the node at addr is smaller than the
  \ specified size.

-->

.( heap 7)

: copynode ( addr1 addr2)
  OVER >size @  headsize -
  ROT  headsize + ROT ROT MOVE  ;

  \ Move the contents of the data field of the node at addr1 to
  \ the data field at addr2. Assumes addr2 is large enough. It
  \ will be.

: enlarge ( addr1 size -- addr2 ior)
  OVER  ?mergeprev
  ALLOCATE DUP >R
  IF  SWAP repair  ELSE  TUCK copynode  THEN  R>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of addr1 to the new node. Merge the node at addr1 with the
  \ one preceding it, if possible. This last behaviour is to
  \ finish off removing the node at addr1. The word ADJUST
  \ (below) starts removing the node. The node is removed
  \ before allocation to increase the probability of ALLOCATE
  \ succeeding. The address returned by ENLARGE is that
  \ returned by ALLOCATE, which is that of the data field, not
  \ the head. If the allocation fails repair the damage done by
  \ removing the node at addr1.


  \ ANSI Heap  ---  Node Restructuring  RESIZE

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >R
  headsize -
  DUP savelink
  DUP togglesize
  DUP ?mergenext R>  ;

  \ Addr1 points to the data field of a node, not the "next"
  \ field. This needs correcting. Size1 also needs adjusting as
  \ per ADJUSTSIZE. In addition it is easier to work with free
  \ nodes than live ones as the size field is correct, and, as
  \ we intend to change the nodes size we will inevitably want
  \ to muck about with the next node, if its free, so lets
  \ merge with it straight away. Sufficient information is
  \ first saved to put the heap back as it was, if necessary.
  \ Now we are ready to get down to business.

-->

.( heap 8)

FORTH-WORDLIST SET-CURRENT

: RESIZE ( addr1 u -- addr2 ior)
  DUP 0<  IF  DROP allocationerror
          ELSE  adjust  2DUP toobig?
                IF enlarge
                ELSE  OVER makenode headsize +  0  THEN
          THEN  ;

  \ Resize the node at addr1 to the specified size. Return the
  \ address of the resized node (addr2) along with an ior of
  \ zero if successful and ALLOCATIONERROR if not. Addr2 may be
  \ the same as, or different to, addr1.  If ior is non-zero
  \ then addr2 is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using MAKENODE, which
  \ has just the right functionality. In this case the ior is
  \ zero. As this is a standard word it takes an unsigned size
  \ argument, but excessive requests fail automatically, as
  \ with ALLOCATE.

  \ }}} =======================================================
  \ Floating point after Spectrum Forth-83 {{{

  \ XXX TODO

  \ }}} =======================================================
  \ Floating point using the ROM calculator {{{

  \ XXX TODO

  \ The ROM calculator is used to implement most words of the
  \ Forth-2012 FLOATING and FLOATING EXT word sets, and some
  \ words not provided by Forth-2012.

  \ XXX FIXME -- The ROM calculator calls the BASIC error
  \ routines, what crashes the system.

( fp-load )

need +thru
1 9 +thru

( float float+ floats s>f f>s )

5 constant float  : float+  ( n1 -- n2 )  float +  ;
                  : floats  ( n1 -- n2 )  float *  ;

need z80-asm  s"  calc " needed

code s>f  ( n -- ) ( F: -- r )
  exx  bc pop  2D2B call  exx  jpnext  end-code

code f>s  ( -- n ) ( F: r -- )
  exx  2DA2 call  bc push  exx  jpnext  end-code

code f>d  ( -- d ) ( F: r -- )
  end-code

( fvariable )

: fvariable  ( "name" -- )  create  float allot  ;

: f!  ( a -- ) ( F: r -- )  ;
  \ XXX TODO

: f,  ( -- )  here float allot f!  ;

: fconstant  ( "name" -- )  ( F: f -- )  create  f,  does>  ;
  \ XXX TODO

( f** f+ f- f/ )

  \ Operators

need z80-asm  s"  calc " needed

code f**  ( F: r1 -- r2 )
  calc 06 c, end-calc jpnext  end-code
code f+  ( F: r1 r2 -- r3 )
  calc 0F c, end-calc jpnext  end-code
code f-  ( F: r1 r2 -- r3 )
  calc 03 c, end-calc jpnext  end-code
code f/  ( F: r1 r2 -- r3 )
  calc 05 c, end-calc jpnext  end-code

 \ code fmax  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code
 \ code fmin  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code

code fsign  ( F: r1 -- r2 )
  calc 29 c, end-calc jpnext  end-code

( fabs fexp fln fmod fnegate fsqrt )

  \ Operators

need z80-asm  s"  calc " needed

code fabs  ( F: r1 -- r2 )
  calc 2A c, end-calc jpnext  end-code
code fexp  ( F: r1 -- r2 )
  calc 26 c, end-calc jpnext  end-code
code fmod  ( F: r1 -- r2 )
  calc 32 c, end-calc jpnext  end-code
code fnegate  ( F: r1 -- r2 )
  calc 1B c, end-calc jpnext  end-code

code fln  ( F: r1 -- r2 )
  calc 25 c, end-calc jpnext  end-code
code fsqrt  ( F: r1 -- r2 )
  calc 28 c, end-calc jpnext  end-code

code fround  ( F: r1 -- r2 )
  calc 3A c, end-calc jpnext  end-code

( f0 f1 fhalf fpi2/ f10 )

  \ Constants

need z80-asm  s"  calc " needed

code f0  ( F: -- r1 )
  calc A0 c, end-calc jpnext  end-code
code f1  ( F: -- r1 )
  calc A1 c, end-calc jpnext  end-code
code fhalf  ( F: -- r1 )
  calc A2 c, end-calc jpnext  end-code
code fpi2/  ( F: -- r1 )
  calc A3 c, end-calc jpnext  end-code
code f10  ( F: -- r1 )
  calc A4 c, end-calc jpnext  end-code

( jp-f>s )

need z80-asm  s"  f>s " needed

  \ XXX TODO -- optimize; `f>s` has another pair of `exx`. A
  \ specific word will be faster and smaller, instead of
  \ `end-calc jp-f>s`.

  \ XXX FIXME -- `macro` is not recognized here.

macro jp-f>s  ( -- )
  ['] f>s call-cfa
  endm

( f0< f0= f< f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm  s"  calc " needed  need jp-f>s

code f0<  ( F: r1 -- rwf )
  calc 36 c, 1B c, end-calc jp-f>s  end-code

code f0=  ( F: r1 -- rwf )
  calc 30 c, 1B c, end-calc jp-f>s  end-code

code f0<>  ( F: r1 -- rwf )
  calc 30 c, 30 c, 1B c, end-calc jp-f>s  end-code

code f<  ( F: r1 r2 -- rwf )
  calc 0D c, 1B c, end-calc jp-f>s  end-code

  \ code f~ \ XXX TODO

( f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm

code f<=  ( F: r1 r2 -- rwf )
  calc 09 c, 1B c, end-calc jp-f>s  end-code

code f<>  ( F: r1 r2 -- rwf )
  calc 0B c, 1B c, end-calc jp-f>s  end-code

code f=  ( F: r1 r2 -- rwf )
  calc 0E c, 1B c, end-calc jp-f>s  end-code

code f>  ( F: r1 r2 -- rwf )
  calc 0C c, 1B c, end-calc jp-f>s  end-code

code f>=  ( F: r1 r2 -- rwf )
  calc 0A c, 1B c, end-calc jp-f>s  end-code

( fdrop fdup fswap fover frot )

  \ Stack

need z80-asm  need float  s"  calc " needed

23651 constant fp0  23653 constant fp  : fp@  ( -- a )  fp @  ;
  \ 23651 = STKBOT system variable
  \ 23653 = STKEND system variable

: fdepth  ( -- n )  fp@ fp0 @ - float /  ;

code fdrop  ( F: r1 -- )
  calc 02 c, end-calc jpnext  end-code

code fdup  ( F: r1 -- r1 r1 )
  calc 31 c, end-calc jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calc 01 c, end-calc jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calc C2 c, C1 c, E1 c, E2 c, E1 c, end-calc jpnext  end-code

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calc C3 c, C2 c, C1 c, E2 c, E3 c, E1 c, end-calc
  jpnext  end-code

( facos fasin fatan fcos fsin ftan )

  \ Trigonometrical functions

need z80-asm  s"  calc " needed

code facos  ( F: r1 -- r2 )
  calc 23 c, end-calc jpnext  end-code
code fasin  ( F: r1 -- r2 )
  calc 22 c, end-calc jpnext  end-code
code fatan  ( F: r1 -- r2 )
  calc 24 c, end-calc jpnext  end-code
code fcos  ( F: r1 -- r2 )
  calc 20 c, end-calc jpnext  end-code
code fsin  ( F: r1 -- r2 )
  calc 1F c, end-calc jpnext  end-code
code ftan  ( F: r1 -- r2 )
  calc 21 c, end-calc jpnext  end-code

  \ }}} =======================================================
  \ Editor {{{

( editor )

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum. It has been
  \ modified in order to adapt it to Solo Forth.
  \
  \ Descriptions and stack comments have been added after the
  \ Specforth manual, the Abersoft Forth manual and the book
  \ _Systems Guide to fig-Forth_. The word `copy` has been
  \ adapted from Abersoft Forth. The word `text` has been
  \ rewritten.

  \ Credits:
  \ Specforth Editor V1.1
  \ Copyright 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983
  \ Modified by Marcos Cruz, 2015

only forth definitions

need list  need update  need flush
need command

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "text<c>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "text<eol>" -- )
  pad c/l 1+ blank  command  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?error scr @ (line) drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current screen buffer.  The screen number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the screen buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current screen.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type [char] _ emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current screen.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "text<eol>"  -- )  text r  ;
  \ Put "text" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the screen.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear screen _n_ with blanks and select for editing.

: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= exhaust  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- tf n3 | ff n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 exhaust  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_ If found leaves _n3_ bytes until the end
  \ of the matching string, else leaves _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 error  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of screen.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the screen.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "text<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "text" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the screen.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "text<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "text".

: till  ( "text<eol>" -- )
  #lead + text 1line 0= #-270 ?error
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "text".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "text<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "text" to the cursor line at the cursor position.

also forth
: copy  ( n1 n2 -- )
  b/scr * swap b/scr * b/scr over + swap
  do
    dup i block 2- ! 1+ update
  loop  drop flush  ;  previous
  \ Copy screen _n1_ to screen _n2_.

only forth definitions decimal

  \ }}} =======================================================
  \ Sample game: Siderator 2 {{{

.( siderator )

  \ XXX TODO

\ Siderator
\ A game for the ZX Spectrum

\ Copyright (C) 2009,2010,2013,2015 Marcos Cruz
\ (programandala.net)

  \ History

  \ 2015-09-02: Start, with the code of the Jupiter ACE
  \ version: http://programandala.net/en.program.siderator.html

  \ Known bugs (or special features)

  \ The craft's autodestruction creates a new star.

only forth definitions

need rnd  need udg:  need inkey  need break-key?

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

vocabulary siderator
also siderator definitions  decimal

-->

( siderator )

  \ Game variables and constants:

variable x          variable speed
variable parsecs    variable record  record off

999 constant max-speed
char 5 constant left-key  char 8 constant right-key

  \ System variables and addresses:

8192 constant 'screen \ XXX OLD

  \ Common words:

: at  ( line col -- )  swap at-xy  ;
: pause  ( -- )  begin  inkey  until  ;  -->

( siderator )

  \ Graphics

15360 constant charset  \ ROM charset
: char>a  ( c -- a )  8 * charset +  ;
: udg>a  ( c -- a )  128 - 8 * udg +  ;
: char>udg  ( c0 c1 -- )  swap char>a swap udg>a 8 cmove  ;

128 constant star0-udg  char * star0-udg char>udg

binary
00011000
00001000
00011000
00010000
00011000
00001000
00011000
00010000 decimal 129 udg: star1-udg  -->

( siderator )

130 constant star2-udg
char | star2-udg char>udg

binary
00001000
00000000
00001000
00000000
00001000
00000000
00001000
00000000 decimal 131 udg: star3-udg  -->

( siderator )

binary
10000001
10000001
11000011
11100111
11111111
01100110
00111100
00011000 decimal 132 udg: craft-udg  -->

( siderator )

  \ Keyboard

: pressed?  ( c -- f )  inkey =  ;
: left  ( col -- col' )  left-key pressed? + 0 max  ;
: right  ( col -- col' )  right-key pressed? - 31 min  ;
: rudder  ( -- )  x @ right left x !  ;

-->

( siderator )

need between

  \ Stars

4 constant #stars
: star-coords  ( -- y x )  23 31  ;
: .star  ( c -- )
  star-coords 1+ random at 1 bright emit 0 bright  ;
: stars/speed  ( -- n )  speed @ #stars 1- max-speed */ 1+  ;
: scroll  ( -- )  star-coords at cr cr  ;
: .stars  ( -- )
  stars/speed dup [ star0-udg 1- ] literal + swap 0
  do  dup .star  loop  drop  ;
: star=  ( c -- f )  star0-udg star3-udg between  ;
: star<>  ( c -- f )  star= 0=  ;

-->

( siderator )

  \ Craft

: craft-coords  ( -- y x )  10 x @  ;
: craft-at  ( -- )  craft-coords at  ;
: -craft  ( -- )  craft-at space  ;
: .craft  ( -- )  craft-at craft-udg 5 ink emit 7 ink  ;

-->

( siderator )

  \ Speed, parsecs, record

: .datum  ( u -- ) 0 <# # # # #> type space  ;
: delay  ( -- )  max-speed speed @ - 2 / 0  do  loop  ;
: .speed  ( -- )  ." Speed:" speed @ .datum  ;
: +speed  ( u1 -- u2 )
  dup 10 / 1 max  parsecs @ 4 mod 0= abs *  + max-speed min  ;
: faster  ( -- )  speed @ +speed speed !  ;
: .parsecs  ( -- )  ." Parsecs:" parsecs @ .datum  ;
: farther  ( -- )  parsecs @ 1+ parsecs !  ;
: .record  ( -- )  ." Record:" record @ .datum  ;
: .info  ( -- )  0 dup at .speed .parsecs .record  ;

-->

( siderator )

  \ End

need j  need ocr

: blast-delay  ( -- )  32 0  do  loop  ;
: (blast)  ( -- )
  .craft blast-delay craft-at star0-udg emit blast-delay  ;
: blast  ( -- )  256 0  do  (blast)  loop  ;

: halt  ( -- )
  32 0  do  24 0 do
    i j ocr star= if  i j at-xy  star0-udg emit  then
  loop  loop  ;
  \ XXX TODO

-->

( siderator )

: safe?  ( -- f )  craft-coords swap ocr star<>  ;
: continue?  ( -- f )  safe? break-key? 0= and  ;
: new-record  ( -- )
  parsecs @ record @ >  if  parsecs @ record !  then  ;
: game-over  ( -- )
  blast halt  11 dup at ." GAME OVER"
  new-record .info 22 0 at  colors0  ;

-->

( siderator )

\ Instructions

: about  ( -- )
  cr ." Siderator 2: Jugdement Day"  cr
  cr ." Copyright (C) Marcos Cruz"
  cr ." (programandala.net)"
  cr ." Version: 2015-09-02"  ;

: objective  ( -- )
  cr ." Your objective is to travel as"
  cr ." much parsecs as possible"
  cr ." while dodging the stars."
  cr ." Anyway you're supposed to die"
  cr ." before the 1000th parsec"
  cr ." because four digits would ruin"
  cr ." the score panel."  ;

-->

( siderator )

\ Instructions

: keys  ( -- )
  cr ." Rudder keys: "
  left-key emit space right-key emit
  cr ." Autodestruction key: Break"  ;

: instructions  ( -- )  objective cr keys  ;

: wait  ( -- )  cr cr ." Press any key to start." pause  ;

-->

( siderator )

  \ Init

need frames@

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;

: init-screen  ( -- )
  init-colors cls about cr instructions wait cls  ;

: 4+-  ( n1 -- n2 )  9 random 4 - +  ;

: init  ( -- )
  frames@ s>d randomize  udg-ocr
  init-screen  15 4+- x ! parsecs off  speed off  ;

-->

( siderator )

  \ Main

: run ( -- )
  init
  begin   -craft scroll  faster farther .info  continue?
  while   rudder .craft .stars  delay
  repeat  game-over  ;

  \ vim: filetype=soloforth
