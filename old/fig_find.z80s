
; doc{
;
; (find)  ( ca nfa --- pfa b tf | ff )
;
; }doc

  ; XXX Note: this version uses the new format name field, but
  ; works the same way the fig-Forth `find`.

  ld (ip_backup),bc ; save Forth IP
  pop de ; nfa
  pop hl ; string address
  ld (paren_find.string_address),hl
paren_find.begin:
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; name field length byte
  ld c,a    ; save for later
  and max_word_length_bit_mask  ; actual length
  cp (hl)
  jr nz,paren_find.not_a_match ; lengths differ
  ; Lengths match.
  ld a,c ; name field length byte
  and max_word_length_bit_mask  ; actual length
  ld b,a
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl)
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; de = address of the last char of the name field
  ; c = name field length byte
  ld hl,5 ; offset from lfa-1 to pfa
  add hl,de
  push hl ; pfa
  ld e,c ; length byte
  ld d,0
  ld hl,true
  ld bc,(ip_backup) ; restore Forth IP
  jp push_de_hl

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  ld a,c ; length byte
  and max_word_length_bit_mask  ; actual length
  ld c,a ; actual length
  inc c ; plus the length byte
  ld b,0
  add hl,bc ; hl = lfa
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e ; end of dictionary?
  jp nz,paren_find.begin ; if not, continue

  ; No match found, return.
  ld bc,(ip_backup) ; restore Forth IP
  jp false_pfa

  _colon_header right_bracket_,']'

if fig_find?

  ; Note: Setting `state` to 0xC0 for "compiling state" will force
  ; non-immediate words to be compiled and immediate words to be executed. See
  ; note in `interpret` for more details.

  _number 0xC0
  dw state_,store_

else

  dw state_,on_

endif
  dw semicolon_s_

; ----------------------------------------------
if fig_find?

  _colon_header context_find_,'CONTEXT-FIND'

; doc{
;
; context-find  ( "name" -- pfa b tf | ff )
;
; Accept the next text word (delimited by blanks) in the input stream to
; `here`, and search the `context` vocabulary for a matching entry.  If found,
; leave the dictionary entry's parameter field address, its length byte, and a
; boolean true.  Otherwise, leave only a boolean false.
;
; }doc

  ; XXX TODO -- return cfa instead of pfa
  dw b_l_,word_
  dw here_,count_,uppers_
  dw here_,context_,fetch_,fetch_
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  dw paren_find_
  ;dw to_r_,to_r_,dup_,dot_,from_r_,dup_,dot_,from_r_,dup_,dot_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  dw semicolon_s_
endif

; ----------------------------------------------
  _colon_header defined_question_,'DEFINED?'

; defined?  ( ca len -- wf )
if fig_find?

  ; XXX TODO -- not finished
  dw context_find_,dup_
  dw zero_branch_,defined_question.end
  dw two_drop_
defined_question.end:
  dw semicolon_s_

else

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; undefined?  ( ca len -- wf )

if fig_find?

  ; XXX TODO -- not finished
  dw defined_question_,zero_equals_
  dw semicolon_s_

else

  dw defined_question_,zero_equals_
  dw semicolon_s_

endif

; ----------------------------------------------
if fig_find? ; XXX OLD

  _colon_header find_,'FIND'

; doc{
;
; find  ( "name" --- pfa b tf | ff )
;
; Accept the next text word (delimited by blanks) in the input
; stream to `here`, and search the `context` and then `current`
; vocabularies for a matching entry.  If found, leave the
; dictionary entry's parameter field address, its length byte,
; and a boolean true.  Otherwise, leave only a boolean false.
;
; }doc

  ; XXX TODO -- return cfa instead of pfa
  dw context_find_,question_dup_
  ; XXX TODO -- optimize with `?exit' here instead of a branch
  dw question_branch_,find.end
  ; The word was not found in the context vocabulary,
  ; try again in the current vocabulary.
  ; XXX TODO -- remove this?
  dw here_,latest_,paren_find_
find.end:
  dw semicolon_s_


; ----------------------------------------------
  _colon_header header_,'HEADER'

; header  ( "name" -- )

  ; XXX NEW
  ; XXX TMP -- this is a copy of the original `create`.
  ; XXX TODO -- accept an xt as parameter?

  if fig_find? ; XXX OLD

    dw find_ ; ( pfa b tf | ff )
    dw zero_branch_,header.continue
    ; The word is not unique.
    dw drop_,pfa_to_nfa_

  else ; XXX NEW

    dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
    dw abs_,star_,question_dup_ ; ( 0 | cfa cfa )
    dw zero_branch_,header.continue
    ; The word is not unique.
    dw cfa_to_nfa_

  endif

  dw id_dot_
  _message not_unique_error
header.continue:

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE]',immediate

if fig_find?
  dw find_,zero_equals_
  _question_error not_found_error
  dw drop_,pfa_to_cfa_,comma_
else
  dw tick_,comma_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'


; XXX TODO -- In order to change the behaviour of `literal`, `2literal`
; and `cliteral` (make them give an error in interpretation mode),
; `interpret` must be modified.

if fig_find?

; doc{
;
; interpret  ( -- )  \ fig-Forth
;
; The outer text interpreter which sequentially executes or
; compiles text from the input stream (terminal or disk)
; depending on `state`. if the word name cannot be found after a
; search of `context` and then `current` it is converted to a
; number according to the current `base`.  That also failing, an
; error message echoing the name with a "?" will be given.
;
; }doc

interpret.begin:
  dw find_ ; found?
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  dw zero_branch_,interpret.word_not_found ; if

  ; Note:
  ;
  ; `state` holds 0xC0 when compiling.  The text interpreter
  ; compares the value stored in `state` with the value in the
  ; length byte of the definition found in the dictionary.  If
  ; the definition is an immediate word, its length byte is
  ; greater than 0xC0 because of the precedence and the sign
  ; bits are both set.  Setting `state` to 0xC0 will force
  ; non-immediate words to be compiled and immediate words to be
  ; executed.

  dw state_,fetch_,less_than_ ; compile the word?
  dw zero_branch_,interpret.execute_the_word ; if
  dw pfa_to_cfa_,comma_ ; compile the word
  dw branch_,interpret.word_done
interpret.execute_the_word: ; else
  dw pfa_to_cfa_
  dw execute_
interpret.word_done: ; then
  ;dw lit_,1,border_ ; XXX INFORMER
  dw question_stack_
  dw branch_,interpret.again
interpret.word_not_found: ; else
  ; word not found, try to convert the text to a number
  dw here_,number_
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number ; if
  ; decimal point detected, so it's a double, 32-bit, number
  dw two_literal_
  dw branch_,interpret.number_done
interpret.16bit_number: ; else
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
interpret.number_done: ; then
  ;dw lit_,2,border_ ; XXX INFORMER
  dw question_stack_

interpret.again:
  dw branch_,interpret.begin

else ; XXX NEW -- version with modern `find`

; ----------------------------------------------
  _colon_header tick_,"'"

if fig_find?
  dw find_
  dw zero_equals_
  _question_error not_found_error
  ; XXX TODO -- after modifying `(find)`, `pfa>cfa` will be unnecessary
  dw drop_,pfa_to_cfa_
else
  dw defined_,question_defined_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

if fig_find?
  dw find_,dup_
  dw zero_branch_,bracket_defined.end
  dw nip_,nip_
bracket_defined.end:
else
  dw defined_,nip_
endif
  dw semicolon_s_

