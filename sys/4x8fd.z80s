; 4x8 FONT DRIVER
; (c) 2007, 2011 Andrew Owen
; optimized by Crisis (to 602 bytes)
; http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

; -----------------------------
; Modified by Marcos Cruz in order to integrate the code into
; Solo Forth
; (http://programandala.net/en.program.solo_forth.html):

; 2015-09-08: Removed the channels stuff. That will be done in
; Forth. First changes to add the left control char.
;
; 2015-09-10: Added left control char. Exchanged column and row
; to suit the Forth convention. Added scroll. Separated the
; font from the code; now the system variable CHARS is used to
; point to the font.
;
; 2015-09-11: Modified some labels and comments.
; -----------------------------

rom_cl_all:  equ 0x0dfe
sys_chars:   equ 23606 ; (2) 256 less than address of character set

original_font: equ 0 ; flag

        org     60000

print_character:

        ; Based on code by Tony Samuels from Your Spectrum issue 13, April 85.

        ; A = character

        ld      b, a            ; save character
        ld      a, (at_flag)    ; value of AT flag
        and     a               ; test against zero
        jr      nz, getcol      ; jump if not
        ld      a, b            ; restore character

check_at:
        cp      0x16            ; test for AT
        jr      nz, check_cr    ; if not test for CR
        ld      a,0xFF          ; next character will be column
save_at_flag_and_exit:
        ld      (at_flag), a
        ret

getcol:
        cp      0xfe            ; test AT flag
        jr      z, getrow       ; jump if setting row
        ld      a, b            ; restore character
        cp      64              ; greater than 63?
        jr      c, valid_col
        ld      a,63            ; maximum
valid_col:
        ld      (col), a        ; store it in col
        ld      hl, at_flag     ; AT flag
        dec     (hl)            ; next character will be row
        ret

getrow:
        ld      a, b            ; restore character
        cp      24              ; greater than 23?
        jr      c,valid_row
        ld      a, 23           ; maximum
valid_row:
        ld      (row), a        ; store it in row
        xor     a               ; set a to zero
        jr      save_at_flag_and_exit

check_cr:
        cp      0x0D            ; carriage return?
        jr      z, do_cr        ; if so, jump
        cp      0x08            ; cursor left?
        jr      z, do_left      ; if so, jump
        call    print_printable_character
        ld      hl, col         ; increment
        inc     (hl)            ; the column
        ld      a, (hl)         ; get it
        cp      64              ; column 64?
        ret     nz              ; return if not

do_cr:
        xor     a               ; set A to zero
        ld      (col), a        ; reset column
        ld      a, (row)        ; get the row
        cp      23              ; row 23?
        jp      z,rom_cl_all    ; if so, scroll
        inc     a               ; increment the row
        ld      (row), a        ; write it back
        ret

do_left:
        ld      a, (col)        ; get the column
        and     a               ; is it zero?
        jr      nz,do_left.same_line
        ; the column is zero
        ld      a, (row)        ; get the row
        and     a               ; is it zero?
        ret z                   ; if so, return
        ; the column is zero
        ; the row is not zero
        dec     a
        ld      (row),a
        ld      a,64            ; last column
do_left.same_line:
        dec     a
        ld      (col),a
        ret

print_printable_character:

        ; A = printable char

        rra                     ; divide by two with remainder in carry flag
        ld      l, a            ; char to low byte of HL
        ld      a, 0            ; don't touch carry flag
        ld      h, a            ; clear H
        ex      af, af'         ; save the carry flag
        ld      d, h            ; store HL in DE
        ld      e, l            ; without using the stack
        add     hl, hl          ; multiply
        add     hl, hl          ; by
        add     hl, hl          ; eight
        sbc     hl, de          ; subtract DE to get original x7

; calculate address of first byte of character map in font

if original_font

        ld      de, font - 0x71 ; offset to FONT
        add     hl, de

else

        ld      de,(sys_chars)
        add     hl,de
        ld      de,0x0071
        and     a               ; reset carry flag
        sbc     hl,de

endif

        ; HL holds address of first byte of character map in font
        push    hl              ; save font address

; convert the row to the base screen address

        ld      a, (row)        ; get the row
        ld      b, a            ; save it
        and     %00011000       ; mask off bit 3-4
        ld      d, a            ; store high byte of offset in D
        ld      a, b            ; retrieve it
        and     %00000111       ; mask off bit 0-2
        rlca                    ; shift
        rlca                    ; five
        rlca                    ; bits
        rlca                    ; to the
        rlca                    ; left
        ld      e, a            ; store low byte of offset in E

; add the column

        ld      a, (col)        ; get the column
        rra                     ; divide by two with remainder in carry
                                ; flag
        push    af              ; store the carry flag
        ld      h, 0x40         ; base location
        ld      l, a            ; plus column offset
        add     hl, de          ; add the offset
        ex      de, hl          ; put the result back in DE

; HL now points to the location of the first byte of char data in FONT
; DE points to the first byte of the screen address
; C holds the offset to the routine

        pop     af              ; restore column carry flag
        pop     hl              ; restore the font address
        ld      b, 8            ; 8 bytes to write
        jr      nc, odd_col     ; jump if odd column

even_col:
        ex      af, af'         ; restore char position carry flag
        jr      c, l_on_l       ; left char on left col
        jr      r_on_l          ; right char on left col

odd_col:
        ex      af, af'         ; restore char position carry flag
        jr      nc, r_on_r      ; right char on right col
        jr      l_on_r          ; left char on right col

; WRITE A CHARACTER TO THE SCREEN
; There are four separate routines
; HL points to the first byte of a character in the font
; DE points to the first byte of the screen address

; left nibble on left hand side

ll_lp:
        ld      a, (hl)         ; get byte of font

l_on_l:
        and     %00001111       ; mask area used by new character
        ld      c, a            ; store in c
        ld      a, (de)         ; read byte at destination
        and     %11110000       ; mask off unused half
        or      c               ; combine with background
        ld      (de), a         ; write it back
        inc     d               ; point to next screen location
        inc     hl              ; point to next font data
        djnz    ll_lp           ; loop 8 times
        ret

; right nibble on right hand side

rr_lp:
        ld      a, (hl)         ; read byte at destination

r_on_r:
        and     %11110000       ; mask area used by new character
        ld      c, a            ; store in c
        ld      a, (de)         ; get byte of font
        and     %00001111       ; mask off unused half
        or      c               ; combine with background
        ld      (de), a         ; write it back
        inc     d               ; point to next screen location
        inc     hl              ; point to next font data
        djnz    rr_lp           ; loop 8 times
        ret

; left nibble on right hand side

lr_lp:
        ld      a, (hl)         ; read byte at destination
        rrca                    ; shift right
        rrca                    ; four bits
        rrca                    ; leaving 7-4
        rrca                    ; empty

l_on_r:
        and     %11110000       ; mask area used by new character
        ld      c, a            ; store in c
        ld      a, (de)         ; get byte of font
        and     %00001111       ; mask off unused half
        or      c               ; combine with background
        ld      (de), a         ; write it back
        inc     d               ; point to next screen location
        inc     hl              ; point to next font data
        djnz    lr_lp           ; loop 8 times
        ret

; right nibble on left hand side

rl_lp:
        ld      a, (hl)         ; read byte at destination
        rlca                    ; shift left
        rlca                    ; four bits
        rlca                    ; leaving 3-0
        rlca                    ; empty

r_on_l:
        and     %00001111       ; mask area used by new character
        ld      c, a            ; store in c
        ld      a, (de)         ; get byte of font
        and     %11110000       ; mask off unused half
        or      c               ; combine with background
        ld      (de), a         ; write it back
        inc     d               ; point to next screen location
        inc     hl              ; point to next font data
        djnz    rl_lp           ; loop 8 times
        ret

; TEXT VARIABLES
; Used by the 64 column driver

at_flag:
        defb    0               ; AT flag

row:
        defb    0               ; row

col:
        defb    0               ; col

; HALF WIDTH 4x8 FONT
; Top row is always zero and not stored (336 bytes)

if original_font

font:
        defb    0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0x00        ; !
        defb    0x52, 0x57, 0x02, 0x02, 0x07, 0x02, 0x00        ;"#
        defb    0x25, 0x71, 0x62, 0x32, 0x74, 0x25, 0x00        ;$%
        defb    0x22, 0x42, 0x30, 0x50, 0x50, 0x30, 0x00        ;&'
        defb    0x14, 0x22, 0x41, 0x41, 0x41, 0x22, 0x14        ;()
        defb    0x20, 0x70, 0x22, 0x57, 0x02, 0x00, 0x00        ;*+
        defb    0x00, 0x00, 0x00, 0x07, 0x00, 0x20, 0x20        ;,-
        defb    0x01, 0x01, 0x02, 0x02, 0x04, 0x14, 0x00        ;./
        defb    0x22, 0x56, 0x52, 0x52, 0x52, 0x27, 0x00        ;01
        defb    0x27, 0x51, 0x12, 0x21, 0x45, 0x72, 0x00        ;23
        defb    0x57, 0x54, 0x56, 0x71, 0x15, 0x12, 0x00        ;45
        defb    0x17, 0x21, 0x61, 0x52, 0x52, 0x22, 0x00        ;67
        defb    0x22, 0x55, 0x25, 0x53, 0x52, 0x24, 0x00        ;89
        defb    0x00, 0x00, 0x22, 0x00, 0x00, 0x22, 0x02        ;:;
        defb    0x00, 0x10, 0x27, 0x40, 0x27, 0x10, 0x00        ;<=
        defb    0x02, 0x45, 0x21, 0x12, 0x20, 0x42, 0x00        ;>?
        defb    0x23, 0x55, 0x75, 0x77, 0x45, 0x35, 0x00        ;@A
        defb    0x63, 0x54, 0x64, 0x54, 0x54, 0x63, 0x00        ;BC
        defb    0x67, 0x54, 0x56, 0x54, 0x54, 0x67, 0x00        ;DE
        defb    0x73, 0x44, 0x64, 0x45, 0x45, 0x43, 0x00        ;FG
        defb    0x57, 0x52, 0x72, 0x52, 0x52, 0x57, 0x00        ;HI
        defb    0x35, 0x15, 0x16, 0x55, 0x55, 0x25, 0x00        ;JK
        defb    0x45, 0x47, 0x45, 0x45, 0x45, 0x75, 0x00        ;LM
        defb    0x62, 0x55, 0x55, 0x55, 0x55, 0x52, 0x00        ;NO
        defb    0x62, 0x55, 0x55, 0x65, 0x45, 0x43, 0x00        ;PQ
        defb    0x63, 0x54, 0x52, 0x61, 0x55, 0x52, 0x00        ;RS
        defb    0x75, 0x25, 0x25, 0x25, 0x25, 0x22, 0x00        ;TU
        defb    0x55, 0x55, 0x55, 0x55, 0x27, 0x25, 0x00        ;VW
        defb    0x55, 0x55, 0x25, 0x22, 0x52, 0x52, 0x00        ;XY
        defb    0x73, 0x12, 0x22, 0x22, 0x42, 0x72, 0x03        ;Z[
        defb    0x46, 0x42, 0x22, 0x22, 0x12, 0x12, 0x06        ;\]
        defb    0x20, 0x50, 0x00, 0x00, 0x00, 0x00, 0x0f        ;^_
        defb    0x20, 0x10, 0x03, 0x05, 0x05, 0x03, 0x00        ;?a
        defb    0x40, 0x40, 0x63, 0x54, 0x54, 0x63, 0x00        ;bc
        defb    0x10, 0x10, 0x32, 0x55, 0x56, 0x33, 0x00        ;de
        defb    0x10, 0x20, 0x73, 0x25, 0x25, 0x43, 0x06        ;fg
        defb    0x42, 0x40, 0x66, 0x52, 0x52, 0x57, 0x00        ;hi
        defb    0x14, 0x04, 0x35, 0x16, 0x15, 0x55, 0x20        ;jk
        defb    0x60, 0x20, 0x25, 0x27, 0x25, 0x75, 0x00        ;lm
        defb    0x00, 0x00, 0x62, 0x55, 0x55, 0x52, 0x00        ;no
        defb    0x00, 0x00, 0x63, 0x55, 0x55, 0x63, 0x41        ;pq
        defb    0x00, 0x00, 0x53, 0x66, 0x43, 0x46, 0x00        ;rs
        defb    0x00, 0x20, 0x75, 0x25, 0x25, 0x12, 0x00        ;tu
        defb    0x00, 0x00, 0x55, 0x55, 0x27, 0x25, 0x00        ;vw
        defb    0x00, 0x00, 0x55, 0x25, 0x25, 0x53, 0x06        ;xy
        defb    0x01, 0x02, 0x72, 0x34, 0x62, 0x72, 0x01        ;z{
        defb    0x24, 0x22, 0x22, 0x21, 0x22, 0x22, 0x04        ;|}
        defb    0x56, 0xa9, 0x06, 0x04, 0x06, 0x09, 0x06        ;~?

endif

; vim: ts=8:sts=8
