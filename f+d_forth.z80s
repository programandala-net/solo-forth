; F+D Forth
; By Marcos Cruz (programandala.net), 2015
; http://programandala.net/en.program.f+d_forth.html

  org 0x5E00

  ; ----------------------------------------------------------------
  ; Symbols

  ; Forth

data_bytes_per_buffer:            equ 0x0200
total_bytes_per_buffer:           equ data_bytes_per_buffer+4
blocks_per_screen:                equ 0x02
bytes_per_data_stack:             equ 0x50

; XXX FIXME
; bytes_per_data_stack:             equ 0x80 ; bombs out with 0x52 bytes full
bytes_per_return_stack:           equ 0x50 ; bombs out with 0x2A bytes full

bytes_per_terminal_input_buffer:  equ 0x50
characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10

false                             equ 0
true                              equ 1

precedence_bit:       equ 6
precedence_bit_mask:  equ 1 shl precedence_bit
smudge_bit:           equ 5
smudge_bit_mask:      equ 1 shl smudge_bit

  ; ROM  routines

rom_beeper:         equ 0x03B5
rom_border_2297:    equ 0x2297
rom_break_key:      equ 0x1F54
rom_chan_open:      equ 0x1601
rom_cls:            equ 0x0D6B ; XXX OLD -- not used
rom_cl_all:         equ 0x0DAF
rom_find_int1:      equ 0x1E94
rom_key_decode:     equ 0x0333
rom_key_scan:       equ 0x028E
rom_key_test:       equ 0x031E
rom_plot_22df:      equ 0x22DF
rom_point_sub_22ce: equ 0x22CE
rom_s_attr_s_2583:  equ 0x2583
rom_s_scrn_s_2538:  equ 0x2538
rom_sa_all:         equ 0x075A
rom_stack_fetch:    equ 0x2BF1

  ; System variables

  ; XXX FIXME Pasmo's bug?
  ; This must be the first one, because it's used in calculations:
sys_errnr:         equ 0x5C3A ; IY

sys_attr_p:        equ 0x5C8D
sys_coordx:        equ 0x5C7D
sys_coordy:        equ 0x5C7E
sys_df_cc:         equ 0x5C84
sys_df_sz:         equ 0x5C6B
sys_df_sz_offset:  equ sys_df_sz-sys_errnr
sys_flags2:        equ 0x5C6A
sys_last_k:        equ 0x5C08
sys_mask_p:        equ 0x5C8E
sys_mode:          equ 0x5C41
sys_p_flag:        equ 0x5C91
sys_s_posn:        equ 0x5C88
sys_scr_ct:        equ 0x5C8C
sys_scr_ct_offset: equ sys_scr_ct-sys_errnr
sys_t_addr:        equ 0x5C74
sys_udg:           equ 0x5C7B

  ; ----------------------------------------------------------------
  ; Macros

_header: macro name,immediate

  ; XXX TODO -- Copied from DZX-Forth. Adapt it.

  ; name        = name string
  ; immediate   = _immediate or nothing

  ; the name field
  this_nfa: defl $ ; link address for next word
  bits: defl 0x80
  if not nul immediate
    ; set immediate bit
    bits: defl bits | precedence_bit_mask
  endif
  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first+bits    ; count and flags byte
  _first:
  db name
  db last_letter+0x80
  _next:
  dw previous_nfa ; the link field

  previous_nfa: defl this_nfa

endm

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm


  ; ----------------------------------------------------------------
  ; User variables

user_variables_origin:

  old_origin? equ 0

  if old_origin?
  ; Unused
  dw 0x0000
  dw 0x0000
  dw 0x0000
  endif
s0_value: ; +0x00
  dw 0x0000
r0_value: ; +0x02
  dw 0x0000
tib_value: ; +0x04
  dw 0x0000
width_value: ; +0x06
  dw 0x0000
warning_value: ; +0x08
  dw 0x0000
fence_value: ; +0x0A
  dw 0x0000
dp_value: ; +0x0C
  dw 0x0000
voc_link_value: ; +0x0E
  dw 0x0000
blk_value: ; +0x10
  dw 0x0000
in_value: ; +0x12
  dw 0x0000
out_value: ; +0x14
  dw 0x0000
scr_value: ; +0x16
  dw 0x0000
offset_value: ; +0x18
  dw 0x0000
context_value: ; +0x1A
  dw 0x0000
current_value: ; +0x1C
  dw 0x0000
state_value: ; +0x1E
  dw 0x0000
base_value: ; +0x20
  dw 0x0000
dpl_value: ; +0x22
  dw 0x0000
fld_value: ; +0x24
  dw 0x0000
csp_value: ; +0x26
  dw 0x0000
r_hash_value: ; +0x28
  dw 0x0000
hld_value: ; +0x2A
  dw 0x0000
  ; Unused
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  if not old_origin?
  dw 0x0000
  dw 0x0000
  dw 0x0000
  endif

  ; ----------------------------------------------------------------
  ; Parameter area

origin:

  ; Entry points
cold_entry:
  nop
  jp cold_start
warm_entry:
  nop
  jp warm_start

fig_release:
  db 0x01
fig_revision:
  db 0x01
fig_user_version:
  ; XXX FIXME -- It should be 0x41 ("A").
  db 0x00

fig_implementation_attributes:
  ; Location: 0x0B +ORIGIN
  db 0x0E
  ; Bits:      76543210
  ; Bit names: ...WIEBA
  ; 0x0E =     00001110
  ; Legend:
  ;   W: 0 = above sufficient
  ;      1 = other differences exist
  ;   I: Interpreter:
  ;      0 = pre-incrementing
  ;      1 = post-incrementing
  ;   E: Address must be even:
  ;      0 = yes
  ;      1 = no
  ;   B: High byte @:
  ;      0 = low address
  ;      1 = high address
  ;   A: CPU address:
  ;      0 = byte
  ;      1 = word

top_most_word_in_forth_voc:
  dw nfa_of_top_most_word_in_forth_voc
backspace_char:
  dw 0x000C

init_user_pointer_value:
  dw user_pointer_value

  ; ----------------------------------------------------------------
  ; User variables init values

  ; These are the default values of the first eight user variables.
  ; They are used by `cold` to overwrite them.  They must be in the
  ; same order than user variables.

init_s0_value:
  dw data_stack_bottom
init_r0_value:
  dw return_stack_bottom
init_tib_value:
  dw terminal_input_buffer
init_width_value:
  dw 0x001F
init_warning_value:
  dw 0x0000
init_fence_value:
  dw dictionary_pointer_after_cold
init_dp_value:
  dw dictionary_pointer_after_cold
init_voc_link_value:
  dw forth_vocabulary_link

user_pointer_value:
  dw user_variables_origin
return_pointer_value:
  dw return_stack_bottom

  ; ----------------------------------------------------------------
  ; Stacks and buffers

;  defs 100 ; XXX TMP

data_stack_limit: equ $+2
  defs bytes_per_data_stack+2
data_stack_bottom:

;  defs 100 ; XXX TMP

terminal_input_buffer:
  defs bytes_per_terminal_input_buffer

;  defs 4 ; XXX TMP

return_stack_limit: equ $+2
  defs bytes_per_return_stack+2
return_stack_bottom:

;  defs 4 ; XXX TMP

first_buffer:
  defs blocks_per_screen*total_bytes_per_buffer
limit:

  ; ----------------------------------------------------------------
  ; Interpreter

pushde:
  push de

pushhl:
  push hl

next:
  ; Execute the word pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa
next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa)
  ; de = cfa+1 = pfa-1
  jp (hl)

  ; ----------------------------------------------------------------
  ; Dictionary

c_lit_nfa:
  db 0x04+0x80,'CLI','T'+0x80
c_lit_lfa:
  dw 0x0000
c_lit_:
  dw c_lit_pfa
c_lit_pfa:
  ld a,(bc)
  inc bc
  ld l,a
  ld h,0
  jp pushhl

lit_nfa:
  db 0x03+0x80,'LI','T'+0x80
lit_lfa:
  dw c_lit_nfa
lit_:
  dw lit_pfa
lit_pfa:
  ld a,(bc)
  inc bc
  ld l,a
  ld a,(bc)
  inc bc
  ld h,a
  jp pushhl

execute_nfa:
  db 0x07+0x80,'EXECUT','E'+0x80
execute_lfa:
  dw lit_nfa
execute_:
  dw execute_pfa
execute_pfa:
  pop hl
  jp next2

branch_nfa:
  db 0x06+0x80,'BRANC','H'+0x80
branch_lfa:
  dw execute_nfa
branch_:
  dw branch_pfa
branch_pfa:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp next

zero_branch_nfa:
  db 0x07+0x80,'0BRANC','H'+0x80
zero_branch_lfa:
  dw branch_nfa
zero_branch_:
  dw zero_branch_pfa
zero_branch_pfa:
  pop hl
  ld a,l
  or h
  jp z,branch_pfa
  inc bc
  inc bc
  jp next

  ; XXX NEW
question_branch_nfa:
  db 0x07+0x80,'?BRANC','H'+0x80
question_branch_lfa:
  dw zero_branch_nfa
question_branch_:
  dw question_branch_pfa
question_branch_pfa:
  pop hl
  ld a,l
  or h
  jp nz,branch_pfa
  inc bc
  inc bc
  jp next

paren_loop_nfa:
  db 0x06+0x80,'(LOOP',')'+0x80
paren_loop_lfa:
  dw question_branch_nfa
paren_loop_:
  dw paren_loop_pfa
paren_loop_pfa:
  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_pointer_value)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl
  inc d
  dec d
  ld d,a
  jp m,l5eedh
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp l5ef2h
l5eedh:
  ld a,(hl)
  sub e
  inc hl
  ld a,(hl)
  sbc a,d
l5ef2h:
  jp m,branch_pfa
  inc hl
  ld (return_pointer_value),hl
  inc bc
  inc bc
  jp next

paren_plus_loop_nfa:
  db 0x07+0x80,'(+LOOP',')'+0x80
paren_plus_loop_lfa:
  dw paren_loop_nfa
paren_plus_loop_:
  dw paren_plus_loop_pfa
paren_plus_loop_pfa:
  pop de
  jp paren_loop.step_in_de

paren_do_nfa:
  db 0x04+0x80,'(DO',')'+0x80
paren_do_lfa:
  dw paren_plus_loop_nfa
paren_do_:
  dw paren_do_pfa
paren_do_pfa:
  ld hl,(return_pointer_value)
  dec hl
  dec hl
  dec hl
  dec hl
  ld (return_pointer_value),hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  pop de
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

i_nfa:
  db 0x01+0x80,'','I'+0x80
i_lfa:
  dw paren_do_nfa
i_:
  dw r_fetch_pfa

digit_nfa:
  db 0x05+0x80,'DIGI','T'+0x80
digit_lfa:
  dw i_nfa
digit_:
  dw digit_pfa
digit_pfa:
  pop hl
  pop de
  ld a,e
  sub 0x30
  jp m,l5f65h
  cp 0x0A
  jp m,l5f5ah
  sub 0x07
  cp 0x0A
  jp m,l5f65h
l5f5ah:
  cp l
  jp p,l5f65h
  ld e,a
  ld hl,0x0001
  jp pushde
l5f65h:
  ld l,h
  jp pushhl

paren_find_nfa:
  db 0x06+0x80,'(FIND',')'+0x80
paren_find_lfa:
  dw digit_nfa
paren_find_:
  dw paren_find_pfa
paren_find_pfa:
  pop de
l5f75h:
  pop hl
  push hl
  ld a,(de)
  xor (hl)
  and 0x3F
  jr nz,l5f9ch
l5f7dh:
  inc hl
  inc de
  ld a,(de)
  xor (hl)
  add a,a
  jr nz,l5f9ah
  jr nc,l5f7dh
  ld hl,0x0005
  add hl,de
  ex (sp),hl
l5f8bh:
  dec de
  ld a,(de)
  or a
  jp p,l5f8bh
  ld e,a
  ld d,0x00
  ld hl,0x0001
  jp pushde
l5f9ah:
  jr c,l5fa2h
l5f9ch:
  inc de
  ld a,(de)
  or a
  jp p,l5f9ch
l5fa2h:
  inc de
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e
  jr nz,l5f75h
  pop hl
  ld hl,0x0000
  jp pushhl

enclose_nfa:
  db 0x07+0x80,'ENCLOS','E'+0x80
enclose_lfa:
  dw paren_find_nfa
enclose_:
  dw enclose_pfa
enclose_pfa:
  pop de
  pop hl
  push hl
  ld a,e
  ld d,a
  ld e,0xFF
  dec hl
l5fc6h:
  inc hl
  inc e
  cp (hl)
  jr z,l5fc6h
  ld d,0x00
  push de
  ld d,a
  ld a,(hl)
  and a
  jr nz,l5fdch
  ld d,0x00
  inc e
  push de
  dec e
  push de
  jp next
l5fdch:
  ld a,d
  inc hl
  inc e
  cp (hl)
  jr z,l5fedh
  ld a,(hl)
  and a
  jr nz,l5fdch
  ld d,0x00
  push de
  push de
  jp next
l5fedh:
  ld d,0x00
  push de
  inc e
  push de
  jp next

; doc{

; >CHAN  ( b -- )

; Send the character with ASCII code c to the current channel.
;
; This word is copied from `TOCH`, from Lennart Benschop's Spectrum
; Forth-83. It is needed by the new version of `AT`, because Abersoft
; Forth's `EMIT' changes the current channel.

; }doc

to_chan_nfa:
  db 0x05+0x80,'>CHA','N'+0x80
to_chan_lfa:
  dw enclose_nfa
to_chan_:
  dw to_chan_pfa
to_chan_pfa:
  pop hl
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  ld a,l
  rst 0x10
  jp next

emit_nfa:
  db 0x04+0x80,'EMI','T'+0x80
emit_lfa:
  dw to_chan_nfa
emit_:
  dw do_colon
emit_pfa:
  dw paren_emit_
  dw one_
  dw out_
  dw plus_store_
  dw semicolon_s_

printer_channel_or_zero: ; XXX TODO move to the code
  db 0x00

paren_emit_:
  dw paren_emit_pfa
paren_emit_pfa:
  pop hl
  push bc
  push hl
  ld a,0x02
  call rom_chan_open
  pop hl
  push hl
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  ld a,l
  rst 0x10
  ld a,(printer_channel_or_zero)
  and a
  jr z,paren_emit.end
  call rom_chan_open
  pop hl
  push hl
  ld a,l
  rst 0x10
paren_emit.end:
  pop hl
  pop bc
  jp next

key_nfa:
  db 0x03+0x80,'KE','Y'+0x80
key_lfa:
  dw emit_nfa
key_:
  dw key_pfa
key_pfa:

  push bc
  ld a,0x02
  call rom_chan_open

  ; flash on
  ld a,0x12
  rst 0x10
  ld a,0x01
  rst 0x10

key.new_key:
  xor a
  ld (sys_last_k),a
  ; Print cursor:
key.cursor_char: equ $+1
  ld a,'L'
  rst 0x10
  ld a,0x08
  rst 0x10
key.wait_for_key:
  ld a,(sys_last_k)
  and a
  jr z,key.wait_for_key
  ; a = pressed key code

  cp 0x06 ; caps?
  jr nz,key.graphic_mode
  ; caps
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a

key.not_graphic_mode_cursor:
  ; a = 0 (lowercase mode)
  ;     8 (uppercase mode)
  ld hl,key.cursor_char
  bit 3,a ; cursor 'L'?
  jr nz,key.cursor_c
  ld (hl),'L'
  jr key.new_key
key.cursor_c:
  ld (hl),'C'
  jr key.new_key

key.graphic_mode:
  cp 0x0F ; change graphics mode?
  jr nz,key.left_bracket
  ; graphics
  ld a,0x02
  ld hl,sys_mode
  xor (hl)
  ld (hl),a
  and a ; now in graphics mode?
  jr nz,key.graphic_mode_cursor
  ; not in graphics mode
  ld a,(sys_flags2)
  jr key.not_graphic_mode_cursor

key.graphic_mode_cursor:
  ld a,'G'
  ld (key.cursor_char),a
  jr key.new_key

  ; Translate some chars
key.left_bracket:
  cp 0xC6
  jr nz,key.right_bracket
  ld a,'['
key.right_bracket:
  cp 0xC5
  jr nz,key.tilde
  ld a,']'
key.tilde:
  cp 0xE2
  jr nz,key.vertical_bar
  ld a,'~'
key.vertical_bar:
  cp 0xC3
  jr nz,key.backslash
  ld a,'|'
key.backslash:
  cp 0xCD
  jr nz,key.left_curly_bracket
  ld a,'\'
key.left_curly_bracket:
  cp 0xCC
  jr nz,key.right_curly_bracket
  ld a,'{'
key.right_curly_bracket:
  cp 0xCB
  jr nz,key.limit
  ld a,'}'

key.limit:
  cp 0xA5 ; greater than 0xA4 (the last UDG)?
  jr nc,key.new_key
  ld l,a
  ld h,0x00

  ; flash off
  ld a,0x12
  rst 0x10
  ld a,0x00
  rst 0x10

  ; delete the cursor
  ld a,0x20
  rst 0x10
  ld a,0x08
  rst 0x10

  pop bc
  jp pushhl


question_terminal_nfa:
  db 0x09+0x80,'?TERMINA','L'+0x80
question_terminal_lfa:
  dw key_nfa
question_terminal_:
  dw question_terminal_pfa
question_terminal_pfa:
  ld hl,0x0000
  push bc
  push de
  call rom_break_key
  ld hl,0x0000
  jr c,l6fcdh
  inc l
  jr l6fd5h
l6fcdh:
  ; XXX OLD
  ld a,(sys_last_k)
  cp 0x07
  jr nz,l6fd5h
  inc hl
l6fd5h:
  pop de
  pop bc
  jp pushhl

cr_nfa:
  db 0x02+0x80,'C','R'+0x80
cr_lfa:
  dw question_terminal_nfa
cr_:
  dw cr_pfa
cr_pfa:
  push bc
  ld a,0x02
  call rom_chan_open
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  ld a,0x0D
  rst 0x10
  ; XXX TODO factor with the same code in paren_emit.
  ld a,(printer_channel_or_zero)
  and a
  jr z,cr.end
  call rom_chan_open
  ld a,0x0D
  rst 0x10
cr.end:
  pop bc
  jp next

cmove_nfa:
  db 0x05+0x80,'CMOV','E'+0x80
cmove_lfa:
  dw cr_nfa
cmove_:
  dw cmove_pfa
cmove_pfa:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ld a,b
  or c
  jr z,l6046h
  ldir
l6046h:
  pop bc
  jp next

u_star_nfa:
  db 0x02+0x80,'U','*'+0x80
u_star_lfa:
  dw cmove_nfa
u_star_:
  dw u_star_pfa
u_star_pfa:
  pop de
  pop hl
  push bc
  ld b,h
  ld a,l
  call sub_606dh
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_606dh
  pop de
  ld c,d
  add hl,bc
  adc a,0x00
  ld d,l
  ld l,h
  ld h,a
  pop bc
  push de
  jp pushhl
sub_606dh:
  ld hl,0x0000
  ld c,0x08
l6072h:
  add hl,hl
  rla
  jr nc,l6079h
  add hl,de
  adc a,0x00
l6079h:
  dec c
  jr nz,l6072h
  ret

u_slash_mod_nfa:
  db 0x05+0x80,'U/MO','D'+0x80
u_slash_mod_lfa:
  dw u_star_nfa
u_slash_mod_:
  dw u_slash_mod_pfa
u_slash_mod_pfa:
  ld hl,0x0004
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l60a0h
  ld hl,0xFFFF
  ld de,0xFFFF
  jr l60c0h
l60a0h:
  ld a,0x10
l60a2h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l60aah
  inc de
  and a
l60aah:
  ex de,hl
  rra
  push af
  jr nc,l60b4h
  and l
  sbc hl,bc
  jr l60bbh
l60b4h:
  and a
  sbc hl,bc
  jr nc,l60bbh
  add hl,bc
  dec de
l60bbh:
  inc de
  pop af
  dec a
  jr nz,l60a2h
l60c0h:
  pop bc
  push hl
  push de
  jp next

and_nfa:
  db 0x03+0x80,'AN','D'+0x80
and_lfa:
  dw u_slash_mod_nfa
and_:
  dw and_pfa
and_pfa:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp pushhl

or_nfa:
  db 0x02+0x80,'O','R'+0x80
or_lfa:
  dw and_nfa
or_:
  dw or_pfa
or_pfa:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp pushhl

xor_nfa:
  db 0x03+0x80,'XO','R'+0x80
xor_lfa:
  dw or_nfa
xor_:
  dw xor_pfa
xor_pfa:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp pushhl

sp_fetch_nfa:
  db 0x03+0x80,'SP','@'+0x80
sp_fetch_lfa:
  dw xor_nfa
sp_fetch_:
  dw sp_fetch_pfa
sp_fetch_pfa:
  ld hl,0x0000
  add hl,sp
  jp pushhl

sp_store_nfa:
  db 0x03+0x80,'SP','!'+0x80
sp_store_lfa:
  dw sp_fetch_nfa
sp_store_:
  dw sp_store_pfa
sp_store_pfa:
  ; XXX OLD
  if old_origin?
   ld e,(ix+0x06)
   ld d,(ix+0x07)
  else
   ld e,(ix+0x00)
   ld d,(ix+0x01)
  endif
   ex de,hl
  ; XXX NEW
  ;ld l,(ix+0x06)
  ;ld h,(ix+0x07)
  ld sp,hl
  jp next

rp_fetch_nfa:
  db 0x03+0x80,'RP','@'+0x80
rp_fetch_lfa:
  dw sp_store_nfa
rp_fetch_:
  dw rp_fetch_pfa
rp_fetch_pfa:
  ld hl,(return_pointer_value)
  jp pushhl

rp_store_nfa:
  db 0x03+0x80,'RP','!'+0x80
rp_store_lfa:
  dw rp_fetch_nfa
rp_store_:
  dw rp_store_pfa
rp_store_pfa:
  ; XXX OLD
  if old_origin?
  ld e,(ix+0x08)
  ld d,(ix+0x09)
  else
  ld e,(ix+0x02)
  ld d,(ix+0x03)
  endif
  ex de,hl
  ; XXX NEW
  ;ld l,(ix+0x08)
  ;ld h,(ix+0x09)
  ld (return_pointer_value),hl
  jp next

semicolon_s_nfa:
  db 0x02+0x80,';','S'+0x80
semicolon_s_lfa:
  dw rp_store_nfa
semicolon_s_:
  dw semicolon_s_pfa
semicolon_s_pfa:
  ld hl,(return_pointer_value)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_pointer_value),hl
  jp next

unloop_nfa:
  db 0x06+0x80,'UNLOO','P'+0x80
unloop_lfa:
  dw semicolon_s_nfa
unloop_:
  dw two_r_drop_pfa

leave_nfa:
  db 0x05+0x80,'LEAV','E'+0x80
leave_lfa:
  dw unloop_nfa
leave_:
  dw leave_pfa
leave_pfa:
  ld hl,(return_pointer_value)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

to_r_nfa:
  db 0x02+0x80,'>','R'+0x80
to_r_lfa:
  dw leave_nfa
to_r_:
  dw to_r_pfa
to_r_pfa:
  pop de
  ld hl,(return_pointer_value)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_pointer_value),hl
  jp next

from_r_nfa:
  db 0x02+0x80,'R','>'+0x80
from_r_lfa:
  dw to_r_nfa
from_r_:
  dw from_r_pfa
from_r_pfa:
  ld hl,(return_pointer_value)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_pointer_value),hl
  push de
  jp next

two_r_drop_nfa:
  db 0x06+0x80,'2RDRO','P'+0x80
two_r_drop_lfa:
  dw from_r_nfa
two_r_drop_:
  dw two_r_drop_pfa
two_r_drop_pfa:
  ld hl,(return_pointer_value)
  inc hl
  inc hl
  inc hl
  inc hl
  ld (return_pointer_value),hl
  jp next

r_drop_nfa:
  db 0x05+0x80,'RDRO','P'+0x80
r_drop_lfa:
  dw two_r_drop_nfa
r_drop_:
  dw two_r_drop_pfa
r_drop_pfa:
  ; XXX FIXME
  ld hl,(return_pointer_value)
  inc hl
  inc hl
  ld (return_pointer_value),hl
  jp next

r_fetch_nfa:
  db 0x02+0x80,'R','@'+0x80
r_fetch_lfa:
  dw r_drop_nfa
r_fetch_:
  dw r_fetch_pfa
r_fetch_pfa:
  ld hl,(return_pointer_value)
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

zero_equals_nfa:
  db 0x02+0x80,'0','='+0x80
zero_equals_lfa:
  dw r_fetch_nfa
zero_equals_:
  dw zero_equals_pfa
zero_equals_pfa:
  pop hl
  ld a,l
  or h
  ld hl,0x0000
  jr nz,l61aeh
  inc hl
l61aeh:
  jp pushhl

zero_less_than_nfa:
  db 0x02+0x80,'0','<'+0x80
zero_less_than_lfa:
  dw zero_equals_nfa
zero_less_than_:
  dw zero_less_than_pfa
zero_less_than_pfa:
  pop hl
  add hl,hl
  ld hl,0x0000
  jr nc,l61c0h
  inc hl
l61c0h:
  jp pushhl

plus_nfa:
  db 0x01+0x80,'','+'+0x80
plus_lfa:
  dw zero_less_than_nfa
plus_:
  dw plus_pfa
plus_pfa:
  pop de
  pop hl
  add hl,de
  jp pushhl

d_plus_nfa:
  db 0x02+0x80,'D','+'+0x80
d_plus_lfa:
  dw plus_nfa
d_plus_:
  dw d_plus_pfa
d_plus_pfa:
  ld hl,0x0006
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  adc hl,bc
  pop bc
  push de
  jp pushhl

negate_nfa:
  db 0x06+0x80,'NEGAT','E'+0x80
negate_lfa:
  dw d_plus_nfa
negate_:
  dw negate_pfa
negate_pfa:
  pop de
  ld hl,0x0000
  and a
  sbc hl,de
  jp pushhl

dnegate_nfa:
  db 0x07+0x80,'DNEGAT','E'+0x80
dnegate_lfa:
  dw negate_nfa
dnegate_:
  dw dnegate_pfa
dnegate_pfa:
  pop hl
  pop de
  sub a
  sub e
  ld e,a
  ld a,0x00
  sbc a,d
  ld d,a
  ld a,0x00
  sbc a,l
  ld l,a
  ld a,0x00
  sbc a,h
  ld h,a
  push de
  jp pushhl

nip_nfa:
  db 0x03+0x80,'NI','P'+0x80
nip_lfa:
  dw dnegate_nfa
nip_:
  dw nip_pfa
nip_pfa:
  pop hl
  pop de
  jp pushhl

tuck_nfa:
  db 0x04+0x80,'TUC','K'+0x80
tuck_lfa:
  dw nip_nfa
tuck_:
  dw tuck_pfa
tuck_pfa:
  pop hl
  pop de
  push hl
  jp pushde

over_nfa:
  db 0x04+0x80,'OVE','R'+0x80
over_lfa:
  dw tuck_nfa
over_:
  dw over_pfa
over_pfa:
  pop de
  pop hl
  push hl
  jp pushde

drop_nfa:
  db 0x04+0x80,'DRO','P'+0x80
drop_lfa:
  dw over_nfa
drop_:
  dw drop_pfa
drop_pfa:
  pop hl
  jp next

swap_nfa:
  db 0x04+0x80,'SWA','P'+0x80
swap_lfa:
  dw drop_nfa
swap_:
  dw swap_pfa
swap_pfa:
  pop hl
  ex (sp),hl
  jp pushhl

dup_nfa:
  db 0x03+0x80,'DU','P'+0x80
dup_lfa:
  dw swap_nfa
dup_:
  dw dup_pfa
dup_pfa:
  pop hl
  push hl
  jp pushhl

two_dup_nfa:
  db 0x04+0x80,'2DU','P'+0x80
two_dup_lfa:
  dw dup_nfa
two_dup_:
  dw two_dup_pfa
two_dup_pfa:
  pop hl
  pop de
  push de
  push hl
  jp pushde

plus_store_nfa:
  db 0x02+0x80,'+','!'+0x80
plus_store_lfa:
  dw two_dup_nfa
plus_store_:
  dw plus_store_pfa
plus_store_pfa:
  pop hl
  pop de
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  jp next

toggle_nfa:
  db 0x06+0x80,'TOGGL','E'+0x80
toggle_lfa:
  dw plus_store_nfa
toggle_:
  dw toggle_pfa
toggle_pfa:
  pop de
  pop hl
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

fetch_nfa:
  db 0x01+0x80,'','@'+0x80
fetch_lfa:
  dw toggle_nfa
fetch_:
  dw fetch_pfa
fetch_pfa:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

c_fetch_nfa:
  db 0x02+0x80,'C','@'+0x80
c_fetch_lfa:
  dw fetch_nfa
c_fetch_:
  dw c_fetch_pfa
c_fetch_pfa:
  pop hl
  ld l,(hl)
  ld h,0x00
  jp pushhl

two_fetch_nfa:
  db 0x02+0x80,'2','@'+0x80
two_fetch_lfa:
  dw c_fetch_nfa
two_fetch_:
  dw two_fetch_pfa
two_fetch_pfa:
  pop hl
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  dec hl
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  push de
  jp next

store_nfa:
  db 0x01+0x80,'','!'+0x80
store_lfa:
  dw two_fetch_nfa
store_:
  dw store_pfa
store_pfa:
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

c_store_nfa:
  db 0x02+0x80,'C','!'+0x80
c_store_lfa:
  dw store_nfa
c_store_:
  dw c_store_pfa
c_store_pfa:
  pop hl
  pop de
  ld (hl),e
  jp next

two_store_nfa:
  db 0x02+0x80,'2','!'+0x80
two_store_lfa:
  dw c_store_nfa
two_store_:
  dw two_store_pfa
two_store_pfa:
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

colon_nfa:
  db 0x01+0x80+precedence_bit_mask,'',':'+0x80
colon_lfa:
  dw two_store_nfa
colon_:
  dw do_colon
colon_pfa:
  dw question_exec_
  dw store_csp_
  dw current_,fetch_
  dw context_
  dw store_
  dw create_
  dw right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_pointer_value)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_pointer_value),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
  jp next

semicolon_nfa:
  db 0x01+0x80+precedence_bit_mask,'',';'+0x80
semicolon_lfa:
  dw colon_nfa
semicolon_:
  dw do_colon
semicolon_pfa:
  dw question_csp_
  dw compile_,semicolon_s_
  dw smudge_
  dw left_bracket_
  dw semicolon_s_

noop_nfa:
  db 0x04+0x80,'NOO','P'+0x80
noop_lfa:
  dw semicolon_nfa
noop_:
  dw do_colon
noop_pfa:
  dw semicolon_s_

constant_nfa:
  db 0x08+0x80,'CONSTAN','T'+0x80
constant_lfa:
  dw noop_nfa
constant_:
  dw do_colon
constant_pfa:
  dw create_
  dw smudge_
  dw comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  ld e,(hl)
  inc hl
  ld d,(hl) ; de=value
  push de
  jp next

variable_nfa:
  db 0x08+0x80,'VARIABL','E'+0x80
variable_lfa:
  dw constant_nfa
variable_:
  dw do_colon
variable_pfa:
  dw constant_
  dw paren_semicolon_code_
do_variable:
  inc de  ; de=pfa
  push de
  jp next

user_nfa:
  db 0x04+0x80,'USE','R'+0x80
user_lfa:
  dw variable_nfa
user_:
  dw do_colon
user_pfa:
  dw constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00
  push ix     ; user variable pointer
  pop hl
  add hl,de   ; hl= address of the user variable
  jp pushhl

zero_nfa:
  db 0x01+0x80,'','0'+0x80
zero_lfa:
  dw user_nfa
zero_:
  dw do_constant
zero_pfa:
  dw 0x0000

one_nfa:
  db 0x01+0x80,'','1'+0x80
one_lfa:
  dw zero_nfa
one_:
  dw do_constant
one_pfa:
  dw 0x0001

two_nfa:
  db 0x01+0x80,'','2'+0x80
two_lfa:
  dw one_nfa
two_:
  dw do_constant
two_pfa:
  dw 0x0002

three_nfa:
  db 0x01+0x80,'','3'+0x80
three_lfa:
  dw two_nfa
three_:
  dw do_constant
three_pfa:
  dw 0x0003

b_l_nfa:
  db 0x02+0x80,'B','L'+0x80
b_l_lfa:
  dw three_nfa
b_l_:
  dw do_constant
b_l_pfa:
  dw 0x0020

c_slash_l_nfa:
  db 0x03+0x80,'C/','L'+0x80
c_slash_l_lfa:
  dw b_l_nfa
c_slash_l_:
  dw do_constant
c_slash_l_pfa:
  dw characters_per_line

first_nfa:
  db 0x05+0x80,'FIRS','T'+0x80
first_lfa:
  dw c_slash_l_nfa
first_:
  dw do_constant
first_pfa:
  dw first_buffer

limit_nfa:
  db 0x05+0x80,'LIMI','T'+0x80
limit_lfa:
  dw first_nfa
limit_:
  dw do_constant
limit_pfa:
  dw limit

b_slash_buf_nfa:
  db 0x05+0x80,'B/BU','F'+0x80
b_slash_buf_lfa:
  dw limit_nfa
b_slash_buf_:
  dw do_constant
b_slash_buf_pfa:
  dw data_bytes_per_buffer

b_slash_scr_nfa:
  db 0x05+0x80,'B/SC','R'+0x80
b_slash_scr_lfa:
  dw b_slash_buf_nfa
b_slash_scr_:
  dw do_constant
b_slash_scr_pfa:
  dw blocks_per_screen

plus_origin_nfa:
  db 0x07+0x80,'+ORIGI','N'+0x80
plus_origin_lfa:
  dw b_slash_scr_nfa
plus_origin_:
  dw do_colon
plus_origin_pfa:
  dw lit_,origin
  dw plus_
  dw semicolon_s_

s0_nfa:
  db 0x02+0x80,'S','0'+0x80
s0_lfa:
  dw plus_origin_nfa
s0_:
  dw do_user
s0_pfa:
  db 0x06*old_origin?
  ; nop ; XXX OLD

r0_nfa:
  db 0x02+0x80,'R','0'+0x80
r0_lfa:
  dw s0_nfa
r0_:
  dw do_user
r0_pfa:
  db 0x02+0x06*old_origin?
  ; nop ; XXX OLD

tib_nfa:
  db 0x03+0x80,'TI','B'+0x80
tib_lfa:
  dw r0_nfa
tib_:
  dw do_user
tib_pfa:
  db 0x04+0x06*old_origin?

width_nfa:
  db 0x05+0x80,'WIDT','H'+0x80
width_lfa:
  dw tib_nfa
width_:
  dw do_user
width_pfa:
  db 0x06+0x06*old_origin?

warning_nfa:
  db 0x07+0x80,'WARNIN','G'+0x80
warning_lfa:
  dw width_nfa
warning_:
  dw do_user
warning_pfa:
  db 0x08+0x06*old_origin?

fence_nfa:
  db 0x05+0x80,'FENC','E'+0x80
fence_lfa:
  dw warning_nfa
fence_:
  dw do_user
fence_pfa:
  db 0x0A+0x06*old_origin?

dp_nfa:
  db 0x02+0x80,'D','P'+0x80
dp_lfa:
  dw fence_nfa
dp_:
  dw do_user
dp_pfa:
  db 0x0C+0x06*old_origin?

voc_link_nfa:
  db 0x08+0x80,'VOC-LIN','K'+0x80
voc_link_lfa:
  dw dp_nfa
voc_link_:
  dw do_user
voc_link_pfa:
  db 0x0E+0x06*old_origin?

blk_nfa:
  db 0x03+0x80,'BL','K'+0x80
blk_lfa:
  dw voc_link_nfa
blk_:
  dw do_user
blk_pfa:
  db 0x10+0x06*old_origin?

in_nfa:
  db 0x02+0x80,'I','N'+0x80
in_lfa:
  dw blk_nfa
in_:
  dw do_user
in_pfa:
  db 0x12+0x06*old_origin?

out_nfa:
  db 0x03+0x80,'OU','T'+0x80
out_lfa:
  dw in_nfa
out_:
  dw do_user
out_pfa:
  db 0x14+0x06*old_origin?

scr_nfa:
  db 0x03+0x80,'SC','R'+0x80
scr_lfa:
  dw out_nfa
scr_:
  dw do_user
scr_pfa:
  db 0x16+0x06*old_origin?

offset_nfa:
  db 0x06+0x80,'OFFSE','T'+0x80
offset_lfa:
  dw scr_nfa
offset_:
  dw do_user
offset_pfa:
  db 0x18+0x06*old_origin?

context_nfa:
  db 0x07+0x80,'CONTEX','T'+0x80
context_lfa:
  dw offset_nfa
context_:
  dw do_user
context_pfa:
  db 0x1A+0x06*old_origin?

current_nfa:
  db 0x07+0x80,'CURREN','T'+0x80
current_lfa:
  dw context_nfa
current_:
  dw do_user
current_pfa:
  db 0x1C+0x06*old_origin?

state_nfa:
  db 0x05+0x80,'STAT','E'+0x80
state_lfa:
  dw current_nfa
state_:
  dw do_user
state_pfa:
  db 0x1E+0x06*old_origin?

base_nfa:
  db 0x04+0x80,'BAS','E'+0x80
base_lfa:
  dw state_nfa
base_:
  dw do_user
base_pfa:
  db 0x20+0x06*old_origin?

dpl_nfa:
  db 0x03+0x80,'DP','L'+0x80
dpl_lfa:
  dw base_nfa
dpl_:
  dw do_user
dpl_pfa:
  db 0x22+0x06*old_origin?

fld_nfa:
  db 0x03+0x80,'FL','D'+0x80
fld_lfa:
  dw dpl_nfa
fld_:
  dw do_user
fld_pfa:
  db 0x24+0x06*old_origin?

csp_nfa:
  db 0x03+0x80,'CS','P'+0x80
csp_lfa:
  dw fld_nfa
csp_:
  dw do_user
csp_pfa:
  db 0x26+0x06*old_origin?

r_hash_nfa:
  db 0x02+0x80,'R','#'+0x80
r_hash_lfa:
  dw csp_nfa
r_hash_:
  dw do_user
r_hash_pfa:
  db 0x28+0x06*old_origin?

hld_nfa:
  db 0x03+0x80,'HL','D'+0x80
hld_lfa:
  dw r_hash_nfa
hld_:
  dw do_user
hld_pfa:
  db 0x2A+0x06*old_origin?

recurse_nfa:
  db 0x07+0x80+precedence_bit_mask,'RECURS','E'+0x80
recurse_lfa:
  dw hld_nfa
recurse_:
  dw do_colon
recurse_pfa:
  dw latest_,nfa_to_pfa_,pfa_to_cfa_,comma_
  dw semicolon_s_

one_plus_nfa:
  db 0x02+0x80,'1','+'+0x80
one_plus_lfa:
  dw recurse_nfa
one_plus_:
  dw one_plus_pfa
one_plus_pfa:
  pop hl
  inc hl
  jp pushhl

two_plus_nfa:
  db 0x02+0x80,'2','+'+0x80
two_plus_lfa:
  dw one_plus_nfa
two_plus_:
  dw two_plus_pfa
two_plus_pfa:
  pop hl
  inc hl
  inc hl
  jp pushhl

one_minus_nfa:
  db 0x02+0x80,'1','-'+0x80
one_minus_lfa:
  dw two_plus_nfa
one_minus_:
  dw one_minus_pfa
one_minus_pfa:
  pop hl
  dec hl
  jp pushhl

two_minus_nfa:
  db 0x02+0x80,'2','-'+0x80
two_minus_lfa:
  dw one_minus_nfa
two_minus_:
  dw two_minus_pfa
two_minus_pfa:
  pop hl
  dec hl
  dec hl
  jp pushhl

two_star_nfa:
  db 0x02+0x80,'2','*'+0x80
two_star_lfa:
  dw two_minus_nfa
two_star_:
  dw two_star_pfa
two_star_pfa:
  pop hl
  add hl,hl
  jp pushhl

here_nfa:
  db 0x04+0x80,'HER','E'+0x80
here_lfa:
  dw two_star_nfa
here_:
  dw do_colon
here_pfa:
  dw dp_,fetch_
  dw semicolon_s_

allot_nfa:
  db 0x05+0x80,'ALLO','T'+0x80
allot_lfa:
  dw here_nfa
allot_:
  dw do_colon
allot_pfa:
  dw dp_
  dw plus_store_
  dw semicolon_s_

comma_nfa:
  db 0x01+0x80,'',','+0x80
comma_lfa:
  dw allot_nfa
comma_:
  dw do_colon
comma_pfa:
  dw here_
  dw store_
  dw two_
  dw allot_
  dw semicolon_s_

c_comma_nfa:
  db 0x02+0x80,'C',','+0x80
c_comma_lfa:
  dw comma_nfa
c_comma_:
  dw do_colon
c_comma_pfa:
  dw here_
  dw c_store_
  dw one_
  dw allot_
  dw semicolon_s_

minus_nfa:
  db 0x01+0x80,'','-'+0x80
minus_lfa:
  dw c_comma_nfa
minus_:
  dw minus_pfa
minus_pfa:
  pop de
  pop hl
  and a
  sbc hl,de
  jp pushhl

not_equals_nfa:
  db 0x02+0x80,'<','>'+0x80
not_equals_lfa:
  dw minus_nfa
not_equals_:
  dw not_equals_pfa
not_equals_pfa:
  pop hl
  pop de
  and a ; reset cy flag
  sbc hl,de
  ld a,h
  or l
  jp z,pushhl
  ld hl,true
  jp pushhl

equals_nfa:
  db 0x01+0x80,'','='+0x80
equals_lfa:
  dw not_equals_nfa
equals_:
  dw do_colon
equals_pfa:
  ; XXX TODO optimize
  dw minus_
  dw zero_equals_
  dw semicolon_s_

less_than_nfa:
  db 0x01+0x80,'','<'+0x80
less_than_lfa:
  dw equals_nfa
less_than_:
  dw less_than_pfa
less_than_pfa:
  pop de
  pop hl
  ld a,d
  xor h
  jp m,l6559h
  and a
  sbc hl,de
l6559h:
  inc h
  dec h
  jp m,l6564h
  ld hl,0x0000
  jp pushhl
l6564h:
  ld hl,0x0001
  jp pushhl

u_less_than_nfa:
  db 0x02+0x80,'U','<'+0x80
u_less_than_lfa:
  dw less_than_nfa
u_less_than_:
  dw do_colon
u_less_than_pfa:
  dw two_dup_
  dw xor_
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6585
  dw drop_
  dw zero_less_than_
  dw zero_equals_
  dw branch_,branch_destination_0x6589
branch_destination_0x6585:
  dw minus_
  dw zero_less_than_
branch_destination_0x6589:
  dw semicolon_s_

greater_than_nfa:
  db 0x01+0x80,'','>'+0x80
greater_than_lfa:
  dw u_less_than_nfa
greater_than_:
  dw do_colon
greater_than_pfa:
  dw swap_
  dw less_than_
  dw semicolon_s_

; XXX TMP -- written in the blocks disk instead
; minus_rot_nfa:
;   db 0x04+0x80,'-RO','T'+0x80
; minus_rot_lfa:
;   dw greater_than_nfa
; minus_rot_:
;   dw minus_rot_pfa
; minus_rot_pfa:
;   pop hl
;   pop de
;   ex (sp),hl
;   ex de,hl
;   jp pushde

rot_nfa:
  db 0x03+0x80,'RO','T'+0x80
rot_lfa:
  ; dw minus_rot_nfa ; XXX TMP
  dw greater_than_nfa
rot_:
  dw rot_pfa
rot_pfa:
  pop de
  pop hl
  ex (sp),hl
  jp pushde

space_nfa:
  db 0x05+0x80,'SPAC','E'+0x80
space_lfa:
  dw rot_nfa
space_:
  dw do_colon
space_pfa:
  dw b_l_
  dw emit_
  dw semicolon_s_

question_dup_nfa:
  db 0x04+0x80,'?DU','P'+0x80
question_dup_lfa:
  dw space_nfa
question_dup_:
  dw do_colon
question_dup_pfa:
  dw dup_
  dw zero_branch_,branch_destination_0x65C6
  dw dup_
branch_destination_0x65C6:
  dw semicolon_s_

traverse_nfa:
  db 0x08+0x80,'TRAVERS','E'+0x80
traverse_lfa:
  dw question_dup_nfa
traverse_:
  dw do_colon
traverse_pfa:
  dw swap_
traverse.begin:
  dw over_,plus_
  dw c_lit_
  db 0x7F
  dw over_,c_fetch_,less_than_
  dw zero_branch_,traverse.begin ; until
  dw swap_,drop_
  dw semicolon_s_

latest_nfa:
  db 0x06+0x80,'LATES','T'+0x80
latest_lfa:
  dw traverse_nfa
latest_:
  dw do_colon
latest_pfa:
  dw current_,fetch_,fetch_
  dw semicolon_s_

pfa_to_lfa_nfa:
  db 0x07+0x80,'PFA>LF','A'+0x80
pfa_to_lfa_lfa:
  dw latest_nfa
pfa_to_lfa_:
  dw do_colon
pfa_to_lfa_pfa:
  dw c_lit_
  db 0x04
  dw minus_
  dw semicolon_s_

pfa_to_cfa_nfa:
  db 0x07+0x80,'PFA>CF','A'+0x80
pfa_to_cfa_lfa:
  dw pfa_to_lfa_nfa
pfa_to_cfa_:
  dw do_colon
pfa_to_cfa_pfa:
  dw two_
  dw minus_
  dw semicolon_s_

pfa_to_nfa_nfa:
  db 0x07+0x80,'PFA>NF','A'+0x80
pfa_to_nfa_lfa:
  dw pfa_to_cfa_nfa
pfa_to_nfa_:
  dw do_colon
pfa_to_nfa_pfa:
  ; XXX TODO optimize
  dw c_lit_
  db 0x05
  dw minus_
  dw lit_,0xFFFF
  dw traverse_
  dw semicolon_s_

nfa_to_pfa_nfa:
  db 0x07+0x80,'NFA>PF','A'+0x80
nfa_to_pfa_lfa:
  dw pfa_to_nfa_nfa
nfa_to_pfa_:
  dw do_colon
nfa_to_pfa_pfa:
  dw one_
  dw traverse_
  dw c_lit_
  db 0x05
  dw plus_
  dw semicolon_s_

store_csp_nfa:
  db 0x04+0x80,'!CS','P'+0x80
store_csp_lfa:
  dw nfa_to_pfa_nfa
store_csp_:
  dw do_colon
store_csp_pfa:
  dw sp_fetch_
  dw csp_
  dw store_
  dw semicolon_s_

question_error_nfa:
  db 0x06+0x80,'?ERRO','R'+0x80
question_error_lfa:
  dw store_csp_nfa
question_error_:
  dw do_colon
question_error_pfa:
  dw swap_
  dw zero_branch_,branch_destination_0x6672
  dw error_
  dw branch_,branch_destination_0x6674
branch_destination_0x6672:
  dw drop_
branch_destination_0x6674:
  dw semicolon_s_

question_comp_nfa:
  db 0x05+0x80,'?COM','P'+0x80
question_comp_lfa:
  dw question_error_nfa
question_comp_:
  dw do_colon
question_comp_pfa:
  dw state_,fetch_,zero_equals_
  dw c_lit_
  db 0x11
  dw question_error_
  dw semicolon_s_

question_exec_nfa:
  db 0x05+0x80,'?EXE','C'+0x80
question_exec_lfa:
  dw question_comp_nfa
question_exec_:
  dw do_colon
question_exec_pfa:
  dw state_,fetch_
  dw c_lit_
  db 0x12
  dw question_error_
  dw semicolon_s_

question_pairs_nfa:
  db 0x06+0x80,'?PAIR','S'+0x80
question_pairs_lfa:
  dw question_exec_nfa
question_pairs_:
  dw do_colon
question_pairs_pfa:
  dw minus_
  dw c_lit_
  db 0x13
  dw question_error_
  dw semicolon_s_

question_csp_nfa:
  db 0x04+0x80,'?CS','P'+0x80
question_csp_lfa:
  dw question_pairs_nfa
question_csp_:
  dw do_colon
question_csp_pfa:
  dw sp_fetch_,csp_,fetch_,not_equals_
  dw c_lit_
  db 0x14
  dw question_error_
  dw semicolon_s_

question_loading_nfa:
  db 0x08+0x80,'?LOADIN','G'+0x80
question_loading_lfa:
  dw question_csp_nfa
question_loading_:
  dw do_colon
question_loading_pfa:
  dw blk_,fetch_,zero_equals_
  dw c_lit_
  db 0x16
  dw question_error_
  dw semicolon_s_

compile_nfa:
  db 0x07+0x80,'COMPIL','E'+0x80
compile_lfa:
  dw question_loading_nfa
compile_:
  dw do_colon
compile_pfa:
  dw question_comp_
  dw from_r_
  dw dup_
  dw two_plus_
  dw to_r_,fetch_
  dw comma_
  dw semicolon_s_

left_bracket_nfa:
  db 0x01+0x80+precedence_bit_mask,'','['+0x80
left_bracket_lfa:
  dw compile_nfa
left_bracket_:
  dw do_colon
left_bracket_pfa:
  dw zero_
  dw state_
  dw store_
  dw semicolon_s_

right_bracket_nfa:
  db 0x01+0x80,'',']'+0x80
right_bracket_lfa:
  dw left_bracket_nfa
right_bracket_:
  dw do_colon
right_bracket_pfa:
  dw c_lit_
  db 0xC0
  dw state_
  dw store_
  dw semicolon_s_

smudge_nfa:
  db 0x06+0x80,'SMUDG','E'+0x80
smudge_lfa:
  dw right_bracket_nfa
smudge_:
  dw do_colon
smudge_pfa:
  dw latest_
  dw lit_,smudge_bit_mask
  dw toggle_
  dw semicolon_s_

hex_nfa:
  db 0x03+0x80,'HE','X'+0x80
hex_lfa:
  dw smudge_nfa
hex_:
  dw do_colon
hex_pfa:
  dw c_lit_
  db 0x10
  dw base_
  dw store_
  dw semicolon_s_

decimal_nfa:
  db 0x07+0x80,'DECIMA','L'+0x80
decimal_lfa:
  dw hex_nfa
decimal_:
  dw do_colon
decimal_pfa:
  dw c_lit_
  db 0x0A
  dw base_
  dw store_
  dw semicolon_s_

paren_semicolon_code_nfa:
  db 0x07+0x80,'(;CODE',')'+0x80
paren_semicolon_code_lfa:
  dw decimal_nfa
paren_semicolon_code_:
  dw do_colon
paren_semicolon_code_pfa:
  dw from_r_
  dw latest_
  dw nfa_to_pfa_
  dw pfa_to_cfa_
  dw store_
  dw semicolon_s_

semicolon_code_nfa:
  db 0x05+0x80+precedence_bit_mask,';COD','E'+0x80
semicolon_code_lfa:
  dw paren_semicolon_code_nfa
semicolon_code_:
  dw do_colon
semicolon_code_pfa:
  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw left_bracket_
  dw smudge_
  dw semicolon_s_

builds_nfa:
  db 0x07+0x80,'<BUILD','S'+0x80
builds_lfa:
  dw semicolon_code_nfa
builds_:
  dw do_colon
builds_pfa:
  dw zero_
  dw constant_
  dw semicolon_s_

does_nfa:
  db 0x05+0x80,'DOES','>'+0x80
does_lfa:
  dw builds_nfa
does_:
  dw do_colon
does_pfa:
  dw from_r_
  dw latest_
  dw nfa_to_pfa_
  dw store_
  dw paren_semicolon_code_
do_does:
  ld hl,(return_pointer_value)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_pointer_value),hl
  inc de      ; de=pfa
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  jp pushhl

count_nfa:
  db 0x05+0x80,'COUN','T'+0x80
count_lfa:
  dw does_nfa
count_:
  dw do_colon
count_pfa:
  dw dup_
  dw one_plus_
  dw swap_
  dw c_fetch_
  dw semicolon_s_

bounds_nfa:
  db 0x06+0x80,'BOUND','S'+0x80
bounds_lfa:
  dw count_nfa
bounds_:
  dw do_colon
bounds_pfa:
  dw over_
  dw plus_
  dw swap_
  dw semicolon_s_

type_nfa:
  db 0x04+0x80,'TYP','E'+0x80
type_lfa:
  dw bounds_nfa
type_:
  dw do_colon
type_pfa:
  dw question_dup_
  dw zero_branch_,type.empty_string
  dw bounds_
  dw paren_do_
type.do:
  dw i_
  dw c_fetch_
  dw emit_
  dw paren_loop_,type.do ; loop
  dw branch_,type.end
type.empty_string:
  dw drop_
type.end:
  dw semicolon_s_

minus_trailing_nfa:
  db 0x09+0x80,'-TRAILIN','G'+0x80
minus_trailing_lfa:
  dw type_nfa
minus_trailing_:
  dw do_colon
minus_trailing_pfa:
  dw dup_
  dw zero_
  dw paren_do_
branch_destination_0x681C:
  dw over_
  dw over_
  dw plus_
  dw one_
  dw minus_
  dw c_fetch_
  dw b_l_
  dw minus_
  dw zero_branch_,branch_destination_0x6836
  dw leave_
  dw branch_,branch_destination_0x683A
branch_destination_0x6836:
  dw one_
  dw minus_
branch_destination_0x683A:
  dw paren_loop_,branch_destination_0x681C
  dw semicolon_s_

paren_dot_quote_nfa:
  db 0x04+0x80,'(."',')'+0x80
paren_dot_quote_lfa:
  dw minus_trailing_nfa
paren_dot_quote_:
  dw do_colon
paren_dot_quote_pfa:
  dw r_fetch_
  dw count_
  dw dup_
  dw one_plus_
  dw from_r_
  dw plus_
  dw to_r_
  dw type_
  dw semicolon_s_

dot_quote_nfa:
  db 0x02+0x80+precedence_bit_mask,'.','"'+0x80
dot_quote_lfa:
  dw paren_dot_quote_nfa
dot_quote_:
  dw do_colon
dot_quote_pfa:
  dw c_lit_
  db 0x22
  dw state_,fetch_
  dw zero_branch_,branch_destination_0x6880
  dw compile_,paren_dot_quote_
  dw word_
  dw here_
  dw c_fetch_
  dw one_plus_
  dw allot_
  dw branch_,branch_destination_0x6888
branch_destination_0x6880:
  dw word_
  dw here_
  dw count_
  dw type_
branch_destination_0x6888:
  dw semicolon_s_

expect_nfa:
  db 0x06+0x80,'EXPEC','T'+0x80
expect_lfa:
  dw dot_quote_nfa
expect_:
  dw do_colon
expect_pfa:
  dw over_
  dw plus_
  dw over_
  dw paren_do_
branch_destination_0x689D:
  dw key_
  dw dup_
  dw c_lit_
  db 0x0C ; backspace_char
  dw equals_
  dw zero_branch_,branch_destination_0x68D7
  dw drop_
  dw dup_
  dw i_
  dw equals_
  dw dup_
  dw from_r_
  dw two_
  dw minus_
  dw plus_
  dw to_r_
  dw zero_branch_,branch_destination_0x68CF
  dw noop_
  dw noop_
  dw branch_,branch_destination_0x68FF
branch_destination_0x68CF:
  dw c_lit_
  db 0x08
  dw branch_,branch_destination_0x68FD
branch_destination_0x68D7:
  dw dup_
  dw c_lit_
  db 0x0D
  dw equals_
  dw zero_branch_,branch_destination_0x68EF
  dw leave_
  dw drop_
  dw b_l_
  dw zero_
  dw branch_,branch_destination_0x68F1
branch_destination_0x68EF:
  dw dup_
branch_destination_0x68F1:
  dw i_
  dw c_store_
  dw zero_
  dw i_
  dw one_plus_
  dw store_
branch_destination_0x68FD:
  dw emit_
branch_destination_0x68FF:
  dw paren_loop_,branch_destination_0x689D
  dw drop_
  dw semicolon_s_

query_nfa:
  db 0x05+0x80,'QUER','Y'+0x80
query_lfa:
  dw expect_nfa
query_:
  dw do_colon
query_pfa:
  dw tib_,fetch_
  dw c_lit_
  db bytes_per_terminal_input_buffer
  dw expect_
  dw zero_
  dw in_
  dw store_
  dw semicolon_s_

onezeroword_nfa:
  db 0x01+0x80+precedence_bit_mask,'',0x80
onezeroword_lfa:
  dw query_nfa
onezeroword_:
  dw do_colon
onezeroword_pfa:
  dw blk_,fetch_
  dw zero_branch_,branch_destination_0x6959
  dw one_
  dw blk_
  dw plus_store_
  dw zero_
  dw in_
  dw store_
  dw blk_,fetch_
  dw b_slash_scr_
  dw one_
  dw minus_
  dw and_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x6955
  dw question_exec_
  dw from_r_
  dw drop_
branch_destination_0x6955:
  dw branch_,branch_destination_0x695D
branch_destination_0x6959:
  dw from_r_
  dw drop_
branch_destination_0x695D:
  dw semicolon_s_

fill_nfa:
  db 0x04+0x80,'FIL','L'+0x80
fill_lfa:
  dw onezeroword_nfa
fill_:
  dw fill_pfa
fill_pfa:
  ld l,c
  ld h,b
  pop de
  pop bc
  ex (sp),hl
  ex de,hl
l696eh:
  ld a,b
  or c
  jr z,l6978h
  ld a,l
  ld (de),a
  inc de
  dec bc
  jr l696eh
l6978h:
  pop bc
  jp next

erase_nfa:
  db 0x05+0x80,'ERAS','E'+0x80
erase_lfa:
  dw fill_nfa
erase_:
  dw do_colon
erase_pfa:
  dw zero_
  dw fill_
  dw semicolon_s_

blanks_nfa:
  db 0x06+0x80,'BLANK','S'+0x80
blanks_lfa:
  dw erase_nfa
blanks_:
  dw do_colon
blanks_pfa:
  dw b_l_
  dw fill_
  dw semicolon_s_

hold_nfa:
  db 0x04+0x80,'HOL','D'+0x80
hold_lfa:
  dw blanks_nfa
hold_:
  dw do_colon
hold_pfa:
  dw lit_,0xFFFF,hld_,plus_store_
  dw hld_,fetch_,c_store_
  dw semicolon_s_

pad_nfa:
  db 0x03+0x80,'PA','D'+0x80
pad_lfa:
  dw hold_nfa
pad_:
  dw do_colon
pad_pfa:
  dw here_
  dw c_lit_
  db 0x44
  dw plus_
  dw semicolon_s_

word_nfa:
  db 0x04+0x80,'WOR','D'+0x80
word_lfa:
  dw pad_nfa
word_:
  dw do_colon
word_pfa:
  dw blk_,fetch_
  dw zero_branch_,branch_destination_0x69E3
  dw blk_,fetch_,block_
  dw branch_,branch_destination_0x69E7
branch_destination_0x69E3:
  dw tib_,fetch_
branch_destination_0x69E7:
  dw in_,fetch_
  dw plus_
  dw swap_
  dw enclose_
  dw here_
  dw c_lit_
  db 0x22
  dw blanks_
  dw in_
  dw plus_store_
  dw over_
  dw minus_
  dw to_r_
  dw r_fetch_
  dw here_
  dw c_store_
  dw plus_
  dw here_
  dw one_plus_
  dw from_r_
  dw cmove_
  dw semicolon_s_

paren_number_nfa:
  db 0x08+0x80,'(NUMBER',')'+0x80
paren_number_lfa:
  dw word_nfa
paren_number_:
  dw do_colon
branch_destination_0x6A22:
paren_number_pfa:
  dw one_plus_
  dw dup_
  dw to_r_
  dw c_fetch_
  dw base_,fetch_
  dw digit_
  dw zero_branch_,branch_destination_0x6A5E
  dw swap_
  dw base_,fetch_
  dw u_star_
  dw drop_
  dw rot_
  dw base_,fetch_
  dw u_star_
  dw d_plus_
  dw dpl_,fetch_
  dw one_plus_
  dw zero_branch_,branch_destination_0x6A58
  dw one_
  dw dpl_
  dw plus_store_
branch_destination_0x6A58:
  dw from_r_
  dw branch_,branch_destination_0x6A22
branch_destination_0x6A5E:
  dw from_r_
  dw semicolon_s_

number_nfa:
  db 0x06+0x80,'NUMBE','R'+0x80
number_lfa:
  dw paren_number_nfa
number_:
  dw do_colon
number_pfa:
  dw zero_
  dw zero_
  dw rot_
  dw dup_
  dw one_plus_
  dw c_fetch_
  dw c_lit_
  db 0x2D
  dw equals_
  dw dup_
  dw to_r_
  dw plus_
  dw lit_,0xFFFF
branch_destination_0x6A89:
  dw dpl_
  dw store_
  dw paren_number_
  dw dup_
  dw c_fetch_
  dw b_l_
  dw minus_
  dw zero_branch_,branch_destination_0x6AAF
  dw dup_
  dw c_fetch_
  dw c_lit_
  db 0x2E
  dw minus_ ; XXX TODO not_equals_
  dw one_
  dw question_error_
  dw zero_
  dw branch_,branch_destination_0x6A89
branch_destination_0x6AAF:
  dw drop_
  dw from_r_
  dw zero_branch_,branch_destination_0x6AB9
  dw dnegate_
branch_destination_0x6AB9:
  dw semicolon_s_

upperc_nfa:
  db 0x06+0x80,'UPPER','C'+0x80
upperc_lfa:
  dw number_nfa
upperc_:
  dw upperc_pfa
upperc_pfa:
  pop hl
  ld a,l
  call upperc.a
  ld l,a
  jp pushhl

upperc.a:
  ; Convert the char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

uppers_nfa:
  db 0x06+0x80,'UPPER','S'+0x80
uppers_lfa:
  dw upperc_nfa
uppers_:
  dw uppers_pfa
uppers_pfa:
  pop de
  pop hl
uppers_pfa.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upperc.a
  ld (hl),a
  inc hl
  dec de
  jp uppers_pfa.do

minus_find_nfa:
  db 0x05+0x80,'-FIN','D'+0x80
minus_find_lfa:
  dw uppers_nfa
minus_find_:
  dw do_colon
minus_find_pfa:
  dw b_l_,word_
  dw here_,count_,uppers_,here_
  dw context_,fetch_,fetch_
  dw paren_find_
  dw dup_,zero_equals_ ; found?
  dw zero_branch_,minus_find.end
  ; The word was not found in the context vocabulary,
  ; try again in the current vocabulary.
  ; XXX TODO -- remove this?
  dw drop_,here_,latest_,paren_find_
minus_find.end:
  dw semicolon_s_

paren_abort_nfa:
  db 0x07+0x80,'(ABORT',')'+0x80
paren_abort_lfa:
  dw minus_find_nfa
paren_abort_:
  dw do_colon
paren_abort_pfa:
  dw abort_
  dw semicolon_s_

error_nfa:
  db 0x05+0x80,'ERRO','R'+0x80
error_lfa:
  dw paren_abort_nfa
error_:
  dw do_colon
error_pfa:
  dw warning_,fetch_,zero_less_than_
  dw zero_branch_,branch_destination_0x6B0B
  dw paren_abort_
branch_destination_0x6B0B:
  dw here_
  dw count_
  dw type_
  dw paren_dot_quote_
  _string '? '
  dw message_
  dw sp_store_
  dw blk_,fetch_,question_dup_
  dw zero_branch_,branch_destination_0x6B2A
  dw in_,fetch_
  dw swap_
branch_destination_0x6B2A:
  dw quit_

id_dot_nfa:
  db 0x03+0x80,'ID','.'+0x80
id_dot_lfa:
  dw error_nfa
id_dot_:
  dw do_colon
id_dot_pfa:
  dw pad_
  dw c_lit_
  db 0x20
  dw c_lit_
  db 0x5F ; XXX why this char?
  dw fill_
  dw dup_
  dw nfa_to_pfa_
  dw pfa_to_lfa_
  dw over_
  dw minus_
  dw pad_
  dw swap_
  dw cmove_
  dw pad_
  dw count_
  dw c_lit_
  db 0x1F
  dw and_
  dw two_dup_
  dw plus_
  dw one_
  dw minus_
  dw dup_
  dw fetch_
  dw lit_,0xFF7F
  dw and_
  dw swap_
  dw store_
  dw type_
  dw space_
  dw semicolon_s_

create_nfa:
  db 0x06+0x80,'CREAT','E'+0x80
create_lfa:
  dw id_dot_nfa
create_:
  dw do_colon
create_pfa:
  dw minus_find_
  dw zero_branch_,create.continue
  ; The word is not unique.
  dw drop_,pfa_to_nfa_,id_dot_
  dw c_lit_
  db 0x04
  dw message_,space_
create.continue:
  dw here_
  dw dup_,c_fetch_,width_,fetch_,min_
  dw one_plus_,allot_
  dw dup_
  dw c_lit_
  db 0xA0 ; XXX TODO document
  dw toggle_
  dw here_,one_,minus_
  dw c_lit_
  db 0x80 ; XXX TODO document
  dw toggle_
  dw latest_,comma_
  dw current_,fetch_,store_
  dw here_,two_plus_,comma_
  dw semicolon_s_

bracket_compile_nfa:
  db 0x09+0x80+precedence_bit_mask,'[COMPILE',']'+0x80
bracket_compile_lfa:
  dw create_nfa
bracket_compile_:
  dw do_colon
bracket_compile_pfa:
  dw minus_find_,zero_equals_
  dw one_,question_error_
  dw drop_,pfa_to_cfa_,comma_
  dw semicolon_s_

c_literal_nfa:
  db 0x08+0x80+precedence_bit_mask,'CLITERA','L'+0x80
c_literal_lfa:
  dw bracket_compile_nfa
c_literal_:
  dw do_colon
c_literal_pfa:
  if 1 ; XXX OLD 
    dw state_,fetch_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw compile_,c_lit_,comma_
  endif
  dw semicolon_s_

literal_nfa:
  db 0x07+0x80+precedence_bit_mask,'LITERA','L'+0x80
literal_lfa:
  dw c_literal_nfa
literal_:
  dw do_colon
literal_pfa:
  if 1 ; XXX OLD 
    dw state_,fetch_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw compile_,lit_,comma_
  endif
  dw semicolon_s_

two_literal_nfa:
  db 0x08+0x80+precedence_bit_mask,'2LITERA','L'+0x80
two_literal_lfa:
  dw literal_nfa
two_literal_:
  dw do_colon
two_literal_pfa:
  if 1 ; XXX OLD 
    dw state_,fetch_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    ; XXX TODO -- dlit
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw swap_,literal_,literal_
  endif
  dw semicolon_s_

depth_nfa:
  db 0x05+0x80,'DEPT','H'+0x80
depth_lfa:
  dw two_literal_nfa
depth_:
  dw do_colon
depth_pfa:
  dw sp_fetch_,s0_,fetch_,minus_,lit_,-2,slash_
  dw semicolon_s_

question_stack_nfa:
  db 0x06+0x80,'?STAC','K'+0x80
question_stack_lfa:
  dw depth_nfa
question_stack_:
  dw do_colon
question_stack_pfa:
  dw sp_fetch_
  dw s0_,fetch_
  dw swap_,less_than_
  dw two_,question_error_
  dw sp_fetch_
  dw lit_,data_stack_limit

  ; XXX INFORMER
  ;dw two_dup_,two_swap_,u_dot_,u_dot_,cr_

  dw less_than_

  ; XXX FIXME why the overflow is not detected?
  ; XXX INFORMER
  ;dw dup_
  ;dw zero_branch_,question_stack.continue
  ;dw two_,border_,key_,drop_
;question_stack.continue:

  dw c_lit_
  db 0x07
  dw question_error_
  dw semicolon_s_

; XXX TODO -- In order to change the behaviour of `literal`, `2literal`
; and `cliteral` (make them give an error in interpretation mode),
; `interpret` must be modified.

interpret_nfa:
  db 0x09+0x80,'INTERPRE','T'+0x80
interpret_lfa:
  dw question_stack_nfa
interpret_:
  dw do_colon
branch_destination_0x6C5D:
interpret_pfa:
  dw minus_find_ ; begin
  dw zero_branch_,branch_destination_0x6C7F ; if
  dw state_,fetch_,less_than_
  dw zero_branch_,branch_destination_0x6C75 ; if
  dw pfa_to_cfa_,comma_
  dw branch_,branch_destination_0x6C79 ; else
branch_destination_0x6C75:
  dw pfa_to_cfa_
  dw execute_ ; then
branch_destination_0x6C79:
  dw question_stack_
  dw branch_,branch_destination_0x6C99 ; else
branch_destination_0x6C7F:
  dw here_
  dw number_
  dw dpl_,fetch_
  dw one_plus_
  dw zero_branch_,branch_destination_0x6C93 ; if
  dw two_literal_
  dw branch_,branch_destination_0x6C97 ; else
branch_destination_0x6C93:
  dw drop_
  ; XXX TODO use `c_literal` for 8 bit values.
  dw literal_ ; then
branch_destination_0x6C97:
  dw question_stack_ ; then
branch_destination_0x6C99:
  dw branch_,branch_destination_0x6C5D ; again

immediate_nfa:
  db 0x09+0x80,'IMMEDIAT','E'+0x80
immediate_lfa:
  dw interpret_nfa
immediate_:
  dw do_colon
immediate_pfa:
  dw latest_
  dw c_lit_
  db precedence_bit_mask
  dw toggle_
  dw semicolon_s_

vocabulary_nfa:
  db 0x0A+0x80,'VOCABULAR','Y'+0x80
vocabulary_lfa:
  dw immediate_nfa
vocabulary_:
  dw do_colon
vocabulary_pfa:
  dw builds_
  dw lit_,0xA081 ; Dummy name field.
  dw comma_
  dw current_,fetch_,pfa_to_cfa_
  dw comma_
  dw here_
  dw voc_link_,fetch_
  dw comma_
  dw voc_link_,store_
  dw does_
do_vocabulary:
  dw two_plus_
  dw context_
  dw store_
  dw semicolon_s_

forth_nfa:
  db 0x05+0x80,'FORT','H'+0x80
forth_lfa:
  dw vocabulary_nfa
forth_:
  dw do_does
forth_pfa:
  dw do_vocabulary
forth_vocabulary_dummy_nfa:
  dw 0xA081 ; Dummy name field.
forth_vocabulary_latest:
  dw nfa_of_top_most_word_in_forth_voc
forth_vocabulary_link:
  dw 0x0000

definitions_nfa:
  db 0x0B+0x80,'DEFINITION','S'+0x80
definitions_lfa:
  dw forth_nfa
definitions_:
  dw do_colon
definitions_pfa:
  dw context_,fetch_
  dw current_,store_
  dw semicolon_s_

paren_nfa:
  db 0x01+0x80+precedence_bit_mask,'','('+0x80
paren_lfa:
  dw definitions_nfa
paren_:
  dw do_colon
paren_pfa:
  dw c_lit_
  db 0x29
  dw word_
  dw semicolon_s_

quit_nfa:
  db 0x04+0x80,'QUI','T'+0x80
quit_lfa:
  dw paren_nfa
quit_:
  dw do_colon
quit_pfa:
  dw zero_,blk_,store_
  dw left_bracket_
quit.do:
  dw rp_store_
  dw cr_
  dw query_
  ;dw two_,border_,key_,drop_ ; XXX INFORMER
  dw interpret_
  dw state_,fetch_
  dw question_branch_,quit.do
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw paren_dot_quote_
  _string 'ok'
  ;dw lit_,3,border_,key_,drop_ ; XXX INFORMER
  dw branch_,quit.do

greeting_nfa:
  db 0x08+0x80,'GREETIN','G'+0x80
greeting_lfa:
  dw quit_nfa
greeting_:
  dw do_colon
greeting_pfa:
  dw paren_dot_quote_
  _string "F+D Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  dw semicolon_s_

abort_nfa:
  db 0x05+0x80,'ABOR','T'+0x80
abort_lfa:
  dw greeting_nfa
abort_:
  dw do_colon
abort_pfa:
  dw sp_store_
  dw decimal_
  dw question_stack_
  dw cls_,greeting_
  dw forth_,definitions_
  dw quit_

warm_start:
  ld bc,warm_start_phony_
  ld ix,(user_pointer_value)
  ld hl,(init_s0_value)
  ld sp,hl
  jp next
warm_start_phony_:
  dw warm_

warm_nfa:
  db 0x04+0x80,'WAR','M'+0x80
warm_lfa:
  dw abort_nfa
warm_:
  dw do_colon
warm_pfa:
  dw empty_buffers_
  dw abort_

cold_start:
  xor a
  ; ld (iy+sys_df_sz_offset),a ; XXX TMP
  ld (printer_channel_or_zero),a
  ld ix,(user_pointer_value)
  ld hl,(init_s0_value)
  ld sp,hl
  ld bc,cold_start_phony_
  jp next
cold_start_phony_:
  dw cold_

cold_nfa:
  db 0x04+0x80,'COL','D'+0x80
cold_lfa:
  dw warm_nfa
cold_:
  dw do_colon
cold_pfa:
  dw empty_buffers_
  dw first_,dup_,use_,store_,prev_,store_
  dw dr0_
  dw lit_,init_s0_value
  dw lit_,user_pointer_value,fetch_
  if old_origin?
  dw c_lit_
  db 0x06 ; XXX TODO -- avoid this gap
  dw plus_
  endif
  dw c_lit_
  db 0x10 ; 0x08 user variables are set to their default values
  dw cmove_
  dw lit_,top_most_word_in_forth_voc
  dw fetch_
  dw lit_,forth_vocabulary_latest
  dw store_
  dw abort_

s_to_d_nfa:
  db 0x03+0x80,'S>','D'+0x80
s_to_d_lfa:
  dw cold_nfa
s_to_d_:
  dw s_to_d_pfa
s_to_d_pfa:
  pop de
  ld hl,0x0000
  ld a,d
  and 0x80
  jr z,l6e1dh
  dec hl
l6e1dh:
  jp pushde

plus_minus_nfa:
  db 0x02+0x80,'+','-'+0x80
plus_minus_lfa:
  dw s_to_d_nfa
plus_minus_:
  dw do_colon
plus_minus_pfa:
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6E2F
  dw negate_
branch_destination_0x6E2F:
  dw semicolon_s_

d_plus_minus_nfa:
  db 0x03+0x80,'D+','-'+0x80
d_plus_minus_lfa:
  dw plus_minus_nfa
d_plus_minus_:
  dw do_colon
d_plus_minus_pfa:
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6E41
  dw dnegate_
branch_destination_0x6E41:
  dw semicolon_s_

abs_nfa:
  db 0x03+0x80,'AB','S'+0x80
abs_lfa:
  dw d_plus_minus_nfa
abs_:
  dw do_colon
abs_pfa:
  dw dup_
  dw plus_minus_
  dw semicolon_s_

dabs_nfa:
  db 0x04+0x80,'DAB','S'+0x80
dabs_lfa:
  dw abs_nfa
dabs_:
  dw do_colon
dabs_pfa:
  dw dup_
  dw d_plus_minus_
  dw semicolon_s_

min_nfa:
  db 0x03+0x80,'MI','N'+0x80
min_lfa:
  dw dabs_nfa
min_:
  dw do_colon
min_pfa:
  dw two_dup_
  dw greater_than_
  dw zero_branch_,branch_destination_0x6E72
  dw swap_
branch_destination_0x6E72:
  dw drop_
  dw semicolon_s_

max_nfa:
  db 0x03+0x80,'MA','X'+0x80
max_lfa:
  dw min_nfa
max_:
  dw do_colon
max_pfa:
  dw two_dup_
  dw less_than_
  dw zero_branch_,branch_destination_0x6E88
  dw swap_
branch_destination_0x6E88:
  dw drop_
  dw semicolon_s_

m_star_nfa:
  db 0x02+0x80,'M','*'+0x80
m_star_lfa:
  dw max_nfa
m_star_:
  dw do_colon
m_star_pfa:
  dw two_dup_
  dw xor_
  dw to_r_
  dw abs_
  dw swap_
  dw abs_
  dw u_star_
  dw from_r_
  dw d_plus_minus_
  dw semicolon_s_

m_slash_nfa:
  db 0x02+0x80,'M','/'+0x80
m_slash_lfa:
  dw m_star_nfa
m_slash_:
  dw do_colon
m_slash_pfa:
  dw over_
  dw to_r_
  dw to_r_
  dw dabs_
  dw r_fetch_
  dw abs_
  dw u_slash_mod_
  dw from_r_
  dw r_fetch_
  dw xor_
  dw plus_minus_
  dw swap_
  dw from_r_
  dw plus_minus_
  dw swap_
  dw semicolon_s_

star_nfa:
  db 0x01+0x80,'','*'+0x80
star_lfa:
  dw m_slash_nfa
star_:
  dw do_colon
star_pfa:
  dw m_star_
  dw drop_
  dw semicolon_s_

slash_mod_nfa:
  db 0x04+0x80,'/MO','D'+0x80
slash_mod_lfa:
  dw star_nfa
slash_mod_:
  dw do_colon
slash_mod_pfa:
  dw to_r_
  dw s_to_d_
  dw from_r_
  dw m_slash_
  dw semicolon_s_

slash_nfa:
  db 0x01+0x80,'','/'+0x80
slash_lfa:
  dw slash_mod_nfa
slash_:
  dw do_colon
slash_pfa:
  dw slash_mod_
  dw swap_
  dw drop_
  dw semicolon_s_

mod_nfa:
  db 0x03+0x80,'MO','D'+0x80
mod_lfa:
  dw slash_nfa
mod_:
  dw do_colon
mod_pfa:
  dw slash_mod_
  dw drop_
  dw semicolon_s_

star_slash_mod_nfa:
  db 0x05+0x80,'*/MO','D'+0x80
star_slash_mod_lfa:
  dw mod_nfa
star_slash_mod_:
  dw do_colon
star_slash_mod_pfa:
  dw to_r_
  dw m_star_
  dw from_r_
  dw m_slash_
  dw semicolon_s_

star_slash_nfa:
  db 0x02+0x80,'*','/'+0x80
star_slash_lfa:
  dw star_slash_mod_nfa
star_slash_:
  dw do_colon
star_slash_pfa:
  dw star_slash_mod_
  dw swap_
  dw drop_
  dw semicolon_s_

m_slash_mod_nfa:
  db 0x05+0x80,'M/MO','D'+0x80
m_slash_mod_lfa:
  dw star_slash_nfa
m_slash_mod_:
  dw do_colon
m_slash_mod_pfa:
  dw to_r_
  dw zero_
  dw r_fetch_
  dw u_slash_mod_
  dw from_r_
  dw swap_
  dw to_r_
  dw u_slash_mod_
  dw from_r_
  dw semicolon_s_

paren_line_nfa:
  db 0x06+0x80,'(LINE',')'+0x80
paren_line_lfa:
  dw m_slash_mod_nfa
paren_line_:
  dw do_colon
paren_line_pfa:
  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_,b_slash_scr_,star_,plus_
  dw block_,plus_,c_slash_l_
  dw semicolon_s_

dot_line_nfa:
  db 0x05+0x80,'.LIN','E'+0x80
dot_line_lfa:
  dw paren_line_nfa
dot_line_:
  dw do_colon
dot_line_pfa:
  dw paren_line_,minus_trailing_,type_
  dw semicolon_s_

message_nfa:
  db 0x07+0x80,'MESSAG','E'+0x80
message_lfa:
  dw dot_line_nfa
message_:
  dw do_colon
message_pfa:
  dw warning_,fetch_
  dw zero_branch_,branch_destination_0x6FB3
  dw question_dup_
  dw zero_branch_,branch_destination_0x6FAF
  dw c_lit_
  db 0x04
  ; XXX OLD
  ; dw offset_
  ; dw fetch_
  ; dw b_slash_scr_
  ; dw slash_
  ; dw minus_
  dw dot_line_
  dw space_
branch_destination_0x6FAF:
  dw branch_,branch_destination_0x6FBE
branch_destination_0x6FB3:
  dw paren_dot_quote_
  _string 'MSG # '
  dw dot_
branch_destination_0x6FBE:
  dw semicolon_s_

use_nfa:
  db 0x03+0x80,'US','E'+0x80
use_lfa:
  dw message_nfa
use_:
  dw do_variable
use_pfa:
  dw first_buffer

prev_nfa:
  db 0x04+0x80,'PRE','V'+0x80
prev_lfa:
  dw use_nfa
prev_:
  dw do_variable
prev_pfa:
  dw first_buffer

hash_buff_nfa:
  db 0x05+0x80,'#BUF','F'+0x80
hash_buff_lfa:
  dw prev_nfa
hash_buff_:
  dw do_constant
hash_buff_pfa:
  dw 0x0008

; doc{

; +BUF  ( a1 -- a2 f )

;   Advance the disk buffer address _a1_ to the address of the next
;   buffer _a2_.  Boolean _f_ is false when _a2_ is the buffer
;   presently pointed to by the variable `prev`.

; }doc


plus_buf_nfa:
  db 0x04+0x80,'+BU','F'+0x80
plus_buf_lfa:
  dw hash_buff_nfa
plus_buf_:
  dw do_colon
plus_buf_pfa:
  dw lit_,total_bytes_per_buffer,plus_ ; a2
  dw dup_,limit_,equals_ ; out of bounds?
  dw zero_branch_,plus_buf.continue
  ; a2 is out of bounds
  dw drop_,first_ ; use the first buffer instead
plus_buf.continue:
  dw dup_,prev_,fetch_,not_equals_
  dw semicolon_s_

update_nfa:
  db 0x06+0x80,'UPDAT','E'+0x80
update_lfa:
  dw plus_buf_nfa
update_:
  dw do_colon
update_pfa:
  dw prev_,fetch_,fetch_
  dw lit_,0x8000,or_
  dw prev_,fetch_,store_
  dw semicolon_s_

empty_buffers_nfa:
  db 0x0D+0x80,'EMPTY-BUFFER','S'+0x80
empty_buffers_lfa:
  dw update_nfa
empty_buffers_:
  dw do_colon
empty_buffers_pfa:
  dw first_,limit_,over_,minus_,erase_
  dw limit_
  dw first_
  dw paren_do_
empty_buffers.do:
  dw lit_,0x7FFF,i_,store_
  dw lit_,total_bytes_per_buffer
  dw paren_plus_loop_,empty_buffers.do
  dw semicolon_s_

dr0_nfa:
  db 0x03+0x80,'DR','0'+0x80
dr0_lfa:
  dw empty_buffers_nfa
dr0_:
  dw do_colon
dr0_pfa:
  ; XXX OLD
  ; dw zero_
  ; dw offset_
  ; dw store_
  dw semicolon_s_

; doc{

; : BUFFER  ( n -- a )

; Obtain the next block buffer and assign it to block _n_.   If the
; contents of the buffer were marked as updated, it is written to the
; disk.  The block _n_ is not read from the disk.  The address left on
; stack is the first cell in the buffer for data storage.

; }doc

buffer_nfa:
  db 0x06+0x80,'BUFFE','R'+0x80
buffer_lfa:
  dw dr0_nfa
buffer_:
  dw do_colon
buffer_pfa:
  dw use_,fetch_
  dw dup_,to_r_
buffer.begin:
  dw plus_buf_
  dw zero_branch_,buffer.begin ; until
  dw use_,store_
  dw r_fetch_,fetch_
  dw zero_less_than_ ; updated?
  dw zero_branch_,buffer.end
  ; The buffer was updated, it must be saved to disk.
  dw r_fetch_,two_plus_ ; first cell of data in the buffer
  dw r_fetch_,fetch_
  dw lit_,0x7FFF,and_ ; discard the update bit, leave the block number
  dw zero_,read_write_ ; write
buffer.end:
  dw r_fetch_,store_
  dw r_fetch_,prev_,store_
  dw from_r_,two_plus_ ; first cell of data in the buffer
  dw semicolon_s_

block_nfa:
  db 0x05+0x80,'BLOC','K'+0x80
block_lfa:
  dw buffer_nfa
block_:
  dw do_colon
block_pfa:
  ; XXX OLD
  ; dw offset_
  ; dw fetch_
  ; dw plus_
  dw to_r_
  dw prev_,fetch_
  dw dup_
  dw fetch_
  dw r_fetch_
  dw minus_
  dw dup_
  dw plus_
  dw zero_branch_,branch_destination_0x71FD
branch_destination_0x71CB:
  dw plus_buf_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x71E5
  dw drop_
  dw r_fetch_
  dw buffer_
  dw dup_
  dw r_fetch_
  dw one_
  dw read_write_
  dw two_
  dw minus_
branch_destination_0x71E5:
  dw dup_
  dw fetch_
  dw r_fetch_
  dw minus_
  dw dup_
  dw plus_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x71CB
  dw dup_
  dw prev_
  dw store_
branch_destination_0x71FD:
  dw from_r_
  dw drop_
  dw two_plus_
  dw semicolon_s_

; doc{
; : cswap  ( n1 -- n2 )
;   \ Swap the low and high bytes within n1.
; }doc

c_swap_nfa:
  db 0x05+0x80,'CSWA','P'+0x80
c_swap_lfa:
  dw block_nfa
c_swap_:
  dw c_swap_pfa
c_swap_pfa:
  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp pushhl

; doc{

; : block>sector  ( block -- sector )
;   \ sector (high byte) = track 0..79, +128 if side 1
;   \        (low byte)   = sector 1..10
;   dup 10 mod 1+    \ sector 1..10
;   swap dup 20 /    \ track 0..79
;   swap 10 / 1 and  \ side 0..1
;   128 * +          \ track 0..207
;   cswap or  ;

; }doc

block_to_sector_nfa:
  db 0x0C+0x80,'BLOCK>SECTO','R'+0x80
block_to_sector_lfa:
  dw c_swap_nfa
block_to_sector_:
  dw do_colon
block_to_sector_pfa:
  dw dup_
  dw c_lit_
  db 10
  dw mod_,one_plus_,swap_,dup_
  dw c_lit_
  db 20
  dw slash_,swap_
  dw c_lit_
  db 10
  dw slash_,one_,and_
  ; XXX TODO optimize with `7 lshift`?
  dw c_lit_
  db 128
  dw star_,plus_,c_swap_,or_
  dw semicolon_s_

read_write_nfa:
  db 0x03+0x80,'R/','W'+0x80
read_write_lfa:
  dw block_to_sector_nfa
read_write_:
  dw do_colon
read_write_pfa:
  dw c_lit_
  db 0x45
  dw swap_,minus_
  dw lit_,read_write_sector_command,c_store_
  dw block_to_sector_
  dw paren_read_write_
  dw semicolon_s_

  ; Headerless word with the low level code of `R/W`.
paren_read_write_:
  dw paren_read_write_pfa
paren_read_write_pfa:
  ld a,2 ; drive ; XXX TMP
  pop de ; sector
  pop hl ; address
  push bc
  push ix
  push hl
  pop ix ; address
  rst 8
read_write_sector_command:
  ; Patched by `R/W`:
  ;   0x45 = write
  ;   0x44 = read
  db 0x45
  pop ix
  pop bc
  jp next
  
flush_nfa:
  db 0x05+0x80,'FLUS','H'+0x80
flush_lfa:
  dw read_write_nfa
flush_:
  dw do_colon
flush_pfa:
  dw hash_buff_,one_plus_,zero_
  dw paren_do_
flush.do:
  dw zero_,buffer_,drop_
  dw paren_loop_,flush.do ; loop
  dw semicolon_s_

load_nfa:
  db 0x04+0x80,'LOA','D'+0x80
load_lfa:
  dw flush_nfa
load_:
  dw do_colon
load_pfa:
  dw dup_,zero_,equals_
  dw c_lit_
  db 0x09
  dw question_error_
  dw blk_,fetch_,to_r_
  dw in_,fetch_,to_r_
  dw zero_,in_,store_
  dw b_slash_scr_,star_,blk_,store_
  dw interpret_
  dw from_r_,in_,store_
  dw from_r_,blk_,store_
  dw semicolon_s_

next_screen_nfa:
  db 0x03+0x80+precedence_bit_mask,'--','>'+0x80
next_screen_lfa:
  dw load_nfa
next_screen_:
  dw do_colon
next_screen_pfa:
  dw question_loading_
  dw zero_,in_,store_
  dw b_slash_scr_
  dw blk_,fetch_
  dw over_
  dw mod_
  dw minus_
  dw blk_
  dw plus_store_
  dw semicolon_s_

tick_nfa:
  db 0x01+0x80,'',"'"+0x80
tick_lfa:
  dw next_screen_nfa
tick_:
  dw do_colon
tick_pfa:
  dw minus_find_
  dw zero_equals_,one_,question_error_
  dw drop_
  dw semicolon_s_

bracket_tick_nfa:
  db 0x03+0x80+precedence_bit_mask,"['",']'+0x80
bracket_tick_lfa:
  dw tick_nfa
bracket_tick_:
  dw do_colon
bracket_tick_pfa:
  dw tick_
  dw literal_
  dw semicolon_s_

back_nfa:
  db 0x04+0x80,'BAC','K'+0x80
back_lfa:
  dw bracket_tick_nfa
back_:
  dw do_colon
back_pfa:
  dw comma_
  dw semicolon_s_

begin_nfa:
  db 0x05+0x80+precedence_bit_mask,'BEGI','N'+0x80
begin_lfa:
  dw back_nfa
begin_:
  dw do_colon
begin_pfa:
  dw question_comp_
  dw here_
  dw one_
  dw semicolon_s_

then_nfa:
  db 0x04+0x80+precedence_bit_mask,'THE','N'+0x80
then_lfa:
  dw begin_nfa
then_:
  dw do_colon
then_pfa:
  dw question_comp_
  dw two_,question_pairs_
  dw here_,swap_,store_
  dw semicolon_s_

do_nfa:
  db 0x02+0x80+precedence_bit_mask,'D','O'+0x80
do_lfa:
  dw then_nfa
do_:
  dw do_colon
do_pfa:
  dw compile_,paren_do_
  dw here_
  dw three_
  dw semicolon_s_

loop_nfa:
  db 0x04+0x80+precedence_bit_mask,'LOO','P'+0x80
loop_lfa:
  dw do_nfa
loop_:
  dw do_colon
loop_pfa:
  dw three_,question_pairs_
  dw compile_,paren_loop_
  dw back_
  dw semicolon_s_

plus_loop_nfa:
  db 0x05+0x80+precedence_bit_mask,'+LOO','P'+0x80
plus_loop_lfa:
  dw loop_nfa
plus_loop_:
  dw do_colon
plus_loop_pfa:
  dw three_
  dw question_pairs_
  dw compile_,paren_plus_loop_
  dw back_
  dw semicolon_s_

until_nfa:
  db 0x05+0x80+precedence_bit_mask,'UNTI','L'+0x80
until_lfa:
  dw plus_loop_nfa
until_:
  dw do_colon
until_pfa:
  dw one_,question_pairs_
  dw compile_,zero_branch_
  dw back_
  dw semicolon_s_

again_nfa:
  db 0x05+0x80+precedence_bit_mask,'AGAI','N'+0x80
again_lfa:
  dw until_nfa
again_:
  dw do_colon
again_pfa:
  dw one_,question_pairs_
  dw compile_,branch_
  dw back_
  dw semicolon_s_

repeat_nfa:
  db 0x06+0x80+precedence_bit_mask,'REPEA','T'+0x80
repeat_lfa:
  dw again_nfa
repeat_:
  dw do_colon
repeat_pfa:
  ; XXX TODO optimize with 2>r and 2r>
  dw to_r_
  dw to_r_
  dw again_
  dw from_r_
  dw from_r_
  dw two_,minus_
  dw then_
  dw semicolon_s_

if_nfa:
  db 0x02+0x80+precedence_bit_mask,'I','F'+0x80
if_lfa:
  dw repeat_nfa
if_:
  dw do_colon
if_pfa:
  dw compile_,zero_branch_
  dw here_
  dw zero_,comma_
  dw two_
  dw semicolon_s_

  ; XXX NEW
unless_nfa:
  db 0x06+0x80+precedence_bit_mask,'UNLES','S'+0x80
unless_lfa:
  dw if_nfa
unless_:
  dw do_colon
unless_pfa:
  dw compile_,question_branch_
  dw here_
  dw zero_,comma_
  dw two_
  dw semicolon_s_

else_nfa:
  db 0x04+0x80+precedence_bit_mask,'ELS','E'+0x80
else_lfa:
  dw unless_nfa
else_:
  dw do_colon
else_pfa:
  dw two_
  dw question_pairs_
  dw compile_,branch_
  dw here_
  dw zero_,comma_
  dw swap_
  dw two_
  dw then_
  dw two_
  dw semicolon_s_

while_nfa:
  db 0x05+0x80+precedence_bit_mask,'WHIL','E'+0x80
while_lfa:
  dw else_nfa
while_:
  dw do_colon
while_pfa:
  dw if_
  dw two_plus_
  dw semicolon_s_

spaces_nfa:
  db 0x06+0x80,'SPACE','S'+0x80
spaces_lfa:
  dw while_nfa
spaces_:
  dw do_colon
spaces_pfa:
  dw zero_
  dw max_
  dw question_dup_
  dw zero_branch_,branch_destination_0x7418
  dw zero_
  dw paren_do_
branch_destination_0x7412:
  dw space_
  dw paren_loop_,branch_destination_0x7412
branch_destination_0x7418:
  dw semicolon_s_

less_hash_nfa:
  db 0x02+0x80,'<','#'+0x80
less_hash_lfa:
  dw spaces_nfa
less_hash_:
  dw do_colon
less_hash_pfa:
  dw pad_
  dw hld_
  dw store_
  dw semicolon_s_

hash_greater_nfa:
  db 0x02+0x80,'#','>'+0x80
hash_greater_lfa:
  dw less_hash_nfa
hash_greater_:
  dw do_colon
hash_greater_pfa:
  dw drop_
  dw drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw semicolon_s_

sign_nfa:
  db 0x04+0x80,'SIG','N'+0x80
sign_lfa:
  dw hash_greater_nfa
sign_:
  dw do_colon
sign_pfa:
  dw rot_
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x7457
  dw c_lit_
  db 0x2D
  dw hold_
branch_destination_0x7457:
  dw semicolon_s_

hash_nfa:
  db 0x01+0x80,'','#'+0x80
hash_lfa:
  dw sign_nfa
hash_:
  dw do_colon
hash_pfa:
  dw base_,fetch_
  dw m_slash_mod_
  dw rot_
  dw c_lit_
  db 0x09
  dw over_
  dw less_than_
  dw zero_branch_,branch_destination_0x7479
  dw c_lit_
  db 0x07
  dw plus_
branch_destination_0x7479:
  dw c_lit_
  db 0x30
  dw plus_
  dw hold_
  dw semicolon_s_

hash_s_nfa:
  db 0x02+0x80,'#','S'+0x80
hash_s_lfa:
  dw hash_nfa
hash_s_:
  dw do_colon
hash_s_pfa:
hash_s.begin:
  dw hash_,over_,over_,or_,zero_equals_
  dw zero_branch_,hash_s.begin ; until
  dw semicolon_s_

d_dot_r_nfa:
  db 0x03+0x80,'D.','R'+0x80
d_dot_r_lfa:
  dw hash_s_nfa
d_dot_r_:
  dw do_colon
d_dot_r_pfa:
  dw to_r_
  dw swap_
  dw over_
  dw dabs_
  dw less_hash_
  dw hash_s_
  dw sign_
  dw hash_greater_
  dw from_r_
  dw over_
  dw minus_
  dw spaces_
  dw type_
  dw semicolon_s_

dot_r_nfa:
  db 0x02+0x80,'.','R'+0x80
dot_r_lfa:
  dw d_dot_r_nfa
dot_r_:
  dw do_colon
dot_r_pfa:
  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw semicolon_s_

d_dot_nfa:
  db 0x02+0x80,'D','.'+0x80
d_dot_lfa:
  dw dot_r_nfa
d_dot_:
  dw do_colon
d_dot_pfa:
  dw zero_,d_dot_r_,space_
  dw semicolon_s_

dot_nfa:
  db 0x01+0x80,'','.'+0x80
dot_lfa:
  dw d_dot_nfa
dot_:
  dw do_colon
dot_pfa:
  dw s_to_d_,d_dot_
  dw semicolon_s_

question_nfa:
  db 0x01+0x80,'','?'+0x80
question_lfa:
  dw dot_nfa
question_:
  dw do_colon
question_pfa:
  dw fetch_,dot_
  dw semicolon_s_

u_dot_nfa:
  db 0x02+0x80,'U','.'+0x80
u_dot_lfa:
  dw question_nfa
u_dot_:
  dw do_colon
u_dot_pfa:
  dw zero_,d_dot_
  dw semicolon_s_

  ; XXX OLD -- move to the blocks
words_nfa:
  db 0x05+0x80,'WORD','S'+0x80
words_lfa:
  dw u_dot_nfa
words_:
  dw do_colon
words_pfa:
  dw c_lit_
  db 0x80
  dw out_,store_
  dw context_,fetch_,fetch_
words.begin:
  dw out_,fetch_
  dw c_lit_
  db 0x1F
  dw c_lit_
  db 0x08
  dw minus_
  dw greater_than_
  dw zero_branch_,words.continue
  dw cr_
  dw zero_,out_,store_
words.continue:
  dw dup_,id_dot_
  dw nfa_to_pfa_,pfa_to_lfa_,fetch_
  dw dup_,zero_equals_,question_terminal_,or_
  dw zero_branch_,words.begin ; until
  dw drop_
  dw semicolon_s_

list_nfa:
  db 0x04+0x80,'LIS','T'+0x80
list_lfa:
  dw words_nfa
list_:
  dw do_colon
list_pfa:
  dw cr_
  dw dup_,scr_,store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw dot_
  dw c_lit_
  db lines_per_screen
  dw zero_
  dw paren_do_
list.do:
  dw cr_
  dw i_
  dw c_lit_
  db 0x02
  dw dot_r_
  dw space_,i_,scr_,fetch_,dot_line_
  dw question_terminal_
  dw zero_branch_,list.loop
  dw leave_
list.loop:
  dw paren_loop_,list.do ; loop
  dw cr_
  dw semicolon_s_

link_nfa:
  db 0x04+0x80,'LIN','K'+0x80
link_lfa:
  dw list_nfa
link_:
  dw link_pfa
link_pfa:
  pop hl
  ld a,l
  and a
  jr z,link.end
  ld a,0x03
link.end:
  ld (printer_channel_or_zero),a
  jp next

cls_nfa:
  db 0x03+0x80,'CL','S'+0x80
cls_lfa:
  dw link_nfa
cls_:
  dw cls_pfa
cls_pfa:
  push bc
  ; XXX TODO -- why open the channel?
  ld a,0x02
  call rom_chan_open
  call rom_cl_all
  ; XXX TODO -- why open the channel?
  ld a,0x02
  call rom_chan_open
  ; XXX TODO check the status of the printer
  pop bc
  jp next

bye_nfa:
  db 0x03+0x80,'BY','E'+0x80
bye_lfa:
  dw cls_nfa
bye_:
  dw bye_pfa
bye_pfa:
  ld (iy+sys_df_sz_offset),0x02
  rst 0x08
  db 0x08

text_nfa:
  db 0x04+0x80,'TEX','T'+0x80
text_lfa:
  dw bye_nfa
text_:
  dw do_colon
text_pfa:
  dw here_
  dw c_slash_l_
  dw one_plus_
  dw blanks_
  dw word_
  dw here_
  dw pad_
  dw c_slash_l_
  dw one_plus_
  dw cmove_
  dw semicolon_s_

line_nfa:
  db 0x04+0x80,'LIN','E'+0x80
line_lfa:
  dw text_nfa
line_:
  dw do_colon
line_pfa:
  dw dup_
  dw lit_,0xFFF0
  dw and_
  dw c_lit_
  db 0x17
  dw question_error_
  dw scr_,fetch_
  dw paren_line_
  dw drop_
  dw semicolon_s_

two_drop_nfa:
  db 0x05+0x80,'2DRO','P'+0x80
two_drop_lfa:
  dw line_nfa
two_drop_:
  dw two_drop_pfa
two_drop_pfa:
  pop hl
  pop hl
  jp next

two_swap_nfa:
  db 0x05+0x80,'2SWA','P'+0x80
two_swap_lfa:
  dw two_drop_nfa
two_swap_:
  dw do_colon
two_swap_pfa:
  dw rot_
  dw to_r_
  dw rot_
  dw from_r_
  dw semicolon_s_

size_nfa:
  db 0x04+0x80,'SIZ','E'+0x80
size_lfa:
  dw two_swap_nfa
size_:
  dw do_colon
size_pfa:
  ; XXX TODO update for the new map, count from org.
  dw here_
  dw zero_,plus_origin_
  dw minus_
  dw semicolon_s_

unused_nfa:
  db 0x06+0x80,'UNUSE','D'+0x80
unused_lfa:
  dw size_nfa
unused_:
  dw do_colon
unused_pfa:
  ; XXX TMP
  dw zero_,here_,minus_
  dw semicolon_s_

forget_nfa:
  db 0x06+0x80,'FORGE','T'+0x80
forget_lfa:
  dw unused_nfa
forget_:
  dw do_colon
forget_pfa:
  dw current_,fetch_
  dw context_,fetch_
  dw not_equals_
  dw c_lit_
  db 0x18
  dw question_error_
  dw tick_
  dw dup_
  dw fence_,fetch_
  dw u_less_than_
  dw c_lit_
  db 0x15
  dw question_error_
  dw dup_
  dw pfa_to_nfa_
  dw dp_
  dw store_
  dw pfa_to_lfa_,fetch_
  dw current_,fetch_
  dw store_
  dw semicolon_s_

  ; XXX TODO -- remove, already copied to the blocks disk
index_nfa:
  db 0x05+0x80,'INDE','X'+0x80
index_lfa:
  dw forget_nfa
index_:
  dw do_colon
index_pfa:
  dw one_plus_
  dw swap_
  dw paren_do_
branch_destination_0x774B:
  dw cr_
  dw i_
  dw three_
  dw dot_r_
  dw space_
  dw zero_
  dw i_
  dw dot_line_
  dw question_terminal_
  dw zero_branch_,branch_destination_0x7763
  dw leave_
branch_destination_0x7763:
  dw paren_loop_,branch_destination_0x774B
  dw semicolon_s_

where_nfa:
  db 0x05+0x80,'WHER','E'+0x80
where_lfa:
  dw index_nfa
where_:
  dw do_colon
where_pfa:
  dw dup_
  dw b_slash_scr_
  dw slash_
  dw dup_
  dw scr_
  dw store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_
  dw dot_
  dw swap_
  dw c_slash_l_
  dw slash_mod_
  dw c_slash_l_
  dw star_
  dw rot_
  dw block_
  dw plus_
  dw cr_
  dw c_slash_l_
  dw type_
  dw cr_
  dw here_
  dw c_fetch_
  dw minus_
  dw spaces_
  dw c_lit_
  db 0x5E
  dw emit_
  dw quit_
  dw semicolon_s_

next_nfa:
  db 0x04+0x80,'NEX','T'+0x80
next_lfa:
  dw where_nfa
next_:
  dw do_constant
next_pfa:
  dw next

pushhl_nfa:
  db 0x06+0x80,'PUSHH','L'+0x80
pushhl_lfa:
  dw next_nfa
pushhl_:
  dw do_constant
pushhl_pfa:
  dw pushhl

pushde_nfa:
  db 0x06+0x80,'PUSHD','E'+0x80
pushde_lfa:
  dw pushhl_nfa
pushde_:
  dw do_constant
pushde_pfa:
  dw pushde

p_fetch_nfa:
  db 0x02+0x80,'P','@'+0x80
p_fetch_lfa:
  dw pushde_nfa
p_fetch_:
  dw p_fetch_pfa
p_fetch_pfa:
  pop hl
  push bc
  ld c,l
  ld b,h
  in a,(c)
  pop bc
  ld h,0x00
  ld l,a
  jp pushhl

p_store_nfa:
  db 0x02+0x80,'P','!'+0x80
p_store_lfa:
  dw p_fetch_nfa
p_store_:
  dw p_store_pfa
p_store_pfa:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  ld a,e
  out (c),a
  pop bc
  jp next

screen_nfa:
  db 0x06+0x80,'SCREE','N'+0x80
screen_lfa:
  dw p_store_nfa
screen_:
  dw screen_pfa
screen_pfa:
  pop hl
  pop de
  push bc
  push ix
  ld c,e
  ld b,l
  call rom_s_scrn_s_2538
  call rom_stack_fetch
  ld a,(de)
  ld h,0x00
  ld l,a
  pop ix
  pop bc
  jp pushhl

at_nfa:
  db 0x02+0x80,'A','T'+0x80
at_lfa:
  dw screen_nfa
at_:
  dw do_colon
at_pfa:

; doc{

; : AT ( line col -- )

; Adapted from Lennart Benschop's Spectrum Forth-83.

; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

  dw swap_
  dw dup_
  dw lit_,23
  dw not_equals_ ; not the last line?
  dw zero_branch_,at_pfa.last_line

  dw lit_,22,to_chan_,to_chan_,to_chan_
  dw exit_

at_pfa.last_line:
  dw one_minus_
  dw to_chan_
  dw to_chan_
  dw zero_
  dw to_chan_
  dw cr_

  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  dw lit_,33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw semicolon_s_

border_nfa:
  db 0x06+0x80,'BORDE','R'+0x80
border_lfa:
  dw at_nfa
border_:
  dw border_pfa
border_pfa:
  pop hl
  push bc
  ld a,l
  call rom_border_2297
  pop bc
  jp next

paper_nfa:
  db 0x05+0x80,'PAPE','R'+0x80
paper_lfa:
  dw border_nfa
paper_:
  dw do_colon
paper_pfa:
  dw abs_
  dw dup_
  dw c_lit_
  db 0x09
  dw greater_than_
  dw zero_branch_,branch_destination_0x7C5F
  dw drop_
  dw branch_,branch_destination_0x7CE5
branch_destination_0x7C5F:
  dw dup_
  dw c_lit_
  db 0x09
  dw equals_
  dw zero_branch_,branch_destination_0x7C83
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0x80
  dw or_
  dw lit_,sys_p_flag
  dw c_store_
  dw drop_
  dw branch_,branch_destination_0x7CE5
branch_destination_0x7C83:
  dw dup_
  dw c_lit_
  db 0x08
  dw equals_
  dw zero_branch_,branch_destination_0x7CA7
  dw lit_,sys_mask_p
  dw c_fetch_
  dw c_lit_
  db 0x38
  dw or_
  dw lit_,sys_mask_p
  dw c_store_
  dw drop_
  dw branch_,branch_destination_0x7CE5
branch_destination_0x7CA7:
  dw c_lit_
  db 0x08
  dw star_
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0xC7
  dw and_
  dw or_
  dw lit_,sys_attr_p
  dw c_store_
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0x7F
  dw and_
  dw lit_,sys_p_flag
  dw store_
  dw lit_,sys_mask_p
  dw c_fetch_
  dw c_lit_
  db 0xC7
  dw and_
  dw lit_,sys_mask_p
  dw store_
branch_destination_0x7CE5:
  dw semicolon_s_

attr_nfa:
  db 0x04+0x80,'ATT','R'+0x80
attr_lfa:
  dw paper_nfa
attr_:
  dw attr_pfa
attr_pfa:
  pop hl
  pop de
  push bc
  push ix
  ld c,e
  ld b,l
  call rom_s_attr_s_2583
  call rom_find_int1
  ld h,0x00
  ld l,a
  pop ix
  pop bc
  jp pushhl

ink_nfa:
  db 0x03+0x80,'IN','K'+0x80
ink_lfa:
  dw attr_nfa
ink_:
  dw do_colon
ink_pfa:
  dw abs_
  dw dup_
  dw c_lit_
  db 0x09
  dw greater_than_
  dw zero_branch_,branch_destination_0x7D4C
  dw drop_
  dw branch_,branch_destination_0x7DCC
branch_destination_0x7D4C:
  dw dup_
  dw c_lit_
  db 0x09
  dw equals_
  dw zero_branch_,branch_destination_0x7D70
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0x20
  dw or_
  dw lit_,sys_p_flag
  dw c_store_
  dw drop_
  dw branch_,branch_destination_0x7DCC
branch_destination_0x7D70:
  dw dup_
  dw c_lit_
  db 0x08
  dw equals_
  dw zero_branch_,branch_destination_0x7D94
  dw lit_,sys_mask_p
  dw c_fetch_
  dw c_lit_
  db 0x07
  dw or_
  dw lit_,sys_mask_p
  dw c_store_
  dw drop_
  dw branch_,branch_destination_0x7DCC
branch_destination_0x7D94:
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0xF8
  dw and_
  dw or_
  dw lit_,sys_attr_p
  dw c_store_
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0xDF
  dw and_
  dw lit_,sys_p_flag
  dw store_
  dw lit_,sys_mask_p
  dw c_fetch_
  dw c_lit_
  db 0xF8
  dw and_
  dw lit_,sys_mask_p
  dw store_
branch_destination_0x7DCC:
  dw semicolon_s_

flash_nfa:
  db 0x05+0x80,'FLAS','H'+0x80
flash_lfa:
  dw ink_nfa
flash_:
  dw do_colon
flash_pfa:
  dw zero_branch_,branch_destination_0x7DF2
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0x80
  dw or_
  dw lit_,sys_attr_p
  dw store_
  dw branch_,branch_destination_0x7E04
branch_destination_0x7DF2:
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0x7F
  dw and_
  dw lit_,sys_attr_p
  dw store_
branch_destination_0x7E04:
  dw semicolon_s_

bright_nfa:
  db 0x06+0x80,'BRIGH','T'+0x80
bright_lfa:
  dw flash_nfa
bright_:
  dw do_colon
bright_pfa:
  dw zero_branch_,branch_destination_0x7E2B
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0x40
  dw or_
  dw lit_,sys_attr_p
  dw store_
  dw branch_,branch_destination_0x7E3D
branch_destination_0x7E2B:
  dw lit_,sys_attr_p
  dw c_fetch_
  dw c_lit_
  db 0xBF
  dw and_
  dw lit_,sys_attr_p
  dw store_
branch_destination_0x7E3D:
  dw semicolon_s_

gover_nfa:
  db 0x05+0x80,'GOVE','R'+0x80
gover_lfa:
  dw bright_nfa
gover_:
  dw do_colon
gover_pfa:
  dw zero_branch_,branch_destination_0x7E61
  dw lit_,sys_p_flag
  dw c_fetch_
  dw two_
  dw or_
  dw lit_,sys_p_flag
  dw store_
  dw branch_,branch_destination_0x7E73
branch_destination_0x7E61:
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0xFD
  dw and_
  dw lit_,sys_p_flag
  dw store_
branch_destination_0x7E73:
  dw semicolon_s_

inverse_nfa:
  db 0x07+0x80,'INVERS','E'+0x80
inverse_lfa:
  dw gover_nfa
inverse_:
  dw do_colon
inverse_pfa:
  dw zero_branch_,branch_destination_0x7E9B
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0x08
  dw or_
  dw lit_,sys_p_flag
  dw store_
  dw branch_,branch_destination_0x7EAD
branch_destination_0x7E9B:
  dw lit_,sys_p_flag
  dw c_fetch_
  dw c_lit_
  db 0xF7
  dw and_
  dw lit_,sys_p_flag
  dw store_
branch_destination_0x7EAD:
  dw semicolon_s_

i_tick_nfa:
  db 0x02+0x80,'I',"'"+0x80
i_tick_lfa:
  dw inverse_nfa
i_tick_:
  dw i_tick_pfa
i_tick_pfa:
  ld hl,(return_pointer_value)
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

j_nfa:
  db 0x01+0x80,'','J'+0x80
j_lfa:
  dw i_tick_nfa
j_:
  dw j_pfa
j_pfa:
  ld hl,(return_pointer_value)
  inc hl
  inc hl
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

two_constant_nfa:
  db 0x09+0x80,'2CONSTAN','T'+0x80
two_constant_lfa:
  dw j_nfa
two_constant_:
  dw do_colon
two_constant_pfa:
  dw create_
  dw smudge_
  dw here_
  dw two_store_
  dw c_lit_
  db 0x04
  dw allot_
  dw paren_semicolon_code_
do_two_constant:
  ; XXX OLD optimize to use pushde
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  dec hl
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  push de
  jp next

two_variable_nfa:
  db 0x09+0x80,'2VARIABL','E'+0x80
two_variable_lfa:
  dw two_constant_nfa
two_variable_:
  dw do_colon
two_variable_pfa:
  dw two_constant_
  dw paren_semicolon_code_
do_two_variable:
  ; XXX TODO optimize to share code with `do_variable`.
  inc de  ; de=pfa
  push de
  jp next

u_dot_r_nfa:
  db 0x03+0x80,'U.','R'+0x80
u_dot_r_lfa:
  dw two_variable_nfa
u_dot_r_:
  dw do_colon
u_dot_r_pfa:
  dw to_r_
  dw zero_
  dw from_r_
  dw d_dot_r_
  dw semicolon_s_

two_over_nfa:
  db 0x05+0x80,'2OVE','R'+0x80
two_over_lfa:
  dw u_dot_r_nfa
two_over_:
  dw do_colon
two_over_pfa:
  ; XXX TODO rewrite in Z80
  dw two_swap_
  dw two_dup_
  ; XXX TODO optimize with 2>r and 2r>
  dw to_r_
  dw to_r_
  dw two_swap_
  dw from_r_
  dw from_r_
  dw semicolon_s_

exit_nfa:
  db 0x04+0x80,'EXI','T'+0x80
exit_lfa:
  dw two_over_nfa
exit_:

  ; XXX FIXME
  ;dw r_drop_pfa ; this fails, why?

  ; XXX FIXME
  ; this fails too, why?, it's the original code.
  ; it has something to do with the stack problems.
  dw exit_pfa
exit_pfa:
  dw from_r_,drop_
  dw semicolon_s_

question_exit_nfa:
  db 0x05+0x80,'?EXI','T'+0x80
question_exit_lfa:
  dw exit_nfa
question_exit_:
  dw question_exit_pfa
question_exit_pfa:
  pop hl
  ld a,h
  or l
  jp nz,r_drop_pfa
  jp next

case_nfa:
  db 0x04+0x80+precedence_bit_mask,'CAS','E'+0x80
case_lfa:
  dw question_exit_nfa
case_:
  dw do_colon
case_pfa:
  dw question_comp_
  dw csp_,fetch_
  dw store_csp_
  dw c_lit_
  db 0x04
  dw semicolon_s_

of_nfa:
  db 0x02+0x80+precedence_bit_mask,'O','F'+0x80
of_lfa:
  dw case_nfa
of_:
  dw do_colon
of_pfa:
  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,over_
  dw compile_,equals_
  dw compile_,zero_branch_
  dw here_
  dw zero_,comma_
  dw compile_,drop_
  dw c_lit_
  db 0x05
  dw semicolon_s_

endof_nfa:
  db 0x05+0x80+precedence_bit_mask,'ENDO','F'+0x80
endof_lfa:
  dw of_nfa
endof_:
  dw do_colon
endof_pfa:
  dw c_lit_
  db 0x05
  dw question_pairs_
  dw compile_,branch_
  dw here_
  dw zero_,comma_
  dw swap_
  dw two_
  dw then_
  dw c_lit_
  db 0x04
  dw semicolon_s_

endcase_nfa:
  db 0x07+0x80+precedence_bit_mask,'ENDCAS','E'+0x80
endcase_lfa:
  dw endof_nfa
endcase_:
  dw do_colon
endcase_pfa:
  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,drop_
branch_destination_0x80F0:
  dw sp_fetch_
  dw csp_,fetch_
  dw equals_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x8106
  dw two_
  dw then_
  dw branch_,branch_destination_0x80F0
branch_destination_0x8106:
  dw csp_
  dw store_
  dw semicolon_s_

inkey_nfa:
  db 0x05+0x80,'INKE','Y'+0x80
inkey_lfa:
  dw endcase_nfa
inkey_:
  dw inkey_pfa
inkey_pfa:
  push bc
  call rom_key_scan
  ld c,0x00
  jr nz,l8128h
  call rom_key_test
  jr nc,l8128h
  dec d
  ld e,a
  call rom_key_decode
l8128h:
  ld l,a
  ld h,0x00
  pop bc
  jp pushhl

char_nfa:
  db 0x04+0x80,'CHA','R'+0x80
char_lfa:
  dw inkey_nfa
char_:
  dw do_colon
char_pfa:
  dw b_l_
  dw word_
  dw here_
  dw one_plus_
  dw c_fetch_
  dw semicolon_s_

bracket_char_nfa:
  db 0x06+0x80+precedence_bit_mask,'[CHAR',']'+0x80
bracket_char_lfa:
  dw char_nfa
bracket_char_:
  dw do_colon
bracket_char_pfa:
  dw char_
  dw literal_
  dw semicolon_s_

backslash_nfa:
  db 0x01+0x80+precedence_bit_mask,'','\'+0x80
backslash_lfa:
  dw bracket_char_nfa
backslash_:
  dw do_colon
backslash_pfa:
  dw in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw in_,plus_store_
  dw semicolon_s_

; doc{
; : .(  ( 'ccc<paren>' -- )
;   [CHAR] ) TEXT PAD COUNT TYPE  ; IMMEDIATE
; }doc

nfa_of_top_most_word_in_forth_voc:

dot_paren_nfa:
  db 0x02+0x80+precedence_bit_mask,'.','('+0x80
dot_paren_lfa:
  dw backslash_nfa
dot_paren_:
  dw do_colon
dot_paren_pfa:
  dw c_lit_
  db ')'
  dw text_,pad_,count_,type_
  dw semicolon_s_

dictionary_pointer_after_cold:

end cold_entry
  
  ; ----------------------------------------------------------------
  ; Debug tools

  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,3,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER

