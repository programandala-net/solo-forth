( Nuclear Invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201602170319

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version by Dancresp:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements)

only forth definitions

need roll       need inkey
need bleep      need beep>bleep
need os-chars   need os-udg
need 2/         need abort"

need benched

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

: debug-point  ( -- )  depth abort" depth is not zero"  ;
\ XXX TMP for debugging

-->

( Variables) debug-point

variable tank-x       \ coordinate (column)
variable shoot-x      \ coordinate (column)
variable shoot-y      \ coordinate (row), 0 if no shoot
variable ufo-x        \ coordinate (column)
variable lifes        \ counter (0..3)
variable phase        \ counter (2..5)
variable score        \ counter
variable record       \ max score
variable invaders     \ counter
variable invader-type \ element of table  (0..8)

-->

( clear-arena at-yx pause ) debug-point

: at-yx  ( y x -- )  swap at-xy  ;
  \ XXX TMP -- compatibility layer for the original code

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code

: clear-arena  ( -- )
  0 2 at-xy 608 spaces  ;
  \ Clear screen except the status bars.

: pause  ( n -- )
  0 do  200 0 do  loop  loop  ;

-->

( .score .record update-score  ) debug-point

: (.score)  ( n x y -- )  at-xy s>d <# # # # #> type  ;
: .score  ( -- )  score @ 3 1 (.score)  ;
: .record  ( -- )  record @ 14 1 (.score)  ;
: update-score  ( n -- )  score +! .score  ;

: rnd  ( -- n )  15403 c@ 31 and  ;
  \ Return a random number _n_ (0..31).
  \ XXX TODO

-->

( udg-set >udg >scan scan! ) debug-point

          27 constant udgs   \ number of UDGs
           8 constant scans  \ scans per UDG
udgs scans * constant /udgs  \ size of the UDG set

create udg-set /udgs allot

: .udgs  ( -- )  cr udgs 0 do  i 'a' + emit  loop
                 cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.
  \ XXX TMP -- for debugging

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: >udg  ( c -- a )  'a' - scans * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.

: >scan  ( n c -- a )  >udg +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

-->

( graphic text mode )

udg-set 'a' scans * -  constant graphic
  \ Address of a presumed font whose char `a` is the first UDG
  \ of the game.  This way the original code will work without
  \ change.
  \ XXX TMP -- compatibility layer for the original code

15360 constant text
  \ Address of the ROM charset (char 0).

: mode  ( a -- )  os-chars !  ;
  \ Set the charset to address _a_ (the bitmap of char 0).

  \ Usage examples:
  \   graphic mode  \ print UDG instead of `a`..`}`
  \   text mode     \ ROM charset 0..127, plus UDG 128..255

-->

( sprite! 2sprite! ) debug-point

: sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into char _c_.

: sprite  ( n0..n7 c "name" -- )  dup constant sprite!  ;

: 2sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - pick flip i scan! 1+  \ first UDG
    dup scans 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is the next char.

: 2sprite  ( n0..n7 c "name" -- )  dup constant 2sprite!  ;

-->

( graphics ) debug-point

binary
  \ "ab",  30 points invader, sprite 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

char a 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "cd",  30 points invader, sprite 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

char c 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "ef",  20 points invader, position 2
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

char e 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "gh",  20 points invader, position 1
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

char g 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "ij",  10 points invader, position 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

char i 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "kl",  10 points invader, position 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

char k 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "mn", tank
0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

char m 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "op", ufo
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

char o 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "qr", explosion, frame 2 (for invaders)
0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

char q 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "s", char 115, projectile
00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

char s sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "tu", explosion, frame 1 (for the UFO)
0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

char t 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "v", brick
11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

char v sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "w", horizontal rule
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

char w sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "xy", top of container
0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

char x 2sprite!

decimal  -->

( graphics ) debug-point

binary
  \ "z{", bottom of container
0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

char z 2sprite!

decimal  -->

( instructions ) debug-point

: wait  ( -- )  begin  inkey  until  ;

: instructions  ( -- )
  cls
   8 1 at-xy ." nuclear invaders"
   4 6 at-xy ." controls: left  = z"
  14 7 at-xy           ." right = x"
  14 8 at-xy           ." fire  = enter"
  6 14 at-xy ." *press key to start*"
  6 21 at-xy ." c scainet soft, 2013"
  wait 9 pause  ;

-->

( presentation ) debug-point

: presentation  ( -- )
  cls
  ."  score<1>   hi-score   score<2>"
  .score .record
  14  5 at-xy ." play"
   8  7 at-xy ." nuclear invaders"
   5 10 at-xy ." *score advance table*"
   9 12 at-xy ." op =? mystery"
   9 14 at-xy ." cd =30 points"
   9 16 at-xy ." gh =20 points"
   9 18 at-xy ." kl=10 points"
   4 22 at-xy ." mnmn" 13 spaces ." credit 00"
  wait clear-arena  -->

( presentation ) debug-point

   1 21 at-xy ." wwwwwwwwwwwwwwwwwwwwwwwwwwwwww"
   2 22 at-xy ." 3"
   9 11 at-xy ." play player<1>"

  10 0 do
   3  1 at-xy 4 spaces  3 pause
   3  1 at-xy ." 0000" 3 pause
  loop  ;

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = lifes (0..3)
  \ +2 = active? (0..1)
  \ +4 = y coordinate (row)
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

      9 constant invader-types
8 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ lifes    active?   y      x     character
    3 ,     0 ,      5 ,   0 ,  'c' ,
    3 ,     0 ,      7 ,   0 ,  'g' ,
    3 ,     0 ,      9 ,   0 ,  'g' ,
    3 ,     0 ,     11 ,   0 ,  'k' ,
    3 ,     0 ,      5 ,  29 ,  'c' ,
    3 ,     0 ,      7 ,  29 ,  'g' ,
    3 ,     0 ,      9 ,  29 ,  'g' ,
    3 ,     0 ,     11 ,  29 ,  'k' ,
    3 ,     0 ,     13 ,  29 ,  'k' ,

here swap - constant /invaders-data
  \ Space occupied by the invaders data.

-->

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: 'invader   ( -- a )  invader-type @ invaders-data +  ;
  \ Data address _a_ of the current invader type.

: invader-lifes   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;
: invader-char    ( -- a )  'invader [ 4 cells ] literal +  ;

-->

( containers ) debug-point

: brick  ( -- )  ." v"  ;

here 1+ s" vvvvvvvvvvvv" s, constant bricks
  \ Compile a string of bricks and save the address
  \ of its first char.

here 1+ s" vxyxyxyxyxy" s, constant containers-top
here 1+ s" vz{z{z{z{z{" s, constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

-->

( containers ) debug-point

 4 constant containers-top-y
15 constant containers-bottom-y

variable containers-x

: containers  ( -- )
  15 phase @ - containers-x !
  bricks phase @ 2* 2+ 2dup
  containers-x @ containers-bottom-y  at-xy type
  containers-x @ containers-top-y     at-xy type
  phase @ 2* 1+  containers-x @
  containers-top-y [ containers-bottom-y 2- ] literal do
    2dup 2dup
    i 1+ at-xy containers-bottom swap type brick
    i    at-xy containers-top    swap type brick
  -2 +loop  2drop  ;
  \ Draw the nuclear containers.

  \ XXX benchmark:  6102 frames / 1000 executions

-->

( init ) debug-point

: init-game  ( -- )  3 lifes !  2 phase !  score off  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: init-invaders  ( -- )
  init-invaders-data  0 invader-type !  30 invaders !
  init-ufo  ;

: init-tank  ( -- )  3 tank-x !  shoot-y off  ;

-->

( init ) debug-point

: .2sprite  ( c -- )  dup emit 1+ emit  ;

: parade  ( -- )
  99 dup 103 dup 107 dup
  3 13 do
     1 i at-xy dup .2sprite
    29 i at-xy     .2sprite
  -2 +loop  ;
  \ XXX TODO -- more legible

: init-arena  ( -- )  clear-arena containers parade  ;

: init-round  ( -- )  init-arena init-invaders init-tank  ;

-->

( move-tank ) debug-point

20 constant tank-y      \ coordinate (row)
 3 constant tank-min-x
27 constant tank-max-x

: tank-limit  ( column -- column' )
  tank-max-x min tank-min-x max  ;

: move-tank  ( -- )
  tank-x @  inkey 'x' = abs +  inkey 'z' = +  tank-limit
  dup tank-x !
  1- tank-y at-xy ."  mn " ;

-->

( move-invader ) debug-point

: at-invader  ( -- )  invader-x @ invader-y @ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

: invader-frame  ( -- c )
  invader-char @ invader-x @ 2 mod 0> 2* +  ;
  \ Frame of the invader.

: .invader-frame  ( -- )  invader-frame .2sprite  ;
  \ Print the frame of the invader.

: .invader  ( n -- )
    dup at-invader 0> if  space  then
    .invader-frame 0< if  space  then  ;
  \ Print the current invader.
  \ _n_ is its x increment (1 or -1).

: move-active-invader  ( -- )
  1 invader-type @ 5 < 0= ?negate  ( 1 | -1 )
  dup invader-x +!  .invader
  invader-x @ dup 14 phase @ -  =
  if  drop 1  else  15 phase @ + =  then  ;  -->

( move-invader ) debug-point

: move-inactive-invader  ( -- )
  rnd  26 invaders @ 5 < 16 * -  >
  if  invader-active on  then  ;

: next-invader  ( -- )
  invader-type @ [ invader-types 1- ] literal =
  if  invader-type off  else  1 invader-type +!  then  ;

: (move-invader)  ( -- f )
  invader-active @ if    move-active-invader
                   else  move-inactive-invader false  then  ;

: move-invader  ( -- f )
  invader-lifes @ if     (move-invader)
                  else   false
                  then   next-invader  ;

-->

( ufo ) debug-point

 3 constant ufo-y       \ coordinate (row)
27 constant ufo-max-x   \ coordinate (column)

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo 3 spaces init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: flying-ufo  ( -- )  1 ufo-x +! at-ufo ."  op"  ;
  \ Update the position of the UFO and show it.

: (ufo)  ( -- )  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: ufo  ( -- )
  ufo-invisible? if  1 ufo-x +!  else  (ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;

: ufo-in-fire  ( -- )  ufo-x @ 1+ ufo-y at-xy ." tu"  ;

: ufo-explosion  ( -- )  ufo-in-fire ufo-bang  ;

: ufo-points  ( -- n )  rnd 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ 3 at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )
  ufo-explosion ufo-bonus 20 pause -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  shoot-y @ 3 - 2/          \ depending on the row
  shoot-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  shoot-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-explosion  ( -- )
  ;
  \ XXX TODO

: invader-impacted  ( -- )
  -1 invaders +!  invader-explosion invader-bonus  ;

-->

( impact ) debug-point

  \ XXX TODO -- factor

: (impact)  ( -- )
  shoot-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted

  invader-type @ >r

  score @ 1- invader-type !
    \ XXX TODO -- check the original

  invader-y @ invader-x @ dup 15 < abs +
  2dup at-yx ." qr"  10 100 beep at-yx 2 spaces

  -1 invader-lifes +!
  invader-lifes @ if
    invader-active off
    shoot-x @ 15 < abs 29 * invader-x !  at-invader
    shoot-x @ 15 < if  space  then
    invader-char @ .2sprite
  then  r> invader-type !  ;
  \ Manage the impact.

-->

( impact ) debug-point

: impact  ( -- )
  shoot-y @ 15 < if  (impact)  then  shoot-y off  ;
  \ Manage the impact, if the projectil is high enough.

: missed?  ( -- )
  9216 shoot-y @ 32 * + shoot-x @ + c@ bl =  ;
  \ Did the projectile missed the target?
  \ XXX TODO adapt
  \ XXX TODO reverse the logic: keep the target char

: impact?  ( -- f )
  missed? if  false  else  impact true  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: .projectile  ( -- )  shoot-x @ shoot-y @ at-xy 115 emit  ;
  \ Show the projectile.

: fire?  ( -- f )  inkey 13 =  ;

: fire  ( -- )
  tank-x @ shoot-x ! [ tank-y 1- ] literal shoot-y !  ;
  \ The tank fires.

: -projectile  ( -- )  shoot-x @ shoot-y @ at-xy space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )  shoot-y @ 5 <  ;
  \ Is the projectile lost?

: shooted  ( -- )
  -projectile projectile-lost?
  if    shoot-y off
  else  -2 shoot-y +! impact? ?exit  .projectile  then  ;
  \ Manage the projectile.

: shooted?  ( -- )  shoot-y @  ;
  \ Has the tank already shooted?

: shoot  ( -- )
  shooted? if  shooted exit  then
  fire? if  fire  then  ;
  \ Manage the shoot.

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
: new-record    ( -- f )  score @ record !  ;
: check-record  ( -- )  new-record? if  new-record  then  ;

-->

( alive game-over next-phase ) debug-point

: .lifes  ( n -- )
  22 tuck at-xy . dup 2* 2+ 22 at-xy 2 spaces  ;

: .game-over  ( -- )  11 17 at-xy ." GAME  OVER"  ;

: game-over  ( -- )  .game-over  check-record  ;

: tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: the-end?  ( -- f )
  tune  30 pause
  lifes @ 1- dup 0>
  if  .lifes  else  game-over  then  dup lifes ! 0= ;

: next-phase  ( -- )
  invaders @ ?exit
  phase @ 5 < abs +! 100 pause init-round  ;

-->

( run ) debug-point

: round  ( -- )
  init-round
  begin   2 pause
          move-tank shoot ufo next-phase move-invader
  until  ;

: game  ( -- )
  init-game begin  round the-end?  until  200 pause  ;

: run  ( -- )
  instructions begin  presentation game  again  ;

-->

( Debugging tools)

: g0  ( -- )  text mode  0 0 at-xy  ;
: g1  ( -- )  graphic mode  ;
: g  ( xt -- )  g1 execute g0  ;
: cg  ( xt -- )  cls g1 execute g0  ;

init-game init-invaders init-tank

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14: Started changing the layout of the original
  \ source code.
  \

  \
  \ Change the layout of the source code.
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ Adapt graphics and data; start factoring.
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-16:
  \
  \ Factor code.
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Improve the invaders' data manipulation.

\ vim: filetype=soloforth
