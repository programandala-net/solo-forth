( Nuclear Invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201602172208

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version by Dancresp:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements)

only forth definitions

need roll       need inkey    need bleep  need beep>bleep
need os-chars   need os-udg   need 2/     need abort"
need value      need case     need random
need columns    need rows

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

need benched    need ~~
13 ~~key !
  \ XXX TMP -- during the development

: debug-point  ( -- )  depth abort" depth is not zero"  ;
  \ XXX TMP for debugging

-->

( Screen and colors) debug-point

16384 constant sys-screen  6912 constant /sys-screen
                           6144 constant /sys-screen-bitmap
  \ Address and size of the screen.

22528 constant attributes  768 constant /attributes
  \ Address and size of the screen attributes.

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery   ( color -- paper-attribute )           8 *  ;
: brighty  ( attribute -- brighty-attribute )  64 and  ;
: flashy   ( attribute -- flashy-attribute )  128 and  ;

              black constant arena-color
                red constant brick-color
     yellow brighty constant container-color

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 1 border  ;
  \ XXX TMP

-->

( Keyboard) debug-point

'z' value left-key
'x' value right-key
13  value fire-key

: .key  ( c -- )
  case
    13 of  ." Enter"  endof
    bl of  ." Space"  endof
    dup emit  \ default
  endcase  ;
  \ Print the name of the key that produces char _c_.

: wait  ( -- )  begin  inkey  until  ;
  \ Wait until any key is pressed.

: fire?  ( -- f )  inkey fire-key =  ;
  \ Is the fire key pressed?

13 constant enter-key
: enter-key?  ( -- f )  inkey enter-key =  ;
: wait-for-enter  ( -- )  begin  enter-key?  until  ;
  \ Wait until the EnterEnter  key is pressed.

-->

( Variables) debug-point

variable tank-x       \ coordinate (column)
variable shoot-x      \ coordinate (column)
variable shoot-y      \ coordinate (row), 0 if no shoot
variable ufo-x        \ coordinate (column)
variable lifes        \ counter (0..3)
variable phase        \ counter (2..5)
variable score        \ counter
variable record       \ max score
variable invaders     \ counter
variable invader-type \ element of table  (0..8)

-->

( beep pause ) debug-point

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code

: pause  ( n -- )  0 do  200 0 do  loop  loop  ;
  \ XXX TODO -- adjust

-->

( .score .record update-score  ) debug-point

: (.score)  ( n x y -- )  at-xy s>d <# # # # #> type  ;
: .score  ( -- )  score @ 3 1 (.score)  ;
: .record  ( -- )  record @ 14 1 (.score)  ;
: update-score  ( n -- )  score +! .score  ;

-->

( udg-set >udg >scan scan! ) debug-point

          27 constant udgs   \ number of UDGs
           8 constant scans  \ scans per UDG
udgs scans * constant /udgs  \ size of the UDG set

create udg-set /udgs allot

: .udgs  ( -- )  cr udgs 0 do  i 'a' + emit  loop
                 cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.
  \ XXX TMP -- for debugging

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: >udg  ( c -- a )  'a' - scans * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.

: >scan  ( n c -- a )  >udg +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

-->

( graphic-font rom-font font! font@ )

udg-set 'a' scans * -  constant graphic-font
  \ Address of a presumed font whose char `a` is the first UDG
  \ of the game.  This way the original code will work without
  \ change.
  \ XXX TMP -- compatibility layer for the original code

15360 constant rom-font
  \ Address of the ROM charset (char 0).

: font!  ( a -- )  os-chars !  ;
  \ Set the current charset to address _a_
  \ (the bitmap of char 0).
: font@  ( -- a )  os-chars @  ;
  \ Fetch the address _a_ of the current charset
  \ (the bitmap of char 0).

  \ Usage examples:
  \   graphic-font font!  \ print UDG instead of `a`..`}`
  \   rom-font font!      \ ROM charset 0..127, plus UDG 128..255


warnings @  warnings off
variable ~~font
: ~~(  font@ ~~font ! rom-font font!  ;
: ~~)  ~~font @ font!  ;
: ~~  ( -- )
  postpone ~~( postpone ~~  postpone ~~)  ; immediate
warnings !
  \ XXX TMP

-->

( sprite! 2sprite! ) debug-point

: sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into char _c_.

: sprite  ( n0..n7 c "name" -- )  dup constant sprite!  ;

: 2sprite!  ( n0..n7 c -- )
  scans 0 do
    dup scans 1+ i - pick flip i scan! 1+  \ first UDG
    dup scans 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is the next char.

: 2sprite  ( n0..n7 c "name" -- )  dup constant 2sprite!  ;

: .2sprite  ( c -- )  dup emit 1+ emit  ;

-->

( sprites ) debug-point

binary
  \ "ab",  30 points invader, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

char a 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "cd",  30 points invader, frame 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

char c 2sprite invader-3

decimal  -->

( sprites ) debug-point

binary
  \ "ef",  20 points invader, frame 2
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

char e 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "gh",  20 points invader, frame 1
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

char g 2sprite invader-2

decimal  -->

( sprites ) debug-point

binary
  \ "ij",  10 points invader, frame 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

char i 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "kl",  10 points invader, frame 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

char k 2sprite invader-1

decimal  -->

( sprites ) debug-point

binary
  \ "mn", tank
0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

char m 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "op", ufo
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

char o 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "qr", explosion, frame 2 (for invaders)
0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

char q 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "s", char 115, projectile
00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

char s sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "tu", explosion, frame 1 (for the UFO)
0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

char t 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "v", brick
11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

char v sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "w", horizontal rule
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

char w sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "xy", top of container
0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

char x 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "z{", bottom of container
0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

char z 2sprite!

decimal  -->

( sprites ) debug-point

binary
  \ "|", blank
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

char | sprite blank-char

decimal  -->

( centered center-type )

: centered  ( len -- column )  columns swap - 2/  ;
  \ Convert a string length to the column required
  \ to print the string centered.

: center-type  ( ca len row -- )
  over centered swap at-xy type  ;
  \ Print string _ca len_ centered on the given row.

-->

( instructions ) debug-point

: title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;

: (c)  ( -- )  127 emit  ;
  \ Print the copyright symbol.

: copyright  ( row -- )
  1 over    at-xy (c) ."  2013 Dancresp (Scainet Soft)"
  1 over 1+ at-xy (c) ."  2016 Marcos Cruz"
  8 swap 2+ at-xy           ." (programandala.net)"  ;
  \ Print the copyright starting at _row_.

: controls  ( row -- )
   4 over    at-xy ." Controls: left  = " left-key .key
  14 over 1+ at-xy           ." right = " right-key .key
  14 swap 2+ at-xy           ." fire  = " fire-key .key  ;
  \ Print the controls starting at _row_.

  -->

( instructions ) debug-point

: score-table-item  ( ca1 len1 ca2 len2 -- )
  graphic-font font! type rom-font font! ."  = " type  ;
  \ Print an item of the score table, with sprite string _ca2
  \ len2_ and description _ca1 len1_

: score-table  ( row -- )
   9 over     at-xy s" 10 points" s" kl" score-table-item
   9 over 2+  at-xy s" 20 points" s" gh" score-table-item
   9 over 4 + at-xy s" 30 points" s" cd" score-table-item
   9 swap 6 + at-xy s" bonus"     s" op" score-table-item  ;
   \ Print the score table starting at the given row.

: start-options  ( row -- )
  >r s" Press SPACE to change controls" r@    center-type
     s" Press ENTER to start"           r> 1+ center-type  ;
  \ Print the menu options starting at the given row.

: instructions  ( -- )
  cls  title  3 score-table  12 controls
              17 start-options 21 copyright
  wait-for-enter 9 pause  ;

-->

( arena ) debug-point

: clear-arena  ( -- )
  rom-font font!  0 2 at-xy 608 spaces  graphic-font font!  ;
  \ Clear the arena (the whole screen except the status bars).

: score-bar  ( -- )
  ."  SCORE<1>    RECORD    SCORE<2>"  .score .record  ;
  \ XXX TODO score 2 is not used in the original

: blinking-score  ( -- )
  10 0 do
    3 1 at-xy 4 spaces 3 pause
    3 1 at-xy ." 0000" 3 pause
  loop  ;

-->

( arena ) debug-point

: status-bar  ( -- )
   2 22 at-xy lifes ?
  21 22 at-xy ." credit 00"
  graphic-font font!
  1 21 at-xy ." wwwwwwwwwwwwwwwwwwwwwwwwwwwwww"
  4 22 at-xy ." mnmn"  rom-font font!  ;
  \ XXX TODO credit is not used in the original

: arena  ( -- )  ~~ init-colors cls score-bar status-bar  ;

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = lifes (0..3)
  \ +2 = active? (0..1)
  \ +4 = y coordinate (row)
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

      9 constant invader-types
8 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ lifes    active?   y      x     character
    3 ,     0 ,      5 ,   0 ,  'c' ,
    3 ,     0 ,      7 ,   0 ,  'g' ,
    3 ,     0 ,      9 ,   0 ,  'g' ,
    3 ,     0 ,     11 ,   0 ,  'k' ,
    3 ,     0 ,      5 ,  29 ,  'c' ,
    3 ,     0 ,      7 ,  29 ,  'g' ,
    3 ,     0 ,      9 ,  29 ,  'g' ,
    3 ,     0 ,     11 ,  29 ,  'k' ,
    3 ,     0 ,     13 ,  29 ,  'k' ,

here swap - constant /invaders-data
  \ Space occupied by the invaders data.

-->

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: 'invader   ( -- a )  invader-type @ invaders-data +  ;
  \ Data address _a_ of the current invader type.

: invader-lifes   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;
: invader-char    ( -- a )  'invader [ 4 cells ] literal +  ;

-->

( containers ) debug-point

: brick  ( -- )  ." v"  ;

here 1+ s" vvvvvvvvvvvv" s, constant bricks
  \ Compile a string of bricks and save the address
  \ of its first char.

here 1+ s" vxyxyxyxyxy" s, constant containers-top
here 1+ s" vz{z{z{z{z{" s, constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

-->

( containers ) debug-point

 4 constant containers-top-y
15 constant containers-bottom-y

variable containers-x

: containers  ( -- ) ~~
  15 phase @ - containers-x !
  bricks phase @ 2* 2+ 2dup
  containers-x @ containers-bottom-y  at-xy type
  containers-x @ containers-top-y     at-xy type
  phase @ 2* 1+  containers-x @
  containers-top-y [ containers-bottom-y 2- ] literal do
    2dup 2dup
    i 1+ at-xy containers-bottom swap type brick
    i    at-xy containers-top    swap type brick
  -2 +loop  2drop  ;
  \ Draw the nuclear containers.

  \ XXX benchmark:  6102 frames / 1000 executions

-->

( init ) debug-point

: init-game  ( -- )
  3 lifes !  2 phase !  score off  arena  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: init-invaders  ( -- )  ~~
  init-invaders-data  0 invader-type !  30 invaders !
  init-ufo  ;

: init-tank  ( -- )  3 tank-x !  shoot-y off  ;

-->

( init ) debug-point

: parade  ( -- )  ~~
  invader-3 dup invader-2 dup invader-3 dup
  3 13 do
     1 i at-xy dup .2sprite
    29 i at-xy     .2sprite
  -2 +loop  ;
  \ Show the invaders at their initial positions.

: init-arena  ( -- )  ~~ clear-arena containers parade  ;

: init-round  ( -- )  ~~ init-arena init-invaders init-tank  ;

-->

( move-tank ) debug-point

20 constant tank-y      \ coordinate (row)
 3 constant tank-min-x
27 constant tank-max-x

: tank-limit  ( column -- column' )
  tank-max-x min tank-min-x max  ;

: move-tank  ( -- )  ~~
  tank-x @  inkey right-key = abs +
            inkey left-key  =     +
  tank-limit dup tank-x !
  1- tank-y at-xy ."  mn " ;

-->

( move-invader ) debug-point

: at-invader  ( -- )  invader-x @ invader-y @ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

: invader-frame  ( -- c )
  invader-char @ invader-x @ 2 mod 0> 2* +  ;
  \ Frame of the invader.

: .invader-frame  ( -- )  invader-frame .2sprite  ;
  \ Print the frame of the invader.

: .invader  ( n -- )  ~~
    dup at-invader 0> if  space  then
    .invader-frame 0< if  space  then  ;
  \ Print the current invader.
  \ _n_ is its x increment (1 or -1).
  \ XXX FIXME -- graphic spaces

: move-active-invader  ( -- )  ~~

  1 invader-type @ 5 < 0= ?negate  ( 1 | -1 )
    \ XXX TODO simpler, no `0=`

  dup invader-x +!  .invader
  invader-x @ dup 14 phase @ -  =
  if  drop 1  else  15 phase @ + =  then  ;  -->
  \ XXX FIXME -- must return a flag

( move-invader ) debug-point

: move-inactive-invader  ( -- )  ~~
  32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;

: next-invader  ( -- )  ~~
  invader-type @ [ invader-types 1- ] literal =
  if  invader-type off  else  1 invader-type +!  then  ;
  \ XXX FIXME

: (move-invader)  ( -- )  ~~
  invader-active @ if    move-active-invader
                   else  move-inactive-invader  then  ;

: move-invader  ( -- )  ~~
  invader-lifes @ if  (move-invader)  then   next-invader  ;

-->

( ufo ) debug-point

 3 constant ufo-y       \ coordinate (row)
27 constant ufo-max-x   \ coordinate (column)

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo ." |||" init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: flying-ufo  ( -- )  1 ufo-x +! at-ufo ." |op"  ;
  \ Update the position of the UFO and show it.

: (ufo)  ( -- )  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: ufo  ( -- )  ~~
  ufo-invisible? if  1 ufo-x +!  else  (ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;

: ufo-in-fire  ( -- )  ufo-x @ 1+ ufo-y at-xy ." tu"  ;

: ufo-explosion  ( -- )  ufo-in-fire ufo-bang  ;

: ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ 3 at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )
  ufo-explosion ufo-bonus 20 pause -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  shoot-y @ 3 - 2/          \ depending on the row
  shoot-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  shoot-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-explosion  ( -- )
  ;
  \ XXX TODO

: invader-impacted  ( -- )
  -1 invaders +!  invader-explosion invader-bonus  ;

-->

( impact ) debug-point

  \ XXX TODO -- factor

: (impact)  ( -- )
  shoot-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted

  invader-type @ >r

  score @ 1- invader-type !
    \ XXX TODO -- check the original

  invader-x @ dup 15 < abs + invader-y @
  2dup at-xy ." qr"  10 100 beep at-xy 2 spaces
  \ XXX FIXME -- graphic spaces

  -1 invader-lifes +!
  invader-lifes @ if
    invader-active off
    shoot-x @ 15 < abs 29 * invader-x !  at-invader

    shoot-x @ 15 < if  space  then
      \ XXX FIXME -- graphic spaces

    invader-char @ .2sprite
  then  r> invader-type !  ;
  \ Manage the impact.

-->

( impact ) debug-point

: impact  ( -- )
  shoot-y @ 15 < if  (impact)  then  shoot-y off  ;
  \ Manage the impact, if the projectil is high enough.

: missed?  ( -- )
  9216 shoot-y @ 32 * + shoot-x @ + c@ bl =  ;
  \ Did the projectile missed the target?
  \ XXX TODO adapt
  \ XXX TODO reverse the logic: keep the target char

: impact?  ( -- f )
  missed? if  false  else  impact true  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: .projectile  ( -- )  shoot-x @ shoot-y @ at-xy 115 emit  ;
  \ Show the projectile.

: fire  ( -- )
  tank-x @ shoot-x ! [ tank-y 1- ] literal shoot-y !  ;
  \ The tank fires.

: -projectile  ( -- )  shoot-x @ shoot-y @ at-xy space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )  shoot-y @ 5 <  ;
  \ Is the projectile lost?

: shooted  ( -- )
  -projectile projectile-lost?
  if    shoot-y off
  else  -2 shoot-y +! impact? ?exit  .projectile  then  ;
  \ Manage the projectile.

: shooted?  ( -- )  shoot-y @  ;
  \ Has the tank already shooted?

: shoot  ( -- )  ~~
  shooted? if  shooted exit  then
  fire? if  fire  then  ;
  \ Manage the shoot.

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
: new-record    ( -- f )  score @ record !  ;
: check-record  ( -- )  new-record? if  new-record  then  ;

-->

( alive game-over next-phase ) debug-point

22 constant lifes-row

: -life-icon  ( -- )
  lifes @ 2* 2+ lifes-row at-xy 2 spaces  ;
  \ Delete the last lifes icon.
  \ XXX FIXME -- graphic spaces

: .lifes  ( -- )  lifes-row lifes tuck at-xy .  ;
  \ Print number of lifes.

: dead  ( -- )  -1 lifes +!  .lifes -life-icon  ;
  \ One life lost.

: .game-over  ( -- )  11 17 at-xy ." GAME  OVER"  ;

: game-over  ( -- )  .game-over  check-record  ;

: next-phase  ( -- )  ~~
  invaders @ ?exit
  phase @ 5 < abs +! 100 pause init-round  ;

-->

( run ) debug-point

: tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: (round)  ( -- )
  init-round
  begin   2 pause
          move-tank shoot ufo next-phase move-invader
          invader-lifes @ 0=  \ XXX TMP
  until   tune  30 pause  dead  ;
  \ XXX FIXME -- crash -- something is printed out of screen

: round  ( -- )  graphic-font font! (round)  rom-font font!  ;
  \ : round  ( -- )  (round)  ;  \ XXX TMP

: game  ( -- )
  init-game
  begin  round  lifes @ 0=  until
  game-over  200 pause  ;

: run  ( -- )  begin  instructions game  again  ;

-->

( Debugging tools)

: g0  ( -- )  rom-font font!  0 0 at-xy  ;
: g1  ( -- )  graphic-font font!  ;
: g  ( xt -- )  g1 execute g0  ;
: cg  ( xt -- )  cls g1 execute g0  ;

init-game init-invaders init-tank

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14:
  \
  \ Started changing the layout of the original
  \ source code.
  \
  \ 2016-02-15:
  \
  \ Change the layout of the source code.
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ 2016-02-16:
  \
  \ Adapt graphics and data; start factoring.
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-17:
  \
  \ Factor code, improve data, accelerate printing.
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Make the printing of containers faster.
  \ - Improve the invaders' data manipulation.
  \
  \ Finish the initial version of the game screens.
  \ - Convert the last `at-yx` to `at-xy`.
  \ - Add first words to support color.
  \ - Factor, modify and combine the presentation and
  \   instructions screens.
  \ - Name the main sprites.
  \ - Improve the logic of the game round loop.
  \ - Factor the arena screen.
  \ - Factor the printing of lifes.

\ vim: filetype=soloforth
