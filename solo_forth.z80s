; Solo Forth

; A disk-based Forth for ZX Spectrum,
; intended for cross-development of ZX Spectrum programs.
; http://programandala.net/en.program.solo_forth.html

; Copyright (C) 2015 Marcos Cruz (programandala.net)

; ==============================================================
; Version A-00-201506291956

; Latest important changes (in chronological order)
; - `skip`, for the new version of `word`.
; - circular string buffer
; - fix: `require`
; - fix: `emits`
; - change: new header macros, with complete names
; - first alternative code to store name fields in memory bank
; - fix: `(find)`
; - fix: `cfa>nfa` (for name fields in bank)
; - fix: `nfa>string` (for name fields in bank)
; - fix: `nfa>cfa`  (for name fields in bank)
; - fix: `words`  (for name fields in bank)
; - change: `_number` macro used for all `lit_` and `c_lit_`,
;   beside a needed exception.
; - change: `_number` macro is not used, because of a Pasmo's
; bug; everything seems to work again.
; - change: all code for `fig_find?` is copied to a file and commented out.
; - change: all code for `fig_find?` is removed.
; - change: new method for the null word.

; ==============================================================
; Acknowledgments

; See the file <ACKNOWLEDGMENTS.adoc>.

; ==============================================================
; License

; XXX TODO

; Copying and distribution of this file, with or without
; modification, are permitted in any medium without royalty
; provided the copyright notice, the aknowledgments file and
; this notice are preserved.  This file is offered as-is,
; without any warranty.

; ==============================================================
; Description

; ----------------------------------------------
; Forth Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before `next`.
;       DE   Input only when pushde called.
;       HL   Input only when pushhl called.
;       IX   Address of `next`.
;            May be used within Forth words if restored before `next`.

; ----------------------------------------------
; Old header structure -- obsolete

; XXX OLD

; The whole header is created in the dictionary:

; nfa: db length+flags     ; Bits:      76543210
                           ; Bit names: BPSLLLLL
                           ; Legend:
                           ;   B: Name bound bit, always 1.
                           ;   P: Precedence bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;      ds length           ; name
; lfa: dw previous_nfa
; cfa: dw code_address
; pfa:    ...              ; data or code

; ----------------------------------------------
; Improved header structure (experimental, unfinished)

; The name and link fields are created in a memory bank:

; cfap: dw cfa             ; Pointer to cfa in main memory.
; lfa: dw previous_nfa
; nfa: db length+flags     ; Bits:      76543210
                           ; Bit names: BPSLLLLL
                           ; Legend:
                           ;   B: Name bound bit, always 1.
                           ;   P: Precedence bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;      ds length           ; name

; The code and parameter fields are created in the dictionary:

; cfa: dw code_address
; pfa:    ...              ; data or code

; ==============================================================
; Glossary

; The description of Forth words is included in this source.
; The markers `doc{` and `}doc` to delimitate the comments that
; form the glossary.

; ----------------------------------------------
; Stack notation

; a        = address
; ca       = character-aligned address

; f        = flag (false is 0; true is any other value)
; tf       = true flag (1)
; ff       = false flag (0)
; wf       = well-formed flag (false is 0; true is 1)

; c        = 8-bit character
; u        = 16-bit unsigned number
; len      = 16-bit unsigned number, length of memory zone or string
; ca len   = string
; n        = 16-bit signed number
; x        = 16-bit signed or unsigned number
; d        = 32-bit signed double number
; ud       = 32-bit unsigned double number
; xd       = 32-bit signed or unsigned number

; x y      = pair of 8-bit graphic coordinates
; line col = pair of 8-bit cursor coordinates

; cfa      = address of code field
; lfa      = address of link field
; nfa      = address of name field
; pfa      = address of parameter field

; ----------------------------------------------
; Parsed text notation

; XXX TODO

; <char>          the delimiting character marking the end of the
;                 string being parsed
; <chars>         zero or more consecutive occurrences of the
;                 character char
; <space>         a delimiting space character
; <spaces>        zero or more consecutive occurrences of the
;                 character space
; <quote>         a delimiting double quote
; <paren>         a delimiting right parenthesis
; <eol>           an implied delimiter marking the end of a line
; ccc             a parsed sequence of arbitrary characters,
;                 excluding the delimiter character
; text            same as ccc
; name            a token delimited by space, equivalent to
;                 ccc<space> or ccc<eol>


; ----------------------------------------------
; Word attributes

; The capital letters on the right show definition characteristics:

; C      May only be used within a colon definition. A digit indicates number
;        of memory addresses used, if other than one. A plus sign indicates
;        a variables number of memory addresses used.
; E      Intended for execution only.
; I      Immediate. Has precedence bit set. Will execute even when compiling.
; U      A user variable.

; ==============================================================
; Configuration

  ; XXX experimental
size_optimization?: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

  ; XXX TODO -- not used yet
fig_parsing?: equ false
  ; true = the fig-Forth parsing words are used.
  ; false = parsing is modified after Forth-83 and ANS Forth.

  ; XXX FIXME Pasmo gives strange errors (symbols not found)
  ; when this config flag is used in nested `if`. A literal flag
  ; (0/1) is used instead, with the flag name in a comment; it
  ; is changed with a text substitution, and Vim mappings
  ; are created to turn it on an off.
;names_in_memory_bank?           equ true
  ; true = name fields and link fields are stored in a memory
  ; bank page, saving dictionary space.
  ; false = name fields and link fields are stored in the
  ; dictionary.

  ; XXX TODO
;fig_does?: equ true
  ; true = the fig-Forth `<builds does>` pair is used
  ; false = the modern `create does>` pair is used

  ; XXX TODO
fig_null_word?: equ false
  ; true = the fig-Forth null word is used to detect the end of
  ; the buffers: a word of one zero character. a null character
  ; is at the end of the buffers. the scanning words (old
  ; `enclose`, new `skip` and `scan`) must treat the null
  ; character as a special unconditional delimiter, and do other
  ; tricks, to simulate the null character found is a parsed
  ; null word.
  ;
  ; false = the same word is used, but the scanning words does
  ; not treat the null char apart; instead, a null and a space
  ; are put after the buffers (disk buffers and `tib`), thus
  ; making the null word to be parsed normally as any other
  ; word. this new method is compatible with the original
  ; fig-Forth parsing words.

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

origin:                           equ 0x5E00

false:                            equ 0
true:                             equ 1

cell:                             equ 2

cells_per_data_stack:             equ 0x50
cells_per_return_stack:           equ 0x50

bytes_per_terminal_input_buffer:  equ 0x50

buffers:                          equ 0x02
data_bytes_per_buffer:            equ 0x0200
total_bytes_per_buffer:           equ data_bytes_per_buffer+4
blocks_per_screen:                equ 0x02
screens_per_disk:                 equ 0x030C ; 780 KiB per disk in G+DOS
characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10

name_bound_bit:       equ 7
name_bound_bit_mask:  equ 1 shl name_bound_bit
precedence_bit:       equ 6
precedence_bit_mask:  equ 1 shl precedence_bit
smudge_bit:           equ 5
smudge_bit_mask:      equ 1 shl smudge_bit

max_word_length:                equ 0x1F
max_word_length_bit_mask:       equ max_word_length

csb_size:                       equ 256 ; circular string buffer

dummy_name_field: equ 0xA081 ; original
;dummy_name_field: equ 0xA000 ; XXX TODO needed for the name fields in bank?

null_word: equ 0x2000 ; a null followed by a blank

; Memory banks

default_bank: equ 0
names_bank:   equ 1

names_bank_address: equ 0xC000 ; names pointers

; Error messages are in the disk, starting from the screen
; number hold in the `msg-scr` constant.  Error codes 0, 16, 32
; etc are not used, because they coincide with the first line of
; screens.

; XXX TODO change the order

not_understood_error:               equ 01
stack_empty_error:                  equ 02
dictionary_full_error:              equ 03 ; not used
not_unique_error:                   equ 04
not_found_error:                    equ 05
out_of_disk_range_error:            equ 06
full_stack_error:                   equ 07
number_08_error:                    equ 08 ; free
loading_from_screen_0_error:        equ 09
number_10_error:                    equ 10 ; free
number_11_error:                    equ 11 ; free
number_12_error:                    equ 12 ; free
number_13_error:                    equ 13 ; free
number_14_error:                    equ 14 ; free
number_15_error:                    equ 15 ; free
compilation_only_error:             equ 17
execution_only_error:               equ 18
conditionals_not_paired_error:      equ 19
definition_not_finished_error:      equ 20
protected_dictionary_error:         equ 21
loading_only_error:                 equ 22
off_current_editing_screen_error:   equ 23
declare_vocabulary_error:           equ 24
unsupported_tape_operation_error:   equ 25
unsupported_disk_operation_error:   equ 26
source_file_needed_error:           equ 27
not_present_though_required_error:  equ 28
required_but_not_located_error:     equ 29
number_30_error:                    equ 30 ; free
number_31_error:                    equ 31 ; free
number_33_error:                    equ 32 ; free

; ----------------------------------------------
; Character codes

caps_char:                  equ 0x06 ; toggle caps lock
edit_char:                  equ 0x07 ; edit
backspace_char:             equ 0x08
delete_char:                equ 0x0c ; delete (backspace)
form_feed_char:             equ 0x0c ; used for printing
carriage_return_char:       equ 0x0d
extended_mode_char:         equ 0x0e ; Fuse associates it to the host's Tab key
graphics_char:              equ 0x0f ; toggle graphics mode
ink_char:                   equ 0x10
paper_char:                 equ 0x11
flash_char:                 equ 0x12
bright_char:                equ 0x13
inverse_char:               equ 0x14
over_char:                  equ 0x15
at_char:                    equ 0x16
tab_char:                   equ 0x17 ; tab (screen only)
space_char:                 equ 0x20

; ----------------------------------------------
; ROM  routines

rom_beeper:                      equ 0x03B5
rom_border_0x2297:               equ 0x2297
rom_break_key:                   equ 0x1F54
rom_chan_open:                   equ 0x1601
rom_cl_all:                      equ 0x0DAF
rom_find_int1:                   equ 0x1E94
rom_key_decode:                  equ 0x0333
rom_key_scan:                    equ 0x028E
rom_key_test:                    equ 0x031E
rom_plot_0x22DF:                 equ 0x22DF
rom_point_sub_0x22CE:            equ 0x22CE
rom_s_attr_s_0x2583:             equ 0x2583
rom_s_scrn_s_0x2538:             equ 0x2538
rom_sa_all:                      equ 0x075A
rom_set_permanent_colors_0x1CAD  equ 0x1CAD
rom_stack_fetch:                 equ 0x2BF1

; ----------------------------------------------
; System variables

  ; XXX FIXME Pasmo's bug?: `sys_errnr` is used as the base offset.  When it's
  ; not the defined first, the compilation halts with error "offset out of
  ; range", though they are fine in the symbols file.

sys_errnr:         equ 0x5C3A ; IY index

sys_attr_p:        equ 0x5C8D
sys_bankm:         equ 0x5B5C
sys_coordx:        equ 0x5C7D
sys_coordy:        equ 0x5C7E
sys_df_cc:         equ 0x5C84
sys_df_sz:         equ 0x5C6B
sys_df_sz_offset:  equ sys_df_sz-sys_errnr
sys_flags2:        equ 0x5C6A
sys_last_k:        equ 0x5C08
sys_mode:          equ 0x5C41
sys_s_posn:        equ 0x5C88
sys_scr_ct:        equ 0x5C8C
sys_scr_ct_offset: equ sys_scr_ct-sys_errnr
sys_t_addr:        equ 0x5C74
sys_udg:           equ 0x5C7B

; ----------------------------------------------
; Ports

bank1_port:        equ 0x7FFD

; ==============================================================
; Macros

; ----------------------------------------------
; Header

immediate: equ 1 ; used as optional parameter
previous_nfa: defl 0 ; link to previous Forth word

_header: macro _base_label,_name,_is_immediate

  flags: defl name_bound_bit_mask
  if not nul _is_immediate
    flags: defl flags | precedence_bit_mask ; add precedence bit
  endif

  if 1 ; names_in_memory_bank?

    ; In dictionary:

    _base_label: ; code field address
    local _dp_backup
    local _name_address
    local _address_after_name
    _dp_backup: equ $

    ; In memory bank:

    org np
    _base_label##cfap: 
      dw _base_label ; code field address pointer
    _base_label##lfa: ; link field address
      dw previous_nfa ; link field
    _base_label##nfa: ; name field address
    flags: defl name_bound_bit_mask
      if not nul _is_immediate
        flags: defl flags | precedence_bit_mask ; add precedence bit
      endif
      db _address_after_name-_name_address+flags ; length
    _name_address: equ $
      db _name ; name field
    _address_after_name: equ $
    np: defl $

    ; Update the names pointer:
    org names_pointer
    dw np
    dw np

    ; In dictionary:
    org _dp_backup

  else

    _base_label##nfa: ; name field address
      db _base_label##lfa-_base_label##nfa-1+flags ; length and flags byte
      db _name ; name field
    _base_label##lfa: ; link field address
      dw previous_nfa ; link field
    _base_label: ; code field address

  endif

  previous_nfa: defl _base_label##nfa

  endm

_code_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw _base_label##pfa ; code field
  _base_label##pfa: ; parameter field address

  endm

_code_alias_header: macro _base_label,_name,_is_immediate,_alias

  _header _base_label,_name,_is_immediate
  dw _alias##pfa ; code field

  endm

_colon_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_does ; code field
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_create ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_create ; code field
  _base_label##pfa: ; parameter field address

  endm


; ----------------------------------------------
; Literals

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_number: macro _n
  if _n=0
    dw zero_
  else
    if _n=1
      dw one_
    else
      if _n=2
        dw two_
      else
        if _n>=0 && _n<=255
          dw c_lit_
          db _n
        else
          dw lit_
          dw _n
        endif
      endif
    endif
  endif
  endm

; ----------------------------------------------
; Jumps

_jp_next: macro

  jp (ix)

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization?
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization?
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization?
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Bank

_bank: macro _n
  _number _n
  dw bank_
  endm

_names_bank: macro
  _bank names_bank
  endm

_default_bank: macro
  _bank default_bank
  endm

; ----------------------------------------------
; Error messages

_question_error: macro _error
  _number _error
  dw question_error_
  endm

_message: macro _error
  _number _error
  dw message_
  endm

; ----------------------------------------------
; Debug

_border: macro _color
  local _pause0
  push af
  push bc
  ld a,_color
  out(0xFE),a
  ld bc,0
  _pause0:
  dec bc
  ld a,b
  or c
  jr nz,_pause0
  pop bc
  pop af
  endm

_border_wait: macro _color
  local _wait
  push af
  ld a,_color
  out(0xFE),a
  xor a
  ld (sys_last_k),a
  _wait:
  ld a,(sys_last_k)
  and a
  jr z,_wait
  pop af
  endm

_echo: macro _txt
  dw cr_,paren_dot_quote_
  _string _txt
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location: `0x00 +origin`
  jp cold_start
warm_entry:
  ; Location: `0x03 +origin`
  jp warm_start

; ==============================================================
; Parameter area

top_most_word_in_forth_voc:
  ; Location: `0x06 +origin`
  dw nfa_of_top_most_word_in_forth_voc

user_variables_pointer:
  ; Location: `0x08 +origin`
  dw user_variables

return_stack_pointer:
  ; Location: `0x0A +origin`
  dw return_stack_bottom

  ; User variables default values

  ; The first eight user variables have default values.  They are used
  ; by `cold` to overwrite the correspondent user variables.  They must
  ; be in the same order than user variables.

default_user_variables_start:

s0_init_value:
  ; Location: `0x0C +origin`
  dw data_stack_bottom
r0_init_value:
  ; Location: `0x0E +origin`
  dw return_stack_bottom
tib_init_value:
  ; Location: `0x10 +origin`
  dw terminal_input_buffer
width_init_value:
  ; Location: `0x12 +origin`
  dw max_word_length
warning_init_value:
  ; Location: `0x14 +origin`
  dw 0x0000
fence_init_value:
  ; Location: `0x16 +origin`
  dw dictionary_pointer_after_cold
dp_init_value:
  ; Location: `0x18 +origin`
  dw dictionary_pointer_after_cold
voc_link_init_value:
  ; Location: `0x1A +origin`
  dw forth_vocabulary_link

default_user_variables_end:

ip_backup: ; temporary copy of Forth IP
  dw 0

if 1 ; names_in_memory_bank?

  np: defl names_bank_address+1

names_pointer:
  ; First free address in the names bank.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

names_pointer_init_value:
  ; Init value of the names pointer, restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

endif

; ==============================================================
; User variables

user_variables:

s0_value: ; +0x00
  dw 0x0000
r0_value: ; +0x02
  dw 0x0000
tib_value: ; +0x04
  dw 0x0000
width_value: ; +0x06
  dw 0x0000
warning_value: ; +0x08
  dw 0x0000
fence_value: ; +0x0A
  dw 0x0000
dp_value: ; +0x0C
  dw 0x0000
voc_link_value: ; +0x0E
  dw 0x0000
blk_value: ; +0x10
  dw 0x0000
in_value: ; +0x12
  dw 0x0000
out_value: ; +0x14
  dw 0x0000
scr_value: ; +0x16
  dw 0x0000
  ; +0x18 ; not used (formerly `offset`)
  dw 0x0000
context_value: ; +0x1A ; XXX TODO use more space, for `order`
  dw 0x0000
current_value: ; +0x1C
  dw 0x0000
state_value: ; +0x1E
  dw 0x0000
base_value: ; +0x20
  dw 0x0000
dpl_value: ; +0x22
  dw 0x0000
fld_value: ; +0x24
  dw 0x0000
csp_value: ; +0x26
  dw 0x0000
r_hash_value: ; +0x28 ; XXX OLD -- used by the editor, remove
  dw 0x0000
hld_value: ; +0x2A
  dw 0x0000

  ; Unused
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Circular string buffer

csb:
csb_unused:
  if csb_size<256
    dw csb_size
  else
    db csb_size
  endif
csb0:
  ds csb_size
csb_total_size: equ $-csb

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer
; XXX OLD -- not practical, because the input address can be
; different
;if ! fig_null_word?
;  dw null_word
;endif

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffers

first_buffer:
  ds blocks_per_screen*total_bytes_per_buffer
limit:

; ==============================================================
; Misc routines

; [Taken from DZX-Forth.]

; ----------------------------------------------
; Compare de and hl

compare_de_hl_unsigned:

  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de

  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:

  ; Input:  de, hl
  ; Output: flag C if hl < de

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ----------------------------------------------
; Move block

move_block:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy the contents of bc consecutive address
  ; units at hl to the bc consecutive address units at de. After the move
  ; completes, the bc consecutive address units at de contain exactly what the
  ; bc consecutive address units at hl contained before the move.

  call compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

move_block_upwards:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from higher addresses to lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ==============================================================
; :Inner interpreter

push_de_hl:
  push de

push_hl:
  push hl

next:
  ; Execute the word pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa

next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa)
  ; de = cfa+1 = pfa-1

  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
  _colon_header s_lit_,'SLIT'

  ; : slit  ( -- ca len )  r@ count dup 1+ r> + >r  ;

  dw r_fetch_,count_,dup_,one_plus_
  dw from_r_,plus_,to_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_s_,'(S)'

; doc{
;
; (s) ( compilation: c "text<c>" -- ) ( run-time:  -- ca len )
;
; }doc

  dw parse_ ; ( ca len )
  dw comp_question_
  dw zero_branch_,paren_s.interpreting
  ; compiling
  dw s_literal_
  dw semicolon_s_
paren_s.interpreting:
  dw save_string_
  dw semicolon_s_

; ----------------------------------------------
  _code_header c_lit_,'CLIT'

  ld a,(bc)
  inc bc
push_a:
  ld l,a
push_l: ; XXX TMP -- not used yet
  ld h,0
  jp push_hl

; ----------------------------------------------
  _code_header lit_,'LIT'

  ; XXX FIXME -- crash if not compiling
  ; XXX TODO -- implement compile-only flag?

  ld a,(bc)
  inc bc
  ld l,a
  ld a,(bc)
  inc bc
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header bank_,'BANK'

; doc{
;
; bank  ( n -- )
;
; Page memory bank _n_ (0..7) at 0xC000..0xFFFF.
;
; }doc

  pop de ; e = bank
  call bank.e
  _jp_next

bank.default:
  ; XXX TODO ?
bank.names:
  ; XXX TODO ?
bank.e:
  ; ret ; XXX TMP for debugging
  di
  ld a,(sys_bankm) ; get the saved status of BANKM
  and 0xF8 ; erase bits 0-2
  or e ; modify bits 0-2
  ld (sys_bankm),a ; update BANKM
  out (bank1_port),a ; page the bank
  ei
  ret

; ----------------------------------------------
  _code_header csb_unused_,'CSB-UNUSED'

; doc{
;
; csb-unused  ( -- len )
;
; }doc

  if csb_size<256
    ld a,(csb_unused)
    jp push_a
  else
    ld hl,(csb_unused)
    jp push_hl
  endif

; ----------------------------------------------
  _constant_header csb0_,'CSB0'

; doc{
;
; csb0  ( -- a )
;
; }doc

  dw csb0

; ----------------------------------------------
  _colon_header question_csb_,'?CSB'

; doc{
;
; ?csb  ( len -- )
;
; Make sure there's room for the given characters.
;
; }doc

  dw dup_,lit_,csb_unused,fetch_,greater_than_
  dw zero_branch_,question_csb_.enough
  ; not enough space; reset the pointer
  dw lit_,csb_size,lit_,csb_unused,store_
question_csb_.enough:
  dw negate_,lit_,csb_unused,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header string_allocate_,'STRING-ALLOCATE'

; doc{
;
; string-allocate  ( len -- ca )
;
; }doc

  dw question_csb_
  dw csb0_,csb_unused_,plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header save_string_,'SAVE-STRING'

; doc{
;
; save-string  ( ca1 len1 -- ca2 len1 )
;
; }doc

  dw dup_,string_allocate_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header save_counted_string_,'SAVE-COUNTED-STRING'

; doc{
;
; save-counted-string  ( ca1 len1 -- ca2 )
;
; }doc

  dw dup_,one_plus_,string_allocate_
  dw dup_,to_r_,dollar_store_,from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header empty_csb_,'EMPTY-CSB'

; doc{
;
; empty-csb  ( -- )
;
; }doc

  dw lit_,csb
  if csb_total_size<256
    dw c_lit_
    db csb_total_size
  else
    dw lit_,csb_total_size
  endif
  dw erase_
  dw semicolon_s_

; ----------------------------------------------
  _code_header execute_,'EXECUTE'

; doc{
;
; execute  ( cfa  -- )
;
; }doc

  pop hl
  jp next2

; ----------------------------------------------
  _code_header perform_,'PERFORM'

; doc{
;
; perform  ( a  -- )
;
; Execute the word whose cfa is stored in _a_.  Do nothing if
; the content of _a_ is zero.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  or h
  ld l,a
  jp nz,next2
  _jp_next

; ----------------------------------------------
  _colon_header forward_mark_,'>MARK'

; doc{
;
; >mark  ( -- a )  \ Forth-83, C, "forward-mark"
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; }doc

  dw question_comp_
  dw here_,zero_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLVE'

; doc{
;
; >resolve  ( a -- )  \ Forth-83, C, "forward-resolve"
;
; Calculate the branch address (to the current location in the
; dictionary) using _a_ and place this branch address into the
; space left by `>mark`.
;
; Used at the destination of a forward branch.
;
; }doc

  dw question_comp_
  dw here_,swap_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_mark_,'<MARK'

; doc{
;
; <mark  ( -- a )  \ Forth-83, C, "backward-mark"
;
; Used at the destination of a backward branch.  _a_ is
; typically only used by `<resolve` to compile a branch address.
;
; }doc

  dw question_comp_
  dw here_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_resolve_,'<RESOLVE'

; doc{
;
; <resolve  ( a -- )  \ Forth-83, C, "backward-resolve"
;
; Used at the source of a backward branch after either `branch`
; or `?branch` or `0branch`.  Compiles a branch address using
; _a_ as the destination address.
;
; }doc

  dw question_comp_
  dw comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header branch_,'BRANCH'

; doc{
; 
; branch  ( -- )  \ ANS Forth
;
; The run-time procedure to branch unconditionally. An in-line
; offset is copied to the interpretive pointer IP to branch
; forward or backward.
;
; }doc

  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  _jp_next

; ----------------------------------------------
  _code_header zero_branch_,'0BRANCH'

; doc{
; 
; 0branch  ( f -- )  \ fig-Forth
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is false (zero), the following in-line address is copied to IP
; to branch forward or  backward.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_pfa
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANCH'

; doc{
; 
; ?branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is not zero, the following in-line address is copied to IP to
; branch forward or backward.
; 
; Note: This is not Forth-83's `?branch`: Forth-83's `?branch`
; does the same than fig-Forth's `0branch`: the branch is done
; when the flag is zero. Solo Forth includes fig-Forth's
; `0branch` and also `?branch`, that branches when the flag is
; not zero.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_pfa
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

  ; XXX NOTE:
  ;
  ; This code is from Abersoft Fort.  It's the same code used in
  ; `(+loop)` in fig-Forth 1.1g.  The author of Abersoft Forth
  ; used it to write `(loop)` and wrote `(+loop)` with a simple
  ; call to it, what saves code.
  ;
  ; XXX TODO -- The `(loop)` of DZX-Forth is much faster, but
  ; requires and additional parameter on the return stack.

  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_stack_pointer)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl ; (hl) = limit
  inc d
  dec d
  ld d,a ; de = new index
  jp m,l5eedh

  ; increment>0
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp l5ef2h

l5eedh: ; increment<0
  ld a,(hl) ; limit-index
  sub e
  inc hl
  ld a,(hl)
  sbc a,d ; a<0?

l5ef2h:
  jp m,branch_pfa ; loop again if a<0
  ; done, discard loop parameters
  inc hl
  ld (return_stack_pointer),hl
  ; skip branch offset
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  pop de
  jp paren_loop.step_in_de

; ----------------------------------------------

if 0

  _colon_header paren_question_do_,'(?DO)'

  ; XXX TODO -- first draft, just copied from DZX-Forth

  ; XXX FIXME -- crash in both cases

  dw two_dup_,equals_
  dw question_branch_,paren_question.end
  dw paren_do_
  dw semicolon_s_
paren_question.end:
  dw two_drop_
  dw from_r_,fetch_,to_r_
  dw semicolon_s_

endif
  
; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; [Code from CP/M fig-Forth 1.1g.]

  exx                           ; 04t 01b
  pop de                        ; 10t 01b
  pop bc                        ; 10t 01b
  ld hl,(return_stack_pointer)  ; 20t 03b
  dec hl                        ; 06t 01b
  ld (hl),b                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),c                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),d                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),e                     ; 07t 01b
  ld (return_stack_pointer),hl  ; 16t 03b
  exx                           ; 04t 01b
                                ;116t 18b TOTAL
  _jp_next

; ----------------------------------------------
; XXX TODO experimental do-loop structures adapted from Spectrum Forth-83

; A do-loop pushes three items on the return stack:
;
; 0) Limit
; 1) Reverse branch address (jump to here if loop repeats).
; 2) Current index (represented as `(index-limit) xor 0x8000`.
;    This is at the top.
;    The current index is represented this way so it is easier
;    to check whether index has crossed the boundary between
;    limit-1 and limit, acoording to
;    the rules of Forth-83, even with negative increment in +LOOP.

  _code_header paren_do83_,'(DO83)'

  pop hl ; initial value
  pop de ; limit
  push hl ; initial value
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e ; push limit value on return stack
  inc bc
  inc bc ; increment the instruction pointer, skip branch address
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c ; push current instruction pointer on return stack
  ex (sp),hl ; initial value now in HL, return stack pointer on stack
  and a ; reset the carry flag
  sbc hl,de ; B SBCP        \ Subtract limit value.
  ld a,h ; H A LD
  xor 0x80 ; 80 XOR#       \ Flip most significant bit.
  ld d,a ; A B LD
  ld e,l ; L C LD        \ Move result to DE.
  pop hl ; H POP        \ Get return stack pointer from stack,
  dec hl ; H DEC
  ld (hl),d ; B M LD
  dec hl ; H DEC
  ld (hl),e ; C M LD        \ Push (initial - limit) XOR 0x8000 onto return stack.
  ld (return_stack_pointer),hl ; RPTR STHL       \ Save return stack pointer.
  _jp_next ; JPIX ;C

  _code_header paren_question_do83_,'(?DO83)'

  pop hl ; initial value
  pop de ; limit
  and a ; reset the carry flag
  sbc hl,de ; compare
  jr z,question_do.equals
  ; not equals
  add hl,de ; reverse the subtraction
  push de ; limit
  push hl ; inital value
  jr paren_do_pfa ; perform regular `do`
  question_do.equals:
  jp branch_pfa ; XXX TODO

  _colon_header question_do83_,'?DO83',immediate

  dw compile_,paren_question_do83_
  dw forward_mark_
  dw c_lit_
  db 3
  dw semicolon_s_

  _colon_header do83_,'DO83',immediate

  dw compile_,paren_do83_
  dw forward_mark_
  dw c_lit_
  db 3
  dw semicolon_s_

  _colon_header loop83_,'LOOP83',immediate

  dw c_lit_
  db 3
  dw question_pairs_
  dw compile_,paren_loop83_
  dw forward_resolve_
  dw semicolon_s_

  _colon_header paren_loop83_,'(LOOP83)'

  ld hl,(return_stack_pointer)
  ld e,(hl) ; M C LD
  inc hl    ; H INC
  ld d,(hl) ; M B LD         \ Read current index value.
  inc de    ; B INC         \ Increment it.
  ld a,d    ; B A LD
  xor 0x80  ; 80 XOR#
  or e      ;  C OR         \ Was it equal to 0x8000 ?
  jp nz,paren_loop83.loop ; jump if not

  ; The real index has reached limit, terminate loop.
  ; Increment ret stack pointer by 5 (1 increment already done).
  ld de,5   ; 5 B LDP#
  add hl,de ; B ADDP
  ld (return_stack_pointer),hl ; RPTR STHL
  _jp_next

paren_loop83.loop:

  ld (hl),d ;  B M LD
  dec hl    ; H DEC
  ld (hl),e ; C M LD    \ Store updated index.
  inc hl    ; H INC
  inc hl    ; H INC
  ld c,(hl) ; M E LD
  inc hl    ; H INC
  ld c,(hl) ; M D LD   \ Read loop start address into instruction pointer, repeat loop.
  _jp_next

; ----------------------------------------------
  _code_alias_header i_,'I',,r_fetch_

; doc{
;
; i  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
;
; x1 = loop index
; x2 = loop limit
; 
; Get a copy of the current (innermost) do-loop index.
;
; }doc

; ----------------------------------------------
  _code_header digit_,'DIGIT'

; doc{
;
; digit  ( c n1 --- n2 tf | ff )  \ fig-Forth
;
; Convert the ascii character _c_ (using base _n1_) to its
; binary equivalent n2, accompanied by a true flag. If the
; conversion is invalid, leave only a false flag.
;
; }doc

  pop hl  ; l=base
  pop de  ; e=character
  ld a,e  ; character
  sub '0' ; >="0"
  jp c,false_pfa ; <"0" is invalid
  cp 0x0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub 0x07 ; gap between "9" & "A", now "A"=0x0A
  cp 0x0A ; >="A"?
  jp c,false_pfa ; characters between "9" & "A" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_pfa ; no, invalid
  ld e,a ; converted digit
  ld hl,0x0001 ; true ; XXX TODO change when true=-1
  jp push_de_hl

; ----------------------------------------------
  _code_header paren_find_,'(FIND)'

if 1 ; names_in_memory_bank?

  ; XXX FIXME -- does not find words?

; doc{
;
; (find)  ( ca nfa --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX Note: this version uses the name fields stored in a
  ; memory bank, with a different format.

  ld e,names_bank
  call bank.e ; page the memory bank

  pop de ; nfa
  pop hl ; string address
  push bc ; save the Forth IP
  ld (paren_find.string_address),hl

  ; XXX FIXME the string searched for must be in the string
  ; buffer, below 0xC000! This is not a problem now, during the
  ; development, because the dictionary is small.

paren_find.begin:
  ;_border 2 ; XXX INFORMER
  ;_border 7 ; XXX INFORMER
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save the nfa for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; length byte of the name field
  ld c,a    ; save for later
  and max_word_length_bit_mask  ; length
  cp (hl) ; same length?
  jr nz,paren_find.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  ld b,a ; length
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl) ; match?
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; c = name field length byte
  ld hl,(paren_find.nfa_backup)
;  ld (0xfffa),hl ; XXX INFORMER ; nfa, ok
  dec hl
  dec hl ; lfa
  dec hl ; high part of the pointer to cfa
  ld d,(hl)
  dec hl ; low part of the pointer to cfa
  ld e,(hl) ; de = cfa

;  ld (0xfffc),de ; XXX INFORMER ; cfa, ok

  ld hl,1 ; 1=immediate word
  ld a,c ; name field length byte
  and precedence_bit_mask ; immediate word?
  jp nz, paren_find.end
  ; non-immediate word
  dec hl
  dec hl ; -1 = non-immediate word

paren_find.end:
  ; If match found:
  ;   de = cfa
  ;   hl = -1 | 1
  ; If no match found:
  ;   de = ca
  ;   hl = 0
  exx
  ld e,default_bank
  call bank.e ; page the default memory bank
  exx
  pop bc ; restore the Forth IP
  ; _border 4 ; XXX INFORMER
  jp push_de_hl

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  dec hl ; high address of lfa
  ld d,(hl) ; high part of the next nfa
  dec hl ; low address of lfa
  ld e,(hl) ; low part of the next nfa
  ld a,d
  or e ; end of dictionary? (next nfa=0)
  jp nz,paren_find.begin ; if not, continue
  ; End of dictionary, no match found, return.
  ld de,(paren_find.string_address)
  ld hl,0
  jp paren_find.end


else
  
; doc{
;
; (find)  ( ca nfa --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX Note: this version uses the new format name field,
  ; and is used by the new version of `find`, written after
  ; Forth-83.

  ld (ip_backup),bc ; save Forth IP
  pop de ; nfa
  pop hl ; string address
  ld (paren_find.string_address),hl

paren_find.begin:
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; name field length byte
  ld c,a    ; save for later
  and max_word_length_bit_mask  ; length
  cp (hl)
  jr nz,paren_find.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  ld b,a ; length, used as count
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl)
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; de = address of the last char of the name field
  ; c = name field length byte
  inc de ; de = lfa
  inc de
  inc de ; de = cfa
  ld hl,1 ; 1=immediate word
  ld a,c ; name field length byte
  ld bc,(ip_backup) ; restore Forth IP
  and precedence_bit_mask ; immediate word?
  jp nz,push_de_hl
  ; non-immediate word
  dec hl
  dec hl ; -1 = non-immediate word
  jp push_de_hl

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  ld a,c ; length byte
  and max_word_length_bit_mask  ; actual length
  ld c,a ; actual length
  inc c ; plus the length byte
  ld b,0
  add hl,bc ; hl = lfa
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e ; end of dictionary?
  jp nz,paren_find.begin ; if not, continue

  ; No match found, return.
  ld bc,(ip_backup) ; restore Forth IP
  ld de,(paren_find.string_address)
  ld hl,false
  jp push_de_hl

endif

; ----------------------------------------------
  _code_header scan_,'SCAN'

if false ; XXX From DXZ-Forth, for ANS Forth parsing

; scan  ( ca1 len1 c -- ca2 len2 )

  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
scan.begin:
  ld a,c
  or b
  _jump_z scan.end
  ld a,e
  cp (hl)
  _jump_z scan.end
  inc hl
  dec bc
  jp scan.begin ; again

scan.end:
  ex (sp),hl ; hl = Forth IP ; push ca2
scan.3:
  push bc ; len2
  ld c,l
  ld b,h ; restore Forth IP
  _jp_next

endif

if 0 ; XXX TMP -- version for fig-Forth parsing

; doc{
;
; scan  ( ca1 c -- ca2 )
;
; ca1 = text address
; c = ascii delimiting character
; ca2 = start of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc


  pop de ; e = delimiter
  pop hl ; ca1
  push bc ; save Forth IP
scan.begin:
  ld a,(hl)
  or a ; null?
  _jump_z scan.end
  cp e
  _jump_z scan.end
  inc hl
  jp scan.begin ; again

scan.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

if 0 ; from the new `(parse)`

; doc{
;
; scan  ( c ca -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop de ; address
  pop hl ; delimiter
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
scan.begin:
  ld a,(de)
  cp c ; delimiter?
  jr z,scan.end

  ; Increase the length before the last check, so the first null
  ; char will be interpreted as the null word, one char length.
  ; XXX FIXME bad effect: the last word of the buffer receives
  ; on additional byte in its count!

  inc hl

  or a ; unconditional null delimiter?
  jr z,scan.end
  inc de
  jp scan.begin ; repeat
scan.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

if 1 ; XXX NEW for `! fig_null_word?`

; doc{
;
; scan  ( ca c -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; }doc

  pop hl ; delimiter
  pop de ; address
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
  dec hl
  dec de
scan.begin:
  inc hl
  inc de
  ld a,(de)
  cp c ; delimiter?
  jr nz,scan.begin
  ; delimiter found
  pop bc ; restore Forth IP
  jp push_hl

endif

; ----------------------------------------------
  _code_header skip_,'SKIP'

if 0 ; XXX From DXZ-Forth, for ANS Forth parsing

; skip  ( ca1 len1 c -- ca2 len2 )

  pop de
  ld l,c
  ld h,b
  pop bc ; len1
  ex (sp),hl ; hl=ca1 ; save Forth IP
skip.begin:
  ld a,c
  or b ; exhausted?
  jp z,scan.end
  ld a,e
  cp (hl) ; delimiter?
  jp nz,scan.end
  inc hl
  dec bc
  jp skip.begin ; again

endif

if 0 ; XXX TMP -- version for fig-Forth parsing

; skip  ( ca1 c -- ca2 )

  pop de ; e = delimiter
  pop hl ; ca1
  push bc ; save Forth IP
skip.begin:
  ld a,(hl)
  or a ; null delimiter?
  jp z,scan.end
  cp e ; delimiter?
  jp nz,scan.end
  inc hl
  jp skip.begin ; again

endif

if 0 ; XXX NEW for `word`

; skip  ( c ca1 -- ca2 )

  pop hl ; ca1
  pop de ; e = delimiter
skip.begin:
  ld a,(hl)
  or a ; unconditional null delimiter?
  jp z,push_hl
  cp e ; delimiter?
  jp nz,push_hl
  inc hl
  jp skip.begin ; again

endif

if 1 ; XXX NEW for `! fig_null_word?`

; skip  ( ca1 c -- ca2 )

  pop de ; e = delimiter
  pop hl ; ca1
skip.begin:
  ld a,(hl)
  cp e ; delimiter?
  jp nz,push_hl
  inc hl
  jp skip.begin ; again

endif


; ----------------------------------------------
  _code_header enclose_,'ENCLOSE'

  ; XXX OLD

  ; doc{
  ;
  ; enclose  ( c ca -- ca n1 n2 n3 )
  ;
  ; The text scanning primitive used by `word`.
  ;
  ; c = delimiting character
  ; ca = text address
  ; n1 = byte offset to the first non-delimiter character
  ; n2 = byte offset to the first delimiter after the text
  ; n3 = byte offset to the first character not included
  ;
  ; This procedure will not process past an ASCII 'null',
  ; treating it as an unconditional delimiter.
  ;
  ; Note: This is not the fig-Forth `enclose`: the order of the
  ; input parameters has been changed, to save a `swap` in
  ; `word`.
  ;
  ; }doc

  ; XXX OLD -- this will be substituted by `(parse)`.

  exx ; save the Forth IP
  pop hl ; hl = address
  pop de ; e  = delimiter
  push hl
  ld a,e  ; a = delimiter
  ld bc,-1 ; init char offset counter
  dec hl

enclose.skip:
  ; Skip initial delimiters.
  ; hl = previous address
  ; a = delimiter
  ; bc = offset
  inc hl
  inc bc
  cp (hl) ; delimiter?
  jp z,enclose.skip ; yes, loop

  ; First non-delimiter found.
  push bc ; save offset
  ld a,(hl)
  and a ; is the first non-delimiter a null?
  jp nz,enclose.scan

  ; The first non-delimiter is a null.
  inc bc
  push bc ; offset to byte following null
  dec bc ; offset to null
  jp enclose.end

enclose.scan:
  ld a,e ; delimiter
  inc hl ; address of next char
  inc bc ; offset to next char
  cp (hl) ; delimiter?
  jp z,enclose.ending_delimiter
  ld a,(hl)
  and a ; null?
  jp nz,enclose.scan

  ; Final null found.
  push bc ; offset to null
  jp enclose.end

enclose.ending_delimiter:
  ; Final delimiter found.
  push bc ; offset to byte following text
  inc bc ; offset to 2 bytes after end of word

enclose.end:
  push bc
  exx ; restore the Forth IP
  _jp_next


; ----------------------------------------------
  _code_header paren_parse_,'(PARSE)'

if 1 ; XXX NEW

; doc{
;
; (parse)  ( c ca -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop de ; address
  pop hl ; delimiter
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
paren_parse.scan:
  ld a,(de)
  or a ; unconditional null delimiter?
  jr z,paren_parse.end
  cp c ; delimiter?
  jr z,paren_parse.end
  inc de
  inc hl
  jp paren_parse.scan
paren_parse.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

if 0 ; XXX NEW

; doc{
;
; (parse)  ( ca c -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop hl
  pop de
  push de
  ld d,l ; delimiter
  ld hl,0 ; length
paren_parse.scan:
  ld a,(de)
  and a ; unconditional null delimiter?
  jp z,push_hl
  cp d ; delimiter?
  jp z,push_hl
  inc hl
  jp paren_parse.scan

endif

; ----------------------------------------------
  _code_header chan_,'CHAN'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
; [Code from Spectrum Forth-83.]

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _colon_header emit_,'EMIT'

  dw paren_emit_
  dw one_,out_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header paren_emit_,'(EMIT)'

; doc{
;
; (emit)  ( b -- )
;
; Send the character b to the current channel.
;
; }doc

; [Code from Spectrum Forth-83's `TOCH`.]

  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
  _jp_next

; ----------------------------------------------
  _colon_header printer_,'PRINTER'

  dw c_lit_
  db 3
  dw chan_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header display_,'DISPLAY'

  dw two_
  dw chan_
  dw semicolon_s_

; ----------------------------------------------
  _code_header key_,'KEY'

  ; XXX TODO simplify, no Spectrum modes

  push bc
  ld a,0x02
  call rom_chan_open

  ; flash on
  ld a,flash_char
  rst 0x10
  ld a,0x01
  rst 0x10

key.new_key:
  xor a
  ld (sys_last_k),a
  ; Print cursor:
key.cursor_char: equ $+1
  ld a,'L'
  rst 0x10
  ld a,backspace_char
  rst 0x10
key.wait_for_key:
  ld a,(sys_last_k)
  and a
  jr z,key.wait_for_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,key.graphic_mode
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a

key.not_graphic_mode_cursor:
  ; a = 0 (lowercase mode)
  ;     8 (uppercase mode)
  ld hl,key.cursor_char
  bit 3,a ; cursor 'L'?
  jr nz,key.cursor_c
  ld (hl),'L'
  jr key.new_key
key.cursor_c:
  ld (hl),'C'
  jr key.new_key

key.graphic_mode:
  cp graphics_char ; change graphics mode?
  jr nz,key.translate
  ; graphics
  ld a,0x02
  ld hl,sys_mode
  xor (hl)
  ld (hl),a
  and a ; now in graphics mode?
  jr nz,key.graphic_mode_cursor
  ; not in graphics mode
  ld a,(sys_flags2)
  jr key.not_graphic_mode_cursor

key.graphic_mode_cursor:
  ld a,'G'
  ld (key.cursor_char),a
  jr key.new_key

  ; Translate some chars
  ; XXX TODO use a configurable list of chars pairs

key.translate:
key.left_bracket:
  cp 0xC6
  jr nz,key.right_bracket
  ld a,'['
key.right_bracket:
  cp 0xC5
  jr nz,key.tilde
  ld a,']'
key.tilde:
  cp 0xE2
  jr nz,key.vertical_bar
  ld a,'~'
key.vertical_bar:
  cp 0xC3
  jr nz,key.backslash
  ld a,'|'
key.backslash:
  cp 0xCD
  jr nz,key.left_curly_bracket
  ld a,'\'
key.left_curly_bracket:
  cp 0xCC
  jr nz,key.right_curly_bracket
  ld a,'{'
key.right_curly_bracket:
  cp 0xCB
  jr nz,key.limit
  ld a,'}'

key.limit:
  cp 0xA5 ; greater than 0xA4 (the last UDG)?
  jr nc,key.new_key
  ld l,a
  ld h,0x00

  ; flash off
  ld a,flash_char
  rst 0x10
  ld a,0x00
  rst 0x10

  ; delete the cursor
  ld a,space_char
  rst 0x10
  ld a,backspace_char
  rst 0x10

  pop bc
  jp push_hl

  ; XXX TODO
  ; Table structure:
  ;   dw chained table (or zero)
  ;   db from1,to1
  ;   db ...
  ;   db from-n,to-n
  ;   db 0 ; end of data, continue at the chained table

key_translation_table:
  dw 0 ; no chained table
  db 0xC6,'['
  db 0xC5,']'
  db 0xE2,'~'
  db 0xC3,'|'
  db 0xCD,'\'
  db 0xCC,'{'
  db 0xCB,'}'
  db 0 ; end of data

; ----------------------------------------------
  _code_header question_terminal_,'?TERMINAL'

  call rom_break_key
  jp nc,true_pfa
  ld a,(sys_last_k)
  cp edit_char
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _colon_header cr_,'CR'

  dw c_lit_
  db carriage_return_char
  dw emit_
  dw out_,off_
  dw semicolon_s_

; ----------------------------------------------
  _code_header cmove_up_,'CMOVE>'

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header cmove_,'CMOVE'

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'MOVE'

; doc{
;
; move  ( a1 a2 len -- )
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header smove_,'SMOVE'

; doc{
;
; smove  ( a1 len a2 -- )
;
; }doc

  exx
  pop de
  pop bc
  jp move.do

; ----------------------------------------------
  _code_header u_star_,'U*'

  pop de
  pop hl
  push bc
  ld b,h
  ld a,l
  call sub_606dh
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_606dh
  pop de
  ld c,d
  add hl,bc
  adc a,0x00
  ld d,l
  ld l,h
  ld h,a
  pop bc
  push de
  jp push_hl
sub_606dh:
  ld hl,0x0000
  ld c,0x08
l6072h:
  add hl,hl
  rla
  jr nc,l6079h
  add hl,de
  adc a,0x00
l6079h:
  dec c
  jr nz,l6072h
  ret

; ----------------------------------------------
  _code_header u_slash_mod_,'U/MOD'

  ld hl,0x0004
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l60a0h
  ld hl,0xFFFF
  ld de,0xFFFF
  jr l60c0h
l60a0h:
  ld a,0x10
l60a2h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l60aah
  inc de
  and a
l60aah:
  ex de,hl
  rra
  push af
  jr nc,l60b4h
  and l
  sbc hl,bc
  jr l60bbh
l60b4h:
  and a
  sbc hl,bc
  jr nc,l60bbh
  add hl,bc
  dec de
l60bbh:
  inc de
  pop af
  dec a
  jr nz,l60a2h
l60c0h:
  pop bc
  push hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header and_,'AND'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header or_,'OR'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header xor_,'XOR'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

if 1 ; names_in_memory_bank?

; ----------------------------------------------
  _constant_header np_,'NP'

  dw names_pointer

; ----------------------------------------------
  _constant_header np0_,'NP0'

  ; XXX TODO

  dw names_bank_address

; ----------------------------------------------
  _code_header np_fetch_,'NP@'

  ld hl,(names_pointer)
  jp push_hl

; ----------------------------------------------
  ; _code_header np_store_,'NP!'

  ; XXX TODO

  ; ld hl,(names_pointer)
  ; jp push_hl
  ; _jp_next

; ----------------------------------------------

  _colon_header comma_np_,',NP'

; doc{
;
; ,np  ( x -- )
;
; Store _x_ into the next available names memory cell, advancing
; the names pointer.
;
; Note: The names memory is supposed to be paged in.
;
; }doc

  dw np_fetch_,store_,two_,np_,plus_store_
  dw semicolon_s_

endif

; ----------------------------------------------
  _code_header sp_fetch_,'SP@'

  ld hl,0x0000
  add hl,sp
  jp push_hl

; ----------------------------------------------
  _code_header sp_store_,'SP!'

  ld hl,(user_variables_pointer)
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'RP'

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP@'

  ld hl,(return_stack_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header rp_store_,'RP!'

  ld hl,(user_variables_pointer)
  inc hl
  inc hl ; hl=address of r0
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header semicolon_s_,';S'

; doc{
; 
; ;s  ( -- )  \ fig-Forth
;
; Return execution to the calling definition.  Unnest one level.
;
; It is used to stop interpretation of a screen. It is also the
; run-time word compiled at the end of a colon-definition which
; returns execution to the calling procedure.
;
; }doc

; XXX TODO combine with `exit`?

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header pick_,'PICK'

  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

; ----------------------------------------------
  _code_alias_header unloop_,'UNLOOP',,two_r_drop_

; doc{
;
; unloop  ( -- ) ( R: x1 x2 -- )  \ ANS Forth, C
; 
; x1 = loop index
; x2 = loop limit
;
; Discard the loop-control parameters for the current nesting
; level. An `unloop` is required for each nesting level before
; the definition may be exited with `exit`. An ambiguous
; condition exists if the loop-control parameters are
; unavailable.
;
; }doc

; ----------------------------------------------
  _code_header leave_,'LEAVE'

; doc{
;
; leave  ( -- ) ( R: x1 x2 -- x1 x1 ) \ fig-Forth, C
;
; x1 = loop index
; x2 = loop limit
;
; Force termination of a do-loop at the next opportunity by
; setting the loop limit equal to the current value of the
; index. The index itself remains unchanged, and execution
; proceeds normally until `loop` or `+loop` is encountered.
;
; Note: This is the fig-Forth version of `leave`, not the ANS
; Forth version.
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header to_r_,'>R'

; doc{
;
; >r  ( x -- ) ( R: -- x )
;
; }doc

  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R>'

; doc{
;
; r>  ( -- x ) ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header two_r_drop_,'2RDROP'

; doc{
;
; 2rdrop  ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDROP'

; doc{
;
; rdrop  ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>R'

; doc{
;
; 2>r  ( -- x1 x2 ) ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2R>'

; 2r>  ( -- x1 x2 ) ( R: x1 x2 -- )

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_pfa

; ----------------------------------------------
  _code_header two_r_fetch_,'2R@'

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R@'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header zero_equals_,'0='

  pop hl
  ld a,l
  or h
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

  pop hl
  ld a,l
  or h
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization?
    add hl,hl ; 11t, 1 byte
  else
    ; [Idea from Ace Forth.]
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

  ; [Taken from DZX-Forth.]

  pop de
  ld hl,0
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header plus_,'+'

  pop de
  pop hl
  add hl,de
  jp push_hl

; ----------------------------------------------
  _code_header d_plus_,'D+'

  ; XXX TODO move to the disk

  ld hl,0x0006
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  adc hl,bc
  pop bc
  jp push_de_hl

if 0 ; XXX TODO study this alternative from fig-Forth 1.1g
  EXX     ;/ SAVE IP
  POP BC    ;  (BC)<--d2H
  POP HL    ;  (HL)<--d2L
  POP AF    ;d (AF)<--d1H
  POP DE    ;  (DE)<--d1L
  PUSH  AF    ;/ (S1)<--d1H
  ADD HL,DE   ;  (HL)<--d2L+d1L=d3L
  EX  DE,HL   ;  (DE)<--d3L
  POP HL    ;  (HL)<--d1H
  ADC HL,BC   ;/ (HL)<--d1H+d2H+CARRY=d3H
  PUSH  DE    ;  (S2)<--d3L
  PUSH  HL    ;/ (S1)<--d3H
  EXX     ;/ RESTORE IP
  JNEXT
endif

; ----------------------------------------------
  _code_header negate_,'NEGATE'

  pop de
  ld hl,0x0000
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header dnegate_,'DNEGATE'

  ; XXX TODO move to the disk

  pop hl
  pop de
  sub a
  sub e
  ld e,a
  ld a,0x00
  sbc a,d
  ld d,a
  ld a,0x00
  sbc a,l
  ld l,a
  ld a,0x00
  sbc a,h
  ld h,a
  push de
  jp push_hl

; ----------------------------------------------
  _code_header nip_,'NIP'

  pop hl
  pop de
  jp push_hl

; ----------------------------------------------
  _code_header tuck_,'TUCK'

  pop hl
  pop de
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header over_,'OVER'

  pop de
  pop hl
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header drop_,'DROP'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWAP'

  pop hl
  ex (sp),hl
  jp push_hl

; ----------------------------------------------
  _code_header dup_,'DUP'

  pop hl
  push hl
  jp push_hl

; ----------------------------------------------
  _code_header two_dup_,'2DUP'

  pop hl
  pop de
  push de
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header plus_store_,'+!'

  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OFF'

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'ON'

  ; XXX TODO -- update when true=-1
  pop hl
  ld (hl),1
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header toggle_,'TOGGLE'

  pop de ; e = bit pattern
  pop hl ; address
  ld a,(hl)
  xor e
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header fetch_,'@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_,'C@'

  pop hl
  ld l,(hl)
  ld h,0x00
  jp push_hl

; ----------------------------------------------
  _code_header two_fetch_,'2@'

  pop hl ; address
two_fetch.hl:
  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1 ; de = low part
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1 ; hl = high part
  ex de,hl      ; 04t  1
  jp push_de_hl ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL

; ----------------------------------------------
  _code_header two_store_,'2!'

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization?
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _colon_header colon_,':',immediate

  dw question_exec_
  dw store_csp_
  dw current_,fetch_,context_,store_ ; XXX OLD -- why fig-Forth does this?
  dw header_,right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
  _jp_next

; ----------------------------------------------
  _colon_header noname_,':NONAME',immediate

  ; [Code from the Afera library.]

  ; XXX TODO move to the disk? problem: do_colon

  dw question_exec_
  dw current_,fetch_,context_,store_ ; XXX TODO why fig-Forth does this in `:`?
  dw smudge_  ; deactivate the effect of the next `smudge` in `;`
  dw here_ ; cfa
  dw store_csp_
  dw lit_,do_colon,comma_ ; create the code field
  dw right_bracket_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate

  dw question_csp_
  dw compile_,semicolon_s_
  dw smudge_
  dw left_bracket_
  dw semicolon_s_

; ----------------------------------------------

if 0 ; XXX OLD
  _colon_header noop_,'NOOP'
  dw semicolon_s_
else ; XXX NEW -- save 2 bytes
  ; XXX TODO test it
  _header noop_,'NOOP'
  dw next ; code field
endif

; ----------------------------------------------
  _colon_header constant_,'CONSTANT'

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp fetch.hl

; ----------------------------------------------
  _colon_header label_,'LABEL'

  dw create_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header variable_,'VARIABLE'

; doc{
;
; variable ( "name" -- )  \ ANS Forth
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve one cell of data
; space.
;
;    _name_ is referred to as a variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the reserved cell. A program is
;    responsible for initializing the contents of the reserved
;    cell.
;
; }doc

  dw create_,cell_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header user_,'USER'

  ; XXX TODO -- Use only one byte for storage,
  ; but defining `cconstant` only for this does not seem a good idea.
  dw constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00
  ld hl,(user_variables_pointer)   ; 20t
  ; XXX This is faster, but makes the access to the pointer non-standard:
;user_variables_pointer: equ $+1
; ld hl,user_variables   ; 10t
  add hl,de   ; hl= address of the user variable
  jp push_hl

; ----------------------------------------------
  _constant_header msg_scr_,'MSG-SCR'

; doc{
;
; msg-scr  ( -- n )
;
; Constant: Screen where the error messages start.
;
; }doc

; Idea taken from lina ciforth.

  dw 0x0004

; ----------------------------------------------
  _constant_header zero_,'0'

  dw 0x0000

; ----------------------------------------------
  _constant_header one_,'1'

  dw 0x0001

; ----------------------------------------------
  _constant_header two_,'2'

  dw 0x0002

; ----------------------------------------------
  _code_header false_,'FALSE'

  ld hl,false
  jp push_hl

; ----------------------------------------------
  _code_header true_,'TRUE'

  ld hl,true
  jp push_hl

; ----------------------------------------------
  _constant_header b_l_,'BL'

  dw space_char

; ----------------------------------------------
  _constant_header c_slash_l_,'C/L'

  dw characters_per_line

; ----------------------------------------------
  _constant_header first_,'FIRST'

  dw first_buffer

; ----------------------------------------------
  _constant_header limit_,'LIMIT'

  dw limit

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BUF'

  dw data_bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_scr_,'B/SCR'

  dw blocks_per_screen

; ----------------------------------------------
  _constant_header scr_slash_disk_,'SCR/DISK'

  dw screens_per_disk

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGIN'

  dw lit_,origin,plus_
  dw semicolon_s_

; ----------------------------------------------
  _user_variable_header sp0_,'SP0'

  db 0x00

; ----------------------------------------------
  _user_variable_header rp0_,'RP0'

  db 0x02

; ----------------------------------------------
  _user_variable_header tib_,'TIB'

  db 0x04

; ----------------------------------------------
  _user_variable_header width_,'WIDTH'

  db 0x06

; ----------------------------------------------
  _user_variable_header warning_,'WARNING'

  db 0x08

; ----------------------------------------------
  _user_variable_header fence_,'FENCE'

  ; XXX TODO why this is a user variable?
  ; XXX OLD -- obsolescent word
  db 0x0A

; ----------------------------------------------
  _user_variable_header dp_,'DP'

  ; XXX TODO why this is a user variable?
  db 0x0C

; ----------------------------------------------
  _user_variable_header voc_link_,'VOC-LINK'

  ; XXX TODO why this is a user variable?
  db 0x0E

; ----------------------------------------------
  _user_variable_header blk_,'BLK'

  db 0x10

; ----------------------------------------------
  _user_variable_header to_in_,'>IN'

  db 0x12

; ----------------------------------------------
  _user_variable_header out_,'OUT'

  db 0x14

; ----------------------------------------------
  _user_variable_header scr_,'SCR' ; XXX OLD ? used by `list`

  db 0x16

; ----------------------------------------------
  _user_variable_header context_,'CONTEXT'

  db 0x1A

; ----------------------------------------------
  _user_variable_header current_,'CURRENT'

  db 0x1C

; ----------------------------------------------
  _user_variable_header state_,'STATE'

  db 0x1E

; ----------------------------------------------
  _user_variable_header base_,'BASE'

  db 0x20

; ----------------------------------------------
  _user_variable_header dpl_,'DPL'

  db 0x22

; ----------------------------------------------
  _user_variable_header fld_,'FLD'

  db 0x24

; ----------------------------------------------
  _user_variable_header csp_,'CSP'

  db 0x26

; ----------------------------------------------
  _user_variable_header r_hash_,'R#'

  db 0x28

; ----------------------------------------------
  _user_variable_header hld_,'HLD'

  db 0x2A

; ----------------------------------------------
  _colon_header recurse_,'RECURSE',immediate

; doc{
;
; recurse  ( -- )  \ ANS Forth
;
; }doc

  dw latest_,nfa_to_cfa_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header one_plus_,'1+'

  pop hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_header two_plus_,'2+'

  pop hl
  inc hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cell_plus_,'CELL+',,two_plus_

; ----------------------------------------------
  _code_header one_minus_,'1-'

  pop hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_minus_,'2-'

  pop hl
  dec hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2*  ( x1 -- x2 )  \ ANS Forth
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; }doc

  ; XXX TODO -- Copy comments against this word from lina ciforth documentation.

  pop hl
  add hl,hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cells_,'CELLS',,two_star_

; ----------------------------------------------
  _constant_header cell_,'CELL'

  dw 0x0002

; ----------------------------------------------
  _code_header two_slash_,'2/'

; doc{
;
; 2/  ( x1 -- x2 )  \ ANS Forth
;
; _x2_ is the result of shifting _x1_ one bit toward the
; least-significant bit, leaving the most-significant bit
; unchanged.
;
; }doc

  ; XXX TODO -- Copy comments against this word from lina ciforth documentation.

  ; [Code from DZX-Forth.]

  pop hl
  call sra_hl
  jp push_hl

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl.1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

; ----------------------------------------------
  _colon_header here_,'HERE'

  dw dp_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header allot_,'ALLOT'

  dw dp_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_comma_,'s,'

; doc{
; s,  ( ca len -- )
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,cmove_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comma_,','

  dw here_,store_,two_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_comma_,'C,'

  dw here_,c_store_,one_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _code_header minus_,'-'

  pop de
  pop hl
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header not_equals_,'<>'

  pop de
  pop hl
  call compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header equals_,'='

  pop de
  pop hl
  call compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header less_than_,'<'

  pop de
  pop hl
is_de_less_than_hl:
  call compare_de_hl_signed
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

; ----------------------------------------------
  _code_header u_greater_than_,'U>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U<'

  pop de
  pop hl
u_less_than.de_hl:
  call compare_de_hl_unsigned
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

; ----------------------------------------------
  _code_header greater_than_,'>'

  pop hl
  pop de
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header rot_,'ROT'

  pop de
  pop hl
  ex (sp),hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header space_,'SPACE'

  dw b_l_
  dw emit_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_dup_,'?DUP'

  dw dup_
  dw zero_branch_,question_dup.end
  dw dup_
question_dup.end:
  dw semicolon_s_

; ----------------------------------------------

if 1 ; names_in_memory_bank?

  _code_alias_header lfa_to_nfa_,'LFA>NFA',,two_minus_

else

  _code_header lfa_to_nfa_,'LFA>NFA'
  pop hl
lfa_to_nfa.do:
  dec hl
  bit name_bound_bit,(hl)
  jp z,lfa_to_nfa.do
  jp push_hl

endif


; ----------------------------------------------
  _colon_header trail_,'TRAIL'

; doc{
;
; trail ( -- nfa )
;
; Leave the name field address of the topmost word in the
; `context` vocabulary.
;
; }doc

  dw context_,fetch_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header latest_,'LATEST'

; doc{
;
; latest ( -- nfa )  \ ANS Forth
;
; Leave the name field address of the topmost word in the
; `current` vocabulary.
;
; }doc

  dw current_,fetch_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pfa_to_lfa_,'PFA>LFA'

if 1 ; names_in_memory_bank?

  dw pfa_to_cfa_,cfa_to_nfa_

else

  dw c_lit_
  db 0x04
  dw minus_
  dw semicolon_s_

endif

; ----------------------------------------------
  _code_alias_header pfa_to_cfa_,'PFA>CFA',,two_minus_

; ----------------------------------------------
  _code_alias_header cfa_to_pfa_,'CFA>PFA',,two_plus_

; ----------------------------------------------

  ; XXX TODO remove, not needed

if 1 ; names_in_memory_bank?

  _colon_header cfa_to_lfa_,'CFA>LFA'
  dw cfa_to_nfa_,nfa_to_lfa_

else

  _code_alias_header cfa_to_lfa_,'CFA>LFA',,two_minus_

endif

; ----------------------------------------------

  _colon_header pfa_to_nfa_,'PFA>NFA'

if 1 ; names_in_memory_bank?

  dw pfa_to_cfa_,cfa_to_nfa_
  dw semicolon_s_

else

  dw pfa_to_lfa_,lfa_to_nfa_
  dw semicolon_s_

endif

; ----------------------------------------------

; doc{
;
; cfa>nfa  ( cfa -- nfa )
; 
; Warning: No check is done where cfa belongs to a definition
; created with `:noname`.
;
; }doc

; XXX FIXME -- make it return 0 if cfa has no name associated

if 1 ; names_in_memory_bank?

  _code_header cfa_to_nfa_,'CFA>NFA'

  ld e,names_bank
  call bank.e ; page the memory bank
  pop de ; cfa
  push bc ; save Forth IP
  ld b,0
  ld hl, names_bank_address-4

cfa_to_nfa.begin_0:
  ; hl = address of the cfa pointer
  inc hl
cfa_to_nfa.begin_1:
  inc hl
  inc hl
  inc hl
  ld a,(hl) ; name field byte length
  and max_word_length_bit_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  add hl,bc ; point to the cfa pointer

  ld a,(hl) ; low byte of cfa
  cp e ; equal?
  jr nz,cfa_to_nfa.begin_0 ; not equal
  inc hl
  ld a,(hl) ; high byte of cfa
  cp d ; equal?
  jr nz,cfa_to_nfa.begin_1 ; not equal
  ; cfa found
  ld c,3
  add hl,bc ; nfa

  ld e,default_bank
  call bank.e ; page the default memory bank

  pop bc ; restore Forth IP
  jp push_hl

else

  _colon_header cfa_to_nfa_,'CFA>NFA'

  dw cfa_to_lfa_,lfa_to_nfa_
  dw semicolon_s_

endif

; ----------------------------------------------

if 1 ; names_in_memory_bank?

  _code_alias_header nfa_to_lfa_,'NFA>LFA',,two_minus_

else

  _colon_header nfa_to_lfa_,'NFA>LFA'

  dw dup_,c_fetch_
  dw c_lit_
  db max_word_length_bit_mask
  dw and_,plus_,one_plus_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header c_fetch_n_,'C@N'

; doc{
;
; c@n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 14 bytes:
  _names_bank
  dw c_fetch_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header fetch_n_,'@N'

; doc{
;
; @n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 14 bytes:
  _names_bank
  dw fetch_
  _default_bank
  dw semicolon_s_

  ; XXX TODO in Z80 if smaller:
  ; ld e,names_bank
  ; call bank.e
  ; pop hl
  ; ld e,default_bank
  ; call bank.e
  ; _jp_next

; ----------------------------------------------
  _colon_header nfa_to_cfa_,'NFA>CFA'

if 1 ; names_in_memory_bank?

  dw c_lit_
  db 4
  dw minus_,fetch_n_
  dw semicolon_s_

else

  dw nfa_to_lfa_,two_plus_
  dw semicolon_s_

endif


; ----------------------------------------------

if 1 ; fig_does? ; XXX OLD -- original fig-Forth version, paired with `<builds`.

  _colon_header nfa_to_pfa_,'NFA>PFA'

  ; XXX TODO remove, not needed

  dw nfa_to_cfa_,cfa_to_pfa_
  dw semicolon_s_

endif

; ----------------------------------------------
; doc{
;
; nfa>string  ( nfa -- ca len )
;
; }doc

if 1 ; names_in_memory_bank?

  _colon_header nfa_to_string_,'NFA>STRING'

  _names_bank
  dw count_
  dw c_lit_
  db max_word_length_bit_mask
  dw and_
  dw save_string_
  _default_bank
  dw semicolon_s_

else

  _code_header nfa_to_string_,'NFA>STRING'

  ; [From DZX-Forth.]

  pop de
  ld a,(de)
  inc  de
  and max_word_length_bit_mask
  ld h,0
  ld l,a
  jp push_de_hl

endif

; ----------------------------------------------
  _colon_header store_csp_,'!CSP'

  dw sp_fetch_,csp_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_error_,'?ERROR'

  dw swap_
  dw zero_branch_,question_error.no_error
  dw error_
  dw semicolon_s_

question_error.no_error:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comp_question_,'COMP?'

  dw state_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_comp_,'?COMP'

  dw comp_question_,zero_equals_
  _question_error compilation_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exec_,'?EXEC'

  dw comp_question_
  _question_error execution_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_pairs_,'?PAIRS'

  dw not_equals_
  _question_error conditionals_not_paired_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_csp_,'?CSP'

  dw sp_fetch_,csp_,fetch_,not_equals_
  _question_error definition_not_finished_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADING'

  dw blk_,fetch_,zero_equals_
  _question_error loading_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header compile_,'COMPILE'

  dw question_comp_
  dw from_r_,dup_,two_plus_,to_r_,fetch_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header postpone_,'POSTPONE',immediate

; doc{
;
; postpone ( "name" -- )  \ ANS Forth, C I
;
; Skip leading space delimiters. Parse name delimited by a
; space. Find name. Append the compilation semantics of _name_ to
; the current definition.
;
; }doc

  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  dw dup_,question_defined_ ; error if not found
  dw zero_less_than_ ; non-immediate word?
  dw zero_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw comma_ ; compile the cfa
  dw semicolon_s_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

  dw state_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header right_bracket_,']'

  dw state_,on_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header smudge_,'SMUDGE'

  dw latest_
  dw c_lit_
  db smudge_bit_mask
  ; XXX TODO factor `toggle-names'?
  _names_bank
  dw toggle_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hex_,'HEX'

  dw c_lit_
  db 0x10
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header decimal_,'DECIMAL'

  dw c_lit_
  db 0x0A
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE)'

  dw from_r_,latest_,nfa_to_cfa_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_code_,';CODE',immediate

  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw left_bracket_,smudge_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header builds_,'<BUILDS'

  ; XXX OLD
  ; XXX TODO remove this, and check `does>`
  ; XXX TODO adapt `vocabulary`
  dw zero_,constant_
  dw semicolon_s_

; ----------------------------------------------
if 1 ; fig_does? ; XXX OLD -- original fig-Forth version, paired with `<builds`.

  _colon_header does_,'DOES>'

  dw from_r_ ; address of the first word after `does>` (the run-time routine)
  dw latest_,nfa_to_pfa_ ; pfa of the definition under construction
  dw store_ ; store the address of the run-time routine as the first parameter
  dw paren_semicolon_code_
do_does:
  ; Push the address of the next instruction on the return stack:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; XXX TODO understand
  ; Put the address of the run-time routine in IP:
  inc de      ; de=pfa
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ; W was incremented in the last instruction, pointing to the
  ; parameter field; push it on the stack:
  jp push_hl

else  ; XXX NEW -- Forth-83 version, paired with `create`

  ; XXX TODO

  _colon_header does_,'DOES>',immediate

  dw compile_,paren_semicolon_code_
  call do_colon
  _jp_next 

endif

; ----------------------------------------------
  _code_header count_,'COUNT'

  ; Code from DZX-Forth.

  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUNDS'

  dw over_,plus_,swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header type_,'TYPE'

  ; XXX TODO Rewrite in Z80, after the ROM routine.

  dw question_dup_
  dw zero_branch_,type.empty_string

  dw bounds_
  dw paren_do_
type.do:
  dw i_,c_fetch_,emit_
  dw paren_loop_,type.do ; loop
  dw semicolon_s_

type.empty_string:
  dw drop_
type.end:
  dw semicolon_s_

; ----------------------------------------------

  _code_header minus_trailing_,'-TRAILING'

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
  ; de = address after the string
  ; hl = length of the string
minus_trailing.begin:
  ld a,l
  or h ; exhausted?
  jp z,push_hl
  dec de ; next char
  ld a,(de)
  cp ' ' ; space?
  jp nz,push_hl
  dec hl ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(.")'

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,one_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate

if 0 ; XXX OLD

  dw c_lit_
  db '"'
  dw comp_question_ ; compiling?
  dw zero_branch_,dot_quote.interpreting
  ; Compiling.
  dw compile_,paren_dot_quote_
  dw word_
  dw here_,c_fetch_,one_plus_,allot_
  dw semicolon_s_
dot_quote.interpreting:
  dw word_,here_,count_,type_
  dw semicolon_s_

else

  dw c_lit_
  db '"'
  dw parse_ ; ( ca len )
  dw comp_question_
  dw zero_branch_,dot_quote.interpreting
  ; Compiling.
  dw compile_,paren_dot_quote_,s_comma_
  dw semicolon_s_
dot_quote.interpreting:
  dw type_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header expect_,'EXPECT'

; doc{
;
; expect  ( ca len -- )
;
; Transfer characters from the terminal to address _ca_, until a
; "return" or the count of characters have been received.
; 
; XXX TODO
; fig-Forth: One or more nulls are added at the end of the text.
; Solo Forth: a null word is added at the end of the text.
;
; }doc

  dw bounds_ ; ( a+len a )
  dw dup_,zero_,swap_,two_swap_ ; ( 0 a a+len a )
  dw paren_do_
expect.do: ; ( i a )
  dw key_,dup_ ; ( i a c c )
  dw c_lit_
  db delete_char
  dw equals_ ; delete key?
  dw zero_branch_,expect.not_the_delete_key

  ; XXX FIXME This word has a bug in Abersoft Forth.  Sometimes, after using
  ; the delete key, the typed word is not recognized.  Maybe the `noop` the
  ; author used to patch the original bell?
  ;
  ; XXX TODO The `noop` and related `branch` were removed. Waiting for the code
  ; to fail...

  ; Delete key ( i a c )
  dw drop_
  dw dup_,i_,equals_ ; cursor at the start position?
  dw dup_ ; ( i a f f )
  ; XXX TODO adapt this when true=-1
  dw from_r_,two_minus_,plus_,to_r_ ; update the index
  dw question_branch_,expect.loop ; nothing to delete
if ! fig_null_word?
  dw b_l_,i_,c_store_ ; update the buffer
endif
  dw c_lit_
  db backspace_char
  dw branch_,expect.emit

expect.not_the_delete_key: ; ( i a c )
  dw dup_
  dw c_lit_
  db carriage_return_char
  dw equals_ ; carriage return?
  dw zero_branch_,expect.ordinary_key

if fig_null_word?

  ; Carriage return ( i a c )
  dw leave_
  dw drop_,b_l_,zero_
  dw branch_,expect.store

else

  ; XXX TODO
  ; Carriage return ( i a c )
  dw leave_
  dw drop_
  dw branch_,expect.loop

endif

expect.ordinary_key: ; ( i a c )
  dw dup_

expect.store: ; ( i a c c | a c 0 )
  dw i_,c_store_
  dw i_,one_plus_,off_

expect.emit: ; ( i a c )
  dw emit_

expect.loop: ; ( i a )
  dw nip_,i_,swap_ ; update the copy of `i` on the stack
  dw paren_loop_,expect.do

  dw drop_
if ! fig_null_word?
  ; Add a null word after the text:
  dw b_l_,over_,c_store_
  dw zero_,over_,one_plus_,c_store_
  dw b_l_,swap_,two_plus_,c_store_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header query_,'QUERY'

  dw tib_,fetch_
  dw c_lit_
  db bytes_per_terminal_input_buffer
  if ! fig_null_word?
    dw two_dup_,blank_ ; clean the input buffer
  endif
  dw expect_
  dw to_in_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header x_,0,immediate

; doc{

; x  ( -- )

; This is pseudonym for the "null" or dictionary entry for a
; name of one character of ascii null. It is the execution
; procedure to terminate interpretation of a line of text from
; the terminal or within a disk buffer, as both buffers always
; have a null at the end.

; }doc

  dw blk_,fetch_ ; input stream from disk?
  dw zero_branch_,x.exit ; if not, branch
  ; From disk.
  dw one_,blk_,plus_store_ ; next disk buffer
  dw to_in_,off_ ; clear `in`, preparing parsing of input text
  ; Note: The following check of the last block is specific for 2
  ; blocks per screen; the generic slower check would be `blk @
  ; b/scr 1- and`.
  dw blk_,fetch_,one_,and_ ; was it the last block of the screen?
  dw question_branch_,x.end ; if not, branch
  ; Last block of the screen.
  dw question_exec_ ; error if not executing
x.exit:

  ; The top item on the return stack is thrown away.  The interpreter
  ; will not continue to execute the `?stack` instruction that follows
  ; `execute` in `interpret`, but will return to the next higher level
  ; of nesting and execute the next word after `interpret` in the Forth
  ; loop.  This is when the familiar "ok" message is displayed on the
  ; terminal, prompting the operator for the next line of commands.

  dw r_drop_
;  dw lit_,7,border_ ; XXX INFORMER

x.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header fill_,'FILL'

  pop de ; e = char
fill.e:
  ld l,c
  ld h,b ; the Forth IP
  pop bc ; count
  ex (sp),hl ; save the Forth IP
fill.do:
  ld a,b
  or c
  _jump_z fill.end
  ld (hl),e
  inc hl
  dec bc
  jp fill.do
fill.end:
  pop bc ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header erase_,'ERASE'

  ld e,0
  jp fill.e

; ----------------------------------------------
  _code_header blank_,'BLANK'

  ld e,space_char
  jp fill.e

; ----------------------------------------------
  _colon_header hold_,'HOLD'

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pad_,'PAD'

  dw here_
  dw c_lit_
  db 0x44
  dw plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header stream_,'STREAM'

; doc{
;
; stream  ( -- ca )
;
; ca = current parsing position in the stream source
;
; }doc

  dw blk_,fetch_,question_dup_ ; from disk?
  dw zero_branch_,stream.terminal
  dw block_ ; from disk
  dw branch_,stream.end
stream.terminal:
  dw tib_,fetch_ ; from terminal
stream.end:
  dw to_in_,fetch_,plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parse_,'PARSE'

; doc{
;
; parse  ( c "text<c>" -- ca len )  \ ANS Forth
;
; Parse _text_ delimited by the delimiter char _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
;
; If the parse area was empty, the resulting string has a zero length.
;
; }doc

  dw stream_,swap_,scan_
  dw dup_,one_plus_,to_in_,plus_store_ ; XXX TODO factor this? possible name: `parsed`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parse_word_,'PARSE-WORD'

; doc{
;
; parse-word  ( "name"  -- ca len )
;
; }word

  ; XXX TODO case insensitive!

  dw stream_,dup_,to_r_ ; ( c c ca1 )
  dw b_l_,skip_ ; ( ca2 )
  dw dup_,from_r_,minus_,to_in_,plus_store_
  ; XXX TODO factor of `parse`?:
  dw b_l_,scan_ ; ( ca len )
  ; XXX TODO factor of `parse`?:
  dw dup_,one_plus_,to_in_,plus_store_ ; XXX TODO `1+` ?
  dw semicolon_s_

; ----------------------------------------------
  _colon_header word_,'WORD'

; doc{
;
; word  ( c "<c...>text<c>" -- )  \ fig-Forth
;
; c = delimiter char
;
; Skip leading _c_ delimiters from the input stream.  Parse the
; next text characters from the input stream, until a delimiter
; _c_ is found, storing the packed character string beginning at
; `here`, as a counted string (the character count in the first
; byte), and with two or more blanks at the end.
;
; }doc

if 0 ; XXX OLD -- original version with `enclose`

  dw stream_  ; ( c ca )
  dw enclose_ ; ( ca n1 n2 n3 )
  ; ca = text address
  ; n1 = byte offset to the first non-delimiter character
  ; n2 = byte offset to the first delimiter after the text
  ; n3 = byte offset to the first character not included
  
  ;dw stream,true_,paren_parse_ ; XXX OLD -- abandoned idea

  ; XXX TODO use a factor of `s,` instead, without `allot`:
  dw here_
  dw c_lit_
  db max_word_length+3
  dw blank_
  dw to_in_,plus_store_
  dw over_,minus_,to_r_ ; length
  dw r_fetch_,here_,c_store_ ; set the length byte
  dw plus_ ; from
  dw here_,one_plus_ ; destination
  dw from_r_ ; count
  dw cmove_ ; move the word
  dw semicolon_s_

else ; XXX NEW -- modern version with `skip parse`

  ; XXX FIXME

  ; the problem seems the null word is not recognized.

  dw stream_ ; ( c a1 )
  dw dup_,to_r_
  dw over_,skip_ ; ( c a2 )
if  0
  dw hex_
  dw cr_,paren_dot_quote_ ; XXX INFORMER
  _string 'In word after skip:' ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
  dw key_,drop_ ; XXX INFORMER
endif
  dw dup_,from_r_,minus_,to_in_,plus_store_
  ; XXX TODO factor of `parse`:
  dw swap_,scan_ ; ( a2 len )
if  0
  dw hex_
  dw cr_,paren_dot_quote_ ; XXX INFORMER
  _string 'In word after scan:' ; XXX INFORMER
  dw cr_,two_dup_,type_ ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
  dw key_,drop_ ; XXX INFORMER
endif
  dw dup_,to_in_,plus_store_

  dw here_
  dw c_lit_
  db max_word_length+3
  dw blank_

  dw dup_,here_,c_store_ ; count byte
  dw here_,one_plus_ ; destination
  dw swap_ ; count
  dw cmove_ ; move the word
  dw semicolon_s_

endif

  if 0
    ;dw space_ ; XXX INFORMER
    ;dw depth_,dot_ ; XXX INFORMER
    ;dw paren_dot_quote_ ; XXX INFORMER
    ;_string 'blk ' ; XXX INFORMER
    ;dw blk_,fetch_,dot_ ; XXX INFORMER
    ;dw paren_dot_quote_ ; XXX INFORMER
    ;_string 'in ' ; XXX INFORMER
    ;dw in_,fetch_,dot_ ; XXX INFORMER
    ;dw here_,count_,one_,ink_,type_,zero_,ink_ ; XXX INFORMER
    ;dw key_,drop_ ; XXX INFORMER
  endif

; ----------------------------------------------
  _colon_header paren_number_,'(NUMBER)'

paren_number.begin: ; begin
  dw one_plus_ ; address of the next digit
  dw dup_,to_r_ ; save the address
  dw c_fetch_ ; get the digit
  dw base_,fetch_,digit_ ; convert the digit
  dw zero_branch_,paren_number.end ; while
  dw swap_ ; get the high order part of d1 to the top.
  dw base_,fetch_,u_star_ ; multiply by base value
  dw drop_ ; drop the high order part of the product
  dw rot_ ; move the low order part of d1 to top of stack
  dw base_,fetch_,u_star_ ; multiply by base value
  dw d_plus_ ; accumulate result into d1
  dw dpl_,fetch_,one_plus_ ; is DPL other than -1?
  dw zero_branch_,paren_number.decimal_point_done
  ; DPL is not -1, a decimal point was encountered
  dw one_,dpl_,plus_store_ ; increment DPL, one more digit to right of decimal point
paren_number.decimal_point_done:
  dw from_r_ ; pop addr1+1 back to convert the next digit
  dw branch_,paren_number.begin ; repeat
paren_number.end:
  dw from_r_ ; address of the first non-convertable digit, a2.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header number_,'NUMBER'

  dw zero_,zero_,rot_ ; two zeros, initial value of the double number
  ;dw dup_,count_,swap_,dot_,dot_ ; XXX INFORMER
  dw dup_,one_plus_,c_fetch_ ; get the first digit
  dw c_lit_
  db '-'
  dw equals_ ; is it a minus sign?
  dw dup_,to_r_ ; save the flag
  ; XXX TODO add `abs` here when `true` is changed to `-1`
  dw plus_
  ; If the first digit is "-", the flag is 1,
  ; and addr+1 points to the second digit.
  ; If the first digit is not "-", the flag is
  ; 0.  addr+0 remains the same, pointing to
  ; the first digit.
  dw lit_,-1 ; initial value of `dpl`
number.begin:
  dw dpl_,store_
  dw paren_number_ ; convert one digit after another until an invalid char occurs
  dw dup_,c_fetch_ ; get the invalid digit
  dw b_l_,not_equals_ ; not a blank?
  dw zero_branch_,number.not_a_blank
  ; The invalid digit is not a blank.
  dw dup_,c_fetch_ ; get the invalid digit again
  dw c_lit_
  db '.'
  dw not_equals_ ; not a decimal point?
  _question_error not_understood_error ; error if not
  ; Decimal point found, set `dpl` to zero next time.
  dw zero_
  dw branch_,number.begin ; repeat
number.not_a_blank:
  dw drop_ ; discard address
  dw from_r_ ; pop the flag of "-" sign back
  dw zero_branch_,number.end
  ; The first digit is a "-" sign.
  dw dnegate_
number.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header upper_,'UPPER'

; doc{
;
; upper  ( c -- c' )
;
; }doc

  pop hl
  ld a,l
  call upper.a
  ld l,a
  jp push_hl

upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20 ; toggle bit 5
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPERS'

; doc{
;
; uppers  ( ca len -- )
;
; }doc

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upper.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

; ----------------------------------------------
  _colon_header defined_question_,'DEFINED?'

; defined?  ( ca len -- wf )

  dw found_,nip_,zero_not_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; doc{
;
; undefined?  ( ca len -- wf )
;
; }doc

  dw defined_question_,zero_equals_
  dw semicolon_s_

; ----------------------------------------------
  _code_header dollar_store_,'$!'

  ; [Code from DZX-Forth's `packed`.]

; doc{
;
; $!  ( ca1 len1 ca2 -- )
;
; Store the string ca1 len1 as a counted string at ca2.  The
; source and destination strings are permitted to overlap.  An
; ambiguous condition exists if len is greater than 255 or the
; buffer at ca2 is less than len1+1 characters.
;
; }doc

  exx
  pop de      ; de=ca2
  pop bc      ; c=len1
  pop hl      ; hl=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; e=len1
  ld (hl),e
  exx
  _jp_next

; ----------------------------------------------
  _colon_header find_,'FIND'

; doc{
;
; find  ( ca --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  dw trail_
  ;dw paren_dot_quote_ ; XXX INFORMER
  ;_string 'In find, nfa is:' ; XXX INFORMER
  ;dw dup_,hex_,u_dot_,decimal_ ; XXX INFORMER ;
    ; Result:
    ;   0x86D3 with default system, why one less than `dot_paren_`? It works, though.
    ;   0xCD87 with bank system, exactly `dot_paren_nfa`, but it
    ;   doesn't work.

  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ; dw cr_,paren_dot_quote_ ; XXX INFORMER
  ; _string 'In find before (find): ' ; XXX INFORMER
  ; dw hex_,dot_s_,decimal_ ; XXX INFORMER
  ; dw key_,drop_ ; XXX INFORMER

  dw paren_find_
  
  ; dw cr_,paren_dot_quote_ ; XXX INFORMER
  ; _string 'In find after (find):: ' ; XXX INFORMER
  ; dw hex_,dot_s_,decimal_ ; XXX INFORMER
  ; dw key_,drop_ ; XXX INFORMER

  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  dw semicolon_s_

; ----------------------------------------------
  _variable_header find_dollar_,'FIND$'

  ; XXX TODO use an unused address above `pad` instead?
  ; XXX TODO rename as `word$`?
  ; XXX TODO use also in `word`?

  ds max_word_length+2

; ----------------------------------------------
  _colon_header found_,'FOUND'

; doc{
;
; found  ( ca len --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX TODO factor

  dw find_dollar_
  dw c_lit_
  db max_word_length+2
  dw erase_ ; make sure there will be a null at the end
  dw find_dollar_,dollar_store_
  dw find_dollar_,count_,uppers_
  dw find_dollar_,find_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT)'

  dw abort_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header error_number_,'ERROR#'

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-POS'

  dw 0,0

; ----------------------------------------------
  _colon_header error_,'ERROR'

  dw dup_,error_number_,store_ ; save the error number
  dw warning_,fetch_,zero_less_than_
  dw question_branch_,paren_abort_pfa

error.message:
  dw here_,count_,type_ ; last parsed word
  dw paren_dot_quote_
  _string '? '
  dw message_
  dw sp_store_
  ; XXX TODO save the output parameters?
  ; (`where` will be in the disk)
  dw blk_,fetch_,question_dup_
  dw zero_branch_,error.end
  dw to_in_,fetch_
  dw swap_
  dw error_pos_,two_store_ ; XXX NEW
error.end:
  dw quit_

; ----------------------------------------------
  _colon_header id_dot_,'ID.'

  dw nfa_to_string_,type_,space_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header header_,'HEADER'

; header  ( "name" -- )

  ; XXX NEW
  ; XXX TMP -- this is a copy of the original `create`.
  ; XXX TODO -- accept an xt as parameter?

  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  dw abs_,star_,question_dup_ ; ( 0 | cfa cfa )
  dw zero_branch_,header.continue
  ; The word is not unique.
  dw cfa_to_nfa_

  dw id_dot_
  _message not_unique_error
header.continue:

if 1 ; names_in_memory_bank?

    ; XXX TODO adapt to `parse-word`; now it works because
    ; `defined` still uses `word`, that leaves the string at
    ; `here`.

  dw here_,count_
  ; XXX TODO error if name is too long (see lina)
  dw width_,fetch_,min_
  dw save_string_,tuck_ ; ( len ca len )
  _names_bank
  dw here_,comma_np_ ; store a pointer to the cfa
  dw latest_,comma_np_ ; link field
  ; Now `np` contains the address of the nfa.
  dw np_fetch_,dollar_store_ ; store the name
  dw np_fetch_,current_,fetch_,store_ ; update contents of `latest` in the current vocabulary
  dw one_plus_,np_,plus_store_ ; update the names pointer with the length+1
  _default_bank
  dw here_,two_plus_,comma_ ; compile the pfa into code field
  dw semicolon_s_

else

  dw here_
  ; XXX TODO error if name is too long (see lina)
  dw dup_,c_fetch_,width_,fetch_,min_,one_plus_,allot_ ; allocate space for name field
  dw dup_
  dw c_lit_
  db name_bound_bit_mask+smudge_bit_mask
  dw toggle_
  dw latest_,comma_ ; compile the nfa of the last word in the link field
  dw current_,fetch_,store_ ; update contents of `latest` in the current vocabulary
  dw here_,two_plus_,comma_ ; compile the pfa into code field.
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header create_,'CREATE'

  dw header_,smudge_
  dw paren_semicolon_code_
do_create:
  inc de  ; de=pfa
  push de
  _jp_next

; ----------------------------------------------

if 1 ; fig_does?

  _does_header assembler_,'ASSEMBLER'

  dw do_vocabulary
assembler_vocabulary_dummy_nfa:
  dw dummy_name_field
assembler_vocabulary_latest:
  dw forth_vocabulary_dummy_nfa
assembler_vocabulary_link:
  dw forth_vocabulary_link

else

  ; XXX TODO
  _colon_header assembler_,'ASSEMBLER'

  dw do_vocabulary
assembler_vocabulary_dummy_nfa:
  dw dummy_name_field
assembler_vocabulary_latest:
  dw forth_vocabulary_dummy_nfa
assembler_vocabulary_link:
  dw forth_vocabulary_link

endif

; ----------------------------------------------
  _colon_header code_,'CODE'

  dw header_
  dw base_,fetch_,hex_ ; save the current `base`
  dw context_,fetch_ ; save the current `context`
  dw assembler_
  dw store_csp_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header end_code_,'END-CODE'

  dw question_csp_
  dw context_,store_ ; restore `context`
  dw base_,store_ ; restore `base`
  dw smudge_
  dw semicolon_s_

; ----------------------------------------------
  _code_header compare_,'COMPARE'

  ; ANS Forth
  ; Adapted from DZX-Forth

  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  pop de      ; de = len2
  pop hl      ; hl = ca2
  ex (sp),hl  ; hl = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; cy = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; de = length of the short string
  ; hl = length of the long string
  ld l,c
  ld h,b ; hl = Forth IP
  pop bc ; bc = ca2
  ex (sp),hl ; hl = ca1 ; save Forth IP
  push af ; save carry flag
compare.compare_strings: equ $+1 ; XXX not used
  call compare_strings_case_sensitive
  jr nz,compare.no_match

compare.match:
  ; The smaller string matches.
  pop af ; restore flags
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl
  dec hl ; 0
  jp z,push_hl ; string1 equals string2
  dec hl ; -1
  jp push_hl

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ; [Code from DZX-Forth.]
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; ----------------------------------------------
  _code_header search_,'SEARCH'

  ; search  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  ; ANS Forth

  ; Adapted from DZX-Forth.
  ;
  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  exx ; save Forth IP
  pop hl
  ld (search.string_2_len),hl
  ld a,l
  or h ; len2 is zero?
  pop bc ; ca2
  pop hl ; len1
  ld (search.string_1_len),hl
  ex de,hl ; de = len1
  pop hl ; ca1
  ld (search.string_1_addr),hl
  jp z,search.match ; if len2 is zero, match
  dec hl
  inc de
search.1:
  inc hl ; address of current char of string 1
  dec de ; remaining length of string 1
  ld a,e
  or d ; end of string 1?
  jp z,search.no_match
; XXX OLD -- already commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
search.string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings_case_sensitive
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.match:
  ld bc,true
search.end:
  push hl
  push de
  push bc
  exx ; restore Forth IP
  _jp_next

search.no_match:
  ld bc,false
search.string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
search.string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.end

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE]',immediate

  dw tick_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERAL',immediate

  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate

  dw compile_,s_lit_,s_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_literal_,'CLITERAL',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,c_lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header literal_,'LITERAL',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header two_literal_,'2LITERAL',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    ; XXX TODO -- dlit
    dw question_comp_
    dw swap_,literal_,literal_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header depth_,'DEPTH'

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_stack_,'?STACK'

  ;dw cr_,depth_,dot_ ; XXX INFORMER
  dw sp_fetch_
  dw sp0_,fetch_
  dw swap_,less_than_
  _question_error stack_empty_error
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_error full_stack_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'


; XXX TODO -- In order to change the behaviour of `literal`, `2literal`
; and `cliteral` (make them give an error in interpretation mode),
; `interpret` must be modified.

interpret.begin:

; doc{
;
; interpret  ( -- )
;
; The outer text interpreter which sequentially executes or
; compiles text from the input stream (terminal or disk)
; depending on `state`. if the word name cannot be found after a
; search of `context` it is converted to a number according to
; the current `base`.  That also failing, an error message
; echoing the name with a "?" will be given.
;
; }doc
;
; Note: The main difference with the fig-Forth version of
; `interpret` is this version does not search the `current`
; vocabulary.

  ; XXX TODO -- finish

  dw question_stack_
  ;dw lit_,3,border_,key_,drop_ ; XXX INFORMER
  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  ;dw cr_,dot_s_ ; XXX INFORMER
  ;if 1 ; names_in_memory_bank?
    ; dw cr_,paren_dot_quote_ ; XXX INFORMER
    ; _string 'In interpret after defined ' ; XXX INFORMER
    ; dw hex_,dot_s_,decimal_,key_,drop_ ; XXX INFORMER
  ;endif
  dw question_dup_ ; found?
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  dw zero_branch_,interpret.word_not_found

  ; Found ( cfa 1 | cfa -1 )
  ; XXX TODO -- remove `negate` when `true` will equal -1 instead of 1
  dw state_,fetch_,negate_ ; compiling?
  dw equals_ ; compiling an immediate word?
  dw zero_branch_,interpret.execute

  ; Compiling and not immediate  ( cfa )
  dw comma_ ; compile the word
  dw branch_,interpret.begin

interpret.execute:
  ; Executing or immediate ( cfa )
;  dw lit_,2,border_,key_,drop_ ; XXX INFORMER
;  _echo 'about to execute cfa ' ; XXX INFORMER
;  dw dup_,u_dot_,key_,drop_ ; XXX INFORMER
  dw execute_
;  dw lit_,7,border_ ; XXX INFORMER
  dw branch_,interpret.begin

interpret.word_not_found:
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ; try to convert the text to a number
  ; ( ca )
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  dw number_
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number
  ; decimal point detected, so it's a double, 32-bit, number
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw two_literal_
  dw branch_,interpret.begin

interpret.16bit_number:
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
  dw branch_,interpret.begin

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIATE'

  dw latest_
  dw c_lit_
  db precedence_bit_mask
  ; XXX TODO factor `toggle-names'?
  _names_bank
  dw toggle_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header vocabulary_,'VOCABULARY'

  dw builds_ ; XXX TODO convert; see DZX-Forth
  dw lit_,dummy_name_field,comma_
  dw current_,fetch_
  dw pfa_to_cfa_ ; XXX FIXME this must be changed?
  dw comma_
  dw here_ ; address of vocabulary link
  dw voc_link_,fetch_,comma_
  dw voc_link_,store_ ; update `voc-link` with the link in this vocabulary
  dw does_ ; end in defining the vocabulary
  ; The next words are to be executed when the vocabulary invoked.
do_vocabulary:
  ; When the vocabulary is invoked, the second cell in its parameter field
  ; will be stored into the variable `context`.  The next
  ; dictionary search will begin with that vocabulary.
  dw two_plus_,context_,store_
  dw semicolon_s_

; ----------------------------------------------

if 1 ; fig_does?

  _does_header forth_,'FORTH'

  dw do_vocabulary
forth_vocabulary_dummy_nfa:
  dw dummy_name_field
forth_vocabulary_latest:
  dw nfa_of_top_most_word_in_forth_voc
forth_vocabulary_link:
  dw 0x0000

else

  ; XXX TODO
  _colon_header forth_,'FORTH'

  dw do_vocabulary
forth_vocabulary_dummy_nfa:
  dw dummy_name_field
forth_vocabulary_latest:
  dw nfa_of_top_most_word_in_forth_voc
forth_vocabulary_link:
  dw 0x0000

endif

; ----------------------------------------------
  _colon_header definitions_,'DEFINITIONS'

  dw context_,fetch_
  dw current_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

  dw c_lit_
  db ')'
  if 0 ; XXX OLD
    dw word_
  else
    ; XXX TODO use `skip`?
    dw parse_,two_drop_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header quit_,'QUIT'

  dw blk_,off_
  dw left_bracket_
quit.do:
  dw rp_store_
  dw cr_,query_
  dw interpret_
  dw comp_question_
  dw question_branch_,quit.do
  dw paren_dot_quote_
  _string 'ok'
  dw branch_,quit.do

; ----------------------------------------------
  _colon_header greeting_,'GREETING'

  dw paren_dot_quote_
  _string "Solo Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abort_,'ABORT'

  dw sp_store_
  dw decimal_
  ;dw lit_,4,border_ ; XXX INFORMER
  dw question_stack_
  dw page_,greeting_
  dw forth_,definitions_
boot:
  dw noop_ ; patched by `turnkey`
  dw quit_

; ----------------------------------------------
  _constant_header boot_,'BOOT'

  dw boot

; ----------------------------------------------
  _colon_header warm_,'WARM'

  dw empty_buffers_
  dw abort_

warm_start:
  call common_start
warm_start_phony_:
  dw warm_

; ----------------------------------------------
  _colon_header cold_,'COLD'

  dw empty_buffers_
  dw empty_csb_
  ; XXX TODO -- restore `np`
  dw first_,dup_,use_,store_,prev_,store_
  dw lit_,default_user_variables_start ; from
  dw lit_,user_variables_pointer,fetch_ ; to
  dw c_lit_
  db default_user_variables_end-default_user_variables_start ; length
  dw cmove_
  dw lit_,top_most_word_in_forth_voc,fetch_
  dw lit_,forth_vocabulary_latest,store_
  dw abort_

cold_start:
  call move_name_fields_to_memory_bank
  call common_start
cold_start_phony_:
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  pop bc ; get the return address, that holds the cfa of `cold` or `warm`
  xor a
  ld (iy+sys_df_sz_offset),a ; no lines at the bottom part of the screen
  ld ix,next
  ld sp,(s0_init_value)
  _jp_next

; ----------------------------------------------
  _code_header s_to_d_,'S>D'

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_de_hl ; jump if positive
  dec hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header plus_minus_,'+-'

  dw zero_less_than_
  dw zero_branch_,plus_minus.end
  dw negate_
plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_plus_minus_,'D+-'

  dw zero_less_than_
  dw zero_branch_,d_plus_minus.end
  dw dnegate_
d_plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abs_,'ABS'

  dw dup_
  dw plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dabs_,'DABS'

  dw dup_
  dw d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _code_header umax_,'UMAX'

  ; umax  ( u1 u2 -- u1 | u2 )

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMIN'

  ; umin  ( u1 u2 -- u1 | u2 )

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MIN'

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MAX'

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  ex de,hl
  jp push_hl

; ----------------------------------------------
  _colon_header m_star_,'M*'

  dw two_dup_
  dw xor_,to_r_
  dw abs_
  dw swap_,abs_,u_star_
  dw from_r_,d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_,'M/'

  dw over_
  dw to_r_
  dw to_r_
  dw dabs_
  dw r_fetch_
  dw abs_
  dw u_slash_mod_
  dw from_r_
  dw r_fetch_
  dw xor_
  dw plus_minus_
  dw swap_
  dw from_r_
  dw plus_minus_
  dw swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_,'*'

  dw m_star_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_mod_,'/MOD'

  dw to_r_,s_to_d_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_,'/'

  dw slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header mod_,'MOD'

  dw slash_mod_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MOD'

  dw to_r_,m_star_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_,'*/'

  dw star_slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_mod_,'M/MOD'

  dw to_r_,zero_,r_fetch_
  dw u_slash_mod_
  dw from_r_,swap_
  dw to_r_,u_slash_mod_,from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_line_,'(LINE)'

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_,b_slash_scr_,star_,plus_
  dw block_,plus_,c_slash_l_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_line_,'.LINE'

  dw paren_line_,minus_trailing_,type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header message_,'MESSAGE'

  dw warning_,fetch_
  dw zero_branch_,message.number_only
  dw msg_scr_,dot_line_,space_
  dw semicolon_s_

message.number_only:
  dw paren_dot_quote_
  _string 'MSG # '
  ; XXX TODO force decimal base
  dw dot_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header use_,'USE'

  dw first_buffer

; ----------------------------------------------
  _variable_header prev_,'PREV'

  dw first_buffer

; ----------------------------------------------
  _constant_header hash_buff_,'#BUFF'

  dw buffers

; ----------------------------------------------
  _colon_header plus_buf_,'+BUF'

; doc{

; +buf  ( a1 -- a2 f )  \ fig-Forth

;   Advance the disk buffer address _a1_ to the address of the next
;   buffer _a2_.  Boolean _f_ is false when _a2_ is the buffer
;   presently pointed to by the variable `prev`.

; }doc

  dw lit_,total_bytes_per_buffer,plus_ ; a2
  dw dup_,limit_,equals_ ; out of bounds?
  dw zero_branch_,plus_buf.continue
  ; a2 is out of bounds
  dw drop_,first_ ; use the first buffer instead
plus_buf.continue:
  dw dup_,prev_,fetch_,not_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header update_,'UPDATE'

  ; XXX TODO move to the disk?

  dw prev_,fetch_,fetch_
  dw lit_,0x8000,or_
  dw prev_,fetch_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFERS'

  dw first_,limit_,over_,minus_,erase_
  dw limit_,first_
  dw paren_do_
empty_buffers.do:
  dw lit_,0x7FFF,i_,store_
  if ! fig_null_word?
    ; Store a null word after the end of the buffer:
    dw lit_,null_word
    dw i_,lit_,data_bytes_per_buffer+2,plus_,store_
  endif
  dw lit_,total_bytes_per_buffer
  dw paren_plus_loop_,empty_buffers.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_,'BUFFER'

; doc{

; : buffer  ( n -- a )

; Obtain the next block buffer and assign it to block _n_.   If the
; contents of the buffer were marked as updated, it is written to the
; disk.  The block _n_ is not read from the disk.  The address left on
; stack is the first cell in the buffer for data storage.

; }doc

  dw use_,fetch_
  dw dup_,to_r_
buffer.begin:
  ; XXX NOTE: `+buf` won't work if single buffer
  dw plus_buf_
  dw zero_branch_,buffer.begin ; until
  dw use_,store_
  dw r_fetch_,fetch_
  dw zero_less_than_ ; updated?
  dw zero_branch_,buffer.end
  ; The buffer was updated, it must be saved to disk.
  dw r_fetch_,two_plus_ ; first cell of data in the buffer
  dw r_fetch_,fetch_
  dw lit_,0x7FFF,and_ ; discard the update bit, leave the block number
  dw zero_,read_write_ ; write
buffer.end:
  dw r_fetch_,store_
  dw r_fetch_,prev_,store_
  dw from_r_,two_plus_ ; first cell of data in the buffer
  dw semicolon_s_

; ----------------------------------------------
  _colon_header block_,'BLOCK'

  dw to_r_
  dw prev_,fetch_ ; most recently accessed buffer
  dw dup_,fetch_ ; its block number (bit 15, the update indicator, may be set)
  dw r_fetch_,minus_ ; compare to the required block
  dw two_star_ ; discard the left most bit, with is the update indicator
  dw zero_branch_,block.end
  ; Block number n is not the previously referenced.
  ; Prepare disk access.
block.begin:
  ; Scan the buffers and look for a buffer which might contain block n already.
  dw plus_buf_,zero_equals_ ; advance a buffer
  dw zero_branch_,branch_destination_0x71E5
  ; This buffer is pointed to by `prev`, all buffers scanned.
  dw drop_ ; discard the buffer address
  dw r_fetch_,buffer_ ; find the disk sector, update the sector if necessary.
  dw dup_,r_fetch_,one_,read_write_ ; read one sector from the disk
  dw two_minus_ ; backup to the buffer address of block n
branch_destination_0x71E5:
  dw dup_,fetch_ ; beginning address of the buffer, with a block number in it
  dw r_fetch_,minus_ ; compare to the block number n.
  dw two_star_ ; discard the left most bit, with is the update indicator
  dw question_branch_,block.begin ; until
  dw dup_,prev_,store_ ; store the buffer address in `prev`
block.end:
  dw r_drop_
  dw two_plus_ ; get the address where data begin
  dw semicolon_s_

; ----------------------------------------------
  _code_header c_swap_,'FLIP'

; doc{
;
; flip  ( n1 -- n2 )
;
;   Exchange the low and high bytes within n1.
;
; }doc

; [Name taken from eForth.]
; XXX TODO move to the disk

  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp push_hl

; ----------------------------------------------
  _colon_header block_to_sector_,'BLOCK>SECTOR'

; doc{
;
; ----
; : block>sector  ( block -- sector )
;   \ sector (high byte) = track 0..79, +128 if side 1
;   \        (low byte)   = sector 1..10
;   dup 10 mod 1+    \ sector 1..10
;   swap dup 20 /    \ track 0..79
;   swap 10 / 1 and  \ side 0..1
;   128 * +          \ track 0..207
;   cswap or  ;
; ----
;
; }doc

  dw dup_
  dw c_lit_
  db 10
  dw mod_,one_plus_,swap_,dup_
  dw c_lit_
  db 20
  dw slash_,swap_
  dw c_lit_
  db 10
  dw slash_,one_,and_
  ; XXX TODO optimize with `7 lshift`?
  dw c_lit_
  db 128
  dw star_,plus_,c_swap_,or_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header read_write_,'R/W'

  dw c_lit_
  db 0x45
  dw swap_,minus_
  dw lit_,read_write_sector_command,c_store_
  dw block_to_sector_
  dw paren_read_write_
  dw semicolon_s_

  ; Headerless word with the low level code of `R/W`.
paren_read_write_:
  dw paren_read_write_pfa
paren_read_write_pfa:
  ld a,2 ; drive ; XXX TMP
  pop de ; sector
  pop hl ; address
  push bc
  push hl
  pop ix ; address
  rst 8
read_write_sector_command:
  ; Patched by `R/W`:
  ;   0x45 = write
  ;   0x44 = read
  db 0x44
  pop bc
  ld ix,next
  _jp_next

; ----------------------------------------------
  _colon_header flush_,'FLUSH'

  ; XXX TODO -- move to the disk?

  dw hash_buff_,one_plus_,zero_
  dw paren_do_
flush.do:
  dw zero_,buffer_,drop_
  dw paren_loop_,flush.do ; loop
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_load_,'(LOAD)'

; doc{
;
; (load)  ( i*x u -- j*x )
;
; XXX FIXME wrong description: not the screen _u_ is stored in
; `blk`, but the correspondent disk block.
;
; Store _u_ in `blk` (thus making block _u_ the input source and
; setting the input buffer to encompass its contents), set `>in`
; to zero, and interpret.  Other stack effects are due to the
; words loaded.
;
; An error is issued if _u_ is zero or `blk` is zero.
;
; }doc

  dw dup_,zero_,equals_
  _question_error loading_from_screen_0_error
  dw to_in_,off_
  dw b_slash_scr_,star_,blk_,store_
  dw interpret_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header continued_,'CONTINUED'

; doc{
;
; load  ( i*x u -- j*x )  \ Forth-79 (uncontrolled word
; definition from the Reference Word Set)
;
; XXX FIXME  wrong description: not the screen _u_ is stored in
; `blk`, but the correspondent disk block.
;
; Store _u_ in `blk` (thus making block _u_ the input source and
; setting the input buffer to encompass its contents), set `>in`
; to zero, and interpret.  Other stack effects are due to the
; words loaded.
;
; An error is issued if _u_ is zero or `blk` is zero.
;
; }doc

; XXX TODO : An ambiguous condition exists if _u_ or is not a
; valid block number.

  dw question_loading_,paren_load_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header load_,'LOAD'

; doc{
;
; load  ( u -- )
;
; XXX FIXME  wrong description: not the screen _u_ is stored in
; `blk`, but the correspondent disk block.
;
; Save the current input-source specification. Store _u_ in
; `blk` (thus making block _u_ the input source and setting the
; input buffer to encompass its contents), set `>in` to zero,
; and interpret. When the parse area is exhausted, restore the
; prior input source specification. Other stack effects are due
; to the words loaded.
;
; An error is issued if _u_ is zero.
;
; }doc

; XXX TODO : An ambiguous condition exists if _u_ or is not a
; valid block number.

  dw blk_,fetch_,to_r_
  dw to_in_,fetch_,to_r_
  dw paren_load_
  dw from_r_,to_in_,store_
  dw from_r_,blk_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header next_screen_,'-->',immediate

  dw question_loading_
  dw to_in_,off_
  dw b_slash_scr_,blk_,fetch_,over_,mod_,minus_
  dw blk_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header defined_,'DEFINED'

; doc{
;
; defined  ( "name" -- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX TODO -- adapt to the new parsing method

  dw b_l_,word_
  dw here_,dup_,count_ ; ( ca ca+1 len )

if  0
  dw hex_
  dw cr_,paren_dot_quote_ ; XXX INFORMER
  _string 'In defined before find:' ; XXX INFORMER
  dw cr_,two_dup_,type_ ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
endif

  dw uppers_,find_

if 0
  dw cr_,paren_dot_quote_ ; XXX INFORMER
  _string 'In defined after find:' ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
  ;dw key_,drop_ ; XXX INFORMER
endif

  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINED'

  ; From DZX-Forth.

  dw zero_equals_
  _question_error not_found_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

  dw defined_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED]',immediate

  dw bracket_defined_,zero_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header tick_,"'"

  dw defined_,question_defined_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate

  dw tick_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header begin_,'BEGIN',immediate

; doc{
;
; begin  ( compilation: -- a n )
;
; At compile time `begin` leaves the dictionary address on
; stack with an error checking number _n_.  It does not compile
; anything to the dictionary.
;
; }doc

  dw question_comp_ ; error if not compiling
  dw backward_mark_ ; address to compute the backward branch
  dw one_ ; error checking number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header then_,'THEN',immediate

  dw question_comp_ ; error if not compiling
  dw two_,question_pairs_ ; check for nesting error
  dw forward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  ; _colon_header question_do_,'?DO',immediate

  ; XXX TODO

  ; dw compile_,paren_question_do_
  ; dw branch_,do.common

; ----------------------------------------------
  _colon_header do_,'DO',immediate

  dw compile_,paren_do_
do.common:
  dw backward_mark_
  dw c_lit_
  db 3
  dw semicolon_s_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate

  dw c_lit_
  db 3
  dw question_pairs_
  dw compile_,paren_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate

  dw c_lit_
  db 3
  dw question_pairs_
  dw compile_,paren_plus_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header until_,'UNTIL',immediate

  dw one_,question_pairs_
  dw compile_,zero_branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header again_,'AGAIN',immediate

; doc{
;
; again  ( compilation: a n -- )
;
; End of an infinite loop.  Compile an unconditional jump
; instruction to branch backward to _a_.
;
; }doc

  dw one_,question_pairs_ ; check n for error
  dw compile_,branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header repeat_,'REPEAT',immediate

; doc{
;
; repeat  ( compilation: a1 n1 a2 n2 -- )
;
; Compile `branch` to jump back to `begin`.  Resolve also  the
; branching offset required by `while`.
;
; }doc

  dw two_to_r_
  dw again_ ; unconditional branch back to `begin`
  dw two_from_r_
  dw two_minus_
  dw then_ ; resolve the forward branching needed by `while`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header if_,'IF',immediate

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
  dw two_ ; error checking number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header unless_,'UNLESS',immediate

  ; Equivalent to `0= if`, but faster.

  ; XXX TODO move to the disk?

  dw compile_,question_branch_
  dw branch_,if.do

; ----------------------------------------------
  _colon_header else_,'ELSE',immediate

  dw two_ ; error checking number
  dw question_pairs_
  dw compile_,branch_
  dw forward_mark_
  dw swap_
  dw two_ ; error checking number
  dw then_
  dw two_ ; error checking number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header while_,'WHILE',immediate

  dw if_
  dw two_plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header spaces_,'SPACES'

  dw b_l_,emits_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header emits_,'EMITS'

  ; emits  ( u c -- )

  ; XXX TODO use `?do` or `for` when available
  dw swap_,zero_,max_,question_dup_
  dw zero_branch_,emits_.end
  dw zero_
  dw paren_do_
emits_.do:
  dw dup_,emit_
  dw paren_loop_,emits_.do
emits_.end:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header less_hash_,'<#'

  dw pad_
  dw hld_
  dw store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_greater_,'#>'

  dw drop_
  dw drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header sign_,'SIGN'

; doc{

; sign  ( n  d  ---  d ) \ fig-Forth

; Stores an ascii "-" sign just before a converted numeric
; output string in the text output buffer when _n_ is negative.
; _n_ is discarded but double number _d_ is maintained. Must be
; used between `<#` and `#>`.

; }doc

  ; XXX TODO convert to ANS Forth

  dw rot_,zero_less_than_
  dw zero_branch_,sign.end
  dw c_lit_
  db '-'
  dw hold_
sign.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_,'#'

; doc{
;
; #  ( d1 -- d2 )
;
; Divide _d1_ by current base.  The remainder is converted to
; an ASCII character and appended to the output text string.
; The quotient _d2_ is left on stack.
;
; }doc


  dw base_,fetch_
  dw m_slash_mod_ ;  ( remainder dquotient )
  dw rot_ ; ( dquotient remainder )
  dw c_lit_
  db 0x09
  dw over_,less_than_ ; remainder<9?
  dw zero_branch_,hash.digit
  ; remainder<9
  dw c_lit_
  db 0x07
  dw plus_ ; make it an alphabet
hash.digit:
  ; Form the ASCII representation of a digit:
  ; "0" to "9" and "A" to "F" (or above).
  dw c_lit_
  db '0'
  dw plus_
  dw hold_ ; put the digit into `pad` in a reversed order.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_s_,'#S'

hash_s.begin:
  dw hash_,two_dup_,or_
  dw question_branch_,hash_s.begin
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.R'

; doc{
;
; d.r  ( d n -- )
;
; Print a signed double number _d_ right justified in a field of
; _n_ characters.
;
; }doc

  dw to_r_ ; save n
  ; Save the high order part of d under d,
  ; to be used by `sign` to add a "-" sign to a negative number:
  dw swap_,over_
  dw dabs_ ; convert d to its absolute value
  ; Convert the absolute value to ASCII text with proper sign:
  dw less_hash_,hash_s_,sign_,hash_greater_
  dw from_r_ ; retrieve n
  dw over_,minus_,spaces_ ; fill the output field with preceding blanks
  dw type_ ; type out the number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_r_,'.R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_,'D.'

; doc{
;
; d.  ( d -- )
;
; Print signed double integer _d_ according to current base,
; followed by only one blank.
;
; }doc

  dw zero_,d_dot_r_,space_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; .  ( n -- )
;
; Print signed integer _n_ according to current base, followed
; by only one blank.
;
; }doc

  dw s_to_d_,d_dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_,'?'

  dw fetch_,dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header u_dot_,'U.'

  dw zero_,d_dot_
  dw semicolon_s_

; ----------------------------------------------

if 1

  _colon_header dot_s_,'.S'

  ; XXX TMP -- only during the development, then remove
  ; It is already on the disk.

  dw depth_,dup_,s_to_d_,less_hash_
  dw c_lit_
  db '>'
  dw hold_,hash_s_
  dw c_lit_
  db '<'
  dw hold_,hash_greater_,type_,space_
  dw zero_branch_,dot_s.end

  dw sp_fetch_,two_minus_,sp0_,fetch_,two_minus_
  dw paren_do_
dot_s.do:
  dw i_,fetch_,u_dot_ ; XXX TMP `u.`
  dw lit_,-2
  dw paren_plus_loop_,dot_s.do
dot_s.end:
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header words_,'WORDS'

  ; XXX TODO move to the disk
  dw c_lit_
  db 0x80
  dw out_,store_
  dw trail_
words.begin:
  dw out_,fetch_
  dw c_lit_
  db 0x1F ; max word length
  dw c_lit_
  db 0x08
  dw minus_
  dw greater_than_
  dw zero_branch_,words.continue
  dw cr_,out_,off_
words.continue:
  dw dup_,id_dot_
  dw nfa_to_lfa_,fetch_n_
  dw dup_,zero_equals_,question_terminal_,or_
  dw zero_branch_,words.begin ; until
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header list_,'LIST'


  ; XXX TODO move to the disk
  dw cr_
  dw dup_,scr_,store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw dot_
  dw c_lit_
  db lines_per_screen
  dw zero_
  dw paren_do_
list.do:
  dw cr_
  dw i_
  dw c_lit_
  db 0x02
  dw dot_r_
  dw space_,i_,scr_,fetch_,dot_line_
  dw question_terminal_
  dw zero_branch_,list.loop
  dw leave_
list.loop:
  dw paren_loop_,list.do ; loop
  dw cr_
  dw semicolon_s_

; ----------------------------------------------
  _code_header page_,'PAGE'

  push bc
  call rom_cl_all
  ; XXX TODO check the status of the printer
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header bye_,'BYE'

  ld (iy+sys_df_sz_offset),0x02 ; restore lines of the lower screen
  rst 0x08
  db 0x08 ; "STOP" BASIC error

; ----------------------------------------------
  _code_header two_drop_,'2DROP'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWAP'

  ; [Code from DZX-Forth.]

  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header unused_,'UNUSED'

  ; XXX TMP
  dw zero_,here_,minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header index_,'INDEX'

  ; XXX TODO -- remove, already copied to the disk

  dw one_plus_
  dw swap_
  dw paren_do_
index.do:
  dw cr_,i_
  dw c_lit_
  db 3
  dw dot_r_,space_
  dw zero_,i_,dot_line_
  dw question_terminal_
  dw zero_branch_,index.loop
  dw leave_
index.loop:
  dw paren_loop_,index.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header where_,'WHERE'

  ; XXX TODO -- remove; already copied to the disk

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw semicolon_s_

where.do_it:
  dw dup_,b_slash_scr_,slash_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_,dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  dw c_lit_
  db '^'
  dw emit_
  dw semicolon_s_

; ----------------------------------------------
  _constant_header next_,'NEXT'

  dw next

; ----------------------------------------------
  _constant_header pushhl_,'PUSHHL'

  dw push_hl

; ----------------------------------------------
  _constant_header pushde_,'PUSHDE'

  dw push_de_hl

; ----------------------------------------------
  _colon_header at_,'AT'

; doc{

; : at ( line col -- )

; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

; [Code adapted from Spectrum Forth-83.]

  dw swap_,dup_
  dw c_lit_
  db 23
  dw not_equals_ ; not the last line?
  dw zero_branch_,at_pfa.last_line
  ; not the last line
  dw lit_,22,paren_emit_,paren_emit_,paren_emit_
  dw semicolon_s_

at_pfa.last_line:
  dw one_minus_,dup_,paren_emit_,paren_emit_,zero_,paren_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  dw c_lit_
  db 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header border_,'BORDER'

  pop hl
  ld a,l
  out(0xFE),a
  _jp_next

; ----------------------------------------------
  _code_header gover_,'GOVER'

  ld a,over_char
  jp color

; ----------------------------------------------
  _code_header flash_,'FLASH'

  ld a,flash_char
  jp color

; ----------------------------------------------
  _code_header inverse_,'INVERSE'

  ld a,inverse_char
  jp color

; ----------------------------------------------
  _code_header bright_,'BRIGHT'

  ld a,bright_char
  jp color

; ----------------------------------------------
  _code_header paper_,'PAPER'

  ld a,paper_char
  jp color

; ----------------------------------------------
  _code_header ink_,'INK'

  ld a,ink_char

color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or gover).
  ; Input:
  ;   a = attribute control char
  ;   (tos) = color attribute value
  rst 0x10
  pop hl
  ld a,l
  rst 0x10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _code_header j_,'J'

; doc{
;
; j  ( -- x2 ) ( R: x1 x2 -- x1 x2 )
;
; x1 = loop index
; x2 = loop limit
;
; Get a copy of the current (innermost) do-loop limit.
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTANT'

  dw two_variable_
  dw paren_semicolon_code_
do_two_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header two_variable_,'2VARIABLE'

; doc{
;
; 2variable ( "name" -- )  \ ANS Forth
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve two consecutive
; cells of data space.
;
;    _name_ is referred to as a two-variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the first (lowes address) cell of two
;    consecutive cells. A program is responsible for
;    initializing the contents.
;
; }doc

  dw create_
  dw lit_,cell*2,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header u_dot_r_,'U.R'

  dw to_r_,zero_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _code_header two_over_,'2OVER'

; doc{
;
; 2over  ( d1 d2 -- d1 d2 d1 )
;
; }doc

  ld hl,4
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header exit_,'EXIT'

; doc{
; 
; exit  ( -- ) ( R: a -- )  \ ANS Forth
;
; Return control to the calling definition, specified by the
; address on the return stack.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; }doc

; XXX TODO combine with `;s`?

  dw r_drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exit_,'?EXIT'

; doc{
; 
; ?exit  ( f -- ) ( R: a | -- a | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by the address on the return stack.
; 
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; }doc

  dw question_branch_,exit_pfa
  dw semicolon_s_

; ----------------------------------------------
  _colon_header case_,'CASE',immediate
  ; XXX TODO move to the disk?

  dw question_comp_
  dw csp_,fetch_,store_csp_
  dw c_lit_
  db 0x04
  dw semicolon_s_

; ----------------------------------------------
  _colon_header of_,'OF',immediate

  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,over_
  dw compile_,equals_
  dw compile_,zero_branch_
  dw forward_mark_
  dw compile_,drop_
  dw c_lit_
  db 0x05
  dw semicolon_s_

; ----------------------------------------------
  _colon_header endof_,'ENDOF',immediate

  dw c_lit_
  db 0x05
  dw question_pairs_
  dw compile_,branch_
  dw forward_mark_
  dw swap_
  dw two_ ; error checking number
  dw then_
  dw c_lit_
  db 0x04
  dw semicolon_s_

; ----------------------------------------------
  _colon_header endcase_,'ENDCASE',immediate

  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,drop_
endcase.compile_then:
  dw sp_fetch_,csp_,fetch_,equals_
  dw question_branch_,endcase.end
  dw two_,then_
  dw branch_,endcase.compile_then
endcase.end:
  dw csp_,store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header inkey_,'INKEY'
  ; XXX TODO move to the disk

  push bc
  call rom_key_scan
  ld c,0x00
  jr nz,l8128h
  call rom_key_test
  jr nc,l8128h
  dec d
  ld e,a
  call rom_key_decode
l8128h:
  ld l,a
  ld h,0x00
  pop bc
  jp push_hl

; ----------------------------------------------
  _colon_header char_,'CHAR'

  if 0 ; XXX OLD
    dw b_l_,word_,here_,one_plus_,c_fetch_
  else
    dw parse_word_,drop_,c_fetch_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_char_,'[CHAR]',immediate

  dw char_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_quote_,'S"',immediate

  ; : s"  ( compilation: "text<">" -- ) ( run-time:  -- ca len )
  ;  [char] " (s)  ; immediate

  dw c_lit_
  db '"'
  dw paren_s_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_next_screen_,'?-->',immediate

  dw zero_branch_,question_next_screen.end
  dw next_screen_
question_next_screen.end:
  dw semicolon_s_

  ; XXX TODO a good place to use `??` instead of a branch:
;  dw question_question_,next_screen_
;  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw to_in_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .(  ( 'text<paren>' -- )  \ immediate
;
; }doc

  dw c_lit_
  db ')'
  dw parse_,type_
  dw semicolon_s_

nfa_of_top_most_word_in_forth_voc: equ dot_paren_nfa

dictionary_pointer_after_cold:

; ==============================================================
; Name and link fields

if 1 ; names_in_memory_bank?

move_name_fields_to_memory_bank:
  
  ; Move the name fields, assembled in ordinary memory,
  ; to the names bank. This routine is needed only once.
  ; Its call is patched with `noop` at the end, and the routine
  ; itself will be overwritten by the Forth dictionary.

  ; The whole screen is used as intermediate buffer for copying
  ; the data.

  ld hl,names_bank_address
  ld de,16384 ; screen
  ld bc,6912 ; screen size
  ldir
  ld e,names_bank
  call bank.e
  ld hl,16384 ; screen
  ld de,names_bank_address
  ldir
  ld e,default_bank
  call bank.e
  ; Erase the default bank (not necessary)
  ld hl,names_bank_address ; the first byte is 0
  ld de,names_bank_address+1
  ld bc,16384
  ldir
  ; Remove the call to this routine:
  ld hl,cold_start ; address of the call to this routine
  ld (hl),0 ; noop
  inc hl
  ld (hl),0 ; noop
  inc hl
  ld (hl),0 ; noop
  ret

  org names_bank_address

  db 0 ; fake length byte, needed by the algorithm used in `cfa>nfa`

endif

; ==============================================================
; End

end cold_entry

; ==============================================================
; Debug tools

  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER

  ;dw two_dup_,two_,ink_,type_,zero_,ink_ ; XXX INFORMER

; ==============================================================
; Development notes
;
; 2015-06-25:
;
; Number  Times compiled (not including error numbers)
; 0       20
; 1       11
; 2       11
; 3       6
