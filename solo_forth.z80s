; Solo Forth

; A disk-based Forth for ZX Spectrum,
; focused on development of ZX Spectrum programs.

; Version A-00-201506100153
; Latests important changes (in chronological order)
; - `(emit)` and attributes fixed.

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; ==============================================================
; Author and acknowledgements

; 2015: Solo Forth
;
; Marcos Cruz (programandala.net)
; http://programandala.net/en.program.solo_forth.html
;
; Solo Forth started with the code of Abersoft Forth (for ZX Spectrum), that
; was first studied and much improved
; (http://programandala.net/en.program.afera.html) and finally fully
; disassembled (http://programandala.net/en.program.abersoft_forth.html).
;
; 1983: Abersoft Forth
;
; Abersoft Forth (for ZX Spectrum) was implemented by John Jones Steele and
; edited by Melbourne House in 1983. It's a tape and RAM disk implementation
; of Z80 fig-Forth 1.1, with ZX Spectrum specific features and some
; extensions beyond the fig-Forth model.
;
; 1979: fig-Forth 1.1
;
; All publications of the FORTH Interest Group are public domain.  They may
; be further distributed by the inclusion of this credit notice:

;               This publication has been made available by:

;               FORTH Interest Group
;               P.O. Box 1105
;               San Carlos, Ca. 94070

; Aknowledgments:

; Solo Forth has copied, adapted and implemented ideas, code and
; documentation from the following Forth systems (acknowledgment notes are
; properly included in the correspondent sources):

; Spectrum Forth-83, by Lennart Benschop (1988,2015)
; v.Forth, by Matteo Vitturi (1990-2015)
; lina ciforth, by Albert van der Horst (2000-2004)

; ==============================================================
; License

; XXX TODO

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

origin:                           equ 0x5E00

false                             equ 0
true                              equ 1

cell                              equ 2

cells_per_data_stack:             equ 0x50
cells_per_return_stack:           equ 0x50

bytes_per_terminal_input_buffer:  equ 0x50

buffers:                          equ 0x02
data_bytes_per_buffer:            equ 0x0200
total_bytes_per_buffer:           equ data_bytes_per_buffer+4
blocks_per_screen:                equ 0x02
characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10

precedence_bit:       equ 6
precedence_bit_mask:  equ 1 shl precedence_bit
smudge_bit:           equ 5
smudge_bit_mask:      equ 1 shl smudge_bit

; ----------------------------------------------
; Config

  ; XXX experimental
  ; The original code used IX as the user variables pointers,
  ; but it seems more useful holding the address of `next` in it.
user_variables_pointer_in_ix?   equ false

  ; XXX experimental
  ; When true, some code pieces are more compact but slower.
size_optimization?              equ false

; ----------------------------------------------
; Character codes

caps_char:                  equ 0x06 ; toggle caps lock
edit_char:                  equ 0x07 ; edit
backspace_char:             equ 0x08
delete_char:                equ 0x0c ; delete (backspace)
form_feed_char:             equ 0x0c ; used for printing
carriage_return_char:       equ 0x0d
extended_mode_char:         equ 0x0e ; Fuse associates it to the host's Tab key
graphics_char:              equ 0x0f ; toggle graphics mode
ink_char:                   equ 0x10
paper_char:                 equ 0x11
flash_char:                 equ 0x12
bright_char:                equ 0x13
inverse_char:               equ 0x14
over_char:                  equ 0x15
at_char:                    equ 0x16
tab_char:                   equ 0x17 ; tab (screen only)

; ----------------------------------------------
; ROM  routines

rom_beeper:                      equ 0x03B5
rom_border_0x2297:               equ 0x2297
rom_break_key:                   equ 0x1F54
rom_chan_open:                   equ 0x1601
rom_cl_all:                      equ 0x0DAF
rom_find_int1:                   equ 0x1E94
rom_key_decode:                  equ 0x0333
rom_key_scan:                    equ 0x028E
rom_key_test:                    equ 0x031E
rom_plot_0x22DF:                 equ 0x22DF
rom_point_sub_0x22CE:            equ 0x22CE
rom_s_attr_s_0x2583:             equ 0x2583
rom_s_scrn_s_0x2538:             equ 0x2538
rom_sa_all:                      equ 0x075A
rom_set_permanent_colors_0x1CAD  equ 0x1CAD
rom_stack_fetch:                 equ 0x2BF1

; ----------------------------------------------
; System variables

  ; XXX FIXME Pasmo's bug?: `sys_errnr` is used as the base offset.  When it's
  ; not the defined first, the compilation halts with error "offset out of
  ; range", though they are fine in the symbols file.

sys_errnr:         equ 0x5C3A ; IY index

sys_attr_p:        equ 0x5C8D
sys_coordx:        equ 0x5C7D
sys_coordy:        equ 0x5C7E
sys_df_cc:         equ 0x5C84
sys_df_sz:         equ 0x5C6B
sys_df_sz_offset:  equ sys_df_sz-sys_errnr
sys_flags2:        equ 0x5C6A
sys_last_k:        equ 0x5C08
sys_mode:          equ 0x5C41
sys_s_posn:        equ 0x5C88
sys_scr_ct:        equ 0x5C8C
sys_scr_ct_offset: equ sys_scr_ct-sys_errnr
sys_t_addr:        equ 0x5C74
sys_udg:           equ 0x5C7B

; ==============================================================
; Macros

_header: macro name,immediate

  ; XXX TODO -- Copied from DZX-Forth. Adapt it.

  ; name        = name string
  ; immediate   = _immediate or nothing

  ; the name field
  this_nfa: defl $ ; link address for next word
  bits: defl 0x80
  if not nul immediate
    ; set immediate bit
    bits: defl bits | precedence_bit_mask
  endif
  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first+bits    ; count and flags byte
  _first:
  db name
  db last_letter+0x80
  _next:
  dw previous_nfa ; the link field

  previous_nfa: defl this_nfa

endm

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_jp_next: macro

  if user_variables_pointer_in_ix?
    jp next
  else
    jp (ix)
  endif

  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location: `0x00 +origin`
  jp cold_start
warm_entry:
  ; Location: `0x03 +origin`
  jp warm_start

; ==============================================================
; Parameter area

top_most_word_in_forth_voc:
  ; Location: `0x06 +origin`
  dw nfa_of_top_most_word_in_forth_voc

user_variables_pointer:
  ; Location: `0x08 +origin`
  dw user_variables

return_stack_pointer:
  ; Location: `0x0A +origin`
  dw return_stack_bottom

  ; User variables default values

  ; The first eight user variables have default values.  They are used
  ; by `cold` to overwrite the correspondent user variables.  They must
  ; be in the same order than user variables.

default_user_variables_start:

s0_init_value:
  ; Location: `0x0C +origin`
  dw data_stack_bottom
r0_init_value:
  ; Location: `0x0E +origin`
  dw return_stack_bottom
tib_init_value:
  ; Location: `0x10 +origin`
  dw terminal_input_buffer
width_init_value:
  ; Location: `0x12 +origin`
  dw 0x001F
warning_init_value:
  ; Location: `0x14 +origin`
  dw 0x0000
fence_init_value:
  ; Location: `0x16 +origin`
  dw dictionary_pointer_after_cold
dp_init_value:
  ; Location: `0x18 +origin`
  dw dictionary_pointer_after_cold
voc_link_init_value:
  ; Location: `0x1A +origin`
  dw forth_vocabulary_link

default_user_variables_end:

; ==============================================================
; User variables

user_variables:

s0_value: ; +0x00
  dw 0x0000
r0_value: ; +0x02
  dw 0x0000
tib_value: ; +0x04
  dw 0x0000
width_value: ; +0x06
  dw 0x0000
warning_value: ; +0x08
  dw 0x0000
fence_value: ; +0x0A
  dw 0x0000
dp_value: ; +0x0C
  dw 0x0000
voc_link_value: ; +0x0E
  dw 0x0000
blk_value: ; +0x10
  dw 0x0000
in_value: ; +0x12
  dw 0x0000
out_value: ; +0x14
  dw 0x0000
scr_value: ; +0x16
  dw 0x0000
  ; +0x18 ; not used (formerly `offset`)
  dw 0x0000
context_value: ; +0x1A
  dw 0x0000
current_value: ; +0x1C
  dw 0x0000
state_value: ; +0x1E
  dw 0x0000
base_value: ; +0x20
  dw 0x0000
dpl_value: ; +0x22
  dw 0x0000
fld_value: ; +0x24
  dw 0x0000
csp_value: ; +0x26
  dw 0x0000
r_hash_value: ; +0x28 ; XXX OLD
  dw 0x0000
hld_value: ; +0x2A
  dw 0x0000

  ; Unused
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  defs cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  defs bytes_per_terminal_input_buffer

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  defs cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffers

first_buffer:
  defs blocks_per_screen*total_bytes_per_buffer
limit:

; ==============================================================
; Misc routines

compare_de_hl_unsigned:

  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de

  ; Taken from DZX-Forth
  ; (http://programandala.net/en.program.dzx-forth.html)

  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

; ==============================================================
; Inner interpreter

pushde:
  push de

pushhl:
  push hl

next:
  ; Execute the word pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa

next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa)
  ; de = cfa+1 = pfa-1
  jp (hl)

; ==============================================================
; Dictionary

c_lit_nfa:
  db 0x04+0x80,'CLI','T'+0x80
c_lit_lfa:
  dw 0x0000
c_lit_:
  dw c_lit_pfa
c_lit_pfa:
  ld a,(bc)
  inc bc
  ld l,a
  ld h,0
  jp pushhl

lit_nfa:
  db 0x03+0x80,'LI','T'+0x80
lit_lfa:
  dw c_lit_nfa
lit_:
  dw lit_pfa
lit_pfa:
  ld a,(bc)
  inc bc
  ld l,a
  ld a,(bc)
  inc bc
  ld h,a
  jp pushhl

execute_nfa:
  db 0x07+0x80,'EXECUT','E'+0x80
execute_lfa:
  dw lit_nfa
execute_:
  dw execute_pfa
execute_pfa:
  pop hl
  jp next2

branch_nfa:
  db 0x06+0x80,'BRANC','H'+0x80
branch_lfa:
  dw execute_nfa
branch_:
  dw branch_pfa
branch_pfa:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  _jp_next

zero_branch_nfa:
  db 0x07+0x80,'0BRANC','H'+0x80
zero_branch_lfa:
  dw branch_nfa
zero_branch_:
  dw zero_branch_pfa
zero_branch_pfa:
  pop hl
  ld a,l
  or h
  jp z,branch_pfa
  inc bc
  inc bc
  _jp_next

  ; XXX NEW
question_branch_nfa:
  db 0x07+0x80,'?BRANC','H'+0x80
question_branch_lfa:
  dw zero_branch_nfa
question_branch_:
  dw question_branch_pfa
question_branch_pfa:
  pop hl
  ld a,l
  or h
  jp nz,branch_pfa
  inc bc
  inc bc
  _jp_next

paren_loop_nfa:
  db 0x06+0x80,'(LOOP',')'+0x80
paren_loop_lfa:
  dw question_branch_nfa
paren_loop_:
  dw paren_loop_pfa
paren_loop_pfa:
  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_stack_pointer)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl
  inc d
  dec d
  ld d,a
  jp m,l5eedh
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp l5ef2h
l5eedh:
  ld a,(hl)
  sub e
  inc hl
  ld a,(hl)
  sbc a,d
l5ef2h:
  jp m,branch_pfa
  inc hl
  ld (return_stack_pointer),hl
  inc bc
  inc bc
  _jp_next

paren_plus_loop_nfa:
  db 0x07+0x80,'(+LOOP',')'+0x80
paren_plus_loop_lfa:
  dw paren_loop_nfa
paren_plus_loop_:
  dw paren_plus_loop_pfa
paren_plus_loop_pfa:
  pop de
  jp paren_loop.step_in_de

paren_do_nfa:
  db 0x04+0x80,'(DO',')'+0x80
paren_do_lfa:
  dw paren_plus_loop_nfa
paren_do_:
  dw paren_do_pfa
paren_do_pfa:
  ld hl,(return_stack_pointer)
  dec hl
  dec hl
  dec hl
  dec hl
  ld (return_stack_pointer),hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  pop de
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

i_nfa:
  db 0x01+0x80,'','I'+0x80
i_lfa:
  dw paren_do_nfa
i_:
  dw r_fetch_pfa

digit_nfa:
  db 0x05+0x80,'DIGI','T'+0x80
digit_lfa:
  dw i_nfa
digit_:
  dw digit_pfa
digit_pfa:
  pop hl
  pop de
  ld a,e
  sub 0x30
  jp m,l5f65h
  cp 0x0A
  jp m,l5f5ah
  sub 0x07
  cp 0x0A
  jp m,l5f65h
l5f5ah:
  cp l
  jp p,l5f65h
  ld e,a
  ld hl,0x0001
  jp pushde
l5f65h:
  ld l,h
  jp pushhl

paren_find_nfa:
  db 0x06+0x80,'(FIND',')'+0x80
paren_find_lfa:
  dw digit_nfa
paren_find_:
  dw paren_find_pfa
paren_find_pfa:
  ; XXX TODO optimize speed with absolute jumps?
  pop de
l5f75h:
  pop hl
  push hl
  ld a,(de)
  xor (hl)
  and 0x3F
  jr nz,l5f9ch
l5f7dh:
  inc hl
  inc de
  ld a,(de)
  xor (hl)
  add a,a
  jr nz,l5f9ah
  jr nc,l5f7dh
  ld hl,0x0005
  add hl,de
  ex (sp),hl
l5f8bh:
  dec de
  ld a,(de)
  or a
  jp p,l5f8bh
  ld e,a
  ld d,0x00
  ld hl,0x0001
  jp pushde
l5f9ah:
  jr c,l5fa2h
l5f9ch:
  inc de
  ld a,(de)
  or a
  jp p,l5f9ch
l5fa2h:
  inc de
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e
  jr nz,l5f75h
  pop hl
  ld hl,0x0000
  jp pushhl

enclose_nfa:
  db 0x07+0x80,'ENCLOS','E'+0x80
enclose_lfa:
  dw paren_find_nfa
enclose_:
  dw enclose_pfa
enclose_pfa:
  ; XXX TODO optimize: exchange the parameters and save `swap` before calling.
  pop de ; e  = delimiter
  pop hl ; hl = address
  push hl
  ld a,e
  ld d,a
  ld e,0xFF
  dec hl
l5fc6h:
  inc hl
  inc e
  cp (hl)
  jr z,l5fc6h
  ld d,0x00
  push de
  ld d,a
  ld a,(hl)
  and a
  jr nz,l5fdch
  ld d,0x00
  inc e
  push de
  dec e
  push de
  _jp_next
l5fdch:
  ld a,d
  inc hl
  inc e
  cp (hl)
  jr z,l5fedh
  ld a,(hl)
  and a
  jr nz,l5fdch
  ld d,0x00
  push de
  push de
  _jp_next
l5fedh:
  ld d,0x00
  push de
  inc e
  push de
  _jp_next

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
; Copied from Spectrum Forth-83.

chan_nfa:
  db 0x0+0x80,'CHA','N'+0x80
chan_lfa:
  dw enclose_nfa
chan_:
  dw chan_pfa
chan_pfa:
  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

emit_nfa:
  db 0x04+0x80,'EMI','T'+0x80
emit_lfa:
  dw chan_nfa
emit_:
  dw do_colon
emit_pfa:
  dw paren_emit_
  dw one_,out_,plus_store_
  dw semicolon_s_

; doc{

; (emit)  ( b -- )

; Send the character b to the current channel.
;
; This word is copied from `TOCH`, from Lennart Benschop's Spectrum
; Forth-83.

; }doc

paren_emit_nfa:
  db 0x06+0x80,'(EMIT',')'+0x80
paren_emit_lfa:
  dw emit_nfa
paren_emit_:
  dw paren_emit_pfa
paren_emit_pfa:
  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
  _jp_next

printer_nfa:
  db 0x07+0x80,'PRINTE','R'+0x80
printer_lfa:
  dw paren_emit_nfa
printer_:
  dw do_colon
printer_pfa:
  dw three_,chan_
  dw semicolon_s_

display_nfa:
  db 0x07+0x80,'DISPLA','Y'+0x80
display_lfa:
  dw printer_nfa
display_:
  dw do_colon
display_pfa:
  dw two_,chan_
  dw semicolon_s_

key_nfa:
  db 0x03+0x80,'KE','Y'+0x80
key_lfa:
  dw display_nfa
key_:
  dw key_pfa
key_pfa:

  push bc
  ld a,0x02
  call rom_chan_open

  ; flash on
  ld a,0x12
  rst 0x10
  ld a,0x01
  rst 0x10

key.new_key:
  xor a
  ld (sys_last_k),a
  ; Print cursor:
key.cursor_char: equ $+1
  ld a,'L'
  rst 0x10
  ld a,0x08
  rst 0x10
key.wait_for_key:
  ld a,(sys_last_k)
  and a
  jr z,key.wait_for_key
  ; a = pressed key code

  cp 0x06 ; caps?
  jr nz,key.graphic_mode
  ; caps
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a

key.not_graphic_mode_cursor:
  ; a = 0 (lowercase mode)
  ;     8 (uppercase mode)
  ld hl,key.cursor_char
  bit 3,a ; cursor 'L'?
  jr nz,key.cursor_c
  ld (hl),'L'
  jr key.new_key
key.cursor_c:
  ld (hl),'C'
  jr key.new_key

key.graphic_mode:
  cp 0x0F ; change graphics mode?
  jr nz,key.left_bracket
  ; graphics
  ld a,0x02
  ld hl,sys_mode
  xor (hl)
  ld (hl),a
  and a ; now in graphics mode?
  jr nz,key.graphic_mode_cursor
  ; not in graphics mode
  ld a,(sys_flags2)
  jr key.not_graphic_mode_cursor

key.graphic_mode_cursor:
  ld a,'G'
  ld (key.cursor_char),a
  jr key.new_key

  ; Translate some chars
key.left_bracket:
  cp 0xC6
  jr nz,key.right_bracket
  ld a,'['
key.right_bracket:
  cp 0xC5
  jr nz,key.tilde
  ld a,']'
key.tilde:
  cp 0xE2
  jr nz,key.vertical_bar
  ld a,'~'
key.vertical_bar:
  cp 0xC3
  jr nz,key.backslash
  ld a,'|'
key.backslash:
  cp 0xCD
  jr nz,key.left_curly_bracket
  ld a,'\'
key.left_curly_bracket:
  cp 0xCC
  jr nz,key.right_curly_bracket
  ld a,'{'
key.right_curly_bracket:
  cp 0xCB
  jr nz,key.limit
  ld a,'}'

key.limit:
  cp 0xA5 ; greater than 0xA4 (the last UDG)?
  jr nc,key.new_key
  ld l,a
  ld h,0x00

  ; flash off
  ld a,0x12
  rst 0x10
  ld a,0x00
  rst 0x10

  ; delete the cursor
  ld a,0x20
  rst 0x10
  ld a,0x08
  rst 0x10

  pop bc
  jp pushhl


question_terminal_nfa:
  db 0x09+0x80,'?TERMINA','L'+0x80
question_terminal_lfa:
  dw key_nfa
question_terminal_:
  dw question_terminal_pfa
question_terminal_pfa:
  call rom_break_key
  jp nc,true_pfa
  ld a,(sys_last_k)
  cp edit_char
  jp z,true_pfa
  jp false_pfa

cr_nfa:
  db 0x02+0x80,'C','R'+0x80
cr_lfa:
  dw question_terminal_nfa
cr_:
  dw do_colon
cr_pfa:
  ; From Spectrum Forth-83.
  dw c_lit_
  db carriage_return_char
  dw emit_
  dw out_,off_
  dw semicolon_s_

cmove_nfa:
  db 0x05+0x80,'CMOV','E'+0x80
cmove_lfa:
  dw cr_nfa
cmove_:
  dw cmove_pfa
cmove_pfa:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ld a,b
  or c
  jr z,cmove.end
  ldir
cmove.end:
  pop bc
  _jp_next

u_star_nfa:
  db 0x02+0x80,'U','*'+0x80
u_star_lfa:
  dw cmove_nfa
u_star_:
  dw u_star_pfa
u_star_pfa:
  pop de
  pop hl
  push bc
  ld b,h
  ld a,l
  call sub_606dh
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_606dh
  pop de
  ld c,d
  add hl,bc
  adc a,0x00
  ld d,l
  ld l,h
  ld h,a
  pop bc
  push de
  jp pushhl
sub_606dh:
  ld hl,0x0000
  ld c,0x08
l6072h:
  add hl,hl
  rla
  jr nc,l6079h
  add hl,de
  adc a,0x00
l6079h:
  dec c
  jr nz,l6072h
  ret

u_slash_mod_nfa:
  db 0x05+0x80,'U/MO','D'+0x80
u_slash_mod_lfa:
  dw u_star_nfa
u_slash_mod_:
  dw u_slash_mod_pfa
u_slash_mod_pfa:
  ld hl,0x0004
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l60a0h
  ld hl,0xFFFF
  ld de,0xFFFF
  jr l60c0h
l60a0h:
  ld a,0x10
l60a2h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l60aah
  inc de
  and a
l60aah:
  ex de,hl
  rra
  push af
  jr nc,l60b4h
  and l
  sbc hl,bc
  jr l60bbh
l60b4h:
  and a
  sbc hl,bc
  jr nc,l60bbh
  add hl,bc
  dec de
l60bbh:
  inc de
  pop af
  dec a
  jr nz,l60a2h
l60c0h:
  pop bc
  push hl
  push de
  _jp_next

and_nfa:
  db 0x03+0x80,'AN','D'+0x80
and_lfa:
  dw u_slash_mod_nfa
and_:
  dw and_pfa
and_pfa:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp pushhl

or_nfa:
  db 0x02+0x80,'O','R'+0x80
or_lfa:
  dw and_nfa
or_:
  dw or_pfa
or_pfa:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp pushhl

xor_nfa:
  db 0x03+0x80,'XO','R'+0x80
xor_lfa:
  dw or_nfa
xor_:
  dw xor_pfa
xor_pfa:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp pushhl

sp_fetch_nfa:
  db 0x03+0x80,'SP','@'+0x80
sp_fetch_lfa:
  dw xor_nfa
sp_fetch_:
  dw sp_fetch_pfa
sp_fetch_pfa:
  ld hl,0x0000
  add hl,sp
  jp pushhl

sp_store_nfa:
  db 0x03+0x80,'SP','!'+0x80
sp_store_lfa:
  dw sp_fetch_nfa
sp_store_:
  dw sp_store_pfa
sp_store_pfa:

  if user_variables_pointer_in_ix? ; XXX OLD -- original method

    ; XXX OLD
    ld e,(ix+0x00) ; T19
    ld d,(ix+0x01) ; T19
    ex de,hl       ; T04
    ; XXX NEW
    ;ld l,(ix+0x00) ; T19
    ;ld h,(ix+0x01) ; T19

  else ; XXX NEW -- experimental

    ld hl,(user_variables_pointer)  ; T20 ; hl=address of s0
    ld a,(hl)                       ; T07
    inc hl                          ; T06
    ld h,(hl)                       ; T07
    ld l,a                          ; T04

  endif

  ld sp,hl
  _jp_next

rp_fetch_nfa:
  db 0x03+0x80,'RP','@'+0x80
rp_fetch_lfa:
  dw sp_store_nfa
rp_fetch_:
  dw rp_fetch_pfa
rp_fetch_pfa:
  ld hl,(return_stack_pointer)
  jp pushhl

rp_store_nfa:
  db 0x03+0x80,'RP','!'+0x80
rp_store_lfa:
  dw rp_fetch_nfa
rp_store_:
  dw rp_store_pfa
rp_store_pfa:

  if user_variables_pointer_in_ix? ; XXX OLD -- original method

    ; XXX OLD
    ld e,(ix+0x02)
    ld d,(ix+0x03)
    ex de,hl
    ; XXX NEW
    ;ld l,(ix+0x02)
    ;ld h,(ix+0x03)

  else ; XXX NEW -- experimental

    ld hl,(user_variables_pointer)
    inc hl
    inc hl ; hl=address of r0
    ld a,(hl)
    inc hl
    ld h,(hl)
    ld l,a

  endif

  ld (return_stack_pointer),hl

  _jp_next

semicolon_s_nfa:
  db 0x02+0x80,';','S'+0x80
semicolon_s_lfa:
  dw rp_store_nfa
semicolon_s_:
  dw semicolon_s_pfa
semicolon_s_pfa:
  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

pick_nfa:
  db 0x04+0x80,'PIC','K'+0x80
pick_lfa:
  dw semicolon_s_nfa
pick_:
  dw pick_pfa
pick_pfa:
  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

unloop_nfa:
  db 0x06+0x80,'UNLOO','P'+0x80
unloop_lfa:
  dw pick_nfa
unloop_:
  ; XXX TODO -- this works, but why? it should save the return address,
  ; the TORS.
  dw two_r_drop_pfa

leave_nfa:
  db 0x05+0x80,'LEAV','E'+0x80
leave_lfa:
  dw unloop_nfa
leave_:
  dw leave_pfa
leave_pfa:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

to_r_nfa:
  db 0x02+0x80,'>','R'+0x80
to_r_lfa:
  dw leave_nfa
to_r_:
  dw to_r_pfa
to_r_pfa:
  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

from_r_nfa:
  db 0x02+0x80,'R','>'+0x80
from_r_lfa:
  dw to_r_nfa
from_r_:
  dw from_r_pfa
from_r_pfa:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

two_r_drop_nfa:
  db 0x06+0x80,'2RDRO','P'+0x80
two_r_drop_lfa:
  dw from_r_nfa
two_r_drop_:
  dw two_r_drop_pfa
two_r_drop_pfa:
  ; XXX FIXME
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

r_drop_nfa:
  db 0x05+0x80,'RDRO','P'+0x80
r_drop_lfa:
  dw two_r_drop_nfa
r_drop_:
  dw two_r_drop_pfa
r_drop_pfa:
  ; XXX FIXME
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

r_fetch_nfa:
  db 0x02+0x80,'R','@'+0x80
r_fetch_lfa:
  dw r_drop_nfa
r_fetch_:
  dw r_fetch_pfa
r_fetch_pfa:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

zero_equals_nfa:
  db 0x02+0x80,'0','='+0x80
zero_equals_lfa:
  dw r_fetch_nfa
zero_equals_:
  dw zero_equals_pfa
zero_equals_pfa:
  pop hl
  ld a,l
  or h
  jp z,true_pfa
  jp false_pfa

zero_not_equals_nfa:
  db 0x03+0x80,'0<','>'+0x80
zero_not_equals_lfa:
  dw zero_equals_nfa
zero_not_equals_:
  dw zero_equals_pfa
zero_not_equals_pfa:
  pop hl
  ld a,l
  or h
  jp z,false_pfa
  jp true_pfa

zero_less_than_nfa:
  db 0x02+0x80,'0','<'+0x80
zero_less_than_lfa:
  dw zero_not_equals_nfa
zero_less_than_:
  dw zero_less_than_pfa
zero_less_than_pfa:
  pop hl
zero_less_.hl: ; XXX entry not used yet
  add hl,hl
true_if_cy:
  jp c,true_pfa
  jp false_pfa

plus_nfa:
  db 0x01+0x80,'','+'+0x80
plus_lfa:
  dw zero_less_than_nfa
plus_:
  dw plus_pfa
plus_pfa:
  pop de
  pop hl
  add hl,de
  jp pushhl

d_plus_nfa:
  db 0x02+0x80,'D','+'+0x80
d_plus_lfa:
  dw plus_nfa
d_plus_:
  dw d_plus_pfa
d_plus_pfa:
  ld hl,0x0006
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  adc hl,bc
  pop bc
  push de
  jp pushhl

negate_nfa:
  db 0x06+0x80,'NEGAT','E'+0x80
negate_lfa:
  dw d_plus_nfa
negate_:
  dw negate_pfa
negate_pfa:
  pop de
  ld hl,0x0000
  and a
  sbc hl,de
  jp pushhl

dnegate_nfa:
  db 0x07+0x80,'DNEGAT','E'+0x80
dnegate_lfa:
  dw negate_nfa
dnegate_:
  dw dnegate_pfa
dnegate_pfa:
  pop hl
  pop de
  sub a
  sub e
  ld e,a
  ld a,0x00
  sbc a,d
  ld d,a
  ld a,0x00
  sbc a,l
  ld l,a
  ld a,0x00
  sbc a,h
  ld h,a
  push de
  jp pushhl

nip_nfa:
  db 0x03+0x80,'NI','P'+0x80
nip_lfa:
  dw dnegate_nfa
nip_:
  dw nip_pfa
nip_pfa:
  pop hl
  pop de
  jp pushhl

tuck_nfa:
  db 0x04+0x80,'TUC','K'+0x80
tuck_lfa:
  dw nip_nfa
tuck_:
  dw tuck_pfa
tuck_pfa:
  pop hl
  pop de
  push hl
  jp pushde

over_nfa:
  db 0x04+0x80,'OVE','R'+0x80
over_lfa:
  dw tuck_nfa
over_:
  dw over_pfa
over_pfa:
  pop de
  pop hl
  push hl
  jp pushde

drop_nfa:
  db 0x04+0x80,'DRO','P'+0x80
drop_lfa:
  dw over_nfa
drop_:
  dw drop_pfa
drop_pfa:
  pop hl
  _jp_next

swap_nfa:
  db 0x04+0x80,'SWA','P'+0x80
swap_lfa:
  dw drop_nfa
swap_:
  dw swap_pfa
swap_pfa:
  pop hl
  ex (sp),hl
  jp pushhl

dup_nfa:
  db 0x03+0x80,'DU','P'+0x80
dup_lfa:
  dw swap_nfa
dup_:
  dw dup_pfa
dup_pfa:
  pop hl
  push hl
  jp pushhl

two_dup_nfa:
  db 0x04+0x80,'2DU','P'+0x80
two_dup_lfa:
  dw dup_nfa
two_dup_:
  dw two_dup_pfa
two_dup_pfa:
  pop hl
  pop de
  push de
  push hl
  jp pushde

plus_store_nfa:
  db 0x02+0x80,'+','!'+0x80
plus_store_lfa:
  dw two_dup_nfa
plus_store_:
  dw plus_store_pfa
plus_store_pfa:
  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

off_nfa:
  db 0x03+0x80,'OF','F'+0x80
off_lfa:
  dw plus_store_nfa
off_:
  dw off_pfa
off_pfa:
  pop hl
  ld (hl),false
  _jp_next

on_nfa:
  db 0x02+0x80,'O','N'+0x80
on_lfa:
  dw off_nfa
on_:
  dw on_pfa
on_pfa:
  pop hl
  ld (hl),true
  _jp_next

toggle_nfa:
  db 0x06+0x80,'TOGGL','E'+0x80
toggle_lfa:
  dw on_nfa
toggle_:
  dw toggle_pfa
toggle_pfa:
  pop de ; e = bit pattern
  pop hl ; address
  ld a,(hl)
  xor e
  ld (hl),a
  _jp_next

fetch_nfa:
  db 0x01+0x80,'','@'+0x80
fetch_lfa:
  dw toggle_nfa
fetch_:
  dw fetch_pfa
fetch_pfa:
  ; XXX TODO optimize? maybe `jp pushhl` can be used?
  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

c_fetch_nfa:
  db 0x02+0x80,'C','@'+0x80
c_fetch_lfa:
  dw fetch_nfa
c_fetch_:
  dw c_fetch_pfa
c_fetch_pfa:
  pop hl
  ld l,(hl)
  ld h,0x00
  jp pushhl

two_fetch_nfa:
  db 0x02+0x80,'2','@'+0x80
two_fetch_lfa:
  dw c_fetch_nfa
two_fetch_:
  dw two_fetch_pfa
two_fetch_pfa:
  pop hl ; address
  inc hl
  inc hl ; high part
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  dec hl
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  push de

  if 0 ; XXX TODO -- study this alternative from C/PM fig-Forth 1.1g

  EXX     ;/ SAVE IP
  POP HL    ;  (HL)<--ADDR
  LD  C,(HL)
  INC HL
  LD  B,(HL)    ;/ (BC)<--dH
  INC HL
  LD  E,(HL)
  INC HL
  LD  D,(HL)    ;  (DE)<--dL
  PUSH  DE    ;  (S2)<--dL
  PUSH  BC    ;/ (S1)<--dH
  EXX     ;/ RESTORE IP

  endif

  _jp_next

store_nfa:
  db 0x01+0x80,'','!'+0x80
store_lfa:
  dw two_fetch_nfa
store_:
  dw store_pfa
store_pfa:
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

c_store_nfa:
  db 0x02+0x80,'C','!'+0x80
c_store_lfa:
  dw store_nfa
c_store_:
  dw c_store_pfa
c_store_pfa:
  pop hl
  pop de
  ld (hl),e
  _jp_next

two_store_nfa:
  db 0x02+0x80,'2','!'+0x80
two_store_lfa:
  dw c_store_nfa
two_store_:
  dw two_store_pfa
two_store_pfa:
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

colon_nfa:
  db 0x01+0x80+precedence_bit_mask,'',':'+0x80
colon_lfa:
  dw two_store_nfa
colon_:
  dw do_colon
colon_pfa:
  dw question_exec_
  dw store_csp_
  dw current_,fetch_
  dw context_,store_
  dw create_
  dw right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
  _jp_next

semicolon_nfa:
  db 0x01+0x80+precedence_bit_mask,'',';'+0x80
semicolon_lfa:
  dw colon_nfa
semicolon_:
  dw do_colon
semicolon_pfa:
  dw question_csp_
  dw compile_,semicolon_s_
  dw smudge_
  dw left_bracket_
  dw semicolon_s_

noop_nfa:
  db 0x04+0x80,'NOO','P'+0x80
noop_lfa:
  dw semicolon_nfa
noop_:
  dw do_colon
noop_pfa:
  dw semicolon_s_

constant_nfa:
  db 0x08+0x80,'CONSTAN','T'+0x80
constant_lfa:
  dw noop_nfa
constant_:
  dw do_colon
constant_pfa:
  dw create_
  dw smudge_
  dw comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  ld e,(hl)
  inc hl
  ld d,(hl) ; de=value
  push de
  _jp_next

variable_nfa:
  db 0x08+0x80,'VARIABL','E'+0x80
variable_lfa:
  dw constant_nfa
variable_:
  dw do_colon
variable_pfa:
  dw constant_
  dw paren_semicolon_code_
do_variable:
  inc de  ; de=pfa
  push de
  _jp_next

user_nfa:
  db 0x04+0x80,'USE','R'+0x80
user_lfa:
  dw variable_nfa
user_:
  dw do_colon
user_pfa:
  ; XXX TODO -- Use only one byte for storage,
  ; but defining `cconstant` only for this does not seem a good idea.
  dw constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl    ; T04
  ld e,(hl)   ; T07
  ld d,0x00

  if user_variables_pointer_in_ix? ; XXX OLD -- original method

    push ix   ; T15 ; user variable pointer
    pop hl    ; T10

  else ; XXX NEW -- experimental

    ld hl,(user_variables_pointer)   ; T20
    ; XXX This is faster, but makes the access to the pointer non-standard:
;user_variables_pointer: equ $+1
;    ld hl,user_variables   ; T10

  endif

  add hl,de   ; hl= address of the user variable
  jp pushhl

; doc{
; msg-scr  ( -- n )  \  Constant: Screen where the error messages start.
; }doc

; Idea taken from lina ciforth.

msg_scr_nfa:
  db 0x07+0x80,'MSG-SC','R'+0x80
msg_scr_lfa:
  dw user_nfa
msg_scr_:
  dw do_constant
msg_scr_pfa:
  dw 0x0004

zero_nfa:
  db 0x01+0x80,'','0'+0x80
zero_lfa:
  dw msg_scr_nfa
zero_:
  dw do_constant
zero_pfa:
  dw 0x0000

one_nfa:
  db 0x01+0x80,'','1'+0x80
one_lfa:
  dw zero_nfa
one_:
  dw do_constant
one_pfa:
  dw 0x0001

two_nfa:
  db 0x01+0x80,'','2'+0x80
two_lfa:
  dw one_nfa
two_:
  dw do_constant
two_pfa:
  dw 0x0002

three_nfa:
  db 0x01+0x80,'','3'+0x80
three_lfa:
  dw two_nfa
three_:
  dw do_constant
three_pfa:
  dw 0x0003

false_nfa:
  db 0x05+0x80,'FALS','E'+0x80
false_lfa:
  dw three_nfa
false_:
  dw false_pfa
false_pfa:
  ld hl,false
  jp pushhl

true_nfa:
  db 0x04+0x80,'TRU','E'+0x80
true_lfa:
  dw false_nfa
true_:
  dw true_pfa
true_pfa:
  ld hl,true
  jp pushhl

b_l_nfa:
  db 0x02+0x80,'B','L'+0x80
b_l_lfa:
  dw true_nfa
b_l_:
  dw do_constant
b_l_pfa:
  dw 0x0020

c_slash_l_nfa:
  db 0x03+0x80,'C/','L'+0x80
c_slash_l_lfa:
  dw b_l_nfa
c_slash_l_:
  dw do_constant
c_slash_l_pfa:
  dw characters_per_line

first_nfa:
  db 0x05+0x80,'FIRS','T'+0x80
first_lfa:
  dw c_slash_l_nfa
first_:
  dw do_constant
first_pfa:
  dw first_buffer

limit_nfa:
  db 0x05+0x80,'LIMI','T'+0x80
limit_lfa:
  dw first_nfa
limit_:
  dw do_constant
limit_pfa:
  dw limit

b_slash_buf_nfa:
  db 0x05+0x80,'B/BU','F'+0x80
b_slash_buf_lfa:
  dw limit_nfa
b_slash_buf_:
  dw do_constant
b_slash_buf_pfa:
  dw data_bytes_per_buffer

b_slash_scr_nfa:
  db 0x05+0x80,'B/SC','R'+0x80
b_slash_scr_lfa:
  dw b_slash_buf_nfa
b_slash_scr_:
  dw do_constant
b_slash_scr_pfa:
  dw blocks_per_screen

plus_origin_nfa:
  db 0x07+0x80,'+ORIGI','N'+0x80
plus_origin_lfa:
  dw b_slash_scr_nfa
plus_origin_:
  dw do_colon
plus_origin_pfa:
  dw lit_,origin
  dw plus_
  dw semicolon_s_

s0_nfa:
  db 0x02+0x80,'S','0'+0x80
s0_lfa:
  dw plus_origin_nfa
s0_:
  dw do_user
s0_pfa:
  db 0x00

r0_nfa:
  db 0x02+0x80,'R','0'+0x80
r0_lfa:
  dw s0_nfa
r0_:
  dw do_user
r0_pfa:
  db 0x02

tib_nfa:
  db 0x03+0x80,'TI','B'+0x80
tib_lfa:
  dw r0_nfa
tib_:
  dw do_user
tib_pfa:
  db 0x04

width_nfa:
  db 0x05+0x80,'WIDT','H'+0x80
width_lfa:
  dw tib_nfa
width_:
  dw do_user
width_pfa:
  db 0x06

warning_nfa:
  db 0x07+0x80,'WARNIN','G'+0x80
warning_lfa:
  dw width_nfa
warning_:
  dw do_user
warning_pfa:
  db 0x08

fence_nfa:
  db 0x05+0x80,'FENC','E'+0x80
fence_lfa:
  dw warning_nfa
fence_:
  dw do_user
fence_pfa:
  db 0x0A

dp_nfa:
  db 0x02+0x80,'D','P'+0x80
dp_lfa:
  dw fence_nfa
dp_:
  dw do_user
dp_pfa:
  db 0x0C

voc_link_nfa:
  db 0x08+0x80,'VOC-LIN','K'+0x80
voc_link_lfa:
  dw dp_nfa
voc_link_:
  dw do_user
voc_link_pfa:
  db 0x0E

blk_nfa:
  db 0x03+0x80,'BL','K'+0x80
blk_lfa:
  dw voc_link_nfa
blk_:
  dw do_user
blk_pfa:
  db 0x10

in_nfa:
  db 0x02+0x80,'I','N'+0x80
in_lfa:
  dw blk_nfa
in_:
  dw do_user
in_pfa:
  db 0x12

out_nfa:
  db 0x03+0x80,'OU','T'+0x80
out_lfa:
  dw in_nfa
out_:
  dw do_user
out_pfa:
  db 0x14

scr_nfa:
  db 0x03+0x80,'SC','R'+0x80
scr_lfa:
  dw out_nfa
scr_:
  dw do_user
scr_pfa:
  db 0x16

context_nfa:
  db 0x07+0x80,'CONTEX','T'+0x80
context_lfa:
  dw scr_nfa
context_:
  dw do_user
context_pfa:
  db 0x1A

current_nfa:
  db 0x07+0x80,'CURREN','T'+0x80
current_lfa:
  dw context_nfa
current_:
  dw do_user
current_pfa:
  db 0x1C

state_nfa:
  db 0x05+0x80,'STAT','E'+0x80
state_lfa:
  dw current_nfa
state_:
  dw do_user
state_pfa:
  db 0x1E

base_nfa:
  db 0x04+0x80,'BAS','E'+0x80
base_lfa:
  dw state_nfa
base_:
  dw do_user
base_pfa:
  db 0x20

dpl_nfa:
  db 0x03+0x80,'DP','L'+0x80
dpl_lfa:
  dw base_nfa
dpl_:
  dw do_user
dpl_pfa:
  db 0x22

fld_nfa:
  db 0x03+0x80,'FL','D'+0x80
fld_lfa:
  dw dpl_nfa
fld_:
  dw do_user
fld_pfa:
  db 0x24

csp_nfa:
  db 0x03+0x80,'CS','P'+0x80
csp_lfa:
  dw fld_nfa
csp_:
  dw do_user
csp_pfa:
  db 0x26

r_hash_nfa:
  db 0x02+0x80,'R','#'+0x80
r_hash_lfa:
  dw csp_nfa
r_hash_:
  dw do_user
r_hash_pfa:
  db 0x28

hld_nfa:
  db 0x03+0x80,'HL','D'+0x80
hld_lfa:
  dw r_hash_nfa
hld_:
  dw do_user
hld_pfa:
  db 0x2A

recurse_nfa:
  db 0x07+0x80+precedence_bit_mask,'RECURS','E'+0x80
recurse_lfa:
  dw hld_nfa
recurse_:
  dw do_colon
recurse_pfa:
  dw latest_,nfa_to_cfa_,comma_
  dw semicolon_s_

one_plus_nfa:
  db 0x02+0x80,'1','+'+0x80
one_plus_lfa:
  dw recurse_nfa
one_plus_:
  dw one_plus_pfa
one_plus_pfa:
  pop hl
  inc hl
  jp pushhl

two_plus_nfa:
  db 0x02+0x80,'2','+'+0x80
two_plus_lfa:
  dw one_plus_nfa
two_plus_:
  dw two_plus_pfa
two_plus_pfa:
  pop hl
  inc hl
  inc hl
  jp pushhl

one_minus_nfa:
  db 0x02+0x80,'1','-'+0x80
one_minus_lfa:
  dw two_plus_nfa
one_minus_:
  dw one_minus_pfa
one_minus_pfa:
  pop hl
  dec hl
  jp pushhl

two_minus_nfa:
  db 0x02+0x80,'2','-'+0x80
two_minus_lfa:
  dw one_minus_nfa
two_minus_:
  dw two_minus_pfa
two_minus_pfa:
  pop hl
  dec hl
  dec hl
  jp pushhl

two_star_nfa:
  db 0x02+0x80,'2','*'+0x80
two_star_lfa:
  dw two_minus_nfa
two_star_:
  dw two_star_pfa
two_star_pfa:
  pop hl
  add hl,hl
  jp pushhl

here_nfa:
  db 0x04+0x80,'HER','E'+0x80
here_lfa:
  dw two_star_nfa
here_:
  dw do_colon
here_pfa:
  dw dp_,fetch_
  dw semicolon_s_

allot_nfa:
  db 0x05+0x80,'ALLO','T'+0x80
allot_lfa:
  dw here_nfa
allot_:
  dw do_colon
allot_pfa:
  dw dp_,plus_store_
  dw semicolon_s_

comma_nfa:
  db 0x01+0x80,'',','+0x80
comma_lfa:
  dw allot_nfa
comma_:
  dw do_colon
comma_pfa:
  dw here_,store_,two_,allot_
  dw semicolon_s_

c_comma_nfa:
  db 0x02+0x80,'C',','+0x80
c_comma_lfa:
  dw comma_nfa
c_comma_:
  dw do_colon
c_comma_pfa:
  dw here_,c_store_,one_,allot_
  dw semicolon_s_

minus_nfa:
  db 0x01+0x80,'','-'+0x80
minus_lfa:
  dw c_comma_nfa
minus_:
  dw minus_pfa
minus_pfa:
  pop de
  pop hl
  and a
  sbc hl,de
  jp pushhl

not_equals_nfa:
  db 0x02+0x80,'<','>'+0x80
not_equals_lfa:
  dw minus_nfa
not_equals_:
  dw not_equals_pfa
not_equals_pfa:
  pop de
  pop hl
  call compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_pfa
  jp true_pfa

equals_nfa:
  db 0x01+0x80,'','='+0x80
equals_lfa:
  dw not_equals_nfa
equals_:
  dw equals_pfa
equals_pfa:
  pop de
  pop hl
  call compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_pfa
  jp false_pfa

less_than_nfa:
  db 0x01+0x80,'','<'+0x80
less_than_lfa:
  dw equals_nfa
less_than_:
  dw less_than_pfa
less_than_pfa:
  pop de ; n2
  pop hl ; n1
  ld a,d
  xor h ; one of them negative?
  jp m,less_than.wich_negative ; if so, determine which
  ; no one is negative
  and a ; clear carry
  sbc hl,de

less_than.wich_negative:

  if 0 ; XXX OLD

  ; Original version from Abersoft Forth,
  ; badly optimized because of the two 'ld
  ; hl' and two `jp pushhl`.

  inc h
  dec h ; h negative?
  jp m,less_than.true
  ld hl,false
  jp pushhl
less_than.true:
  ld hl,true
  jp pushhl

  else ; XXX NEW

  ; Version from CP/M fig-Forth 1.1g,
  ; with additional improvement for speed:

  ; bit 7,h ; h negative?
  ; ld hl,false
  ; jp z,pushhl
  ; inc l ; true ; XXX TODO -- change to `dec hl` when true=-1
  ; jp pushhl

  ; Optimized for space:

  bit 7,h ; h negative?
  jp z,false_pfa
  jp true_pfa

  endif

u_less_than_nfa:
  db 0x02+0x80,'U','<'+0x80
u_less_than_lfa:
  dw less_than_nfa

if 1 ; XXX OLD -- original

u_less_than_:
  dw do_colon
u_less_than_pfa:
  dw two_dup_
  dw xor_
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6585
  dw drop_
  dw zero_less_than_
  dw zero_equals_
  dw branch_,branch_destination_0x6589
branch_destination_0x6585:
  dw minus_
  dw zero_less_than_
branch_destination_0x6589:
  dw semicolon_s_

else

  ; XXX NEW -- from DZX-Forth
  ; XXX FIXME

u_less_than_:
  dw u_less_than_pfa
u_less_than_pfa:
  pop de
  pop hl
u_less_than.de_hl:
  call compare_de_hl_unsigned
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

endif

greater_than_nfa:
  db 0x01+0x80,'','>'+0x80
greater_than_lfa:
  dw u_less_than_nfa
greater_than_:
  dw do_colon
greater_than_pfa:
  dw swap_
  dw less_than_
  dw semicolon_s_

; XXX TMP -- written in the blocks disk instead
; minus_rot_nfa:
;   db 0x04+0x80,'-RO','T'+0x80
; minus_rot_lfa:
;   dw greater_than_nfa
; minus_rot_:
;   dw minus_rot_pfa
; minus_rot_pfa:
;   pop hl
;   pop de
;   ex (sp),hl
;   ex de,hl
;   jp pushde

rot_nfa:
  db 0x03+0x80,'RO','T'+0x80
rot_lfa:
  ; dw minus_rot_nfa ; XXX TMP
  dw greater_than_nfa
rot_:
  dw rot_pfa
rot_pfa:
  pop de
  pop hl
  ex (sp),hl
  jp pushde

space_nfa:
  db 0x05+0x80,'SPAC','E'+0x80
space_lfa:
  dw rot_nfa
space_:
  dw do_colon
space_pfa:
  dw b_l_
  dw emit_
  dw semicolon_s_

question_dup_nfa:
  db 0x04+0x80,'?DU','P'+0x80
question_dup_lfa:
  dw space_nfa
question_dup_:
  dw do_colon
question_dup_pfa:
  dw dup_
  dw zero_branch_,question_dup.end
  dw dup_
question_dup.end:
  dw semicolon_s_

traverse_nfa:
  db 0x08+0x80,'TRAVERS','E'+0x80
traverse_lfa:
  dw question_dup_nfa
traverse_:
  dw do_colon
traverse_pfa:
  dw swap_
traverse.begin:
  dw over_,plus_
  dw c_lit_
  db 0x7F
  dw over_,c_fetch_,less_than_
  dw zero_branch_,traverse.begin ; until
  dw swap_,drop_
  dw semicolon_s_

latest_nfa:
  db 0x06+0x80,'LATES','T'+0x80
latest_lfa:
  dw traverse_nfa
latest_:
  dw do_colon
latest_pfa:
  dw current_,fetch_,fetch_
  dw semicolon_s_

pfa_to_lfa_nfa:
  db 0x07+0x80,'PFA>LF','A'+0x80
pfa_to_lfa_lfa:
  dw latest_nfa
pfa_to_lfa_:
  dw do_colon
pfa_to_lfa_pfa:
  dw c_lit_
  db 0x04
  dw minus_
  dw semicolon_s_

pfa_to_cfa_nfa:
  db 0x07+0x80,'PFA>CF','A'+0x80
pfa_to_cfa_lfa:
  dw pfa_to_lfa_nfa
pfa_to_cfa_:
  dw two_minus_pfa

cfa_to_pfa_nfa:
  db 0x07+0x80,'CFA>PF','A'+0x80
cfa_to_pfa_lfa:
  dw pfa_to_cfa_nfa
cfa_to_pfa_:
  dw two_plus_pfa

cfa_to_lfa_nfa:
  db 0x07+0x80,'CFA>LF','A'+0x80
cfa_to_lfa_lfa:
  dw cfa_to_pfa_nfa
cfa_to_lfa_:
  dw two_minus_pfa

pfa_to_nfa_nfa:
  db 0x07+0x80,'PFA>NF','A'+0x80
pfa_to_nfa_lfa:
  dw cfa_to_lfa_nfa
pfa_to_nfa_:
  dw do_colon
pfa_to_nfa_pfa:
  dw c_lit_
  db 0x05
  dw minus_
  dw lit_,-1,traverse_
  dw semicolon_s_

cfa_to_nfa_nfa:
  db 0x07+0x80,'CFA>NF','A'+0x80
cfa_to_nfa_lfa:
  dw pfa_to_nfa_nfa
cfa_to_nfa_:
  dw do_colon
cfa_to_nfa_pfa:
  dw three_,minus_
  dw lit_,-1,traverse_
  dw semicolon_s_

nfa_to_lfa_nfa:
  db 0x07+0x80,'NFA>LF','A'+0x80
nfa_to_lfa_lfa:
  dw cfa_to_nfa_nfa
nfa_to_lfa_:
  dw do_colon
nfa_to_lfa_pfa:
  dw one_,traverse_,one_plus_
  dw semicolon_s_

nfa_to_cfa_nfa:
  db 0x07+0x80,'NFA>CF','A'+0x80
nfa_to_cfa_lfa:
  dw nfa_to_lfa_nfa
nfa_to_cfa_:
  dw do_colon
nfa_to_cfa_pfa:
  dw nfa_to_lfa_,two_plus_
  dw semicolon_s_

nfa_to_pfa_nfa:
  db 0x07+0x80,'NFA>PF','A'+0x80
nfa_to_pfa_lfa:
  dw nfa_to_cfa_nfa
nfa_to_pfa_:
  dw do_colon
nfa_to_pfa_pfa:
  dw nfa_to_cfa_,two_plus_
  dw semicolon_s_

store_csp_nfa:
  db 0x04+0x80,'!CS','P'+0x80
store_csp_lfa:
  dw nfa_to_pfa_nfa
store_csp_:
  dw do_colon
store_csp_pfa:
  dw sp_fetch_,csp_,store_
  dw semicolon_s_

question_error_nfa:
  db 0x06+0x80,'?ERRO','R'+0x80
question_error_lfa:
  dw store_csp_nfa
question_error_:
  dw do_colon
question_error_pfa:
  ; XXX TODO optimize the memory usage with to exit points,
  ; instead of jumps; search for similar cases in the code
  dw swap_
  dw zero_branch_,question_error.no_error
  dw error_
  dw branch_,question_error.end
question_error.no_error:
  dw drop_
question_error.end:
  dw semicolon_s_

question_comp_nfa:
  db 0x05+0x80,'?COM','P'+0x80
question_comp_lfa:
  dw question_error_nfa
question_comp_:
  dw do_colon
question_comp_pfa:
  dw state_,fetch_,zero_equals_
  dw c_lit_
  db 0x11
  dw question_error_
  dw semicolon_s_

question_exec_nfa:
  db 0x05+0x80,'?EXE','C'+0x80
question_exec_lfa:
  dw question_comp_nfa
question_exec_:
  dw do_colon
question_exec_pfa:
  dw state_,fetch_
  dw c_lit_
  db 0x12
  dw question_error_
  dw semicolon_s_

question_pairs_nfa:
  db 0x06+0x80,'?PAIR','S'+0x80
question_pairs_lfa:
  dw question_exec_nfa
question_pairs_:
  dw do_colon
question_pairs_pfa:
  dw not_equals_
  dw c_lit_
  db 0x13
  dw question_error_
  dw semicolon_s_

question_csp_nfa:
  db 0x04+0x80,'?CS','P'+0x80
question_csp_lfa:
  dw question_pairs_nfa
question_csp_:
  dw do_colon
question_csp_pfa:
  dw sp_fetch_,csp_,fetch_,not_equals_
  dw c_lit_
  db 0x14
  dw question_error_
  dw semicolon_s_

question_loading_nfa:
  db 0x08+0x80,'?LOADIN','G'+0x80
question_loading_lfa:
  dw question_csp_nfa
question_loading_:
  dw do_colon
question_loading_pfa:
  dw blk_,fetch_,zero_equals_
  dw c_lit_
  db 0x16
  dw question_error_
  dw semicolon_s_

compile_nfa:
  db 0x07+0x80,'COMPIL','E'+0x80
compile_lfa:
  dw question_loading_nfa
compile_:
  dw do_colon
compile_pfa:
  dw question_comp_
  dw from_r_,dup_,two_plus_,to_r_,fetch_,comma_
  dw semicolon_s_

left_bracket_nfa:
  db 0x01+0x80+precedence_bit_mask,'','['+0x80
left_bracket_lfa:
  dw compile_nfa
left_bracket_:
  dw do_colon
left_bracket_pfa:
  dw state_,off_
  dw semicolon_s_

right_bracket_nfa:
  db 0x01+0x80,'',']'+0x80
right_bracket_lfa:
  dw left_bracket_nfa
right_bracket_:
  dw do_colon
right_bracket_pfa:

  ; Note: Setting `state` to 0xC0 for "compiling state" will force
  ; non-immediate words to be compiled and immediate words to be executed. See
  ; note in `interpret` for more details.

  dw c_lit_
  db 0xC0
  dw state_,store_
  dw semicolon_s_

smudge_nfa:
  db 0x06+0x80,'SMUDG','E'+0x80
smudge_lfa:
  dw right_bracket_nfa
smudge_:
  dw do_colon
smudge_pfa:
  dw latest_
  dw c_lit_
  db smudge_bit_mask
  dw toggle_
  dw semicolon_s_

hex_nfa:
  db 0x03+0x80,'HE','X'+0x80
hex_lfa:
  dw smudge_nfa
hex_:
  dw do_colon
hex_pfa:
  dw c_lit_
  db 0x10
  dw base_,store_
  dw semicolon_s_

decimal_nfa:
  db 0x07+0x80,'DECIMA','L'+0x80
decimal_lfa:
  dw hex_nfa
decimal_:
  dw do_colon
decimal_pfa:
  dw c_lit_
  db 0x0A
  dw base_,store_
  dw semicolon_s_

paren_semicolon_code_nfa:
  db 0x07+0x80,'(;CODE',')'+0x80
paren_semicolon_code_lfa:
  dw decimal_nfa
paren_semicolon_code_:
  dw do_colon
paren_semicolon_code_pfa:
  dw from_r_,latest_,nfa_to_cfa_,store_
  dw semicolon_s_

semicolon_code_nfa:
  db 0x05+0x80+precedence_bit_mask,';COD','E'+0x80
semicolon_code_lfa:
  dw paren_semicolon_code_nfa
semicolon_code_:
  dw do_colon
semicolon_code_pfa:
  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw left_bracket_,smudge_
  dw semicolon_s_

builds_nfa:
  db 0x07+0x80,'<BUILD','S'+0x80
builds_lfa:
  dw semicolon_code_nfa
builds_:
  dw do_colon
builds_pfa:
  dw zero_,constant_
  dw semicolon_s_

does_nfa:
  db 0x05+0x80,'DOES','>'+0x80
does_lfa:
  dw builds_nfa
does_:
  dw do_colon
does_pfa:
  dw from_r_
  dw latest_
  dw nfa_to_pfa_
  dw store_
  dw paren_semicolon_code_
do_does:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  inc de      ; de=pfa
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  jp pushhl

count_nfa:
  db 0x05+0x80,'COUN','T'+0x80
count_lfa:
  dw does_nfa
count_:
  dw do_colon
count_pfa:
  ; XXX TODO -- rewrite in Z80
  dw dup_,one_plus_,swap_,c_fetch_
  dw semicolon_s_

bounds_nfa:
  db 0x06+0x80,'BOUND','S'+0x80
bounds_lfa:
  dw count_nfa
bounds_:
  dw do_colon
bounds_pfa:
  dw over_,plus_,swap_
  dw semicolon_s_

type_nfa:
  db 0x04+0x80,'TYP','E'+0x80
type_lfa:
  dw bounds_nfa
type_:
  dw do_colon
type_pfa:
  dw question_dup_
  dw zero_branch_,type.empty_string
  dw bounds_
  dw paren_do_
type.do:
  dw i_,c_fetch_,emit_
  dw paren_loop_,type.do ; loop
  dw branch_,type.end
type.empty_string:
  dw drop_
type.end:
  dw semicolon_s_

minus_trailing_nfa:
  db 0x09+0x80,'-TRAILIN','G'+0x80
minus_trailing_lfa:
  dw type_nfa
minus_trailing_:
  dw do_colon
minus_trailing_pfa:
  dw dup_,zero_
  dw paren_do_
minus_trailing.do:
  dw two_dup_,plus_
  dw one_minus_
  dw c_fetch_,b_l_,not_equals_
  dw zero_branch_,minus_trailing.space
  ; not a space
  dw leave_
  dw branch_,minus_trailing.loop
minus_trailing.space:
  dw one_minus_
minus_trailing.loop:
  dw paren_loop_,minus_trailing.do
  dw semicolon_s_

paren_dot_quote_nfa:
  db 0x04+0x80,'(."',')'+0x80
paren_dot_quote_lfa:
  dw minus_trailing_nfa
paren_dot_quote_:
  dw do_colon
paren_dot_quote_pfa:
  dw r_fetch_,count_,dup_,one_plus_
  dw from_r_,plus_,to_r_
  dw type_
  dw semicolon_s_

dot_quote_nfa:
  db 0x02+0x80+precedence_bit_mask,'.','"'+0x80
dot_quote_lfa:
  dw paren_dot_quote_nfa
dot_quote_:
  dw do_colon
dot_quote_pfa:
  dw c_lit_
  db '"'
  dw state_,fetch_ ; compiling?
  dw zero_branch_,dot_quote.interpreting
  ; compiling
  dw compile_,paren_dot_quote_
  dw word_,here_,c_fetch_,one_plus_,allot_
  dw semicolon_s_
dot_quote.interpreting:
  dw word_,here_,count_,type_
dot_quote.end:
  dw semicolon_s_

expect_nfa:
  db 0x06+0x80,'EXPEC','T'+0x80
expect_lfa:
  dw dot_quote_nfa
expect_:
  dw do_colon
expect_pfa:
  ;dw lit_,0,border_ ; XXX INFORMER
  dw over_
  dw plus_
  dw over_
  dw paren_do_
expect.do:
  dw key_,dup_
  dw c_lit_
  db delete_char
  dw equals_
  dw zero_branch_,expect.not_the_delete_key ; if

  ; XXX FIXME This word has a bug in Abersoft Forth.  Sometimes, after using
  ; the delete key, the typed word is not recognized.  Maybe the `noop` the
  ; author used to patch the original bell?

  ; Delete key
  ;dw lit_,1,border_ ; XXX INFORMER
  dw drop_
  dw dup_
  dw i_,equals_
  dw dup_
  dw from_r_,two_minus_,plus_,to_r_
  dw zero_branch_,expect.backspace ; if
  ; XXX OLD -- bell was here
  dw noop_
  dw noop_
  dw branch_,expect.loop ; else

expect.backspace:
  dw c_lit_
  db backspace_char
  dw branch_,expect.emit

expect.not_the_delete_key:
  dw dup_
  dw c_lit_
  db carriage_return_char
  dw equals_ ; carriage return?
  dw zero_branch_,expect.ordinary_key
  ; carriage return
  ;dw lit_,2,border_ ; XXX INFORMER
  dw leave_
  dw drop_,b_l_,zero_
  dw branch_,expect.store

expect.ordinary_key:
  dw dup_

expect.store:
  dw i_,c_store_
  dw i_,one_plus_,off_

expect.emit:
  dw emit_

expect.loop:
  dw paren_loop_,expect.do
  dw drop_
  ;dw lit_,7,border_ ; XXX INFORMER
  dw semicolon_s_

query_nfa:
  db 0x05+0x80,'QUER','Y'+0x80
query_lfa:
  dw expect_nfa
query_:
  dw do_colon
query_pfa:
  dw tib_,fetch_
  dw c_lit_
  db bytes_per_terminal_input_buffer
  dw expect_
  dw in_,off_
  dw semicolon_s_

; doc{

; x  ( -- )

; This is pseudonym for the "null" or
; dictionary entry for a name of one
; character of ascii null. It is the
; execution proceedure to terminate
; interpretation of a line of text from the
; terminal or within a disk buffer, as both
; buffers always have a null at the end.

; }doc

x_nfa:
  db 0x01+0x80+precedence_bit_mask,'',0x80
x_lfa:
  dw query_nfa
x_:
  dw do_colon
x_pfa:
  dw blk_,fetch_ ; input stream from disk?
  dw zero_branch_,x.from_terminal
  ; From disk.
  dw one_,blk_,plus_store_ ; next disk buffer
  dw in_,off_ ; clear `in`, preparing parsing of input text
  dw blk_,fetch_,b_slash_scr_,one_minus_,and_,zero_equals_ ; last buffer?
  dw zero_branch_,x.end
  ; The last buffer, the end of the text block.
  dw question_exec_ ; error if not executing
  ; Discard the address of `?stack` after `execute` in the interpretation loop.
  ; XXX FIXME why `rdrop` bombs out here?
  dw from_r_,drop_
  dw branch_,x.end
x.from_terminal:
  ; XXX FIXME why `rdrop` bombs out here?
  dw from_r_,drop_

  ; The top item on the return stack was
  ; thrown away.  At the end of 'x', the
  ; interpreter will not continue to execute
  ; the `?stack` instruction, but will return
  ; to the next higher level of nesting and
  ; execute the next word after `interpret` in
  ; the Forth loop.  This is when the familiar
  ; "ok" message is displayed on the terminal,
  ; prompting the operator for the next  line
  ; of commands.

x.end:
  dw semicolon_s_

fill_nfa:
  db 0x04+0x80,'FIL','L'+0x80
fill_lfa:
  dw x_nfa
fill_:
  dw fill_pfa
fill_pfa:
  pop de ; e = char
fill.e:
  ld l,c
  ld h,b ; the Forth IP
  pop bc ; bc = count
  ex (sp),hl ; save the Forth IP
fill.do
  ld a,b
  or c
  jp z,fill.end
  ld (hl),e
  inc hl
  dec bc
  jp fill.do
fill.end:
  pop bc ; restore the Forth IP
  _jp_next

erase_nfa:
  db 0x05+0x80,'ERAS','E'+0x80
erase_lfa:
  dw fill_nfa
erase_:
  dw erase_pfa
erase_pfa:
  ld e,0
  jp fill.e

blanks_nfa:
  db 0x06+0x80,'BLANK','S'+0x80
blanks_lfa:
  dw erase_nfa
blanks_:
  dw blanks_pfa
blanks_pfa:
  ld e,' '
  jp fill.e

hold_nfa:
  db 0x04+0x80,'HOL','D'+0x80
hold_lfa:
  dw blanks_nfa
hold_:
  dw do_colon
hold_pfa:
  dw lit_,0xFFFF,hld_,plus_store_
  dw hld_,fetch_,c_store_
  dw semicolon_s_

pad_nfa:
  db 0x03+0x80,'PA','D'+0x80
pad_lfa:
  dw hold_nfa
pad_:
  dw do_colon
pad_pfa:
  dw here_
  dw c_lit_
  db 0x44
  dw plus_
  dw semicolon_s_

word_nfa:
  db 0x04+0x80,'WOR','D'+0x80
word_lfa:
  dw pad_nfa
word_:
  dw do_colon
word_pfa:
  dw blk_,fetch_ ; from disk?
  ; XXX TODO optimize with `?dup` here instead of repeating `blk @` later
  dw zero_branch_,word.from_terminal
  ; from disk
  dw blk_,fetch_,block_
  dw branch_,word.from_address
word.from_terminal:
  dw tib_,fetch_
word.from_address:
  dw in_,fetch_,plus_,swap_,enclose_

  dw here_
  dw c_lit_
  db 0x22
  dw blanks_ ; XXX original
  dw in_,plus_store_
  dw over_,minus_
  ;dw dup_,dot_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  dw to_r_ ; length
  dw r_fetch_,here_,c_store_ ; set the length byte
  dw plus_ ; from
  dw here_,one_plus_ ; destination
  dw from_r_ ; count
  dw cmove_ ; move
  ; XXX FIXME blank 1-char strings are parsed from empty screens!
  ; they are converted to 0 by `number` and the stack gets full!
  ;dw lit_,'{',emit_,here_,count_,type_,lit_,'}',emit_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  dw semicolon_s_

paren_number_nfa:
  db 0x08+0x80,'(NUMBER',')'+0x80
paren_number_lfa:
  dw word_nfa
paren_number_:
  dw do_colon
paren_number_pfa:
paren_number.begin: ; begin
  dw one_plus_ ; address of the next digit
  dw dup_,to_r_ ; save the address
  dw c_fetch_ ; get the digit
  dw base_,fetch_,digit_ ; convert the digit
  dw zero_branch_,paren_number.end ; while
  dw swap_ ; get the high order part of d1 to the top.
  dw base_,fetch_,u_star_ ; multiply by base value
  dw drop_ ; drop the high order part of the product
  dw rot_ ; move the low order part of d1 to top of stack
  dw base_,fetch_,u_star_ ; multiply by base value
  dw d_plus_ ; accumulate result into d1
  dw dpl_,fetch_,one_plus_ ; is DPL other than -1?
  dw zero_branch_,paren_number.decimal_point_done
  ; DPL is not -1, a decimal point was encountered
  dw one_,dpl_,plus_store_ ; increment DPL, one more digit to right of decimal point
paren_number.decimal_point_done
  dw from_r_ ; pop addr1+1 back to convert the next digit
  dw branch_,paren_number.begin ; repeat
paren_number.end:
  dw from_r_ ; address of the first non-convertable digit, a2.
  dw semicolon_s_

number_nfa:
  db 0x06+0x80,'NUMBE','R'+0x80
number_lfa:
  dw paren_number_nfa
number_:
  dw do_colon
number_pfa:
  dw zero_,zero_,rot_ ; two zeros, initial value of the double number
  dw dup_,one_plus_,c_fetch_ ; get the first digit
  dw c_lit_
  db '-'
  dw equals_ ; is it a minus sign?
  dw dup_,to_r_ ; save the flag
  ; XXX TODO add `abs` here when `true` is changed to `-1`
  dw plus_
  ; If the first digit is "-", the flag is 1,
  ; and addr+1 points to the second digit.
  ; If the first digit is not "-", the flag is
  ; 0.  addr+0 remains the same, pointing to
  ; the first digit.
  dw lit_,-1 ; initial value of `dpl`
number.begin:
  dw dpl_,store_
  dw paren_number_ ; convert one digit after another until an invalid char occurs
  dw dup_,c_fetch_ ; get the invalid digit
  dw b_l_,not_equals_ ; not a blank?
  dw zero_branch_,number.not_a_blank
  ; The invalid digit is not a blank.
  dw dup_,c_fetch_ ; get the invalid digit again
  dw c_lit_
  db '.'
  dw not_equals_ ; not a decimal point?
  dw one_,question_error_ ; error if not
  ; Decimal point found, set `dpl` to zero next time.
  dw zero_
  dw branch_,number.begin ; repeat
number.not_a_blank:
  dw drop_ ; discard address
  dw from_r_ ; pop the flag of "-" sign back
  dw zero_branch_,number.end
  ; Negate the number if the first digit is a "-" sign.
  dw dnegate_
number.end:
  dw semicolon_s_

upperc_nfa:
  db 0x06+0x80,'UPPER','C'+0x80
upperc_lfa:
  dw number_nfa
upperc_:
  dw upperc_pfa
upperc_pfa:
  pop hl
  ld a,l
  call upperc.a
  ld l,a
  jp pushhl

upperc.a:
  ; Convert the char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

uppers_nfa:
  db 0x06+0x80,'UPPER','S'+0x80
uppers_lfa:
  dw upperc_nfa
uppers_:
  dw uppers_pfa
uppers_pfa:
  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upperc.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

minus_find_nfa:
  db 0x05+0x80,'-FIN','D'+0x80
minus_find_lfa:
  dw uppers_nfa
minus_find_:
  dw do_colon
minus_find_pfa:
  dw b_l_,word_
  dw here_,count_,uppers_
  dw here_,context_,fetch_,fetch_,paren_find_
  dw dup_,zero_equals_ ; found?
  dw zero_branch_,minus_find.end
  ; The word was not found in the context vocabulary,
  ; try again in the current vocabulary.
  ; XXX TODO -- remove this?
  dw drop_,here_,latest_,paren_find_
minus_find.end:
  dw semicolon_s_

paren_abort_nfa:
  db 0x07+0x80,'(ABORT',')'+0x80
paren_abort_lfa:
  dw minus_find_nfa
paren_abort_:
  dw do_colon
paren_abort_pfa:
  dw abort_
  dw semicolon_s_

error_nfa:
  db 0x05+0x80,'ERRO','R'+0x80
error_lfa:
  dw paren_abort_nfa
error_:
  dw do_colon
error_pfa:
  dw warning_,fetch_,zero_less_than_
  ; XXX TODO optimize: jump directly to parent_abort_
  dw zero_branch_,branch_destination_0x6B0B
  dw paren_abort_
branch_destination_0x6B0B:
  dw here_,count_,type_
  dw paren_dot_quote_
  _string '? '
  dw message_
  dw sp_store_
  dw blk_,fetch_,question_dup_
  dw zero_branch_,branch_destination_0x6B2A
  dw in_,fetch_,swap_
branch_destination_0x6B2A:
  dw quit_

id_dot_nfa:
  db 0x03+0x80,'ID','.'+0x80
id_dot_lfa:
  dw error_nfa
id_dot_:
  dw do_colon
id_dot_pfa:
  dw pad_
  dw c_lit_
  db 0x20
  dw c_lit_
  db 0x5F ; XXX why this char?
  dw fill_
  dw dup_
  dw nfa_to_lfa_
  dw over_
  dw minus_
  dw pad_
  dw swap_
  dw cmove_
  dw pad_
  dw count_
  dw c_lit_
  db 0x1F ; max word length
  dw and_
  dw two_dup_
  dw plus_
  dw one_minus_
  dw dup_
  dw fetch_
  dw lit_,0xFF7F
  dw and_
  dw swap_
  dw store_
  dw type_
  dw space_
  dw semicolon_s_

create_nfa:
  db 0x06+0x80,'CREAT','E'+0x80
create_lfa:
  dw id_dot_nfa
create_:
  dw do_colon
create_pfa:
  dw minus_find_
  dw zero_branch_,create.continue
  ; The word is not unique.
  dw drop_,pfa_to_nfa_,id_dot_
  dw c_lit_
  db 0x04
  dw message_,space_
create.continue:
  dw here_
  dw dup_,c_fetch_,width_,fetch_,min_
  dw one_plus_,allot_
  dw dup_
  dw c_lit_
  db 0xA0 ; XXX TODO document
  dw toggle_
  dw here_,one_,minus_
  dw c_lit_
  db 0x80 ; XXX TODO document
  dw toggle_
  dw latest_,comma_
  dw current_,fetch_,store_
  dw here_,two_plus_,comma_
  dw semicolon_s_

bracket_compile_nfa:
  db 0x09+0x80+precedence_bit_mask,'[COMPILE',']'+0x80
bracket_compile_lfa:
  dw create_nfa
bracket_compile_:
  dw do_colon
bracket_compile_pfa:
  dw minus_find_,zero_equals_
  dw one_,question_error_
  dw drop_,pfa_to_cfa_,comma_
  dw semicolon_s_

c_literal_nfa:
  db 0x08+0x80+precedence_bit_mask,'CLITERA','L'+0x80
c_literal_lfa:
  dw bracket_compile_nfa
c_literal_:
  dw do_colon
c_literal_pfa:
  if 1 ; XXX OLD
    dw state_,fetch_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw compile_,c_lit_,comma_
  endif
  dw semicolon_s_

literal_nfa:
  db 0x07+0x80+precedence_bit_mask,'LITERA','L'+0x80
literal_lfa:
  dw c_literal_nfa
literal_:
  dw do_colon
literal_pfa:
  if 1 ; XXX OLD
    dw state_,fetch_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw compile_,lit_,comma_
  endif
  dw semicolon_s_

two_literal_nfa:
  db 0x08+0x80+precedence_bit_mask,'2LITERA','L'+0x80
two_literal_lfa:
  dw literal_nfa
two_literal_:
  dw do_colon
two_literal_pfa:
  if 1 ; XXX OLD
    dw state_,fetch_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    ; XXX TODO -- dlit
    ; XXX FIXME -- `interpret` needs the old method of `literal`
    dw question_comp_
    dw swap_,literal_,literal_
  endif
  dw semicolon_s_

depth_nfa:
  db 0x05+0x80,'DEPT','H'+0x80
depth_lfa:
  dw two_literal_nfa
depth_:
  dw do_colon
depth_pfa:
  dw sp_fetch_,s0_,fetch_,minus_,lit_,-2,slash_
  dw semicolon_s_

question_stack_nfa:
  db 0x06+0x80,'?STAC','K'+0x80
question_stack_lfa:
  dw depth_nfa
question_stack_:
  dw do_colon
question_stack_pfa:
  dw sp_fetch_
  dw s0_,fetch_
  dw swap_,less_than_
  dw two_,question_error_
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  dw c_lit_
  db 0x07
  dw question_error_
  dw semicolon_s_

; XXX TODO -- In order to change the behaviour of `literal`, `2literal`
; and `cliteral` (make them give an error in interpretation mode),
; `interpret` must be modified.

interpret_nfa:
  db 0x09+0x80,'INTERPRE','T'+0x80
interpret_lfa:
  dw question_stack_nfa
interpret_:
  dw do_colon
interpret_pfa:
interpret.begin:
  dw minus_find_ ; found?
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  dw zero_branch_,interpret.word_not_found ; if

  ; Note: `state` holds 0xC0 when compiling.  The text interpreter compares the
  ; value stored in `state` with the value in the length byte of the definition
  ; found in the dictionary.  If the definition is an immediate word, its
  ; length byte is greater than 0xC0 because of the precedence and the sign
  ; bits are both set.  Setting `state` to 0xC0 will force non-immediate words
  ; to be compiled and immediate words to be executed, thus entering into the
  ; "compiling state".

  dw state_,fetch_,less_than_ ; compile the word?
  dw zero_branch_,interpret.execute_the_word ; if
  dw pfa_to_cfa_,comma_ ; compile the word
  dw branch_,interpret.word_done
interpret.execute_the_word: ; else
  dw pfa_to_cfa_
  dw execute_
interpret.word_done: ; then
  dw question_stack_
  dw branch_,interpret.again
interpret.word_not_found: ; else
  ; word not found, try to convert the text to a number
  ; XXX FIXME the flow gets here for every space of an empty screen!
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw here_,number_
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number ; if
  ; decimal point detected, so it's a double, 32-bit, number
  dw two_literal_
  dw branch_,interpret.number_done
interpret.16bit_number: ; else
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
interpret.number_done: ; then
  ; XXX FIXME an empty screen causes numbers to
  ; be pushed on the stack! see `word`
  ;dw lit_,4,border_ ; XXX INFORMER
  dw question_stack_
  ;dw depth_,dot_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER

interpret.again:
  dw branch_,interpret.begin

immediate_nfa:
  db 0x09+0x80,'IMMEDIAT','E'+0x80
immediate_lfa:
  dw interpret_nfa
immediate_:
  dw do_colon
immediate_pfa:
  dw latest_
  dw c_lit_
  db precedence_bit_mask
  dw toggle_
  dw semicolon_s_

vocabulary_nfa:
  db 0x0A+0x80,'VOCABULAR','Y'+0x80
vocabulary_lfa:
  dw immediate_nfa
vocabulary_:
  dw do_colon
vocabulary_pfa:
  dw builds_
  dw lit_,0xA081 ; Dummy name field.
  dw comma_
  dw current_,fetch_,pfa_to_cfa_
  dw comma_
  dw here_
  dw voc_link_,fetch_
  dw comma_
  dw voc_link_,store_
  dw does_
do_vocabulary:
  dw two_plus_
  dw context_
  dw store_
  dw semicolon_s_

forth_nfa:
  db 0x05+0x80,'FORT','H'+0x80
forth_lfa:
  dw vocabulary_nfa
forth_:
  dw do_does
forth_pfa:
  dw do_vocabulary
forth_vocabulary_dummy_nfa:
  dw 0xA081 ; Dummy name field.
forth_vocabulary_latest:
  dw nfa_of_top_most_word_in_forth_voc
forth_vocabulary_link:
  dw 0x0000

definitions_nfa:
  db 0x0B+0x80,'DEFINITION','S'+0x80
definitions_lfa:
  dw forth_nfa
definitions_:
  dw do_colon
definitions_pfa:
  dw context_,fetch_
  dw current_,store_
  dw semicolon_s_

paren_nfa:
  db 0x01+0x80+precedence_bit_mask,'','('+0x80
paren_lfa:
  dw definitions_nfa
paren_:
  dw do_colon
paren_pfa:
  dw c_lit_
  db ')'
  dw word_
  dw semicolon_s_

quit_nfa:
  db 0x04+0x80,'QUI','T'+0x80
quit_lfa:
  dw paren_nfa
quit_:
  dw do_colon
quit_pfa:
  dw blk_,off_
  dw left_bracket_
quit.do:
  dw rp_store_
  dw cr_,query_,interpret_
  dw state_,fetch_
  dw question_branch_,quit.do
  dw paren_dot_quote_
  _string 'ok'
  dw branch_,quit.do

greeting_nfa:
  db 0x08+0x80,'GREETIN','G'+0x80
greeting_lfa:
  dw quit_nfa
greeting_:
  dw do_colon
greeting_pfa:
  dw paren_dot_quote_
  _string "Solo Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  dw semicolon_s_

abort_nfa:
  db 0x05+0x80,'ABOR','T'+0x80
abort_lfa:
  dw greeting_nfa
abort_:
  dw do_colon
abort_pfa:
  dw sp_store_
  dw decimal_
  dw question_stack_
  dw page_,greeting_ ; XXX TODO use cls0 instead
  dw forth_,definitions_
boot:
  dw noop_ ; patched by `turnkey`
  ;dw one_,two_,equals_,dot_,dot_,cr_ ; XXX INFORMER
  dw quit_

boot_nfa:
  db 0x04+0x80,'BOO','T'+0x80
boot_lfa:
  dw abort_nfa
boot_:
  dw do_constant
boot_pfa:
  dw boot

common_start:
  ; Common operations done by warm_start and cold_start.
  pop bc ; get the return address, that holds the cfa of `cold` or `warm`
  xor a
  ld (iy+sys_df_sz_offset),a ; no lines at the bottom part of the screen
  if user_variables_pointer_in_ix?
    ld ix,(user_variables_pointer)
  else
    ld ix,next
  endif
  ld sp,(s0_init_value)
  _jp_next

warm_start:
  call common_start
warm_start_phony_:
  dw warm_

warm_nfa:
  db 0x04+0x80,'WAR','M'+0x80
warm_lfa:
  dw boot_nfa
warm_:
  dw do_colon
warm_pfa:
  dw empty_buffers_
  dw abort_

cold_start:
  call common_start
cold_start_phony_:
  dw cold_

cold_nfa:
  db 0x04+0x80,'COL','D'+0x80
cold_lfa:
  dw warm_nfa
cold_:
  dw do_colon
cold_pfa:
  dw empty_buffers_
  dw first_,dup_,use_,store_,prev_,store_
  dw dr0_ ; XXX TODO -- change
  dw lit_,default_user_variables_start ; from
  dw lit_,user_variables_pointer,fetch_ ; to
  dw c_lit_
  db default_user_variables_end-default_user_variables_start ; length
  dw cmove_
  dw lit_,top_most_word_in_forth_voc,fetch_
  dw lit_,forth_vocabulary_latest,store_
  dw abort_

s_to_d_nfa:
  db 0x03+0x80,'S>','D'+0x80
s_to_d_lfa:
  dw cold_nfa
s_to_d_:
  dw s_to_d_pfa
s_to_d_pfa:
  pop de
  ld hl,0x0000
  ld a,d
  and 0x80
  jr z,l6e1dh
  dec hl
l6e1dh:
  jp pushde

plus_minus_nfa:
  db 0x02+0x80,'+','-'+0x80
plus_minus_lfa:
  dw s_to_d_nfa
plus_minus_:
  dw do_colon
plus_minus_pfa:
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6E2F
  dw negate_
branch_destination_0x6E2F:
  dw semicolon_s_

d_plus_minus_nfa:
  db 0x03+0x80,'D+','-'+0x80
d_plus_minus_lfa:
  dw plus_minus_nfa
d_plus_minus_:
  dw do_colon
d_plus_minus_pfa:
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x6E41
  dw dnegate_
branch_destination_0x6E41:
  dw semicolon_s_

abs_nfa:
  db 0x03+0x80,'AB','S'+0x80
abs_lfa:
  dw d_plus_minus_nfa
abs_:
  dw do_colon
abs_pfa:
  dw dup_
  dw plus_minus_
  dw semicolon_s_

dabs_nfa:
  db 0x04+0x80,'DAB','S'+0x80
dabs_lfa:
  dw abs_nfa
dabs_:
  dw do_colon
dabs_pfa:
  dw dup_
  dw d_plus_minus_
  dw semicolon_s_

min_nfa:
  db 0x03+0x80,'MI','N'+0x80
min_lfa:
  dw dabs_nfa
min_:
  dw do_colon
min_pfa:
  dw two_dup_
  dw greater_than_
  dw zero_branch_,branch_destination_0x6E72
  dw swap_
branch_destination_0x6E72:
  dw drop_
  dw semicolon_s_

max_nfa:
  db 0x03+0x80,'MA','X'+0x80
max_lfa:
  dw min_nfa
max_:
  dw do_colon
max_pfa:
  dw two_dup_
  dw less_than_
  dw zero_branch_,branch_destination_0x6E88
  dw swap_
branch_destination_0x6E88:
  dw drop_
  dw semicolon_s_

m_star_nfa:
  db 0x02+0x80,'M','*'+0x80
m_star_lfa:
  dw max_nfa
m_star_:
  dw do_colon
m_star_pfa:
  dw two_dup_
  dw xor_
  dw to_r_
  dw abs_
  dw swap_
  dw abs_
  dw u_star_
  dw from_r_
  dw d_plus_minus_
  dw semicolon_s_

m_slash_nfa:
  db 0x02+0x80,'M','/'+0x80
m_slash_lfa:
  dw m_star_nfa
m_slash_:
  dw do_colon
m_slash_pfa:
  dw over_
  dw to_r_
  dw to_r_
  dw dabs_
  dw r_fetch_
  dw abs_
  dw u_slash_mod_
  dw from_r_
  dw r_fetch_
  dw xor_
  dw plus_minus_
  dw swap_
  dw from_r_
  dw plus_minus_
  dw swap_
  dw semicolon_s_

star_nfa:
  db 0x01+0x80,'','*'+0x80
star_lfa:
  dw m_slash_nfa
star_:
  dw do_colon
star_pfa:
  dw m_star_
  dw drop_
  dw semicolon_s_

slash_mod_nfa:
  db 0x04+0x80,'/MO','D'+0x80
slash_mod_lfa:
  dw star_nfa
slash_mod_:
  dw do_colon
slash_mod_pfa:
  dw to_r_
  dw s_to_d_
  dw from_r_
  dw m_slash_
  dw semicolon_s_

slash_nfa:
  db 0x01+0x80,'','/'+0x80
slash_lfa:
  dw slash_mod_nfa
slash_:
  dw do_colon
slash_pfa:
  dw slash_mod_
  dw swap_
  dw drop_
  dw semicolon_s_

mod_nfa:
  db 0x03+0x80,'MO','D'+0x80
mod_lfa:
  dw slash_nfa
mod_:
  dw do_colon
mod_pfa:
  dw slash_mod_
  dw drop_
  dw semicolon_s_

star_slash_mod_nfa:
  db 0x05+0x80,'*/MO','D'+0x80
star_slash_mod_lfa:
  dw mod_nfa
star_slash_mod_:
  dw do_colon
star_slash_mod_pfa:
  dw to_r_
  dw m_star_
  dw from_r_
  dw m_slash_
  dw semicolon_s_

star_slash_nfa:
  db 0x02+0x80,'*','/'+0x80
star_slash_lfa:
  dw star_slash_mod_nfa
star_slash_:
  dw do_colon
star_slash_pfa:
  dw star_slash_mod_
  dw swap_
  dw drop_
  dw semicolon_s_

m_slash_mod_nfa:
  db 0x05+0x80,'M/MO','D'+0x80
m_slash_mod_lfa:
  dw star_slash_nfa
m_slash_mod_:
  dw do_colon
m_slash_mod_pfa:
  dw to_r_,zero_,r_fetch_
  dw u_slash_mod_
  dw from_r_,swap_
  dw to_r_,u_slash_mod_,from_r_
  dw semicolon_s_

paren_line_nfa:
  db 0x06+0x80,'(LINE',')'+0x80
paren_line_lfa:
  dw m_slash_mod_nfa
paren_line_:
  dw do_colon
paren_line_pfa:
  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_,b_slash_scr_,star_,plus_
  dw block_,plus_,c_slash_l_
  dw semicolon_s_

dot_line_nfa:
  db 0x05+0x80,'.LIN','E'+0x80
dot_line_lfa:
  dw paren_line_nfa
dot_line_:
  dw do_colon
dot_line_pfa:
  dw paren_line_,minus_trailing_,type_
  dw semicolon_s_

message_nfa:
  db 0x07+0x80,'MESSAG','E'+0x80
message_lfa:
  dw dot_line_nfa
message_:
  dw do_colon
message_pfa:
  dw warning_,fetch_
  dw zero_branch_,branch_destination_0x6FB3
  dw question_dup_
  dw zero_branch_,branch_destination_0x6FAF
  dw msg_scr_
  dw dot_line_
  dw space_
branch_destination_0x6FAF:
  dw branch_,branch_destination_0x6FBE
branch_destination_0x6FB3:
  dw paren_dot_quote_
  _string 'MSG # '
  dw dot_
branch_destination_0x6FBE:
  dw semicolon_s_

use_nfa:
  db 0x03+0x80,'US','E'+0x80
use_lfa:
  dw message_nfa
use_:
  dw do_variable
use_pfa:
  dw first_buffer

prev_nfa:
  db 0x04+0x80,'PRE','V'+0x80
prev_lfa:
  dw use_nfa
prev_:
  dw do_variable
prev_pfa:
  dw first_buffer

hash_buff_nfa:
  db 0x05+0x80,'#BUF','F'+0x80
hash_buff_lfa:
  dw prev_nfa
hash_buff_:
  dw do_constant
hash_buff_pfa:
  dw buffers

; doc{

; +BUF  ( a1 -- a2 f )

;   Advance the disk buffer address _a1_ to the address of the next
;   buffer _a2_.  Boolean _f_ is false when _a2_ is the buffer
;   presently pointed to by the variable `prev`.

; }doc


plus_buf_nfa:
  db 0x04+0x80,'+BU','F'+0x80
plus_buf_lfa:
  dw hash_buff_nfa
plus_buf_:
  dw do_colon
plus_buf_pfa:
  dw lit_,total_bytes_per_buffer,plus_ ; a2
  dw dup_,limit_,equals_ ; out of bounds?
  dw zero_branch_,plus_buf.continue
  ; a2 is out of bounds
  dw drop_,first_ ; use the first buffer instead
plus_buf.continue:
  dw dup_,prev_,fetch_,not_equals_
  dw semicolon_s_

update_nfa:
  db 0x06+0x80,'UPDAT','E'+0x80
update_lfa:
  dw plus_buf_nfa
update_:
  dw do_colon
update_pfa:
  dw prev_,fetch_,fetch_
  dw lit_,0x8000,or_
  dw prev_,fetch_,store_
  dw semicolon_s_

empty_buffers_nfa:
  db 0x0D+0x80,'EMPTY-BUFFER','S'+0x80
empty_buffers_lfa:
  dw update_nfa
empty_buffers_:
  dw do_colon
empty_buffers_pfa:
  dw first_,limit_,over_,minus_,erase_
  dw limit_,first_
  dw paren_do_
empty_buffers.do:
  dw lit_,0x7FFF,i_,store_
  dw lit_,total_bytes_per_buffer
  dw paren_plus_loop_,empty_buffers.do
  dw semicolon_s_

dr0_nfa:
  db 0x03+0x80,'DR','0'+0x80
dr0_lfa:
  dw empty_buffers_nfa
dr0_:
  dw do_colon
dr0_pfa:
  ; XXX OLD -- not used
  dw semicolon_s_

; doc{

; : BUFFER  ( n -- a )

; Obtain the next block buffer and assign it to block _n_.   If the
; contents of the buffer were marked as updated, it is written to the
; disk.  The block _n_ is not read from the disk.  The address left on
; stack is the first cell in the buffer for data storage.

; }doc

buffer_nfa:
  db 0x06+0x80,'BUFFE','R'+0x80
buffer_lfa:
  dw dr0_nfa
buffer_:
  dw do_colon
buffer_pfa:
  dw use_,fetch_
  dw dup_,to_r_
buffer.begin:
  ; XXX NOTE: `+buf` won't work if single buffer
  dw plus_buf_
  dw zero_branch_,buffer.begin ; until
  dw use_,store_
  dw r_fetch_,fetch_
  dw zero_less_than_ ; updated?
  dw zero_branch_,buffer.end
  ; The buffer was updated, it must be saved to disk.
  dw r_fetch_,two_plus_ ; first cell of data in the buffer
  dw r_fetch_,fetch_
  dw lit_,0x7FFF,and_ ; discard the update bit, leave the block number
  dw zero_,read_write_ ; write
buffer.end:
  dw r_fetch_,store_
  dw r_fetch_,prev_,store_
  dw from_r_,two_plus_ ; first cell of data in the buffer
  dw semicolon_s_

block_nfa:
  db 0x05+0x80,'BLOC','K'+0x80
block_lfa:
  dw buffer_nfa
block_:
  dw do_colon
block_pfa:
  dw to_r_
  dw prev_,fetch_
  dw dup_
  dw fetch_
  dw r_fetch_
  dw minus_
  dw dup_
  dw plus_
  dw zero_branch_,branch_destination_0x71FD
branch_destination_0x71CB:
  dw plus_buf_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x71E5
  dw drop_
  dw r_fetch_
  dw buffer_
  dw dup_
  dw r_fetch_
  dw one_
  dw read_write_
  dw two_minus_
branch_destination_0x71E5:
  dw dup_
  dw fetch_
  dw r_fetch_
  dw minus_
  dw dup_
  dw plus_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x71CB
  dw dup_
  dw prev_
  dw store_
branch_destination_0x71FD:
  dw from_r_,drop_
  dw two_plus_
  dw semicolon_s_

; doc{
; : cswap  ( n1 -- n2 )
;   \ Swap the low and high bytes within n1.
; }doc

c_swap_nfa:
  db 0x05+0x80,'CSWA','P'+0x80
c_swap_lfa:
  dw block_nfa
c_swap_:
  dw c_swap_pfa
c_swap_pfa:
  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp pushhl

; doc{

; : block>sector  ( block -- sector )
;   \ sector (high byte) = track 0..79, +128 if side 1
;   \        (low byte)   = sector 1..10
;   dup 10 mod 1+    \ sector 1..10
;   swap dup 20 /    \ track 0..79
;   swap 10 / 1 and  \ side 0..1
;   128 * +          \ track 0..207
;   cswap or  ;

; }doc

block_to_sector_nfa:
  db 0x0C+0x80,'BLOCK>SECTO','R'+0x80
block_to_sector_lfa:
  dw c_swap_nfa
block_to_sector_:
  dw do_colon
block_to_sector_pfa:
  dw dup_
  dw c_lit_
  db 10
  dw mod_,one_plus_,swap_,dup_
  dw c_lit_
  db 20
  dw slash_,swap_
  dw c_lit_
  db 10
  dw slash_,one_,and_
  ; XXX TODO optimize with `7 lshift`?
  dw c_lit_
  db 128
  dw star_,plus_,c_swap_,or_
  dw semicolon_s_

read_write_nfa:
  db 0x03+0x80,'R/','W'+0x80
read_write_lfa:
  dw block_to_sector_nfa
read_write_:
  dw do_colon
read_write_pfa:
  dw c_lit_
  db 0x45
  dw swap_,minus_
  dw lit_,read_write_sector_command,c_store_
  dw block_to_sector_
  dw paren_read_write_
  dw semicolon_s_

  ; Headerless word with the low level code of `R/W`.
paren_read_write_:
  dw paren_read_write_pfa
paren_read_write_pfa:
  ld a,2 ; drive ; XXX TMP
  pop de ; sector
  pop hl ; address
  push bc
  push ix
  push hl
  pop ix ; address
  rst 8
read_write_sector_command:
  ; Patched by `R/W`:
  ;   0x45 = write
  ;   0x44 = read
  db 0x44
  pop ix
  pop bc
  _jp_next

flush_nfa:
  db 0x05+0x80,'FLUS','H'+0x80
flush_lfa:
  dw read_write_nfa
flush_:
  dw do_colon
flush_pfa:
  dw hash_buff_,one_plus_,zero_
  dw paren_do_
flush.do:
  dw zero_,buffer_,drop_
  dw paren_loop_,flush.do ; loop
  dw semicolon_s_

continued_nfa:
  db 0x09+0x80,'CONTINUE','D'+0x80
continued_lfa:
  dw flush_nfa
continued_:
  dw do_colon
continued_pfa:
  dw dup_,zero_,equals_
  dw c_lit_
  db 0x09
  dw question_error_
  dw in_,off_
  dw b_slash_scr_,star_,blk_,store_
  dw interpret_
  dw semicolon_s_

load_nfa:
  db 0x04+0x80,'LOA','D'+0x80
load_lfa:
  dw continued_nfa
load_:
  dw do_colon
load_pfa:
if 1 ; XXX OLD
  dw dup_,zero_,equals_
  dw c_lit_
  db 0x09
  dw question_error_
  dw blk_,fetch_,to_r_
  dw in_,fetch_,to_r_
  dw in_,off_
  dw b_slash_scr_,star_,blk_,store_
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  dw interpret_
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER
else ; XXX NEW
  ; XXX no difference, this is not the cause of the new problems with `load`.
  dw blk_,fetch_,to_r_
  dw in_,fetch_,to_r_
  dw continued_
endif
  dw from_r_,in_,store_
  dw from_r_,blk_,store_
  dw semicolon_s_

next_screen_nfa:
  db 0x03+0x80+precedence_bit_mask,'--','>'+0x80
next_screen_lfa:
  dw load_nfa
next_screen_:
  dw do_colon
next_screen_pfa:
  dw question_loading_
  dw in_,off_
  dw b_slash_scr_,blk_,fetch_,over_,mod_,minus_
  dw blk_,plus_store_
  dw semicolon_s_

tick_nfa:
  db 0x01+0x80,'',"'"+0x80
tick_lfa:
  dw next_screen_nfa
tick_:
  dw do_colon
tick_pfa:
  dw minus_find_
  dw zero_equals_,one_,question_error_
  dw drop_,pfa_to_cfa_
  dw semicolon_s_

bracket_tick_nfa:
  db 0x03+0x80+precedence_bit_mask,"['",']'+0x80
bracket_tick_lfa:
  dw tick_nfa
bracket_tick_:
  dw do_colon
bracket_tick_pfa:
  dw tick_,literal_
  dw semicolon_s_

back_nfa:
  db 0x04+0x80,'BAC','K'+0x80
back_lfa:
  dw bracket_tick_nfa
back_:
  dw do_colon
back_pfa:
  dw comma_
  dw semicolon_s_

begin_nfa:
  db 0x05+0x80+precedence_bit_mask,'BEGI','N'+0x80
begin_lfa:
  dw back_nfa
begin_:
  dw do_colon
begin_pfa:
  dw question_comp_
  dw here_
  dw one_
  dw semicolon_s_

then_nfa:
  db 0x04+0x80+precedence_bit_mask,'THE','N'+0x80
then_lfa:
  dw begin_nfa
then_:
  dw do_colon
then_pfa:
  dw question_comp_
  dw two_,question_pairs_
  dw here_,swap_,store_
  dw semicolon_s_

do_nfa:
  db 0x02+0x80+precedence_bit_mask,'D','O'+0x80
do_lfa:
  dw then_nfa
do_:
  dw do_colon
do_pfa:
  dw compile_,paren_do_
  dw here_
  dw three_
  dw semicolon_s_

loop_nfa:
  db 0x04+0x80+precedence_bit_mask,'LOO','P'+0x80
loop_lfa:
  dw do_nfa
loop_:
  dw do_colon
loop_pfa:
  dw three_,question_pairs_
  dw compile_,paren_loop_
  dw back_
  dw semicolon_s_

plus_loop_nfa:
  db 0x05+0x80+precedence_bit_mask,'+LOO','P'+0x80
plus_loop_lfa:
  dw loop_nfa
plus_loop_:
  dw do_colon
plus_loop_pfa:
  dw three_
  dw question_pairs_
  dw compile_,paren_plus_loop_
  dw back_
  dw semicolon_s_

until_nfa:
  db 0x05+0x80+precedence_bit_mask,'UNTI','L'+0x80
until_lfa:
  dw plus_loop_nfa
until_:
  dw do_colon
until_pfa:
  dw one_,question_pairs_
  dw compile_,zero_branch_
  dw back_
  dw semicolon_s_

again_nfa:
  db 0x05+0x80+precedence_bit_mask,'AGAI','N'+0x80
again_lfa:
  dw until_nfa
again_:
  dw do_colon
again_pfa:
  dw one_,question_pairs_
  dw compile_,branch_
  dw back_
  dw semicolon_s_

repeat_nfa:
  db 0x06+0x80+precedence_bit_mask,'REPEA','T'+0x80
repeat_lfa:
  dw again_nfa
repeat_:
  dw do_colon
repeat_pfa:
  ; XXX TODO optimize with 2>r and 2r>
  dw to_r_
  dw to_r_
  dw again_
  dw from_r_
  dw from_r_
  dw two_minus_
  dw then_
  dw semicolon_s_

if_nfa:
  db 0x02+0x80+precedence_bit_mask,'I','F'+0x80
if_lfa:
  dw repeat_nfa
if_:
  dw do_colon
if_pfa:
  dw compile_,zero_branch_
  dw here_
  dw zero_,comma_
  dw two_
  dw semicolon_s_

  ; XXX NEW
unless_nfa:
  db 0x06+0x80+precedence_bit_mask,'UNLES','S'+0x80
unless_lfa:
  dw if_nfa
unless_:
  dw do_colon
unless_pfa:
  dw compile_,question_branch_
  dw here_
  dw zero_,comma_
  dw two_
  dw semicolon_s_

else_nfa:
  db 0x04+0x80+precedence_bit_mask,'ELS','E'+0x80
else_lfa:
  dw unless_nfa
else_:
  dw do_colon
else_pfa:
  dw two_
  dw question_pairs_
  dw compile_,branch_
  dw here_
  dw zero_,comma_
  dw swap_
  dw two_
  dw then_
  dw two_
  dw semicolon_s_

while_nfa:
  db 0x05+0x80+precedence_bit_mask,'WHIL','E'+0x80
while_lfa:
  dw else_nfa
while_:
  dw do_colon
while_pfa:
  dw if_
  dw two_plus_
  dw semicolon_s_

spaces_nfa:
  db 0x06+0x80,'SPACE','S'+0x80
spaces_lfa:
  dw while_nfa
spaces_:
  dw do_colon
spaces_pfa:
  dw zero_,max_,question_dup_
  dw zero_branch_,branch_destination_0x7418
  dw zero_
  dw paren_do_
branch_destination_0x7412:
  dw space_
  dw paren_loop_,branch_destination_0x7412
branch_destination_0x7418:
  dw semicolon_s_

less_hash_nfa:
  db 0x02+0x80,'<','#'+0x80
less_hash_lfa:
  dw spaces_nfa
less_hash_:
  dw do_colon
less_hash_pfa:
  dw pad_
  dw hld_
  dw store_
  dw semicolon_s_

hash_greater_nfa:
  db 0x02+0x80,'#','>'+0x80
hash_greater_lfa:
  dw less_hash_nfa
hash_greater_:
  dw do_colon
hash_greater_pfa:
  dw drop_
  dw drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw semicolon_s_

sign_nfa:
  db 0x04+0x80,'SIG','N'+0x80
sign_lfa:
  dw hash_greater_nfa
sign_:
  dw do_colon
sign_pfa:
  dw rot_
  dw zero_less_than_
  dw zero_branch_,branch_destination_0x7457
  dw c_lit_
  db '-'
  dw hold_
branch_destination_0x7457:
  dw semicolon_s_

hash_nfa:
  db 0x01+0x80,'','#'+0x80
hash_lfa:
  dw sign_nfa
hash_:
  dw do_colon
hash_pfa:
  dw base_,fetch_,m_slash_mod_,rot_
  dw c_lit_
  db 0x09
  dw over_,less_than_
  dw zero_branch_,hash.digit
  dw c_lit_
  db 0x07
  dw plus_
hash.digit:
  dw c_lit_
  db '0'
  dw plus_
  dw hold_
  dw semicolon_s_

hash_s_nfa:
  db 0x02+0x80,'#','S'+0x80
hash_s_lfa:
  dw hash_nfa
hash_s_:
  dw do_colon
hash_s_pfa:
hash_s.begin:
  dw hash_,two_dup_,or_,zero_equals_
  dw zero_branch_,hash_s.begin ; until
  dw semicolon_s_

d_dot_r_nfa:
  db 0x03+0x80,'D.','R'+0x80
d_dot_r_lfa:
  dw hash_s_nfa
d_dot_r_:
  dw do_colon
d_dot_r_pfa:
  dw to_r_
  dw swap_
  dw over_
  dw dabs_
  dw less_hash_
  dw hash_s_
  dw sign_
  dw hash_greater_
  dw from_r_
  dw over_
  dw minus_
  dw spaces_
  dw type_
  dw semicolon_s_

dot_r_nfa:
  db 0x02+0x80,'.','R'+0x80
dot_r_lfa:
  dw d_dot_r_nfa
dot_r_:
  dw do_colon
dot_r_pfa:
  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw semicolon_s_

d_dot_nfa:
  db 0x02+0x80,'D','.'+0x80
d_dot_lfa:
  dw dot_r_nfa
d_dot_:
  dw do_colon
d_dot_pfa:
  dw zero_,d_dot_r_,space_
  dw semicolon_s_

dot_nfa:
  db 0x01+0x80,'','.'+0x80
dot_lfa:
  dw d_dot_nfa
dot_:
  dw do_colon
dot_pfa:
  dw s_to_d_,d_dot_
  dw semicolon_s_

question_nfa:
  db 0x01+0x80,'','?'+0x80
question_lfa:
  dw dot_nfa
question_:
  dw do_colon
question_pfa:
  dw fetch_,dot_
  dw semicolon_s_

u_dot_nfa:
  db 0x02+0x80,'U','.'+0x80
u_dot_lfa:
  dw question_nfa
u_dot_:
  dw do_colon
u_dot_pfa:
  dw zero_,d_dot_
  dw semicolon_s_

  ; XXX OLD -- move to the blocks
words_nfa:
  db 0x05+0x80,'WORD','S'+0x80
words_lfa:
  dw u_dot_nfa
words_:
  dw do_colon
words_pfa:
  dw c_lit_
  db 0x80
  dw out_,store_
  dw context_,fetch_,fetch_
words.begin:
  dw out_,fetch_
  dw c_lit_
  db 0x1F ; max word length
  dw c_lit_
  db 0x08
  dw minus_
  dw greater_than_
  dw zero_branch_,words.continue
  dw cr_,out_,off_
words.continue:
  dw dup_,id_dot_
  dw nfa_to_lfa_,fetch_
  dw dup_,zero_equals_,question_terminal_,or_
  dw zero_branch_,words.begin ; until
  dw drop_
  dw semicolon_s_

list_nfa:
  db 0x04+0x80,'LIS','T'+0x80
list_lfa:
  dw words_nfa
list_:
  dw do_colon
list_pfa:
  dw cr_
  dw dup_,scr_,store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw dot_
  dw c_lit_
  db lines_per_screen
  dw zero_
  dw paren_do_
list.do:
  dw cr_
  dw i_
  dw c_lit_
  db 0x02
  dw dot_r_
  dw space_,i_,scr_,fetch_,dot_line_
  dw question_terminal_
  dw zero_branch_,list.loop
  dw leave_
list.loop:
  dw paren_loop_,list.do ; loop
  dw cr_
  dw semicolon_s_

page_nfa:
  db 0x04+0x80,'PAG','E'+0x80
page_lfa:
  dw list_nfa
page_:
  dw page_pfa
page_pfa:
  push bc
  ; XXX OLD -- why open the channel?
  ;ld a,0x02
  ;call rom_chan_open
  call rom_cl_all
  ; XXX OLD -- why open the channel?
  ;ld a,0x02
  ;call rom_chan_open
  ; XXX TODO check the status of the printer
  pop bc
  _jp_next

bye_nfa:
  db 0x03+0x80,'BY','E'+0x80
bye_lfa:
  dw page_nfa
bye_:
  dw bye_pfa
bye_pfa:
  ld (iy+sys_df_sz_offset),0x02 ; restore lines of the lower screen
  rst 0x08
  db 0x08 ; "STOP" BASIC error

text_nfa:
  db 0x04+0x80,'TEX','T'+0x80
text_lfa:
  dw bye_nfa
text_:
  dw do_colon
text_pfa:
  dw here_,c_slash_l_,one_plus_,blanks_ ; fill the word buffer with blanks
  dw word_
  dw here_ ; origin
  dw pad_ ; destination
  dw c_slash_l_,one_plus_ ; count
  dw cmove_
  dw semicolon_s_

line_nfa:
  db 0x04+0x80,'LIN','E'+0x80
line_lfa:
  dw text_nfa
line_:
  dw do_colon
line_pfa:
  dw dup_
  dw lit_,0xFFF0
  dw and_ ; make sure line is between 0 and 15.
  dw c_lit_
  db 0x17
  dw question_error_ ; if not, issue an error message
  dw scr_,fetch_ ; screen number
  dw paren_line_ ; address of the n'th line in the screen buffer
  dw drop_ ; discard the character count left by `(line)`
  dw semicolon_s_

two_drop_nfa:
  db 0x05+0x80,'2DRO','P'+0x80
two_drop_lfa:
  dw line_nfa
two_drop_:
  dw two_drop_pfa
two_drop_pfa:
  pop hl
  pop hl
  _jp_next

two_swap_nfa:
  db 0x05+0x80,'2SWA','P'+0x80
two_swap_lfa:
  dw two_drop_nfa
two_swap_:
  dw do_colon
two_swap_pfa:
  dw rot_
  dw to_r_
  dw rot_
  dw from_r_
  dw semicolon_s_

size_nfa:
  db 0x04+0x80,'SIZ','E'+0x80
size_lfa:
  dw two_swap_nfa
size_:
  dw do_colon
size_pfa:
  ; XXX TODO update for the new map, count from org.
  dw here_,zero_,plus_origin_,minus_
  dw semicolon_s_

unused_nfa:
  db 0x06+0x80,'UNUSE','D'+0x80
unused_lfa:
  dw size_nfa
unused_:
  dw do_colon
unused_pfa:
  ; XXX TMP
  dw zero_,here_,minus_
  dw semicolon_s_

  ; XXX TODO -- remove, already copied to the blocks disk
index_nfa:
  db 0x05+0x80,'INDE','X'+0x80
index_lfa:
  dw unused_nfa
index_:
  dw do_colon
index_pfa:
  dw one_plus_
  dw swap_
  dw paren_do_
branch_destination_0x774B:
  dw cr_,i_,three_,dot_r_,space_
  dw zero_,i_,dot_line_
  dw question_terminal_
  dw zero_branch_,branch_destination_0x7763
  dw leave_
branch_destination_0x7763:
  dw paren_loop_,branch_destination_0x774B
  dw semicolon_s_

where_nfa:
  db 0x05+0x80,'WHER','E'+0x80
where_lfa:
  dw index_nfa
where_:
  dw do_colon
where_pfa:
  dw dup_
  dw b_slash_scr_
  dw slash_
  dw dup_
  dw scr_
  dw store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_
  dw dot_
  dw swap_
  dw c_slash_l_
  dw slash_mod_
  dw c_slash_l_
  dw star_
  dw rot_
  dw block_
  dw plus_
  dw cr_
  dw c_slash_l_
  dw type_
  dw cr_
  dw here_
  dw c_fetch_
  dw minus_
  dw spaces_
  dw c_lit_
  db 0x5E
  dw emit_
  dw quit_
  dw semicolon_s_

next_nfa:
  db 0x04+0x80,'NEX','T'+0x80
next_lfa:
  dw where_nfa
next_:
  dw do_constant
next_pfa:
  dw next

pushhl_nfa:
  db 0x06+0x80,'PUSHH','L'+0x80
pushhl_lfa:
  dw next_nfa
pushhl_:
  dw do_constant
pushhl_pfa:
  dw pushhl

pushde_nfa:
  db 0x06+0x80,'PUSHD','E'+0x80
pushde_lfa:
  dw pushhl_nfa
pushde_:
  dw do_constant
pushde_pfa:
  dw pushde

p_fetch_nfa:
  db 0x02+0x80,'P','@'+0x80
p_fetch_lfa:
  dw pushde_nfa
p_fetch_:
  dw p_fetch_pfa
p_fetch_pfa:
  pop hl
  push bc
  ld c,l
  ld b,h
  in a,(c)
  pop bc
  ld h,0x00
  ld l,a
  jp pushhl

p_store_nfa:
  db 0x02+0x80,'P','!'+0x80
p_store_lfa:
  dw p_fetch_nfa
p_store_:
  dw p_store_pfa
p_store_pfa:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  ld a,e
  out (c),a
  pop bc
  _jp_next

  ; XXX TODO -- move to the blocks disk and optimize
screen_nfa:
  db 0x06+0x80,'SCREE','N'+0x80
screen_lfa:
  dw p_store_nfa
screen_:
  dw screen_pfa
screen_pfa:
  pop hl
  pop de
  push bc
  push ix
  ld c,e
  ld b,l
  call rom_s_scrn_s_0x2538
  call rom_stack_fetch
  ld a,(de)
  ld h,0x00
  ld l,a
  pop ix
  pop bc
  jp pushhl

; doc{

; : AT ( line col -- )

; Adapted from Lennart Benschop's Spectrum Forth-83.

; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

at_nfa:
  db 0x02+0x80,'A','T'+0x80
at_lfa:
  dw screen_nfa
at_:
  dw do_colon
at_pfa:

  dw swap_,dup_
  dw c_lit_
  db 23
  dw not_equals_ ; not the last line?
  dw zero_branch_,at_pfa.last_line
  ; not the last line
  dw lit_,22,paren_emit_,paren_emit_,paren_emit_
  dw semicolon_s_

at_pfa.last_line:
  dw one_minus_,dup_,paren_emit_,paren_emit_,zero_,paren_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  dw c_lit_
  db 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw semicolon_s_

border_nfa:
  db 0x06+0x80,'BORDE','R'+0x80
border_lfa:
  dw at_nfa
border_:
  dw border_pfa
border_pfa:
  pop hl
  ld a,l
  out(0xFE),a
  _jp_next

gover_nfa:
  db 0x05+0x80,'GOVE','R'+0x80
gover_lfa:
  dw border_nfa
gover_:
  dw gover_pfa
gover_pfa:
  ld a,over_char
  jp color

flash_nfa:
  db 0x05+0x80,'FLAS','H'+0x80
flash_lfa:
  dw gover_nfa
flash_:
  dw flash_pfa
flash_pfa:
  ld a,flash_char
  jp color

inverse_nfa:
  db 0x07+0x80,'INVERS','E'+0x80
inverse_lfa:
  dw flash_nfa
inverse_:
  dw inverse_pfa
inverse_pfa:
  ld a,inverse_char
  jp color

bright_nfa:
  db 0x06+0x80,'BRIGH','T'+0x80
bright_lfa:
  dw inverse_nfa
bright_:
  dw bright_pfa
bright_pfa:
  ld a,bright_char
  jp color

paper_nfa:
  db 0x05+0x80,'PAPE','R'+0x80
paper_lfa:
  dw bright_nfa
paper_:
  dw paper_pfa
paper_pfa:
  ld a,paper_char
  jp color

ink_nfa:
  db 0x03+0x80,'IN','K'+0x80
ink_lfa:
  dw paper_nfa
ink_:
  dw ink_pfa
ink_pfa:
  ld a,ink_char
color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or gover).
  ; a = attribute control char
  ; (tos) = color attribute value
  rst 0x10
  pop hl
  ld a,l
  rst 0x10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

i_tick_nfa:
  db 0x02+0x80,'I',"'"+0x80
i_tick_lfa:
  dw ink_nfa
i_tick_:
  dw i_tick_pfa
i_tick_pfa:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

j_nfa:
  db 0x01+0x80,'','J'+0x80
j_lfa:
  dw i_tick_nfa
j_:
  dw j_pfa
j_pfa:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

two_constant_nfa:
  db 0x09+0x80,'2CONSTAN','T'+0x80
two_constant_lfa:
  dw j_nfa
two_constant_:
  dw do_colon
two_constant_pfa:
  dw create_
  dw smudge_
  dw here_
  dw two_store_
  dw c_lit_
  db 0x04
  dw allot_
  dw paren_semicolon_code_
do_two_constant:
  ; XXX OLD optimize to use pushde
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  dec hl
  dec hl
  ld d,(hl)
  dec hl
  ld e,(hl)
  push de
  _jp_next

two_variable_nfa:
  db 0x09+0x80,'2VARIABL','E'+0x80
two_variable_lfa:
  dw two_constant_nfa
two_variable_:
  dw do_colon
two_variable_pfa:
  dw two_constant_
  dw paren_semicolon_code_
do_two_variable:
  ; XXX TODO optimize to share code with `do_variable`.
  inc de  ; de=pfa
  push de
  _jp_next

u_dot_r_nfa:
  db 0x03+0x80,'U.','R'+0x80
u_dot_r_lfa:
  dw two_variable_nfa
u_dot_r_:
  dw do_colon
u_dot_r_pfa:
  dw to_r_,zero_,from_r_,d_dot_r_
  dw semicolon_s_

two_over_nfa:
  db 0x05+0x80,'2OVE','R'+0x80
two_over_lfa:
  dw u_dot_r_nfa
two_over_:
  dw do_colon
two_over_pfa:
  ; XXX TODO rewrite in Z80
  dw two_swap_
  dw two_dup_
  ; XXX TODO optimize with 2>r and 2r>
  dw to_r_
  dw to_r_
  dw two_swap_
  dw from_r_
  dw from_r_
  dw semicolon_s_

exit_nfa:
  db 0x04+0x80,'EXI','T'+0x80
exit_lfa:
  dw two_over_nfa
exit_:
  dw do_colon
exit_pfa:
  dw r_drop_
  dw semicolon_s_

question_exit_nfa:
  db 0x05+0x80,'?EXI','T'+0x80
question_exit_lfa:
  dw exit_nfa
question_exit_:
  dw question_exit_pfa
question_exit_pfa:
  ; XXX FIXME
  pop hl
  ld a,h
  or l
  jp nz,r_drop_pfa
  _jp_next

case_nfa:
  db 0x04+0x80+precedence_bit_mask,'CAS','E'+0x80
case_lfa:
  dw question_exit_nfa
case_:
  dw do_colon
case_pfa:
  dw question_comp_
  dw csp_,fetch_
  dw store_csp_
  dw c_lit_
  db 0x04
  dw semicolon_s_

of_nfa:
  db 0x02+0x80+precedence_bit_mask,'O','F'+0x80
of_lfa:
  dw case_nfa
of_:
  dw do_colon
of_pfa:
  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,over_
  dw compile_,equals_
  dw compile_,zero_branch_
  dw here_
  dw zero_,comma_
  dw compile_,drop_
  dw c_lit_
  db 0x05
  dw semicolon_s_

endof_nfa:
  db 0x05+0x80+precedence_bit_mask,'ENDO','F'+0x80
endof_lfa:
  dw of_nfa
endof_:
  dw do_colon
endof_pfa:
  dw c_lit_
  db 0x05
  dw question_pairs_
  dw compile_,branch_
  dw here_
  dw zero_,comma_
  dw swap_
  dw two_
  dw then_
  dw c_lit_
  db 0x04
  dw semicolon_s_

endcase_nfa:
  db 0x07+0x80+precedence_bit_mask,'ENDCAS','E'+0x80
endcase_lfa:
  dw endof_nfa
endcase_:
  dw do_colon
endcase_pfa:
  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,drop_
branch_destination_0x80F0:
  dw sp_fetch_
  dw csp_,fetch_
  dw equals_
  dw zero_equals_
  dw zero_branch_,branch_destination_0x8106
  dw two_
  dw then_
  dw branch_,branch_destination_0x80F0
branch_destination_0x8106:
  dw csp_
  dw store_
  dw semicolon_s_

inkey_nfa:
  db 0x05+0x80,'INKE','Y'+0x80
inkey_lfa:
  dw endcase_nfa
inkey_:
  dw inkey_pfa
inkey_pfa:
  push bc
  call rom_key_scan
  ld c,0x00
  jr nz,l8128h
  call rom_key_test
  jr nc,l8128h
  dec d
  ld e,a
  call rom_key_decode
l8128h:
  ld l,a
  ld h,0x00
  pop bc
  jp pushhl

char_nfa:
  db 0x04+0x80,'CHA','R'+0x80
char_lfa:
  dw inkey_nfa
char_:
  dw do_colon
char_pfa:
  dw b_l_,word_,here_,one_plus_,c_fetch_
  dw semicolon_s_

bracket_char_nfa:
  db 0x06+0x80+precedence_bit_mask,'[CHAR',']'+0x80
bracket_char_lfa:
  dw char_nfa
bracket_char_:
  dw do_colon
bracket_char_pfa:
  dw char_,literal_
  dw semicolon_s_

backslash_nfa:
  db 0x01+0x80+precedence_bit_mask,'','\'+0x80
backslash_lfa:
  dw bracket_char_nfa
backslash_:
  dw do_colon
backslash_pfa:
  dw in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw in_,plus_store_
  dw semicolon_s_

; doc{
; : .(  ( 'ccc<paren>' -- )
;   [CHAR] ) TEXT PAD COUNT TYPE  ; IMMEDIATE
; }doc

nfa_of_top_most_word_in_forth_voc:

dot_paren_nfa:
  db 0x02+0x80+precedence_bit_mask,'.','('+0x80
dot_paren_lfa:
  dw backslash_nfa
dot_paren_:
  dw do_colon
dot_paren_pfa:
  dw c_lit_
  db ')'
  dw text_,pad_,count_,type_
  dw semicolon_s_

dictionary_pointer_after_cold:

end cold_entry

; ==============================================================
; Debug tools

  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER

