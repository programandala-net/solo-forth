  \ tool.list.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201611211916

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-11-20: Factor `list-lines` from `list`. Improve
  \ documentation of all words. Compact the code to save one
  \ block. Add conditional compilation to `list`, `list-lines`,
  \ `index`, `.index`.
  \
  \ 2016-11-21: Modify title of listed screen, to avoid
  \ confusion when the radix is other than decimal. Move the
  \ `blocked` editor's quick index here, improve it and
  \ document it. Write `/line#` and `.line#`, useful factors of
  \ `list-lines`. Move `contains` to <strings.misc.fsb>.

( /line# .line# list-lines list )

[unneeded] /line#
?\ : /line#  ( -- n )  #16 base @ - 4 / 1+  ;  exit

  \ doc{
  \
  \ /line#  ( -- # )
  \
  \ Maximum length of a line number in the current radix.
  \ It works for decimal, hex and binary.
  \
  \ }doc

[unneeded] .line#
?\ need /line#  : .line#  ( n -- )  /line# .r  ;  exit

  \ doc{
  \
  \ .line#  ( n -- )
  \
  \ Print line number _n_ right-aligned in a field whose width
  \ depends on the current radix (decimal, hex or binary).
  \
  \ }doc

need ?(

[unneeded] list-lines ?(  need .line  need nuf?  need .line#
: list-lines  ( u1 u2 u3 -- )
  rot dup scr ! cr ." Screen " .  1+ swap
  ?do  cr i .line# space i scr @ .line nuf? ?leave  loop cr  ;
exit ?)

  \ doc{
  \
  \ list-lines  ( u1 u2 u3 -- )
  \
  \ Display lines _u2..u3_ of block _u1_ and store _u1_ in `scr`.
  \
  \ See: `list`, `scr`.
  \
  \ }doc

[unneeded] list ?(  need list-lines
: list  ( u -- )  0 [ l/scr 1- ] literal list-lines  ;  exit ?)

  \ doc{
  \
  \ list  ( u -- )
  \
  \ Display block _u_ and store _u_ in `scr`.
  \
  \ See: `list-lines`, `scr`.
  \
  \ Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( .index index )

[unneeded] .index ?(  need .line
: .index  ( u -- )  cr dup 3 .r space 0 swap .line  ;  exit ?)

  \ doc{
  \
  \ .index  ( u -- )
  \
  \ Print the first line of the block _u_, which conventionally
  \ contains a comment with a title.
  \
  \ }doc

[unneeded] index ?(  need .line  need nuf?
: index  ( u1 u2 -- )
  1+ swap ?do  cr i 3 .r space 0 i .line  nuf? ?leave  loop  ;
exit ?)

  \ doc{
  \
  \ index  ( u1 u2 -- )
  \
  \ Print the first line of each block over the range from
  \ _u1_ to _u2_, which conventionally contains a comment with
  \ a title.
  \
  \ Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
  \ (Uncontrolled Reference Words).
  \
  \ }doc

( index-like )

need .index  need nuf?  need contains

: index-like  ( u1 u2 "name" -- )
  parse-name 2swap
  1+ swap ?do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ doc{
  \
  \ index-like  ( u1 u2 "name" -- )
  \
  \ Print the first line of each block over the range from _u1_
  \ to _u2_, which conventionally contains a comment with a
  \ title, as long as the string "name" is included in the
  \ line. The string comparison is case-sensitive.
  \
  \ See: `index`, `index-ilike`.
  \
  \ }doc

( index-ilike )

need .index  need contains

: index-ilike  ( u1 u2 "name" -- )
  parse-name save-string 2dup uppers
  2swap 1+ swap ?do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ doc{
  \
  \ index-ilike  ( u1 u2 "name" -- )
  \
  \ Print the first line of each block over the range from _u1_
  \ to _u2_, which conventionally contains a comment with a
  \ title, as long as the string "name" is included in the
  \ line. The string comparison is case-insensitive.
  \
  \ See: `index`, `index-like`.
  \
  \ }doc

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

( qx nx px )

  \ Quick index

  \ Credit:
  \
  \ Code extracted, adapted and improved from Gforth's
  \ `blocked`, originally written by Bernd Paysan, 1995.

need rows  need columns  need j  need inverse
need .line#  need /line#

: qx-columns  ( -- n )  columns 14 /  ;

  \ doc{
  \
  \ qx-columns  ( -- n )
  \
  \ Number of columns of the quick index.
  \
  \ See: `qx`.
  \
  \ }doc

: /qx-column  ( -- n )  columns qx-columns /  ;

  \ doc{
  \
  \ /qx-column  ( -- n )
  \
  \ Width of a column of the quick index.
  \
  \ See: `qx`.
  \
  \ }doc

: /qx  ( -- n )  rows 2- qx-columns *  ;

  \ doc{
  \
  \ /qx  ( -- n )
  \
  \ Header lines shown on a quick index.
  \
  \ See: `qx`.
  \
  \ }doc

: qx-bounds  ( -- u1 u2 )
  scr @ /qx / /qx * /qx bounds
  0 max swap [ blocks 1+ ] literal min swap  ;

  \ doc{
  \
  \ qx-bounds  ( -- u1 u2 )
  \
  \ Blocks to be included in the quick index, from block _u2_
  \ to block _u1-1_. They depend on `scr`.
  \
  \ See: `qx`, `scr`.
  \
  \ }doc

: qx ( -- )
  home  qx-bounds do  qx-columns 0 do
    i 1+ j +  dup 3 .r  dup scr @ = abs inverse
    block /qx-column 3 - type  0 inverse
  loop  cr  qx-columns 2 +loop  ;

  \ doc{
  \
  \ name  ( -- )
  \
  \ Give a quick index. The number and width of the columns
  \ depend on the current screen mode. The current block,
  \ stored in `scr`, is highlighted.
  \
  \ See: `scr`, `nx`, `px`.
  \
  \ }doc

  \ XXX FIXME -- The combination of loops makes the block count
  \ overflow at the end of the disk, beyond `blocks`.
  \
  \ XXX TODO -- factor `3 .r` to `.line-number`, dependent on
  \ `base`
  \
  \ XXX TODO -- change _3_ to `/line-number`, a factor of
  \ `.line-number`
  \
  \ XXX TODO -- simplify: one single `do loop` and a
  \ conditional `cr`, or padding to end of line

: nx  ( -- )  /qx scr @ + blocks min scr ! qx  ;

  \ doc{
  \
  \ nx  ( -- )
  \
  \ Give next quick index, calculated from `scr`.
  \
  \ See: `qx`, `px`, `scr`.
  \
  \ }doc

: px  ( -- )  scr @ /qx - 0 max scr ! qx  ;

  \ doc{
  \
  \ px  ( -- )
  \
  \ Give previous quick index, calculated from `scr`.
  \
  \ See: `qx`, `nx`, `scr`.
  \
  \ }doc

  \ vim: filetype=soloforth
