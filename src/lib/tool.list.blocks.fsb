  \ tool.list.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201611212213

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-11-20: Factor `list-lines` from `list`. Improve
  \ documentation of all words. Compact the code to save one
  \ block. Add conditional compilation to `list`, `list-lines`,
  \ `index`, `.index`.
  \
  \ 2016-11-21: Modify title of listed screen, to avoid
  \ confusion when the radix is other than decimal. Move the
  \ `blocked` editor's quick index here, improve it and
  \ document it. Write `/line#` and `.line#`, useful factors of
  \ `list-lines`. Move `contains` to <strings.misc.fsb>.
  \ Move `.line` from <blocks.fsb>. Compact the code, saving
  \ one block. Add `/block#` and `.block#`, for clarity.

( /line# .line# .line list-lines list )

[unneeded] /line#
?\ : /line#  ( -- n )  #16 base @ - 4 / 1+  ;  exit

  \ doc{
  \
  \ /line#  ( -- # )
  \
  \ Maximum length of a line number in the current radix.
  \ It works for decimal, hex and binary.
  \
  \ }doc

[unneeded] .line#
?\ need /line#  : .line#  ( n -- )  /line# .r  ;  exit

  \ doc{
  \
  \ .line#  ( n -- )
  \
  \ Print line number _n_ right-aligned in a field whose width
  \ depends on the current radix (decimal, hex or binary).
  \
  \ }doc

[unneeded] .line
?\ : .line  ( n1 n2 -- )  line>string -trailing type  ;  exit

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

need ?(

[unneeded] list-lines ?(  need .line  need nuf?  need .line#
: list-lines  ( u1 u2 u3 -- )
  rot dup scr ! cr ." Screen " .  1+ swap
  ?do  cr i .line# space i scr @ .line nuf? ?leave  loop cr  ;
exit ?)

  \ doc{
  \
  \ list-lines  ( u1 u2 u3 -- )
  \
  \ Display lines _u2..u3_ of block _u1_ and store _u1_ in `scr`.
  \
  \ See: `list`, `scr`.
  \
  \ }doc

[unneeded] list ?(  need list-lines
: list  ( u -- )  0 [ l/scr 1- ] literal list-lines  ;  exit ?)

  \ doc{
  \
  \ list  ( u -- )
  \
  \ Display block _u_ and store _u_ in `scr`.
  \
  \ See: `list-lines`, `scr`.
  \
  \ Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( /block# .block# .index index )

[unneeded] /block# ?\ 3 constant /block#  exit

need ?(

[unneeded] .block# ?(  need /block#
: .block#  ( n -- )  /block# .r  ;  exit ?)

[unneeded] .index ?(  need .line
: .index  ( u -- )
  cr dup .block# space 0 swap .line  ;  exit ?)

  \ doc{
  \
  \ .index  ( u -- )
  \
  \ Print the first line of the block _u_, which conventionally
  \ contains a comment with a title.
  \
  \ }doc

[unneeded] index ?(  need .line  need nuf?
: index  ( u1 u2 -- )
  1+ swap ?do  cr i .block# space 0 i .line  nuf? ?leave
  loop  ;
exit ?)

  \ doc{
  \
  \ index  ( u1 u2 -- )
  \
  \ Print the first line of each block over the range from
  \ _u1_ to _u2_, which conventionally contains a comment with
  \ a title.
  \
  \ Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
  \ (Uncontrolled Reference Words).
  \
  \ }doc

( index-like index-ilike )

need ?(  need .index  need contains  need nuf?

[unneeded] index-like ?(

: index-like  ( u1 u2 "name" -- )
  parse-name 2swap
  1+ swap ?do  0 i line>string 2over contains
               if  i .index  then  nuf? ?leave
  loop  2drop  ;  exit ?)

  \ doc{
  \
  \ index-like  ( u1 u2 "name" -- )
  \
  \ Print the first line of each block over the range from _u1_
  \ to _u2_, which conventionally contains a comment with a
  \ title, as long as the string "name" is included in the
  \ line. The string comparison is case-sensitive.
  \
  \ See: `index`, `index-ilike`.
  \
  \ }doc

[unneeded] index-ilike ?(

: index-ilike  ( u1 u2 "name" -- )
  parse-name save-string 2dup uppers
  2swap 1+ swap ?do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;  exit ?)

  \ doc{
  \
  \ index-ilike  ( u1 u2 "name" -- )
  \
  \ Print the first line of each block over the range from _u1_
  \ to _u2_, which conventionally contains a comment with a
  \ title, as long as the string "name" is included in the
  \ line. The string comparison is case-insensitive.
  \
  \ See: `index`, `index-like`.
  \
  \ }doc

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

( qx nx px )

  \ Quick index

  \ Credit:
  \
  \ Code extracted, adapted and improved from Gforth's
  \ `blocked` blocks editor, originally written by Bernd
  \ Paysan, 1995.

need rows  need columns  need j  need inverse
need .line#  need /line#  need .block#  need /block#

: qx-columns  ( -- n )  columns 14 /  ;

  \ doc{
  \
  \ qx-columns  ( -- n )
  \
  \ Number of columns (2..4) of the quick index. It depends on
  \ the columns (32, 42, 64...) of the current screen mode.
  \
  \ See: `qx`, `/qx-column`.
  \
  \ }doc

: /qx-column  ( -- n )  columns qx-columns /  ;

  \ doc{
  \
  \ /qx-column  ( -- n )
  \
  \ Width of a column of the quick index. It depends on the
  \ columns (32, 42, 64...) of the current screen mode.
  \
  \ See: `qx`, `qx-columns`.
  \
  \ }doc

: /qx  ( -- n )  rows 2- qx-columns *  ;

  \ doc{
  \
  \ /qx  ( -- n )
  \
  \ Header lines shown on a quick index. It depends on the rows
  \ and columns of the current screen mode.
  \
  \ See: `qx`.
  \
  \ }doc

: qx-bounds  ( -- u1 u2 )
  scr @ /qx / /qx * /qx bounds 0 max swap blocks min swap  ;

  \ doc{
  \
  \ qx-bounds  ( -- u1 u2 )
  \
  \ Blocks to be included in the quick index, from block _u2_
  \ to block _u1-1_. They depend on `scr`.
  \
  \ See: `qx`, `scr`.
  \
  \ }doc

: qx-row?  ( n -- f )  qx-columns mod 1+ qx-columns =  ;

  \ doc{
  \
  \ qx-row?  ( n -- f )
  \
  \ Is block counter _n_ (0..) the end of a row of the quick
  \ index?
  \
  \ See: `qx`, `/qx`, `qx-columns`.
  \
  \ }doc

  \ : qx ( -- )
  \   home  qx-bounds do  qx-columns 0 do
  \     i j +  dup .block#  dup scr @ = abs inverse
  \     block /qx-column /block# - type  0 inverse
  \   loop  cr  qx-columns +loop  ;
  \
  \ XXX OLD -- The stepped outer loops makes the block count
  \ overflow at the end of the disk, beyond `blocks`. The new
  \ version uses one single loop.

: qx ( -- ) home  0  qx-bounds ?do
    i dup .block#  dup scr @ = inverse
    block /qx-column /block# - type  0 inverse
    dup qx-row? if  cr  then  1+  loop  drop  ;

  \ XXX TODO --  try with `mode64` and `mode42`

  \ doc{
  \
  \ name  ( -- )
  \
  \ Give a quick index. The number and width of the columns
  \ depend on the current screen mode. The current block,
  \ stored in `scr`, is highlighted.
  \
  \ See: `scr`, `nx`, `px`.
  \
  \ Origin: `qx` included in the Gforth's `blocked` editor.
  \
  \ }doc

: nx  ( -- )  /qx scr @ + [ blocks 1- ] literal min scr ! qx  ;

  \ doc{
  \
  \ nx  ( -- )
  \
  \ Give next quick index, calculated from `scr`.
  \
  \ See: `qx`, `px`, `scr`.
  \
  \ }doc

: px  ( -- )  scr @ /qx - 0 max scr ! qx  ;

  \ doc{
  \
  \ px  ( -- )
  \
  \ Give previous quick index, calculated from `scr`.
  \
  \ See: `qx`, `nx`, `scr`.
  \
  \ }doc

  \ vim: filetype=soloforth
