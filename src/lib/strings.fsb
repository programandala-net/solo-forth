  \ strings.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains string words and tools.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( s= )  \ ==strings==

: s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

( sconstant )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

( cslit csliteral c" )

  \ This is the default definition of `csliteral`, based on a
  \ system-dependent `cslit`, which makes it possible to decode
  \ `c"`.

  \ XXX REMARK -- 43 bytes used

: cslit  ( -- ca )  r@ dup c@ 1+ r> + >r  ;
  \ doc{
  \
  \ cslit  ( -- ca )
  \
  \ Return a string that is compiled after the calling word, and
  \ adjust the instruction pointer to step over the inline string.
  \
  \ }doc

: csliteral  ( ca len -- )
  compile cslit s,  ; immediate compile-only
  \ doc{
  \
  \ csliteral  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Compile a string _ca len_ which at run-time will
  \ be returned as a counted string.
  \
  \ }doc

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  [char] " parse postpone csliteral  ; immediate compile-only
  \ doc{
  \
  \ c"  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Parse a string delimited by double quotes and
  \ compile it into the current definition.
  \ At run-time the string will be returned as a
  \ counted string _ca_.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( csliteral c" )

  \ This is an alternative system-independent definition of
  \ `csliteral`.

  \ XXX REMARK -- 43 bytes used

: csliteral  ( Compilation: ca len -- )
             ( Run-time: -- ca )
  2>r postpone ahead here 2r> s, >r postpone then
  r> postpone literal  ; immediate compile-only
  \ Credits:
  \ Code from Gforth's `CLiteral`.

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  [char] " parse postpone csliteral  ; immediate compile-only

( parse-escaped-string )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( parse-escaped-string )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "ccc<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

( s\" )

need parse-escaped-string

: s\"  ( Interpretation: "ccc<quote>" -- ca len )
       ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "ccc<quote>"  - ca len )
  \
  \ }doc

( .\" )

need parse-escaped-string

: .\"  ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credits:
  \
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credits:
  \
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( s' )

  \ Credits:
  \
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  \
  \ Identical to the standard word `s"`, but using single
  \ quote as delimiter. A simple alternative to `s\"` when only
  \ double quotes are needed in a string.
  \
  \ }doc

: s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  [char] ' parse-string  ; immediate

( begin-stringtable end-stringtable )

  \ Credits:
  \
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

( hunt )

  \ Credits:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( #spaces )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credits:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

( #chars )

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credits:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need s=  need [if]

  \ Credits:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]
: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> s=  ;
[then]

  \ Credits:
  \
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]
: suffix? ( ca1 len1 ca2 len2 -- wf )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string s=  ;
[then]

( -prefix )

  \ Credits:
  \
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credits:
  \
  \ Code from Galope (module minus-suffix.fs).

need string-suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credits:
  \
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credits:
  \
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credits:
  \
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( replaces )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \
  \ Code adapted from the Forth-2012 documentation.

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

vocabulary replaces-voc
wid-of replaces-voc constant wid-subst
  \ wordlist id of the wordlist used to hold substitution names and replacement text.

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

-->

( replaces )

: findsubst  ( ca len -- xt f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _xt_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if
    nip nip execute    \ get buffer address
  else
     makesubst
  then
  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )

  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc

  \ vim: filetype=soloforth
