  \ graphics.pixels.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604071548

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate pixels.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( gx gy -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

\ (pixel-addr) \

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( gx gy -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credit:
  \
  \ Author of the original code: José Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( gx gy -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by José Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by José Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( gx gy -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true jpnz
  ' false jp
  end-code

( pixels )

need z80-asm

code pixels  ( -- u )

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code

  \ doc{
  \
  \ pixels  ( -- u )
  \
  \ Number of pixels set on the screen.
  \
  \ }doc

  \ 26 bytes used.

  \ Credit:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret

( slow-pixels )

  \ Slower version of `pixels`.

need bits
: pixels  ( -- u )  16384 6144 bits  ;

  \ vim: filetype=soloforth
