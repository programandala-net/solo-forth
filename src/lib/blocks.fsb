  \ blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605131208

  \ -----------------------------------------------------------
  \ Description

  \ Words related to disk blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-29: Add `lineload` and `lineblock>source`.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-13: Add `load-section`.

( ?--> update flush thru )

[unneeded] ?-->
?\ : ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "ccc<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credit:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ Origin: Pygmy Forth.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loaded or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credit:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ Origin: MMSFORTH.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;

[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line lineblock>source lineload load-section )

[unneeded] .line
?\ : .line  ( n1 n2 -- )  line>string -trailing type  ;  exit

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

[unneeded] lineblock>source [unneeded] lineload and
?\ : lineblock>source  ( n1 n2 -- )  blk !  c/l * >in !  ;

  \ doc{
  \
  \ lineblock>source  ( n1 n2 -- )
  \
  \ Set block _n2_ as the current source, starting from its
  \ line _n1_.
  \
  \ }doc

need ?( [unneeded] lineload ?(

: lineload  ( n1 n2 -- )
  dup 0= #-259 ?throw
  nest-source lineblock>source interpret unnest-source  ; ?)

  \ doc{
  \
  \ lineload  ( n1 n2 -- )
  \
  \ Begin interpretation at line _n1_ of block _n2_.
  \
  \ Origin: Forth-83 (Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] load-section ?( need locate
variable loading-section

  \ doc{
  \
  \ loading-section ( -- a )
  \ 
  \ A variable that holds a flag: Is a section of the library
  \ being loaded? This flag is modified by `load-section` and
  \ `end-section`.
  \
  \ See `load-section`, `end-section`.
  \
  \ }doc

: end-section  ( -- )  loading-section off  ;  end-section

  \ doc{
  \
  \ end-section  ( -- )
  \
  \ End a section of the library.
  \
  \ See `load-section`, `loading-section`.
  \
  \ }doc

: load-section  ( "name" -- )
  loading-section on
  blocks locate ?do   loading-section @ 0= ?leave  i load
                loop  end-section  ; ?)

  \ doc{
  \
  \ load-section  ( "name" -- )
  \ 
  \ Load a section of the library, starting from the first
  \ block that has "name" in its header line. Load all
  \ following blocks of the library or until `end-section` is
  \ executed`.
  \
  \ See `end-section`, `loading-section`.
  \
  \ }doc

  \ vim: filetype=soloforth
