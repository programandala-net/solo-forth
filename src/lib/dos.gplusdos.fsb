  \ dos.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201702101849

  \ -----------------------------------------------------------
  \ Description

  \ G+DOS support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016, 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \
  \ 2016-04-11: Start `plusd-in`, plusd-out`, `plusd-in,`,
  \ plusd-out,`.
  \
  \ 2016-04-26: Remove `char`.
  \
  \ 2016-08-04: Remove obsolete words `dosior>error` and
  \ `?dos-error`. Update and fix comments. Fix `(cat)`: the
  \ border was not restored.
  \
  \ 2016-08-10: Move `dosior>ior` to the DOS module of the
  \ kernel.
  \
  \ 2016-12-20: Rename `jpnext` to `jpnext,` after the change
  \ in the kernel.
  \
  \ 2017-01-04: Review the words to page in and page out the
  \ Plus D interface: Use the port to page in, not the hook;
  \ use Z80 opcodes, not `z80-asm`.
  \
  \ 2017-01-04: Compact the code, saving one block.
  \
  \ 2017-01-04: Convert `get-drive` and `set-drive` from
  \ `z80-asm` to `z80-asm,`; make them independent to `need`;
  \ improve their documentation.
  \
  \ 2017-01-05: Convert all assembly words from `z80-asm` to
  \ `z80-asm,`: `(delete-file)`, `(>file)`, `(<file)`,
  \ `(file>screen)`, `(<file-as-is)`, `(file?)`, `(cat)`,
  \ `@dos`, `c@dos`, `c!dos`, `!dos`, `@dosvar`, `c@dosvar`,
  \ `!dosvar`, `c!dosvar`.
  \
  \ 2017-01-05: Update `need z80-asm,` to `need assembler`.
  \
  \ 2017-02-05: Fix needing of `set-drive`.
  \
  \ 2017-02-07: Use `cconstant` for byte constants
  \
  \ 2017-02-08: Update and complete the paging tests `g.100h`
  \ and `g.100i`. Make hook codes individually accessible to
  \ `need`. Improve `set-drive` to return an error result and
  \ move it to the kernel.
  \
  \ 2017-02-09: Improve all the Plus D memory fetch and store
  \ words: smaller and faster. Compact the code, saving 4
  \ blocks.
  \
  \ 2017-02-10: Rename `<file` to `file>`, and `<file-as-is` to
  \ `file-as-is>`.  The new names are consistent with the
  \ convention used in Forth.  Non-standard file words are
  \ being unified in G+DOS, TR-DOS and +3DOS. Add `ufia1` and
  \ `ufia2`.

( plusd-in plusd-out plusd-in, plusd-out, ufia1 ufia2 )

[unneeded] plusd-in
?\ code plusd-in  ( -- )  DB c, #231 c, jpnext,  end-code
  \ in a,(231)
  \ _jp_next

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ See: `plusd-out`, `plusd-in,`.
  \
  \ }doc

[unneeded] plusd-out
?\ code plusd-out  ( -- )  D3 c, #231 c, jpnext,  end-code
  \ out (231),a
  \ _jp_next

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ See: `plusd-in`, `plusd-out,`.
  \
  \ }doc

[unneeded] plusd-in,
?\ need macro  macro plusd-in,  ( -- )  DB c, #231 c,  endm
  \ in a,(231)

  \ doc{
  \
  \ plusd-in,  ( -- )
  \
  \ Compile the Z80 instruction `in a,(231)`, which pages in
  \ the Plus D memory.
  \
  \ See: `plusd-out,`, `plusd-in`.
  \
  \ }doc

[unneeded] plusd-out,
?\ need macro  macro plusd-out,  ( -- )  D3 c, #231 c,  endm
  \ out (231),a

  \ doc{
  \
  \ plusd-out,  ( -- )
  \
  \ Compile the Z80 instruction `out(231),a`, which pages out
  \ the Plus D memory.
  \
  \ See: `plusd-in,`, `plusd-out`.
  \
  \ }doc

[unneeded] ufia1 ?\ $3E01 constant ufia1
  \ G+DOS UFIA1 (in the Plus D memory).

[unneeded] ufia2 ?\ $3E1A constant ufia2
  \ G+DOS UFIA1 (in the Plus D memory).

( ufia )

24 cconstant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1   \ drive: 1 or 2
ufia 1+   constant fstr1   \ program number
ufia 2+   constant sstr1   \ stream number
ufia 3 +  constant device  \ device: "D" or "d"
ufia 4 +  constant nstr1   \ directory description
ufia 5 +  constant nstr2   \ file name
ufia 15 + constant hd00    \ file type
ufia 16 + constant hd0b    \ file length
ufia 18 + constant hd0d    \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

'd' device c!  2 sstr1 c!  1 dstr1 c!
  \ Defaults: device "d" (instead of "D"), stream 2, drive 1

variable file-length  variable file-address
  \ `file-length` holds a copy of `hd0b` used by `(file>)`
  \ `file-address` holds a copy of `hd0d` used by `(file>)`

( --file-types-- )

0 cconstant basic-filetype
1 cconstant data-array-filetype
2 cconstant string-array-filetype
3 cconstant code-filetype

: --file-types--  ;

( hxfer ofsm hofile sbyte hsvbk cfsm pntp cops hgfile lbyte )

  \ Hook codes

[unneeded] hxfer   ?\ $33 cconstant hxfer
[unneeded] ofsm    ?\ $34 cconstant ofsm
[unneeded] hofile  ?\ $35 cconstant hofile
[unneeded] sbyte   ?\ $36 cconstant sbyte
[unneeded] hsvbk   ?\ $37 cconstant hsvbk
[unneeded] cfsm    ?\ $38 cconstant cfsm
[unneeded] pntp    ?\ $39 cconstant pntp
[unneeded] cops    ?\ $3A cconstant cops
[unneeded] hgfile  ?\ $3B cconstant hgfile
[unneeded] lbyte   ?\ $3C cconstant lbyte

( hldbk wsad sad rest heraz cops2 pcat hrsad hwsad otfoc )

  \ Hook codes (continued)

[unneeded] hldbk   ?\ $3D cconstant hldbk
[unneeded] wsad    ?\ $3E cconstant wsad
[unneeded] sad     ?\ $3F cconstant sad
[unneeded] rest    ?\ $40 cconstant rest
[unneeded] heraz   ?\ $41 cconstant heraz
[unneeded] cops2   ?\ $42 cconstant cops2
[unneeded] pcat    ?\ $43 cconstant pcat
[unneeded] hrsad   ?\ $44 cconstant hrsad
[unneeded] hwsad   ?\ $45 cconstant hwsad
[unneeded] otfoc   ?\ $46 cconstant otfoc

( patch --directory-descriptions-- dos-vars )

  \ Hook codes (continued)

[unneeded] patch   ?\ $47 cconstant patch

  \ Directory descriptions

need ?(  [unneeded] --directory-descriptions ?(

01 cconstant basic-file-dir    02 cconstant data-array-dir
03 cconstant string-array-dir  04 cconstant code-file-dir
05 cconstant snapshot-48k-dir  06 cconstant microdrive-file-dir
07 cconstant screens$-file-dir 08 cconstant special-file-dir
09 cconstant snapshot-128k-dir 10 cconstant opentype-file-dir
11 cconstant execute-file-dir

: --directory-descriptions--  ; ?)

[unneeded] dos-vars ?\ 8192 constant dos-vars

  \ doc{
  \
  \ dos-vars  ( -- a )
  \
  \ Address of the G+DOS variables in its own memory.
  \
  \ }doc

( get-drive )

need ?(  [unneeded] get-drive ?(

need assembler  need plusd-in,  need plusd-out,

code get-drive  ( -- n )
  b push,  \ save the Forth IP
  plusd-in, 3ACE fta, plusd-out,
  b pop, next ix ldp#,  \ restore the Forth registers
  pusha jp,  end-code  ?)

  \ XXX TODO check this method:
  \ bit 0 of 3DD1

  \ doc{
  \
  \ get-drive  ( -- n )
  \
  \ Get the current drive _n_ (1 or 2).
  \
  \ See: `set-drive`.
  \
  \ }doc

( delete-file )

need assembler  need ufia  need heraz
need filename>ufia

code (delete-file)  ( -- ior )
  b push,  \ save the Forth registers
  ufia ix ldp#,
  heraz hook,  \ erase the file
  b pop, next ix ldp#,  \ restore the Forth registers
  af push,
  jpnext,
  end-code

  \ doc{
  \
  \ (delete-file)  ( -- ior )
  \
  \ Delete a disk file using the data hold in UFIA.
  \ Return a result code _ior_.
  \
  \ This word is a factor of `delete-file`.
  \
  \ See: `delete-file`, `ufia`.
  \
  \ }doc

: delete-file  ( ca len -- ior )
  filename>ufia (delete-file) dosior>ior  ;

  \ doc{
  \
  \ delete-file  ( ca len -- ior )
  \
  \ Delete the disk file named in the string _ca len_ and
  \ return a result code _ior_.
  \
  \ Origin: Forth-94 (FILE), Forth-2012 (FILE).
  \
  \ See: `(delete-file)`.
  \
  \ }doc

( -filename filename! >ufia filename>ufia )

need ufia  need get-drive

10 cconstant /filename  \ max filename length

  \ doc{
  \
  \ /filename  ( -- b )
  \
  \ A constant that returns the maximum length of a G+DOS
  \ filename.
  \
  \ }doc

: -filename  ( -- )  nstr2 /filename blank  ;

  \ doc{
  \
  \ -filename  ( -- )
  \
  \ Blank the filename in UFIA.
  \
  \ See: `ufia`, `/filename`.
  \
  \ }doc

: filename!  ( ca len -- )
  -filename /filename min nstr2 swap cmove  ;

  \ XXX TODO -- Rename to `filename>ufia`, but rename
  \ `filename>ufia` first!

  \ doc{
  \
  \ filename!  ( ca len -- )
  \
  \ Store a filename _ca len_ into UFIA.
  \
  \ }doc

: >ufia  ( ca1 len1 ca2 len2 -- )
  filename!  dup hd0b !  file-length !
             dup hd0d !  file-address !
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  get-drive dstr1 c!  ;

  \ doc{
  \
  \ >ufia  ( ca1 len1 ca2 len2 -- )
  \
  \ Set UFIA with the memory region _ca1 len1_, which will
  \ be saved or loaded, and filename _ca2 len2_
  \
  \ }doc

1 set-drive throw  \ default drive

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;
  \ XXX TODO -- Rename to `file>ufia`

( >file )

need assembler  need ufia  need >ufia
need hofile  need hsvbk  need cfsm

code (>file)  ( -- ior )

  b push,  \ save the Forth IP
  ufia ix ldp#,
  hofile hook, \ open the file and create its header
  nc? rif \ no error?
    hd0d d ftp, hd0b b ftp,  \ DE=start, BC=length
    hsvbk hook, \ save to file
    nc? rif  cfsm hook,  rthen  \ close the file if no error
  rthen  b pop, next ix ldp#,  \ restore the Forth registers
  af push,  \ ior
  jpnext, end-code
  \ Save a file to disk using the data hold in UFIA
  \ and return error result _ior_.

: >file  ( ca1 len1 ca2 len2 -- ior )
  >ufia (>file) dosior>ior  ;
  \ Save memory region _ca1 len1_ to a file named by the string
  \ _ca2 len2_, and return error result _ior_.

( file> )

need assembler  need ufia  need >ufia
need hgfile  need lbyte  need hldbk

code (file>)  ( -- ior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    hd00 d ldp#, 9 b ld#,  \ destination and count
    rbegin  lbyte hook, d stap, d incp,  rstep
      \ Load the file header.

    file-address d ftp, file-length b ftp,
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    b tstp, z? rif  hd0b b ftp,  rthen  hldbk hook,
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  rthen  b pop, next ix ldp#, af push,
        \ restore the Forth registers and save the ior
  jpnext,  end-code
  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command. Return error result _ior_.

: file>  ( ca1 len1 ca2 len2 -- ior )
  2swap >ufia (file>) dosior>ior  ;

  \ doc{
  \
  \ file>  ( ca1 len1 ca2 len2 -- ior )
  \
  \ }doc

  \ Load a memory region _ca1 len1_ from file _ca2 len2_
  \ and return error result _ior_.

( file>screen )

  \ XXX UNDER DEVELOPMENT
  \ Experimental code to read lines from a file

need assembler  need ufia  need >ufia
need hgfile  need lbyte

code (file>screen)  ( -- dosior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    patch hook, 4000 d ldp#, #128 b ldp#,
      \ page in the Plus D memory
      \ destination and count

    d h ld,
    rbegin   lbyte hook, d stap,
            a l ld, d push, b push, 1744 call, b pop, d pop,
              \ print HL
            d incp, b decp, b a ld, c or,
    z? runtil  E7 out,  \ page out the Plus D memory
    \ rbegin
    \   lbyte hook,  af push,  10 hook,  af pop,  13 cp#,
    \ z runtil

  rthen  b pop, next ix ldp#, af push,
        \ restore the Forth registers and save the ior
  jpnext,  end-code -->
  \ Print a file on the screen, line by line, using the data
  \ hold in UFIA.


( file>screen )

: file>screen  ( ca len -- ior )
  >ufia (file>screen) dosior>ior  ;
  \ Copy a file _ca len_ to the screen, line by line,
  \ and return error result _ior_.

( g.100h g.100i )

  \ XXX TMP -- for debugging

need assembler  need plusd-in,  need plusd-out,  need patch

code g.100h  ( u -- )
  h pop, b push,
  h push, patch hook, h pop, 1744 call, plusd-out,
  b pop,  next ix ldp#,  jpnext, end-code
  \ Print _u_ using a routine of the Plus D ROM, paging it
  \ with a hook.

code g.100i  ( u -- )
  h pop, b push,
  plusd-in, 1744 call, plusd-out,
  b pop,  next ix ldp#,  jpnext, end-code
  \ Print _u_ using a routine of the Plus D ROM, paging it
  \ with an `in` instruction.

( file-as-is> )

need assembler  need ufia  need >ufia
need hgfile  need lbyte  need hldbk

code (file-as-is>)  ( -- ior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    hd00 d ldp#, 9 b ld#,  \ destination and count
    rbegin  lbyte hook, d stap, d incp,  rstep
      \ Load the file header.

    hd0d d ftp, hd0b b ftp, hldbk hook,
      \ Use the address and length from the header.
      \ Then load the file data.

  rthen  b pop, next ix ldp#, af push,
        \ Restore the Forth registers and save the ior.

  jpnext,  end-code
  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

: file-as-is>  ( ca len -- ior )
  0 0 2swap >ufia (file-as-is>) dosior>ior  ;
  \ Load a file _ca len_ from disk, returning the error result
  \ _ior_.

( file? )

need assembler need ufia  need filename!  need patch

code (file?)  ( -- f )
  b push,  \ save the Forth IP
  patch hook,
  nstr2 ix ldp#,
  1146 call,  \ FIND_FILE
  168E call,  \ BORD_REST = restore the border
  E7 out,  \ page out the Plus D memory
  b pop, next ix ldp#,  \ restore the Forth registers
  ' true z? ?jp,
  ' false jp,
  end-code
  \ Does the file whose name is stored in UFIA exist?

: file?  ( ca len -- f )  filename! (file?)  ;
  \ Does file _ca len_ exist?

( cat acat wcat wacat )

need assembler
need ufia  need ufia1  need filename>ufia  need patch

code (cat)  ( n -- )

  h pop, b push, exx,
    \ Get the parameter in hl' and save the Forth IP

  patch hook,

  ufia h ldp#, ufia1 d ldp#, /ufia b ldp#, ldir,
    \ Copy Forth UFIA to G+DOS UFIA1.

  \ exx  l a ld  24B5 call  168E call \ XXX OLD
    \ 24B5 = CAT_RUN (input: cat type in the A register)
    \ 168E = BORD_REST (restore the border)

  exx, l a ld, 09A5 call, 168E call,
    \ 09A5 = SCAN_CAT  (input: cat or search type in the A register)
    \ 168E = BORD_REST (restore the border)

  E7 out, b pop, next ix ldp#,
    \ page out the Plus D memory
    \ restore the Forth registers and exit
  jpnext,  end-code
  \ Show a catalogue of the current disk, of type _n_
  \ (2=compact; 4=detailed).  This word is the low-level common
  \ factor of all words that show disk catalogues.

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a wild-cald disk catologue using the wild-card
  \ filename _ca len_.  See the Plus D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ Show a wild-cald abbreviated disk catologue using the
  \ wild-card filename _ca len_.  See the Plus D manual for
  \ wild-card syntax.  See the Plus D manual for wild-card syntax.

: cat  ( -- )  s" *" wcat  ;
  \ Show a disk catalogue.

: acat  ( -- )  s" *" wacat ;  decimal
  \ Show an abbreviated disk catologue.

  \ XXX REMARK -- The disk catalogues can be printed out on a
  \ printer by storing the number 3 into SSTR1 (a field of UFIA
  \ that holds the stream number to use) before doing `CAT`.
  \ The default value is 2 (screen) and should be restored.
  \ Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos c@dos  )

need ?(

[unneeded] @dos ?(

need assembler  need plusd-in,  need plusd-out,

code @dos  ( a -- x )
  h pop, plusd-in, m e ld, h incp, m d ld,
         plusd-out, d push, jpnext, end-code ?)
  \ doc{
  \
  \ @dos  ( a -- x )
  \
  \ Fetch the cell _x_ stored at Plus D memory address _a_.
  \
  \ See: `!dos`, `c@dos`.
  \
  \ }doc

[unneeded] c@dos ?(

need assembler  need plusd-in,  need plusd-out,

code c@dos  ( ca -- b )
  h pop, plusd-in, m a ld,
         plusd-out, pusha jp, end-code ?)

  \ doc{
  \
  \ c@dos  ( ca -- b )
  \
  \ Fetch byte _b_ stored at Plus D memory address _ca_.
  \
  \ See: `c!dos`, `@dos`.
  \
  \ }doc

( !dos c!dos )

need ?(

[unneeded] !dos ?(

need assembler  need plusd-in,  need plusd-out,

code !dos  ( x a -- )
  h pop, d pop, plusd-in, e m ld, h incp, d m ld,
                plusd-out, jpnext, end-code ?)
  \ doc{
  \
  \ !dos  ( x a -- )
  \
  \ Store _x_ at the Plus D memory address _a_.
  \
  \ See: `@dos`, `c!dos`.
  \
  \ }doc

[unneeded] c!dos ?(

need assembler  need plusd-in,  need plusd-out,

code c!dos  ( b ca -- )
  h pop, d pop, plusd-in, e m ld,
                plusd-out, jpnext, end-code ?)

  \ doc{
  \
  \ c!dos  ( b ca -- )
  \
  \ Store _b_ at the Plus D memory address _ca_.
  \
  \ See: `c@dos`, `!dos`.
  \
  \ }doc


( @dosvar c@dosvar )

need ?(

[unneeded] @dosvar ?(

need assembler  need dos-vars  need plusd-in,  need plusd-out,

code @dosvar  ( n -- x )
  h pop,
  plusd-in, dos-vars d ldp#, d addp, m e ld, h incp, m d ld,
  plusd-out, d push, jpnext, end-code ?)

  \ doc{
  \
  \ name  ( -- )
  \
  \ Fetch the contents _x_ of G+DOS variable _n_.
  \
  \ See: `!dosvar`, `c@dosvar`, `!dos`.
  \
  \ }doc

[unneeded] c@dosvar ?(

need assembler  need dos-vars  need plusd-in,  need plusd-out,

code c@dosvar  ( n -- b )
  h pop, plusd-in, dos-vars d ldp#, d addp, m a ld,
         plusd-out, pusha jp, end-code ?)

  \ doc{
  \
  \ c@dosvar  ( n -- b )
  \
  \ Fetch the contents _b_ of G+DOS variable _n_.
  \
  \ See: `c!dosvar`, `c!dosvar`, `@dos`.
  \
  \ }doc

( !dosvar c!dosvar )

need ?(

[unneeded] !dosvar ?(

need assembler  need dos-vars  need plusd-in,  need plusd-out,

code !dosvar  ( x n -- )
  h pop, plusd-in, dos-vars d ldp#, d addp,
                   d pop, e m ld, h incp, d m ld,
         plusd-out, jpnext, end-code ?)

  \ doc{
  \
  \ !dosvar  ( x n -- )
  \
  \ Store _x_ into the G+DOS variable _n_.
  \
  \ See: `@dosvar`, `c!dosvar`, `!dos`.
  \
  \ }doc

[unneeded] c!dosvar ?(

need assembler  need dos-vars  need plusd-in,  need plusd-out,

code c!dosvar  ( b n -- )
  h pop, plusd-in, dos-vars d ldp#, d addp, d pop, e m ld,
                   plusd-out, jpnext, end-code ?)

  \ doc{
  \
  \ c!dosvar  ( b n -- )
  \
  \ Store _b_ into the G+DOS variable _n_.
  \
  \ See: `c@dosvar`, `!dosvar`, `c!dos`.
  \
  \ }doc

  \ vim: filetype=soloforth
