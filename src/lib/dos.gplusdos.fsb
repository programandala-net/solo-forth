  \ dos.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201702051219

  \ -----------------------------------------------------------
  \ Description

  \ G+DOS support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016, 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \
  \ 2016-04-11: Start `plusd-in`, plusd-out`, `plusd-in,`,
  \ plusd-out,`.
  \
  \ 2016-04-26: Remove `char`.
  \
  \ 2016-08-04: Remove obsolete words `dosior>error` and
  \ `?dos-error`. Update and fix comments. Fix `(cat)`: the
  \ border was not restored.
  \
  \ 2016-08-10: Move `dosior>ior` to the DOS module of the
  \ kernel.
  \
  \ 2016-12-20: Rename `jpnext` to `jpnext,` after the change
  \ in the kernel.
  \
  \ 2017-01-04: Review the words to page in and page out the
  \ Plus D interface: Use the port to page in, not the hook;
  \ use Z80 opcodes, not `z80-asm`.
  \
  \ 2017-01-04: Compact the code, saving one block.
  \
  \ 2017-01-04: Convert `get-drive` and `set-drive` from
  \ `z80-asm` to `z80-asm,`; make them independent to `need`;
  \ improve their documentation.
  \
  \ 2017-01-05: Convert all assembly words from `z80-asm` to
  \ `z80-asm,`: `(delete-file)`, `(>file)`, `(<file)`,
  \ `(file>screen)`, `(<file-as-is)`, `(file?)`, `(cat)`,
  \ `@dos`, `c@dos`, `c!dos`, `!dos`, `@dosvar`, `c@dosvar`,
  \ `!dosvar`, `c!dosvar`.
  \
  \ 2017-01-05: Update `need z80-asm,` to `need assembler`.
  \
  \ 2017-02-05: Fix needing of `set-drive`.

( plusd-in plusd-out plusd-in, plusd-out, )

[unneeded] plusd-in
?\ code plusd-in  ( -- )  DB c, #231 c, jpnext,  end-code

  \ XXX OLD
  \ need --hook-codes--
  \ code plusd-in  ( -- )  CF c, patch c, jpnext,  end-code
  \   \ rst $08
  \   \ defb patch
  \   \ jp (ix)

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ }doc

[unneeded] plusd-out
?\ code plusd-out  ( -- )  D3 c, #231 c, jpnext,  end-code
  \ out (231),a
  \ jp (ix)

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ }doc

[unneeded] plusd-in,
?\ need macro  macro plusd-in,  ( -- )  DB c, #231 c,  endm
  \ in a,(231)

  \ doc{
  \
  \ plusd-in,  ( -- )
  \
  \ Compile machine code to page in the Plus D memory.
  \
  \ }doc

[unneeded] plusd-out,
?\ need macro  macro plusd-out,  ( -- )  D3 c, #231 c,  endm
  \ out (231),a

  \ doc{
  \
  \ plusd-out,  ( -- )
  \
  \ Compile machine code to page out the Plus D memory.
  \
  \ }doc

( ufia )

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1   \ drive: 1 or 2
ufia 1+   constant fstr1   \ program number
ufia 2+   constant sstr1   \ stream number
ufia 3 +  constant device  \ device: "D" or "d"
ufia 4 +  constant nstr1   \ directory description
ufia 5 +  constant nstr2   \ file name
ufia 15 + constant hd00    \ file type
ufia 16 + constant hd0b    \ file length
ufia 18 + constant hd0d    \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

'd' device c! \ "d" or "D"
2 sstr1 c!  \ stream 2
1 dstr1 c!  \ drive 1

variable file-length   \ copy of `hd0b` used by `(<file)`
variable file-address  \ copy of `hd0d` used by `(<file)`

( --file-types-- )

0 constant basic-filetype
1 constant data-array-filetype
2 constant string-array-filetype
3 constant code-filetype

: --file-types--  ;

( --directory-descriptions-- )

01 constant basic-file-dir      02 constant data-array-dir
03 constant string-array-dir    04 constant code-file-dir
05 constant snapshot-48k-dir    06 constant microdrive-file-dir
07 constant screens$-file-dir   08 constant special-file-dir
09 constant snapshot-128k-dir   10 constant opentype-file-dir
11 constant execute-file-dir

: --directory-descriptions--  ;

( --hook-codes-- )

$33 constant hxfer  $34 constant ofsm  $35 constant hofile
$36 constant sbyte  $37 constant hsvbk $38 constant cfsm
$39 constant pntp   $3A constant cops  $3B constant hgfile
$3C constant lbyte  $3D constant hldbk $3E constant wsad
$3F constant sad    $40 constant rest  $41 constant heraz
$42 constant cops2  $43 constant pcat  $44 constant hrsad
$45 constant hwsad  $46 constant otfoc $47 constant patch

: --hook-codes--  ;

( get-drive set-drive )

need ?(

[unneeded] get-drive ?(

need assembler  need plusd-in,  need plusd-out,

code get-drive  ( -- n )
  b push,  \ save the Forth IP
  plusd-in, 3ACE fta, plusd-out,
  b pop, next ix ldp#,  \ restore the Forth registers
  pusha jp,  end-code  ?)

  \ XXX TODO check this method:
  \ bit 0 of 3DD1

  \ doc{
  \
  \ get-drive  ( -- n )
  \
  \ Get the current drive _n_ (1 or 2).
  \
  \ }doc

[unneeded] set-drive ?(  need assembler

code set-drive  ( n -- )
  h pop, b push,
  l a ld, 21 hook,   \ select drive in a
  b pop, next ix ldp#,  \ restore the Forth registers
  jpnext,  end-code ?)

  \ doc{
  \
  \ set-drive  ( n -- )
  \
  \ Set the current drive _n_ (1 or 2).
  \
  \ }doc

( delete-file )

need assembler  need ufia  need --hook-codes--
need filename>ufia

code (delete-file)  ( -- ior )
  b push,  \ save the Forth registers
  ufia ix ldp#,
  heraz hook,  \ erase the file
  b pop, next ix ldp#,  \ restore the Forth registers
  af push,
  jpnext,
  end-code
  \ Delete a disk file using the data hold in UFIA.
  \ Return a G+DOS _ior_.

: delete-file  ( ca len -- ior )
  filename>ufia (delete-file) dosior>ior  ;
  \ Delete a disk file _ca len_ and return I/O result code
  \ _ior_.

( -filename filename! >ufia filename>ufia )

need ufia  need get-drive

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  -filename /filename min nstr2 swap cmove  ;
  \ Store a filename _ca len_ into UFIA.
  \ XXX TODO -- rename to `set-filename`?

: >ufia  ( ca1 len1 ca2 len2 -- )
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  get-drive dstr1 c!  ;
  \ Set the UFIA with the memory region _ca1 len1_, which will
  \ be saved or loaded, and filename _ca2 len2_

1 set-drive  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need assembler  need ufia  need --hook-codes--  need >ufia

code (>file)  ( -- ior )

  b push,  \ save the Forth IP
  ufia ix ldp#,
  hofile hook, \ open the file and create its header
  nc? rif \ no error?
    hd0d d ftp, hd0b b ftp,  \ DE=start, BC=length
    hsvbk hook, \ save to file
    nc? rif  cfsm hook,  rthen  \ close the file if no error
  rthen  b pop, next ix ldp#,  \ restore the Forth registers
  af push,  \ ior
  jpnext, end-code
  \ Save a file to disk using the data hold in UFIA
  \ and return error result _ior_.

: >file  ( ca1 len1 ca2 len2 -- ior )
  >ufia (>file) dosior>ior  ;
  \ Save memory region _ca1 len1_ to a file with name _ca2
  \ len2_, and return error result _ior_.

( <file )

need assembler  need ufia  need --hook-codes--  need >ufia

code (<file)  ( -- ior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    hd00 d ldp#, 9 b ld#,  \ destination and count
    rbegin  lbyte hook, d stap, d incp,  rstep
      \ Load the file header.

    file-address d ftp, file-length b ftp,
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    b tstp, z? rif  hd0b b ftp,  rthen  hldbk hook,
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  rthen  b pop, next ix ldp#, af push,
        \ restore the Forth registers and save the ior
  jpnext,  end-code
  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command. Return error result _ior_.

: <file  ( a1 len1 ca2 len2 -- ior )
  >ufia (<file) dosior>ior  ;
  \ Load a memory region _ca1 len1_ from file _ca2 len2_
  \ and return error result _ior_.

( file>screen )

  \ XXX UNDER DEVELOPMENT
  \ Experimental code to read lines from a file

need assembler  need ufia  need --hook-codes--  need >ufia

code (file>screen)  ( -- dosior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    patch hook, 4000 d ldp#, #128 b ldp#,
      \ page +D in
      \ destination and count

    d h ld,
    rbegin   lbyte hook, d stap,
            a l ld, d push, b push, 1744 call, b pop, d pop,
              \ print HL
            d incp, b decp, b a ld, c or,
    z? runtil  E7 out,  \ page +D out
    \ begin
    \   lbyte hook  af push  10 hook  af pop  13 cp
    \ z until

  rthen  b pop, next ix ldp#, af push,
        \ restore the Forth registers and save the ior
  jpnext,  end-code -->
  \ Print a file on the screen, line by line, using the data
  \ hold in UFIA.


( file>screen )

: file>screen  ( ca len -- ior )
  >ufia (file>screen) dosior>ior  ;
  \ Copy a file _ca len_ to the screen, line by line,
  \ and return error result _ior_.

( .100 )

  \ XXX TMP -- for debugging

code .100  ( u -- )
  hl pop
  bc push
  hl push
  patch hook
  hl pop
  1744 call
  E7 out  \ page +D out
  bc pop  next ix ldp#  jpnext,
  end-code

( <file-as-is )

need assembler  need ufia  need --hook-codes--  need >ufia

code (<file-as-is)  ( -- ior )

  b push,  \ save the Forth IP

  ufia ix ldp#, hgfile hook,  \ get the file
  nc? rif  \ no error?  -- load the file header:

    hd00 d ldp#, 9 b ld#,  \ destination and count
    rbegin  lbyte hook, d stap, d incp,  rstep
      \ Load the file header.

    hd0d d ftp, hd0b b ftp, hldbk hook,
      \ Use the address and length from the header.
      \ Then load the file data.

  rthen  b pop, next ix ldp#, af push,
        \ Restore the Forth registers and save the ior.

  jpnext,  end-code
  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

: <file-as-is  ( ca len -- ior )
  0 0 2swap >ufia (<file-as-is) dosior>ior  ;
  \ Load a file _ca len_ from disk, returning the error result
  \ _ior_.

( file? )

need assembler need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )
  b push,  \ save the Forth IP
  patch hook,
  nstr2 ix ldp#,
  1146 call,  \ FIND_FILE
  168E call,  \ BORD_REST = restore the border
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  ' true z? ?jp,
  ' false jp,
  end-code
  \ Does the file whose name is stored in UFIA exist?

: file?  ( ca len -- f )  filename! (file?)  ;
  \ Does file _ca len_ exist?

( cat acat wcat wacat )

need assembler  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ $3E01 constant ufia1
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  h pop, b push, exx,
    \ Get the parameter in hl' and save the Forth IP

  patch hook,

  ufia h ldp#, ufia1 d ldp#, /ufia b ldp#, ldir,
    \ Copy Forth UFIA to G+DOS UFIA1.

  \ exx  l a ld  24B5 call  168E call \ XXX OLD
    \ 24B5 = CAT_RUN (input: cat type in the A register)
    \ 168E = BORD_REST (restore the border)

  exx, l a ld, 09A5 call, 168E call,
    \ 09A5 = SCAN_CAT  (input: cat or search type in the A register)
    \ 168E = BORD_REST (restore the border)

  E7 out, b pop, next ix ldp#,
    \ page +D out
    \ restore the Forth registers and exit
  jpnext,  end-code
  \ Show a catalogue of the current disk, of type _n_
  \ (2=compact; 4=detailed).  This word is the low-level common
  \ factor of all words that show disk catalogues.

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a wild-cald disk catologue using the wild-card
  \ filename _ca len_.  See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ Show a wild-cald abbreviated disk catologue using the
  \ wild-card filename _ca len_.  See the +D manual for
  \ wild-card syntax.  See the +D manual for wild-card syntax.

: cat  ( -- )  s" *" wcat  ;
  \ Show a disk catologue.

: acat  ( -- )  s" *" wacat ;  decimal
  \ Show an abbreviated disk catologue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need assembler  need --hook-codes--

code @dos  ( a -- n )
  h pop,
  b push,  \ save the Forth IP
  h push,
  patch hook,
  h pop, m e ld, h incp, m d ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  d push,
  jpnext,
  end-code
  \ Fetch the content of +D memory address.

( c@dos )

need assembler  need --hook-codes--

code c@dos  ( a -- b )
  h pop,
  b push,  \ save the Forth IP
  h push,
  patch hook,
  h pop,
  m a ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  pusha jp,
  end-code
  \ Fetch the content of +D memory address.

( c!dos )

need assembler  need --hook-codes--

code c!dos  ( b a -- )
  h pop, d pop,
  b push,  \ save the Forth IP
  d push, h push,
  patch hook,
  h pop, d pop, e m ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  jpnext,
  end-code
  \ Store b into the +D memory address a.

( !dos )

need assembler  need --hook-codes--

code !dos  ( n a -- )
  h pop, d pop,
  b push,  \ save the Forth IP
  d push, h push,
  patch hook,
  h pop, d pop, e m ld, h incp, d m ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  jpnext,
  end-code
  \ Store _n_ into the +D memory address _a_.

( @dosvar )

need assembler  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  h pop,
  b push,  \ save the Forth IP
    \ XXX TODO use exx instead?
  h push,
  patch hook,
  h pop, dos-vars d ldp#, d addp,
  m e ld, h incp, m d ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  d push,
  jpnext,
  end-code
  \ Fetch the content _n2_ of G+DOS variable _n1_.

( c@dosvar )

need assembler  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  h pop,
  b push,  \ save the Forth IP
  h push,
  patch hook,
  h pop, dos-vars d ldp#, d addp,
  m a ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  pusha jp,

  end-code
  \ Fetch the content _b_ of G+DOS variable _n_.

( !dosvar )

need assembler  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  h pop, d pop,
  b push,  \ save the Forth IP
  d push, h push,
  patch hook,
  h pop, dos-vars d ldp#, d addp, d pop,
  e m ld, h incp, d m ld,
  E7 out,  \ page +D out
  b pop, next, ix, ldp#,  \ restore the Forth registers
  jpnext,
  end-code
  \ Store _n1_ into the G+DOS variable _n2_.

( c!dosvar )

need assembler  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  h pop, d pop,
  b push,  \ save the Forth IP
  d push, h push,
  patch hook,
  h pop, dos-vars d ldp#, d addp, d pop,
  e m ld,
  E7 out,  \ page +D out
  b pop, next ix ldp#,  \ restore the Forth registers
  jpnext,
  end-code
  \ Store _b_ into the G+DOS variable _n_.

  \ vim: filetype=soloforth
