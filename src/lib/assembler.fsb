  \ assembler.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains two versions of a Z80 assembler, and
  \ some related words.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( z80-asm, )

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.
  \
  \ 2015-12-25 First changes:
  \
  \ 1. "," suffixes in Z80 instructions;
  \ 2. one single set of conditions;
  \ 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".

  \ XXX TODO
  \
  \ - combine changes 2..4 with the previous version.
  \ - rename `|mark` and `|resolve`
  \ - remove all "retCOND" and "callCOND" and "jpCOND"
  \   (or make them optional
  \ - make absolute-jump control structures optional.
  \

  \ Z80 assembler for Solo Forth

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).

  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm, -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  create c, does>  ( -- )  ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- )
  create , does>  ( -- )  ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;
  \ Relative jumps.

-->

( z80-asm, -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, -- opcodes)

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 20 m9 jrnz,
22 m5 sthl, 27 m1 daa, 28 m9 jrz, 2A m5 fthl, 2F m1 cpl, 30 m9
jrnc, 32 m5 sta, 37 m1 scf, 38 m9 jrc, 3A m5 fta, 3F m1 ccf, 76
m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98 m2 sbc, B8 m2 cp,
C1 m3 pop, C2 m5 jpnz, C3 m5 jp, C5 m3 push, C6 m4 add#, C7 m2
rst, C9 m1 ret, CA m5 jpz, CD m5 call, CE m4 adc#, D2

-->

( z80-asm, -- opcodes)

m5 jpnc, D3 m4 out, 41 m3 outbc, D6 m4 sub#, D9 m1 exx, DA m5
jpc, DB m4 in, 40 m3 inbc, 0DE m4 sbc#, E2 m5 jppo, E3 m1
exsp, E6 m4 and#, E9 m1 jphl, EA m5 jppe, EB m1 exde, EE m4
xor#, F2 m5 jpp, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FA m5 jpm,
FB m1 ei, FE m4 cp#, 00 m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6
rr, 20 m6 sla,  28 m6 sra, 38 m6 srl,  40 m7 bit, 80 m7 res, C0
m7 set, B0ED m8 ldir, B8ED m8 lddr, 44ED m8 neg, 57ED m8 ldai,
47ED m8 ldia, 56ED m8 im1 5EED m8 im2 B1ED m8 cpir, 6FED m8
rld,

-->

( z80-asm, -- opcodes)

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ldp#,  ;
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;

  \ ZX Spectrum specific

CF m4 hook, \ rst 0x08
D7 m1 prt,  \ rst 0x16

-->

( z80-asm, -- index register opcodes)

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, -- conditions)

  \ Conditions are Z80 opcodes for the required jump
  \ instruction.
  \
  \ Example: `z aif` compiles a `jp nz`, so `z` is the code for
  \ `jp nz`.
  \
  \ Control structures that compile relative jumps modify the
  \ opcode accordingly. Example: `z rif` compiles a `jr nz `

C2 constant z  CA constant nz D2 constant cy DA constant nc
E2 constant pe EA constant po F2 constant ne  FA constant p

  \ XXX FIXME condition `m` has been renamed to `ne` because of
  \ the register `m`; but maybe all registers should be
  \ renamed.
  \ XXX TODO ne->ns and p->ps

: jp>jr  ( op1 -- op2 )  dup nc > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

-->

( z80-asm, -- conditional ret and call)

  \ Conditional ret

: ?ret,  ( op -- )  8 xor 2- c,  ;

: retc,  ( -- )  cy ?ret,  ;    : retnc,  ( -- )  nc ?ret,  ;
: retz,  ( -- )  z ?ret,  ;     : retnz,  ( -- )  nz ?ret,  ;
: retm,  ( -- )  ne ?ret,  ;     : retp,  ( -- )  p ?ret,  ;
: retpe,  ( -- )  pe ?ret,  ;   : retpo,  ( -- )  po ?ret,  ;

  \ Conditional call

: ?call,  ( a op -- )  8 xor 2+ c, ,  ;

: callc,  ( -- )  cy ?call, ;
: callnc,  ( -- )  nc ?call,  ;
: callz,  ( -- )  z ?call, ;
: callnz,  ( -- )  nz ?call,  ;
: callm,  ( -- )  ne ?call, ;
: callp,  ( -- )  p ?call,  ;
: callpe,  ( -- )  pe ?call, ;
: callpo, ( -- )  po ?call,  ;

-->

( z80-asm, -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, -- control structures with relative jumps)

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr , >relmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: relse  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`

( z80-asm, -- control structures with absolute jumps)

  \ XXX TODO document

: aif  (  op -- orig cs-id )  c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ C3 = opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm, -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and,  B0 m2 or,  A8 m2 xor,

  \ Macro, 16-bit subtract:
: subp,  ( rp -- )  a and sbcp,  ;

  \ Macro to test 16-bit register for zero:
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;

-->

( z80-asm, -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( z80-asm )

\ Z80 assembler for Solo Forth

  \ XXX NOTE: first version

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).


  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm -- opcodes)

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm -- index register opcodes)

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( calc end-calc )

need z80-asm

  \ current @  also assembler definitions
  \ XXX OLD
  \ XXX TODO

macro calc  ( -- )  exx EF c,  endm
  \ 0xEF = `rst 0x28`, call the ROM calculator

macro end-calc  ( -- )  38 c, exx  next ix ldp  endm
  \ 0x38 = ROM calculator `end-calc` command
  \
  \ XXX TODO It seems IX is not used by the calculator,
  \ so this code will work:
  \ macro end-calc  ( -- )  38 c, exx  endm

  \ current !  previous
  \ XXX OLD
  \ XXX TODO

( << >> )

  \ For dumping assembled code to screen.

  \ Credits:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credits:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

macro execute-hl  ( -- )
  here 6 + bc ldp#  \ point IP to phony_compiled_word
  jphl          \ execute the xt in HL
  \ phony_compiled_word:
  here cell+ ,      \ point to the phony xt following
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt  ( xt -- )
  hl ldp#  execute-hl
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
