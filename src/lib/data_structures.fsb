  \ data_structures.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains words to create data structures.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( associative: )

  \ Credits:
  \
  \ Code adapted from F83.

: associative:  ( n -- )
  \ Create a table lookup word.
  \ n = number of entries in the table
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \
  \ 1000 constant zx1  200 constant zx2  30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

( associative-list )

  \ Credits:
  \
  \ Based on code written by Wil Baden, published on: Forth
  \ Dimensions (volume 17, number 4, page 11, 1995-11).

  \ XXX UNDER DEVELOPMENT

need words  need abort"

: associative-list  ( "name" -- )  wordlist constant  ;

: entry  ( ca len wid "name" -- )
  current @ >r current !  create  s,  r> current !
  does>  ( -- ca len )  ( pfa ) count  ;

: item?  ( ca len -- 0 | xt )
  search-wordlist dup if  drop  then  ;

: item  ( ca1 len1 wid -- ca2 len2 )
  item? dup 0= abort" Not an item." execute  ;

: items  ( wid -- )  >order words previous  ;

( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

( buffer: cvariable enum )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;

( value to )

  \ Origin: Forth-94.

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone !
                     else  !  then  ; immediate

( 2value 2to )

  \ Implementation of `2value` (from Forth-2012) but with
  \ the non-standard word `2to`

: 2value  ( d "name"  -- )  2constant  ;

: 2to  ( Interpretation: d "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone 2!
                     else  2!  then  ; immediate

( cvalue cto )

: cvalue  ( b "name"  -- )  cconstant  ;

: cto  ( Interpretation: b "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone c!
                       else  c!  then  ; immediate

( value 2value to )

  \ Origin: Forth-2012.

  \ This Forth-2012 implementation of `to` is provided as an
  \ alternative, but it's bigger and slower than the Forth-94
  \ `to` and the non-standard `2to`.

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;
: 2value  ( n "name"  -- )  create  1 c, , ,  does> 1+ 2@  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

( value to )

  \ Non-standard implementation of `value` with non-parsing
  \ `to`. This could be useful in special cases.

  \ Credits:
  \
  \ Code inspired by lina.

variable (value)  ['] @ (value) !
: to    ( -- )  ['] ! (value) !  ;
: value  ( n "name" -- )
  create ,  does>   (value) perform  ['] @ (value) !  ;

( set )

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

  \ doc{
  \
  \ set  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will  cause  the
  \ value _x_  to be stored at _a_.
  \
  \ Origin: Forth-79 (Reference Word Set); Forth-83 (Appendix
  \ B.  Uncontrolled Reference Words).
  \
  \ }doc

( link@ link, )

  \ 2015-11-15

  \ Credits:
  \
  \ Code written after the description by Rick VanNorman,
  \ published on Forth Dimensions (volume 20, number 3, pages
  \ 19-22, 1998-09).

defer link@  ( node1 -- node2 )
  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

( [switch switch] )

  \ 2015-11-15

  \ Credits:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default xt
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched xt. If no match is found, leave _n_ on
  \ the stack and execute the default xt.

: :switch  ( xt "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _xt_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head xt n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _xt_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the xt of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

: run:  ( head n "ccc<semicolon>" -- )
  :noname [char] ; parse evaluate postpone ; ( xt )
  swap >switch  ;

( [switch-test ) \ without syntactic sugar

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test ) \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( user )

  \ XXX UNDER DEVELOPMENT -- improved version, which uses the
  \ first free offset.

  \ doc{
  \
  \ user  ( +n "name" -- )
  \
  \ Create a user variable _name_.  _+n_ is the offset within
  \ the user area where the value for _name_ is stored.
  \ Execution of _name_ leaves its absolute user area storage
  \ address.
  \
  \ Origin: Forth-79, Forth-83.
  \
  \ }doc

: user  ( n "name -- )
  create c,  does>  c@ up @ +  ;

exit

: user  ( n "name -- )
  cconstant
  ;code asm
  de incp  \ de=pfa
  exde
  m e ld
  00 d ld#  \ de = index of the user variable
  up fthl \ ld hl,(user_variables_pointer) \ XXX FIXME
  de addp  \ hl= address of the user variable
  jppushhl  end-asm

( 1array ) \ noble-arrays

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble

  \ 2015-11-15

  \ ---------------------------------------------------
  \ (c) Copyright 2001 Julian V. Noble. \
  \ Permission is granted by the author to \
  \ use this software for any application pro- \
  \ vided this copyright notice is preserved. \
  \ ---------------------------------------------------

  \ ...........................................................
  \ References:
  \
  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ ...........................................................
  \ Description:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ Implementation:

  \ words for 1-dimensional arrays

need <=

: long ; immediate

: 1array ( len #bytes/datum --) \ ( #b len data ...)
  create 2dup , , * allot ;

: _len ( base_addr -- len)  cell+ @ ;
  \ determine length of an array

: } ( base_adr indx -- adr[indx] )
  over _len over <= over 0< or #-272 ?throw
    \ #-272 = array index out of range
  over @ * + cell+ cell+ ;

( 2array ) \ noble-arrays

  \ words for 2-dimensional arrays

need 1array

: wide ; immediate

: 2array ( hgt wid data_size --) \ ( wid #b len data ...)
  create >r tuck , ( wid hgt)
  r@ , * dup , r> * allot ;

: }} ( base_adr m n -- adr[m,n] ) \ data stored row-wise
  2>r cell+ dup cell- @
  r> * r> + ( base_adr+cell m+n*w)
  } ;

  \ ...........................................................
  \ Usage examples:

  \ 20 long 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 long 20 wide 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 long 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

( array ato ) \ wong-arrays )

  \ One-dimensional arrays by Leo Wong

  \ 2015-11-15

  \ ...........................................................
  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ ...........................................................
  \ Description:

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ ...........................................................
  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of array array> ato +ato. A Flight
  \ scripter would not be expected to implement these words.

  \ ...........................................................
  \ Sample implementation:

need within

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

( xstack )

  \ Credits:
  \
  \ Code adapted from Galope (xstack module).

  \ Creation and core manipulation of xstacks

need value  need allocate  need free

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- )
    \ Make an xstack the current one.
    ( pfa ) dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: xfree  ( -- )  xp0 free throw  ;

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

need xstack

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( 2x@ 2>x 2x> 2xdrop 2xdup )

  \ xstack double-number operations

need xstack  need x@  need >x  need xpick  need xover

: 2x@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: 2xdrop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: 2xdup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xdepth .x )

  \ xstack tools

need xstack

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the right-most item.
: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack,
  \ followed by a list of the items, if any; TOS is the right-most item.

  \ vim: filetype=soloforth
