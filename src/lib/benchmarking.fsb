  \ benchmarking.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains benchmarking tools.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

  \ -------------------------------------------------------------
  \ Description

  \ This file contains generic benchmarks and benchmarking
  \ tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in the file <development_benchmarks.fsb>.

( bench{ }bench }bench. bench. benched )

  \ Credits:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

  \ XXX OLD
  \ : sec.  ( n -- )  s>d <# # # [char] . hold #s #> type  ;

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

exit

  \ System-dependent timing routines.
  \ XXX UNDER DEVELOPMENT

  \ Original code.

  \ This is the ForthCMP/ZEN/ANS version.
  \ Output doubles are seconds since midnight.

: t>b  ( sec min hour -- d )  60 * +  60 um*  rot s>d d+  ;

: bench{  ( -- d )  cr get-time t>b 2dup d.  ;
  \ start timing

: }bench  ( d -- )  get-time t>b 2dup d. d- dnegate d.   ;
  \ stop timing

( do-prime )

  \ Eratosthenes Sieve Prime Number program in Forth
  \ by Jim Gilbreath, BYTE Magazine, 1981-09, page 190.

forth definitions decimal

8190 constant size  variable flags  size allot

: do-prime  ( -- )
  flags size 1 fill
  0 size 0
  do flags i + c@
     if i dup + 3 + dup i +
          begin   dup size <
          while   0 over flags + c! over +
          repeat  drop drop 1+
     then
  loop  .  ." primes "  ;

( byte-magazine-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).
  \
  \ 2015-12-24. Removed the Modified: no printing.

need bench{

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop
  \ u. ." PRIMES" cr  \ XXX OLD
  drop  \ XXX NEW
  ;  -->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( n -- )
  cr dup u. ." iterations..." cr
  bench{ 0 ?do  do-prime  loop }bench.  ;

  cr
  \  <------------------------------>
  .( To run the BYTE Magazine) cr
  .( benchmark type:) cr
  .(   n byte-magazine-benchmark) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 1000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       -----         -----
  \ 00010  6397          5216
  \ 00100 63970 (1.00)  52159 (0.81)

  \ 2016-03-16
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 00001                    517
  \ 00010                   5164
  \ 00100 52161 (1.00)     51635 (0.98)
  \
  \ [1] Changed only in the kernel.

( interface-age-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ Interface Age Benchmark, 1985-11-16.  This is the Interface
  \ Age benchmark program described in Appendix D of the
  \ forthCMP Manual.

  \ 2015-12-24. Modified: no printing.

need bench{  need 2/

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 ?do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop
    \ if  .  else  drop  then  \ XXX OLD
    2drop  \ XXX NEW
  loop  drop  ;  -->

( interface-age-benchmark )

: interface-age-benchmark  ( n -- )
  bench{ (interface-age-benchmark) }bench.  ;

  cr
  \  <------------------------------>
  .( To run the interface age) cr
  .( benchmark type:) cr
  .(   n interface-age-benchmark  ) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 5000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       ------------  ------------
  \ 05000 80091 (1.00)  72445 (0.90)

  \ 2016-03-16 XXX TODO --
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 05000 72445 (1.00)     71914 (0.99)
  \
  \ [1] Changed only in the kernel.

( vector-loop-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench{

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !
     1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop3 ( -- ) \ vector divide
  0 begin
    dup vec1 @ over vec2 @ / over vec3 !
    1+ dup vsize =
  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench{ 0 begin  loop0 1+ dup reps =  until  drop }bench.
  ." Vector No-Op" cr  ;

: bench1 ( -- ) \ benchmark loop1
  bench{ 0 begin  loop1 1+ dup reps =  until  drop }bench.
  ." Vector +    " cr  ;

: bench2 ( -- ) \ benchmark loop2
  bench{ 0 begin  loop2 1+ dup reps =  until  drop }bench.
  ." Vector *    " cr  ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench{ 0 begin  loop3 1+ dup reps =  until  drop }bench.
  ." Vector /    " cr  ;

: bench4 ( -- ) \ benchmark loop4
  bench{ 0 begin  loop4 1+ dup reps =  until  drop }bench.
  ." Vector */   " cr  ;

: vector-loop-benchmarks  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  cr
  \  <------------------------------>
  .( To run the vector loop) cr
  .( benchmarks type:) cr
  .(   vector-loop-benchmarks ) cr

  \ 2015-12-24
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               ITC           DTC
  \               ------        -------------
  \ Vector noop    10919 (1.0)    9033 (0.82)
  \ Vector +       58650 (1.0)   47462 (0.80)
  \ Vector *      107770 (1.0)   91611 (0.85)
  \ Vector /      149002 (1.0)  127495 (0.85)
  \ Vector */     178854 (1.0)  154480 (0.86)

  \ 2016-03-16  XXX TODO --
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               jp pushhl        push hl + jp (ix) [1]
  \               ------------     ---------------------
  \ Vector noop     9033 (1.0)       8943 (0.99)
  \ Vector +       47461 (1.0)      47177 (0.99)
  \ Vector *       91920 (1.0)      91153 (0.99)
  \ Vector /      127496 (1.0)     126783 (0.99)
  \ Vector */     155192 (1.0)     154364 (0.99)

  \ [1] Changed only in the kernel.

( all-benchmarks )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

( Interface Age Benchmark program )

  \ XXX TODO -- test

  \ Forth Dimensions (volume 2, number 4, page 112)

: bench  ( -- )
  dup 2 / 1+ swap ." Starting " cr
  1 do dup i 1 rot
    2 do drop dup i /mod
      dup 0= if  drop drop 1 leave
      else  1 = if drop 1
            else  dup 0 > if  drop 1
                  else  0= if  0 leave  then
                  then
            then
      then
    loop
    if  4 .r  else  drop  then
  loop  drop cr ." Finished " ;

  \ vim: filetype=soloforth
