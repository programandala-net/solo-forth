  \ 002.need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605080207

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the library dependencies.
  \ It must be at block 2 of the library.
  \
  \ The utility consists of words `need`, `needed`, `reneed`
  \ and `reneeded`. All of them are deferred words. Their
  \ default behaviour is set by `set-located-need`: locate the
  \ required word searching the blocks of the library.
  \
  \ An alternative faster behaviour is provided by the
  \ `indexer` tool, in other module.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06: First version, partly based on code from Afera.
  \
  \ 2015-06-25: Fix: `require` and `locate` needed to save the
  \ parsed words to the circular string buffer.
  \
  \ 2015-09-13: Rename `require` to `need`, and all related
  \ words accordingly.  The reason is `require` and `required`
  \ are standard words (in Forth-94 and Forth-2012), and should
  \ not be used for different purposes.
  \
  \ 2015-10-05: Fix `needed`. The trailing and leading spaces
  \ of the string, sometimes used to prevent name clashes, had
  \ to be removed before `undefined?`. `-leading` has to be
  \ moved to the kernel.
  \
  \ 2015-10-16: Add `[needed]`.  It allows selective
  \ compilation depending on the word specified by `need` or
  \ `needed`.  Improve `located`: now the string searched for
  \ is delimited with spaces. This prevents name clashes and
  \ makes it unnecessary to add the spaces explicitly in risky
  \ cases.
  \
  \ 2015-10-25: Improve `need` and `needed` a bit.
  \
  \ 2016-04-02: Factor `new-needed-word` from `needed`.  This
  \ change was needed for `indexer`.
  \
  \ 2016-04-03: Make `need` and related words deferred. Factor
  \ `new-needed-word` from `needed`. These changes were needed
  \ for `indexer`.
  \
  \ 2016-04-26: Improve `located`: when the user press the
  \ break key, throw exception #-28 ("user interrupt");
  \ formerly the ordinary #-268 ("required, but not located")
  \ was thrown by the calling word.
  \
  \ 2016-05-06: Make `from` and `locate` optional. Compact the
  \ blocks.
  \
  \ 2016-05-07: Improve documentation. Fix the word shown when
  \ `?locate` throws an error.

( contains delimited located ?located )

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does string _ca1 len1_ contain string _ca2 len2_?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited  ( ca1 len1 -- ca2 len2 )
  \
  \ Add one leading space and one trailing space to string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
      contains if  2drop i unloop exit  then
      break-key? #-28 ?throw \ "user interrupt"
  loop  2drop 0  ;

  \ doc{
  \
  \ located  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

2variable needed-word

-->

( ?located reneeded reneed needed-word [needed] [unneeded] )

: ?located  ( n -- )
  dup ?exit  needed-word 2@ parsed-name 2! #-268 throw  ;

  \ doc{
  \
  \ ?located ( n -- )
  \
  \ If _n_ is zero, throw an exception -268 ("required, but not
  \ located").
  \
  \ }doc

defer reneeded  ( ca len -- )

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Load the first block whose header contains the string _ca
  \ len_ (surrounded by spaces).  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneeded`.
  \
  \ }doc

: locate-reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ locate-reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

defer reneed  ( "name" -- )

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Load the first block whose header contains "name" (but
  \ surrounded by spaces).
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneed`.
  \
  \ }doc

: locate-reneed  ( "name" -- )
  parse-name save-string reneeded  ;

  \ doc{
  \
  \ locate-reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name" (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: [needed]  ( "name" -- f )
  parse-name needed-word 2@ 2dup or
  if  compare 0= exit  then  2drop 2drop true  ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return true.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _true_, else return _false_.
  \
  \ }doc

: [unneeded]  ( "name" -- f )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- f )
  \ 
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return false.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _false_, else return _true_.
  \
  \ }doc

: new-needed-word  ( ca len -- ca' len' )
  -trailing -leading save-string 2dup needed-word 2!  ;

  \ doc{
  \
  \ new-needed-word  ( ca1 len -- ca2 len' )
  \ 
  \ Remove trailing and leading spaces from the word _ca1 len_,
  \ which is the parameter of the latest `need` `needed`,
  \ `reneed` or `reneeded`, store it in the circular string
  \ buffer and return it as _ca2 len'_ for further processing.
  \
  \ }doc

-->

( needed need )

defer needed  ( ca len -- )

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, load the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces).  If not found, throw an exception
  \ -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-needed`.
  \
  \ }doc

: locate-needed  ( ca len -- )
  \ cr ." need " 2dup type  \ XXX INFORMER
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ locate-needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

defer need  ( "name" -- )

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-need`.
  \
  \ }doc

: locate-need  ( "name" -- )  parse-name locate-needed  ;

  \ doc{
  \
  \ locate-need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is the default behaviour of the deferred word `need`.
  \
  \ }doc

: set-located-need  ( -- )
  ['] locate-reneeded ['] reneeded  defer!
  ['] locate-reneed   ['] reneed    defer!
  ['] locate-need     ['] need      defer!
  ['] locate-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-located-need  ( -- )
  \
  \ Set the default behaviour of `need`, `needed`, `reneed` and
  \ `reneeded`: Use `locate` for searching the library.
  \
  \ The alternative, provided by the optional `indexer` tool,
  \ is set by `set-indexed-need`.
  \
  \ }doc

set-located-need

blk @ 1+ dup default-first-locatable !  first-locatable !

( locate from need-here )

[unneeded] locate [unneeded] from and
?\ : locate  ( "name" -- n )  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- n )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

[unneeded] from
?\ : from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268
  \ ("required, but not located").
  \
  \ This word is intended to prevent undesired name clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker.
  \
  \ Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures==  need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

[unneeded] need-here ?exit

: need-here  ( "name" -- )
  parse-name
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  blk @ load  else  2drop  then  2r> needed-word 2!  ;
    
  \ doc{
  \
  \ need-here  ( "name" -- )
  \
  \ If "name" is not a word found in the current search order,
  \ load the current block.
  \
  \ This is a faster alternative to `need`, when the needed
  \ word is in the same block, and conditional compilation is
  \ used with `?\`, `?(` or `[if]`.
  \
  \ }doc

  \ vim: filetype=soloforth
