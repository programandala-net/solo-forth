  \ 002.need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201701191619

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the code dependencies.
  \ For convenience it is in block 2.
  \
  \ The utility consists of words `need`, `needed`, `reneed`
  \ and `reneeded`. All of them are deferred words. Their
  \ default behaviour is set by `use-no-index`: locate the
  \ required word searching a configurable range of blocks.
  \
  \ Alternative behaviours are provided by the optional tools
  \ Thru Indexer and Fly Indexer.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016, 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06: First version, partly based on code from Afera.
  \
  \ 2015-06-25: Fix: `require` and `locate` needed to save the
  \ parsed words to the circular string buffer.
  \
  \ 2015-09-13: Rename `require` to `need`, and all related
  \ words accordingly.  The reason is `require` and `required`
  \ are standard words (in Forth-94 and Forth-2012), and should
  \ not be used for different purposes.
  \
  \ 2015-10-05: Fix `needed`. The trailing and leading spaces
  \ of the string, sometimes used to prevent name clashes, had
  \ to be removed before `undefined?`. `-leading` has to be
  \ moved to the kernel.
  \
  \ 2015-10-16: Add `[needed]`.  It allows selective
  \ compilation depending on the word specified by `need` or
  \ `needed`.  Improve `located`: now the string searched for
  \ is delimited with spaces. This prevents name clashes and
  \ makes it unnecessary to add the spaces explicitly in risky
  \ cases.
  \
  \ 2015-10-25: Improve `need` and `needed` a bit.
  \
  \ 2016-04-02: Factor `new-needed-word` from `needed`.  This
  \ change was needed for `indexer`.
  \
  \ 2016-04-03: Make `need` and related words deferred. Factor
  \ `new-needed-word` from `needed`. These changes were needed
  \ for `indexer`.
  \
  \ 2016-04-26: Improve `located`: when the user press the
  \ break key, throw exception #-28 ("user interrupt");
  \ formerly the ordinary #-268 ("required, but not located")
  \ was thrown by the calling word.
  \
  \ 2016-05-06: Make `from` and `locate` optional. Compact the
  \ blocks.
  \
  \ 2016-05-07: Improve documentation. Fix the word shown when
  \ `?locate` throws an error.
  \
  \ 2016-05-10: Fix a harmless bug: `locate-reneed` called the
  \ deferred `reneeded` instead of `locate-reneeded`.
  \
  \ 2016-05-31: Fix block header.
  \
  \ 2016-06-01: Fix `need-here`, which left the string on the
  \ stack.
  \
  \ 2016-10-28: Add a temporary debugging informer to
  \ `located`.
  \
  \ 2016-11-19: Add `unlocated` in order to implement
  \ `fly-indexer`. Improve the documentation.
  \
  \ 2016-11-21: Document why `contains` is not accessible here,
  \ and therefore it's defined also in the strings module.
  \
  \ 2016-11-24: Rename some words to be consistent with the
  \ changes in the Thru Index and the Fly Index.  Factor
  \ `use-no-index`. Improve documentation.
  \
  \ 2016-11-25: Factor `use-no-index`, `use-default-located`.
  \ Fix and improve documentation and names.
  \
  \ 2016-11-26: Improve `(located)` to detect empty strings.
  \
  \ 2016-12-03: Add debugging code.
  \
  \ 2016-12-25: Rename `from` to `need-from` and improve its
  \ documentation.
  \
  \ 2016-12-30: Compact the code, saving one block.
  \
  \ 2017-01-05: Update `indexer` to `make-thru-index` in
  \ documentation.
  \
  \ 2017-01-17: Improve documentation.
  \
  \ 2017-01-18: Remove `exit` at the end of conditional
  \ interpretation.
  \
  \ 2017-01-19: Improve optional debugging code in `(located)`.

( delimited located needed-word )

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
  \ Does string _ca1 len1_ contain string _ca2 len2_?
  \
  \ This word is defined also in <strings.misc.fsb>,
  \ because it can not be loaded by the applications from this
  \ block (because `[unneeded]` is not defined at this point).
  \ That's why `contains` is not included in the block header.

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

  \ doc{
  \
  \ first-locatable  ( -- a )
  \
  \ A variable that holds the number of the first block to be
  \ searched by `located` and its descendants.
  \
  \ See: `last-locatable`, `located`.
  \
  \ }doc

  \ doc{
  \
  \ default-first-locatable  ( -- a )
  \
  \ A variable that holds the default number of the first block
  \ to be searched by `located` and its descendants.
  \
  \ See: `first-locatable`, `located`.
  \
  \ }doc

  \ doc{
  \
  \ last-locatable  ( -- a )
  \
  \ A variable that holds the number of the last block to be
  \ searched by `located` and its descendants. Its default
  \ value is the last block of the disk.
  \
  \ See: `first-locatable`, `located`.
  \
  \ }doc

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited  ( ca1 len1 -- ca2 len2 )
  \
  \ Add one leading space and one trailing space to string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

defer unlocated  ( block -- )

  \ doc{
  \
  \ unlocated  ( block -- )
  \
  \ Deferred word called in the loop of `located`, when the
  \ word searched for is not located in _block_.  Its default
  \ behaviour is `drop`, and it's changed by `use-fly-index`
  \ in order to index the blocks on the fly.
  \
  \ See: `use-fly-index`.
  \
  \ }doc

: (located)  ( ca len -- block | false )
  \ : (located) cr 2dup type get-current dup u. 0= if  quit  then
    \ XXX INFORMER
  \ : (located)  cr 2dup type space .s depth 2 > if  key drop  then
    \ XXX INFORMER
  \ : (located)  cr 2dup type space rp@ rp0 @ - -2 / . hp@ u. cr .s
    \ XXX INFORMER
  \ : (located)  cr ." (located)<" 2dup type ." >"
    \ XXX INFORMER
  \ : (located)  cr ."  base: #" base @ dup decimal . base !
    \ XXX INFORMER
  \ : (located)  cr ."  rdepth: " rp@ rp0 @ - -2 / .
    \ XXX INFORMER
  \ : (located)  cr ."  unused-csb: " unused-csb .
    \ XXX INFORMER
  ?dup 0= if  drop false exit  then
  delimited last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over contains
      if  2drop i unloop exit  then  break-key? #-28 ?throw
      i unlocated  loop  2drop 0  ;
  \ Note: Error #-28 is "user interrupt".

  \ doc{
  \
  \ (located)  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ Only the blocks delimited by `first-locatable-block` and
  \ `last-locatable-block` are searched`.
  \
  \ This is the default behaviour of `located`, which is
  \ changed by `use-fly-index`.
  \
  \ See: `located`, `use-fly-index`, `default-first-locatable`,
  \ `first-locatable`, `last-locatable`.
  \
  \ }doc

defer located  ( ca len -- block | false )  -->

  \ doc{
  \
  \ located  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ Only the blocks delimited by `first-locatable-block` and
  \ `last-locatable-block` are searched`.
  \
  \ This is a deferred word whose default action is
  \ `(located)`.
  \
  \ See: `(located)`, `first-locatable-block`,
  \ `last-locatable-block`.
  \
  \ }doc

( ?located reneeded reneed needed-word [needed] [unneeded] )

2variable needed-word  0. needed-word 2!

: ?located  ( n -- )  \ cr ." ?located " dup .
                      \ XXX INFORMER
  dup ?exit  needed-word 2@ parsed-name 2! #-268 throw  ;

  \ doc{
  \
  \ ?located ( n -- )
  \
  \ If _n_ is zero, throw an exception #-268 ("needed, but
  \ not located").
  \
  \ }doc

defer reneeded  ( ca len -- )

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Load the first block whose header contains the string _ca
  \ len_ (surrounded by spaces).  If not found, throw an
  \ exception #-268 ("needed, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneeded`.
  \
  \ See: `locate-reneeded`, `make-thru-index`.
  \
  \ }doc

: locate-reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ locate-reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception #-268 ("needed, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneeded`.
  \
  \ See: `reneeded`, `make-thru-index`.
  \
  \ }doc

defer reneed  ( "name" -- )  defer needed  ( ca len -- )

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Load the first block whose header contains "name" (but
  \ surrounded by spaces).
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneed`.
  \
  \ See: `locate-reneed`, `make-thru-index`.
  \
  \ }doc

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, load the first block where "name"
  \ is included in the block header (but surrounded by spaces).
  \ If not found, throw an exception #-268 ("needed, but not
  \ located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-needed`.
  \
  \ See: `locate-needed`, `make-thru-index`.
  \
  \ }doc



: locate-reneed  ( "name" -- )
  parse-name save-string locate-reneeded  ;

  \ doc{
  \
  \ locate-reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name" (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception #-268 ("needed, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneed`.
  \
  \ See: `reneed`, `make-thru-index`.
  \
  \ }doc

: [needed]  ( "name" -- f )
  parse-name needed-word 2@ 2dup or
  if  compare 0= exit  then  2drop 2drop true  ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return true.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _true_, else return _false_.
  \
  \ }doc

: [unneeded]  ( "name" -- f )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return false.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _false_, else return _true_.
  \
  \ }doc

: new-needed-word  ( ca len -- ca' len' )
  -trailing -leading save-string 2dup needed-word 2!  ;  -->

  \ doc{
  \
  \ new-needed-word  ( ca1 len -- ca2 len' )
  \
  \ Remove trailing and leading spaces from the word _ca1 len_,
  \ which is the parameter of the latest `need` `needed`,
  \ `reneed` or `reneeded`, store it in the circular string
  \ buffer and return it as _ca2 len'_ for further processing.
  \
  \ }doc

( locate-needed need use-no-index )

: locate-needed  ( ca len -- )
  \ cr ." LN<" 2dup type ." >"  \ XXX INFORMER
  \ rp@ rp0 @ - -2 / ." rdepth=" .  \ XXX INFORMER
  needed-word 2@ 2>r new-needed-word  2dup undefined?
  if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ locate-needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block where
  \ "name" is included in the block header (but surrounded by
  \ spaces), and load it.  If not found, throw an exception
  \ #-268 ("needed, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `needed`.
  \
  \ See: `needed`, `make-thru-index`.
  \
  \ }doc

defer need  ( "name" -- )

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block where "name" is included is the block
  \ header (surrounded by spaces), and load it.  If not found,
  \ throw an exception #-268 ("needed, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-need`.
  \
  \ See: `locate-need`, `make-thru-index`.
  \
  \ }doc

: locate-need  ( "name" -- )  parse-name locate-needed  ;

  \ doc{
  \
  \ locate-need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block where "name" is included is the block
  \ header (surrounded by spaces), and load it.  If not found,
  \ throw an exception #-268 ("needed, but not located").
  \
  \ This is the default behaviour of the deferred word `need`.
  \
  \ See: `need`, `make-thru-index`.
  \
  \ }doc

: use-default-need  ( -- )
  ['] locate-reneeded ['] reneeded  defer!
  ['] locate-reneed   ['] reneed    defer!
  ['] locate-need     ['] need      defer!
  ['] locate-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ use-default-need  ( -- )
  \
  \ Set the default behaviour of `need`, `needed`, `reneed`,
  \ and `reneeded`: Use `locate` for searching the blocks.
  \
  \ This word is a common factor of `use-no-index` and
  \ `use-fly-index`.
  \
  \ See: `use-no-index`, `use-fly-index`.
  \
  \ }doc

: use-default-located  ( -- )  ['] (located) ['] located defer!
                               ['] drop ['] unlocated defer!  ;

  \ doc{
  \
  \ use-default-located  ( -- )
  \
  \ Set the default behaviour of `located` and `unlocated`:
  \ search the blocks.
  \
  \ This word is a common factor of `use-no-index` and
  \ `use-thru-index`.
  \
  \ See: `use-no-index`, `use-thru-index`.
  \
  \ }doc

: use-no-index  ( -- )
  use-default-need use-default-located  ;  use-no-index

  \ doc{
  \
  \ use-no-index  ( -- )
  \
  \ Set the default behaviour of `need`, `needed`, `reneed`,
  \ `reneeded` and `unlocated`: Use `locate` for searching the
  \ blocks.
  \
  \ The alternative behaviours are set by `use-thru-index` and
  \ `use-fly-index`.
  \
  \ See: `use-thru-index`, `use-fly-index`.
  \
  \ }doc

blk @ 1+ dup default-first-locatable !  first-locatable !

( locate need-from need-here )

need ?(

[unneeded] locate ?(
: locate  ( "name" -- block | false )
  parse-name save-string located  ; ?)

  \ doc{
  \
  \ locate  ( "name" -- block | false )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number _block_. If
  \ not found, return _false_.  The search is case-sensitive.
  \
  \ Only the blocks delimited by `first-locatable-block` and
  \ `last-locatable-block` are searched`.
  \
  \ See: `located`, `first-locatable-block`,
  \ `last-locatable-block`.
  \
  \ }doc

[unneeded] need-from ?(  need locate
: need-from  ( "name" -- )
  locate ?located first-locatable !  ; ?)

  \ doc{
  \
  \ need-from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception #-268
  \ ("needed, but not located").
  \
  \ This word is intended to prevent undesired name clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker.
  \
  \ Usage example:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ need-from ==data-structures==  need x
  \
  \ x
  \
  \ ( y ==data-structures== )
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

[unneeded] need-here ?(

: need-here  ( "name" -- )
  parse-name needed-word 2@ 2>r
  new-needed-word  2dup needed-word 2! undefined?
  if  blk @ load  else  2drop  then  2r> needed-word 2!  ; ?)

  \ doc{
  \
  \ need-here  ( "name" -- )
  \
  \ If _name_ is not a word found in the current search order,
  \ load the current block.
  \
  \ This is a faster alternative to `need`, when the needed
  \ word is in the same block, and conditional compilation is
  \ used with `?\`, `?(` or `[if]`.
  \
  \ }doc

  \ vim: filetype=soloforth
