  \ data.array.wong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201611221918

  \ -----------------------------------------------------------
  \ Description

  \ The one-dimensional Wong arrays.

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ Main idea:

  \ Treat arrays like values.

  \ Example of use:

    \ 4 array bar
    \ 10 0 ato bar  20 1 ato bar  30 2 ato bar  40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of `array`, `array>` `ato` and `+ato`.

  \ -----------------------------------------------------------
  \ Authors

  \ Leo Wong.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \
  \ 2016-04-02: Reorganized the description.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.
  \
  \ 2016-11-22: Fix and complete documentation of all words.

( array ato )

need within  need >body

: array>  ( n a1 -- a2 )
  2dup @ 0 swap within 0= #-272 ?throw
  cell+ swap cells +  ;

  \ doc{
  \
  \ array>  ( n a1 -- a2 )
  \
  \ If in range, return address _a2_ of element _n_ of array
  \ _a1_, else throw error code #-272 (array index out of
  \ range).
  \
  \ See: `array`.
  \
  \ }doc

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;

  \ doc{
  \
  \ array  ( n "name" -- )
  \
  \ Create a 1-cell array _name_ of _n_ elements with the
  \ execution semantics defined below.
  \
  \ `name` execution:
  \
  \ name  ( n -- x )
  \
  \ If in range, return contents _x_ of element _n_ else throw
  \ error code #-272 (array index out of range).
  \
  \ See: `ato`, `+ato`, `array>`.
  \
  \ }doc

: (ato)  ( x n xt -- )  >body array> !  ;

  \ doc{
  \
  \ (ato)  ( x n xt -- )
  \
  \ Store _x_ into element _n_ of array _xt_.
  \
  \ See: `ato`.
  \
  \ }doc

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then  ; immediate

  \ doc{
  \
  \ ato  ( x n "name" -- )
  \
  \ Store _x_ into element _n_ of array _name_.
  \
  \ See: `array`, `(ato)`.
  \
  \ }doc

: (+ato)  ( n1 n2 a -- )  >body array> +!  ;

  \ doc{
  \
  \ (+ato)  ( n1 n2 xt -- )
  \
  \ Add _n1_ to element _n2_ of array _xt_.
  \
  \ See: `array`, `+ato`.
  \
  \ }doc

: +ato  ( n1 n2 "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate

  \ doc{
  \
  \ +ato  ( n1 n2 "name" -- )
  \
  \ Add _n1_ to element _n2_ of array _name_.
  \
  \ See: `array`, `(+ato)`.
  \
  \ }doc

  \ vim: filetype=soloforth
