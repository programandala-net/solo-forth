  \ memory.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605092201

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-17: Added `-!`. Documented some words.
  \ 2016-04-23: Added `c-!`.
  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.
  \ 2016-04-25: Add `@cell+`. Move `n,`, `n@`, `n!` from the
  \ module "compilation.fsb".  Add `nn@`, `nn,`, `nn!`.
  \ 2016-04-26: Remove unused words, specific of the TED
  \ editor.
  \ 2016-04-27: Add `/!`, `*!`, `2/!`, `2*!`.
  \ 2016-05-09: Add `align`, `aligned`.

( -! )

code -!  ( n|u a -- )
  E1 c,  D1 c,
  \ pop hl ; address
  \ pop de ; number
  7E c,  90 03 + c,  70 07 + c,  23 c,
  \ ld a,(hl)
  \ sub a,e
  \ ld (hl),a
  \ inc hl
  7E c,  98 02 + c,  70 07 + c,
  \ ld a,(hl)
  \ sbc a,d
  \ ld (hl),a
  jpnext  end-code

  \ doc{
  \
  \ -!  ( n|u a -- )
  \
  \ Subtract n|u from the single-cell number at _a_.
  \
  \ }doc

( c+! c-! c@+ )

need z80-asm  need [if]

[needed] c+! [if]

code c+!  ( c ca -- )
  hl pop  de pop  e a ld  m add  a m ld  jpnext  end-code

  \ doc{
  \
  \ code c+!  ( c ca - )
  \
  \ Add _c_ to the char at _ca_
  \
  \ }doc

[then]

[needed] c-! [if]

code c-!  ( c ca -- )
  hl pop  de pop  m a ld  e sub  a m ld  jpnext  end-code

  \ doc{
  \
  \ c-!  ( c ca - )
  \
  \ Subtract _c_ from the char at _ca_
  \
  \ }doc

[then]

[needed] c@+ [if]

code c@+  ( ca -- ca+1 c )
  hl pop  m a ld  hl incp  hl push  pusha jp  end-code

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ doc{
  \
  \ code c@+  ( ca -- ca+1 c )
  \
  \ Fetch the character at _ca_ and increment the address.
  \ This is handy for stepping through character arrays.
  \
  \ }doc

[then]

( 1+! 1-! )

need z80-asm  need [if]

[needed] 1+! [if]

code 1+!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de incp
  d m ld  hl decp  e m ld  jpnext
end-code

[then]

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the single-cell number at _a_.
  \
  \ }doc

[needed] 1-! [if]

code 1-!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de decp
  d m ld  hl decp  e m ld  jpnext
end-code

[then]

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the single-cell number at _a_.
  \
  \ }doc

( c1+! c1-! )

need z80-asm

[unneeded] c1+!
?\  code c1+!  ( ca -- )  hl pop  m inc  jpnext  end-code

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the char at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  hl pop  m dec  jpnext  end-code

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the char at _ca_.
  \
  \ }doc

( @cell+ )

: @cell+  ( a -- a' x )  dup cell+ swap @  ;

  \ doc{
  \
  \ @cell+  ( a -- a' x )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by one cell.
  \
  \ }doc

exit  \ XXX TODO -- alternative, rename

: @cell+  ( a -- x a' )  dup @ swap cell+  ;

  \ doc{
  \
  \ @cell+  ( a -- x a' )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by one cell.
  \
  \ }doc

( n, nn, )

: n,  ( xu..x1 u -- )  0 ?do  ,  loop  ;
  \ If _u_ is not zero, store _u_ cells _xu..x1_ into data
  \ space, being _x1_ the first one stored and _xu_ the last
  \ one.

: nn,  ( xu..x1 u -- )  dup , n,  ;
  \ Store the count _u_ into data space.  If _u_ is not zero,
  \ store also _u_ cells _xu..x1_ into data space, being _x1_
  \ the first one stored and _xu_ the last one.

( n@ nn@ n! nn! )

need [if]

[needed] n@ [needed] nn@ or [if]

: n@  ( a u -- xu..x1 )
  tuck 1- cells +  \ point _a_ to _xu_
  swap 0 ?do  dup i cells - @ swap  loop  drop  ;
  \ If _u_ is not zero, read _u_ cells _xu..x1_ from
  \ _a_, being _x1_ the first one stored and _xu_ the last
  \ one.

: nn@  ( a -- x1..xu u | 0 )  dup @ >r cell+ r@ n@ r>  ;
  \ Read the count _u_ from _a_.  If it's zero, return it.  If
  \ _u_ is not zero, read _u_ cells _xu..x1_ from the next cell
  \ address, being _x1_ the first cell stored there and _xu_
  \ the last one.

[then]

[needed] n! [needed] nn! or [if]

: n!  ( xu..x1 u a -- )
  swap 0 ?do  dup >r ! r> cell+  loop  drop  ;
  \ If _u_ is not zero, store _u_ cells at address _a_, being
  \ _x1_ the first cell stored there and _xu_ the last one.

: nn!  ( xu..x1 u a -- )  2dup ! cell+ n!  ;
  \ Store the count _u_ at _a_.  If _u_ is not zero, store also
  \ _u_ cells _xu..x1_ at the next cell address, being _x1_ the
  \ first one stored and _xu_ the last one.

[then]

( @+ @- !+ !- c@+ c@- c!+ c!- )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credit:
  \
  \ Words written after cmForth.

  \ XXX Note: the original descriptions didn't include stack
  \ notations. Some of them are not clear.

  \ @+  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is incremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ XXX TODO alternative found -- which one is cmForth?
  : @+ ( a inc -- value a+inc )  + dup @ swap  ;

  \ @-  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is decremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ !+  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then incremented by _n_.

  \ XXX TODO alternative found -- which one is cmForth?
  : !+  ( value a inc -- a+inc )  + tuck !  ;

  \ !-  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then decremented by _n_.

  \ c@+  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and increment the address by _n_.

  \ c@-  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and decrement the address by _n_.

  \ c!+  ( c ca n -- ca' )
  \
  \ Store a character to memory and increment the address by _n_.

  \ c!-  ( c ca n -- ca' )
  \
  \ Store a character to memory and decrement the address by _n_.

( bit? set-bit reset-bit )

need lshift

: bit>mask  ( n -- b )  1 swap lshift  ;

  \ doc{
  \
  \ bit>mask  ( n -- b )
  \
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.
  \
  \ }doc

: bit? ( b n -- f )  bit>mask and 0<> ;

  \ doc{
  \
  \ bit? ( b n -- f )
  \
  \ Is bit _n_ of _b_ set?
  \
  \ }doc

: set-bit ( b1 n -- b2 )  bit>mask or ;

  \ doc{
  \
  \ set-bit ( b1 n -- b2 )
  \
  \ Set bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

: reset-bit ( b1 n -- b2 )  bit>mask invert and ;

  \ doc{
  \
  \ reset-bit ( b1 n -- b2 )
  \
  \ Reset bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc


( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credit:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need z80-asm  need [if]

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- f )
  \   hl pop  de pop  e a ld  m and
  \   ' true jpnz  ' false jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s '<' emit type '>' emit cr

[needed] c@test-bits [if]
code c@test-bits  ( b1 ca -- b2 )
  hl pop  de pop  e a ld  m and  pusha jp
  end-code  exit  [then]
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[needed] c!toggle-bits [if]
code c!toggle-bits  ( b ca -- )
  hl pop  de pop  m a ld  e xor  a m ld  jpnext
  end-code  exit  [then]
  \ Invert the bits at _ca_ specified by the bitmask _b_.

( exchange reserve alloted align aligned )

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

[unneeded] reserve
?\ : reserve  ( n -- a )  here tuck over erase allot  ;

  \ doc{
  \
  \ reserve  ( n -- a )
  \
  \ Reserve _n_ address units of data space, erase the zone and
  \ return its address _a_.
  \
  \ }doc

[unneeded] alloted
?\ : allotted  ( n -- a )  here swap allot ;

  \ doc{
  \
  \ allotted  ( n -- a )
  \
  \ Reserve _n_ address units of data space and return its
  \ address _a_.
  \
  \ }doc

[unneeded] align
?\ need alias  ' noop alias align immediate

[unneeded] aligned
?\ need alias  ' noop alias aligned immediate

( /! *! 2/! 2*! )

[unneeded] /!
?\ : /!  ( n a -- )  tuck @ swap / swap !  ;

  \ doc{
  \
  \ /!  ( n a -- )
  \
  \ Divide _n_ by the single-cell number at _a_ and store
  \ the quotient in _a_
  \
  \ }doc

[unneeded] *!
?\ : *!  ( n a -- )  tuck @ swap * swap !  ;

  \ doc{
  \
  \ *!  ( n|u a -- )
  \
  \ Multiply _n|u_ by the single-cell number at _a_ and store
  \ the product in _a_
  \
  \ }doc

[unneeded] 2*!
?\ : 2*!  ( a -- )  dup @ 2* swap !  ;

  \ doc{
  \
  \ 2*!  ( a -- )
  \
  \ Do a `2*` shift to the single-cell number at _a_.
  \
  \ See `2*`.
  \
  \ }doc

[unneeded] 2/! ?exit
need 2/
: 2/!  ( a -- )  dup @ 2/ swap !  ;

  \ doc{
  \
  \ 2/!  ( a -- )
  \
  \ Do a `2/` shift to the single-cell number at _a_.
  \
  \ See `2/`.
  \
  \ }doc

  \ vim: filetype=soloforth
