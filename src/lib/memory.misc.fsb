  \ memory.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242158

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-17: Added `-!`. Documented some words.
  \ 2016-04-23: Added `c-!`.
  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( exchange )

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

( -! )

code -!  ( n|u a -- )
  E1 c,  D1 c,
  \ pop hl ; address
  \ pop de ; number
  7E c,  90 03 + c,  70 07 + c,  23 c,
  \ ld a,(hl)
  \ sub a,e
  \ ld (hl),a
  \ inc hl
  7E c,  98 02 + c,  70 07 + c,
  \ ld a,(hl)
  \ sbc a,d
  \ ld (hl),a
  jpnext  end-code

  \ doc{
  \
  \ -!  ( n|u a -- )
  \
  \ Subtract n|u from the single-cell number at _a_.
  \
  \ }doc

( c+! c-! c@+ )

need z80-asm  need [if]

[needed] c+! [if]

code c+!  ( c ca -- )
  hl pop  de pop  e a ld  m add  a m ld  jpnext  end-code

  \ doc{
  \
  \ code c+!  ( c ca - )
  \
  \ Add _c_ to the char at _ca_
  \
  \ }doc

[then]

[needed] c-! [if]

code c-!  ( c ca -- )
  hl pop  de pop  m a ld  e sub  a m ld  jpnext  end-code

  \ doc{
  \
  \ c-!  ( c ca - )
  \
  \ Subtract _c_ from the char at _ca_
  \
  \ }doc

[then]

[needed] c@+ [if]

code c@+  ( ca - ca+1 c )
  hl pop  m a ld  hl incp  hl push  pusha jp  end-code

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX OLD -- First version
  \ de pop  de ftap  de incp  0 h ld# a l ld  pushhlde jp

  \ doc{
  \
  \ code c@+  ( ca - ca+1 c )
  \
  \ Fetch the character at _ca_ a and increments the address.
  \ This is handy for stepping through character arrays.
  \
  \ }doc

[then]

( 1+! 1-! )

need z80-asm  need [if]

[needed] 1+! [if]

code 1+!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de incp
  d m ld  hl decp  e m ld  jpnext
end-code

[then]

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the single-cell number at _a_.
  \
  \ }doc

[needed] 1-! [if]

code 1-!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de decp
  d m ld  hl decp  e m ld  jpnext
end-code

[then]

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the single-cell number at _a_.
  \
  \ }doc

( c1+! c1-! )

need z80-asm

[unneeded] c1+!
?\  code c1+!  ( ca -- )  hl pop  m inc  jpnext  end-code

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the char at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  hl pop  m dec  jpnext  end-code

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the char at _ca_.
  \
  \ }doc

( c@+ c!+ -c@ -c! )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credit:
  \
  \ Words from the TED editor.
  \ http://dxforth.netbay.com.au/ted.html

  \ Note: these words are too specific for the TED editor.

need 1+!  need 1-!

: c@+  ( ca -- c )  dup @ c@ swap 1+!  ;
: c!+  ( c ca -- )  tuck @ c! 1+!  ;
: -c@  ( ca -- c )  dup 1-! @ c@  ;
: -c!  ( c ca -- )  dup 1-! @ c!  ;

( @+ @- !+ !- c@+ c@- c!+ c!- )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credit:
  \
  \ Words written after cmForth.

  \ XXX Note: the original descriptions didn't include stack
  \ notations. Some of them are not clear.

  \ @+  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is incremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ XXX TODO alternative found -- which one is cmForth?
  : @+ ( a inc -- value a+inc )  + dup @ swap  ;

  \ @-  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is decremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ !+  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then incremented by _n_.

  \ XXX TODO alternative found -- which one is cmForth?
  : !+  ( value a inc -- a+inc )  + tuck !  ;

  \ !-  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then decremented by _n_.

  \ c@+  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and increment the address by _n_.

  \ c@-  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and decrement the address by _n_.

  \ c!+  ( c ca n -- ca' )
  \
  \ Store a character to memory and increment the address by _n_.

  \ c!-  ( c ca n -- ca' )
  \
  \ Store a character to memory and decrement the address by _n_.

( bit? set-bit reset-bit )

need lshift

: bit>mask  ( n -- b )  1 swap lshift  ;

  \ doc{
  \
  \ bit>mask  ( n -- b )
  \
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.
  \
  \ }doc

: bit? ( b n -- f )  bit>mask and 0<> ;

  \ doc{
  \
  \ bit? ( b n -- f )
  \
  \ Is bit _n_ of _b_ set?
  \
  \ }doc

: set-bit ( b1 n -- b2 )  bit>mask or ;

  \ doc{
  \
  \ set-bit ( b1 n -- b2 )
  \
  \ Set bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

: reset-bit ( b1 n -- b2 )  bit>mask invert and ;

  \ doc{
  \
  \ reset-bit ( b1 n -- b2 )
  \
  \ Reset bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc


( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credit:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need z80-asm  need [if]

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- f )
  \   hl pop  de pop  e a ld  m and
  \   ' true jpnz  ' false jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s '<' emit type '>' emit cr

[needed] c@test-bits [if]
code c@test-bits  ( b1 ca -- b2 )
  hl pop  de pop  e a ld  m and  pusha jp
  end-code  exit  [then]
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[needed] c!toggle-bits [if]
code c!toggle-bits  ( b ca -- )
  hl pop  de pop  m a ld  e xor  a m ld  jpnext
  end-code  exit  [then]
  \ Invert the bits at _ca_ specified by the bitmask _b_.

( reserve alloted )

: reserve  ( n -- a )  here tuck over erase allot  ;

  \ doc{
  \
  \ reserve  ( n -- a )
  \
  \ Reserve _n_ address units of data space, erase the zone and
  \ return its address _a_.
  \
  \ }doc

: allotted  ( n -- a )  here swap allot ;

  \ doc{
  \
  \ allotted  ( n -- a )
  \
  \ Reserve _n_ address units of data space and return its
  \ address _a_.
  \
  \ }doc

  \ and return its address _a_.

  \ vim: filetype=soloforth
