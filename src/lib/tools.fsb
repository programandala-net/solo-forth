  \ tools.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains development and debugging tools.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.


  \ }}} =======================================================
  \ Tools {{{

( bin. dec. hex. )

  \ Credits:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credits:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credits:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  bounds ?do
    i c@ 127 and dup bl < if  drop [char] .  then  emit
  loop  ;

( dump )

need 16hex.  need ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

  \ XXX FIXME -- when len=0 a row is shown; `wdump` does
  \ nothing.

: dump  ( ca len -- )
  8 2dup mod - + 8 / 0
  ?do
    cr dup 16hex.
    8 0 do  i over + @ flip 16hex.  cell +loop
    \ 16 0 do  i over + c@ hexb.  loop  \ XXX OLD
    dup bs 8 ascii-type
    break-key? ?leave
  8 + loop  drop  ;
  \ Show the contents of _n_ bytes starting from _ca_.

( wdump )

need 16hex.

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  ?do
    i 4 mod 0= if  cr dup 16hex. space  then  \ show address
    dup @ 16hex. cell+
    break-key? ?leave
  loop  drop  ;

( decode )


  \ XXX UNDER DEVELOPMENT -- DTC version
  \ 2015-12-24: Start adapting to DTC.

  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

  \ Credits:
  \
  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions IV,#2 p28 (1982-07).

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2* spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )
  cell+ dup @ cell+ body>name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof

-->

( decode )

    [defined] cslit [if]
      ['] cslit     of  decode-sliteral  endof
    [then]
    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof
    [then]

  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD <> if  drop false exit  then
  1+ @  docolon =  ;
  \ Is _cfa_ a colon definition?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the colon interpreter.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is _pfa_ a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @  ( pfa+n xt ) dup decode-end? 0=
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      >body ( pfa+n pfa' ) dup indent+  body>name .name
      key case  [char] q  of  sp0 @ sp! quit  endof
                      bl  of  drop            endof
                swap recurse  \ default
          endcase  decode-special  cell+  -1 decode-level +!
    repeat  indent >name .name
            \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined  ( nt | 0 )  dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

( words wordlist-words )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

need trail  need name>link  need tab  need nuf?

[defined] more-words?
?\ : more-words?  ( -- f )  dup 0<>  nuf? 0= and  ;
     \ A common factor of `words` and `words-like`.

: words  ( -- )
  trail
  begin  more-words?  while
    dup .name tab  name>link @s
  repeat drop  ;

[unneeded] wordlist-words ?exit

: wordlist-words  ( wid -- )  >order  words  previous  ;

( words-like )

  \ Credits:
  \
  \ Code adapted from pForth.

need trail  need name>link  need tab  need nuf?

[defined] more-words?
?\ : more-words?  ( -- f )  dup 0<>  nuf? 0= and  ;
     \ A common factor of `words` and `words-like`.

[defined] contains
?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
   \ Does the string _ca1 len1_ contains the string _ca2
   \ len2?_

: words-like  ( "name" -- )
  \ Print all words (from the `context` vocabulary) containing a substring.
  parse-name 2dup uppers trail  ( ca len nt )
  begin  more-words?  while
    dup >r
    name>string 2over contains if  r@ .name tab  then
    r> name>link @s
  repeat drop 2drop  ;

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr # " decimal dup . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s u.s )

  \ Credits:
  \
  \ Code from Afera. Original algorithm from v.Forth.

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.

: .depth  ( n -- )  [char] < emit 0 .r [char] > space  ;

: .s   ( -- )
  depth dup .depth if
    sp@ s0 @ cell- do i @ .  [ cell negate ] literal +loop
  then  ;

: u.s   ( -- )
  depth dup .depth if
    sp@ s0 @ cell- do i @ u.  [ cell negate ] literal +loop
  then  ;

( possibly anew )

need marker

  \ Credits:
  \
  \ Code adapted from Wil Baden.

  \ XXX TODO test

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ;

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

( marker ) \ second approach

  \ XXX UNDER DEVELOPMENT

: marker,  ( -- a )
  here  voc-link @ dup ,
  begin
    dup cell- @  ( a nt ) swap @
  dup 0= until  drop
  np@ ,  ;
  \ Compile the data required by a a marker and return its
  \ address.

: unmarker  ( a -- )
  ;
  \ Restore the data preserved at _a_ by a marker word.

: marker  ( "name" -- )
  marker, create ,  does>  ( -- ) ( pfa )  @ unmarker  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT

  \ 2016-01-01: example taken from m3forth
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: MARKER ( "name" -- )
  here
  get-current ,
  get-order dup , 0 ?do dup , @ , loop
  create ,
  does> @ dup \ only
  dup @ set-current cell+
  dup @ >r r@ cells 2* + 1 cells - r@ 0
  ?do dup dup @ swap cell+ @ over ! swap 2 cells - loop
  drop r> set-order
  there
  ;

( marker )  \ first approach

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nt0..ntn | nt )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nt0..ntn | nt -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nt1..ntn2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ there  ;

-->

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT
  \ Code from eForth, for reference.

 \ : _MARKER ( -- ) ( R: dfa -- ) \ ???
 \   R> 2@ ( * ) DUP @ FOLLOWER !  DUP CONTEXT
 \   BEGIN >R CELL+ DUP @ DUP R@ ! WHILE R> CELL+ REPEAT ( search order )
 \   CELL+ DUP 2@ CURRENT 2!  CELL+ DUP @ ( cur wid & head )
 \   BEGIN >R  CELL+ DUP @ R@ !  R> CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   R> 2DROP ( * ) DP 2! ; COMPILE-ONLY

 \ : MARKER ( "name" -- ) \ ???
 \   ALIGN DP 2@ ( * ) FOLLOWER @ ,  CONTEXT
 \   BEGIN DUP @ DUP , WHILE CELL+ REPEAT  DROP ( search order )
 \   CURRENT 2@ , DUP , ( cur wid & head )
 \   BEGIN DUP @ , CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   ['] _MARKER : REVEAL COMPILE, ( * ) , , ;

( ~~ )


  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->

( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

( assert assert= )

  \ Credits:
  \
  \ Taken from Brad Nelson's code:
  \ http://bradn123.github.io/literateforth/out/events.fs

: assert   ( n -- )    0= if  abort  then  ;
: assert=  ( a b -- )  = assert  ;

( assert( )

  \ Credits:
  \
  \ Code and documentation from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

( .current .context order wordlists )

  \ XXX TODO -- test

need wid>name  need wid>link  need get-order

: .wid ( wid -- )
  space dup wid>name @ ?dup if  .name drop exit  then  0 u.r  ;

: .current  ( -- )  get-current .wid  ;

: .context  ( -- )
  get-order begin  ?dup  while  swap .wid 1-  repeat  ;

: order  ( -- )
  cr ." Search: " .context cr ." Define: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

 : wordlists  ( -- )
   voc-link
   begin  @ ?dup  while  dup .wid wid>link  repeat  ;
   \ List all wordlists.
   \ XXX FIXME -- prints only one

