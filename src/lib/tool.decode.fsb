  \ tool.decode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604151341

  \ -----------------------------------------------------------
  \ Description

  \ The `decode` utility.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions (volume 4, number 2, page 28, 1982-07).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes
  
  \ 2015-12-24: Start converting from ITC to DTC.

  \ 2016-04-15: Fixed `decode-compile`, which had not been
  \ adapted from ITC to DTC.

( decode )

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2* spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )  cell+ dup @ >name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof

-->

( decode )

    [defined] cslit [if]
      ['] cslit     of  decode-sliteral  endof
    [then]
    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof
    [then]

  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD <> if  drop false exit  then
  1+ @  docolon =  ;
  \ Is _cfa_ a colon definition?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the colon interpreter.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is _pfa_ a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @  ( pfa+n xt ) dup decode-end? 0=
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      >body ( pfa+n pfa' ) dup indent+  body>name .name
      key case  [char] q  of  sp0 @ sp! quit  endof
                      bl  of  drop            endof
                swap recurse  \ default
          endcase  decode-special  cell+  -1 decode-level +!
    repeat  indent >name .name
            \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined  ( nt | 0 )  dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

  \ vim: filetype=soloforth
