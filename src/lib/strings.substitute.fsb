  \ strings.substitute.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201701221655

  \ -----------------------------------------------------------
  \ Description

  \ Forth-2012's `substitute`.

  \ -----------------------------------------------------------
  \ Author

  \ Unknown. Published in the documentation of Forth-2012.
  \
  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2017-01-21: First version, adapted from the documentation
  \ of Forth-2012.
  \
  \ 2017-01-22: Improve documentation. Make the code more clear
  \ by renaming and a bit of factoring.

( substitute )

need find-substitution  need /counted-string

'%' cconstant substitute-delimiter
  \ Character used as the substitution name delimiter.

create name /counted-string 1+ chars allot
  \ Substitution name as a counted string.

variable /substitute-result
  \ Maximum length of the destination buffer.

2variable substitute-result
  \ Destination string current length and address.

variable substitute-error
  \ Zero or an error code.

: char>substitute-result  ( c -- )
  substitute-result @ /substitute-result @ <
  if    substitute-result 2@ + c! 1 chars substitute-result +!
  else  drop #-78 substitute-error !  then  ;
  \ Add the character _c_ to the destination string.

: form-name  ( ca len -- ca' len' )
  1 /string 2dup substitute-delimiter scan >r drop
    \ Find length of residue.
  2dup r> - dup >r name place
    \ Save name in buffer.
  r> char+ /string  ;
    \ Step over name and trailing "%".

  \ Given a source string _ca len_ pointing at a leading
  \ delimiter, place the name string in the name buffer.
  \
  \ XXX TODO -- simplify, just scan, dont't copy the string

-->

( substitute )

: string>substitute-result  ( ca len -- )
  bounds ?do  i c@ char>substitute-result  loop  ;
  \ Add a string to the output string.
  \ XXX TODO -- faster, not character by character

: (process-name)  ( ca len -- f )
  find-substitution dup >r
  if    execute count string>substitute-result
  else  substitute-delimiter char>substitute-result
        name count string>substitute-result
        substitute-delimiter char>substitute-result
  then  r>  ;
  \ Process the substitution name _ca len_. Return _true_ if
  \ found; return _false_ if not found.

: process-name  ( -- f )  name count (process-name)  ;
  \ Process the last substitution name. Return _true_ if found;
  \ return _false_ if not found.

: substitute-delimiter?  ( ca -- f )
  c@ substitute-delimiter =  ;

-->

( substitute )

: substitute  ( ca1 len1 ca2 len2 -- ca2 len3 n )
   /substitute-result ! 0 substitute-result 2! 0 -rot
   \ ( -- 0 ca1 len1 )
   substitute-error off
   begin  dup 0>  while  ( -- n ca1 len1 )
     over substitute-delimiter? if
       over char+ substitute-delimiter?
       if    substitute-delimiter char>substitute-result
             2 /string
       else  form-name process-name if  rot 1+ -rot  then
       then
     else
       over c@ char>substitute-result 1 /string
     then
   repeat   2drop substitute-result 2@ rot
            substitute-error @ ?dup if  nip  then  ; 

  \ XXX REMARK -- Note that this version is simplistic,
  \ performs no error checking, and requires a global buffer
  \ and global variables.

  \ XXX TODO -- use a variable to hold the count

  \ doc{
  \
  \ substitute  ( ca1 len1 ca2 len2 -- ca2 len3 n )

  \
  \ Perform substitution on the string _ca1 len1_ placing
  \ the result at string _ca2 len3_, where _len3_ is the length
  \ of the resulting string. An error occurs if the resulting
  \ string will not fit into _ca2 len2_ or if _ca2_ is
  \ the same as _ca1_. The return value _n_ is positive or 0
  \ on success and indicates the number of substitutions made.
  \ A negative value for _n_ indicates that an error occurred,
  \ leaving _ca2 len3_ undefined, and being _n_ the exception
  \ code.
  \
  \ Substitution occurs left to right from the start of
  \ _ca1_ in one pass and is non-recursive.  When text  of
  \ a  potential substitution  name, surrounded  by "%" (ASCII
  \ $25)  delimiters is  encountered  by `substitute`, the
  \ following occurs:
  \
  \  1. If the name is null, a single delimiter character is
  \  passed to the output, i.e., "%%" is replaced by "%". The
  \  current number of substitutions is not changed.
  \
  \  2. If the text is a valid substitution name acceptable to
  \  `replaces`, the leading and trailing
  \  delimiter characters and the enclosed substitution name
  \  are replaced by the substitution text. The current number
  \  of substitutions is incremented.
  \
  \  3. If the text is not a valid substitution name, the name
  \  with leading and trailing delimiters is passed unchanged
  \  to the output. The current number of substitutions is not
  \  changed.
  \
  \  4. Parsing of the input string resumes after the trailing
  \  delimiter.
  \
  \ If after processing any pairs of delimiters, the residue of
  \ the input string contains a single delimiter,  the residue
  \ is passed unchanged to the output.
  \
  \ See: `replaces`, `unescape`.
  \
  \ }doc

