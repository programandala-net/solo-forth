  \ strings.substitute.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201701222017

  \ -----------------------------------------------------------
  \ Description

  \ Forth-2012's `substitute`.

  \ -----------------------------------------------------------
  \ Author

  \ Unknown. Published in the documentation of Forth-2012.
  \
  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2017-01-21: First version, adapted from the documentation
  \ of Forth-2012.
  \
  \ 2017-01-22: Improve documentation. Make the code more clear
  \ by renaming and a bit of factoring. Make it faster with Z80
  \ code. Rewrite some parts to make the intermediate buffer
  \ unnecessary.

( substitute )

need find-substitution

'%' cconstant substitute-delimiter
  \ Character used as the substitution name delimiter.

  \ doc{
  \
  \ substitute-delimiter  ( -- c )
  \
  \ A character constant that returns the character used as
  \ delimiter by `substitute`. By default it's "%".
  \
  \ See: `substitute`, `substitute-delimiter?`.
  \
  \ }doc

variable /substitute-result
  \ Maximum length of the destination buffer.

2variable substitute-result
  \ Destination string current length and address.

variable substitute-error
  \ Zero or an error code.

: c>substitute-result  ( c -- )
  substitute-result @ /substitute-result @ <
  if    substitute-result 2@ + c! 1 chars substitute-result +!
  else  drop #-78 substitute-error !  then  ;
  \ Add the character _c_ to the destination string.
  \ XXX TODO -- use a specific exception code

: str>substitute-result  ( ca len -- )
  bounds ?do  i c@ c>substitute-result  loop  ;  -->

  \ Add a string to the output string.
  \ XXX TODO -- faster, not character by character

( substitute )

: get-substitution  ( ca1 len1 -- ca3 len3 ca2 len2 )
  1 /string 2dup substitute-delimiter scan dup
  if    dup >r 1 /string 2swap r> -
  else  2swap #-78 substitute-error !  then  ;
  \ Given a source string _ca1 len1_ pointing at a leading
  \ delimiter, divide into the delimited substitution _ca2
  \ len2_ and the residue _ca3 len3_ of the string
  \
  \ If no ending delimiter can be found, `substitute-error` is
  \ updated, the substitution is the whole string after the
  \ starting delimiter, and the residue is an empty string.
  \
  \ XXX TODO -- use a specific exception code

: substituted?  ( ca len -- f )
  2dup find-substitution dup >r
  if    execute count str>substitute-result 2drop
  else  substitute-delimiter c>substitute-result
        str>substitute-result
        substitute-delimiter c>substitute-result  then  r>  ;
  \ Process the substitution _ca len_. Return _true_ if
  \ found and substituted; return _false_ if not found.

need >body

code substitute-delimiter?  ( ca -- f )
  E1 c, 3A c, ' substitute-delimiter >body , BE c,
  \ pop hl
  \ ld a,(substitute_delimiter)
  \ cp (hl)
  CA c, ' true , C3 c, ' false , end-code  -->
  \ jp z,true
  \ jp false

  \ doc{
  \
  \ substitute-delimiter?  ( ca -- f )
  \
  \ Does _ca_ contains the character hold in the character
  \ constant `substitute-delimiter`? If so return _true_, else
  \ return _false_.
  \
  \ This word is a factor of `substitute`.
  \
  \ This word is written in Z80. Its equivalent code is Forth
  \ is the following:
  \
  \ ----
  \ : substitute-delimiter?  ( ca -- f )
  \  c@ substitute-delimiter =  ;
  \ ----
  \
  \ See: `substitute`, `substitute-delimiter`.
  \
  \ }doc

( substitute )

: substitute  ( ca1 len1 ca2 len2 -- ca2 len3 n )
   /substitute-result ! 0 substitute-result 2! 0 -rot
   \ ( -- 0 ca1 len1 )
   substitute-error off
   begin  dup 0>  while  ( -- n ca1 len1 )
     over substitute-delimiter? if
       over char+ substitute-delimiter?
       if    substitute-delimiter c>substitute-result
             2 /string
       else  get-substitution
             substituted? if  rot 1+ -rot  then
       then
     else  over c@ c>substitute-result 1 /string  then
   repeat  2drop substitute-result 2@ rot
           substitute-error @ ?dup if  nip  then  ;

  \ XXX REMARK -- Note that this version is simplistic,
  \ performs no error checking, and requires a global buffer
  \ and global variables.

  \ XXX TODO -- use a variable to hold the count

  \ doc{
  \
  \ substitute  ( ca1 len1 ca2 len2 -- ca2 len3 n )

  \
  \ Perform substitution on the string _ca1 len1_ placing
  \ the result at string _ca2 len3_, where _len3_ is the length
  \ of the resulting string. An error occurs if the resulting
  \ string will not fit into _ca2 len2_ or if _ca2_ is
  \ the same as _ca1_. The return value _n_ is positive or 0
  \ on success and indicates the number of substitutions made.
  \ A negative value for _n_ indicates that an error occurred,
  \ leaving _ca2 len3_ undefined, and being _n_ the exception
  \ code.
  \
  \ Substitution occurs left to right from the start of
  \ _ca1_ in one pass and is non-recursive.  When text  of
  \ a  potential substitution  name, surrounded  by "%" (ASCII
  \ $25)  delimiters is  encountered  by `substitute`, the
  \ following occurs:
  \
  \  1. If the name is null, a single delimiter character is
  \  passed to the output, i.e., "%%" is replaced by "%". The
  \  current number of substitutions is not changed.
  \
  \  2. If the text is a valid substitution name acceptable to
  \  `replaces`, the leading and trailing
  \  delimiter characters and the enclosed substitution name
  \  are replaced by the substitution text. The current number
  \  of substitutions is incremented.
  \
  \  3. If the text is not a valid substitution name, the name
  \  with leading and trailing delimiters is passed unchanged
  \  to the output. The current number of substitutions is not
  \  changed.
  \
  \  4. Parsing of the input string resumes after the trailing
  \  delimiter.
  \
  \ If after processing any pairs of delimiters, the residue of
  \ the input string contains a single delimiter,  the residue
  \ is passed unchanged to the output.
  \
  \ See: `replaces`, `unescape`, `substitute-delimiter?`.
  \
  \ }doc

  \ vim: filetype=soloforth
