  \ graphics.circle.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201701281743

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of `circle`.

  \ -----------------------------------------------------------
  \ Authors

  \ rtunes
  \ (https://worldofspectrum.org/forums/profile/259/rtunes),
  \ 2008.  Published in
  \ <http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/>.
  \
  \ Marcos Cruz (programandala.net) adapted the code to Solo
  \ Forth, 2015, 2016, 2017.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2017-01-02: Convert from `z80-asm` to `z80-asm,`.
  \
  \ 2017-01-05: Update `need z80-asm,` to `need assembler`.
  \
  \ 2017-01-28: Finish the conversion of the original code of
  \ `circle`.  Document the word.

( circle )

  \ Credit:
  \
  \ <http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/>.
  \ Code adapted from:
  \ <http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/>,
  \ which was written and published by rtunes
  \ (https://worldofspectrum.org/forums/profile/259/rtunes),
  \ 2008.

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

need assembler  need (pixel-addr)

create (plot  ( -- )  asm

  ED c, 43 c, 5C7D , CD c, (pixel-addr) ,
    \ ld ($5C7D),bc     ; update COORDS
    \ call pixel_addr   ; HL = screen address
    \                   ; A = pixel position in hl (0..7)
  CD c, 22EC , C9 c,  end-asm
    \ call $22EC        ; ROM PLOT-SUB + 7
    \ ret
  \ XXX TMP --

create circle-plot  ( -- a )  asm
  h push, b push, d push, (plot call,
  d pop, b pop, h pop, ret,
  end-asm
  \ XXX TMP --

-->

( circle )

need assembler  need l:  need l#

code circle  ( gx gy b -- )

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

  h pop, l a ld, d pop, h pop, l d ld, b push, 0 h ld#, a l ld,
    \ pop hl
    \ ld a,l ; A = radius
    \ pop de ; E = gy
    \ pop hl
    \ ld d,l ; D = gx
    \ push bc ; Save Forth IP
    \ ld h,0 ; H = x -- init to 0
    \ ld l,a ; L = y -- init to radius
  exx, cpl, a c ld, FF b ld#, b incp, 1 h ldp#, b addp, exde,
    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc ; BC' = -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl ; DE' = f = 1-radius ; f error control
  c rl, b rl, 5 h ldp#, b addp, 3 b ldp#, exx,
    \ rl c
    \ rl b ; -2*radius
    \ ld hl,5
    \ add hl,bc ; HL' = ddfy = 5-2*r
    \ ld bc,3 ; BC' = ddfx = 3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
 
  \ org $8F69 ; XXX TMP -- for debugging 
  rbegin  d a ld, h add, a c ld, e a ld, l add, a b ld,
  circle-plot call,
    \ org $8F69 ; XXX TMP -- for debugging
    \ ld a,d ; point #1
    \ add a,h
    \ ld c,a
    \ ld a,e
    \ add a,l
    \ ld b,a
    \ call circle_plot

  e a ld, l sub, a b ld, circle-plot call,
    \ ld a,e ;point #2
    \ sub l
    \ ld b,a
    \ call circle_plot

  d a ld, h sub, a c ld, circle-plot call,
    \ ld a,d ;point #4
    \ sub h
    \ ld c,a
    \ call circle_plot

  e a ld, l add, a b ld, circle-plot call,
    \ ld a,e ;point #3
    \ add a,l
    \ ld b,a
    \ call circle_plot

  d a ld, l add, a c ld, e a ld, h add, a b ld,
  circle-plot call,
    \ ld a,d ;point #5
    \ add a,l
    \ ld c,a
    \ ld a,e
    \ add a,h
    \ ld b,a
    \ call circle_plot

  e a ld, h sub, a b ld, circle-plot call,
    \ ld a,e ;point #6
    \ sub h
    \ ld b,a
    \ call circle_plot

  d a ld, l sub, a c ld, circle-plot call,
    \ ld a,d ;point #8
    \ sub l
    \ ld c,a
    \ call circle_plot

  e a ld, h add, a b ld, circle-plot call,  -->
    \ ld a,e ;point #7
    \ add a,h
    \ ld b,a
    \ call circle_plot

( circle )

  \ ;********main logic***********

  h a ld, l cp, c? rwhile  \ y x > while
  \ control:
    \ ld a,h  ; H = x
    \ cp l    ; L = y
    \ jr nc,end_circle ; while (y>x)

  exx, d 7 bit, 2 l# nz? ?jr,
    \ exx
    \ bit 7,d  ;if f>0
    \ jr nz,fneg

  \ fpos:

  exde, d addp, exde, h incp, h incp, exx, l dec, 3 l# jr,
    \ ex de,hl
    \ add hl,de
    \ ex de,hl
    \ inc hl  ; HL' = ddfy
    \ inc hl
    \ exx
    \ dec l
    \ jr fneg2

    \ ;end if
  2 l: exde, b addp, exde, exx,
  \ org $8FB0 ; XXX TMP -- for debugging
  \ fneg:
    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  3 l: exx, b incp, b incp, h incp, h incp, exx, h inc, rrepeat
  \ org $8FB4 ; XXX TMP -- for debugging
  \ fneg2:
    \ exx
    \ inc bc ; BC' = ddfx
    \ inc bc
    \ inc hl
    \ inc hl
    \ exx
    \ inc h ; H = x
    \ jr loop ; repeat
 
  \ end_circle:
  \ org $8F8D ; XXX TMP -- for debugging
  9 l: exx, b pop, next ix ldp#, jpnext,  end-code

    \ exx
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore Forth IX
    \ _jp_next
  
  \ doc{
  \
  \ circle  ( gx gy b -- )
  \
  \ Draw a circle at center coordinates _gx gy_ and with radius
  \ _b_.
  \
  \ This word does not use the ROM routine and it's much
  \ faster.
  \
  \ Note no error checking is done: the whole circle must fit
  \ the screen. Otherwise, strange things will happen when
  \ other parts of the screen bitmap, the screen attributes or
  \ even the system variables will be altered.
  \
  \ }doc

  \ vim: filetype=soloforth

