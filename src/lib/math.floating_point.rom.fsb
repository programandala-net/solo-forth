  \  math.floating_point.rom.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604182318

  \ -----------------------------------------------------------
  \ Description

  \ A floating point implementation that uses the ROM
  \ calculator.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development.
  \
  \ 2016-04-11: Revision. Code reorganized. First improvements.
  \
  \ 2016-04-12: Started `f.` and `f,`.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Made `f.` immune to the ROM bug. Fixed
  \ `ftrunc`. Moved the ROM calculator to its own file.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Write `fliteral`, `ffield:`, `fvalue`,
  \ environmental queries.
  \
  \ XXX TODO -- Write safer alternatives for the ambiguous
  \ conditions listed in Forth-2012.
  \
  \ XXX TODO -- Test everything.
  \
  \ XXX TODO -- Document.

( --fp-rom-- )

  \ XXX TMP -- for development

need +thru

1 22 +thru

: --fp-rom-- ;

( float float+ floats )

5 constant float

: float+  ( fa1 -- fa2 )  float +  ;
: floats  ( n1 -- n2 )  float *  ;

( fp0 fp (fp@ fp@ empty-fs fdepth )

need float

23651 constant fp0  \ STKBOT system variable
23653 constant fp   \ STKEND system variable

  \ Note: The calculator stack grows towards higher memory, and
  \ `fp` points to the first free position, therefore above top
  \ of stack.

: (fp@  ( -- a )  fp @  ;

: fp@  ( -- a )  (fp@ float -  ;

: empty-fs  ( -- )  fp0 @ fp !  ;
  \ XXX TODO -- try alternative: ROM routine $16BF

: fdepth  ( -- n )  (fp@ fp0 @ - float /  ;

( end-calculator-flag )

need macro  need f>s  need call-xt

: f>flag  ( -- f ) ( F: rf -- )  f>s negate  ;

  \ Convert a floating-poing flag _rf_ (1|0) to an actual flag
  \ _f_ in the data stack.

macro end-calculator-flag  ( -- f ) ( F: 1|0 -- )
  [ calculator-wordlist >order ] end-calculator [ previous ]
  ['] f>flag call-xt  jpnext endm

  \ Exit the ROM calculator and convert a flag calculated by
  \ it (_1|0_) to a well-formed flag on the data stack.
  \
  \ This macro is a common factor of all floating point logical
  \ operators.

( f= f<> )

need calculator  need end-calculator-flag

code f<>  ( -- f ) ( F: r1 r2 -- )
  calculator  <>  end-calculator-flag  end-code
  \ XXX FIXME -- it always return true

code f=  ( -- f ) ( F: r1 r2 -- )
  calculator  =  end-calculator-flag  end-code
  \ XXX FIXME -- it always return true

  \ code f~ \ XXX TODO

( f0< f0= f0<> f0> )

need calculator  need end-calculator-flag

code f0<  ( -- f ) ( F: r -- )
  calculator  0<  end-calculator-flag  end-code

code f0=  ( -- f ) ( F: r -- )
  calculator  0=  end-calculator-flag  end-code

code f0<>  ( -- f ) ( F: r -- )
  calculator  0= 0=  end-calculator-flag  end-code

code f0>  ( -- f ) ( F: r -- )
  calculator  0>  end-calculator-flag  end-code

( f< f<= f> f>= )


need calculator  need end-calculator-flag

code f<  ( -- f ) ( F: r1 r2 -- )
  calculator  <  end-calculator-flag  end-code
  \ XXX FIXME -- it always return true

code f<=  ( -- f ) ( F: r1 r2 -- )
  calculator  <=  end-calculator-flag  end-code

code f>  ( -- f ) ( F: r1 r2 -- )
  calculator  >  end-calculator-flag  end-code
  \ XXX FIXME -- it always return true

code f>=  ( -- f ) ( F: r1 r2 -- )
  calculator  >=  end-calculator-flag  end-code

( fdrop fdup fswap fover )

need calculator

code fdrop  ( F: r -- )
  calculator  drop  end-calculator  jpnext  end-code

code fdup  ( F: r -- r r )
  calculator  dup  end-calculator  jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calculator  swap  end-calculator  jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calculator  over  end-calculator  jpnext  end-code

( frot -frot )

need calculator

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calculator
    1 >mem drop swap 1 mem> swap
  end-calculator  jpnext  end-code

code -frot  ( F: r1 r2 r3 -- r3 r1 r2 )
  calculator
    swap 1 >mem drop swap 1 mem>
  end-calculator  jpnext  end-code

( f+ f- f* f/ fmod )

need calculator  need fdup  need f0=

code f+  ( F: r1 r2 -- r3 )
  calculator  +  end-calculator  jpnext  end-code

code f-  ( F: r1 r2 -- r3 )
  calculator  -  end-calculator  jpnext  end-code

code f*  ( F: r1 r2 -- r3 )
  calculator  *  end-calculator  jpnext  end-code

code f/  ( F: r1 r2 -- r3 )
  calculator  /  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r2_ is zero, the calculator issues
  \ "number too big" BASIC error, what crashes the system.  It
  \ could be trapped with G+DOS. A safe alternative `?f/` is
  \ provided.

: ?f/  ( F: r1 r2 -- r3 )  fdup f0= #-42 ?throw f/  ;
  \ Safe version of `f/`. If _r2_ is zero, an exception
  \ is thrown.

code fmod  ( F: r1 -- r2 )
  calculator  mod  end-calculator  jpnext  end-code

( fmax )

need calculator

code fmax  ( F: r1 r2 -- r1|r2 )
  calculator
    2dup >  ( F: r1 r2 rf -- )
    if    swap drop  ( F: r1 )
    else  drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

( fmin )

need calculator

code fmin  ( F: r1 r2 -- r1|r2 )
  calculator
    2dup <  ( F: r1 r2 rf -- )
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

( fsgn fabs fnegate )

need calculator

code fsgn  ( F: r1 -- -1|0|1 )
  calculator  sgn  end-calculator  jpnext  end-code

code fabs  ( F: r1 -- r2 )
  calculator  abs  end-calculator  jpnext  end-code

code fnegate  ( F: r1 -- r2 )
  calculator  negate  end-calculator  jpnext  end-code

( fln fexp f** fsqrt )

need calculator  need fdup  need f0<

code fln  ( F: r1 -- r2 )
  calculator  ln  end-calculator  jpnext  end-code

code fexp  ( F: r1 -- r2 )
  calculator  exp  end-calculator  jpnext  end-code

code f**  ( F: r1 -- r2 )
  calculator  **  end-calculator  jpnext  end-code

code fsqrt  ( F: r1 -- r2 )
  calculator  sqrt  end-calculator  jpnext  end-code

  \ XXX FIXME -- when _r1_ is negative, the calculator issues
  \ "invalid argument" BASIC error, what crashes the system.
  \ Maybe it could be trapped with G+DOS. A safe alternative
  \ `?fsqrt` is provided.

: ?fsqrt  ( F: r1 -- r2 )  fdup f0< #-46 ?throw f/  ;
  \ Safe version of `fsqrt`. If _r1_ is negative, an exception
  \ is thrown.

( f0 f1 fhalf fpi2/ f10 )

need calculator

code f0  ( F: -- r )
  calculator  zero  end-calculator  jpnext  end-code

code f1  ( F: -- r )
  calculator  one  end-calculator  jpnext  end-code

code fhalf  ( F: -- r )
  calculator  half  end-calculator  jpnext  end-code

code fpi2/  ( F: -- r )
  calculator  pi2/  end-calculator  jpnext  end-code

code f10  ( F: -- r )
  calculator  ten  end-calculator  jpnext  end-code

( frestack b>f u>f s>f f>s )

need calculator  need fnegate

code frestack  ( F: r -- r' )
  calculator  re-stack  end-calculator  jpnext end-code
  \ Restacks an integer in full floating point form.

code b>f  ( b -- ) ( F: -- r )
  D9 c, E1 c, 78 05 + c, CD c, 2D28 , D9 c,  jpnext  end-code
    \ exx
    \ pop hl
    \ ld a,l
    \ call $2D28 ; STACK_A ROM routine
    \ exx
  \ XXX TODO -- test

code u>f  ( u -- ) ( F: -- r )
  D9 c, C1 c, CD c, 2D2B , D9 c,  jpnext  end-code
    \ exx
    \ pop bc
    \ call $2D2B ; STACK_BC ROM routine
    \ exx

: s>f  ( n -- ) ( F: -- r )
  dup 0< if  abs u>f fnegate  else  u>f  then  ;
  \ XXX TODO -- test

code f>s  ( -- n ) ( F: r -- )
  D9 c, CD c, 2DA2 , C5 c, D9 c,  jpnext  end-code
    \ exx
    \ call $2DA2 ; FP_TO_BC ROM routine
    \ push bc
    \ exx
  \ XXX TODO -- test

  \ code f>d  ( -- d ) ( F: r -- )
  \ end-code
  \ XXX TODO

  \ code d>f  ( d -- ) ( F: -- r )
  \ end-code
  \ XXX TODO

  \ code f>string  ( -- ca len ) ( F: r -- )
  \ end-code
  \ XXX TODO -- command $2E

  \ : >float  ;
  \ XXX TODO --

( f! f@ )

need z80-asm

code f!  ( fa -- ) ( F: r -- )
  exx  2BF1 call  \ STK_FETCH ROM routine
       hl pop  a m ld  hl incp
               e m ld  hl incp  d m ld  hl incp
               c m ld  hl incp  b m ld
  exx  jpnext end-code

  \ doc{
  \
  \ f!  ( fa -- ) ( F: r -- )
  \
  \ Store _r_ at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

code f@  ( fa -- ) ( F: -- r )
  exx  hl pop m a ld  hl incp
              m e ld  hl incp  m d ld  hl incp
              m c ld  hl incp  m b ld
              2AB6 call  \ STK_STORE ROM routine
  exx  jpnext end-code

  \ doc{
  \
  \ f@  ( fa -- ) ( F: -- r )
  \
  \ _r_ is the value stored at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

( f, fconstant fvariable )

need f!

: f,  ( -- ) ( F: r -- )  here float allot f!  ;

  \ doc{
  \
  \ f,  ( -- ) ( F: r -- )
  \
  \ Reserve data space for one floating-point number and store
  \ _r_ in that space.
  \
  \ Origin: Gforth.
  \
  \ }doc

: fconstant  ( "name" -- )  ( F: r -- )  create  f,  does>  ;

  \ doc{
  \
  \ fconstant  ( "name" -- )  ( F: r -- )
  \
  \ Create a floating-point constant called "name" with value
  \ _r_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

: fvariable  ( "name" -- )  create  float allot  ;

( facos fasin fatan fcos fsin ftan )

need calculator

code facos  ( F: r1 -- r2 )
  calculator  acos  end-calculator  jpnext  end-code

code fasin  ( F: r1 -- r2 )
  calculator  asin  end-calculator  jpnext  end-code

code fatan  ( F: r1 -- r2 )
  calculator  atan  end-calculator  jpnext  end-code

code fcos  ( F: r1 -- r2 )
  calculator  cos  end-calculator  jpnext  end-code

code fsin  ( F: r1 -- r2 )
  calculator  sin  end-calculator  jpnext  end-code

code ftan  ( F: r1 -- r2 )
  calculator  tan  end-calculator  jpnext  end-code

( (f. f. )

need fdepth  need fdrop

code (f.  ( F: r -- )
  C5 c,  CD c, 2DE3 ,  C1 c,
    \ push bc
    \ call $2DE3  ; PRINT_FP ROM routine
    \ pop bc
  jpnext  end-code
  \ Note: `exx` can no be used to preserve `bc`, the Forth IP,
  \ because the routine uses the alternative registers.  `bc`
  \ is saved on the stack instead.

: f.  ( F: r -- )
  fdepth >r  (f. space
  fdepth r> = if  fdrop  then  ;

  \ Note: the depth of the stack must be checked because
  \ there's a bug in the PRINT-FP ROM routine called "unbalaced
  \ stack error". When the number is a non-integer less than 1,
  \ a zero is left on the stack.  This bug is documented in the
  \ ZX Spectrum ROM disassembly. Credit: Tony Stratton, 1982.

  \ XXX FIXME -- The Forth-2012 standard reads `f.` must use
  \ fixed-point notation, but in this implementation the
  \ decimal point is not shown at the end when the number is
  \ integer.

( .fs dump-fs )

need (fp@  need fp0  need f@  need f.
need fdepth  need float  need float+  need .depth

: (.fs  ( -- )  (fp@ fp0 @ ?do  i f@ f.  float +loop  ;

: .fs   ( -- )  fdepth dup .depth 0> if  (.fs  then  ;

: (dump-fs  ( -- )
  cr ." Bottom"
  (fp@ fp0 @ ?do
    i dup cr u. float bounds ?do  i c@ 4 .r  loop
  float +loop  cr ." Top" cr  ;
  \ XXX TODO -- improve: print the top at the top

: dump-fs  ( -- )  fdepth dup .depth 0> if  (dump-fs  then  ;

( fround floor ftrunc )

need calculator  need f0=  need f0<  need fdup  need fnegate

: fround  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ fround  ( r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round to
  \ nearest" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

: floor  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ negative infinity" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc


code ftrunc  ( F: r1 -- r2 )
  calculator  truncate  end-calculator  jpnext  end-code

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ zero" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

  \ Example from the documentation of Forth-2012:

  \ : ftrunc  ( F: r1 -- r2 )
  \   fdup f0= 0= if
  \     fdup f0< if  fnegate floor fnegate  else  floor  then
  \   then  ;

  \ From Gforth:
  \
  \ : ftrunc  ( F: r1 -- r2 )  f>d d>f ;

( falign faligned )

need alias

' noop alias falign     ( -- )        immediate
' noop alias faligned   ( a -- fa )   immediate
  \ ' noop alias sfalign    ( -- )        immediate
  \ ' noop alias sfaligned  ( a -- dfa )  immediate
  \ ' noop alias dfalign    ( -- )        immediate
  \ ' noop alias dfaligned  ( a -- dfa )  immediate

  \ vim: filetype=soloforth
