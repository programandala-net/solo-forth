  \ meta.test.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605051551

  \ -----------------------------------------------------------
  \ Description

  \ Development tests.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]` and `char`, which have been
  \ moved to the library.
  \
  \ 2016-04-28: Move the tests of `type-center`, `type-left`
  \ and `type-right` from the module "printing.type.fsb".
  \ Add `?ccase-test`, `ccase0-test`. Add `jk-test`.
  \
  \ 2016-05-01: `color-test`.
  \
  \ 2016-05-05: `search-test`.

( alias-test synonym-test )

  \ 2015-11-24

need alias need synonym

' literal alias literal-a
' border alias border-a
' if alias if-a

synonym border-s border
synonym literal-s literal
synonym if-s if

  \ XXX TMP -- alternative `synonym` that uses `alias`
synonym2 border-s2 border
synonym2 literal-s2 literal
synonym2 if-s2 if

  \ : ifa if-a ." yes" then ;   \ "then" error #-4
  \ : ifs if-s ." yes" then ;   \ ok
  \ : ifs2 if-s2 ." yes" then ;   \ "then" error #-4
  \
  \ 1 literal     \ error -14 \ ok
  \ 1 literal-a   \ no error
  \ 1 literal-s   \ error -14 \ ok
  \ 1 literal-s2  \ no error
  \
  \ : zx [ 1 ] literal ;      \ ok
  \ : zx [ 1 ] literal-a ;    \ error #-264
  \ : zx [ 1 ] literal-s ;    \ no error \ ok
  \ : zx [ 1 ] literal-s2 ;   \ error #-264

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test >body 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test >body dup here swap - dump

( {if-test {do-test )

  \ 2015-11-11

: test2  ( n -- )
  {do   dup 5 <   do> ." <5" cr 1+
  |do|  dup 10 <  do> ." <10" cr 1+
  do} drop  ;

: test1  ( n1 n2 -- )
  {if   2dup > if> ." >" cr
  |if|  2dup < if> ." <" cr
  if}  ;

( options[-test )

: o1 ." option 1" ;  : o2 ." option 2" ;  : o3 ." option 3" ;

: test  ( c -- )
  options[
    'a' option o1  'b' option o2  'c' option o3
  ]options  ." end of test" cr   ;

: retest  ( -- )  'a' test ." end of retest" cr  ;

: o0 ." default" ;

: testd  ( c -- )
  options[
    'a' option o1  'b' option o2  'c' option o3
    default-option o0
  ]options  ;

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( exception-test )

  \ Credit:
  \
  \ Code from MPE Forth for TiniARM User Manual.

: could-fail  ( -- c )
  key dup 'q' =
  if  -1 throw  then  ;

: do-it  ( a b -- c )
  2drop could-fail  ;

: try-it  ( -- )
  1 2 ['] do-it catch
  if    ( x1 x2 )  2drop ." There was an exception" cr
  else  ." The character was " emit cr then  ;

: retry-it  ( -- )
  begin   1 2 ['] do-it catch
  while   ( x1 x2 ) 2drop ." Exception, keep trying" cr
  repeat  ( c )
  ." The character was " emit cr  ;

( err>ord )

  \ XXX TMP -- `err>ord` tests `error>ordinal`

: err>ord  ( -- )
  91 1 do  i . i error>ordinal ."  -> " . cr  loop
  286 256 do  i . i error>ordinal ."  -> " . cr  loop
  1025 1000 do  i . i error>ordinal ."  -> " . cr  loop ;

( type-fields-test )

need type-left  need type-center  need type-right

s" La Mancha" 2constant text

: ruler  ( -- )  home '-' 32 emits home  ;

: ready  ( -- )
  0 1 at-xy ." Press any key to continue"
  key drop ruler  ;

-->

( type-fields-test )

: test  ( -- )  page

  ready text text nip type-left
  ready text 32 type-left
  ready text 5 type-left

  ready text text nip type-center
  ready text 32 type-center
  ready text 5 type-center

  ready text text nip type-right
  ready text 32 type-right
  ready text 5 type-right  ;

: tc  ( ca len1 len2 -- )
  2dup <=> cells type-center-cases + @ >name .name  ;

: tr  ( ca len1 len2 -- )
  2dup <=> cells type-right-cases + @ >name .name  ;

( ?ccase-test ccase0-test )

need ?ccase  need ccase0

: .a     ( -- )  ." Letter A"  ;
: .b     ( -- )  ." Letter B"  ;
: .c     ( -- )  ." Letter C"  ;
: .nope  ( -- )  ." Nope!"  ;
: .end   ( -- )  ."  The End" cr  ;

: ?letter  ( c -- )
  cr ." ?letter... " key drop
  s" abc" ?ccase  .a .b .c  end?ccase  .end  ;

'a' ?letter  'b' ?letter  'c' ?letter  'x' ?letter

: letter0  ( c -- )
  cr ." letter0... " key drop
  s" abc" ccase0 .nope  .a .b .c  endccase0  .end  ;

'a' letter0  'b' letter0  'c' letter0  'x' letter0

( ccase-test )

need ccase

: .a     ( -- )  ." Letter A"  ;
: .b     ( -- )  ." Letter B"  ;
: .c     ( -- )  ." Letter C"  ;
: .nope  ( -- )  ." Nope!"  ;
: .end   ( -- )  ."  The End" cr  ;

: letter  ( c -- )
  cr ." letter... " key drop
  s" abc" ccase  .a .b .c  .nope  endccase  .end  ;

'a' letter  'b' letter  'c' letter  'x' letter

( jk-test )

need j  need k

: jk-test  ( -- )
  3 0 do
    13 10 do
      23 20 do
        k . j . i . cr
      loop
    loop
  loop  ;

cr jk-test

( color-test )

  \ 2016-05-01

need color  need permcolor

: c?  ( ca -- ) c@ .  ;

: .color  ( -- )
  cr ." os-attr-t " os-attr-t c?
  cr ." os-mask-t " os-mask-t c?
  cr ." os-attr-p " os-attr-p c?
  cr ." os-mask-p " os-mask-p c?  ;

( search-test )

  \ 2016-05-05

  \ Test the bug recently discovered in the code of `search`
  \ that was adapted from DZX-Forth.

256 constant /long-string
create long-string /long-string allot

: -long-string  ( -- )  long-string /long-string blank  ;
  \ Blank the long string.

s"  zx " 2constant substring

: place-substring  ( n -- )
  -long-string substring rot long-string + 1- swap cmove  ;
  \ Place the substring at offset _n_ of the long string.

: search-at  ( n -- )
  dup place-substring long-string swap substring search
  .s drop 2drop  ;
  \ Search the first _n_ characters of the long string for the
  \ substring, which is placed at offset _n_.

: run  ( -- )
  cr ." Search at 128:" 128 search-at
  cr ." Search at 64:" 64 search-at
  cr ." Search at 32:" 32 search-at  ;

  \ XXX NOTE: In fact, the substring is found at any position.

( lineload-test )

  \ Do `n locate lineload-test lineload` where "n" is the line
  \ number of this block.

  .( line 1 ) cr
  .( line 2 ) cr
  .( line 3 ) cr
  .( line 4 ) cr
  .( line 5 ) cr
  .( line 6 ) cr
  .( line 7 ) cr
  .( line 8 ) cr
  .( line 9 ) cr
  .( line 10 ) cr
  .( line 11 ) cr
  .( line 12 ) cr
  .( line 13 ) cr
  .( line 14 ) cr
  .( line 15 ) cr
.( block x line 0)
  .( block x line 1 ) cr
  .( block x line 2 ) cr
  .( block x line 3 ) cr
  .( block x line 4 ) cr
  .( block x line 5 ) cr
  .( block x line 6 ) cr
  .( block x line 7 ) cr
  .( block x line 8 ) cr
  .( block x line 9 ) cr
  .( block x line 10 ) cr
  .( block x line 11 ) cr
  .( block x line 12 ) cr
  .( block x line 13 ) cr
  .( block x line 14 ) cr
  .( block x line 15 ) cr
.( block x+1 line 0)
  .( block x+1 line 1 ) cr
  .( block x+1 line 2 ) cr
  .( block x+1 line 3 ) cr
  .( block x+1 line 4 ) cr
  .( block x+1 line 5 ) cr
  .( block x+1 line 6 ) cr
  .( block x+1 line 7 ) cr
  .( block x+1 line 8 ) cr
  .( block x+1 line 9 ) cr
  .( block x+1 line 10 ) cr
  .( block x+1 line 11 ) cr
  .( block x+1 line 12 ) cr
  .( block x+1 line 13 ) cr
  .( block x+1 line 14 ) cr
  .( block x+1 line 15 ) cr

( XXX TMP -- block for temporary tries)

need thru
blk @ 1+ blk @ 2+ thru

( XXX TMP -- block for temporary tries)

: hello  ( -- )

  ;

  \ vim: filetype=soloforth
