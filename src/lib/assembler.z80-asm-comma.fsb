  \ assembler.z80-asm-comma.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.

  \ Last modified: 201611141919

  \ -----------------------------------------------------------
  \ Description

  \ A alternative Z80 assembler, called `z80-asm,`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015-12-25: First changes:
  \
  \   1. "," suffixes in Z80 instructions;
  \   2. one single set of conditions;
  \   3. "a" and "r" prefixes in control structures;
  \   4. condition "m" is renamed to "ne".

  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module.  Fixed `execute-hl`,
  \ then renamed it and `call-xt` with a trailing comma, to
  \ avoid loading them instead of the versions written for the
  \ first assembler.

  \ 2016-05-08:
  \
  \ - Rename conditions to the original names plus "?".
  \ - Rename `|mark` to `>amark`.
  \ - Rename `|resolve` to `>aresolve`.
  \ - Rename "resmark"-like words to "rmark"-like.
  \ - Rename "resresolve"-like words to "rresolve"-like.
  \ - Remove "retCOND"-like and "callCOND"-like macros.
  \ - Compact the blocks.
  \ - Add `?jp` and `?jr` for conditional jumps.
  \ - Remove "jpCOND"-like and "jrCOND"-like opcodes.
  \ - Change the opcode values of the conditions.
  \ - Rename `?page` to `?jr-range`.
  \ - Rename `clr,` to `clrp,`; add new `clr,`.

  \ 2016-05-09: Save and restore the compile word list, the
  \ current radix and the search order.
  \
  \ 2016-11-14: Now `call,` is defined in the kernel, where it
  \ already existed with the old name `code-field,`. Compact
  \ the code, save one block.  Move `8*` to the 1-cell
  \ operators module.

  \ -------------------------------------------------------------
  \ XXX TODO

  \ - Combine changes 2..4 with the previous version.
  \ - Make absolute-jump control structures optional.
  \ - Use `get-order` at the start and `set-order` at the end.
  \ - Document.

( z80-asm, )

get-current forth-wordlist set-current

need ?pairs  need 3dup  need 8*

: z80-asm,  ( -- )  assembler  ;

also assembler definitions base @ hex

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?jr-range  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  create c, does>  ( -- ) ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- ) ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- ) ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;  -->
  \ Bit manipulation of registers.

( z80-asm, )

  \ Defining words for z80 instructions

: m8  ( 16b "name" -- ) create , does>  ( -- ) ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: (jr,)  ( a op -- )  c, here 1+ - ?jr-range c,  ;
  \ Compile a relative jump _op_ to absolute address _a_.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- ) ( a pfa )  c@ (jr,)  ;
  \ Relative jumps.

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;  -->
  \ Bit manipulation with index registers.

( z80-asm, )

  \ Opcodes

  \ XXX FIXME ftap

  \ XXX OLD -- CD m5 call,
  \ `call,` is already defined in the kernel

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 22 m5 sthl,
27 m1 daa, 2A m5 fthl, 2F m1 cpl, 32 m5 sta, 37 m1 scf, 3A m5
fta, 3F m1 ccf, 76 m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98
m2 sbc, B8 m2 cp, C1 m3 pop, C3 m5 jp, C5 m3 push, C6 m4 add#,
C7 m2 rst, C9 m1 ret, CE m4 adc#, D3 m4 out, 41 m3
outbc, D6 m4 sub#, D9 m1 exx, DB m4 in, 40 m3 inbc, 0DE m4
sbc#, E3 m1 exsp, E6 m4 and#, E9 m1 jphl, EB m1 exde, EE m4
xor#, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FB m1 ei, FE m4 cp#, 00
m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6 rr, 20 m6 sla, 28 m6 sra, 38
m6 srl,  40 m7 bit, 80 m7 res, C0 m7 set, B0ED m8 ldir, B8ED m8
lddr, 44ED m8 neg, 57ED m8 ldai, 47ED m8 ldia, 56ED m8 im1 5EED
m8 im2 B1ED m8 cpir, 6FED m8 rld, A0 m2 and, B0 m2 or,  A8 m2
xor, -->

( z80-asm, )

  \ Opcodes

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ld#,  ;
  \ Macro to clear an 8-bit register with zero.
: clrp,  ( rp -- )  0 swap ldp#,  ;
  \ Macro to clear a 16-bit register with zero.
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;
  \ Macro, 16-bit register load.
: subp,  ( rp -- )  a and, sbcp,  ;
  \ Macro, 16-bit subtract.
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;  -->
  \ Macro to test 16-bit register for zero.

( z80-asm, )

  \ ZX Spectrum specific

CF m4 hook,  \ rst $08
D7 m1 prt,   \ rst $16

  \ Index register opcodes

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, )

  \ Conditions

  \ Conditions are Z80 opcodes for the required absolute jump
  \ instruction.

CA constant z?  C2 constant nz? DA constant c? D2 constant nc?
EA constant pe? E2 constant po? FA constant m? F2 constant p?

: jp>jr  ( op1 -- op2 )  dup nc? > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

: ?ret,  ( op -- )  2- c,  ;
  \ Conditional ret

: ?call,  ( a op -- )  2+ c, ,  ;
  \ Conditional call

: ?jp,  ( a op -- )  c, ,  ;
  \ Conditional absolute jump

: ?jr,  ( a op -- )  jp>jr (jr,)  ;
  \ Conditional relative jump

  \ Control structures with relative jumps

: >rmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.

: rresolve  ( orig dest -- )  1- over - ?jr-range swap c!  ;
  \ Resolve a relative branch.

: >rresolve  ( orig -- )  here rresolve  ;
  \ Resolve a forward relative branch.

: <rresolve  ( dest -- )  here 1- swap rresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, )

  \ Control structures with relative jumps

: inverse-cond  ( op1 -- op2 )  8 xor  ;
  \ Convert a condition flag (actually, an absolute jump
  \ opcode) to its opposite.
  \
  \ Examples: `c?` to `nc?` (jpc to jpnc); nz? to z? (jpnz to
  \ jpz); etc.

: rahead  ( -- orig  )  18 , >rmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.
  \ Note: $18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr inverse-cond , >rmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >rresolve  ;

: relse  ( orig cs-id -- cs-id )
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note: $18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <rresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`
  \ Note: $18 is the opcode of `jr`.

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`
  \ Note: $10 is the Z80 opcode for `djnz`.

( z80-asm, )

  \ Control structures with absolute jumps

: aif  (  op -- orig cs-id )  inverse-cond c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ Note: $C3 is the opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.
  \ Note: $C3 is the opcode of `jp`

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: >amark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: >aresolve  ( a -- )  >amark swap !  ;
  \ Resolve an absolute forward reference.

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

base ! set-current previous

( execute-hl, call-xt, )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm,  need macro

macro execute-hl,  ( -- )
  0000 bc stp,  >amark      \ save the Forth IP
  0000 bc ldp#, >amark      \ point IP to phony_compiled_word
  jphl,                     \ execute the xt in HL
  >resolve                  \ phony_compiled_word
  here cell+ ,              \ point to the phony xt following
  0000 bc ldp#  >aresolve   \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt,  ( xt -- )
  hl ldp#,  execute-hl,
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
