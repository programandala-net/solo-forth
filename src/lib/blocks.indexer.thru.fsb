  \ blocks.indexer.thru.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201611241642

  \ -----------------------------------------------------------
  \ Description

  \ Blocks Thru Indexer
  \
  \ A blocks indexer that changes the default behaviour of
  \ `need` and related words: The whole disk is indexed first,
  \ and then `need and family uses the index instead of
  \ searching the blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-02: Start.
  \
  \ 2016-04-03: First working version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has
  \ been moved from the kernel to the library.
  \
  \ 2016-05-05: Update `s=` to `str=`. Improve documentation.
  \
  \ 2016-05-07: New method: the indexed word is an alias, which
  \ doesn't use data space, and its execution token is the
  \ block it's associated to. This way, no data space is used
  \ by the index.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \
  \ 2016-08-05: Compact the code to save one block.
  \
  \ 2016-11-13: Check the code with the far-memory system
  \ recently implemented in the kernel. Now the library disk
  \ can be indexed. Improve the documentation. Remove old
  \ unused code.
  \
  \ 2016-11-19: Move to <blocks.index-wordlist.fsb> the code
  \ shared with the new module <blocks.fly-indexer.fsb>.
  \
  \ 2016-11-24: Rename the module and some words, to be
  \ consistent with the alternative version Fly Indexer.

( make-thru-index )

only forth definitions

need common-indexer  need get-order  need set-order
need evaluate

: thru-index-reneeded  ( ca len -- )
  search-index 0= #-277 ?throw load  ;

  \ doc{
  \
  \ thru-index-reneeded  ( ca len-- )
  \
  \ Search the index word list for word _ca len_. If found,
  \ load the block it's associated to.  If not found, throw an
  \ exception -277 ("required, but not indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

: thru-index-reneed  ( "name" -- )
  parse-name thru-index-reneeded  ;

  \ doc{
  \
  \ thru-index-reneed  ( "name" -- )
  \
  \ Search the index word list for word "name". If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: thru-index-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if    thru-index-reneeded
  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ thru-index-needed ( ca len -- )
  \
  \ If word _ca len_ is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

: thru-index-need  ( "name" -- )
  parse-name thru-index-needed  ;  -->

  \ doc{
  \
  \ thru-index-need  ( "name" -- )
  \
  \ If word "name" is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `need`.
  \
  \ }doc

( make-thru-index )

: set-thru-index  ( -- )
  ['] thru-index-reneeded ['] reneeded  defer!
  ['] thru-index-reneed   ['] reneed    defer!
  ['] thru-index-need     ['] need      defer!
  ['] thru-index-needed   ['] needed    defer!
  ['] (located)           ['] located   defer!
  ['] drop                ['] unlocated defer!  ;

  \ doc{
  \
  \ set-thru-index  ( -- )
  \
  \ Change the behaviour of `need`, `needed`, `reneed`,
  \ `reneeded`, `located` and `unlocated` in order to use the
  \ blocks index created by `make-thru-index`.
  \
  \ The default behaviour of all said words can be restored by
  \ `set-no-index`.
  \
  \ See: `make-thru-index`, `set-no-index`, `set-fly-index`.
  \
  \ }doc

: (make-thru-index)  ( -- )
  last-locatable @ 1+ first-locatable @
  ?do  i index-block-header  loop  ;

  \ doc{
  \
  \ (make-thru-index)  ( -- )
  \
  \ Create the blocks index, from `last-locatable` to
  \ `last-locatable`. This word is a factor of
  \ `make-thru-index`.
  \
  \ See: `make-thru-index`, `first-locatable`,
  \ `last-locatable`.
  \
  \ }doc

: make-thru-index  ( -- )  get-current  get-order
  index-wordlist set-current  indexer-wordlist 1 set-order
  ['] (make-thru-index) catch  dup #-278 <> swap ?throw
  set-order set-current  set-thru-index  ;

  \ doc{
  \
  \ make-thru-index  ( -- )
  \
  \ Create the blocks index and activate it. The current word
  \ list and the current search order are preserved.
  \
  \ This word changes the default behaviour of `need` `needed`,
  \ `reneed` and `reneeded`: It creates a word list from the
  \ names that are on the index (header) line of every
  \ searchable block, ignoring duplicates.  These words will
  \ load the block they belong to. This way, after indexing all
  \ the disk blocks only once, `need` will search the word list
  \ and execute the word found, which will load its block. On
  \ the contrary, the default behaviour of `need` is to search
  \ all the blocks every time.
  \
  \ The default behaviour of `need` and related words can be
  \ restored with `set-no-index`.
  \
  \ See: `need`, `needed`, `reneed`, `reneeded`,
  \ `set-thru-index`, `set-no-index`.
  \
  \ }doc

  \ vim: filetype=soloforth
