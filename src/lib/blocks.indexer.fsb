  \ blocks.indexer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- It works fine, but the indexed
  \ words (all words from the library) fill the memory bank.
  \ The solution is a configurable system bank.

  \ Last modified: 201605140237

  \ -----------------------------------------------------------
  \ Description

  \ A blocks indexer that improves the default behaviour of
  \ `need`, `needed`, `reneed` and `reneeded`: It creates a
  \ word list from the names that are on the index (header)
  \ line of every searchable block, ignoring duplicates.  These
  \ words will load the block they belong to. This way, after
  \ indexing all of the disk blocks only once, `need` will
  \ search the word list and execute the word found, instead of
  \ searching all of the blocks every time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-02: Start.
  \
  \ 2016-04-03: First working version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has
  \ been moved from the kernel to the library.
  \
  \ 2016-05-05: Update `s=` to `str=`. Improve documentation.
  \
  \ 2016-05-07: New method: the indexed word is an alias, which
  \ doesn't use data space, and its execution token is the
  \ block it's associated to. This way, no data space is used
  \ by the index.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.

( indexer )

only forth definitions

need str=  need alias  need string/
need get-order  need set-order  need nextname

wordlist constant index-wordlist
  \ Word list for the indexed words.

: search-index  ( ca len -- 0 | xt 1 | xt -1 )
  index-wordlist search-wordlist  ;
  \ Search the index for word _ca len_.

: name-indexed?  ( ca len -- f )
  search-index 0<> dup if  nip  then  ;
  \ Is word _ca len_ in the index?

variable indexed-block

  \ variable counter counter off  \ XXX INFORMER

: index-name  ( ca len -- )
  2dup name-indexed? if  2drop exit  then
  \ 1 counter +! counter ? 2dup type space np@ u.
  \ XXX INFORMER
  nextname indexed-block @ alias  ;
  \ Add word _ca len_ to the blocks index, if not done before.
  \ The current word list is supposed to be `index-wordlist`.

-->

( indexer )

wordlist dup constant indexer-wordlist set-current
  \ Word list for the words that parse the block index lines.

: (  ( "ccc<space><paren><space|eof>" -- )
  begin  parse-name 2dup s" )" str= 0=
  while  index-name  repeat  2drop  ;
  \ Parse and index the names until the next right paren name.

' ( alias .(

: \  ( "ccc<space><backslash><space|eof>" -- )
  begin  parse-name 2dup s" \" str= 0=
  while  index-name  repeat  2drop  ;
  \ Parse and index the names until the next backslash name.

forth-wordlist set-current  -->

( indexer )

: index-reneeded  ( ca len -- )
  search-index 0= #-277 ?throw load  ;

  \ doc{
  \
  \ index-reneeded  ( ca len-- )
  \
  \ Search the index word list for word _ca len_. If found,
  \ load the block it's associated to.  If not found, throw an
  \ exception -277 ("required, but not indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

: index-reneed  ( "name" -- )  parse-name index-reneeded  ;

  \ doc{
  \
  \ index-reneed  ( "name" -- )
  \
  \ Search the index word list for word "name". If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: index-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  index-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ index-needed ( ca len -- )
  \
  \ If word _ca len_ is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

: index-need  ( "name" -- )  parse-name index-needed  ;

  \ doc{
  \
  \ index-need  ( "name" -- )
  \
  \ If word "name" is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `need`.
  \
  \ }doc

: set-indexed-need  ( -- )
  ['] index-reneeded ['] reneeded  defer!
  ['] index-reneed   ['] reneed    defer!
  ['] index-need     ['] need      defer!
  ['] index-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-indexed-need  ( -- )
  \
  \ Set the alternative behaviour of `need`, `needed`, `reneed`
  \ and `reneeded`: Use the library index created by `indexer`.
  \ In fact `indexer` executes `set-indexed-need` after
  \ creating the index.
  \
  \ The default behaviour can be restored by
  \ `set-located-need`.
  \
  \ }doc

-->

( indexer )

  \ : valid-block-header?  ( ca len -- f )
  \   -trailing dup 0= #-278 ?throw
  \   2 string/ 2dup s"  )" str= >r s"  \" str= r> or  ;
  \ XXX TODO -- remove

  \ XXX OLD
  \ doc{
  \
  \ valid-block-header?  ( ca len -- f )
  \
  \ Is block header _ca len_ valid?
  \ Valid block headers end with " )" or " /".
  \ If it's empty, throw error -278 in order to quit
  \ the indexing.
  \
  \ }doc

  \ XXX OLD
  \ : index-block-header  ( ca len -- )
  \   2dup valid-block-header? if  evaluate exit  then  2drop  ;
  \ Index block header _ca len_, if it's valid.

need evaluate

: index-block  ( +n -- )
  dup indexed-block ! 0 swap line>string evaluate  ;
  \ Index block _+n_.

  \ XXX OLD
  \ dup indexed-block ! 0 swap line>string index-block-header  ;

: (indexer)  ( -- )  last-locatable @ 1+ first-locatable @
                     ?do  i index-block  loop  ;
  \ Create the blocks index.

: indexer  ( -- )
  get-current  get-order
  index-wordlist set-current  indexer-wordlist 1 set-order
  ['] (indexer) catch  dup #-278 <> swap ?throw
  set-order set-current  set-indexed-need  ;

  \ doc{
  \
  \ indexer  ( -- )
  \
  \ Create the blocks index and activate it. The current
  \ word list and the current search order are preserved.
  \
  \ }doc

  \ vim: filetype=soloforth
