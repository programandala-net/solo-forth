  \ screen_mode.fzx.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains the FZX screen mode.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 set-drive  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( xc yc -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credits:
  \
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    r now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  r add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) call
  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
