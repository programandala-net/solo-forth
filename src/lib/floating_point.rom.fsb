  \ floating_point.rom.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604181259

  \ -----------------------------------------------------------
  \ Description

  \ A floating point implementation that uses the ROM
  \ calculator.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development.
  \
  \ 2016-04-11: Revision. Code reorganized. First improvements.
  \
  \ 2016-04-12: Started `f.` and `f,`.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Made `f.` immune to the ROM bug. Fixed
  \ `ftrunc`.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX FIXME -- When the calculator stack is out of bounds,
  \ the calculator could issue a BASIC error and crash the
  \ system. Test it.
  \
  \ XXX TODO -- Move the stack and make it configurable. The
  \ default location is limited by the small free memory left
  \ to BASIC.
  \
  \ XXX TODO -- Write `fliteral`, `ffield:`, `fvalue`,
  \ environmental queries.
  \
  \ XXX TODO -- Write safer alternatives for the ambiguous
  \ conditions listed in Forth-2012.
  \
  \ XXX TODO -- Move the ROM calculator extensions to their own
  \ module.
  \
  \ XXX TODO -- Use a word list for the calculator commands.
  \ This way they will not need a prefix.

( --fp-rom-- )

  \ XXX TMP -- for development

need +thru

1 28 +thru

: --fp-rom-- ;

( float float+ floats )

5 constant float

: float+  ( n1 -- n2 )  float +  ;
: floats  ( n1 -- n2 )  float *  ;

( calc calc-end end-calc )

need macro

  \ Two assembler macros to make it easier to use the ROM
  \ calculator.

macro calc  ( -- )  C5 c, EF c,  endm
  \ Compile the assembler instructions to start the ROM
  \ calculator:
  \ ----
  \ push bc ; save the Forth IP
  \ rst $28 ; call the ROM calculator
  \ ----

macro calc-end  ( -- )  38 c,  endm
  \ Compile the `end-calc` ROM calculator command.
  \ ----
  \ db $38 ; exit the ROM calculator
  \ ----

macro end-calc  ( -- )  calc-end C1 c,  endm
  \ Compile the assembler instructions to exit the ROM calculator:
  \ ----
  \ db $38 ; `end-calc` ROM calculator command
  \ pop bc ; restore the Forth IP
  \ ----

( calc-drop calc-dup calc-swap calc-over calc>mem calc<mem )

macro calc-drop  ( -- )  02 c,  endm
  \ Compile the `drop` ROM calculator command.

macro calc-dup  ( -- )  31 c,  endm
  \ Compile the `dup` ROM calculator command.

macro calc-swap  ( -- )  01 c,  endm
  \ Compile the `swap` ROM calculator command.

macro calc>mem  ( n -- )  C0 + c,  endm
  \ Compile the `st-mem` ROM calculator command for memory
  \ number _n_ (0..5). Note: The float stack TOS is copied, not
  \ moved.

macro calc<mem  ( n -- )  E0 + c,  endm
  \ Compile the `get-mem` ROM calculator command for memory
  \ number _n_ (0..5).

macro calc-over  ( -- )
  2 calc>mem calc-drop 1 calc>mem 2 calc<mem 1 calc<mem  endm
  \ Compile the ROM calculator commands to do `over`.

( calc-negate calc-not )

macro calc-negate  ( -- )  1B c,  endm
  \ Compile the `negate` ROM calculator command.

macro calc-not  ( -- )  30 c,  endm
  \ Compile the `not` ROM calculator command.

( calc<> calc= calc> calc< calc<= calc>= )

macro calc<>  ( -- )  0B c,  endm
  \ Compile the `nos-neql` ROM calculator command.

macro calc=  ( -- )  0E c,  endm
  \ Compile the `nos-eql` ROM calculator command.

macro calc>  ( -- )  0C c,  endm
  \ Compile the `no-grtr` ROM calculator command.

macro calc<  ( -- )  0D c,  endm
  \ Compile the `no-less` ROM calculator command.

macro calc<=  ( -- )  09 c,  endm
  \ Compile the `no-l-eql` ROM calculator command.

macro calc>=  ( -- )  0A c,  endm
  \ Compile the `no-gr-eql` ROM calculator command.

( calc0< calc0> )

macro calc0>  ( -- )  36 c,  endm
  \ Compile the `less-0` ROM calculator command.

macro calc0<  ( -- )  37 c,  endm
  \ Compile the `greater-0` ROM calculator command.

( calc-?branch calc-branch calc-mark> calc-resolve> )

need alias

macro calc-?branch  ( -- )  00 c,  endm
  \ Compile the `jump-true` ROM calculator command.

macro calc-branch  ( -- )  33 c,  endm
  \ Compile the `jump` ROM calculator command.

: >calc-mark  ( -- a )  here 0 c,  ;

  \ Compile space for the displacement of a ROM calculator
  \ forward branch which will later be resolved by
  \ `>calc-resolve`.
  \
  \ Typically used after either `calc-branch` or
  \ `calc-?branch`.

: from-here  ( a -- n )  here swap -  ;
  \ Calculate the displacement _n_ from the current data-space
  \ pointer to address _a_.

: >calc-resolve  ( a -- )  dup from-here swap c!  ;

  \ Resolve a ROM calculator forward branch by placing the
  \ displacement to the current position into the space
  \ compiled by `>calc-mark`.

' here alias <calc-mark  ( -- a )

  \ Leave the address of the current data-space pointer as the
  \ destination of a ROM calculator backward branch which will
  \ later be resolved by `<calc-resolve`.
  \
  \ Typically used before either `calc-branch` or
  \ `calc-?branch`.

: <calc-resolve  ( a -- )  from-here c,  ;

  \ Resolve a ROM calculator backward branch by compiling the
  \ displacement from the current position to the address left
  \ by `<calc-mark`.

( fp0 fp (fp@ fp@ empty-fs fdepth )

need float

23651 constant fp0  \ STKBOT system variable
23653 constant fp   \ STKEND system variable

  \ Note: The calculator stack grows towards higher memory, and
  \ `fp` points to the first free position, therefore above top
  \ of stack.

: (fp@  ( -- a )  fp @  ;

: fp@  ( -- a )  (fp@ float -  ;

: empty-fs  ( -- )  fp0 @ fp !  ;
  \ XXX TODO -- try alternative: ROM routine $16BF

: fdepth  ( -- n )  (fp@ fp0 @ - float /  ;

( end-calc-flag )

need macro  need f>s  need call-xt

: f>flag  ( -- f ) ( F: 1|0 -- )  f>s negate  ;

  \ Convert a ROM calculator flag in the float stack (_1|0_) to
  \ an actual flag _wf_ in the stack.

macro end-calc-flag  ( -- wf ) ( F: 1|0 -- )
  end-calc ['] f>flag call-xt  jpnext endm

  \ Exit the ROM calculator and convert a a flag calculated by
  \ it (_1|0_) to an actual flag _wf_ in the stack.
  \
  \ This macro is a common factor of all floating point logical
  \ operators.

( f= f<> )

need calc  need end-calc-flag  need calc=  need calc<>
need calc-not  \ XXX TMP --

code f<>  ( -- wf ) ( F: r1 r2 -- )
  calc calc<> end-calc-flag  end-code
    \ XXX TODO -- test
    \ XXX FIXME -- always returns 0
  \ calc calc= calc-not end-calc-flag  end-code

code f=  ( -- wf ) ( F: r1 r2 -- )
  calc calc= end-calc-flag  end-code

  \ code f~ \ XXX TODO

( f0< f0= f0<> f0> )

need calc  need end-calc-flag
need calc-not  need calc0>  need calc0<

code f0<  ( -- wf ) ( F: r -- )
  calc calc0< end-calc-flag  end-code

code f0=  ( -- wf ) ( F: r -- )
  calc calc-not end-calc-flag  end-code

code f0<>  ( -- wf ) ( F: r -- )
  calc calc-not calc-not end-calc-flag  end-code

code f0>  ( -- wf ) ( F: r -- )
  calc calc0> end-calc-flag  end-code

( f< f<= f> f>= )

need calc  need end-calc-flag
need calc<  need calc>  need calc<=  need calc>=

code f<  ( -- wf ) ( F: r1 r2 -- )
  calc calc< end-calc-flag  end-code

code f<=  ( -- wf ) ( F: r1 r2 -- )
  calc calc<= end-calc-flag  end-code

code f>  ( -- wf ) ( F: r1 r2 -- )
  calc calc> end-calc-flag  end-code

code f>=  ( -- wf ) ( F: r1 r2 -- )
  calc calc>= end-calc-flag  end-code

( fdrop fdup fswap fover )

need calc  need calc-over  need calc-drop  need calc-dup
need calc-swap

code fdrop  ( F: r -- )
  calc calc-drop end-calc jpnext  end-code

code fdup  ( F: r -- r r )
  calc calc-dup end-calc jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calc calc-swap end-calc jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calc calc-over end-calc jpnext  end-code

( frot -frot )

need calc  need calc>mem  need calc<mem  need calc-drop

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calc 3 calc>mem calc-drop
       2 calc>mem calc-drop
       1 calc>mem calc-drop
       2 calc<mem 3 calc<mem 1 calc<mem
  end-calc jpnext  end-code

code -frot  ( F: r1 r2 r3 -- r3 r1 r2 )
  calc 3 calc>mem calc-drop
       2 calc>mem calc-drop
       1 calc>mem calc-drop
       3 calc<mem 1 calc<mem 2 calc<mem
  end-calc jpnext  end-code

( f+ f- f* f/ fmod )

need calc  need fdup  need f0=

code f+  ( F: r1 r2 -- r3 )
  calc 0F c, end-calc jpnext  end-code

code f-  ( F: r1 r2 -- r3 )
  calc 03 c, end-calc jpnext  end-code

code f*  ( F: r1 r2 -- r3 )
  calc 04 c, end-calc jpnext  end-code
  \ XXX FIXME --
  \ F: fp2/ 2 -- crash!
  \ F: 60000 0.5 -- 60000 0
  \ F: 1 0.5 -- 1 0
  \ F: 0.5 1 -- 0.5 0

code f/  ( F: r1 r2 -- r3 )
  calc 05 c, end-calc jpnext  end-code
  \ XXX FIXME -- when _r2_ is zero, the calculator issues
  \ "number too big" BASIC error, what crashes the system.  It
  \ could be trapped with G+DOS. A safe alternative `?f/` is
  \ provided.

: ?f/  ( F: r1 r2 -- r3 )  fdup f0= #-42 ?throw f/  ;
  \ Safe version of `f/`. If _r2_ is zero, an exception
  \ is thrown.

code fmod  ( F: r1 -- r2 )
  calc 32 c, end-calc jpnext  end-code

( fmax )

need calc  need calc-over  need calc>  need calc-drop
need calc-swap  need calc-?branch  need calc-branch

code fmax  ( F: r1 r2 -- r1|r2 )
  calc  calc-over calc-over calc>  ( F: r1 r2 rf -- )
        calc-?branch >calc-mark ( Compilation: a1 )
        calc-swap calc-drop  ( F: r1 )
        calc-branch >calc-mark ( Compilation: a1 a2 )
        swap >calc-resolve  \ resolve the first branch
        calc-drop  ( F: r2 )
        >calc-resolve  \ resolve the second branch
  end-calc jpnext  end-code

( fmin )

need calc  need calc-over  need calc>  need calc-drop
need calc-swap  need calc-?branch  need calc-branch

code fmin  ( F: r1 r2 -- r1|r2 )
  calc  calc-over calc-over calc<  ( F: r1 r2 rf -- )
        calc-?branch >calc-mark ( Compilation: a1 )
        calc-drop  ( F: r1 )
        calc-branch >calc-mark ( Compilation: a1 a2 )
        swap >calc-resolve  \ resolve the first branch
        calc-swap calc-drop  ( F: r2 )
        >calc-resolve  \ resolve the second branch
  end-calc jpnext  end-code

( fsign fabs fnegate )

need calc  need calc-negate

code fsign  ( F: r1 -- r2 )
  calc 29 c, end-calc jpnext  end-code

code fabs  ( F: r1 -- r2 )
  calc 2A c, end-calc jpnext  end-code

code fnegate  ( F: r1 -- r2 )
  calc calc-negate end-calc jpnext  end-code

( fln fexp f** fsqrt )

need calc  need fdup  need f0<

code fln  ( F: r1 -- r2 )
  calc 25 c, end-calc jpnext  end-code

code fexp  ( F: r1 -- r2 )
  calc 26 c, end-calc jpnext  end-code

code f**  ( F: r1 -- r2 )
  calc 06 c, end-calc jpnext  end-code

code fsqrt  ( F: r1 -- r2 )
  calc 28 c, end-calc jpnext  end-code

  \ XXX FIXME -- when _r1_ is negative, the calculator issues
  \ "invalid argument" BASIC error, what crashes the system.
  \ Maybe it could be trapped with G+DOS. A safe alternative
  \ `?fsqrt` is provided.

: ?fsqrt  ( F: r1 -- r2 )  fdup f0< #-46 ?throw f/  ;
  \ Safe version of `fsqrt`. If _r1_ is negative, an exception
  \ is thrown.

( f0 f1 fhalf fpi2/ f10 )

need calc

code f0  ( F: -- r )
  calc A0 c, end-calc jpnext  end-code

code f1  ( F: -- r )
  calc A1 c, end-calc jpnext  end-code

code fhalf  ( F: -- r )
  calc A2 c, end-calc jpnext  end-code

code fpi2/  ( F: -- r )
  calc A3 c, end-calc jpnext  end-code

code f10  ( F: -- r )
  calc A4 c, end-calc jpnext  end-code

( b>f u>f s>f f>s )

need calc  need fnegate

code restack  ( F: r -- r' )
  calc  3D c,  end-calc  jpnext end-code
  \ Restacks an integer in full floating point form.
  \
  \ XXX TODO -- Better name. Maybe `refloat`, `>f`.  "re-stack"
  \ is the command of the ROM calculator.
  \
  \ XXX TODO -- remove, keep only the calculator command

code b>f  ( b -- ) ( F: -- r )
  D9 c, E1 c, 78 05 + c, CD c, 2D28 , D9 c,  jpnext  end-code
    \ exx
    \ pop hl
    \ ld a,l
    \ call $2D28 ; STACK_A ROM routine
    \ exx
  \ XXX TODO -- test

code u>f  ( u -- ) ( F: -- r )
  D9 c, C1 c, CD c, 2D2B , D9 c,  jpnext  end-code
    \ exx
    \ pop bc
    \ call $2D2B ; STACK_BC ROM routine
    \ exx

: s>f  ( n -- ) ( F: -- r )
  dup 0< if  abs u>f fnegate  else  u>f  then  ;
  \ XXX TODO -- test

code f>s  ( -- n ) ( F: r -- )
  D9 c, CD c, 2DA2 , C5 c, D9 c,  jpnext  end-code
    \ exx
    \ call $2DA2 ; FP_TO_BC ROM routine
    \ push bc
    \ exx
  \ XXX TODO -- test

  \ code f>d  ( -- d ) ( F: r -- )
  \ end-code
  \ XXX TODO

  \ code d>f  ( d -- ) ( F: -- r )
  \ end-code
  \ XXX TODO

  \ code f>string  ( -- ca len ) ( F: r -- )
  \ end-code
  \ XXX TODO -- command $2E

  \ : >float  ;
  \ XXX TODO --

( f! f@ )

need z80-asm

code f!  ( fa -- ) ( F: r -- )
  exx  2BF1 call  \ STK_FETCH ROM routine
       hl pop  a m ld  hl incp
               e m ld  hl incp  d m ld  hl incp
               c m ld  hl incp  b m ld
  exx  jpnext end-code

code f@  ( fa -- ) ( F: -- r )
  exx  hl pop m a ld  hl incp
              m e ld  hl incp  m d ld  hl incp
              m c ld  hl incp  m b ld
              2AB6 call  \ STK_STORE ROM routine
  exx  jpnext end-code

( f, fconstant fvariable )

need f!

: f,  ( -- ) ( F: r -- )  here float allot f!  ;

: fconstant  ( "name" -- )  ( F: f -- )  create  f,  does>  ;

: fvariable  ( "name" -- )  create  float allot  ;

( facos fasin fatan fcos fsin ftan )

need calc

code facos  ( F: r1 -- r2 )
  calc 23 c, end-calc jpnext  end-code

code fasin  ( F: r1 -- r2 )
  calc 22 c, end-calc jpnext  end-code

code fatan  ( F: r1 -- r2 )
  calc 24 c, end-calc jpnext  end-code

code fcos  ( F: r1 -- r2 )
  calc 20 c, end-calc jpnext  end-code

code fsin  ( F: r1 -- r2 )
  calc 1F c, end-calc jpnext  end-code

code ftan  ( F: r1 -- r2 )
  calc 21 c, end-calc jpnext  end-code

( (f. f. )

code (f.  ( F: r -- )
  C5 c,  CD c, 2DE3 ,  C1 c,
    \ push bc
    \ call $2DE3  ; PRINT_FP ROM routine
    \ pop bc
  jpnext  end-code
  \ Note: `exx` can no be used to preserve `bc`, the Forth IP,
  \ because the routine uses the alternative registers.  `bc`
  \ is saved on the stack instead.

: f.  ( F: r -- )
  fdepth >r  (f. space
  fdepth r> = if  fdrop  then  ;

  \ Note: the depth of the stack must be checked because
  \ there's a bug in the PRINT-FP ROM routine called "unbalaced
  \ stack error". When the number is a non-integer less than 1,
  \ it's not removed from the stack at the end, and a zero is
  \ pushed on the stack.  This bug is documented in the ROM
  \ disassembly. Credit: Tony Stratton, 1982.

  \ XXX FIXME -- The Forth-2012 standard reads `f.` must use
  \ fixed-point notation, but in this implementation the
  \ decimal point is not shown at the end when the number is
  \ integer.

( .fs dump-fs )

need (fp@  need fp0  need f@  need f.
need fdepth  need float  need float+  need .depth

: (.fs  ( -- )  (fp@ fp0 @ ?do  i f@ f.  float +loop  ;

: .fs   ( -- )  fdepth dup .depth 0> if  (.fs  then  ;

: (dump-fs  ( -- )
  cr ." Bottom"
  (fp@ fp0 @ ?do
    i dup cr u. float bounds ?do  i c@ 4 .r  loop
  float +loop  cr ." Top" cr  ;

: dump-fs  ( -- )  fdepth dup .depth 0> if  (dump-fs  then  ;

( fround floor ftrunc )

need calc  need f0=  need f0<  need fdup  need fnegate

: fround  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ fround  ( r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round to
  \ nearest" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

: floor  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ negative infinity" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc


code ftrunc  ( F: r1 -- r2 )
  calc 3A c, end-calc jpnext  end-code

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ zero" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

  \ Example from the documentation of Forth-2012:

  \ : ftrunc  ( F: r1 -- r2 )
  \   fdup f0= 0= if
  \     fdup f0< if  fnegate floor fnegate  else  floor  then
  \   then  ;

  \ From Gforth:
  \
  \ : ftrunc  ( F: r1 -- r2 )  f>d d>f ;

( falign faligned )

need alias

' noop alias falign     ( -- )        immediate
' noop alias faligned   ( a -- fa )   immediate
  \ ' noop alias sfalign    ( -- )        immediate
  \ ' noop alias sfaligned  ( a -- dfa )  immediate
  \ ' noop alias dfalign    ( -- )        immediate
  \ ' noop alias dfaligned  ( a -- dfa )  immediate

( xx )

  \ XXX TMP -- for debugging the bug of the PRINT-FP ROM
  \ routine

  \ List the floating-point stack, showing the value returned
  \ by `fp@` after every step:

: xx  ( -- )
  (fp@ fp0 @ ?do
    cr i fp@ u.
    f@
    \ the pointer is increased by `f@`
    fp@ u.
    '[' emit f. ']' emit
    \ the pointer is restored after `f.`, except when
    \ the printed float is non-integer and less than 1
    fp@ u.
  float +loop  ;

  \ vim: filetype=soloforth
