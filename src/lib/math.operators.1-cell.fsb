  \ math.operators.1-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605020257

  \ -----------------------------------------------------------
  \ Description

  \ Single-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015: Add `within`, `between`, and common operators.
  \ 2015-08-12: Add `lshift`. Improve `2/`.
  \ 2015-08-14: Add `under+`, in Forth.
  \ 2015-11-01: Add `rshift` and faster `lshift`.
  \ 2015-11-13: Add `sqrt` (version by Wil Baden).
  \ 2015-12-15: Rewrote `under+` in Z80.
  \ 2015-12-21: Add `polarity`.
  \ 2015-12-22: Add `%` and `u%`.
  \ 2015-12-29: Add second version of `sqrt` (from Computer One
  \ Forth).
  \ 2016-03-20: Add `+under`, a variant of `under+`.
  \ 2016-04-05: Add `cell/`.
  \ 2016-04-07: Add `bits`, generic version of `pixels`.
  \ 2016-04-27: Add `sgn`, `<=>`, `either`, `neither`.
  \ 2016-04-28: Fix `<=>`. Add `0max`.
  \ 2016-05-01: Add `clshift`.
  \ 2016-05-02: Compact the blocks to save space. Remove `sgn`
  \ because `polarity` does the same already.

( under+ +under )

need [if]

[needed] under+ [if]

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c, D1 c, C1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop de
  \ pop bc
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `+under`.
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \   rot + swap  ;
  \ ----
  \
  \ }doc

[then]

[needed] +under [if]

code +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  D9 c, C1 c, D1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop bc
  \ pop de
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `under+`
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \   >r + r>  ;
  \ ----
  \
  \ }doc

[then]

  \ XXX TODO -- variant after PFE's `(under+)`:
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;

( within between % u% )

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ Credit:
  \
  \ Code from DZX-Forth.

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit

: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/between.html

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ }doc

[unneeded] %
?\ : %  ( n1 n2 -- n3 )  100 swap */  ;
  \ _n1_ is percentage _n3_ of _n2_

[unneeded] u%
?\ : u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;
  \ _u1_ is percentage _u3_ of _u2_

( polarity <=> )

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code
  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve
  78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

  \ doc{
  \
  \ polarity  ( n -- -1|0|1 )
  \
  \ If _n_ is zero, return zero.
  \ If _n_ is negative, return negative one.
  \ If _n_ is positive, return positive one.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : polarity  ( n -- -1|0|1 )
  \   dup 0= ?exit  0< ?dup ?exit  1  ;
  \ ----
  \
  \ }doc

  \ Credit:
  \
  \ Assembler version of `polarity` adapted from Z88
  \ CamelForth.

[unneeded] <=>
?\ : <=>  ( n1 n2 -- -1|0|1 )  - polarity  ;

  \ doc{
  \
  \ <=>  ( n1 n2 -- -1|0|1 )
  \
  \ If _n1_ equals _n2_, return zero.
  \ If _n1_ is less than _n2_, return negative one.
  \ If _n1_ is greater than _n2_, return positive one.
  \
  \ }doc

( u<= u>= <= >= 0>= 0<= 0max )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;  exit

[unneeded] 0max ?exit

code 0max  ( n -- n | 0 )
  E1 c,  CB c, 10 05 + c,  DA c, ' false ,  CB c, 18 05 + c,
    \ pop hl
    \ rl h ; negative?
    \ jp c,false_
    \ rr h
  jppushhl  end-code
    \ jp push_hl

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ 0max  ( n -- n | 0 )
  \
  \ If _n_ is negative, return 0; else return _n_.
  \ This is a faster alternative to the idiom `0 max`.
  \
  \ }doc

( lshift )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 16 bytes.

need z80-asm

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 19 bytes.

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is 3 bytes smaller but slower (133% the
  \ execution time of the version adapted from Z88 CamelForth).

  \ Data space used: 16 bytes.

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( clshift )

code clshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,  80 07 + c,  C3 c, ,
    \ dec e
    \ jp z,push_a
    \ add a,a
    \ jp begin
  end-code

( crshift )

  \ XXX UNDER DEVELOPMENT -- 2016-05-01

code crshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,
    \ dec e
    \ jp z,push_a
  \ 80 07 + c,
    \ rra
  C3 c, ,
    \ jp begin

  end-code

( bits )

  \ Credit:
  \
  \ Based on a pixels counter written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Data space used: 29 bytes.

need z80-asm

code bits  ( ca len -- u )

  0 hl ldp#  \ init bit count
  exx  \ save IP and count
  de pop  hl pop  \ memory zone
  begin
    d a ld  e or  nz if
      08 b ld#  \ bits per byte
      begin  m rrc  cy if  exx hl incp exx  then  step
      hl incp  de decp  \ next byte
  2swap again then
    \ Note: `2swap` is needed because `begin again` and `if
    \ then` are not nested.

  exx jppushhl end-code

  \ doc{
  \
  \ bits  ( ca len -- u )
  \
  \ Count the number of bits set in memory zone _ca len_.
  \
  \ }doc

( 2/ cell/ )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

need [if]

[needed] 2/ [needed] cell/ or [if]

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  jppushhl        \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

[then]

[unneeded] cell/  ?\ need alias  ' 2/ alias cell/
  \ Credit:
  \
  \ Idea from IsForth.

( sqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

  \ XXX TODO -- benchmark

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credit:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

  \ XXX TODO -- benchmark

need 2/

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ XXX TODO -- remove, it's in the kernel

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need sm/rem

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need fm/mod

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? either neither )

need [if]

[needed] any? [if]  need roll  variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;

  \ doc{
  \
  \ any?  ( x0 x1..xn n -- f )
  \
  \ Is any _x1..xn_ equal to _x0_?
  \
  \ Origin: F83.
  \
  \ }doc

  \ Credit:
  \
  \ Code from F83.

[then]

  \ Credit:
  \
  \ Code from IsForth (version 1.23b).

[needed] either [if]

: either  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over = -rot = or  ;

  \ doc{
  \
  \ either  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ equals either _n2|u2_ or _n3|u3_;
  \ else return _false_.
  \
  \ }doc

[then]

[needed] neither [if]

: neither  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over <> -rot <> and  ;

  \ doc{
  \
  \ neither  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ is not equal to either _n2|u2_ or
  \ _n3|u3_; else return _false_.
  \
  \ }doc

[then]

( split join )

need [if]

[needed] split [if]

code split  ( x -- b1 b2 )
  E1 c,
    \ pop hl
  16 c, 00 c,  58 05 + c,  68 04 + c,  26 c, 00 c,
    \ ld d,0
    \ ld e,l
    \ ld l,h
    \ ld h,0
  C3 c, pushhlde ,  end-code
    \ jp push_hlde

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ split  ( x -- b1 b2 )
  \
  \ Get _b1_ and _b2_ from the 2 bytes which compose _x_: _b1_
  \ is the high-order byte and _b2_ is the low-order byte.
  \
  \ See `join`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

[needed] join [if]

code join  ( b1 b2 -- x )
  D1 c,  60 03 + c,  D1 c,  68 03 + c,
    \ pop de
    \ ld h,e
    \ pop de
    \ ld l,e
  jppushhl  end-code
    \ jp push_hl

  \ doc{
  \
  \ join  ( b1 b2 -- x )
  \
  \ _b1_ is the low-order byte of _x_, and _b2_ is the
  \ high-order byte of _x_.
  \
  \ See `split`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth
