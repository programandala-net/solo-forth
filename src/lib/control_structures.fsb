  \ control_structures.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains control structures. 
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( 0if 0while 0until )  \ ==controlstructures==

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch ,
    \ jp z,branch_code ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( 0exit )

code 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                 \ pop hl
  78 04 + c,            \ ld a,h
  B0 05 + c,            \ or l
  CA c, ' exit ,        \ jp z,exit_code
  jpnext                \ jp next

  end-code

  \ doc{
  \
  \ 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _f_ is zero, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `0exit` is not intended to be used within a do-loop. Use
  \ `0= if unloop exit then` instead.
  \
  \ In Solo Forth `0exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

code -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                   \ pop hl
  CB c, 7C c,             \ bit 7,h ; negative?
  C2 c, ' exit ,          \ jp nz,exit_code
  jpnext                  \ jp next

  end-code

  \ doc{
  \
  \ -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _n_ is negative, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `-exit` is not intended to be used within a do-loop. Use
  \ `0< if unloop exit then` instead.
  \
  \ In Solo Forth `-exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

( retry ?retry )

  \ Credits:
  \
  \ Code of `retry` from an article by Richard Astle in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

need name>body

: retry  ( -- )
  latest name>body postpone again
  ; immediate compile-only

: ?retry  ( run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

( base-execute )

  \ Credits:
  \
  \ Word from Gforth.

: base-execute  ( xt n -- )  base @ >r execute r> base !  ;
  \ Execute _xt_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

( cs-pick cs-roll cs-swap cs-drop )

need alias need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this in the kernel:

  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value
  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

( begincase )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

need cs-push  need cs-pop

: begincase
  postpone case  postpone begin  cs-push  ; immediate

: (nextcase)
  cs-pop  postpone again  postpone endcase  ; immediate

: nextcase
  postpone drop  postpone (nextcase)  ; immediate

: test
  begincase
    cr ." press a key ('2' '4' '9' exits) : " key
    [char] 2 of  ." ... 2 "  endof
    [char] 4 of  ." ... 4 "  endof
    [char] 9 of  ." ... 9 "  endof
      dup emit ."  try again"
  nextcase  ;

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX first version

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

  \ XXX TODO
  \ code (times)  ( n -- )
  \   \ ld h,b
  \   \ ld l,c
  \   \ ld e,(hl)
  \   \ inc hl
  \   \ ld d,(hl) ; de = xt to execute
  \   end-code

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times) postpone [']  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX second version
  \ Immediate words are not allowed.

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f )  -271 ?throw  compile,
  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX third version
  \ No check is done during compilation.

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( ?? )

  \ Credits:
  \
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

( j )

code j
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop index.

  2A c, rp ,            \ ld hl,(return_stack_pointer)
  11 c, 3 cells ,       \ ld de,3*cell
  19 c,                 \ add hl,de
  C3 c, ' i 3 + ,       \ jp i_code+3

  end-code

( k )

code k
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the third loop index.

  2A c, rp ,            \ ld hl,(return_stack_pointer)
  11 c, 6 cells ,       \ ld de,6*cell
  19 c,                 \ add hl,de
  C3 c, ' i 3 + ,       \ jp i_code+3

  end-code

( i' )

code i'  ( -- x )
         ( R: loop-sys -- loop-sys )

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,        \ ld hl,(return_stack_pointer)
  11 c, 2 cells ,   \ ld de,2*cell
  19 c,             \ add hl,de
  C3 c, fetchhl ,   \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 5 cells , \ ld de,5*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( k' )

code k'
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the second next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 8 cells , \ ld de,8*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( for step )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch ,
    \ jp nz,branch_code ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( u -- )
  \
  \ Start of a `for step` loop, that will iterate _u+1_ times,
  \ starting with _u_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `r@`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

( dfor dstep di )

: (dstep)  ( R: x ud -- x ud' )

  \ doc{
  \
  \ (dstep)  ( R: x ud -- x ud' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( ud -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest )
  \ Run-time: ( ud -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `di`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

: di  ( -- ud )  ( R: x ud -- x ud )
  r> 2r@ rot >r  ;

  \ XXX TODO -- rename `dfor-i`?

  \ doc{
  \
  \ di  ( -- ud )  ( R: x ud -- x ud )
  \
  \ Return the current index _ud_ of a `dfor` loop.
  \
  \ }doc

( case )

  \ Credits:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop  begin  ?dup  while  [compile] then  repeat
  ; immediate compile-only

( case )  \ baden-case )

  \ An alternative `case` structure that makes any
  \ calculation easier.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

  \ XXX TODO rename, avoid standard names: `case`, `of`,
  \ `endof`.

defer case  ( n -- n n )  ' dup ' case defer!
defer othercase  ( n -- )  ' drop ' othercase defer!

: of  ( n f -- )
  postpone if  postpone drop  ; immediate compile-only

: endof  ( n f -- )
  postpone exit  postpone then  ; immediate compile-only  exit

  \ Usage example

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;

  \ : test  ( n -- )
  \   case 0 = of  say0  endof
  \   case 1 = of  say1  endof
  \   case 2 = of  say2  endof
  \            othercase say-other  ;
  \ ----

( case )  \ eforth-case )

  \ Credits:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  [compile] then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( case )  \ 94-doc-case )

  \ Credits:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( case )  \ abersoft-case )

  \ Credits:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credits:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credits:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credits:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credits:
  \
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credits:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID:
  \ <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credits:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credits:
  \
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 wf )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 wf )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Point "              else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  char a  .(   ) dup emit  select-test
cr  char ,  .(   ) dup emit  select-test
cr  char 8  .(   ) dup emit  select-test
cr  char ?  .(   ) dup emit  select-test
cr  char K  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ Create a word that will return the address of its pfa.

  \ Credits:
  \
  \ The idea for this word was borrowed from CP/M-volksForth
  \ 3.80a.

( positional-case: )

  \ Credits:
  \
  \ Code adapted from F83's `case:`.

need create:

: positional-case:  ( "name" -- )
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;
  \ Create a positional case word "name"
  \ At runtime, the n-th word is
  \ executed, depending upon the value on the stack. No
  \ range checking.

  \ Usage example:
  \
  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ positional-case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

( associative-case: )

  \ Credits:
  \
  \ Code adapted from Pygmy Forth's `case:`

need create:

: associative-case: ( "name" -- )
  create:
  does> ( n -- ) ( n pfa ) cell+  \ move past `lit`
  begin   2dup @ dup 0= >r  ( n a n n')
          =  r> or  0= ( n a f )
  while   ( n a )  [ 3 cells ] literal +  \ no match
  repeat  nip cell+ perform  ;

  \ doc{

  \ associative-case: ( "name" -- )
  \
  \ Create an associative case definition "name":
  \ `name  ( i*x n -- j*x )`.

  \ Usage example:

  \ ----
  \ : red       ." red"  ;
  \ : blue      ." blue"  ;
  \ : orange    ." orange"  ;
  \ : pink      ." pink"  ;
  \ : black     ." black"  ;
  \
  \ associative-case: color  ( n -- )
  \   7 red  12 blue  472 orange  15 pink  0 black  ;
  \
  \ 7 color cr  472 color cr  3000 color cr
  \ ----

  \ _n_ for default must be 0 and the default pair must be
  \ last.  Numbers can be in any order except 0 must be last.
  \ An actual zero or a no match causes the default to be
  \ executed.  Numbers can't be constants.

  \ }doc

( cases: )

  \ `cases:` structure, alternative to the standard `case`.
  \ It saves space, but is slower.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted, renamed and commented from code written by Dan
  \ Lerner, published on Forth Dimensions (volume 3, number 6,
  \ page 189, 1982-03).

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  leave
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>  say10
  \    100 case>  say100
  \   1000 case>  say1000
  \        other> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: other>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ XXX TODO -- rename? `anycase>`, `othercase>`...

  \ doc{
  \
  \ other>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required, `other>
  \ noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

( options[ )

  \ Credits:
  \
  \ `options[` is a port of IsForth's `case:`.

  \ Note: in the original IsForth code the word `(options`)
  \ (called `docase` in IsForth) is written in x86 assembler. I
  \ rewrote it from scratch, without investigating the
  \ assembler code.

  \ XXX TODO -- alternative version `coptions[`

  \ 166 bytes used.

variable (default-option)
  \ default option xt

variable #options
  \ number of compiled options

: default-option ( "name" -- )  ' (default-option) !  ;
  \ Set the default option.
  \ It can go anywhere inside a the options statement.

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option xt
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  leave then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

( options[ )

: options[  ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ number of options is 0 so far
  compile (options)           \ compile run time handler
  >mark >mark >mark  ( a1 a2 a3 )
  postpone [  ; immediate compile-only

  \ doc{
  \
  \ options[  ( -- )
  \
  \ Start an `options[` structure.

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  \ Compile an option _x_ and the xt of its action "name".
  ,  ' ,  1 #options +!  ;

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option xt
  >resolve                    \ store exit point
  ]  ;

( executions )

  \ Credits:
  \
  \ Code from Galope (module times.fs).

: executions  ( xt n -- )
  \ Execute _xt_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming". Originally published
  \ on Forth Dimensions (volume 18, number 4, pp 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 ?do  postpone then  loop  ; immediate compile-only
  \ end a conditional

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming" Originally published
  \ on Forth Dimensions (number 18, number 4, pages 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ vim: filetype=soloforth
