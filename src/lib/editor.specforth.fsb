  \ editor.specforth.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605140159

  \ -----------------------------------------------------------
  \ Description

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum.  Its original
  \ name is "Specforth Editor V1.1".
  \
  \ It has been adapted to Solo Forth.
  \
  \ Word descriptions and stack comments have been added after
  \ the Specforth manual, the Abersoft Forth manual and Dr.
  \ C.H. Ting's book _Systems Guide to fig-Forth_. The word
  \ `copy` has been adapted from Abersoft Forth. The word
  \ `text` has been rewritten.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-11: Adapted to Solo Forth.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \ 2016-05-14: Update with `parse-all`, a fixed version of old
  \ `parse-line`.

( editor )

only forth definitions

need list  need update  need flush  need parse-all

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "ccc<char>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "ccc<eol>" -- )
  pad c/l 1+ blank  parse-all  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type '_' emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "ccc<eol>"  -- )  text r  ;
  \ Put "ccc" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear block _n_ with blanks and select for editing.

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= leave  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 leave  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "ccc<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "ccc" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "ccc<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "ccc".

: till  ( "ccc<eol>" -- )
  #lead + text 1line 0= #-270 ?throw
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "ccc".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "ccc<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "ccc" to the cursor line at the cursor position.

also forth

: copy  ( n1 n2 -- )
  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ vim: filetype=soloforth
