  \ numbers.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html
  \ 
  \ This file contains words related to number conversion and
  \ notation.
  \
  \ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

( b# d# h# )

  \ Credits:
  \
  \ Based on code from eForth and code written by Wil Baden
  \ (published on Forth Dimensions 20-3, p. 27).

: base# ( -- ) ( "name" -- )
  create c, immediate
  does> c@
  base c@ >r  base !    \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

 2 base# b#
10 base# d#
16 base# h#

( b# o# d# h# t# )

  \ Credits:
  \
  \ Code from eForth.

: x# ( -- ) ( "name" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create o# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate
create t# ( "name" -- n | d ) 36 c, x# immediate

( c# )

  \ Credits:
  \
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate
  \ Parse a name and return the code of the its first
  \ character. This is an alternative to `char` and `[char]`.

( number )

: number  ( ca len -- n | d )  number? 0= #-275 ?throw  ;
  \ doc{
  \
  \ number  ( ca len -- n | d )
  \
  \ Attempt to convert a string _ca len_ into a number. If
  \ a valid point is found, return _d_; if there is no
  \ valid point, return _n_. If conversion fails due to an
  \ invalid character, an exception #-275 is thrown.
  \
  \ }doc

( standard-number-point? extended-number-point? )

need [if]

[needed] classic-number-point? [if]

: classic-number-point?  ( c -- f )
  dup [char] : = swap [char] , - 4 u< or  ;
  \ doc{
  \
  \ standard-number-point?  ( c -- f )
  \
  \ Is character _c_ a classic number point?  Allowed
  \ points are: comma, hyphen, period, slash and
  \ colon.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`.
  \
  \ }doc

[then]

[needed] extended-number-point? [if]

: extended-number-point?  ( c -- f )
  dup [char] : = swap [char] + - 5 u< or  ;
  \ doc{
  \
  \ extended-number-point?  ( c -- f )
  \
  \ Is character _c_ an extended number point?  Allowed
  \ points are: plus sign, comma, hyphen, period, slash and
  \ colon, after _Forth Programmer's Handbook_.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`.
  \
  \ }doc
  \
  \ Credits:
  \
  \ Code by Wil Baden, from Forth Dimensions (volume 20, number
  \ 3 page 26, 1998-10).

[then]

( bin. dec. hex. )

  \ Credits:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credits:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credits:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

  \ vim: filetype=soloforth
