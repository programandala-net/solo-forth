  \ word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605042148

  \ -----------------------------------------------------------
  \ Description

  \ Words related to word lists.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore.
  \
  \ 2016-05-02: Join several blocks, to save space.
  \
  \ 2016-05-04: Improve the documentation of `trail`.

( wid>link wid>name named-wid wid>vocabulary )

  \ XXX TODO -- test

need alias

' cell+ alias wid>link  ( wid -- a )

: (wid>name)  ( wid -- a )  [ 2 cells ] literal +  ;

  \ doc{
  \
  \ (wid>name)  ( wid -- a )
  \
  \ Return the address _a_ which holds the _nt_ of _wid_ (or
  \ zero if the word list has no associated name).
  \
  \ }doc

: wid>name  ( wid -- nt|0 )  (wid>name) @  ;

  \ doc{
  \
  \ wid>name  ( wid -- nt|0 )
  \
  \ Return the _nt_ of _wid_ (or zero if the word list has no
  \ associated name).
  \
  \ }doc

: named-wid  ( wid -- )  (wid>name) latest swap !  ;

  \ doc{
  \
  \ named-wid ( wid -- )
  \
  \ Associate the latest name to _wid_.
  \
  \ }doc

: wid>vocabulary  ( wid "name" -- )
  create dup , named-wid
  does>  ( -- )  ( pfa )  @ context !  ;

  \ doc{
  \
  \ wid>vocabulary  ( wid "name" -- )
  \
  \ Create a vocabulary "name" for the _wid_ word list.
  \
  \ }doc

( get-order order@ )

  \ Credit: Code from eForth.

need recurse

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@  ;

( wid-of swap-current trail find-name-in find )

[unneeded] wid-of
?\ : wid-of  ( "name" -- wid )  ' >body  ;  exit
  \ Return the _wid_ of vocabulary "name".

  \ Credit:
  \
  \ Adapted from eForth's `widof`.

[unneeded] trail
?\ : trail  ( -- nt )  context @ @  ;  exit

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the first word list
  \ of the search order.
  \
  \ }doc

need [if]     [needed] swap-current [if]

: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ;    [then]

  \ Credit:
  \
  \ Idea from lpForth.

[needed] find-name-in [if]
: find-name-in  ( ca len wid -- nt | 0 )  @ find-name-from  ;

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in
  \ word list _wid_. If the definition is found, return its
  \ _nt_, else return zero.
  \
  \ The search is case-sensitive.  // XXX TODO -- confirm
  \
  \ }doc

[then]

[needed] find [if]
: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ;  [then]

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

  \ vim: filetype=soloforth
