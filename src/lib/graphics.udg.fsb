  \ graphics.udg.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201612220053

  \ -----------------------------------------------------------
  \ Description

  \ Words related to User Defined Graphics and fonts.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-23: Add `0udg:`. Factor `0udg!` from `udg!`.
  \ Improve the documentation.
  \
  \ 2016-04-24: Add `udg[` and `0udg[`.
  \
  \ 2016-10-11: Add `udg-row[`.
  \
  \ 2016-12-21: Add `make-block-characters`,
  \ `block-characters`, `0udg>`, `set-udg`, `get-udg`,
  \ `set-font`, `get-font`, `rom-font`.

( 0udg> 0udg! udg! 0udg: udg: )

need os-udg  need 8*

[defined] first-udg ?\ #128 constant first-udg

: 0udg>  ( n -- a )  8* os-udg @ +  ;
  \ Convert UDG number _n_ (0..127) to the address _a_ of its
  \ bitmap.

: 0udg!  ( b0..b7 n -- )  0udg> dup 7 + do  i c!  -1 +loop  ;

  \ doc{
  \
  \ udg!  ( b0..b7 n -- )
  \
  \ Store the given 8 bytes into UDG number _n_ (0..127).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg!  ( b0..b7 c -- )  first-udg - 0udg!  ;

  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into UDG char _c_ (128..255).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;

  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant "name" for UDG char _c_ (128..255) and
  \ store the given 8 bytes into that UDG char.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: 0udg:  ( b0..b7 n "name" -- )  dup constant 0udg!  ;

  \ doc{
  \
  \ 0udg:  ( b0..b7 n "name" -- )
  \
  \ Create a constant "name" for UDG number _n_ (0..127) and
  \ store the given 8 bytes into UDG char _128+n_.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

( 0udg[ udg[ )

need os-udg

[defined] first-udg ?\ #128 constant first-udg
variable udg0
variable current-udg
variable current-scan

[defined] binary ?\  : binary  ( -- )  2 base !  ;

: 0udg[  ( b -- )
  dup udg0 !  current-udg !  current-scan off  binary  ;

  \ doc{
  \
  \ 0udg[  ( b -- )
  \
  \ Start a set of UDG definitions, from UDG number _b_
  \ (0..255).
  \
  \ See: `udg[`, `|`, `||`, `||]`.
  \
  \ }doc

: udg[  ( c -- )  first-udg - 0udg[  ;

  \ doc{
  \
  \ udg[  ( c -- )
  \
  \ Start a set of UDG definitions, from UDG character _c_
  \ (128..255).
  \
  \ See: `0udg[`, `|`, `||`, `||]`.
  \
  \ Usage example:
  \
  \ ----
  \ 140 udg[  \ define UDG 140..144
  \
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01011110 ||
  \ 11111111 | 11111111 | 11111111 | 10111111 | 10111111 ||
  \ 11111111 | 11111111 | 10111111 | 10111111 | 11111111 ||
  \ 11111111 | 10111111 | 10111111 | 11111111 | 11111111 ||
  \ 11001111 | 11011111 | 11111111 | 11111111 | 11111111 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||]
  \ ----
  \
  \ }doc

: |  ( b -- )
  os-udg @ current-udg @ 8 * current-scan @ + + c!
  1 current-udg +!  ;

  \ doc{
  \
  \ |  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined.
  \
  \ See: `0udg[`, `udg[`, `||`, `||]`.
  \
  \ }doc

: || ( b -- )
  |  1 current-scan +!  udg0 @ current-udg !  ;

  \ doc{
  \
  \ || ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and start
  \ a new row of scans.
  \
  \ See: `0udg[`, `udg[`, `|`, `||]`.
  \
  \ }doc


: ||]  ( b -- )  ||  decimal  ;

  \ doc{
  \
  \ ||]  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and stop
  \ defining UDGs.
  \
  \ See: `0udg[`, `udg[`, `|`, `||`.
  \
  \ }doc

( udg-block[ )

  \ XXX UNDER DEVELOPMENT
  \ 2016-10-04

need s=

: udg-block[  ( c "ccc" -- )
  begin   parse-name 2dup s" ]udg-block" compare
  while   dup 8 mod dup abort" Wrong scan length"

  repeat  ;

: ]udg-block ;

  \ doc{
  \
  \ udg-block[  ( c "ccc" -- )
  \
  \ Start a set of UDG definitions that form a sprite, from UDG
  \ character _c_ (128..255).

  \ Usage example:
  \
  \ ----
  \ 140 udg-block[
  \
  \ 0011110000111100001111000011110000111100
  \ 0111111001111110011111100111111001011110
  \ 1111111111111111111111111011111110111111
  \ 1111111111111111101111111011111111111111
  \ 1111111110111111101111111111111111111111
  \ 1100111111011111111111111111111111111111
  \ 0111111001111110011111100111111001111110
  \ 0011110000111100001111000011110000111100
  \
  \ ]udg-block
  \ ----
  \
  \ }doc

( udg-row[ )

need os-udg  need evaluate
[defined] binary  ?\ : binary  ( -- )  2 base !  ;

8 constant udg-height  8 constant udg-width
  \ height in bytes (scans)
  \ width in pixels

variable udg-row-height  variable udg-row-width
  \ height in scans
  \ width in characters

variable udg-row-first-udg

: ?block-scan-length  ( n -- )
  dup udg-width mod abort" Wrong block scan length"
  udg-width / udg-row-width @ ?dup
  if    <> abort" Wrong block width"
          \ not the first scan, so check the width
  else  udg-row-width !  then  ;
          \ first scan, so save the width

: udg-row-current-row  ( -- n )
  udg-row-height @ udg-height /  ;

: udg-current-scan  ( -- n )
  udg-row-height @ udg-height mod  ;  -->

( udg-row[ )

[defined] first-udg ?\ #128 constant first-udg

: >udg-scan  ( n -- a )
  udg-height * udg-current-scan +
  udg-row-first-udg @ first-udg - udg-height * +  os-udg @ +  ;
  \ Convert column _n_ of the current UDG row to address _a_
  \ of the scan of the current UDG.

: udg-scan!  ( b n -- )  >udg-scan c!  ;
  \ Store UDG scan _b_, which is at column _n_ of the current UDG
  \ block.

: udg-row-scan  ( ca len -- )
  base @ >r binary  dup ?block-scan-length
  dup udg-width / 0 do  over udg-width
    evaluate i udg-scan!  udg-width /string
  loop  2drop  r> base !  1 udg-row-height +!  ;
  \ Manage a UDG row scan _ca len_, extracting the individual
  \ UDG scans from it.

: ]udg-row  ( ca len -- )
  2drop  udg-row-height @ udg-height <>
  abort" The height of the UDG row is wrong"  ;
  \ End a UDG row. Check its height.

: udg-row-scan?  ( ca len -- f )  s" ]udg-row" compare 0<>  ;
  \ Is the string _ca len_ a UDG row scan
  \ instead of the end of the UDG row?

-->

( udg-row[ )

: parse-udg-row-scan  ( "ccc" -- ca len )
  begin   parse-name dup 0=
  while   2drop refill 0= abort" UDG row scan is missing"
  repeat  ;

: udg-row[  ( c "ccc" -- )
  udg-row-first-udg !  udg-row-height off  udg-row-width off
  begin   parse-udg-row-scan 2dup udg-row-scan?
  while   udg-row-scan
  repeat  ]udg-row  ;

  \ doc{
  \
  \ udg-row[  ( c "ccc" -- )
  \
  \ Start a UDG row (a graphic formed by a row of UDG). Parse
  \ its scans, extract the individual UDG scans and store them
  \ starting from UDG code _c_ (128..255).

  \ Usage example:
  \
  \ ----
  \ 140 udg-row[
  \
  \ 0011110000111100001111000011110000111100
  \ 0111111001111110011111100111111001011110
  \ 1111111111111111111111111011111110111111
  \ 1111111111111111101111111011111111111111
  \ 1111111110111111101111111111111111111111
  \ 1100111111011111111111111111111111111111
  \ 0111111001111110011111100111111001111110
  \ 0011110000111100001111000011110000111100
  \
  \ ]udg-row
  \ ----
  \
  \ }doc

( make-block-characters )

need z80-asm,

code make-block-characters  ( a -- )
  h pop, b push,
  #128 a ld#,  \ first char is #128
  rbegin
    af push, a b ld, 0B3B call, af pop, a inc,
  #144 cp#, nz? runtil  \ last char is #143
  b pop, jpnext, end-code

  \ Note: $0B3B is a secondary entry point to the PO-GR-1 ROM
  \ routine ($0B38), in order to force a non-default value of
  \ the HL register, which holds the destination address, which
  \ holds the destination address.

  \ doc{
  \
  \ make-block-characters  ( a -- )
  \
  \ Make the bit patterns of the 16 ZX Spectrum block
  \ characters, originally assigned to character codes
  \ 128..143, and store them (128 bytes in total) from address
  \ _a_.
  \
  \ This word is provided for easier conversion of BASIC
  \ programs that use the original block characters. These
  \ characters are part of the ZX Spectrum character set, but
  \ they are not included in the ROM font. Instead, their
  \ bitmaps are built on the fly by the BASIC ROM printing
  \ routine. In Solo Forth there's no such restriction, and
  \ characters 128..255 can be redefined by the user.
  \
  \ This word is written in Z80 and uses 18 B of code space.
  \
  \ See `block-characters`.
  \
  \ }doc

( block-characters )

$0F $0F $0F $0F $00 $00 $00 $00 #129 need udg! udg!
$F0 $F0 $F0 $F0 $00 $00 $00 $00 #130 udg!
$FF $FF $FF $FF $00 $00 $00 $00 #131 udg!
$00 $00 $00 $00 $0F $0F $0F $0F #132 udg!
$0F $0F $0F $0F $0F $0F $0F $0F #133 udg!
$F0 $F0 $F0 $F0 $0F $0F $0F $0F #134 udg!
$FF $FF $FF $FF $0F $0F $0F $0F #135 udg!
$00 $00 $00 $00 $F0 $F0 $F0 $F0 #136 udg!
$0F $0F $0F $0F $F0 $F0 $F0 $F0 #137 udg!
$F0 $F0 $F0 $F0 $F0 $F0 $F0 $F0 #138 udg!
$FF $FF $FF $FF $F0 $F0 $F0 $F0 #139 udg!
$00 $00 $00 $00 $FF $FF $FF $FF #140 udg!
$0F $0F $0F $0F $FF $FF $FF $FF #141 udg!
$F0 $F0 $F0 $F0 $FF $FF $FF $FF #142 udg! need 0udg>
$FF $FF $FF $FF $FF $FF $FF $FF #143 udg! 0 0udg> 8 erase

  \ doc{
  \
  \ block-characters  ( -- )
  \
  \ A phoney word used only to do `need block-characters`.  The
  \ loading of the correspondent source block will define
  \ characters 128..143 as block characters, with the shape
  \ they have in Sinclair BASIC.
  \
  \ See: `make-block-characters`.
  \
  \ }doc

( set-udg get-udg set-font get-font rom-font )

[unneeded] set-udg
?\ need os-udg  : set-udg  ( a -- )  os-udg !  ;  exit

  \ doc{
  \
  \ set-udg  ( a -- )
  \
  \ Set address _a_ as the the current UDG set (characters
  \ 128..255).  _a_ must be the bitmap address of character
  \ 128.
  \
  \ }doc

[unneeded] get-udg
?\ need os-udg  : get-udg  ( -- a )  os-udg @  ;  exit

  \ doc{
  \
  \ get-udg  ( -- a )
  \
  \ Get address _a_ of the current UDG set (characters
  \ 128..255).  _a_ is the bitmap address of character 128.
  \
  \ }doc

[unneeded] set-font
?\ need os-chars  : set-font  ( a -- )  os-chars !  ;  exit

  \ doc{
  \
  \ set-font  ( a -- )
  \
  \ Set address _a_ as the the current font (characters
  \ 32..127).  _a_ must be the bitmap address of character 0.
  \
  \ }doc

[unneeded] get-font
?\ need os-chars  : get-font  ( -- a )  os-chars @  ;  exit

  \ doc{
  \
  \ get-font  ( -- a )
  \
  \ Get address _a_ of the current font (characters 32..127).
  \ _a_ is the bitmap address of character 0.
  \
  \ }doc

[unneeded] rom-font ?\ 15360 constant rom-font  exit

  \ doc{
  \
  \ rom-font ( -- a )
  \
  \ A constant that holds the address of the ROM font (_a_ is
  \ the bitmap address of character 0).
  \
  \ }doc

  \ vim: filetype=soloforth
