  \ compilation.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605020017

  \ -----------------------------------------------------------
  \ Description

  \ Words related to compilation.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-04: Add `[if] [else] [then]`, adapted from Afera.
  \ 2015-06-17: Add `[true]`, `[false]`.
  \ 2015-06-25: Finish `[if] [else] [then]`.
  \ 2015-10-22: Rename words that convert header addresses.
  \ 2015-10-24: Move `body>name`, `name>link`, `link>name` and
  \ `>>link` from the kernel.
  \ 2015-10-29: Move `smudge` and `smudged` from the kernel.
  \ 2015-11-13: Move `?pairs` from the kernel.
  \ 2016-03-19: Add `save-here` and `restore-here`.
  \ 2016-04-17: Add `name>>`.
  \ 2016-04-24: Add `]l`, `]2l`, `exec`, `eval`.
  \ 2016-04-24: Add `[const]`, `[2const]`, `[cconst]`.
  \ 2016-04-24: Move `cliteral` from the kernel.
  \ 2016-04-24: Move `n,` from module "tool.marker.fsb".
  \ 2016-04-25: Simplify `exec`, move `possibly` from the
  \ module "tool.marker.fsb".
  \ 2016-04-25: Move `n,`, `n@`, `n!` to the module
  \ "memory.misc.fsb".
  \ 2016-04-26: Fix `restore-here`. Add `name>interpret`,
  \ `name>compile`.  Move `current-latest` from the kernel,
  \ formerly called `latest`.
  \ 2016-04-27: Add `comp'`, `[comp']`. Move `warning` from the
  \ kernel. Add `warn.throw`, `warn.message`, `warn-throw`
  \ and common factors.
  \ 2016-04-29: Add `string-parameter`.
  \ 2016-05-02: Join several blocks to save space.

( [false] [true] [if] [else] [then] )

[unneeded] [true]  ?\   0 constant [false] immediate exit 
[unneeded] [false] ?\  -1 constant [true]  immediate exit

need s=

: [else]  ( "..." -- )

  1 begin   parse-name dup
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( body>name name>body link>name name>link name<name )

[unneeded] body>name
?\ : body>name  ( pfa -- nt ) body> >name  ;

[unneeded] name>body
?\ : name>body  ( nt -- pfa ) name> >body  ;

[unneeded] link>name
?\ need alias  ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link
?\ need alias  ' cell- alias name>link  ( nt -- pfa )

[unneeded] name<name
?\ need name>link  : name<name  ( nt1 -- nt2 )  name>link @s  ;
  \ Get the previous _nt2_ from _nt1_.

( >>link name>> )

[unneeded] >>link
?\ need alias  ' cell+ alias >>link  ( xtp -- lfa )

[unneeded] name>>
?\ : name>>  ( nt -- xtp )  [ 2 cells ] literal -  ;

( name>interpret name>compile comp' [comp'] )

: name>interpret  ( nt -- xt | 0 )
  dup name> swap compile-only? 0= and  ;

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return _xt_ that represents the interpretation semantics of
  \ the word _nt_. If _nt_ has no interpretation semantics,
  \ return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[needed] name>interpret ?exit

: (comp')  ( nt -- xt )
  immediate?  if    ['] execute
              else  ['] compile,  then  ;

: name>compile  ( nt -- x xt )  dup name> swap (comp')  ;

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of the word _nt_. The  returned _xt_ has the
  \ stack effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[needed] name>compile ?exit

: comp'  ( "name" -- x xt )
  defined dup ?defined name>compile  ;

  \ doc{
  \
  \ comp'  ( "name" -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

[needed] comp' ?exit

: [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  comp' postpone 2literal  ; immediate compile-only

  \ doc{
  \
  \ [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

( ?pairs smudge smudged )

[unneeded] ?pairs
?\ : ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;  exit

  \ doc{
  \
  \ ?pairs  ( x1 x2 -- )
  \
  \ If _x1_ not equals _x2_ throw error #-22 (control structure
  \ mismatch).
  \
  \ }doc

need c!toggle-bits

: smudged  ( nt -- )
  smudge-mask swap system-bank c!toggle-bits default-bank  ;

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hided` and `revealed` are used
  \ instead.
  \
  \ }doc

 : smudge  ( -- )  latest smudged  ;

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ]l ]2l exec eval save-here restore-here )

need [if]

[needed] ]l [if]

: ]l  ( x -- )  ] postpone literal  ; immediate compile-only

  \ doc{
  \
  \ ]l  ( x -- )
  \
  \ A short form of the idiom `] literal`.
  \
  \ }doc

[then]

[needed] ]2l [if]

: ]2l  ( xd -- )  ] postpone 2literal  ; immediate compile-only

  \ doc{
  \
  \ ]2l  ( xd -- )
  \
  \ A short form of the idiom `] 2literal`.
  \
  \ }doc

[then]

[needed] save-here [needed] restore-here or [if]

variable here-backup
: save-here  ( -- )  here here-backup !  ;
: restore-here  ( -- )  here-backup @ there  ;

  \ XXX TODO -- behead `here-backup`

[then]

( possibly exec eval )

  \ Credit:
  \
  \ Code of `possibly` adapted from Wil Baden.

need [if]

[needed] possibly [if]

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ;

  \ doc{
  \
  \ possibly  ( "name" -- )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else do nothing.
  \
  \ }doc

[then]

[needed] exec [if]

: exec  ( "name" -- i*x )
  defined ?dup 0= #-13 ?throw  name> execute  ;

  \ doc{
  \
  \ exec  ( "name" -- i*x )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else throw exception
  \ #-13.
  \
  \ }doc

[then]

[needed] eval [if]

: eval  ( i*x "name" -- j*x )  parse-name evaluate  ;

  \ doc{
  \
  \ exec  ( i*x "name" -- j*x )
  \
  \ Parse and evaluate "name".
  \ 
  \ This is a common factor of `[const]`, `[2const]` and
  \ `[cconst]`.
  \
  \ }doc

[then]

( [const] [2const] [cconst] )

need eval  need [if]

[needed] [const] [if]

: [const]  ( "name" -- )
  eval postpone literal  ; immediate compile-only

  \ doc{
  \
  \ [const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the single-cell value left on
  \ the stack.
  \
  \ This word is intented to compile constants as literals, in
  \ order to gain execution speed. "name" can be any word, as
  \ long as its execution returns a single-cell value on the
  \ stack.
  \
  \ Usage example:
  \ 
  \ ----
  \ 48 constant zx
  \ : test  ( -- )  [const] zx .  ;
  \ ----
  \
  \ }doc

[then]

[needed] [2const] [if]

: [2const]  ( "name" -- )
  eval postpone 2literal  ; immediate compile-only

  \ doc{
  \
  \ [2const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the double-cell value left on
  \ the stack.
  \
  \ This word is intented to compile double-cell constants as
  \ literals, in order to gain execution speed.
  \
  \ Usage example:
  \ 
  \ ----
  \ 48. 2constant zx
  \ : test  ( -- )  [2const] zx d.  ;
  \ ----
  \
  \ }doc

[then]

[needed] [cconst] [if]

: [cconst]  ( "name" -- )
  eval postpone cliteral  ; immediate compile-only

  \ doc{
  \
  \ [cconst]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the char left
  \ on the stack.
  \
  \ This word is intented to compile char constants as literals, in
  \ order to gain execution speed.
  \
  \ Usage example:
  \
  \ ----
  \ 48 cconstant zx
  \ : test  ( -- )  [cconst] zx emit  ;
  \ ----
  \
  \ }doc

[then]

( current-latest cliteral )

[unneeded] current-latest
?\ : current-latest  ( -- nt )  get-current @  ;  exit

  \ doc{
  \
  \ current-latest ( -- nt )
  \
  \ Leave the name token of the topmost word in the current
  \ compilation word list.  This is different from `latest`,
  \ which returns the name token of the latest word defined in
  \ the system.
  \
  \ Origin: fig-Forth `latest`.
  \
  \ }doc

: cliteral  ( b -- )  compile clit c,  ; immediate compile-only

  \ doc{
  \
  \ cliteral  ( b -- )
  \
  \ Compile _b_ in the current definition.
  \
  \ This word does the same than `literal` but saves one byte
  \ of data space.
  \
  \ Origin: Comus.
  \
  \ }doc

( warnings )

need user  need search-wordlist

user warnings  \ flag

  \ doc{
  \
  \ warnings  ( -- a )
  \
  \ User variable that holds a flag. If it's zero, no warning
  \ is shown when a compiled word is not unique in the
  \ `current` vocabulary.
  \
  \ }doc

: no-warnings?  ( -- f )  warnings @ 0=  ;

  \ doc{
  \
  \ no-warnings?  ( -- f )
  \
  \ Are the warnings deactivated?
  \
  \ }doc

: not-redefined?  ( ca len -- ca len xt false | ca len true )
  2dup get-current search-wordlist 0=  ;

  \ doc{
  \
  \ not-redefined?  ( ca len -- ca len xt false | ca len true )
  \ 
  \ Is the word name _ca len_ not yet defined in the
  \ current compilation word list?
  \
  \ }doc

: ?warn  ( ca len -- ca len | ca len xt )
    no-warnings? if  unnest exit  ( ca len )  then
  not-redefined? if  unnest                   then
  ( ca len | ca len xt )  ;

  \ doc{
  \
  \ ?warn  ( ca len -- ca len | ca len xt )
  \
  \ A common factor of `warn.throw`, `warn.message` and
  \ `warn-throw`.  Check if a warning about the redefinition of
  \ the word name _ca len_ is needed.  If no warning is needed,
  \ unnest the calling definition and return _ca len_. If a
  \ warning is needed, return _ca len_ and the _xt_ of the word
  \ found in the current compilation wordlist.
  \
  \ See `warn.throw`, `warn-throw`, `warn.message`.
  \
  \ }doc

( warn.throw warn.message )

need warnings  need [if]

[needed] warn.throw [if]

: warn.throw  ( ca len -- ca len )
  ?warn ( ca len xt )  drop 2drop .error-word  #-257 .throw  ;

  \ doc{
  \
  \ warn.throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print throw error #-257, without
  \ actually throwing an error.
  \
  \ See `warn-throw`, `warn.message`.
  \
  \ }doc

' warn.throw ' warn defer!  warnings on

[then]

[needed] warn.message [if]

: warn.message  ( ca len -- ca len )
  ?warn ( ca len xt )  ." redefined " >name .name  ;

  \ doc{
  \
  \ warn.message  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print a warning message.
  \
  \ See `warn.throw`, `warn-throw`.
  \
  \ }doc

' warn.message ' warn defer!  warnings on

[then]

( warn-throw )

need warnings  need [if]

[needed] warn-throw [if]

: warn-throw  ( ca len -- ca len )
  ?warn ( ca len xt )  #-257 throw  ;

  \ doc{
  \
  \ warn-throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, throw error #-257 instead of
  \ printing a warning message.
  \
  \ See `warn.throw`, `warn.message`.
  \
  \ }doc

' warn-throw ' warn defer!  warnings on

[then]

( string-parameter )

  \ Credit:
  \
  \ Inspired by pForth's `param`.

: string-parameter  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  @ count             ( ca len ) ( R: a1 )
    \ get the string
  dup char+ r@ @ +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ XXX TODO -- benchmark this alternative:

: string-parameter2  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len ) ( R: a1 )
    \ get the string
  dup char+ rot +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

: string-parameter3  ( -- ca len )
  \ XXX UNDER DEVELOPMENT
  rp@ cell+ dup       ( a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len )
    \ get the string
  rot dup >r over char+ over +    ( ca len a2 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ doc{
  \
  \ string-param  ( -- ca len )
  \
  \ Return a string compiled after the calling word.
  \
  \ See `warning"` and `(warning")` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
