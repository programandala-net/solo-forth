  \ strings.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605110243

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-22: Add `s""`, moved from the kernel.
  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \ 2016-04-27: Add `char-in-string?` and `char-position?`.
  \ 2016-05-05: Rename `s=` to `str=`. Add `str<` and `str>`.
  \ 2016-05-11: Fix `-prefix`. Start compacting the blocks.

( str= str< str> trim )

[unneeded] str=
?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit

[unneeded] str<
?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit

[unneeded] str>
?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit

[unneeded] trim
: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

( sconstant char>string chars>string +place hunt )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
            bounds do  i c!  loop  2r>
      else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

  \ Credit:
  \
  \ Code from Afera.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

need pick

[defined] lengths
?\ : lengths   2over nip over  ;
   \ ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( #spaces #chars )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credit:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  bl skip 2dup bl scan  ;
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

need trim
: last-name  ( ca1 len1 -- ca2 len2 )
  trim  begin  2dup bl scan bl skip dup
        while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need str=  need ?(

  \ Credit:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[unneeded] prefix? ?(

: prefix?  ( ca1 len1 ca2 len2 -- f )
  tuck 2>r min 2r> str=  ; ?)

  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).

[unneeded] suffix? (?

need pick

: suffix? ( ca1 len1 ca2 len2 -- f )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string str=  ; ?)

( -prefix -suffix )

  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

need ?(

[unneeded] -prefix ?(  need prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ; ?)

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

[unneeded] -suffix ?(  need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ; ?)

( ud>str d>str chop s"" )

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

[unneeded] ud>str
?\ : ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

[unneeded] d>str
?\ : d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module chop.fs).

[unneeded] chop
?\ : chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

[unneeded] s""
?\ : s""  ( -- ca len )  0 allocate-string 0  ;

  \ doc{
  \
  \ s""  ( -- ca len )
  \
  \ Return an empty string in the circular string buffer.
  \
  \ }doc

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ char-in-string? char-position? ruler )

need ?(

code string/  ( ca1 len1 len2 -- ca2 len2 )
  D9 c, C1 c, D1 c, E1 c, 19 c, A7 c, ED c, 42 c,
    \                           ;   T  B
    \                           ;  -- --
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c, C5 c, D9 c, jpnext  end-code
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

[unneeded] char-in-string? ?(  need -rot

: char-in-string? ( ca len c -- f )
  -rot bounds ?do   dup i c@ = if  drop true unloop exit  then
              loop  drop false  ; ?)

  \ doc{
  \
  \ char-in-string? ( ca len c -- f )
  \
  \ Is char _c_ in string _ca len_?
  \
  \ }doc

[unneeded] char-position? ?(  need -rot

: char-position?  ( ca len c -- +n true | false )
  -rot 0 ?do   2dup i + c@ = if  2drop i true unloop exit  then
         loop  2drop false  ; ?)

  \ doc{
  \
  \ char-position?  ( ca len c -- +n true | false )
  \
  \ If char _c_ is in string _ca len_, return its first
  \ position _+n_ and _true_; else return _false_.
  \
  \ }doc


[unneeded] ruler ?(

: ruler  ( c len -- ca len )
  dup allocate-string swap 2dup 2>r rot fill 2r>  ; ?)

  \ doc{
  \
  \ ruler  ( c len -- ca len )
  \
  \ Return a string _ca len_ of characters _c_.
  \
  \ }doc

  \ vim: filetype=soloforth

