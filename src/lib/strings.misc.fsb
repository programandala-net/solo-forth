  \ strings.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201611172116

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-22: Add `s""`, moved from the kernel.
  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \ 2016-04-27: Add `char-in-string?` and `char-position?`.
  \ 2016-05-05: Rename `s=` to `str=`. Add `str<` and `str>`.
  \ 2016-05-11: Fix `-prefix`. Start compacting the blocks.
  \ 2016-08-02: Improve comment of `hunt`. Comment the string
  \ comparison operators.
  \ 2016-08-05: Reorganize and compact the code to save one
  \ block.
  \ 2016-11-17: Fix needing `trim`. Fix `+place`.

( str= str< str> trim +place hunt )

[unneeded] str=
?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit
  \ Is string _ca1 len1_ lexicographically equal to string _ca2
  \ len2_?

[unneeded] str<
?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit
  \ Is string _ca1 len1_ lexicographically smaller than string
  \ _ca2 len2_?

[unneeded] str>
?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit
  \ Is string _ca1 len1_ lexicographically larger than string
  \ _ca2 len2_?

[unneeded] trim
?\ : trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

need ?(

[unneeded] +place ?(  need c+!
: +place  ( ca1 len1 ca2 -- )
  2dup 2>r count + smove 2r> c+! ;  ?)
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

[unneeded] hunt ?(
: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ; ?)

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_. Therefore _ca3 len3_ = _ca1+n
  \ len1-n_.
  \
  \ }doc

( ud>str d>str char>string chars>string )

[unneeded] ud>str
?\ : ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

[unneeded] d>str
?\ : d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

need ?(

[unneeded] char>string ?(
: char>string  ( c -- ca len )
  1 allocate-string tuck c! 1  ; ?)
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

[unneeded] chars>string ?(
: chars>string  ( c1..cn n -- ca len )
  dup if    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
            bounds do  i c!  loop  2r>
      else  pad swap  then  ; ?)
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

need pick

[defined] lengths
?\ : lengths   2over nip over  ;
   \ ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( #spaces #chars )

need under+

  \ XXX TODO -- finish and benchmark. rewrite `#spaces` after
  \ `#chars`? add `#nulls`

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string _ca len_.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count chars _c_ in a string _ca len_.

( /name first-name last-name )

  \ Credit:
  \
  \ Code from Galope.

need ?(  [unneeded] last-name ?(  need trim

: last-name  ( ca1 len1 -- ca2 len2 )
  trim  begin  2dup bl scan bl skip dup
        while  2nip  repeat  2drop  ;  exit ?)
  \ Get the last name _ca2 len2_ from string _ca1 len1_.  A
  \ name is a substring separated by spaces.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  bl skip 2dup bl scan  ;
  \ Split string _ca1 len1_ into _ca2 len2_ (from the start of
  \ the first name in _ca1 len1_) and _ca3 len3_ (from the char
  \ after the first name in _ca1 len1).  A name is a substring
  \ separated by spaces.

[unneeded] first-name ?exit

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Return the first name _ca2 len2_ from string _ca1 len1_.  A
  \ name is a substring separated by spaces.

( prefix? suffix? -prefix -suffix )

need ?(

[unneeded] prefix? ?(  need str=  

: prefix?  ( ca1 len1 ca2 len2 -- f )
  tuck 2>r min 2r> str=  ; ?)
  \ Is string _ca2 len2_ the prefix of string _ca1 len1_?
  
  \ Credit:
  \
  \ Code adapted from Galope (module string-prefix-question.fs).

[unneeded] suffix? (?  need pick  need str=  

: suffix? ( ca1 len1 ca2 len2 -- f )
  2swap dup 3 pick - /string str=  ; ?)
  \ Is string _ca2 len2_ the suffix of string _ca1 len1_?
  
  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).


[unneeded] -prefix ?(  need prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  dup >r 2over 2swap prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ; ?)
  \ Remove prefix _ca2 len2_ from string _ca1 len1_.
  
  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

[unneeded] -suffix ?(  need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ; ?)
  \ Remove suffix _ca2 len2_ from string _ca1 len1_.

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

( chop s"" sconstant save-counted-string )

[unneeded] chop
?\ : chop  ( ca len -- ca' len' )  1- swap char+ swap  ;  exit
  \ Remove the last character from string _ca len_.
  \
  \ Credit:
  \
  \ Code from Galope (module chop.fs).


[unneeded] s""
?\ : s""  ( -- ca len )  0 allocate-string 0  ;  exit

  \ doc{
  \
  \ s""  ( -- ca len )
  \
  \ Return an empty string in the circular string buffer.
  \
  \ }doc

need ?(  [unneeded] sconstant ?(
: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ; ?)

[unneeded] save-counted-string ?(
: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ; ?)

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ char-in-string? char-position? ruler )

need ?(

code string/  ( ca1 len1 len2 -- ca2 len2 )
  D9 c, C1 c, D1 c, E1 c, 19 c, A7 c, ED c, 42 c,
    \                           ;   T  B
    \                           ;  -- --
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c, C5 c, D9 c, jpnext  end-code
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

[unneeded] char-in-string? ?(  need -rot

: char-in-string? ( ca len c -- f )
  -rot bounds ?do   dup i c@ = if  drop true unloop exit  then
              loop  drop false  ; ?)

  \ doc{
  \
  \ char-in-string? ( ca len c -- f )
  \
  \ Is char _c_ in string _ca len_?
  \
  \ }doc

[unneeded] char-position? ?(  need -rot

: char-position?  ( ca len c -- +n true | false )
  -rot 0 ?do   2dup i + c@ = if  2drop i true unloop exit  then
         loop  2drop false  ; ?)

  \ doc{
  \
  \ char-position?  ( ca len c -- +n true | false )
  \
  \ If char _c_ is in string _ca len_, return its first
  \ position _+n_ and _true_; else return _false_.
  \
  \ }doc


[unneeded] ruler ?(

: ruler  ( c len -- ca len )
  dup allocate-string swap 2dup 2>r rot fill 2r>  ; ?)

  \ doc{
  \
  \ ruler  ( c len -- ca len )
  \
  \ Return a string _ca len_ of characters _c_.
  \
  \ }doc

  \ vim: filetype=soloforth

