  \ strings.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605050040

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-22: Add `s""`, moved from the kernel.
  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \ 2016-04-27: Add `char-in-string?` and `char-position?`.
  \ 2016-05-05: Rename `s=` to `str=`. Add `str<` and `str>`.

( str= str< str> )

[unneeded] str=
?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit

[unneeded] str<
?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit

[unneeded] str>
?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit

( sconstant )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credit:
  \
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

need pick

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( hunt )

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( #spaces )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

( #chars )

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credit:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need str=  need [if]

  \ Credit:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]

: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> str=  ;

[then]

  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]

need pick

: suffix? ( ca1 len1 ca2 len2 -- f )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string str=  ;

[then]

( -prefix )

  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ )

code string/  ( ca1 len1 len2 -- ca2 len2 )
    \                           ;   T  B
    \                           ;  -- --
  D9 c,  C1 c,  D1 c,  E1 c,
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
  19 c,  A7 c,  ED c, 42 c,
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c,  C5 c,
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
  D9 c,  jpnext
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total
  end-code

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

exit

  \ Slower version, 1 byte shorter
  \
  \ Credit: code from Galope.

: string/  ( ca1 len1 len2 -- ca2 len2 )
  >r + r@ - r>  ;
  \ Return the _len2_ ending characters of string _ca1 len1_.

( s"" )

: s""  ( -- ca len )  0 allocate-string 0  ;

  \ doc{
  \
  \ s""  ( -- ca len )
  \
  \ Return an empty string in the circular string buffer.
  \
  \ }doc

( char-in-string? char-position? )

need -rot  need [if]

[needed] char-in-string? [if]

: char-in-string? ( ca len c -- f )
  -rot bounds
  ?do  dup i c@ = if  drop true unloop exit  then  loop
  drop false  ;

  \ doc{
  \
  \ char-in-string? ( ca len c -- f )
  \
  \ Is char _c_ in string _ca len_?
  \
  \ }doc

[then]

[needed] char-position? [if]

: char-position?  ( ca len c -- +n true | false )
  -rot 0 ?do
    2dup i + c@ = if  2drop i true unloop exit  then
  loop  2drop false  ;

  \ doc{
  \
  \ char-position?  ( ca len c -- +n true | false )
  \
  \ If char _c_ is in string _ca len_, return its first
  \ position _+n_ and _true_; else return _false_.
  \
  \ }doc

[then]

( ruler )

: ruler  ( c len -- ca len )
  dup allocate-string swap 2dup 2>r rot fill 2r>  ;

  \ doc{
  \
  \ ruler  ( c len -- ca len )
  \
  \ Return a string _ca len_ of characters _c_.
  \
  \ }doc

  \ vim: filetype=soloforth

