; kernel.trdos.z80s

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; XXX UNDER DEVELOPMENT

; Last modified: 201702052217

; ==============================================================
; Description

; The part of the Solo Forth's kernel that is specific to TR-DOS.

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2016, 2017.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; Latest changes:

; 2016-12-29: Change definition names to lowercase, after the
; changes in the main kernel.
;
; 2017-02-03: Add more test words.
;
; 2017-02-04: Add option to restore the BASIC SP and the number
; of lines of the lower screen before calling TR-DOS.
;
; The number of lines was the reason of the crash: TR-DOS
; throws a disk error and BASIC can not print it. The disk
; error happens when `transfer-sectors` reads a sector from
; disk B.  Choosing "abort" at the TR-DOS disk error message
; enters BASIC. Then Forth can be reentered using a warm
; restart.  The step rate of drive B has been increased by 2
; units.
;
; Test all implementations of `cat` to confirm the problem.
;
; 2017-02-05: Remove duplicated implementations of `cat`. Tidy,
; fix and improve the routines to enter and exit TR-DOS.
; Remove old code. Add `read-system-track`. Add first working
; version of `set-drive`.
;
; 2017-02-05: Move `read-block` and `write-block` to the main
; file of the kernel, because they are identical in G+DOS,
; TR-DOS and +3DOS.

; ==============================================================

if defined trdos

include inc/zx_spectrum_trdos.z80s

testing_trdos: equ 1 ; flag

; ==============================================================
; Routines to call TR-DOS

; ------------------------------
dos:

  ; Execute a TR-DOS command, preserving the Forth IP.

  ; Input:
  ;   A' =TR-DOS command code ($00..$18)
  ;   A, DE, HL = possible parameters, depending on the command
  ; Output if error:
  ;   A  = TR-DOS error code (0..12)
  ;   Z  = reset
  ; Output if no error:
  ;   A  = zero
  ;   Z  = set

  push bc     ; save the Forth IP
  call do_dos_command
  pop bc      ; restore the Forth IP
  ret

; ------------------------------
dos.tos_ip:

  ; Execute a TR-DOS command, restoring the Forth IP at the
  ; end, which has been pushed on the stack before the calling.
  ; This routine must be used when the B register is a
  ; parameter for TR-DOS.

  ; Input:
  ;   A' = TR-DOS command code ($00..$18)
  ;   (SP) = Forth IP
  ;   A, B DE, HL = possible parameters, depending on the command
  ; Output if error:
  ;   A  = TR-DOS error code (0..12)
  ;   Z  = reset
  ; Output if no error:
  ;   A  = zero
  ;   Z  = set

  call do_dos_command
  pop hl   ; get the return address
  pop bc   ; restore the Forth IP
  jp (hl)  ; return

; ------------------------------
do_dos_command:

  ; Execute a TR-DOS command.

  ; Input:
  ;   A' = TR-DOS command code ($00..$18)
  ;   A, B, DE, HL = possible parameters, depending on the command
  ; Output if error:
  ;   A  = TR-DOS error code (0..12)
  ;   Z  = reset
  ; Output if no error:
  ;   A  = zero
  ;   Z  = set


  ex af,af'
  ld c,a
  ex af,af'

; ------------------------------
do_dos_command.c:

  ; Execute the TR-DOS command in the C register.

  ; Input:
  ;   C = TR-DOS command code ($00..$18)
  ;   A, B, DE, HL = possible parameters, depending on the command
  ; Output if error:
  ;   A  = TR-DOS error code (0..12)
  ;   Z  = reset
  ; Output if no error:
  ;   A  = zero
  ;   Z  = set

  ld (iy+sys_df_sz_offset),2 ; BASIC mode: 2 lines in the lower screen
  call trdos_entry.execute_command_in_c
  ld (iy+sys_df_sz_offset),0 ; Forth mode: no lines in the lower screen
  ld a,c      ; error code
  and a
  ret

; ------------------------------
push_dos_ior:

  ; This routine is entered with `jp`, not with `call`, because
  ; it works as the end of a code Forth word: it jumps to
  ; `next` at the end.

  ; Input:
  ;   A  = TR-DOS error code (0..12) or zero
  ;   Z = no error?
  ; Output if error:
  ;   TOS = TR-DOS error code in Forth range (-1012..-1000)
  ; Output if no error:
  ;   TOS = false (no error)

  jp z,false_
  call dosior_to_ior
  _jp_pushhl

; ==============================================================
; Dictionary

; ----------------------------------------------
  _constant_header dos_routine_,'dos-routine'

  ; XXX TODO -- Move to the assembler word list.

  dw dos

; ----------------------------------------------
  _constant_header tos_ip_dos_routine_,'tos-ip-dos-routine'

  ; XXX TODO -- Move to the assembler word list.

  dw dos.tos_ip

; ----------------------------------------------
  _constant_header push_dos_ior_,'pushdosior'

  ; XXX TODO -- Move to the assembler word list.

  dw push_dos_ior

; ----------------------------------------------
  _code_header dosior_to_ior_,'dosior>ior'

; doc{
;
; dosior>ior  ( dosior -- ior )
;
; Convert a DOS ior to a Forth ior.
;
; This word is written in Z80. Its equivalent code in Forth is
; the following:

; ----
; : dosior>ior  ( dosior -- ior )
;   1000 + negate  ;
; ----

; }doc

  pop hl
  call dosior_to_ior.hl
  _jp_pushhl

dosior_to_ior:

  ; Input:
  ;   A  = TR-DOS error code (0..12)
  ; Output:
  ;   HL = TR-DOS error in Forth range (-1012..-1000)

  ld h,0
  ld l,a

dosior_to_ior.hl:

  ; Input:
  ;   HL = original DOS error code (0..12)
  ; Output:
  ;   HL = DOS error code in Forth range (-1012..-1000)

  ld de,1000
  add hl,de
  jp negate_hl ; then return

; ----------------------------------------------
  _c_constant_header rec_slash_track_,'rec/track'

; doc{
;
; rec/track  ( -- n )
;
; Records (sectors) per disk track.
;
; }doc

  db 16
  ; XXX TODO -- use a label and move to the kernel

; ----------------------------------------------
  _colon_header sector_id_,'sector-id'

; doc{

; sector-id  ( n -- x )

; Convert the sequential disk sector _n_ to the disk sector id
; _x_, in the format required by TR-DOS: The high byte of _x_
; is the track (0..79 for side 0; 80..159 for side 1); its low
; byte is the sector (0..15).
;
; ----
; : sector-id  ( n -- x )
;   rec/track +         \ the first track is not used
;   dup rec/track mod   ( n sector )
;   swap rec/track /    ( sector track )
;   flip or  ;
; ----
;
; }doc

  dw rec_slash_track_,plus_  ; the first track is not used
  dw dup_,rec_slash_track_,mod_
  dw swap_,rec_slash_track_,slash_
  dw flip_,or_
  dw exit_

; ----------------------------------------------
  _code_header transfer_sectors_,'transfer-sectors'

; doc{
;
; transfer-sectors  ( x a b -- ior )
;
; The sector-level disk read-write linkage.  Transfer _b_
; sectors from memory address _a_ to disk sector _x_ or the
; other way around.  The read or write mode must be previously
; set by `write-mode` or `read-mode`.
;
; The high byte of _x_ is the track (0..79 for side 0; 80..159
; for side 1); its low byte is the sector (0..15).
;
; See `sector-id`.
;
; }doc

  ; XXX FIXME -- 2017-02-05: When there's no disk in the drive,
  ; TR-DOS throws "Disc Error. Retry,Abort,Ignore?". "Retry" is
  ; useless; "Abort" exits to BASIC with "Tape loading error";
  ; "Ignore" crashes the system. There must be a way to avoid
  ; this and return an ior.

transfer_sectors.command equ $+1
  ld a,trdos_command.read_sectors ; read or write command (patched)
  ex af,af'
  pop hl
  ld a,l    ; number of sectors
  pop hl    ; address
  pop de    ; D = track 0..159; E = sector 0..15
  push bc   ; save the Forth IP
  ld b,a    ; number of sectors
  call dos.tos_ip
  jp push_dos_ior

; ----------------------------------------------
  _colon_header write_mode_,'write-mode'

; doc{
;
; write-mode  ( -- )
;
; Set the write mode for `transfer-sectors` and `transfer-block`.
;
; }doc

  ; XXX TODO -- rewrite in Z80

  _literal trdos_command.write_sectors
  dw branch_,transfer_mode

; ----------------------------------------------
  _colon_header read_mode_,'read-mode'

; doc{
;
; read-mode  ( -- )
;
; Set the read mode for `transfer-sectors` and `transfer-block`.
;
; }doc

  ; XXX TODO -- rewrite in Z80

  _literal trdos_command.read_sectors
transfer_mode:
  _literal transfer_sectors.command
  dw c_store_
  dw exit_

; ----------------------------------------------
  _colon_header transfer_block_,'transfer-block'

; doc{
;
; transfer-block  ( n -- )
;
; The block-level disk read-write linkage.  Transfer block _n_
; to or from disk.  The read or write mode must be previously
; set by `write-mode` or `read-mode`.

; ----
; : transfer-block  ( n -- )
;   rec/blk * sector-id buffer-data rec/blk
;   transfer-sectors throw  ;
; ----

; }doc

  dw rec_slash_blk_,star_ ; sequential number of the first sector of the block
  dw sector_id_,buffer_data_,rec_slash_blk_
  dw transfer_sectors_,throw_
  dw exit_

; ----------------------------------------------
  _code_header init_drive_,'init-drive'

; doc{
;
; init-drive  ( b -- ior )
;
; Init TR-DOS drive _b_ (0..3) and set it as the current one.
;
; This word is used by `set-drive`.
;
; See: `set-drive`.
;
; }doc

; Note: The TR-DOS init-drive command stores the drive number in
; `trdos_variable.current_temporary_drive`.

; XXX FIXME -- 2017-02-05: When there's no disk in the drive,
; TR-DOS exits to BASIC with "R Tape Loading Error", except
; when the drive was initialized before (in this case, nothing
; happens and _ior_ is zero).

  ld a,trdos_command.init_drive
  ex af,af'
  pop hl
  ld a,l    ; drive number (0..3)
  call dos
  jp push_dos_ior

; ----------------------------------------------
  _code_header read_system_track_,'read-system-track'

; doc{
;
; read-system-track  ( -- ior )
;
; Read the system track of the current TR-DOS disk.
;
; This word is used by `set-drive`.
;
; See: `set-drive`, `init-drive`.
;
; }doc

  ; XXX REMARK -- 2017-02-05: This operation is required to set
  ; the current disk drive (see `set-drive`). It was very hard
  ; to find out, with the help of a TR-DOS disassembly under
  ; development, and also studying the the following book:
  ; _TR-DOS для профессионалов и любителей_ (TR-DOS for
  ; professionals and amateurs, by Yu Pomortsev, Moscow, 1994).
  ; PDF version by Deny (Denisenko DA), 2007. It can be
  ; downloaded from Virtual TR-DOS: http://vtrdos.ru.

  ; XXX FIXME -- 2017-02-05: When there's no disk in the drive,
  ; TR-DOS throws "Disc Error. Retry,Abort,Ignore?". "Retry" is
  ; useless; "Abort" exits to BASIC with "Tape loading error";
  ; "Ignore" crashes the system. There must be a way to avoid
  ; this and return an ior.

  ld a,trdos_command.read_system_track
  ex af,af'
  call dos
  jp push_dos_ior

; ----------------------------------------------
  _colon_header set_drive_,'set-drive'

; doc{
;
; set-drive  ( b -- ior )
;
; Set drive _b_ (0..3) as the main one.
;
; See: `init-drive`, `read-system-track`.
;
; }doc

  dw dup_
  _literal trdos_variable.default_drive
  dw c_store_
  dw init_drive_,question_dup_,question_exit_
  dw read_system_track_
  dw exit_

; ==============================================================
; Test code

  ; XXX TMP --
  ; XXX UNDER DEVELOPMENT

if testing_trdos

; ----------------------------------------------
  _colon_header dot_drives_,'.drives'

  ; XXX TMP -- for debugging

; doc{
;
; .drives ( -- )
;
; Display TR-DOS variables related to disk drives.
;
; }doc

  dw cr_
  _literal trdos_variable.current_temporary_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' current'
  dw cr_
  _literal trdos_variable.two_files_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' two files'
  dw cr_
  _literal trdos_variable.cat_drive_or_read_verify_flag
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' cat'
  dw cr_
  _literal trdos_variable.default_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' default'
  dw cr_
  dw paren_dot_quote_
  _string "Drive modes"
  _literal 23756
  _literal 23752
  dw paren_do_,dot_drives.exit
  dw cr_,i_,dup_,u_dot_,c_fetch_,dot_
  dw paren_loop_
dot_drives.exit
  dw exit_

; Value of some TR-DOS variables after changing the default drive with
; command `*"a"`, `*"b"`, etc.
;
;        A  B  C  D
;
; 23798  0  1  2  3  = current drive
; 23800  0  0  0  0  = two-files drive
; 23801  0  0  0  0  = cat drive
; 23833  0  1  2  3  = default drive

; After booting Solo Forth from drive A:

; 23798  0  = current drive
; 23800  0  = two-files drive
; 23801  0  = cat drive
; 23833  0  = default drive

; After booting Solo Forth from drive B:

; 23798  1  = current drive
; 23800  0  = two-files drive
; 23801  0  = cat drive
; 23833  1  = default drive

; ----------------------------------------------
  _colon_header dot_step_rates_,'.step-rates'

  ; XXX TMP -- for debugging

; doc{
;
; .step-rates ( -- )
;
; Display the configured step rates of the TR-DOS disk drives.
;
; }doc

  dw cr_
  dw paren_dot_quote_
  _string 'Drive A: '
  _literal trdos_variable.drive_a_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive B: '
  _literal trdos_variable.drive_b_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive C: '
  _literal trdos_variable.drive_c_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive D: '
  _literal trdos_variable.drive_d_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw exit_

; ----------------------------------------------

if 1

  _code_header readtry_,'readtry'

; doc{
;
; readtry  ( -- ior )
;
; }doc

  ; XXX TMP -- Firt try to read the contents of a file.
  ;
  ; XXX REMARK -- 2016: It works.
  ;
  ; XXX REMARK -- 2017-02-05: It fails: "nonsense in BASIC".

  push bc   ; save the Forth IP
  ;ld (backup_bc),bc

  ld c,trdos_command.read_system_track
  call do_dos_command.c

  ld hl,name_and_type
  ld c,trdos_command.copy_from_hl_to_descriptor
  call do_dos_command.c
  jr nz,readtry.exit ; error
  ld c,trdos_command.find_file
  call do_dos_command.c
  ; a=directory entry of the file, or $FF if not found
  inc a ; file not found?
  jr nz,readtry.file_found ; no error
  ; file not found
  ld a,1 ; error code "no files"
  and a ; unset Z
  jr readtry.exit
readtry.file_found:
  dec a ; restore file descriptor (0..127)
  ld c,trdos_command.read_file_descriptor
  call do_dos_command.c
;  jr nz,readtry.exit ; error
  xor a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a ; set load flag
  ld hl,16384      ; load address
  ld a, $ff        ; take length from the directory
  ld c,trdos_command.read_file
  call do_dos_command.c

  ; XXX FIXME --
  ; a = 2 = file descriptor, not error code!

readtry.exit:
  pop bc      ; restore the Forth IP
;backup_bc equ $+1
;  ld bc,0
  jp push_dos_ior

name_and_type:
  defm "pr64.binC"

endif ; readtry

endif ; testing_trdos

endif ; defined trdos

; vim: filetype=z80:textwidth=64
