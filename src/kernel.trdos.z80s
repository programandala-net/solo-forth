; kernel.trdos.z80s

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; XXX UNDER DEVELOPMENT

; Last modified: 201612290139

; ==============================================================
; Description

; The part of the Solo Forth's kernel that is specific to TR-DOS.

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2016.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; Latest changes:

; 2016-12-29: Change definition names to lowercase, after the
; changes in the main kernel.

; ==============================================================

if defined trdos

include inc/zx_spectrum_trdos.z80s

; ==============================================================
; Routines

; ------------------------------
; DOS call

dos:

if 0

; XXX OLD

  push bc     ; save the Forth IP
dos.command equ $+1
  ld c,0      ; DOS command (must be patched before calling)
  call trdos_entry.execute_command_in_c
  ld a,c      ; error code
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  ret

endif

if 1

; XXX OLD

; Input:
;   (dos.command) = command
; Output:
;   A  = error code or zero
;   BC = error code or zero
;   Z  = no error?

dos.command equ $+1
  ld c,0    ; DOS command (must be patched before calling)
  ; _z80_border_wait 3 ; XXX INFORMER
  call trdos_entry.execute_command_in_c
  ; _z80_border_wait 4 ; XXX INFORMER
  ld a,c    ; error code
  and a
  ret

endif

; ------------------------------

if 1

; Input:
;   C = command
; Output:
;   A  = error code or zero
;   BC = error code or zero
;   Z  = no error?

trdos.execute_command:
  ; XXX NEW -- experimental
  push af
  xor a
  ld (trdos_variable.error_code),a
  pop af
  call trdos_entry.execute_command_in_c
;  ld (22530),bc ; XXX INFORMER
  ld a,c    ; error code
  and a
  ret

endif

; ------------------------------

dos.hl:
  push hl
  jp trdos_entry.call_pushed_address

; ------------------------------

back_from_dos:
;   A  = error code or zero
;   Z  = no error?
  jp z,false_

back_from_dos.error:
  ; a = error code
  call dosior_to_ior
  ; hl = error code
  _jp_pushhl

dosior_to_ior:
  ; Input:   a  = original DOS error code (0..12)
  ; Output: hl = DOS error code converted to Forth range (-1012..-1000)
  ld h,0
  ld l,a
dosior_to_ior.hl:
  ; Input:   hl  = original DOS error code (0..12)
  ; Output: hl = DOS error code converted to Forth range (-1012..-1000)
  ld de,1000
  add hl,de
  jp negate_hl

; ==============================================================
; Dictionary

; ----------------------------------------------
_code_header dosior_to_ior_,'dosior>ior'

; doc{
;
; dosior>ior  ( dosior -- ior )
;
; Convert a DOS ior to a Forth ior.

; ----
; : dosior>ior  ( dosior -- ior )
;   1000 + negate  ;
; ----

; }doc

  pop hl
  call dosior_to_ior.hl
  _jp_pushhl

; ----------------------------------------------
  _constant_header rec_slash_track_,'rec/track'

; doc{
;
; rec/track  ( -- n )
;
; Records (sectors) per disk track.
;
; }doc

  dw 16
  ; XXX TODO -- use a label and move to the kernel

; ----------------------------------------------
  _colon_header sector_id_,'sector-id'

; doc{

; sector-id  ( n -- x )

; Convert the sequential disk sector _n_ to the disk sector id
; _x_, in the format required by TR-DOS: The high byte of _x_
; is the track (0..79 for side 0; 80..159 for side 1); its low
; byte is the sector (0..15).
;
; ----
; : sector-id  ( n -- x )
;   rec/track +             \ the first track is not used
;   dup sectors/track mod   ( n sector )
;   swap sectors/track /    ( sector track )
;   flip or  ;
; ----
;
; }doc

  dw rec_slash_track_,plus_  ; the first track is not used
  dw dup_,rec_slash_track_,mod_
  dw swap_,rec_slash_track_,slash_
  dw flip_,or_
  dw exit_

; ----------------------------------------------
  _colon_header read_block_,'read-block'

; doc{
;
; read-block  ( n -- )
;
; Read disk block _n_ to the buffer.
;
; ----
; : read-block  ( n -- )
;   read-mode transfer-block  ;
; ----
;
; }doc

  dw read_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header write_block_,'write-block'

; doc{
;
; write-block  ( n -- )
;
; Write the buffer to disk block _n_.
;
; ----
; : write-block  ( n -- )
;   write-mode transfer-block  ;
; ----
;
; }doc

  dw write_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header transfer_block_,'transfer-block'

; doc{
;
; transfer-block  ( n -- )
;
; The block-level disk read-write linkage.
; Transfer block _n_ to or from disk.
; The read or write mode must be previously set
; by `write-mode` or `read-mode`.
;
; ----
; : transfer-block  ( n -- )
;   rec/blk * sector-id buffer-data rec/blk transfer-sectors  ;
;
; ----
; }doc

  ; XXX TODO restore the current drive

  dw rec_slash_blk_,star_ ; sequential number of the first sector of the block
  dw sector_id_
  dw buffer_data_
  dw rec_slash_blk_
  dw transfer_sectors_
  dw exit_

; ----------------------------------------------
  _code_header transfer_sectors_,'transfer-sectors'

if 1

; doc{
;
; transfer-sectors  ( x a n -- )
;
; The sector-level disk read-write linkage.  Transfer _n_ sectors from
; memory address _a_ to disk sector _x_ or the other way around.  The
; read or write mode must be previously set by `write-mode` or
; `read-mode`.
;
; The high byte of _x_ is the track (0..79 for side 0; 80..159 for
; side 1); its low byte is the sector (0..15).
;
; See `sector-id`.
;
; }doc

  pop hl
  ld a,l    ; number of sectors
  pop hl    ; address
  pop de    ; d = track 0..159; e = sector 0..15
  push bc   ; save the Forth IP
  ld b,a    ; number of sectors
transfer_sectors.command equ $+1
  ld c,trdos_command.read_sectors
  call trdos_entry.execute_command_in_c

  ; XXX FIXME -- when there's no disk in the drive, the call never
  ; returns, and the system hangs.
  ;
  ; XXX TODO -- check error code returned in bc
  ;ld (22528),bc  ; XXX INFORMER  XXX TMP --

  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

else

; doc{
;
; transfer-sectors  ( x a n -- ior )
;
; The sector-level disk read-write linkage.  Transfer _n_ sectors from
; memory address _a_ to disk sector _x_ or the other way around.  The
; read or write mode must be previously set by `write-mode` or
; `read-mode`.
;
; The high byte of _x_ is the track (0..79 for side 0; 80..159 for
; side 1); its low byte is the sector (0..15).
;
; See `sector-id`.
;
; }doc

transfer_sectors.command equ $+1
  ld a,trdos_command.read_sectors
  ld (dos.command),a
  pop hl
  ld a,l    ; number of sectors
  pop hl    ; address
  pop de    ; d = track 0..159; e = sector 0..15
  push bc   ; save the Forth IP
  ld b,a    ; number of sectors
  call dos

  ; XXX FIXME -- when there's no disk in the drive, the call never
  ; returns, and the system hangs.
  ; XXX TODO -- check error code returned in bc

  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  jp back_from_dos

endif

; ----------------------------------------------
;  _colon_header library_disk_,'library-disk'

; doc{
;
; library-disk  ( c -- )
;
; Set disk drive _c_ ('a', 'b', 'c' or 'd') as the current library
; disk.  By default it's disk drive 'b'.
;
; }doc

  ; XXX TMP -- for debugging

; ----------------------------------------------
  _code_header init_drive_,'init-drive'

; doc{
;
; init-drive  ( n -- ior )
;
; }doc

; Note: this TR-DOS routine stores the drive number in
; `trdos_variable.current_temporary_drive`.

  ; XXX FIXME -- when there's no disk in the drive, the system never
  ; returns from the DOS.

  pop hl
  ld a,l    ; drive number (0..3)
  push bc   ; save the Forth IP
  ld c,trdos_command.init_drive
  call trdos.execute_command
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  jp back_from_dos

; ----------------------------------------------
;  _code_header cat_,'cat'

; doc{
;
; cat  ( -- ior )
;
; }doc

if 1

  _code_header cat1_,'cat1'

  ; XXX FIXME -- hang!

  ld a,trdos_command.cat
  ld (dos.command),a
  ld a,(trdos_variable.current_temporary_drive)
  ld (trdos_variable.two_files_drive),a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a
  ld (trdos_variable.default_drive),a
  ld a,2    ; stream: screen
  push bc   ; save the Forth IP
  _z80_border_wait 1 ; XXX INFORMER
  call dos
  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  jp back_from_dos

endif

if 1

  _code_header cat2_,'cat2'

  ; XXX FIXME -- hang!

  ld a,(trdos_variable.current_temporary_drive)
  ld (trdos_variable.two_files_drive),a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a
  ld (trdos_variable.default_drive),a
  ld a,2    ; stream: screen
  push bc   ; save the Forth IP
  ld c,trdos_command.cat
  _z80_border_wait 1 ; XXX INFORMER
  call trdos_entry.execute_command_in_c
  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

if 1

  _code_header cat3_,'cat3'

  ; XXX FIXME -- hang!

  ld a,2      ; stream: screen
  push bc     ; save the Forth IP
  ld c,trdos_command.cat
  _z80_border_wait 1 ; XXX INFORMER
  call trdos_entry.execute_command_in_c
  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

if 1

  _code_header cat4_,'cat4'

  push bc   ; save the Forth IP
;  ld hl,(sys_ch_add)
;  push hl
  ld hl,cat.command_line
  ld (sys_ch_add),hl
  _z80_border_wait 1 ; XXX INFORMER
  call trdos_entry.interpret_rem_command
  ; XXX FIXME -- hang -- no return here
  _z80_border_wait 2 ; XXX INFORMER

  ; XXX INFORMER:
  ; push bc ; error code
  ; pop hl
  ; ld (22528),hl ; it's meaningless, why?

;  pop hl
;  ld (sys_ch_add),hl
  pop bc    ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

cat.command_line:
  db token.rem,':',token.cat,13

endif

if 1

  _code_header cat5_,'cat5'

  ; XXX FIXME -- no effect

  push bc   ; save the Forth IP
  ld hl,$0429 ; `CAT`
  call dos.hl
  _z80_border_wait 4 ; XXX INFORMER

  ; XXX INFORMER:
  ; push bc ; error code
  ; pop hl
  ; ld (22528),hl ; it's meaningless, why?

  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

if 1

  _code_header cat6_,'cat6'

  push bc   ; save the Forth IP
  ld c,$07
  call dos.hl
  _z80_border_wait 4 ; XXX INFORMER

  ; XXX INFORMER:
  ; push bc ; error code
  ; pop hl
  ; ld (22528),hl ; it's meaningless, why?

  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

if 1

  _code_header cat7_,'cat7'

  ; XXX FIXME -- hang!

  ; ld a,trdos_command.cat
  ; ld (dos.command),a

  ; ld a,0; drive
  ; ld (trdos_variable.current_temporary_drive),a

  ld a,(trdos_variable.current_temporary_drive)

  ld (trdos_variable.two_files_drive),a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a
  ld (trdos_variable.default_drive),a
  push bc   ; save the Forth IP
  _z80_border_wait 1 ; XXX INFORMER

;  call dos

  ;XXX REMARK -- this init makes no difference:
  ;ld c,trdos_command.init_drive
  ;call trdos_entry.execute_command_in_c

  ld a,2    ; stream: screen
  ld c,trdos_command.cat
  call trdos_entry.execute_command_in_c

  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _z80_border_wait 5 ; XXX INFORMER
  jp back_from_dos

endif

if 1

  _code_header cat8_,'cat8'

  push bc   ; save the Forth IP

  ld a,(trdos_variable.current_temporary_drive)
  ld (trdos_variable.two_files_drive),a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a
  ld (trdos_variable.default_drive),a
  ;_z80_border_wait 1 ; XXX INFORMER

  ;XXX FIXME -- hang:
  ;ld a,2    ; stream: screen

  ;XXX FIXME -- hang:
  ;ld a,2
  ;call rom_chan_open
  ;ld a,2    ; stream: screen

  ; XXX FIXME -- it works, but channel is not restored:
  ;ld a,3    ; stream: printer

  ld c,trdos_command.cat
  call trdos.execute_command

  ;_z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  ;_z80_border_wait 5 ; XXX INFORMER
  jp back_from_dos

endif

if 1

  _code_header cat9_,'cat9'

  ld a,2      ; stream: screen
  push bc     ; save the Forth IP
  ld c,trdos_command.cat
  _z80_border_wait 1 ; XXX INFORMER
  call trdos.execute_command
  ; XXX FIXME -- hang -- no return here
  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

if 1

  _code_header cat10_,'cat10'

  push bc     ; save the Forth IP
  ld a,2      ; stream: screen
  call rom_chan_open
  ld a,2      ; stream: screen
  ld c,trdos_command.cat
  _z80_border_wait 1 ; XXX INFORMER
  call trdos.execute_command
  ; XXX FIXME -- hang -- no return here
  _z80_border_wait 2 ; XXX INFORMER
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

endif

; ----------------------------------------------
  _colon_header set_drive_,'set-drive'

; doc{
;
; set-drive  ( n -- )
;
; }doc

  ; XXX FIXME -- hang:
  ;_literal trdos_variable.current_temporary_drive
  ;dw c_store_

  ; XXX FIXME -- no effect:
  ; _literal trdos_variable.default_drive
  ; dw c_store_

  ; XXX FIXME -- hang:
  ; dw dup_,init_drive_
  ; _literal trdos_variable.default_drive
  ; dw c_store_

  ; XXX TODO -- how to set the default drive?

  ; XXX FIXME -- no effect:
  ; dw dup_
  ; _literal trdos_variable.default_drive
  ; dw c_store_
  ; _literal trdos_variable.current_temporary_drive
  ; dw c_store_

  ; XXX FIXME -- no effect:
  ; dw dup_
  ; _literal trdos_variable.default_drive
  ; dw c_store_
  ; dw dup_
  ; _literal trdos_variable.current_temporary_drive
  ; dw c_store_
  ; dw init_drive_

if 0

; XXX FIXME -- 2016-08-13: Crash! But the same code works outside
; Forth, why?

; XXX REMARK -- 2016-08-13: The problem is found in routine $3E08: The
; step rates of the drives (variables 23802..23805) contain $FF except
; the first one, which contains $08.
;
; Variable     Drive  From BASIC(1)  From Forth(2)
; -----------  -----  -------------  -------------
; 23802 $5CFA  A      $FF            $08
; 23803 $5CFB  B      $08            $FF
; 23804 $5CFC  C      $FF            $FF
; 23805 $5CFD  D      $FF            $FF
;
; 1 = Contents when the code is directly called from BASIC
; 2 = Contents when `set-drive` is executed

; $5CFB is set to 8 at $3E1D (Beta 128 Disk ROM). But then it's
; modified by ROM 48 at $19F7 (`ldir`), which is part of the RECLAIM
; routine. The problem seems TR-DOS moves up and down BASIC. But this
; should not affect the zone above RAMTOP.

;  pop hl
;  ld a,l ; drive 0..3

  ld a,1  ; XXX TMP --
  add a,'A' ; drive 'A'..'D'
  ld (set_drive2.command_line.drive),a
  push bc   ; save the Forth IP
  ld hl,(sys_ch_add)
  push hl
  ld hl,set_drive2.command_line
  ld (sys_ch_add),hl
  ;_z80_border_wait 1 ; XXX INFORMER
  call trdos_entry.interpret_rem_command
  ; XXX FIXME -- crash before getting here
  ;_z80_border_wait 2 ; XXX INFORMER

  ; XXX INFORMER:
  ; push bc ; error code
  ; pop hl
  ; ld (22528),hl

  pop hl
  ld (sys_ch_add),hl
  pop bc    ; restore the Forth IP
  ld ix,next  ; restore IX
  _jp_next

set_drive2.command_line:
set_drive2.command_line.drive equ $+4
  db token.rem,':*"A"',13

endif

if 0

; doc{
;
; set-drive  ( n -- )
;
; }doc

  dw dup_,init_drive_,throw_
  dw dup_
  _literal trdos_variable.default_drive
  dw c_store_
  _literal trdos_variable.current_temporary_drive
  dw c_store_

endif

if 0

; doc{
;
; set-drive  ( n -- ior )
;
; }doc

  dw dup_,init_drive_,question_dup_,question_exit_
  dw dup_
  _literal trdos_variable.default_drive
  dw c_store_
  _literal trdos_variable.current_temporary_drive
  dw c_store_
  _literal 0

endif

if 1

; XXX REMARK -- 2016-09-01: New version, based on the disassembly of
; TR-DOS (project under development)

; doc{
;
; set-drive  ( n -- ior )
;
; }doc

  dw dup_
  _literal trdos_variable.default_drive
  dw c_store_
  dw init_drive_

endif

  dw exit_

; ----------------------------------------------
  _colon_header get_drive_,'get-drive'

; doc{
;
; get-drive ( -- n )
;
; }doc

  _literal trdos_variable.current_temporary_drive
  dw c_fetch_
  dw exit_

; ----------------------------------------------
  _colon_header dot_drives_,'.drives'

  ; XXX TMP -- for debugging

; doc{
;
; .drives ( -- )
;
; }doc

  dw cr_
  _literal trdos_variable.current_temporary_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' current'
  dw cr_
  _literal trdos_variable.two_files_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' two files'
  dw cr_
  _literal trdos_variable.cat_drive_or_read_verify_flag
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' cat'
  dw cr_
  _literal trdos_variable.default_drive
  dw dup_,dot_,c_fetch_,dot_
  dw paren_dot_quote_
  _string ' default'
  dw cr_
  dw exit_

; Value of some TR-DOS variables after changing the default drive with
; command `*"a"`, `*"b"`, etc.
;
;        A  B  C  D
;
; 23798  0  1  2  3  = current drive
; 23800  0  0  0  0  = two-files drive
; 23801  0  0  0  0  = cat drive
; 23833  0  1  2  3  = default drive

; After booting Solo Forth from drive A:

; 23798  0  = current drive
; 23800  0  = two-files drive
; 23801  0  = cat drive
; 23833  0  = default drive

; After booting Solo Forth from drive B:

; 23798  1  = current drive
; 23800  0  = two-files drive
; 23801  0  = cat drive
; 23833  1  = default drive

; ----------------------------------------------
  _colon_header dot_step_rates_,'.step-rates'

  ; XXX TMP -- for debugging

; doc{
;
; .step-rates ( -- )
;
; }doc

  dw cr_
  dw paren_dot_quote_
  _string 'Drive A: '
  _literal trdos_variable.drive_a_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive B: '
  _literal trdos_variable.drive_b_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive C: '
  _literal trdos_variable.drive_c_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw paren_dot_quote_
  _string 'Drive D: '
  _literal trdos_variable.drive_d_step_rate
  dw dup_,dot_,c_fetch_,dot_
  dw cr_
  dw exit_

; ----------------------------------------------
  _colon_header write_mode_,'write-mode'

; doc{
;
; write-mode  ( -- )
;
; Set the write mode for `transfer-sectors` and `transfer-block`.
;
; }doc

  _literal trdos_command.write_sectors
  dw branch_,transfer_mode

; ----------------------------------------------
  _colon_header read_mode_,'read-mode'

; doc{
;
; read-mode  ( -- )
;
; Set the read mode for `transfer-sectors` and `transfer-block`.
;
; }doc

  _literal trdos_command.read_sectors
transfer_mode:
  _literal transfer_sectors.command
  dw c_store_
  dw exit_

; ----------------------------------------------
  _code_header xxx_,'xxx'

; doc{
;
; xxx  ( -- ior )
;
; }doc

  ; XXX TMP -- for debugging
  ; XXX REMARK -- it works

  push bc   ; save the Forth IP
  ;ld (backup_bc),bc

  ld c,trdos_command.read_system_track
  call trdos.execute_command
  _z80_border_wait 1 ; XXX INFORMER

  ld hl,name_and_type
  ld c,trdos_command.copy_from_hl_to_descriptor
  call trdos.execute_command
  jr nz,xxx.exit ; error
  _z80_border_wait 2 ; XXX INFORMER
  ld c,trdos_command.find_file
  call trdos.execute_command
  ; a=directory entry of the file, or $FF if not found
  inc a ; Z=file not found?
  jr nz,xxx.file_found ; no error
  ; file not found
  ld a,1 ; error code "no files"
  and a ; unset Z
  jr xxx.exit
xxx.file_found:
  dec a ; restore file descriptor (0..127)
  _z80_border_wait 3 ; XXX INFORMER
  ld c,trdos_command.read_file_descriptor
  call trdos.execute_command
;  jr nz,xxx.exit ; error
  _z80_border_wait 4 ; XXX INFORMER
  xor a
  ld (trdos_variable.cat_drive_or_read_verify_flag),a ; set load flag
  ld hl,16384      ; load address
  ld a, $ff        ; take length from the directory
  ld c,trdos_command.read_file
  _z80_border_wait 5 ; XXX INFORMER
  call trdos.execute_command
  _z80_border_wait 6 ; XXX INFORMER

  ; XXX FIXME -- 
  ; a = 2 = file descriptor, not error code!

xxx.exit:
  pop bc      ; restore the Forth IP
  ld ix,next  ; restore IX
  ;ld ix,next
;backup_bc equ $+1
;  ld bc,0
  jp back_from_dos

name_and_type:
  defm "pr64.binC" 

endif

; vim: filetype=z80:textwidth=64
