; kernel.plus3dos.z80s

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; Last modified: 201703082332

; ==============================================================
; Description

; The part of the kernel that is specific to +3DOS.

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2015, 2016, 2017.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; Latest changes:

; 2016-12-29: Change definition names to lowercase, after the
; changes in the main kernel.
;
; 2017-02-05: Move `read-block` and `write-block` to the main
; file of the kernel, because they are identical in G+DOS,
; TR-DOS and +3DOS. Improve the layout.  Move `rec/track` to the
; main file of the kernel.
;
; 2017-02-07: Rewrite `read-mode` and `write-mode` in Z80.
; First draft of `transfer-sector`.
;
; 2017-02-09: Add `>drive-block` to `transfer-block`.
;
; 2017-02-17: Update cross references.
;
; 2017-03-03: Factor the DOS page in and page out from DOS call
; routine. Rename the DOS entry points. Add `dos.tos`.
;
; 2017-03-04: Update naming convention of Z80 routines, after
; the changes in the kernel.  Move `/filename` ,`>filename`,
; `(rename-file)`, `rename-file`, `dos-set-1346` and
; `dos-get-1364` to the library.
;
; 2017-03-05: Try alternative code to make `set-block-drives`
; work.
;
; 2017-03-06: Reorganize all the code alternatives with
; conditional compilation.
;
; 2017-03-08: Move `close-file` to the library.

; ==============================================================
; Requirements

if plus3dos

include inc/zx_spectrum_plus3dos.z80s

; ==============================================================
; Configuration

current_drive_method: equ 3 ; XXX TMP --

; ==============================================================
; Routines to call +3DOS

; ------------------------------
; DOS call (routine in IX)

dos.ix:

  ; Input:
  ;   IX = address of the +3DOS routine
  ; Output:
  ;   IX = Forth `next`

  ; All other registers are passed intact to the DOS routine and
  ; are returned from it.

  ; The stack must be somewhere in central 32K (conforming to
  ; +3DOS requirements).

  call dos_in
  call call_ix    ; call routine in IX
dos.ix.return:
  call dos_out
  ld ix,next      ; restore Forth IX
  ret

; ------------------------------
; DOS call (routine in TOS)

dos.tos:

  ; The top of the Z80 stack holds the address of the DOS
  ; routine to be run.  All registers are passed intact to the
  ; DOS routine and are returned from it.

  ; This is used when the IX register is a parameter of the DOS
  ; routine.

  ; The stack must be somewhere in central 32K (conforming to
  ; DOS requirements).

  call dos_in
  exx                  ; preserve parameters
  pop de               ; return address to Forth word
  pop hl               ; address of the DOS routine
  push de              ; return address to Forth word
  ld de,dos.ix.return  ; return address from the DOS routine
  push de              ; force the return later
  push hl              ; address of the DOS routine
  exx                  ; restore parameters
  ret                  ; call routine in TOS, then continue at dos.ix.return

; ------------------------------
; Page in DOS

dos_in:
  push af
  push bc                  ; temp save registers while switching
  ld   a,(sys_bankm)       ; RAM/ROM switching system variable
  or   %00000111           ; set bits 0-3: RAM 7
  res  4,a                 ; and DOS ROM
  ld   bc,bank1_port       ; port used for horiz. ROM switch and RAM paging
  di
  ld   (sys_bankm),a       ; keep system variables up to date
  out  (c),a               ; RAM page 7 to top and DOS ROM
  ei
  pop  bc
  pop  af
  ret

; ------------------------------
; Page out DOS

dos_out:

  push af
  push bc
  ld   a,(sys_bankm)
  and  %11111000           ; reset bits 0-3: RAM 0
  set  4,a                 ; switch to ROM 3 (48 BASIC)
  ld   bc,bank1_port
  di
  ld   (sys_bankm),a
  out  (c),a               ; switch back to RAM page 0 and 48 BASIC
  ei
  pop  bc
  pop  af
  ret

; ------------------------------
; DOS call (routine in IX, preserving the Forth IP)

dos.ix.preserve_ip:

  ; This is used when the BC register (the Forth IP) is not a
  ; parameter of the DOS routine.

  ; IX holds the address of the DOS routine to be run. All
  ; other registers are passed intact to the DOS routine and
  ; are returned from it.

  ; The stack must be somewhere in central 32K (conforming to
  ; DOS requirements), so saved AF and BC will not be switched
  ; out.

  push bc
  call dos.ix
  pop bc
  ret

; ------------------------------
; Push DOS ior and continue at `next`

push_dos_ior:

  ; This routine is entered with `jp`, not with `call`, because
  ; it works as the end of a code Forth word: it jumps to
  ; `next` at the end.

  ; Input:
  ;   CY = no error?
  ;   A  = +3DOS error code (0..36)
  ; Output if error:
  ;   TOS = Forth exception code (-1036..-1000)
  ; Output if no error:
  ;   TOS = false

  jp c,false_   ; no error
  call dosior_to_ior
  ; HL = error code
  _jp_pushhl

; ------------------------------

if 0

  ; XXX TODO -- move to the library

get_current_drive:
  ld a,$FF

set_current_drive:
  ; a = drive (ASCII 'A'..'P' to set it; $FF to get it)
  ld ix,dos_set_drive
  jr dos.ix.preserve_ip

get_current_user:
  ld a,$FF

set_current_user:
  ; a = user ($00..$0F to set it; $FF to get it)
  ld ix,dos_set_user

endif

; ==============================================================
; Dictionary

; ----------------------------------------------
  _constant_header dos_ix_underscore_,'dos-ix_'

; doc{
;
; dos-ix_ ( -- a )
;
; Address of a routine that executes the +3DOS command hold in
; the IX register.

; ....
; Input:
;   IX = address of the +3DOS routine
; Output:
;   IX = Forth `next`
; ....

; The stack must be somewhere in central 32K (conforming to
; +3DOS requirements).
;
; See also: `dos-ix-preserve-ip_`, `dos-tos_`.
;
; }doc

  ; XXX TODO -- Move to the assembler word list.

  dw dos.ix

; ----------------------------------------------
  _constant_header dos_tos_underscore_,'dos-tos_'

; doc{
;
; dos-tos_ ( -- a )
;
; Address of a routine that executes the +3DOS command hold on
; the top of the stack.
;
; This routine is used when the IX register is a parameter of
; the +3DOS routine.

; ....
; Input:
;   (TOS) = address of the +3DOS routine
; Output:
;   IX = Forth `next`
; ....

; The stack must be somewhere in central 32K (conforming to
; +3DOS requirements).
;
; See also: `dos-ix_`, `dos-ix-preserve-ip_`.
;
; }doc

  ; XXX TODO -- Move to the assembler word list.

  dw dos.tos

; ----------------------------------------------
  _constant_header dos_in_underscore_,'dos-in_'

; doc{
;
; dos-in_ ( -- a )
;
; Address of a routine that pages in RAM 7 and ROM 2 (DOS), as
; needed to call a +3DOS routine.
;
; The stack must be somewhere in central 32K (conforming to
; +3DOS requirements).
;
; See also: `dos-out_`.
;
; }doc

  ; XXX TODO -- Move to the assembler word list.

  dw dos_in

; ----------------------------------------------
  _constant_header dos_out_underscore_,'dos-in_'

; doc{
;
; dos-out_ ( -- a )
;
; Address of a routine that pages out RAM 7 and ROM 2 (DOS),
; paging in the default memory configuration: RAM 0 and ROM 3
; (48 BASIC).
;
; The stack must be somewhere in central 32K (conforming to
; +3DOS requirements).
;
; See also: `dos-in_`.
;
; }doc

  ; XXX TODO -- Move to the assembler word list.

  dw dos_in

; ----------------------------------------------
  _constant_header dos_ix_preserve_ip_underscore_,'dos-ix-preserve-ip_'

; doc{
;
; dos-ix-preserve-ip_ ( -- a )
;
; Address of a routine that executes the +3DOS command hold in
; the IX register, preserving the Forth IP.

; ....
; Input:
;   IX = address of the +3DOS routine
; Output:
;   IX = Forth `next`
; ....

; The stack must be somewhere in central 32K (conforming to
; +3DOS requirements).
;
; See also: `dos-ix_`, `dos-tos_`.
;
; }doc

  ; XXX TODO -- Move to the assembler word list.

  dw dos.ix.preserve_ip


; ----------------------------------------------
  _constant_header push_dos_ior_,'pushdosior'

  ; XXX TODO -- Move to the assembler word list.

; doc{
;
; pushdosior ( -- a )
;
; Address of an entry point to the Forth inner interpreter.
; This entry point is jumped to at the end of a code word, in order
; to convert a _dosior_ into a _ior_ and push it.

; ....
; Input:
;   A  = +3DOS error result (0..36)
; Output:
;   If error:
;     TOS = Forth exception code (-1036..-1000)
;   If no error:
;     TOS = zero
; ....

; See also: `dosior>ior`.
;
; }doc

  dw push_dos_ior

; ----------------------------------------------
_code_header dosior_to_ior_,'dosior>ior'

; doc{
;
; dosior>ior ( dosior -- ior )
;
; Convert a DOS ior to a Forth ior.
;
; This word is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : dosior>ior ( dosior -- ior )
;   1000 + negate ;
; ----

; See also: `pushdosior`.
;
; }doc

  pop hl
  call dosior_to_ior.hl
  _jp_pushhl

dosior_to_ior:

  ; Input:
  ;   A  = +3DOS error code (0..36)
  ; Output:
  ;   HL = Forth exception code (-1036..-1000)

  ld h,0
  ld l,a

dosior_to_ior.hl:

  ; Input:
  ;   HL  = +3DOS error code (0..36)
  ; Output:
  ;   HL = Forth exception code (-1036..-1000)

  ld de,1000
  add hl,de
  jp negate_hl

; ----------------------------------------------
  _colon_header sector_id_,'sector-id'

; doc{

; sector-id ( n -- x )

; Convert the sequential disk sector _n_ (0 base) to the disk
; sector id _x_, in the format required by +3DOS: The high byte
; of _x_ is the logical track (0 base); its low byte is the
; logical sector (0 base).

; ----
; : sector-id ( n -- x )
;   1+              \ the first sector is not used
;   rec/track /mod  ( sector track )
;   flip or ;
; ----

; }doc

  dw one_plus_
  dw rec_slash_track_,slash_mod_
  dw flip_,or_
  dw exit_

; ----------------------------------------------
  _colon_header transfer_block_,'transfer-block'

; doc{
;
; transfer-block ( u -- ior )
;
; The block-level disk read-write linkage.  Transfer block _u_
; to or from disk.  The read or write mode must be previously
; set by `write-mode` or `read-mode`.
;
; Definition:

; ----
; : transfer-block ( u -- )
;   >drive-block
;   rec/blk * dup    sector-id buffer-data
;                    transfer-sector throw
;                 1+ sector-id [ buffer-data b/rec + ] literal
;                    transfer-sector throw ;
; ----

; See also: `transfer-sector`.
;
; }doc

  dw to_drive_block_
  dw rec_slash_blk_,star_ ; sequential number of the first sector of the block
  dw dup_
  dw sector_id_
  dw buffer_data_
  dw transfer_sector_,throw_

  dw one_plus_,sector_id_
  _literal buffer_data+bytes_per_sector
  dw transfer_sector_,throw_

  dw exit_

; ----------------------------------------------
  _code_header reposition_file_,'reposition-file'

; doc{
;
; reposition-file ( ud fid -- ior )
;
; }doc

  ; XXX TODO -- Move to the library.

  ld (reposition_file.backup_ip),bc ; save Forth IP
  pop bc
  ld b,c ; fid
  pop de ;
  pop hl ; EHL = file pointer
  ld ix,dos_set_position
  call dos.ix
reposition_file.backup_ip equ $+1
  ld bc,0 ; restore Forth IP
  jp push_dos_ior

; ----------------------------------------------
  _code_header file_position_,'file-position'

; doc{
;
; file-position ( fid -- ud ior )
;
; }doc

  ; XXX TODO -- Move to the library.

  pop hl ; L = fid
  push bc ; save Forth IP
  ld b,l ; fid
  ld ix,dos_get_eof
  call dos.ix
  pop bc ; restore Forth IP
  push hl ; low part of _ud_
  push de ; high part of _ud_
  jp push_dos_ior

; ----------------------------------------------
  _code_header transfer_bytes_,'transfer-bytes'

; doc{
;
; transfer-bytes ( n ca len fid -- ior )
;
; Transfer _len_ bytes to/from file _fid_ to/from memory, using _n_ as
; page $C000..$FFFF.  The read or write mode must be previously set by
; `write-mode` or `read-mode`.
;
; }doc

  ; XXX OLD
  ; XXX TODO -- Move to the library.
  ; XXX TODO -- Update `read-mode` and `write-mode` to modify
  ; this word too

  ld (transfer_bytes.backup_ip),bc ; save Forth IP
  pop bc ; C = fid
  ld a,c ; A = fid
  pop de ; length
  pop hl ; address
  pop bc ; C = page
  ld b,a ; B = fid
transfer_bytes.command equ $+2
  ld ix,dos_write
  call dos.ix
transfer_bytes.backup_ip equ $+1
  ld bc,0 ; restore Forth IP
  jp push_dos_ior

; ----------------------------------------------

bytes_per_xdpb: equ 26

if current_drive_method=2

xdpb:
  defs bytes_per_xdpb ; XXX TMP --

endif

if current_drive_method=4

  _variable_header xdpb0_,'xdpb0'

  defs bytes_per_xdpb ; XXX TMP -- For unit 0.

  _variable_header xdpb1_,'xdpb1'

  defs bytes_per_xdpb ; XXX TMP -- For unit 1.

endif

; ----------------------------------------------
  _code_header transfer_sector_,'transfer-sector'

; doc{
;
; transfer-sector ( x a -- ior )
;
; The sector-level disk read-write linkage.  Transfer one
; sector from memory address _a_ to disk sector _x_ or the
; other way around.  The read or write mode must be previously
; set by `write-mode` or `read-mode`.
;
; See also: `transfer-block`.
;
; }doc

if current_drive_method=0 ; XXX TMP --

  ; XXX REMARK -- This is not affected by `set-drive`. Therefore
  ; it does not work with `set-block-drives`.  Only the first
  ; drive is used for blocks.

  ld (transfer_sector.backup_ip),bc ; save Forth IP

  call dos_in
  ld a,'A'                          ; logical drive: 'A' or 'B'
  call dos_ref_xdpb
  ; IX = XDPB of the current drive
  call dos_out

  pop hl                                ; address of origin or destination buffer
  pop de                                ; D = logical track, E = logical sector

  jr nc,transfer_sector.end             ; exit if the DOS call failed

  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer

  ld a,(address_of_default_bank)
  ld b,a                                ; page for $C000..$FFFF
  ld c,0                                ; physical drive: 0..1

  exx                                   ; save HL
transfer_sector.command equ $+1
  ld hl,dd_read_sector
  push hl
  exx                                   ; restore HL

  ; B  = page for $C000..$FFFF
  ; C  = unit (physical drive): 0..1
  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer
  call dos.tos

transfer_sector.end:
transfer_sector.backup_ip equ $+1
  ld bc,0                               ; restore Forth IP
  ld ix,next                            ; restore Forth IX
  jp push_dos_ior

endif

if current_drive_method=1 ; XXX TMP --

  ; XXX FIXME -- 
  ;
  ; need set-block-drives
  ; 11 block u. ; OK
  ; 730 block u. ; error #-1004 ("no data")

  ld (transfer_sector.backup_ip),bc ; save Forth IP

  call dos_in
transfer_sector.logical_drive: equ $+1
  ld a,'A'                              ; logical drive: 'A'..'B' (patched by `set-drive`)
  call dos_ref_xdpb
  ; IX = XDPB of the current drive
  call dos_out

  pop hl                                ; address of origin or destination buffer
  pop de                                ; D = logical track, E = logical sector

  jr nc,transfer_sector.end             ; exit if the DOS call failed

  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer

  ld a,(address_of_default_bank)
  ld b,a                                ; page for $C000..$FFFF
transfer_sector.physical_drive: equ $+1
  ld c,0                                ; physical drive: 0..1 (patched by `set-drive`)

  exx                                   ; save HL
transfer_sector.command equ $+1
  ld hl,dd_read_sector
  push hl
  exx                                   ; restore HL

  ; B  = page for $C000..$FFFF
  ; C  = unit (physical drive): 0..1
  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer
  call dos.tos

transfer_sector.end:
transfer_sector.backup_ip equ $+1
  ld bc,0                               ; restore Forth IP
  ld ix,next                            ; restore Forth IX
  jp push_dos_ior

endif

if current_drive_method=2 ; XXX TMP --

  ; XXX REMARK -- This works with `set-block-drives`, but
  ; it's too slow calling `dd_login` for every sector.

  ld (transfer_sector.backup_ip),bc ; save Forth IP

  call dos_in
transfer_sector.physical_drive.instance_0: equ $+1
  ld c,0                                ; physical drive: 0..1 (patched by `set-drive`)
  ld ix,xdpb
  call dd_login
  ; IX = XDPB of the first drive
  call dos_out

  pop hl                                ; address of origin or destination buffer
  pop de                                ; D = logical track, E = logical sector

  jr nc,transfer_sector.end             ; exit if the DOS call failed

  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer

  ld a,(address_of_default_bank)
  ld b,a                                ; page for $C000..$FFFF
transfer_sector.physical_drive.instance_1: equ $+1
  ld c,0                                ; physical drive: 0..1 (patched by `set-drive`)

  exx                                   ; save HL
transfer_sector.command equ $+1
  ld hl,dd_read_sector
  push hl
  exx                                   ; restore HL

  ; B  = page for $C000..$FFFF
  ; C  = unit (physical drive): 0..1
  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer
  call dos.tos

transfer_sector.end:
transfer_sector.backup_ip equ $+1
  ld bc,0                               ; restore Forth IP
  ld ix,next                            ; restore Forth IX
  jp push_dos_ior

endif

if current_drive_method=3 ; XXX TMP --

  ; XXX FIXME --
  ;
  ; need set-block-drives
  ; 11 block u.   \ OK
  ; 730 block u.  \ error #-1004 ("no data")

  ld (transfer_sector.backup_ip),bc ; save Forth IP

transfer_sector.xdpb: equ $+2           ; XDPB (patched by `set-drive`)
  ld ix,0

  pop hl                                ; address of origin or destination buffer
  pop de                                ; D = logical track, E = logical sector

  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer

  ld a,(address_of_default_bank)
  ld b,a                                ; page for $C000..$FFFF
transfer_sector.physical_drive: equ $+1
  ld c,0                                ; physical drive: 0..1 (patched by `set-drive`)

  exx                                   ; save HL
transfer_sector.command equ $+1
  ld hl,dd_read_sector
  push hl
  exx                                   ; restore HL

  ; B  = page for $C000..$FFFF
  ; C  = unit (physical drive): 0..1
  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer
  call dos.tos

transfer_sector.end:
transfer_sector.backup_ip equ $+1
  ld bc,0                               ; restore Forth IP
  ld ix,next                            ; restore Forth IX
  jp push_dos_ior

endif

if current_drive_method=4 ; XXX TMP -- Copy of 3

  ; XXX WARNING -- This approach needs `0 log-in-disk` and `1
  ; log-in-disk` after inserting the library disks.

  ; XXX FIXME --
  ;
  ; need set-block-drives
  ; 0 log-in-disk
  ; 1 log-in-disk
  ; 11 block u.   \ OK
  ; 730 block u.  \ error #-1004 ("no data")

  ld (transfer_sector.backup_ip),bc ; save Forth IP

transfer_sector.xdpb: equ $+2           ; XDPB (patched by `set-drive`)
  ld ix,xdpb0_pfa                       ; xdpb0_pfa or xdpb1_pfa

  pop hl                                ; address of origin or destination buffer
  pop de                                ; D = logical track, E = logical sector

  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer

  ld a,(address_of_default_bank)
  ld b,a                                ; page for $C000..$FFFF
transfer_sector.physical_drive: equ $+1
  ld c,0                                ; physical drive: 0..1 (patched by `set-drive`)

  exx                                   ; save HL
transfer_sector.command equ $+1
  ld hl,dd_read_sector
  push hl
  exx                                   ; restore HL

  ; B  = page for $C000..$FFFF
  ; C  = unit (physical drive): 0..1
  ; D  = logical track
  ; E  = logical sector
  ; HL = address of origin or destination buffer
  call dos.tos

transfer_sector.end:
transfer_sector.backup_ip equ $+1
  ld bc,0                               ; restore Forth IP
  ld ix,next                            ; restore Forth IX
  jp push_dos_ior

endif

; ----------------------------------------------
  _code_header write_mode_,'write-mode'

; doc{
;
; write-mode ( -- )
;
; Set the write mode for `transfer-sector` and `transfer-block`.
;
; See also: `read-mode`.
;
; }doc

  ld hl,dd_write_sector
  jr transfer_mode

; ----------------------------------------------
  _code_header read_mode_,'read-mode'

; doc{
;
; read-mode ( -- )
;
; Set the read mode for `transfer-sector` and `transfer-block`.
;
; See also: `write-mode`.
;
; }doc

  ld hl,dd_read_sector

transfer_mode:
  ; HL = DOS routine
  ld (transfer_sector.command),hl
  _jp_next

; ----------------------------------------------
if 0 ; XXX OLD
  _code_header open_disk_,'open-disk'

; doc{
;
; open-disk ( c n -- ior )
;
; Open disk _c_ ('A'..'P') as a single file _n_ (0..15).
;
; }doc

  ; XXX TODO -- Finish the documentation.

  ; XXX TODO -- Move to the library.

  pop hl               ; L = file number
  pop de               ; E = drive
  push bc              ; save Forth IP
  ld a,e               ; drive
  ld b,l               ; file number
  ld c,%011            ; access mode: exclusive-read-write ; XXX TMP --
  ld ix,dos_open_drive
  call dos.ix
  pop bc               ; restore Forth IP
  jp push_dos_ior

endif

; ----------------------------------------------
  _code_header get_drive_,'get-drive'

; doc{
;
; get-drive ( -- c ior )
;
; Get the current default drive _c_ ('A'..'P'), i.e.
; the drive implied by all filenames that do not specify a
; drive. The default drive is intially 'A'.
;
; See also: `set-drive`.
;
; }doc

  ; XXX TODO -- Also default drive for blocks.
  ; XXX TODO -- Move to the library.

  ld a,255
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  ld h,0
  ld l,a
  push hl
  jp push_dos_ior

; ----------------------------------------------
if current_drive_method=4

  _code_header log_in_disk_,'log-in-disk'

; doc{
;
; log-in-disk  ( n -- ior )
;
; Log in a new disk in phyisical drive unit _n_ (0..1).
;
; }doc

  exx                   ; save Forth IP
  pop bc                ; C = physical drive unit (0..1)
  ld ix,xdpb0_pfa       ; XDPB for physical drive unit 0
  ld a,c
  and a                 ; physical drive unit 0?
  jr z,log_in_disk.call ; if so, continue
  ld ix,xdpb1_pfa       ; XDPB for physical drive unit 0
log_in_disk.call
  call dos_in
  call dd_login
  call dos_out
  exx                   ; restore Forth IP
  ld ix,next            ; restore Forth IX
  jp push_dos_ior

endif

; ----------------------------------------------
if 0 ; XXX TMP --

  _code_header set_sector_drive_,'set-sector-drive'

  ; XXX TMP -- Experimental factor.

; doc{
;
; set-sector-unit ( n -- ior )
;
; Set unit _n_ (0..1) as the default unit for sector-level
; access, i.e.  the unit used by `transfer-sector` and
; `transfer-block`. The default unit is initially 0.
;
; See also: `set-sector-unit`.
;
; }doc

  pop hl
  ld a,l
  sub 'A'
  ld hl,xdpb0_pfa
  jr z,set_sector_drive.patch_transfer_sector
  ld hl,xdpb1_pfa
set_sector_drive.patch_transfer_sector:
  ld (transfer_sector.physical_drive),a
  ld (transfer_sector.xdpb),hl
  jp push_dos_ior

; ----------------------------------------------
  _code_header get_sector_unit_,'get-sector-unit'

  ; XXX TMP -- Experimental factor.

; doc{
;
; get-sector-unit ( -- n )
;
; Get unit _n_ (0..1) currently used for sector-level access,
; i.e.  the unit used by `transfer-sector` and `transfer-block`.
; The default unit is initially 0.
;
; See also: `set-sector-unit`.
;
; }doc

  ld a,(transfer_sector.physical_drive)
  jp push_a

endif

; ----------------------------------------------
  _code_header set_filename_drive_,'set-filename-drive'

  ; XXX TMP -- Experimental factor.

; doc{
;
; set-filename-drive ( c -- ior )
;
; Set drive _c_ ('A'..'P') as the current default drive, i.e.
; the drive implied by all filenames that do not specify a
; drive.
;
; Does not access the drive, but merely checks that there is a
; driver for it (which does not imply that the drive exists).
;
; See also: `get-filename-drive`.
;
; }doc

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jp push_dos_ior

; ----------------------------------------------
  _code_header get_filename_drive_,'get-filename-drive'

  ; XXX TMP -- Experimental factor.

; doc{
;
; get-filename-drive ( -- c ior )
;
; Get drive _c_ ('A'..'P') currently used as default drive, i.e.
; the drive implied by all filenames that do not specify a
; drive.
;
; See also: `set-filename-drive`.
;
; }doc

  ld a,$FF
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  ld h,0
  ld l,a
  push hl
  jp push_dos_ior

; ----------------------------------------------
  _code_header set_drive_,'set-drive'

; doc{
;
; set-drive ( c -- ior )
;
; Set drive _c_ ('A'..'P') as the current default drive, i.e.
; the drive implied by all filenames that do not specify a
; drive, and the drive used by `transfer-sector` and
; `transfer-block`. The default drive is intially 'A'.
;
; Does not access the drive, but merely checks that there is a
; driver for it (which does not imply that the drive exists).
;
; See also: `get-drive`.
;
; }doc

  ; XXX UNDER DEVELOPMENT

if current_drive_method=0 ; XXX TMP --

  ; XXX REMARK -- This does not affect the drive used by
  ; `transfer-sector`. Therefore `set-block-drives` has no
  ; effect and all blocks are loaded from the first drive.

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jp push_dos_ior

endif

if current_drive_method=1 ; XXX TMP --

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jr nc,set_drive.end ; skip if error

  ; A = logical drive ('A'..'P')
  ; CY = 1 (no error)

  ld (transfer_sector.logical_drive),a
  sub 'A'
  ccf ; set carry flag again
  ld (transfer_sector.physical_drive),a

set_drive.end
  jp push_dos_ior

endif

if current_drive_method=2 ; XXX TMP --

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jr nc,set_drive.end ; skip if error

  ; A = logical drive ('A'..'P')
  ; CY = 1 (no error)

  sub 'A'
  ccf ; set carry flag again
  ld (transfer_sector.physical_drive.instance_0),a
  ld (transfer_sector.physical_drive.instance_1),a

set_drive.end
  jp push_dos_ior

endif

if current_drive_method=3 ; XXX TMP --

  ; XXX UNDER DEVELOPMENT

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jr nc,set_drive.end ; skip if error

  ; A = logical drive ('A'..'P')
  ; CY = 1 (no error)
  push af

  call dos_in
  call dos_ref_xdpb
  ; IX = XDPB of the current drive
  ld (transfer_sector.xdpb),ix
  call dos_out
  ld ix,next

  pop af
  push af
  sub 'A'
  ld (transfer_sector.physical_drive),a
  pop af

set_drive.end
  jp push_dos_ior

endif

if current_drive_method=4 ; XXX TMP --

  ; XXX UNDER DEVELOPMENT

  pop hl
  ld a,l
  ld ix,dos_set_drive
  call dos.ix.preserve_ip
  jr nc,set_drive.end ; skip if error

  ; A = logical drive ('A'..'P')
  ; CY = 1 (no error)
  push af

  sub 'A'
  ld hl,xdpb0_pfa
  jr z,set_drive.patch_transfer_sector
  ld hl,xdpb1_pfa
set_drive.patch_transfer_sector:
  ld (transfer_sector.physical_drive),a
  ld (transfer_sector.xdpb),hl

  pop af

set_drive.end
  jp push_dos_ior

endif


; ----------------------------------------------
  _code_header ref_xdbp_,'ref-xdpb'

; doc{
;
; ref-xdbp ( c -- a ior )
;
; Return the address _a_ of the XDPB of drive _c_ ('A'..'P').
;
; }doc

  ; XXX TODO -- Confirm: The returned address is accessible
  ; when bank 7 is paged in.

  ; XXX TODO -- Move to the library.

  pop hl
  ld a,l               ; drive 'A'..'P'
  ld ix,dos_ref_xdpb
  call dos.ix.preserve_ip
  push ix
  jp push_dos_ior

; ==============================================================

endif ; defined plus3dos

; vim: filetype=z80:textwidth=64
