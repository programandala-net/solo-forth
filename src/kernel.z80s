; kernel.z80s

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; Last modified: 202007080015

include version.z80s

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2015, 2016, 2017, 2018, 2019,
; 2020.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; History

; See:
; http://programandala.net/en.program.solo_forth.history.html
; http://github.com/programandala-net/solo-forth

; ==============================================================
; System description

; ----------------------------------------------
; Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before exit.
;       IX   Address of `next`.
;            May be used within Forth words if restored before exit.
;       IY   Address of the ERRNR ZX Spectrum system variable.
;            May be used within Forth words if restored before exit.

; ----------------------------------------------
; Header structure

; The headers are created in paged memory:

; xtp: dw xt               ; Pointer to xt in main memory.
; lfa: dw nt of the previous word
; nt:  db length+flags     ; Bits:      76543210
                           ; Bit names: CPSLLLLL
                           ; Legend:
                           ;   C: Compile-only bit.
                           ;      0 = non-restricted word
                           ;      1 = compile-only word
                           ;   P: Immediate bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0 .. 31).
;       ds length          ; name

; The code field and the data field are created in the data
; space:

; xt:  code
; dfa: ...

; ==============================================================
; Configuration

  ; XXX Note: Pasmo issues strange errors (symbols not found)
  ; when some config flags are used in a nested `if`. A literal
  ; flag (0/1) is used instead, with the flag name in a comment;
  ; it is changed with a text substitution.

; ----------------------------------------------
; DOS

  ; Solo Forth can be compiled for G+DOS, +3DOS or TR-DOS.  This
  ; depends on three labels, `gplusdos`, `plus3dos` and `trdos`,
  ; defined with a parameter of the Pasmo assembler. See the
  ; Makefile files for details.

if !defined gplusdos
  gplusdos: equ false
endif

if !defined plus3dos
  plus3dos: equ false
endif

if !defined trdos
  trdos: equ false
endif

if (gplusdos+plus3dos+trdos)=0
  gplusdos: equ true ; G+DOS by default
endif

; ----------------------------------------------
; Pentagon and Scorpion

  ; The TR-DOS version of Solo Forth needs some changes on the
  ; Pentagon and Scorpion computers.  The labels `pentagon` and
  ; `scorpion` are created with a parameter of the Pasmo
  ; assembler, initializing them with the RAM size RAM (256, 512
  ; or 1024). By default, their value is false, i.e. the
  ; compilation is not done for them, but for the Sinclar
  ; models:

if (!defined pentagon)
  pentagon: equ false
endif

if (!defined scorpion)
  scorpion: equ false
endif

; ----------------------------------------------
; Misc

size_optimization: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

;assembler_core_in_kernel: equ true
  ; XXX REMARK -- this flag is harcoded in the code

developing: equ true
  ; true = include some words needed during the development
  ; false = don't

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

default_origin:                   equ $5E00

if gplusdos

  ; XXX REMARK -- G+DOS needs 787 bytes for every output
  ; channel, but the file-access word set is not finished yet.
  ;
  ;origin:                         equ default_origin+2*787

  origin:                         equ default_origin

endif

if plus3dos

  origin:                         equ default_origin

endif

if trdos

  ; TR-DOS needs $70 bytes of RAM for its system variables.  It
  ; also uses a $100-byte buffer when accessing the disk.  This
  ; buffer is allocated dynamically. Therefore, the default
  ; origin of the Forth system must be moved up $170 bytes:

  origin:                         equ default_origin+$170

endif

ramtop:                           equ origin-1 ; used by the BASIC loader

false:                            equ $0000
true:                             equ $FFFF ; -1

cell:                             equ $02

cells_per_data_stack:             equ $50
cells_per_return_stack:           equ $A8

  ; XXX REMARK -- 2016-11-19: The return stack has been
  ; increased from $50 to $55 cells. The loading of `tt` (a
  ; sample game) needs $55 cells; `blocked` (a block editor)
  ; needs $54 cells.  Formerly the terminal input buffer was
  ; below the return stack and worked as a pad for it, so the
  ; problem was unnoticed.  But the terminal input buffer was
  ; moved on 2016-11-15 in order to make all buffers contiguous
  ; so the circular string buffer can be expandable.  As a
  ; temporary solution, also the return stack is checked in
  ; `?stack`, when the developing label is on.
  ;
  ; XXX REMARK -- 2016-12-03: Each `nest-source` uses 6 cells
  ; of the return stack for data; `need` uses 2 cells for data;
  ; 9 more cells are used by calls at every nesting level of
  ; `need`... With a $56 cells large return stack, only 5
  ; levels of `need` are possible.  The size is increased to
  ; $64. `?rstack` has been factored from `?stack` and called
  ; directly by `interpret`, during the development.
  ;
  ; XXX REMARK -- 2017-01-04: $70 cells, the minimum needed to
  ; load `8-bit-rng-pix-benchs` and `16-bit-rng-pix-benchs` (8
  ; nested `need` each).
  ;
  ; XXX REMARK -- 2017-01-23: $90 cells. $70 is not enough to
  ; load `beep`. The final solution is to share a common space
  ; between the data and the return stack, as planned.
  ;
  ; XXX REMARK -- 2017-01-24: $A0 cells, needed to load the
  ; latest factored version of `beep`...
  ;
  ; XXX REMARK -- 2017-01-24: $A8 cells, needed to load the
  ; latest factored version of `beep`...

bytes_per_terminal_input_buffer:  equ $50

bytes_per_buffer:                 equ $0400

if gplusdos
  sectors_per_track:                equ 10
  blocks_per_disk:                  equ 800
  sectors_per_block:                equ 2
  max_drives:                       equ 2
  first_drive:                      equ 1 ; 1 .. 2
endif
if plus3dos
  sectors_per_track:                equ 9
  blocks_per_disk:                  equ 719 ; 720 minus 1 KiB of 2 sectors (first and last)
  sectors_per_block:                equ 2
  max_drives:                       equ 2
  first_drive:                      equ 'A' ; 'A' .. 'P'
endif
if trdos
  sectors_per_track:                equ 16
  blocks_per_disk:                  equ 636 ; 640 minus 4 KiB of track 0
  sectors_per_block:                equ 4
  max_drives:                       equ 4
  first_drive:                      equ 0 ; 0 .. 3
endif

bytes_per_sector:                 equ bytes_per_buffer/sectors_per_block

characters_per_line:              equ $40
lines_per_screen:                 equ $10
max_search_order:                 equ $08 ; maximum number of word lists in the search order
bytes_per_user_variables:         equ $40

word_length_mask:                 equ %00011111
smudge_mask:                      equ %00100000
immediate_mask:                   equ %01000000
compile_only_mask:                equ %10000000

max_word_length:                  equ word_length_mask
valid_word_length_mask:           equ word_length_mask or smudge_mask

stringer_size:                    equ 256 ; in bytes

; Memory banks

bank_start:                       equ $C000
bank_end:                         equ $FFFF
bank_size:                        equ $4000 ; 16 KiB

default_bank:                     equ 0

names_pointer_bottom:             equ $0000

; Error codes used in the kernel

error.stack_overflow:               equ -003
error.stack_underflow:              equ -004
error.return_stack_overflow:        equ -005
error.return_stack_underflow:       equ -006
error.dictionary_overflow:          equ -008
error.not_found:                    equ -013
error.compilation_only:             equ -014
error.zero_length_name:             equ -016
error.control_structure_mismatch:   equ -022
error.invalid_block_number:         equ -035
error.search_order_overflow:        equ -049
error.search_order_underflow:       equ -050
error.not_understood:               equ -256
error.not_unique:                   equ -257
error.stack_unbalanced:             equ -258
error.loading_from_screen_0:        equ -259
error.wrong_digit:                  equ -260
error.deferred_word_uninitialized:  equ -261
error.assertion_failed:             equ -262
error.execution_only:               equ -263
error.definition_not_finished:      equ -264
error.loading_only:                 equ -265
error.off_current_editing_screen:   equ -266

; ----------------------------------------------
; ZX Spectrum

include inc/zx_spectrum_char_codes.z80s
include inc/zx_spectrum_rom_routines.z80s
include inc/zx_spectrum_system_variables.z80s
include inc/zx_spectrum_system_variables_offsets.z80s

sys_screen:                 equ $4000 ; address
sys_screen_size:            equ $1B00
sys_screen_bitmap_size:     equ $1800
sys_screen_attributes:      equ $5800 ; address
sys_screen_attributes_size: equ $0300

bank1_port:     equ $7FFD
bank2_port:     equ $1FFD
border_port:    equ $FE

; ==============================================================
; Macros

; ----------------------------------------------
; Macros for headers

immediate:    equ immediate_mask
compile_only: equ compile_only_mask

nt_of_the_previous_word: defl 0 ; link to previous Forth word

word_count: defl 0

_header: macro _base_label,_name,_flags,_xt

  ; In data space:

  if nul _xt
    _base_label: equ $ ; execution token
  else
    _base_label: equ _xt ; execution token of an alias
  endif

  local _dp_backup
  local _name_address
  local _address_after_name
  _dp_backup: equ $

  ; In memory bank:
  org bank_start+(np mod bank_size)

  ; Execution token pointer:
  _base_label##xtp: equ $-bank_start

  if nul _xt
    dw _base_label ; execution token pointer
  else
    dw _xt ; execution token pointer of an alias
  endif
  ; XXX TODO -- the `if` can be removed because `_base_label`
  ; has already been set at the start of the macro

  ; Link field address:
  _base_label##lfa: equ $-bank_start

    dw nt_of_the_previous_word ; link field

  ; Name token:
  _base_label##nt: equ $-bank_start

  ; Length byte with optional flags:

  if nul _flags
    db _address_after_name-_name_address
  else
    db _address_after_name-_name_address+_flags
  endif

  _name_address: equ $
    db _name
  _address_after_name: equ $

  ; Set new value of the name-space pointer:
  np: defl $-bank_start

  ; Update the name-space pointer:
  org names_pointer
  dw np ; overwrite the contents of names_pointer
  dw np ; overwrite the contents of names_pointer_init_value

  word_count: defl word_count+1

  ; In dictionary:
  org _dp_backup

  nt_of_the_previous_word: defl _base_label##nt

  endm

_code_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags

  endm

_defer_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags
  jp _xt

  endm

_alias_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags,_xt

  endm

_colon_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_colon ; code field
  _base_label##dfa: ; data field address

  endm

_user_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_user ; code field
  _base_label##dfa: ; data field address

  endm

_does_header: macro _base_label,_name,_flags,_runtime_routine

  _header _base_label,_name,_flags

  call _runtime_routine ; code field ; XXX TODO confirm this
  _base_label##dfa: ; data field address

  endm

_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_constant ; code field
  _base_label##dfa: ; data field address

  endm

_two_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_two_constant ; code field
  _base_label##dfa: ; data field address

  endm

_c_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_c_constant ; code field
  _base_label##dfa: ; data field address

  endm

_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_variable ; code field
  _base_label##dfa: ; data field address

  endm

_two_variable_header: macro _base_label,_name,_flags

  _variable_header _base_label,_name,_flags

  endm

; ----------------------------------------------
; Macros for literals

_string: macro text

  local _first ; address of the first character of the name
  local _next  ; address after the last character of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_literal: macro _n

  ; Note: parenthesis are needed to prevent a strange problem of
  ; Pasmo with signs.

  if (_n)=(-1)
    dw minus_one_
  else
    if (_n)=0
      dw zero_
    else
      if (_n)=1
        dw one_
      else
        if (_n)=2
          dw two_
        else
          if (_n)>=0 && (_n)<=255
            dw c_lit_
            db _n
          else
            dw lit_
            dw _n
          endif
        endif
      endif
    endif
  endif

  endm

; ----------------------------------------------
; Macros for jumps

_jp_next: macro

  jp (ix)

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Macros for error messages

_throw: macro _error
  _literal (_error)
  dw throw_
  endm

_question_throw: macro _error
  _literal (_error)
  dw question_throw_
  endm

_message: macro _error
  _literal (_error)
  dw dot_throw_
  endm

; ----------------------------------------------
; Macros for debugging

debugging: equ 0

_just_border: macro _color
  if debugging
    dw lit_,_color,border_
  endif
  endm

_z80_just_border: macro _color
  if debugging
    push af
    ld a,_color
    out($FE),a
    pop af
  endif
  endm

_z80_border: macro _color
  if debugging
    local _pause0
    push af
    push bc
    ld a,_color
    out($FE),a
    ld bc,0
    _pause0:
    dec bc
    ld a,b
    or c
    jr nz,_pause0
    pop bc
    pop af
  endif
  endm

_border_wait: macro _color
  if debugging
    _just_border _color
    dw key_,drop_
  endif
  endm

_z80_border_wait: macro _color
  if debugging
    local _wait
    push af
    ld a,_color
    out($FE),a
    xor a
    ld (sys_last_k),a
    _wait:
    ld a,(sys_last_k)
    and a
    jr z,_wait
    pop af
  endif
  endm

_echo: macro _txt
  if debugging
    dw cr_,paren_dot_quote_
    _string _txt
  endif
  endm

  ; type the string on top of stack
_type: macro
  if debugging
    _echo 'TOS str= <'
    dw two_dup_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; type the counted string on top of stack
_ctype: macro
  if debugging
    _echo 'TOS cstr= <'
    dw dup_,count_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; check point
_chk: macro _message
  if debugging
    _echo _message
    ; dw base_,fetch_,to_r_,hex_
    dw cr_,u_dot_s_
    ; dw from_r_,base_,store_
  endif
  endm

_prompt: macro _message
  if debugging
    _echo _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
_brk: macro _message
  if debugging
    _chk _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the string on top of stack
_brk_type: macro _message
  if debugging
    _chk _message
    _type
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the counted string on top of stack
_brk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
    dw key_,drop_
  endif
  endm

  ; check point
  ; first type the string on top of stack
_chk_type: macro _message
  if debugging
    _chk _message
    _type
  endif
  endm

  ; check point
  ; first type the counted string on top of stack
_chk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
  endif
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; `$01 +origin` (destination address of the jump)
  jp cold_start
warm_entry:
  ; `$04 +origin` (destination address of the jump)
  jp warm_start

; ==============================================================
; Parameter area

latest_nt_in_root_word_list.init_value:
  ; `$06 +origin`
  dw latest_nt_in_root_word_list

latest_nt_in_forth_word_list.init_value:
  ; `$08 +origin`
  dw latest_nt_in_forth_word_list

  ; `$0A +origin`
if 1 ; assembler_core_in_kernel
latest_nt_in_assembler_word_list.init_value:
  dw latest_nt_in_assembler_word_list
else
  dw 0 ; XXX TMP --
endif

latest_wordlist.init_value:
  ; `$0C +origin`
if 1 ; assembler_core_in_kernel
  dw assembler_wordlist_dfa
else
  dw forth_wordlist_dfa
endif

return_stack_pointer:
  ; `$0E +origin`
  dw return_stack_bottom

default_attribute_and_mask:
  ; `$10 +origin`
  db 4          ; low byte: green paper, black ink
  ; `$11 +origin`
  db %00000000  ; high byte: no mask

  ; User variables default values

  ; The first 9 user variables have default values.  They are
  ; used by `cold` to overwrite the actual user variables and
  ; must be defined in identical order.

default_user_variables_start:

sp0_init_value:                               ; +$00
  ; `$12 +origin`
  dw data_stack_bottom

rp0_init_value:                               ; +$02
  ; `$14 +origin`
  dw return_stack_bottom

; XXX OLD -- Not used.                        ; +$04
  ; `$16 +origin`
  dw $0000

width_init_value:                             ; +$06
  ; `$18 +origin`
  dw max_word_length

; XXX OLD -- Not used.                        ; +$08
  ; `$1A +origin`
  dw $0000

last_init_value:                              ; +$0A
  ; `$1C +origin`
  dw latest_nt_in_forth_word_list

dictionary_pointer_init_value:                ; +$0C
  ; `$1E +origin`
  dw dictionary_pointer_after_cold

user_data_pointer_init_value:                 ; +$0E
  ; `$20 +origin`
  dw user_data_pointer

lastxt_init_value:                            ; +$10
  ; `$22 +origin`
  dw latest_xt_in_forth_word_list

default_user_variables_end:

ip_backup: ; temporary copy of Forth IP
  ; `$24 +origin`
  ; XXX OLD -- not used
  dw 0

np: defl names_pointer_bottom

names_pointer:
  ; `$26 +origin`
  ; First free address in the system bank, restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

names_pointer_init_value:
  ; `$28 +origin`
  ; Init value of the name-space pointer, used by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

  ; `$2A +origin`
  ; Size of the data stack, used by `environment?`.
  dw cells_per_data_stack

  ; `$2C +origin`
  ; Size of the return stack, used by `environment?`.
  dw cells_per_return_stack

; ==============================================================
; User variables

user_variables:

  ; Note: the first 9 user variables are initialized with
  ; default values by `cold`.  They must be ordered after their
  ; default values.

  ; User variables that are initialized by `cold`:

sp0_value:                                    ; +$00
  dw data_stack_bottom
rp0_value:                                    ; +$02
  dw return_stack_bottom
paren_wait:                                   ; +$04 ; XXX OLD
  dw $0000
width_value:                                  ; +$06
  dw max_word_length
                                              ; +$08 ; XXX OLD
  dw $0000
last_value:                                   ; +$0A
  dw latest_nt_in_forth_word_list
dictionary_pointer_value:                     ; +$0C
  dw dictionary_pointer_after_cold
user_data_pointer_value:                      ; +$0E
  dw user_data_pointer
lastxt_value:                                 ; +$10
  dw latest_xt_in_forth_word_list

  ; User variables that are not initialized by `cold`:

in_value:                                     ; +$12
  dw $0000
blk_value:                                    ; +$14
  dw $0000
scr_value:                                    ; +$16
  dw $0000
; XXX not used                                ; +$18
  dw $0000
hld_value:                                    ; +$1A
  dw $0000
current_value:                                ; +$1C
  dw $0000
state_value:                                  ; +$1E
  dw $0000
base_value:                                   ; +$20
  dw $000A
dpl_value:                                    ; +$22
  dw $0000
csp_value:                                    ; +$24
  dw $0000
number_sign_order_value:                             ; +$26
  dw $0000

context_value:                                ; +$28 .. +$36

  dw forth_dfa
  dw root_dfa
  ds (max_search_order-2)*cell

  ; Free space for more user variables:

user_data_pointer: equ $-user_variables
  ds bytes_per_user_variables-user_data_pointer

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Stringer (circular string buffer)

stringer:
  ds stringer_size

; ----------------------------------------------
; Disk buffer

buffer_block_id_mask: equ $7FFF

; A block id is the number of the associated block, with the
; sign bit indicating, when it's set, that the buffer has been
; modified.

disk_buffer:
  dw buffer_block_id_mask     ; Block id used when the  buffer
                              ; is not associated with a block.
buffer_data:
  ds bytes_per_buffer         ; Actual content of the block.

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer

  ; XXX TODO -- Move the terminal input buffer below the return
  ; stack?

; ==============================================================
; Misc routines

; XXX TODO -- investigate if the code is optimized for Z80;
; the code of DZX-Forth is generic, also for 8080.

; ----------------------------------------------
; Compare DE and HL

; Credit:
; Code from DZX-Forth.

compare_de_hl_unsigned:

  ; Input:
  ;   DE, HL
  ; Output (HL<DE):
  ;   Fc=1
  ; Output (HL=DE):
  ;   Fz=1

  ; Credit:
  ; Code from DZX-Forth

          ;  T  B
          ; -- --
  ld a,h  ; 04 01
  cp d    ; 04 01
  ret nz  ; 11 01  05 01
  ld a,l  ; 04 01
  cp e    ; 04 01
  ret     ; 10 01
          ; -- --  -- --
          ; 37 06  31 06 Total

compare_de_hl_signed:

  ; Input:
  ;   DE, HL
  ; Output (HL<DE):
  ;   Fc=1

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
noop:
  ret

; ----------------------------------------------
; Move block

; Credit:
; Code from DZX-Forth.

move_block:

  ; Input:
  ;   HL = source
  ;   DE = destination
  ;   BC = count

  ; If BC is greater than zero, copy the contents of BC
  ; consecutive bytes at HL to the BC consecutive bytes at DE.
  ; After the move completes, the BC consecutive bytes at DE
  ; contain exactly what the BC consecutive bytes at HL
  ; contained before the move.

  call compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

; Credit:
; Code from DZX-Forth.

move_block_upwards:

  ; Input:
  ;   HL = source
  ;   DE = destination
  ;   BC = count

  ; If BC is greater than zero, copy BC consecutive characters from the data
  ; space starting at HL to that starting at DE, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

; Credit:
; Code from DZX-Forth.

  ; Input:
  ;   HL = source
  ;   DE = destination
  ;   BC = count

  ; If BC is greater than zero, copy BC consecutive characters
  ; from the data space starting at HL to that starting at DE,
  ; proceeding character-by-character from higher addresses to
  ; lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ----------------------------------------------
; Multiplication primitives

; XXX TODO -- Improve -- the DZX-Forth routines are for 8080,
; not Z80.

; Credit:
; Code from DZX-Forth.

; AHL <- A * DE

a_multiplied_by_de_to_ahl:
  ld hl,0
  ld c,8
a_multiplied_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_multiplied_by_de_to_ahl.2
  add hl,de
  adc a,0
a_multiplied_by_de_to_ahl.2:
  dec c
  jp nz,a_multiplied_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32-bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_unsigned:
  push bc ; save Forth IP
  ld b,h
  ld a,l
  call a_multiplied_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_multiplied_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc ; restore Forth IP
  ret

if 1 ; original_m_star
else

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_multiplied_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde ; XXX TODO

endif

if 0

  ; XXX TODO -- adapt
  ;
  ; Credit:
  ; http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#1.3

  ; Input:
  ;   DE = Multiplier
  ;   BC = Multiplicand
  ;   HL = 0
  ; Output:
  ;   DE:HL = Product

de_multiplied_by_bc_to_dehl_unsigned:

  push bc

  sla e   ; optimised 1st iteration
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.continue
  ld  h,b
  ld  l,c

de_multiplied_by_bc_to_dehl_unsigned.continue:
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  rl  e
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  add hl,bc
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  inc de

de_multiplied_by_bc_to_dehl_unsigned.end:
  pop bc
  ret

endif

; ==============================================================
; Dictionary

; ----------------------------------------------
; Start compiling in the `root` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _alias_header root_forth_,'forth',,forth_

; ----------------------------------------------
  _alias_header root_forth_wordlist_,'forth-wordlist',,forth_wordlist_

; ----------------------------------------------
  _alias_header root_set_order_,'set-order',,set_order_

  ; Name token of the latest word defined in `root-wordlist`:
latest_nt_in_root_word_list: equ root_set_order_nt

if 1 ; assembler_core_in_kernel

; ----------------------------------------------
; Start compiling in the `assembler-wordlist` word list

nt_of_the_previous_word: defl 0

; ----------------------------------------------

if 1 ; abase

  _variable_header abase_,'abase'

; doc{
;
; abase ( -- a ) "a-base"
;
; A `variable`. _a_ is the address of a cell where the current
; value of `base` is preserved by `asm`.
;
; }doc

  ; XXX TODO use the return stack instead?

  dw 0

endif

; ----------------------------------------------
  _colon_header end_asm_,'end-asm'

; doc{
;
; end-asm ( -- )
;
; Exit the `assembler` mode started by `asm`.
;
; Definition:

; ----
; : end-asm ( -- ) ?csp previous abase @ base ! ;
; ----

; See: `end-code`, `?csp`, `previous`, `abase`, `base`.
;
; }doc

  dw question_csp_
  dw previous_ ; restore the search order
if 1 ; abase
  dw abase_,fetch_,base_,store_ ; restore `base`
else
  dw base_,store_ ; restore `base`
endif

  dw exit_

; ----------------------------------------------
  _colon_header end_code_,'end-code'

; doc{
;
; end-code ( -- )
;
; Terminate a code definition started by `code` or `;code`.
;
; Definition:

; ----
; : end-code ( -- ) end-asm reveal ;
; ----

; Origin: Forth-83 (Assembler Extension Word Set).
;
; See: `end-asm`, `reveal`.
;
; }doc

  ; XXX TODO -- `code` and `end-code` could be moved to the
  ; library but they are used by 382 words in 64 library
  ; modules.

  dw end_asm_,reveal_
  dw exit_

; ----------------------------------------------
  _constant_header lower_underscore_,'lower_'

; doc{
;
; lower_ ( -- a )
;
; A `constant`. _a_ is the address of a routine that converts to
; uppercase the ASCII character hold in the A register.
;
; See: `lower`, `upper_`.
;
; }doc

  dw ascii_lower.a

; ----------------------------------------------
  _constant_header next_,'next'

; doc{
;
; next ( -- a )
;
; A `constant`. _a_ is the address of the main entry point of the
; Forth inner interpreter.  It is the address Forth words jump
; to at the end.  The code at _a_ executes the word whose
; execution token is in the address pointed by the Forth IP (the
; Z80 BC register).
;
; In Solo Forth, the Z80 IX register contains _a_, which must be
; preserved across Forth words.
;
; See: `pushhl`, `pusha`.
;
; }doc

  dw next

; ----------------------------------------------
  _constant_header pusha_,'pusha'

; doc{
;
; pusha ( -- a ) "push-a"
;
; A `constant`. _a_ is the address of a secondary entry point of
; the Forth inner interpreter.  The code at _a_ pushes the A
; register onto the stack and then continues at the address
; returned by `next`.
;
; ``pusha`` is useful for exiting from a `code` word using an
; absolute conditional jump, or to save the bytes needed to
; prepare an 8-bit register to be pushed on the stack.
;
; See: `pushhl`, `pushhlde`.
;
; }doc

  dw push_a

; ----------------------------------------------
  _constant_header pushhl_,'pushhl'

; doc{
;
; pushhl ( -- a ) "push-h-l"
;
; A `constant`. _a_ is the address of a secondary entry point of
; the Forth inner interpreter.  The code at _a_ pushes the HL
; register onto the stack and then continues at the address
; returned by `next`.
;
; ``pushhl`` is useful for exiting from a `code` word using an
; absolute conditional jump.
;
; See: `pusha`, `pushhlde`.
;
; }doc

  dw push_hl

; ----------------------------------------------
  _constant_header fetchhl_,'fetchhl'

  ; XXX TODO -- Move to the library? Calculate the address from
  ; the xt of `@`.

; doc{
;
; fetchhl ( -- a ) "fetch-h-l"
;
; A `constant`. _a_ is the address of a secondary entry point in
; the code of `@`.  The code at _a_ fetches the cell pointed by
; the HL register, pushes it onto the stack and then continues
; at the address returned by `next`.
;
; See: `pushhl`.
;
; }doc

  dw fetch.hl

; ----------------------------------------------
  _colon_header jpnext_comma_,'jpnext,'

; doc{
;
; jpnext, ( -- ) "j-p-next-comma"
;
; Compile a Z80 jump to `next`.
;
; See: `jp,`.
;
; }doc

  _literal $E9DD ; Z80 opcode for "jp (ix)"
  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header jp_comma_,'jp,'

; doc{
;
; jp, ( a -- ) "j-p-comma"
;
; Compile the Z80 opcode to jump to _a_.
;
; Definition:

; ----
; : jp, ( a -- ) $C3 c, , ;
; ----

; See: `call,`.

; }doc

  _literal $C3 ; Z80 opcode for "jp"
  dw c_comma_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header call_comma_,'call,'

; doc{
;
; call, ( a -- ) "call-comma"
;
; Compile the Z80 opcode to call _a_.
;
; Definition:

; ----
; : call, ( a -- ) $CD c, , ;
; ----

; See: `jp,`.

; }doc

  _literal $CD ; Z80 opcode for "call"
  dw c_comma_,comma_
  dw exit_

  ; Name token of the latest word defined in `assembler-wordlist`:
latest_nt_in_assembler_word_list: equ call_comma_nt

endif

; ----------------------------------------------
; Start compiling in the `forth` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _colon_header dos_,'dos'

; doc{
;
; dos ( -- ca len )
;
; Return the name of the DOS in string _ca len_.
; It can be "+3DOS", "G+DOS" or "TR-DOS".
;
; See: `g+dos`, `tr-dos`, `+3dos`.
;
; }doc

  dw s_lit_
if gplusdos
  _string 'G+DOS'
endif
if trdos
  _string 'TR-DOS'
endif
if plus3dos
  _string '+3DOS'
endif
  dw exit_

; ----------------------------------------------
  _c_constant_header max_drives_,'max-drives'

; doc{
;
; max-drives ( -- b )
;
; A `cconstant`. _b_ is the maximum number of drives
; available in the DOS.
;
; See: `first-drive`, `drive`.
;
; }doc

  db max_drives

; ----------------------------------------------
  _c_constant_header first_drive_,'first-drive'

; doc{
;
; first-drive ( -- c )
;
; A `cconstant`. _c_ is the identifier of the first drive
; available in the DOS.
;
; See: `max-drives`, `drive`.
;
; }doc

  db first_drive

; ----------------------------------------------

; Note: Conditional `include` is not allowed in the Pasmo assembler.
; That's why all DOS files are included, and they check their own
; condition.

  include kernel.gplusdos.z80s
  include kernel.trdos.z80s
  include kernel.plus3dos.z80s

; ----------------------------------------------
  _variable_header far_banks_,'far-banks'

; doc{
;
; far-banks ( -- ca )
;
; _ca_ is the address of an array of four bytes. It holds the
; four memory banks used as a virtual 64-KiB continuous space,
; called "far memory". Every byte holds the bank number used for
; a 16-KiB range of addresses, as follows:

; ifndef::plus3dos[]

; // XXX REMARK -- G+DOS or TR-DOS

; |===
; | Offset | Address range   | Bank
;
; | +0     | $0000 .. $3FFF  | 1
; | +1     | $4000 .. $7999  | 3
; | +2     | $8000 .. $BFFF  | 4
; | +3     | $C000 .. $FFFF  | 6
; |===

; See: `bank`, `banks`, `bank-index`, `far`, `far@`, `farc@`,
; `far!`, `farc!`, `farcount`, `farplace`, `fartype`,
; `faruppers`, `farlimit`.
;
; endif::[]

; ifdef::plus3dos[]

; // XXX REMARK -- +3DOS

; |===
; | Offset | Address range   | Bank
;
; | +0     | $0000 .. $3FFF  | 1
; | +1     | $4000 .. $7999  | 3
; | +2     | $8000 .. $BFFF  | 4
; | +3     | $C000 .. $FFFF  | 6 (not used on +3DOS)
; |===

; WARNING: Bank 6 is used by +3DOS for disk cache and RAM disk,
; and the default value of `farlimit` is $C000 instead of $0000.
; Therefore, the name space is 16 KiB smaller on +3DOS than on
; G+DOS or TR-DOS.

; See: `bank`, `banks`, `bank-index`, `far`, `far@`, `farc@`,
; `far!`, `farc!`, `farcount`, `farplace`, `fartype`,
; `faruppers`, `default-1346`.
;
; endif::plus3dos[]
;
; }doc

  ; Credit:

  ; The "far" naming convention was borrowed from a post by Dr
  ; Jefyll in 6502.org (2010-02-16):
  ;
  ; http://forum.6502.org/viewtopic.php?f=9&t=1529&p=10079
  ;
  ; Also Garry Lancaster used the name "far memory" in his Z88
  ; CamelForth (2001):
  ;
  ; http://www.worldofspectrum.org/z88forever/camelforth/camel-pools.html

  db 1,3,4,6

; ----------------------------------------------
  _code_header question_next_bank_,'?next-bank'

; doc{
;
; ?next-bank ( a -- a|a' ) "question-next-bank"
;
; If the actual far-memory address _a_ ($C000 .. $FFFF) has
; increased to the next bank ($0000 .. $3FFF), convert it to the
; corresponding actual address _a'_ ($C000 .. $FFFF) in the next
; bank and page in the next bank. Otherwise return _a_.
;
; See: `?next-bank_`, `?previous-bank`.
;
; }doc

  pop hl
  call question_next_bank
  push hl
  _jp_next

question_next_bank:

  ; If the actual far-memory address ($C000 .. $FFFF) in the HL
  ; register has increased to the next bank ($0000 .. $3FFF),
  ; convert it to the corresponding actual address
  ; ($C000 .. $FFFF) in the next bank and page in the next bank,
  ; else do nothing.
  ;
  ; Input:
  ;   HL = address in a paged bank ($C000 .. $FFFF) or higher
  ;        ($0000 .. $3FFF).
  ; Output (when HL is above the paged bank):
  ;   HL = corresponding address in the next bank, which is paged in
  ;   A = corrupted
  ;   D = 0
  ;   E = bank
  ; Output (when HL is an address in a paged bank):
  ;   HL = preserved
  ;   A = corrupted
  ;
  ; Note: the address of this routine is returned by
  ; `?next-bank_`, a constant defined in the assembler
  ; word list in the <memory.far.fsb> module of the library, so
  ; `code` words can call it.

  ld a,h
  cp $C0 ; is HL below $C000?
  ret nc

  ; Update HL to the next bank of the far memory:
  ld a,(bank_index_dfa)
  inc a
  ld de,bank_start
  add hl,de

new_bank:

  ; Input:
  ;   A = updated bank index (possibly out of range 0 .. 3)
  ; Output:
  ;   A = corrupted
  ;   D = 0
  ;   E = bank

  push hl
  and %11 ; force range 0 .. 3
  ld (bank_index_dfa),a
  ld e,a
  ld hl,far_banks_dfa
  ld d,0
  add hl,de
  ld e,(hl) ; E = bank
  pop hl
  jp bank.e ; page in the bank E, then return

; ----------------------------------------------
  _code_header question_previous_bank_,'?previous-bank'

; doc{
;
; ?previous-bank ( a -- a|a' ) "question-previous-bank"
;
; If the actual far-memory address _a_ ($C000 .. $FFFF) has
; decreased to the previous bank ($8000 .. $BFFF), convert it to
; the corresponding actual address _a'_ ($C000 .. $FFFF) in the
; previous bank and page in the next bank. Otherwise return
; _a_.
;
; See: `?previous-bank_`, `?next-bank`.
;
; }doc

  pop hl
  call question_previous_bank
  push hl
  _jp_next

question_previous_bank:

  ; If the actual far-memory address ($C000 .. $FFFF) in the HL
  ; register has decreased to the previous bank ($8000 .. $BFFF),
  ; convert it to the corresponding actual address
  ; ($C000 .. $FFFF) in the previous bank and page in the next
  ; bank, else do nothing.
  ;
  ; Input:
  ;   HL = address in a paged bank ($C000 .. $FFFF) or lower
  ;        ($8000 .. $BFFF).
  ; Output (when HL is below the paged bank):
  ;   HL = corresponding address in the previous bank, which is paged in
  ;   A = corrupted
  ;   D = 0
  ;   E = bank
  ; Output (when HL is an address in a paged bank):
  ;   HL = preserved
  ;   A = corrupted
  ;
  ; Note: the address of this routine is returned by
  ; `?previous-bank_`, a constant defined in the assembler
  ; word list in the <memory.far.fsb> module of the library, so
  ; `code` words can call it.

  ld a,h
  cp $C0 ; is HL below $C000?
  ret nc

  ; Update HL to the previous bank of the far memory:
  ld a,(bank_index_dfa)
  dec a
  ld de,bank_size
  add hl,de

  jr new_bank

; ----------------------------------------------
  _variable_header bank_index_,'bank-index'

; doc{
;
; bank-index ( -- ca )
;
; A `cvariable`. _ca_ is the address of a byte containing
; the bank index (0 .. 3) calculated by the latest execution of
; `far`.
;
; See: `far-banks`, `bank`, `banks`.
;
; }doc

  db 0

; ----------------------------------------------
  _code_header far_,'far'

; doc{
;
; far ( a1 -- a2 )
;
; Convert a far-memory address _a1_ ($0000 .. $FFFF) to its actual
; equivalent _a2_ ($C000 .. $FFFF) and page in the corresponding
; memory bank, using the configuration at `far-banks`.
;
; ``far`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : far ( a1 -- a2 )
;   u>ud /bank um/mod  far-banks + c@ bank  bank-start + ;
; ----

; See: `far-hl_`, `bank`.
;
; }doc

  ; XXX WARNING -- The address of `far.hl` is stored in constant
  ; `far-hl_` (defined in <memory.fas.fs>), using the address of
  ; `far` to calculate the address of `call far.hl`:

  pop hl
  call far.hl
  push hl
  _jp_next

far.hl:

  ; Convert a far-memory address ($0000 .. $FFFF) to its actual
  ; equivalent ($C000 .. $FFFF) and page in the corresponding
  ; memory bank.
  ;
  ; Input: HL = far-memory address ($0000 .. $FFFF) Output: HL =
  ; actual memory address ($C000 .. $FFFF) A = corrupted DE =
  ; corrupted
  ;
  ; Note: the address of this routine is returned by `far-hl_`,
  ; a constant defined in the assembler word list in the
  ; <memory.far.fsb> module of the library, so `code` words can
  ; call it.

  ld e,h
  srl e
  srl e
  srl e
  srl e
  srl e
  srl e ; E = 0 .. 3 (bank index)
  ld a,e
  ld (bank_index_dfa),a ; save the bank index
  push hl
  ld hl,far_banks_dfa
  ld d,0
  add hl,de
  ld e,(hl) ; E = bank
  call bank.e

  pop hl ; HL = far-memory address ($0000 .. $FFFF)
  ld a,h
far.hl.mod:
  sub $40 ; substract $4000 (16 KiB)...
  jr nc,far.hl.mod ; ...as many times as needed
  ld h,a ; HL = actual memory address ($C000 .. $FFFF)
  ret

; ----------------------------------------------
  _code_header execute_,'execute'

; doc{
;
; execute ( i*x xt  -- j*x )
;
; Execute execution token _xt_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `perform`.
;
; }doc

  pop hl
  jp (hl)

; ----------------------------------------------
  _code_header perform_,'perform'

; doc{
;
; perform ( a  -- )
;
; If the cell stored at _a_ is zero, do nothing.  Otherwise
; execute it as an execution token.
;
; `perform` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : perform ( a  -- ) @ ?dup if execute then ;
; ----

; NOTE: ``perform`` is called ``@execute`` in other Forth systems.
;
; See: `execute`, `+perform`.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp nz,execute_hl

  ; Execution continues in `noop`:

; ----------------------------------------------
  _code_header noop_,'noop'

; doc{
;
; noop ( -- ) "no-op"
;
; Do nothing.
;
; See: `noop_`.
;
; }doc

jp_next:
call_ix: ; for clarity; used by +3DOS' `dos.ix` routine

  _jp_next

; ----------------------------------------------
  _constant_header noop_underscore,'noop_'

; doc{
;
; noop_ ( -- a ) "no-op-underscore"
;
; A `constant`. _a_ is the address of a routine that does nothing,
; except executing a Z80 ``ret`` to return.
;
; ``noop_`` is used as the default jump point of `circle-pixel`.
;
; See: `noop`.
;
; }doc

  dw noop

; XXX TODO -- `noop_` could be removed. `circle-pixel` could use
; use a custom address.

; ----------------------------------------------
if gplusdos
  _alias_header g_plus_dos_,'g+dos',immediate,noop_
endif

; doc{
;
; g+dos ( -- ) "g-plus-dos"
;
; An alias of `noop` that is defined only in the G+DOS version
; of Solo Forth.  Its goal is to check the DOS a program is
; running on, using `defined` or `[defined]`.
;
; ``g+dos`` is an `immediate` word.
;
; See: `dos`, `tr-dos`, `+3dos`.
;
; }doc

; ----------------------------------------------
if trdos
  _alias_header tr_dos_,'tr-dos',immediate,noop_
endif

; doc{
;
; tr-dos ( -- ) "t-r-dos"
;
; An alias of `noop` that is defined only in the TR-DOS version
; of Solo Forth.  Its goal is to check the DOS a program is
; running on, using `defined` or `[defined]`.
;
; ``tr-dos`` is an `immediate` word.
;
; See: `dos`, `g+dos`, `+3dos`.
;
; }doc

; ----------------------------------------------
if plus3dos
  _alias_header plus_3_dos_,'+3dos',immediate,noop_
endif

; doc{
;
; +3dos ( -- ) "plus-three-dos"
;
; An alias of `noop` that is defined only in the +3DOS version
; of Solo Forth.  Its goal is to check the DOS a program is
; running on, using `defined` or `[defined]`.
;
; ``+3dos`` is an `immediate` word.
;
; See: `dos`, `tr-dos`, `g+dos`.
;
; }doc

; ----------------------------------------------
  _defer_header init_asm_,'init-asm',,noop_

; doc{
;
; init-asm ( -- )
;
; A deferred word called by `asm`.  Its action is set by the
; assembler labels module in order to init the labels.  Its
; default action is `noop`.
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header asm_,'asm'

; doc{
;
; asm ( -- )
;
; Enter the `assembler` mode. ``asm`` is executed by `code` and
; `;code`.
;
; Definition:

; ----
; : asm ( -- )
;   !csp init-asm base @ abase ! hex assembler-wordlist >order ;
; ----

; See: `end-asm`, `init-asm`, `abase`, `!csp`, `hex`.
;
; }doc

  ; Credit:
  ; Idea taken from Coos Haak's Z80 Forth assembler.

  dw store_csp_
  dw init_asm_
if 1 ; abase
  dw base_,fetch_,abase_,store_ ; save the current base
else
  dw base_,fetch_ ; save the current base
endif
  dw hex_
  dw assembler_wordlist_,to_order_
  dw exit_

; ----------------------------------------------
  _colon_header also_,'also'

; doc{
;
; also ( -- )
;
; Duplicate the word list at the top of the search order.
;
; Definition:

; ----
; : also ( -- ) get-order over swap 1+ set-order ;
; ----

; Origin: Forth-83 (Experimental proposals), Forth-94 (SEARCH
; EXT), Forth-2012 (SEARCH-EXT).

; See: `previous`, `get-order`, `set-order`, `only`,
; `order`, `>order`.
;
; }doc

  dw get_order_,over_,swap_,one_plus_,set_order_
  dw exit_

  ; XXX TODO -- check the limit, see Gforth's `>order`

  ; XXX TODO -- `over swap` could be replaced with `nup`, which is in
  ; the library

  ; XXX TODO -- in Gforth `also` is simpler:
  ;     : also ( -- ) context @ >order ;
  ; because `>order` does the low-level work.

; ----------------------------------------------
  _colon_header only_,'only'

; doc{
;
; only ( -- )
;
; Set the search order to the minimum search order.
;
; Definition:

; ----
; : only ( -- ) -1 set-order ;
; ----

; Origin: Forth-94 (SEARCH EXT), Forth-2012 (SEARCH EXT).
;
; See: `also`, `set-order`, `previous`, `order`.
;
; }doc

  _literal -1
  dw set_order_
  dw exit_

; ----------------------------------------------
  _colon_header get_order_,'get-order'

; doc{
;
; get-order ( -- wid#n .. wid#1 n )
;
; Return the number of word lists _n_ in the search order and
; the word lists identifiers _wid#n .. wid#1_ identifying these
; word lists.  _wid#1_ identifies the word list that is
; searched first, and _wid#n_ the word list that is searched
; last.

; ----
; : get-order ( -- wid#n .. wid#1 n )
;   #order @ dup 0 ?do
;     dup i - 1- cells context + @ swap
;   loop ;
; ----

; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).

; See: `set-order`, `>order`, `context`, `#order`.
;
; }doc

  dw number_sign_order_,fetch_,dup_
  _literal 0
  dw paren_question_do_,get_order.exit
  dw dup_,i_,minus_,one_minus_,cells_
  dw context_,plus_,fetch_,swap_
  dw paren_loop_
get_order.exit:
  dw exit_

; ----------------------------------------------
  _constant_header max_order_,'max-order'

; doc{
;
; max-order ( -- n )
;
; A `constant`. _n_ is the maximum number of word lists in the
; search order.
;
; See: `context`, `#order`, `set-order`, `get-order`, `>order`.
;
; }doc

  dw max_search_order

; ----------------------------------------------
  _colon_header question_order_,'?order'

; doc{
;
; ?order ( n -- ) "question-order"
;
; If _n_ is not a valid size for the search order, `throw` an
; exception #-49 ("search-order overflow").
;
; Definition:

; ----
; : ?order ( n -- )
;   dup 0< #-50 ?throw  max-order < ?exit  #-49 throw ;
; ----

; See: `#order`, `set-order`, `>order`, `order`.
;
; }doc

  dw dup_,zero_less_than_
  _question_throw error.search_order_underflow
  dw max_order_,less_than_,question_exit_
  _throw error.search_order_overflow
  ; No return from `throw`, no need for `exit` here.

; ----------------------------------------------
  _colon_header set_order_,'set-order'

; doc{
;
; set-order ( -1 | 0 | wid#n .. wid#1 n -- )
;
; Set the search order to the word lists identified by _wid#n ..
; wid#1_. Subsequently, word list _wid1_ will be searched first,
; and word list _wid#n_ searched last. If _n_ is zero, empty the
; search order. If _n_ is minus one, set the search order to the
; implementation-defined minimum search order.
;
; Definition:

; ----
; : set-order ( -1 | 0 | wid#n .. wid#1 n -- )
;   dup -1 = if  drop root-wordlist dup 2  then
;   dup ?order  dup #order !
;   0 ?do  i cells context + !  loop ;
; ----

; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; See: `get-order`, `>order`.
;
; }doc

  ; XXX TODO -- Factor `root-wordlist dup 2` to `only-order`?
  ; Probably it will be changed to `forth-wordlist 1` anyway.

  dw dup_
  _literal -1
  dw equals_
  dw zero_branch_,set_order.do
  dw drop_,root_wordlist_,dup_
  _literal 2
set_order.do:
  dw dup_,question_order_
  dw dup_,number_sign_order_,store_
  _literal 0
  dw paren_question_do_,set_order.loop_exit
  dw context_,i_,cells_,plus_,store_
  dw paren_loop_
set_order.loop_exit:
  dw exit_

; ----------------------------------------------
  _colon_header to_order_,'>order'

; doc{
;
; >order ( wid -- ) "to-order"
;
; Push word list identifier _wid_ on the search order.
;
; Definition:

; ----
; : >order ( wid -- ) also context ! ;
; ----

; Origin: Gforth.
;
; See: `previous`, `also`, `set-order`,  `context`.
;
; }doc

  dw also_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header previous_,'previous'

; doc{
;
; previous ( -- )
;
; Remove the top word list (the word list that is searched
; first) from the search order.
;
; Definition:

; ----
; : previous ( -- ) get-order nip 1- set-order ;
; ----

; Origin: Forth-94 (SEARCH EXT), Forth-2012 (SEARCH EXT).
;
; See: `>order`, `get-order`, `set-order`.
;
; }doc

  dw get_order_,nip_,one_minus_,set_order_
  dw exit_

; XXX TODO -- from Gforth:
;
; : previous ( -- )
;   vp @ 1- dup 0= -50 ?throw vp ! ;

; : get-order
;  vp @ 0 ?do  vp cell+ i cells + @  loop  vp @ ;

; ----------------------------------------------
  _variable_header root_wordlist_,'root-wordlist'

; doc{
;
; root-wordlist ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; the words defined in the minimum search order. The words
; defined in the word list identified by ``root-wordlist`` are
; aliases of the definitions in `forth-wordlist`.
;
; See: `only`, `wordlist`, `set-order`,
; `assembler-wordlist`, `alias`.
;
; }doc

  dw latest_nt_in_root_word_list
  dw $0000
  dw root_nt

; ----------------------------------------------
  _does_header root_,'root',,do_vocabulary

; doc{
;
; root ( -- )
;
; Transform the search order consisting of _wid#n .. wid#2
; wid#1_ (where _wid#1_  is searched first)  into _wid#n ..
; wid#2 wid#r_, where _wid#r_ is the word-list identifier
; returned by `root-wordlist`.  I.e., replace the top word list
; of the search order with `root-wordlist`.
;
; ``root`` is the `vocabulary` corresponding to `root-wordlist`.
;
; See: `forth`, `wordlist`.
;
; }doc

  dw root_wordlist_dfa

; ----------------------------------------------
  _variable_header forth_wordlist_,'forth-wordlist'

; doc{
;
; forth-wordlist ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; all standard words provided by the implementation.
; ``forth-wordlist`` is initially the compilation word list and
; is part of the initial search order.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; See: `wordlist`, `set-order`, `root-wordlist`,
; `assembler-wordlist`.
;
; }doc

  dw latest_nt_in_forth_word_list
  dw root_wordlist_dfa
  dw forth_nt

; ----------------------------------------------
  _does_header forth_,'forth',,do_vocabulary

; doc{
;
; forth ( -- )
;
; Transform the search  order consisting of  _wid#n .. wid#2
; wid#1_ (where _wid#1_  is searched first)  into _wid#n ..
; wid#2 wid#f_, where _wid#f_ is the word-list identifier
; returned by `forth-wordlist`.  I.e., replace the top word list
; of the search order with `forth-wordlist`.
;
; ``forth`` is the `vocabulary` corresponding to
; `forth-wordlist`.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (SEARCH EXT),
; Forth-2012 (SEARCH EXT).
;
; See: `root`, `wordlist`.
;
; }doc

  dw forth_wordlist_dfa

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _variable_header assembler_wordlist_,'assembler-wordlist'

; doc{
;
; assembler-wordlist ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; the words defined as part of the `assembler`
; (see the main ones in section <<_z80_instructions>>).
;
; See: `wordlist`, `set-order`, `forth-wordlist`,
; `root-wordlist`.
;
; }doc

  dw latest_nt_in_assembler_word_list
  dw forth_wordlist_dfa
  dw 0

endif

; ----------------------------------------------
  _colon_header s_lit_,'slit'

; doc{
;
; slit ( -- ca len ) "s-lit"
;
; Return a string that is compiled after the calling word, and
; adjust the instruction pointer to step over the inline string.
;
; Definition:

; ----
; : slit ( -- ca len ) r@ count dup char+ r> + >r ;
; ----

; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,char_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw exit_

; ----------------------------------------------
  _colon_header parse_string_,'parse-string'

; doc{
;
; parse-string
;   Compilation:    ( c "ccc<char>" -- )
;   Interpretation: ( c "ccc<char>" -- ca len )
;   Run-time:       ( -- ca len )

; Parse _ccc_ delimited by character _c_.  If interpreting, copy
; the parsed string to the `stringer` and return it as _ca len_.
; If compiling, compile the parsed string and return it at
; run-time as _ca len_.
;
; WARNING: ``parse-string`` is a state-smart word (see `state`).
;
; Definition:

; ----
; : parse-string \ Compilation:    ( c "ccc<char>" -- )
;                \ Interpretation: ( c "ccc<char>" -- ca len )
;                \ Run-time:       ( -- ca len )
;   parse compiling? if postpone sliteral exit then >stringer ;
; ----

; See: `parse-name`, `compiling?`, `sliteral`, `>stringer`,
; `parse-char`, `parse`.
;
; }doc

  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,parse_string.interpreting
  ; compiling
  dw s_literal_
  dw exit_
parse_string.interpreting:
  dw to_stringer_
  dw exit_

; ----------------------------------------------
  _code_header c_lit_,'clit',compile_only

; doc{
;
; clit ( -- b ) "c-lit"
;
; Return _b_, which was compiled by `cliteral` after ``clit``.
;
; ``clit`` is a `compile-only` word.
;
; See: `lit`, `2lit`.
;
; }doc

  ld a,(bc)
  inc bc
push_a:
  ld l,a
  ld h,0
  push hl
  _jp_next

; ----------------------------------------------
  _code_header two_lit_,'2lit',compile_only

; doc{
;
; 2lit ( -- x1 x2 ) "two-lit"
;
; Return _x1 x2_, which was compiled by `2literal` after
; ``2lit``.
;
; ``2lit`` is a `compile-only` word.
;
; See: `lit`, `clit`.
;
; }doc

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a ; HL = high part
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a ; DE = low part
  inc bc
push_hlde:
  push de
push_hl:
  push hl
  _jp_next

  ; XXX WARNING -- In the library the `pushhlde` constant gets
  ; its value from `pushhl`, which depends on the `push_hl`
  ; label above. Therefore, the offset between both labels must
  ; be preserved here.

; ----------------------------------------------
  _code_header lit_,'lit',compile_only

; doc{
;
; lit ( -- x )
;
; Return _x_, which was compiled by `literal` after ``lit``.
;
; ``lit`` is a `compile-only` word.
;
; See: `clit`, `2lit`.
;
; }doc

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  push hl
  _jp_next

; ----------------------------------------------
  _constant_header default_bank_number_sign_,'default-bank#'

; doc{
;
; default-bank# ( -- ca ) "default-bank-number-sign"
;
; A `constant`. _ca_ is the address of a byte containing the value
; of the default `bank` paged in at $C000 .. $FFFF.  Its default
; value is zero.
;
; See: `banks`, `far-banks`.
;
; }doc

  ; XXX TMP --

  dw address_of_default_bank

; ----------------------------------------------
  _code_header bank_,'bank'

  ; XXX TODO -- Move to the library, using `e-bank_`.

; doc{
;
; bank ( +n -- )
;
; Page in the 16-KiB memory bank _+n_ at $C000 .. $FFFF.
;
; The range of _+n_ depends on the computer:

; |===
; | Computer          | Memory banks
;
; | ZX Spectrum 128  >| 0 .. 7
; | ZX Spectrum +2   >| 0 .. 7
; | ZX Spectrum +3   >| 0 .. 7
; | ZX Spectrum +3e  >| 0 .. 7
; | Pentagon 128     >| 0 .. 7
; | Scorpion ZS 256  >| 0 .. 15
; | Pentagon 512     >| 0 .. 31
; | Pentagon 1024    >| 0 .. 63
; |===

; See: `default-bank`, `banks`, `far-banks`.
;
; }doc

  pop de ; E = bank
  call bank.e
  _jp_next

; ----------------------------------------------
  _code_header unused_stringer_,'unused-stringer'

; doc{
;
; unused-stringer ( -- n )
;
; Return the number _n_ of free characters in the `stringer`.
;
; ``unused-stringer`` is written in Z80. Its equivalent
; definition if Forth is the following:

; ----
; : unused-stringer ( -- n ) +stringer @ ;
; ----

; See: `+stringer`.
;
; }doc

  ld hl,(plus_stringer_dfa)
  push hl
  _jp_next

; ----------------------------------------------
  _constant_header slash_stringer_,'/stringer'

; doc{
;
; /stringer ( -- len ) "slash-stringer"
;
; A `constant`. _len_ is the maximum size of the `stringer`, in
; characters. See how to configure it in the documentation of
; `stringer`.
;
; See: `+stringer`, `empty-stringer`, `default-stringer'.
;
; }doc

  dw stringer_size

; ----------------------------------------------
  _variable_header plus_stringer_,'+stringer'

; doc{
;
; +stringer ( -- a ) "plus-stringer"
;
; A `variable`. _a_ is the address of a cell containing the
; pointer of the `stringer`, i.e. an offset to its first free
; address. The offset equals the number of free characters in
; the `stringer`.
;
; See: `empty-stringer`.
;
; }doc

  dw stringer_size

; ----------------------------------------------
  _constant_header stringer_,'stringer'

; doc{
;
; stringer ( -- a )
;
; A `constant`. _a_ is the base address of the ``stringer``, which
; is the circular string buffer used by all string operations.
;
; A program can move and resize the ``stringer`` if needed.
; Example:

; ----
; stringer /stringer 2constant old-stringer
;   \ Keep the address and length of the old stringer, in order
;   \ to reuse its space later.
;
; need !>
;
; here 1024 dup allot !> /stringer !> stringer empty-stringer
;   \ Create a new, 1024-byte ``stringer`` in data space.
; ----

; The default ``stringer`` can be restored by
; `default-stringer`.
;
; See: `!>`, `/stringer`, `empty-stringer`, `+stringer`,
; `unused-stringer`, `fit-stringer`, `allocate-stringer`,
; `>stringer`.
;
; }doc

  dw stringer

; ----------------------------------------------
  _colon_header fit_stringer_,'fit-stringer'

; doc{
;
; fit-stringer ( len -- )
;
; Make sure there's room in the `stringer` for _len_ characters.
;
; Definition:

; ----
; : fit-stringer ( len -- )
;   dup unused-stringer > if empty-stringer then
;       negate +stringer +! ;
; ----

; See: `unused-stringer`, `empty-stringer`, `+stringer`.
;
; }doc

  dw dup_,unused_stringer_,greater_than_
  dw zero_branch_,fit_stringer_.allocate
  dw empty_stringer_

fit_stringer_.allocate:
  dw negate_,plus_stringer_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header allocate_stringer_,'allocate-stringer'

; doc{
;
; allocate-stringer ( len -- ca )

; Allocate _len_ characters in the `stringer` and return the
; address _ca_ of the allocated space. If _len_ is greater than
; `unused-stringer`, `empty-stringer` is executed, no check is
; done whether _len_ is greater than `/stringer` (the maximum
; capacity of the buffer).
;
; Definition:

; ----
; : allocate-stringer ( len -- ca )
;   fit-stringer stringer unused-stringer + ;
; ----

; See: `>stringer`.
;
; }doc

  dw fit_stringer_
  dw stringer_,unused_stringer_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header to_stringer_,'>stringer'

; doc{
;
; >stringer ( ca1 len1 -- ca2 len1 ) "to-stringer"

; Copy string _ca1 len1_ to the `stringer` and return it as _ca2
; len1_.
;
; Definition:

; ----
; : >stringer ( ca1 len1 -- ca2 len1 )
;   dup allocate-stringer swap 2dup 2>r move 2r> ;
; ----

; See: `allocate-stringer`, `far>stringer`.
;
; }doc

  dw dup_,allocate_stringer_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw exit_

; ----------------------------------------------
  _code_header default_stringer_,'default-stringer'

; doc{
;
; default-stringer  ( -- )
;
; Set the default values of `stringer` and `/stringer`.
; ``default-stringer`` is executed by `cold`.
;
; }doc

  ld hl,stringer
  ld (stringer_dfa),hl
  ld hl,stringer_size
  ld (slash_stringer_dfa),hl

  ; Execution continues in `empty-stringer`:

; ----------------------------------------------
  _colon_header empty_stringer_,'empty-stringer'

; doc{
;
; empty-stringer ( -- )
;
; Empty the `stringer`, by initializing `+stringer` with
; `/stringer`.  The contents of the `stringer` are not modified.
;
; Definition:

; ----
; : empty-stringer ( -- ) /stringer +stringer ! ;
; ----

; See: `default-stringer`.
;
; }doc

  dw slash_stringer_,plus_stringer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header forward_mark_,'>mark'

; doc{
;
; >mark ( C: -- orig ) "forward-mark"
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; Definition:

; ----
; : >mark ( C: -- orig ) here 0 , ;
; ----

; Origin: Forth-83 (System Extension Word Set).
;
; See: `<mark`.
;
; }doc

  dw here_
  _literal 0
  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header forward_resolve_,'>resolve'

; doc{
;
; >resolve ( C: orig -- ) "forward-resolve"
;
; Resolve a forward branch by placing the address of the current
; data-space pointer into the space compiled by `>mark`.
;
; Definition:

; ----
; : >resolve ( C: orig -- ) here swap ! ;
; ----

; Origin: Forth-83 (System Extension Word Set).
;
; See: `here`, `<resolve`.
;
; }doc

  dw here_,swap_,store_
  dw exit_

; ----------------------------------------------
  _colon_header here_,'here'

; doc{
;
; here ( -- a )
;
; _a_ is the data-space pointer.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `dp`, `limit`, `unused`, `there`.
;
; }doc

  dw dp_,fetch_
  dw exit_

; ----------------------------------------------
  _alias_header backward_mark_,'<mark',,here_

; doc{
;
; <mark ( C: -- dest ) "backward-mark"
;
; _dest_ is the current data-space pointer, to be used as the
; destination of a backward branch.  _dest_ is typically only
; used by `<resolve` to compile a branch address.
;
; ``<mark`` is an `alias` of `here`.
;
; Origin: Forth-83 (System Extension Word Set).
;
; See: `>mark`, `begin`.
;
; }doc

; ----------------------------------------------
  _colon_header comma_,','

; doc{
;
; , ( x -- ) "comma"
;
; Reserve one cell of data space and store _x_ in the cell.
;
; Definition:

; ----
; : , ( x -- ) here ! cell allot ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `2,`, `c,`, `here`, `!`, `cell`, `allot`.
;
; }doc

  dw here_,store_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _alias_header compile_comma_,'compile,',,comma_

; doc{
;
; compile, ( xt -- ) "compile-comma"
;
; Append the execution semantics of the definition represented
; by _xt_ to the execution semantics of the current definition.
;
; ``compile,`` is the compilation equivalent of `execute`.
;
; Since Solo Forth is a threaded-code implementation,
; ``compile,`` is an `alias` of `,`.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

; ----------------------------------------------
  _alias_header backward_resolve_,'<resolve',,comma_

; doc{
;
; <resolve ( C: dest -- ) "backward-resolve"
;
; Resolve a backward branch.  Compile a branch address using
; _dest_, the address left by `<mark`,  as the destination
; address.  Used at the source of a backward branch after either
; `branch` or `?branch` or `0branch`.
;
; ``<resolve`` is an `alias` of `,`.
;
; Origin: Forth-83 (System Extension Word Set).
;
; }doc

; ----------------------------------------------
  _code_header zero_branch_,'0branch'

; doc{
;
; 0branch ( f -- ) "zero-branch"
;
; A run-time procedure to branch conditionally. If  _f_
; is false (zero), the following in-line address is copied to IP
; to branch forward or backward.
;
; Origin: fig-Forth.
;
; See: `branch`, `?branch`, `-branch`, `+branch`.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_ ; branch if zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?branch'

; doc{
;
; ?branch ( f -- ) "question-branch"
;
; A run-time procedure to branch conditionally. If  _f_ is not
; not zero, the following in-line address is copied to IP to
; branch forward or backward.
;
; NOTE: This ``?branch`` is not Forth-83's ``?branch``, which is
; equivalent to fig-Forth's ``0branch``, which is a more logical
; name for the "branch if zero" action. Solo Forth borrows
; `0branch` from fig-Forth, and completes the branches after a
; logical naming convention shared with optional control flow
; words, e.g. `?exit`, `0exit`, `-exit`...
;
; See: `branch`, `-branch`, `+branch`.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_ ; branch if not zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header unloop_,'unloop'

; doc{
;
; unloop ( -- ) ( R: loop-sys -- )
;
; Discard the `loop` control parameters _loop-sys_ for the
; current nesting level. An `unloop` is required for each
; nesting level before the definition may be exited with `exit`.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `leave`, `do`, `?do`, `+loop`.
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*3
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header paren_question_do_,'(?do'

; doc{
;
; (?do ( n1|u1 n2|u2 -- ) ( R: -- loop-sys | ) "paren-question-do"
;
; If _n1|u1_ is equal to _n2|u2_, continue execution at the
; location given by the consumer of the _do-sys_ left by `?do`
; at compilation time.  Otherwise set up loop control parameters
; _loop-sys_ with index _n2|u2_ and limit _n1|u1_ and continue
; executing immediately following `?do`.  Anything  already on
; the  return stack becomes unavailable until the loop control
; parameters _loop_sys_ are discarded.
;
; ``(?do`` is compiled by `?do`.
;
; See: `(do`, `(-do`.
;
; }doc

  ; Credit:
  ; Code based on Spectrum Forth-83.

  pop hl       ; HL = init
  pop de       ; DE = limit
  and a
  sbc hl,de    ; init=limit?
  jp z,branch_ ; if so, skip the loop
  add hl,de    ; reverse the substraction
  jp paren_do.de_hl

; ----------------------------------------------
  _colon_header question_do_,'?do',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; ?do "question-do"
;   Compilation: ( -- do-sys )
;

; Compile `(?do` and leave _do-sys_ to be consumed by `loop` or
; `+loop`.
;
; ``?do`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : ?do ( -- do-sys )
;   postpone (?do >mark ; immediate compile-only
; ----

; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `do`, `-do`, `times`, `executions`.
;
; }doc

  dw compile_,paren_question_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header loop_,'loop',immediate+compile_only

; doc{
;
; loop
;   Compilation: ( do-sys -- )
;

; Compile `(loop` and resolve the _do-sys_ address left by
; `do`, or `?do`.
;
; ``loop`` is an `immediate` and `compile-only` word.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `+loop`, `-do`.
;
; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  dw compile_,paren_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------

if 0 ; developing

_colon_header plus_loop_,'+loop',immediate+compile_only

; XXX REMARK -- This word is in the library. This copy is
; preserved to be activated for debugging.

; +loop "plus-loop"
;   Compilation: ( do-sys -- )
;

; Compilation: Compile `(+loop` and resolve the _do-sys_
; address left by `do`, `?do` or `-do`.
;
; ``+loop`` is an `immediate` and `compile-only` word.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `loop`.

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  dw compile_,paren_plus_loop_
  dw forward_resolve_
  dw exit_

endif

; ----------------------------------------------
  _code_header paren_do_,'(do'

; doc{
;
; (do ( n1|u1 n2|u2 -- ) ( R: -- loop-sys ) "paren-do"
;
; Set up loop control parameters _loop-sys_ with index _n2|u2_
; and limit _n1|u1_ and continue executing immediately following
; `do`.  Anything  already on the  return stack becomes
; unavailable until the loop control parameters _loop_sys_ are
; discarded.
;
; ``(do`` is compiled by `do`.
;
; See: `(?do`, `(-do`.
;
; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  pop hl                        ; init
  pop de                        ; limit
paren_do.de_hl:
  push hl
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push limit on return stack
  inc bc
  inc bc                        ; skip branch address
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c                     ; push IP on return stack
  ex (sp),hl                    ; HL=init, (SP)=rp@
  and a
  sbc hl,de                     ; HL=init-limit
  ld a,h
  xor $80                       ; flip most significant bit
  ld d,a
  ld e,l
  pop hl                        ; HL=rp@
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push (init-limit) xor $8000 on return stack
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header i_,'i'

; doc{
;
; i ( -- n|u ) ( R: do-sys -- do-sys )
;
; Return a copy _n|u_ of the current (innermost) `loop` index.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `i'`, `j`, `k`.
;
; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
i.hl: ; entry point for `j` and `k`: cfa of `i` plus 3
  ld e,(hl)
  inc hl
  ld d,(hl) ; DE= current index, wich is: (index-limit) xor $8000
  inc hl
  inc hl
  inc hl
  ld a,(hl)
  add a,e   ; read limit and add to index
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  xor $80  ; flip most significant bit, getting true index value
  ld d,a
  push de ; result
  _jp_next

; ----------------------------------------------
  _code_header leave_,'leave'

; doc{
;
; leave ( -- ) ( R: loop-sys -- )
;
; Discard the `loop` control parameters for the current nesting
; level.  Continue execution immediately following the innermost
; syntactically enclosing `loop` or `+loop`.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `?leave`, `0leave`, `unloop`, `do`, `?do`, `+loop`.
;
; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; BC = start address
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl ; write updated return stack pointer (6 was added)
  dec bc
  dec bc ; point IP to forward branch address

  ; Execution continues in `branch`:

; ----------------------------------------------
  _code_header branch_,'branch'

; doc{
;
; branch ( -- )
;
; The run-time procedure to branch unconditionally. The
; following in-line address is copied to IP to branch forward or
; backward.
;
; Origin: Forth-83 (System Extension Word Set).
;
; See: `?branch`, `0branch`, `-branch`, `+branch`.
;
; }doc

  ld h,b
  ld l,c ; HL = Forth IP, containing the address to jump to
  ld c,(hl)
  inc hl
  ld b,(hl) ; BC = New Forth IP
  _jp_next

; ----------------------------------------------
_code_header paren_plus_loop_,'(+loop'

; doc{
;
; (+loop ( n -- ) ( R: loop-sys1 -- loop-sys2 ) "paren-plus-loop"
;
; Add _n_ to the loop index. If the loop index did not cross the
; boundary between the loop limit minus one and the loop limit,
; continue execution at the beginning of the loop. Otherwise,
; discard the loop parameters and continue execution immediately
; following the loop.
;
; ``(+loop`` is compiled by `+loop`.
;
; See: `(loop`.
;
; }doc

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; DE = current index
  ex (sp),hl  ; HL = the increment value

  and a
  adc hl,de   ; add increment to index
  ; Note: `and a` and `adc` are used because `add` does not affect the po flag
  jp po,paren_plus_loop.continue

  ; If overflow, then boundary between limit-1 and limit is
  ; crossed, terminate loop.

  pop hl ; return stack pointer
  ld de,$0005
  add hl,de
  ld (return_stack_pointer),hl
  ; Increment return stack pointer by 5 (1 increment already done)
  _jp_next

paren_plus_loop.continue:
  ld d,h
  ld e,l ; DE = updated index
  pop hl ; return stack pointer

paren_loop.continue:

  ld (hl),d
  dec hl
  ld (hl),e  ; update the index on the return stack
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; IP = start address, repeat loop
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(loop'

; doc{
;
; (loop ( R: loop-sys1 -- loop-sys2 ) "paren-loop"
;
; Increment the loop index by one.  If the loop index did not
; cross the boundary between the loop limit minus one and the
; loop limit, continue execution at the beginning of the loop.
; Otherwise, discard the loop parameters and continue execution
; immediately following the loop.
;
; ``(loop`` is compiled by `loop`.
;
; See: `(+loop`.
;
; }doc

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; DE = index value
  inc de      ; increment the index
  ld a,d
  xor $80
  or e        ; index=$8000?
  jp nz,paren_loop.continue

  ; limit reached
  ld de,$0005
  add hl,de ; increment RP by 5 (1 already done)
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header digit_question_,'digit?'

; doc{
;
; digit? ( c n -- u true | false ) "digit-question"
;
; Convert the ascii character _c_ (using base _n_) to its binary
; equivalent _u_, accompanied by a true flag. If the conversion
; is invalid, leave only a false flag.
;
; Origin: fig-Forth's ``digit``.
;
; }doc

; XXX Note: alternative implementation in CamelForth:
;
;   \ silly looking but it works!
;   DUP $39 > $100 AND +
;   DUP $140 > $107 AND - $30 -
;   DUP BASE @ U< ;

  pop hl  ; L=base
  pop de  ; E=character
  ld a,e  ; character
  call ascii_lower.a
  sub '0' ; >="0"?
  jp c,false_ ; <"0" is invalid
  cp $0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub "a"-"9"-1 ; gap between "9" & "a", now "a"=$0A
  cp $0A ; >="a"?
  jp c,false_ ; characters between "9" & "a" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_ ; no, invalid
  ld e,a ; converted digit
  push de
  jp true_

; ----------------------------------------------
  _colon_header number_base_,'number-base'

; doc{
;
; number-base ( ca len -- ca' len' n )
;
; If the first character of string _ca len_ is a radix prefix,
; return its value _n_ and the updated string _ca' len'_ (which
; does not include the radix prefix).  Otherwise return _ca
; len_ untouched and the current value of `base` _n_.
;
; Definition:

; ----
; : number-base ( ca len -- ca' len' n )
;   dup if
;    over c@
;    dup '$' = if  drop 1 /string #16  exit  then
;    dup '%' = if  drop 1 /string  #2  exit  then
;        '#' = if       1 /string #10  exit  then
;   then
;   base @ ;
; ----

; }doc

number_base.try_hex:
  dw dup_
  dw zero_branch_,number_base.current
  dw over_,c_fetch_
  dw dup_
  _literal '$'
  dw equals_,zero_branch_,number_base.try_binary
  dw drop_
  dw one_slash_string_
  _literal 16
  dw exit_
number_base.try_binary:
  dw dup_
  _literal '%'
  dw equals_,zero_branch_,number_base.try_decimal
  dw drop_
  dw one_slash_string_
  _literal 2
  dw exit_
number_base.try_decimal:
  _literal '#'
  dw equals_,zero_branch_,number_base.current
  dw one_slash_string_
  _literal 10
  dw exit_
number_base.current:
  dw base_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header to_number_,'>number'

; doc{
;
; >number ( ud1 ca1 len1 -- ud2 ca2 len2 ) "to-number"

; _ud2_ is the unsigned result of converting the characters
; within the string specified by _ca1 len1_ into digits, using
; the number in `base`, and adding each into _ud1_ after
; multiplying _ud1_ by the number in `base`. Conversion
; continues left-to-right until a character that is not
; convertible, including any "+" or "-", is encountered or the
; string is entirely converted. _ca2_ is the location of the
; first unconverted character or the first character past the
; end of the string if the string was entirely converted. _len2_
; is the number of unconverted characters in the string.

;
; Definition:

; ----
; : >number ( d1 ca1 len1 -- d2 ca2 len2 )
;   begin  dup  while
;     over c@ base @ digit? while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string
;   repeat then ;
; ----

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `number?`, `number`.
;
; }doc

; XXX TODO -- check:
; An ambiguous condition exists if _ud2_ overflows during the
; conversion.

  ; Credit:
  ; Code from DZX-Forth.

to_number.begin: ; begin
  dw dup_
  dw zero_branch_,to_number.end  ; while
; _chk '>number -- before digit' ; XXX INFORMER
  dw over_,c_fetch_,base_,fetch_,digit_question_
; _chk '>number -- after digit' ; XXX INFORMER
  dw zero_branch_,to_number.end  ; while
  dw to_r_,two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw u_m_star_,drop_
  dw rot_
  dw base_,fetch_
  dw u_m_star_
  dw d_plus_
  dw two_swap_
  dw one_slash_string_
  ; dw one_,dpl_,plus_store_ ; XXX TODO why this?
  dw branch_,to_number.begin  ; repeat
to_number.end:
  ; then
  dw exit_

; ----------------------------------------------
  _defer_header number_point_question_,'number-point?',,standard_number_point_question_

; doc{
;
; number-point? ( c -- f ) "number-point-question"
;
; _f_ is true if character _c_ is a valid point in a number.
; ``number-point?`` is a deferred word used in `number?`. Its
; default action is `standard-number-point?`, which only allows
; the period.
;
; See: `classic-number-point?`, `extended-number-point?`,
; `dpl`, `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header standard_number_point_question_,'standard-number-point?'

; doc{
;
; standard-number-point? ( c -- f ) "standard-number-point-question"
;
; _f_ is true if if character _c_ is a valid point in a number.
; The only allowed point is period.
;
; ``standard-number-point?`` is the default action of the
; deferred word `number-point?`, which is used in `number?`.

; Definition:

; ----
; : standard-number-point? ( c -- f ) '.' = ;
; ----

; See: `classic-number-point?`, `extended-number-point?`,
; `defer`.
;
; }doc

  _literal '.'
  dw equals_
  dw exit_

; ----------------------------------------------
  _colon_header number_question_,'number?'

; doc{
;
; number? ( ca len -- 0 | n 1 | d 2 ) "number-question"
;
; Convert a string _ca len_ to a number, using the current value
; of `base`.. Return 0 if the conversion is not possible. If the
; result is a single number, return _n_ and 1. If the result is
; a double number, return _d_ and 2.
;
; ``number?`` accepts valid point anywhere on the number and
; updates `dpl` with the position of the last one. If no point
; is found, `dpl` contains -1.
;
; Characters between single quotes are recognized, after
; Forth-2012.
;
; Definition:

; ----
; : number? ( ca len -- 0 | n 1 | d 2 )
;
;   dup 0= if  2drop 0 exit  then  \ reject empty strings
;
;   2dup char? if  nip nip 1 exit  then  \ character format
;
;   over c@ number-point?  \ first character is a point?
;   if  2drop 0 exit  then  \ is so, reject the string
;
;   base @ >r  number-base base ! ( R: radix )
;   skip-sign? >r                 ( R: radix sign )
;   0 0 2swap  dpl on
;
;   begin ( d ca len ) >number dup  while
;
;     over c@ number-point? 0=   \ invalid point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup dpl @ =   \ previous character was a point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup 1- dpl !  \ update the position of the last point
;     1 /string     \ skip the point
;
;   repeat
;
;   2drop                     \ discard the empty string
;   dpl @ 0<                  \ single-cell number?
;   if    d>s r> ?negate  1   \ single-cell number
;   else  r> ?dnegate  2      \ double-cell number
;   then  r> base ! ;         \ restore the radix
; ----

; See: `>number`, `number-point?`, `skip-sign?`, `dpl`,
; `number`.
;
; }doc

  ; XXX TODO make it a deferred word

  dw dup_,zero_equals_ ; empty string?
  dw zero_branch_,number_question.try_char
  ; reject an empty string
number_question.reject:
  dw two_drop_,false_
  dw exit_

number_question.try_char:
  dw two_dup_,char_question_ ; a character?
  dw zero_branch_,number_question.try_initial_point
  ; return the character code
  dw nip_,nip_
  _literal 1
  dw exit_

number_question.try_initial_point:
  dw over_,c_fetch_ ; first char...
  dw number_point_question_ ; ...is point?
  dw question_branch_,number_question.reject ; is so, reject the string

  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  dw two_lit_,0,0 ; initial value
  dw two_swap_,dpl_,on_

number_question.begin:
  dw to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question.done ; while

  ; The conversion was not completed, so it may be because of a
  ; point that indicates it's a double number.

  dw over_,c_fetch_ ; get the non-digit character
  dw number_point_question_ ; is it valid point?
  dw question_branch_,number_question.point

number_question.invalid_character:
  dw two_drop_,two_drop_,r_drop_,false_
  dw branch_,number_question.end

number_question.point:
  dw dup_,dpl_,fetch_,equals_ ; was the previous character a point?
  dw question_branch_,number_question.invalid_character ; if so, invalid

number_question.valid_point:
  dw dup_,one_minus_,dpl_,store_ ; update the position of the last point
  dw one_slash_string_ ; skip the point

  dw branch_,number_question.begin ; repeat

number_question.done:
  dw two_drop_ ; discard the empty string
  dw dpl_,fetch_,zero_less_than_ ; single-cell number?
  dw zero_branch_,number_question.double

  ; single-cell number
  dw d_to_s_,from_r_,question_negate_
  _literal 1
  dw branch_,number_question.end

number_question.double:
  ; double-cell number
  dw from_r_,question_d_negate_
  _literal 2

number_question.end:
  dw from_r_,base_,store_  ; restore `base`

  dw exit_

; ----------------------------------------------
  _colon_header char_question_,'char?'

; doc{
;
; char? ( ca len -- c true | false ) "char-question"
;
; If the string _ca len_ is the representation of a character,
; return the character _c_ and `true`; else return `false`.
;
; Definition:

; ----
; : char? ( ca len -- c true | false )
;   3 = if
;     dup c@ ''' <> if
;       dup [ 2 chars ] cliteral + c@ ''' <>
;       if char+ c@ true exit then
;     then
;   then
;   drop false ;
; ----

; }doc

  _literal 3
  dw equals_
  dw zero_branch_,char_question.not

char_question.right_length:
  dw dup_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.first_quote:
  dw dup_,two_plus_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.match:
  dw char_plus_,c_fetch_,true_,exit_

char_question.not:
  dw drop_,false_,exit_
  dw exit_

; ----------------------------------------------
  _colon_header skip_sign_question_,'skip-sign?'

; doc{
;
; skip-sign? ( ca len -- ca' len' f ) "skip-sign-question"
;
; If number string _ca len_ starts with a minus sign, remove it
; and return the result string _ca' len'_ and a true flag _f_;
; else _ca' len'_ is identical to _ca len_ and _f_ is false.
;
; Definition:

; ----
; : skip-sign? ( ca len -- ca' len' f )
;   over c@ '-' = dup >r abs /string r> ;
; ----

; See: `number?`, `?negate`.
;
; }doc

  ; Credit:
  ; Code adapted from CamelForth.

  dw over_,c_fetch_
  _literal '-'
  dw equals_,dup_,to_r_,abs_
  dw slash_string_,from_r_
  dw exit_

; ----------------------------------------------
  _code_header find_name_from_,'find-name-from'

; doc{
;
; find-name-from ( ca len nt1 -- nt2 | 0 )
;
; Find the definition named in the string _ca len_, starting at
; _nt1_. If the definition is found, return its _nt2_, else
; return zero.
;
; String _ca len_ must be below memory address $C000.
;
; See: `find-name`, `find-name-in`, `find`.
;
; }doc

  ; Patch the code with the routine proper to the
  ; case-sensitive mode:

  ld hl,(case_sensitive_dfa) ; contents of the `case-sensitive` variable
  ld a,h
  or l ; case-sensitive mode?
  ld hl,ascii_lower.a ; routine used when case-sensitive mode is off
  jr z,find_name_from.set_case_sensitivity ; jump if case-sensitive mode is off
  ld hl,noop ; routine used when case-sensitive mode is on
find_name_from.set_case_sensitivity:
  ld (find_name_from.change_case_routine),hl ; patch the call

  ; Get the parameters and patch the code with the string:

  ld (find_name_from.ip),bc ; save the Forth IP
  pop hl ; nt
  pop bc ; len (B must be 0)
  ld (find_name_from.string_length.16_bits),bc
  ld a,c
  ld (find_name_from.string_length.8_bits),a
  pop de ; ca
  ld (find_name_from.string_address),de

find_name_from.begin:

  ; Compare the string with a word pointed by its nt.
  ; HL = nt of the word to compare with
  ;      (or zero if the end of the word list has been reached)
  ld (find_name_from.result),hl
  ld a,h
  or l ; end of word list? (nt=0)
  jr z,find_name_from.end
  call far.hl
  ; HL = actual address of the nt in the far memory, which is
  ;      paged in

  ld a,(hl) ; length byte of the name field
  and valid_word_length_mask  ; mask the length and the smudge bit
find_name_from.string_length.8_bits: equ $+1
  cp $00 ; length of the string
  jr z,find_name_from.compare_characters
  ; Lengths differ.

find_name_from.not_a_match:
  ; Not a match, try the next word.
  ld hl,(find_name_from.result) ; HL = nt
  dec hl ; point to high byte of the link field
  call far.hl
  ; HL = actual address of the high byte of the link
  ; field in the far memory, which is paged in
  ld b,(hl) ; high part of the next nt
  dec hl ; point to link field address
  call question_previous_bank
  ld l,(hl) ; low part of the next nt
  ld h,b ; HL = nt of the previous word
  jp find_name_from.begin ; continue

find_name_from.compare_characters:
  ; Lengths match, compare the characters.
  inc hl ; point to the first character of the name
  call question_next_bank
find_name_from.string_address: equ $+1
  ld de,$0000 ; string address
find_name_from.string_length.16_bits: equ $+1
  ld bc,$0000 ; string length
find_name_from.compare_next_char:
  ld a,(de)
find_name_from.change_case_routine: equ $+1
  call ascii_lower.a
  cpi
  jr nz,find_name_from.not_a_match ; jump if the chars are different
  inc de ; point to next character of the string
  push de
  push af
  call question_next_bank
  pop af
  pop de
  jp pe,find_name_from.compare_next_char ; jump if length is not exhausted
  ; The length is exhausted, so the string and the name equal.

find_name_from.end:
  call bank.default ; page in the default memory bank
find_name_from.result: equ $+1
  ld hl,$0000 ; result
  ; If match found:
  ;   HL = nt of the word found
  ; If no match found:
  ;   HL = false
find_name_from.ip: equ $+1
  ld bc,$0000 ; restore the Forth IP

  push hl
  _jp_next

; ----------------------------------------------
  _colon_header find_name_,'find-name'

; doc{
;
; find-name ( ca len -- nt | 0 )
;
; Find the definition identified by the string _ca len_ in the
; current search order. If the definition is not found after
; searching all the vocabularies in the search order, return
; zero.  If the definition is found, return its _nt_.
;
; Definition:

; ----
; : find-name ( ca len -- nt | 0 )
;   #order @ 0 ?do
;     2dup context i cells + @ @ find-name-from ?dup
;     ( ca len nt nt | ca len 0 )
;     if  nip nip unloop exit  then ( ca len )
;   loop  2drop false ;
; ----

; Origin: Gforth.
;
; See: `find-name-in`, `find-name-from`, `find`.
;
; }doc

  dw number_sign_order_,fetch_
  _literal 0
  dw paren_question_do_,find_name.loop_exit ; do

  ; ( ca len )
;  _chk_type 'find-name' ; XXX INFORMER
  dw two_dup_,context_,i_,cells_,plus_
;  _chk 'before first @' ; XXX INFORMER
  dw fetch_
;  _chk 'before second @' ; XXX INFORMER
  dw fetch_
;  _brk 'before find-name-from' ; XXX INFORMER
  dw find_name_from_
;  _chk 'after find-name-from' ; XXX INFORMER
  dw question_dup_ ; ( ca len nt nt | ca len 0 )
  dw zero_branch_,find_name.loop
  dw nip_,nip_,unloop_,exit_
find_name.loop:
  dw paren_loop_ ; loop

find_name.loop_exit:
  dw two_drop_,false_
  dw exit_

; ----------------------------------------------
  _variable_header case_sensitive_,'case-sensitive'

; doc{
;
; case-sensitive ( -- a )
;
; A `variable`. _a_ is the address of a cell containing a flag
; that turns case-sensitive mode on and off.
;
; When the contents of `case-sensitive` are zero, case-sensitive
; mode is off (this is the default): the name of new words
; defined will be stored in lowercase into the dictionary; and
; any name searched for in the dictionary will be converted to
; lowercase first (the conversion is done at low level, not
; affecting the name string passed as parameter).
;
; When the contents of `case-sensitive` are non-zero,
; case-sensitive mode is on: the name of new words defined will
; be stored as they are parsed from the input stream, without
; modification; and any name searched for in the dictionary will
; not be modified, therefore it will be found only if it's
; identical to the name stored in the definition header.
;
; WARNING: Words that are defined when case-sensitive mode is
; on, and that have uppercase characters in their names, will
; not be found when case-sensitive mode is off.
;
; }doc

  dw false

; ----------------------------------------------
  _code_header scan_,'scan'

; doc{
;
; scan ( ca1 len1 c -- ca2 len2 )
;
; Scan the string _ca1 len1_ for the first occurence of
; character _c_.  Leave match address _ca2_ and length remaining
; _len2_.  If no match occurred then _len2_ is zero and _ca2_ is
; _ca1+len1_.
;
; }doc

  exx
  pop de ; E = character searched for
  pop bc ; len1, count
  ld a,c
  or b ; empty string?
  jr z,scan.nothing ; if so, exit
  pop hl ; ca1
  ld a,e ; A = character searched for
  cpir ; scan until match or count=0
  jr nz,scan.no_match
  dec hl ; point to match character
  inc bc ; adjust the count
scan.no_match:
  push hl
scan.nothing:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header skip_,'skip'

; doc{
;
; skip ( ca1 len1 c -- ca2 len2 | ca1 len1 )
;
; Skip over leading occurences of the character _c_ in the string
; _ca1 len1_.  Leave the address of the first non-matching
; character _ca2_ and length remaining _len2_.  If no characters were
; skipped leave _ca1 len1_.
;
; }doc

; Credit:
; Code adapted and modified from CamelForth.

  exx
  pop de ; E = character searched for
  pop bc ; len1
  ld a,c
  or b ; empty string?
  jr z,skip.end ; if so, exit
  pop hl ; ca1
  ld a,e ; A = character searched for
skip.begin:
  cpi
  jr nz,skip.mismatch ; character mismatch, exit
  jp pe,skip.begin ; count not exhausted
  jr skip.done ; count 0, no mismatch
skip.mismatch:
  dec hl ; point at mismatch character
  inc bc ; adjust the count
skip.done:
  push hl
skip.end:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _variable_header current_channel_,'current-channel'

  db 2

; doc{
;
; current-channel ( -- ca )
;
; A `cvariable`. _ca_ is the address of a byte containing
; the number of the latest output channel set by `channel`.
;
; }doc

; ----------------------------------------------
  _code_header channel_,'channel'

; doc{
;
; channel ( n -- )
;
; Open channel _n_ for output. Store _n_ into `current-channel`.
;
; See: `terminal`, `printer`, `printing`.
;
; }doc

  pop hl
  push bc
  ld a,l
  ld (current_channel_dfa),a
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _variable_header last_font_char_,'last-font-char'

; doc{
;
; last-font-char ( -- ca )
;
; A `cvariable`. _ca_ is the address of a byte
; containing the code of the last character displayed from the
; current font by the current action of `emit` and by `g-emit`.
; Higher characters are managed apart, displayed by `emit-udg`
; (depending on the actual implementation of `emit`, which is a
; deferred word) or `g-emit-udg`.
;
; At the moment, only `mode-32-emit` and `g-emit` check this
; value.  Eventually, also the alternative modes will use it.
;
; ``last-font-char`` is a character variable, which must be set
; with `c!`.  Its default value is 127.
;
; See: `set-font`, `set-udg`.
;
; }doc

  db 127

; ----------------------------------------------
  _code_header mode_32_emit_,'mode-32-emit'

; doc{
;
; mode-32-emit ( c -- )
;
; Send character _c_ to the current channel, calling the ROM
; routine at $0010.
;
; ``mode-32-emit`` is the default action of `emit`.
;
; ``mode-32-emit`` uses `last-font-char` the following way:
; characters up to and including `last-font-char` (by default,
; 0 .. 127) are displayed through the ROM routine, while higher
; characters (by default, 128 .. 255) are displayed by `emit-udg`
; from the current UDG set.  The following table shows the
; effect of changing the value of `last-font-char`:

; [cols="1,9"]
; |===
; | Value | Effect
;
; | 126 | Characters 0 .. 126 are displayed by the ROM;
;         characters 127 .. 255 are displayed by `emit-udg`.
; | 127 | Characters 0 .. 127 are displayed by the ROM;
;         characters 128 .. 255 are displayed by `emit-udg`.
; | 143 | Characters 0 .. 143 are displayed by the ROM
;         (this range includes the block graphics);
;         characters 144 .. 255 are displayed by `emit-udg`.
; | 162 | Characters 0 .. 162 are displayed by the ROM
;         (this range includes also the 128-BASIC UDG set 144 .. 162,
;         corresponding to UDG characters 0 .. 18 in Solo Forth);
;         characters 163 .. 255 are displayed by `emit-udg`.
; | 255 | Characters 0 .. 255 are displayed by the ROM
;         (this range includes also the 128-BASIC tokens);
;         no character is displayed by `emit-udg`.
; |===

; When a standard character set is required, without the ROM
; interpreting characters 128 .. 255 its own way,
; `mode-32iso-emit` can be used instead.
;
; See: `current-mode`, `mode-32`, `set-font`, `set-udg`.
;
; }doc

  pop hl ; L = character
  push bc ; save the Forth IP
  ld a,(last_font_char_dfa) ; max character displayed from the font
  cp l ; is character L in range?
  jr z,mode_32_emit.l ; if equals, display it from the font
  jr c,emit_udg.l ; if greater, display it from the UDG set
  ; Otherwise, display it from the font.
mode_32_emit.l:
  ld a,l ; A =character
mode_32_emit.a:
  ld (iy+sys_scr_ct_offset),$FF ; no scroll message
  rst $10
  pop bc ; restore the Forth IP
  _jp_next

; XXX TODO -- Add multitasker's `pause` when available.

; ----------------------------------------------
  _code_header emit_udg_,'emit-udg'

  ; XXX REMARK -- `emit-udg` cannot be moved to the library,
  ; because `mode32-emit` jumps into `emit_udg.l`.

; doc{
;
; emit-udg ( c|n -- ) "emit-u-d-g"
;
; Display the UDG _c|n_ from the current UDG set, which is
; pointed by `os-udg`.
;
; NOTE: The usual parameter is _c_ (0 .. 255), but no check is
; done: If a 16-bit value _n_ is received instead, it will be
; used to calculate the address of the corresponding character
; bitmap in the UDG set.
;
; WARNING: ``emit-udg`` gets the cursor position and the current
; screen address from the OS variables. Therefore, it works only
; in display modes that use the ROM printing routines and keep
; those variables updated, like `mode-32` and `mode-32iso`.
;
; See: `set-udg`, `emit-udga`, `emit`, `mode-32-emit`,
; `g-emit-udg`, `last-font-char`.
;
; }doc

  pop hl ; HL = UDG
  push bc ; save the Forth IP
emit_udg.l:
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; DE = character address in the UDG set
emit_udg.address:
  ; DE = character address in the UDG set
  ld bc,(sys_s_posn) ; cursor position
  ld hl,(sys_df_cc) ; current screen address
  ld (iy+sys_scr_ct_offset),$FF ; no scroll message
  call rom_pr_all
  ld (sys_s_posn),bc
  ld (sys_df_cc),hl
  pop bc ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header emit_udga_,'emit-udga'

  ; XXX TODO -- Move to the library. Calculate
  ; `emit_udg.address` from `emit-udg`.

; doc{
;
; emit-udga ( ca -- ) "emit-u-d-g-a"
;
; Display the UDG defined at _ca_, i.e, the 8 bytes of the UDG
; are stored at _ca_, in the usual ZX Spectrum font/UDG format:
; the first byte is the top scan.
;
; WARNING: ``emit-udga`` gets the cursor position and the
; current screen address from the OS variables. Therefore, it
; works only in display modes that use the ROM printing routines
; and keep those variables updated, like `mode-32` and
; `mode-32iso`.
;
; See: `emit-udg`, `emit`, `mode-32-emit`.
;
; }doc

  pop de ; UDG address
  push bc ; save the Forth IP
  jp emit_udg.address

; ----------------------------------------------
  _defer_header emit_,'emit',,mode_32_emit_

; doc{
;
; emit ( x -- )
;
; If _x_ is a graphic character in the character set used by the
; current display mode, display it.  If _x_ is a control
; character used by the current display mode, manage it.
;
; ``emit`` is a deferred word whose default action is
; `mode-32-emit`.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `current-mode`, `emit-udg`, `g-emit-udg`, `defer`.
;
; }doc

; ----------------------------------------------
  _variable_header printing_,'printing'

; doc{
;
; printing ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; printer flag.  ``printing`` is set by `printer`, reset by
; `terminal` and checked by `page`. ``printing`` should not be
; changed directly by the program.
;
; }doc

  dw false

; ----------------------------------------------
  _colon_header terminal_,'terminal'

; doc{
;
; terminal ( -- )
;
; Select the terminal as output.
;
; See: `printer`, `printing`, `page`.
;
; }doc

  _literal 2
  dw channel_
  dw printing_,off_
  dw exit_

; ----------------------------------------------
  _variable_header key_translation_table_,'key-translation-table'

; doc{
;
; key-translation-table ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; address of the current key translation table, used by `key`.
;
; The table consists of pairs of characters. The first one is
; the character that has to be translated and the second one is
; its translation. The table is finished with a zero.
;
; The default table makes it possible to access the following
; characters with Symbol Shift: '[', ']', '~', '|', '\', '{' and
; '}'.
;
; }doc

  dw default_key_translation_table

default_key_translation_table:

;  dw 0 ; no chained table ; XXX TODO
              ; Symbol Shift + Letter --> new character
  db $C6,'[' ; "Y" 198 ($C6) "AND"  --> 091 ($5B) "["
  db $C5,']' ; "U" 197 ($C5) "OR"   --> 093 ($5D) "]"
  db $E2,'~' ; "A" 226 ($E2) "STOP" --> 126 ($7E) "~"
  db $C3,'|' ; "S" 195 ($C3) "NOT"  --> 124 ($7C) "|"
  db $CD,'\' ; "D" 205 ($CD) "STEP" --> 092 ($5C) "\"
  db $CC,'{' ; "F" 204 ($CC) "TO"   --> 123 ($7B) "{"
  db $CB,'}' ; "G" 203 ($CB) "THEN" --> 125 ($7D) "}"
  db 0 ; end of data

  ; "I" 172 ($AC) "AT"   --> 127 ($7F) "(C)" ; XXX TODO

; ----------------------------------------------
  _code_header translate_char_,'translate-char'

; doc{
;
; translate-char ( c1 -- c1 | c2 )
;
; Translate character _c1_ using the current keyboard decoding
; table, pointed by `key-translation-table`.
;
; }doc

  pop de
  ld a,e
  call translate_char.a
  jp push_a

translate_char.a:
  ld hl,(key_translation_table_dfa)
  dec hl
translate_char.begin:
  inc hl    ; next record of the table
  ld e,(hl) ; character that must be translated, or zero
  inc e     ; is it...
  dec e     ; zero? (=end of table?)
  ret z
  cp e      ; match?
  inc hl    ; point to the character transalation
  jr nz,translate_char.begin ; no match yet, continue
  ; match
  ld a,(hl) ; translate character
  ret

; ----------------------------------------------
if 0 ; XXX UNDER DEVELOPMENT

  ; improved version with support for chained tables

  _colon_header translate_char_,'translate-char'

;
; translate-char ( c1 -- c2 )
;

  ; XXX TODO

  dw key_translation_table_
  dw fetch_
  dw question_dup_
  _literal 0

translate_char.do_it:
  dw cell_plus_
  dw paren_translate_char_
  dw exit_

; ----------------------------------------------
  _code_header paren_translate_char_,'(translate-char'

;
; (translate-char ( c1 ca -- c1 false | c2 true )
;

  ; XXX TODO

  pop hl  ; ca
  pop de  ; c1
  push de ; keep c1 on the stack, as default
  dec hl

translate_char.begin:
  inc hl
  ld a,(hl)
  and a ; end of table?
  jp z,false_ ; no match found
  cp e
  inc hl
  jr nz,translate_char.begin

  ; match found
  ld e,(hl)
translate_char.end:
  pop hl  ; discard c1
  push de
  jp true_

endif

; ----------------------------------------------
  ; _code_header paren_key_,'(key'

  ; XXX TODO --

  ; ld a,(sys_last_k)
  ; ld (previous_key),a
; paren_key_.begin:
  ; ; call pause ; XXX TODO
  ; ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ; ld a,(sys_last_k)
; previous_key: equ $+1
  ; cp 0 ; a different key?
  ; jp z,paren_key_.begin
  ; ld h,0
  ; ld l,a
  ; xor a
  ; ld (sys_last_k),a ; delete the last key
  ; push hl
  ; jp translate_char_

; ----------------------------------------------
  _code_header default_break_key_question_,'default-break-key?'

; doc{
;
; default-break-key? ( -- f ) "default-break-key-question"
;
; _f_ is true if the default break key (Shift+Space) is pressed.
; ``default-break-key?`` is the default action of the deferred
; word `break-key?`.
;
; }doc

  call rom_break_key
  jp nc,true_
  jp false_

; ----------------------------------------------
  _defer_header break_key_question_,'break-key?',,default_break_key_question_

; doc{
;
; break-key? ( -- f ) "break-key-question"
;
; _f_ is true if the break key is pressed. ``break-key?`` is a
; deferred word whose default action is `default-break-key?`.
;
; See: `key?`, `defer`.
;
; }doc

; ----------------------------------------------
  _code_header key_question_,'key?'

; doc{
;
; key? ( -- f ) "key-question"
;
; If a character is available, return true. Otherwise, return
; false. If non-character keyboard events are available before
; the first valid character, they are discarded and are
; subsequently unavailable. The character is returned by the
; next execution of `key`.
;
; After ``key?`` returns with a value of true, subsequent
; executions of ``key?`` prior to  the execution of `key` also
; return true, without discarding keyboard events.
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; See: `-keys`.
;
; }doc

  ; XXX TODO -- Update when `ekey` is implemented.

  ; XXX REMARK -- This version works only when the system
  ; interrupts are on.

  bit 5,(iy+$01) ; new key available? (system variable FLAGS)
  jp z,false_
  jp true_

; ----------------------------------------------
  _variable_header cursor_char_,'cursor-char'

; doc{
;
; cursor-char ( -- ca )
;
; A `cvariable`. _ca_ is the address of a byte containing
; the character code of the cursor used by `xkey`.  Note this is
; a character variable, thus it has to be fetched with `c@` and
; modified with `c!`.
;
; }doc

  db $5F ; character code

; ----------------------------------------------
  _code_header key_,'key'

; doc{
;
; key ( -- c )
;
; Return character _c_ of the key struck, a member of the
; defined character set. Keyboard events that do not correspond
; to such characters are discarded until a valid character is
; received, and those events are subsequently unavailable.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `key?`, `new-key`, `new-key-`, `-keys`.
;
; }doc

  call wait_for_key
  call translate_char.a ; XXX TODO
  jp push_a

; ----------------------------------------------
  _code_header xkey_,'xkey'

; doc{
;
; xkey ( -- c ) "x-key"
;
; Show a cursor, wait for the next terminal key struck; if it's
; the caps lock key, toggle caps and keep waiting; else leave
; the character code _c_ of the key struck.
;
; See: `key`, `-keys`.
;
; }doc

  ; XXX TODO -- Rename to `a[ccept]key`, `c[aps]key`,
  ; `m[ode]key`?

  push bc

  ; Display cursor:
  ld a,(cursor_char_dfa) ; cursor character code
  rst $10
  ld a,backspace_char
  rst $10

xkey.new_key:
  call wait_for_key
  ; A = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,xkey.translate
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,$08
  xor (hl)
  ld (hl),a
  jr xkey.new_key

xkey.translate:
  ; Translate some chars
  call translate_char.a ; XXX TMP
  ld l,a
  ld h,$00

  ; delete the cursor
  ld a,space_char
  rst $10
  ld a,backspace_char
  rst $10

  pop bc
  push hl
  _jp_next

; ----------------------------------------------
  _code_header discard_key_,'discard-key'

; doc{
;
; discard-key ( -- )
;
; Wait for a valid key and discard it.
;
; }doc

  ; XXX TODO -- Make it compatible with the future multitasking

  ; XXX REMARK -- `discard-key` cannot be moved to the library,
  ; because `key` and `xkey` call it.

  push ix ; make next `ret` jump to `next`

wait_for_key:

  ; XXX TMP -- for debugging of `view`:
  ; im 1 ; interrupt mode 1

  ; XXX TODO -- On G+DOS, routine at $0E08 can be used instead,
  ; to save some bytes.

  ; output: A = key code
  bit 5,(iy+1)      ; FLAGS system variable: new key available?
  jr z,wait_for_key
  ld a,(sys_last_k) ; return the key in register A
  res 5,(iy+1)      ; no new key available anymore
  ret

; ----------------------------------------------
  _colon_header paren_cr_,'(cr'

; doc{
;
; (cr ( -- ) "paren-c-r"
;
; Transmit a carriage return to the selected output device.
; ``(cr`` is the default action of the deferred word `cr`.
;
; }doc

  _literal carriage_return_char
  dw emit_
  dw exit_

; ----------------------------------------------
  _defer_header cr_,'cr',,paren_cr_

; doc{
;
; cr ( -- ) "c-r"
;
; Transmit a carriage return to the selected output device.
;
; ``cr`` is a deferred word whose default action is `(cr`.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _code_header c_move_up_,'cmove>'

; doc{
;
; cmove> ( ca1 ca2 u -- ) "c-move-up"
;
; If _u_ is greater than zero, copy _u_ consecutive characters
; from the data space  starting at _ca1_ to that starting at
; _ca2_, proceeding character-by-character from higher addresses
; to lower addresses.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (STRING),
; Forth-2012 (STRING).
;
; See: `cmove`, `move`.
;
; }doc

  ; XXX REMARK -- Not used in the kernel, but moving it to the
  ; library would be a problem.

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header c_move_,'cmove'

; doc{
;
; cmove ( ca1 ca2 u -- ) "c-move"
;
; If _u_ is greater than zero, copy _u_ consecutive characters
; from the data space  starting at _ca1_ to that starting at
; _ca2_, proceeding character-by-character from lower addresses
; to higher addresses.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `cmove>`, `move`.
;
; }doc

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'move'

; doc{
;
; move ( a1 a2 u -- )
;
; If _u_ is greater than zero, copy the contents of _u_
; consecutive bytes at _a1_ to the _u_ consecutive bytes at
; _a2_. After ``move`` completes, the _u_ consecutive bytes at
; _a2_ contain exactly what the _u_ consecutive bytes at _a1_
; contained before the move.
;
; See: `cmove`, `cmove>`.
;
; Origin: Forth-83 (Uncontrolled Reference Words), Forth-94
; (STRING), Forth-2012 (STRING).
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header s_move_,'smove'

; doc{
;
; smove ( ca1 len1 ca2 -- ) "s-move"
;
; Move the string _ca1 len1_ to _ca2_.
;
; ``smove`` is the equivalent of the idiom ``swap move``, but
; faster.
;
; See: `cmove`, `cmove>`, `move`.
;
; }doc

  exx
  pop de
  pop bc
  _jump move.do

; ----------------------------------------------
  _code_header u_m_star_,'um*'

; doc{
;
; um* ( u1 u2 -- ud ) "u-m-star"
;
; Multiply _u1_ by _u2_, giving the unsigned double-cell product
; _ud_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `m*`, `*`, `d*`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header u_m_slash_mod_,'um/mod'

; doc{
;
; um/mod ( ud u1 -- u2 u3 ) "u-m-slash-mod"
;
; Divide _ud_ by _u1_, giving the quotient _u3_ and the
; remainder _u2_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `/mod`, `du/mod`, `mod`, `*/mod`.
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth.

  exx
  pop bc      ; BC = divisor
  pop hl      ; HLDE = dividend
  pop de
  ld a,16     ; loop counter
  sla e
  rl d        ; hi bit DE -> Fc
u_m_slash_mod.do:
  adc hl,hl   ; rot left with carry
  jr nc,u_m_slash_mod.3
  ; case 1: 17 bit, Fc:HL = 1xxxx
  or a        ; we know we can subtract
  sbc hl,bc
  or a        ; clear Fc to indicate sub ok
  jr u_m_slash_mod.4
  ; case 2: 16 bit, Fc:HL = $xxx
u_m_slash_mod.3:
  sbc hl,bc   ; try the subtract
  jr nc,u_m_slash_mod.4 ; if no Fc, subtract ok
  add hl,bc   ; else cancel the subtract
  scf         ;   and set Fc to indicate
u_m_slash_mod.4:
  rl e        ; rotate result bit into DE,
  rl d        ; and next bit of DE into Fc
  dec a
  jr nz,u_m_slash_mod.do
  ; now have complemented quotient in DE,
  ; and remainder in HL
  ld a,d
  cpl
  ld b,a
  ld a,e
  cpl
  ld c,a
  push hl     ; remainder
  push bc     ; quotient
  exx
  _jp_next

; ----------------------------------------------
  _code_header and_,'and'

; doc{
;
; and ( x1 x2 -- x3 )
;
; _x3_ is the bit-by-bit logical "and" of _x1_ with _x2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `or`, `xor`, `negate`, `0=`, `dand`.
;
; }doc

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  push hl
  _jp_next

; ----------------------------------------------
  _code_header or_,'or'

; doc{
;
; or ( x1 x2 -- x3 )
;
; _x3_ is the bit-by-bit inclusive-or of _x1_ with _x2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `and`, `xor`, `negate`, `0=`, `dor`.
;
; }doc

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  push hl
  _jp_next

; ----------------------------------------------
  _code_header xor_,'xor'

; doc{
;
; xor ( x1 x2 -- x3 ) "x-or"
;
; _x3_ is the bit-by-bit exclusive-or of _x1_ with _x2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `or`, `and`, `negate`, `0=`, `dxor`.
;
; }doc

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  push hl
  _jp_next

; ----------------------------------------------
  _constant_header slash_user_,'/user'

; doc{
;
; /user ( -- n ) "slash-user"
;
; A `constant`. _n_ is the length of the user area.
;
; See: `up`.
;
; }doc

  dw bytes_per_user_variables

; ----------------------------------------------
  _variable_header up_,'up'

; doc{
;
; up ( -- a ) "u-p"
;
; A `variable`. _a_ is the address of a cell containing the user
; area pointer.
;
; Origin: fig-Forth.
;
; See: `/user`, `user`.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header up0_,'up0'

; doc{
;
; up0 ( -- a ) "u-p-zero"
;
; A `constant`. _a_ is the default address of the user area.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header np_,'np'

; doc{
;
; np ( -- a ) "n-p"
;
; A `constant`. _a_ is the address of a cell containing the
; name-space pointer, which points to the next free address
; where the next word header will be stored.
;
; Name space is in "far memory": a 64-KiB memory formed by 4
; configurable memory banks.
;
; See: `np0`, `np@`, `dp`, `far-banks`.
;
; }doc

  ; XXX TODO -- User variable?
  ; XXX TODO -- Variable?

  dw names_pointer

; ----------------------------------------------
  _constant_header np0_,'np0'

; doc{
;
; np0 ( -- a ) "n-p-zero"
;
; A `constant`. _a_ is the the bottom (initial) address of the
; name-space pointer `np`.
;
; }doc

  dw names_pointer_bottom

; ----------------------------------------------
  _code_header np_fetch_,'np@'

; doc{
;
; np@ ( -- a ) "n-p-fetch"
;
; Fetch the content of the name-space pointer `np`.
;
; ``np@`` is written in Z80. Its equivalent definition in Forth
; is the following:
;
; ----
; : np@ ( -- a ) np @ ;
; ----
;
; }doc

  ; XXX TODO -- Remove? `np@` is used 3 times in the kernel
  ; (beside debugging optional code) and its definition needs 6
  ; B: 3*2+6=12 B total. After removing the definition: 3*4+0=12
  ; B.

  ld hl,(names_pointer)
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header comma_np_,',np'

; doc{
;
; ,np ( x -- ) "comma-n-p"
;
; Store _x_ into the cell address pointed by `np`, the
; name-space pointer, increasing it by one `cell`.
;
; See: `far!`.
;
; }doc

  dw np_fetch_
  dw far_store_
  dw cell_,np_,plus_store_
  dw exit_

; ----------------------------------------------
  _code_header sp_fetch_,'sp@'

; doc{
;
; sp@ ( -- a ) "s-p-fetch"
;
; Fetch the content of the stack pointer. _a_ is the address of
; the top of the stack just before ``sp@`` was executed.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words).
;
; See: `sp!`, `sp0`.
;
; }doc

  ld hl,$0000
  add hl,sp
  push hl
  _jp_next

; ----------------------------------------------
  _code_header sp_store_,'sp!'

; doc{
;
; sp! ( a -- ) "s-p-store"
;
; Store _a_ into the stack pointer.
;
; }doc

  pop hl
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'rp'

; doc{
;
; rp ( -- a ) "r-p"
;
; A `constant`. _a_ is the address of the return stack pointer.
;
; See: `rp@`, `rp!`.
;
; }doc

  ; XXX TODO -- convert to user variable
  ;
  ; XXX TODO -- Finish the documentation: details of the return
  ; stack.

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'rp@'

; doc{
;
; rp@ ( -- a ) "r-p-fetch"
;
; Fetch the content of the return stack pointer.
;
; ``rp@`` is written in Z80. Its equivalent definition in Forth
; is the following:
;
; ----
; : rp@ ( -- a ) rp @ ;
; ----
;
; See: `rp`, `rp!`.
;
; }doc

  ld hl,(return_stack_pointer)
  push hl
  _jp_next

; ----------------------------------------------
  _code_header rp_store_,'rp!'

; doc{
;
; rp! ( a -- ) "r-p-store"
;
; Store _a_ into the return stack pointer.
;
; ``rp!`` is written in Z80. Its equivalent definition in Forth
; is the following:
;
; ----
; : rp! ( a -- ) rp ! ;
; ----
;
; See: `rp`, `rp@`.
;
; }doc

  pop hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header to_r_,'>r'

; doc{
;
; >r ( x -- ) ( R: -- x ) "to-r"
;
; Move _x_ from the data stack to the return stack.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `r>`, `r@`, 2>r`, `dup>r`.
;
; }doc

  pop de
to_r_.de ; entry point used (calculated) by `dup>r`, defined in the library
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'r>'

; doc{
;
; r> ( -- x ) ( R: x -- ) "r-from"
;
; Move _x_ from the return stack to the data stack.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `>r`, `r@`, `2r>`.
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'rdrop'

; doc{
;
; rdrop ( R: x -- ) "r-drop"
;
; Remove _x_ from the return stack.
;
; See: `r@`, `drop`.
;
; Origin: Comus.
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>r'

; doc{
;
; 2>r ( x1 x2 -- ) ( R: -- x1 x2 ) "two-to-r"
;
; Move _x1 x2_ from the data stack to the return stack.
; Semantically equivalent to ``swap >r >r``.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `2r>`, `2r@`, `>r`.
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2r>'

; doc{
;
; 2r> ( -- x1 x2 ) ( R: x1 x2 -- ) "two-r-from"
;
; Move _x1 x2_ from the return stack to the data stack.
; Semantically equivalent to ``r> r> swap``.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `2>r`, `2r@`, `r>`.
;
; }doc

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_

; ----------------------------------------------
  _code_header two_r_fetch_,'2r@'

; doc{
;
; 2r@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 ) "two-r-fetch"
;
; Copy _x1 x2_ from the return stack to the data stack.
; Semantically equivalent to ``r> r> 2dup >r >r swap``.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `2>r`, `2r>`, `r@`.
;
; }doc

  ; XXX TODO -- Move to the library?  Use `' 2@ 1+` to calculate
  ; the jump address. Problem: `rp` will be converted to a user
  ; variable.

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'r@'

; doc{
;
; r@ ( -- x ) ( R: x -- x ) "r-fetch"
;
; Copy _x_ from the return stack to the data stack.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `>r`, `r>`, `rdrop`, `r'@`.
;
; }doc

  ld hl,(return_stack_pointer)
  jp fetch.hl

; ----------------------------------------------
  _code_header zero_equals_,'0='

; doc{
;
; 0= ( x -- f ) "zero-equals"
;
; _f_ is true if and only if _x_ is equal to zero.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `0<>`, `0<`, `0>`, `negate`, `invert`.
;
; }doc

  pop hl
zero_equals.hl:
  ld a,l
  or h
  jp z,true_

  ; Execution continues in `0`, which is `false`:

; ----------------------------------------------
  _code_header zero_,'0'

; doc{
;
; 0 ( -- 0 )
;
; Return _0_. ``0`` is not a `constant`, but a `code` word,
; which is faster.
;
; See: `-1`, `1`, `2`, `false`.
;
; }doc

  ld hl,0
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header false_,'false',,zero_

; doc{
;
; false ( -- false )
;
; Return a false flag, a single-cell value with all bits
; clear.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `true`, `0`.
;
; }doc

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

; doc{
;
; 0<> ( x -- f ) "zero-not-equals"
;
; _f_ is true if and only if _x_ is not equal to zero.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `0=`.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

; doc{
;
; 0< ( x -- f ) "0-less"
;
; _f_ is true if and only if _n_ is less than zero.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `0>`, `0<=`, `0=`, `0<>`.
;
; }doc

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization
              ;   T  B
              ;  -- --
    add hl,hl ;  11  1
  else
    ; Credit:
    ; Idea from Ace Forth.
              ;   T  B
              ;  -- --
    rl h      ;   8  2
  endif
true_if_cy:
  jp c,true_
  jp false_

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

; doc{
;
; 0> ( n -- f ) "zero-greater"
;
; _f_ is true if and only if _n_ is greater than zero.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `0<`, `0>=`, `0=`, `0<>`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  ld hl,0
  jp less_than.de_hl

; ----------------------------------------------
  _code_header plus_,'+'

; doc{
;
; + ( n1|u1 n2|u2 -- n3|u3 ) "plus"
;
; Add _n1|u1_ to _n2|u2_, giving the sum _n3|u3_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `m+`, `d+`, `2+`, `1+`, `-`.
;
; }doc

  pop de
  pop hl
  add hl,de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header d_plus_,'d+'

; doc{
;
; d+ ( d1|ud1 d2|ud2 -- d3|ud3 ) "d-plus"
;
; Add _d2|ud2_ to _d1|ud1_, giving the sum _d3|ud3_.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (DOUBLE), Forth-2012
; (DOUBLE).
;
; See: `d-`, `+`, `dmax`.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

                        ;   T  B
                        ;  -- --
  pop de                ;  10 01 ; DE=d2hi
  exx                   ;  04 01
  pop de                ;  10 01 ; DE'=d2lo
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL=d1hi,DE=d2hi
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL'=d1lo
  add hl,de             ;  11 01
  push hl               ;  11 01 ; 2OS=d1lo+d2lo=d3lo
  exx                   ;  04 01
  adc hl,de             ;  15 02 ; HL=d1hi+d2hi+Fc=d3hi
  push hl               ;  11 01
  _jp_next              ;  08 02
                        ;  -- --
                        ; 112 15 Total

; ----------------------------------------------
  _code_header invert_,'invert'

; doc{
;
; invert ( x1 -- x2 )
;
; Invert all bits of _x1_ giving its logical inverse _x2_.
;
; See: `0=`, `negate`.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

  pop hl
  ld a,h
  cpl
  ld h,a
  ld a,l
  cpl
  ld l,a
  push hl
  _jp_next

; ----------------------------------------------
  _code_header negate_,'negate'

; doc{
;
; negate ( n1 -- n2 )
;
; Negate _n1_, giving its arithmetic inverse _n2_.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required
; Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `?negate`, `0=`, `inverse`, `dnegate`.
;
; }doc

if 0 ; XXX OLD

  pop hl          ; 10 01
  call negate_hl  ; 17 03
  push hl         ; 11 01
  _jp_next        ; 08 02 ; jp (ix)
                  ; -- --
                  ; 46 07

else ; XXX NEW

  ld hl,push_hl   ; 10 03
  ex (sp),hl      ; 19 01
                  ; 11 01 ; push hl ; done after return
                  ; -- --
                  ; 40 05

endif

negate_hl:

  ; Credit:
  ;
  ; http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Signed_Math

  ; Input:
  ;   HL
  ; Ouput:
  ;   HL = negated
  ;   A = corrupted

  ;       ;  T  B
  ;       ; -- --
  xor a   ; 04 01
  sub l   ; 04 01
  ld l,a  ; 04 01
  sbc a,a ; 04 01
  sub h   ; 04 01
  ld h,a  ; 04 01
          ; -- --
          ; 24 06 Total
  ret

; ----------------------------------------------
  _code_header d_negate_,'dnegate'

; doc{
;
; dnegate ( d1 -- d2 ) "d-negate"
;
; Negate _d1_, giving its arithmetic inverse _d2_.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required
; Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `negate`, `?dnegate`.
;
; }doc

if size_optimization

  ; Credit:
  ; Code from Spectrum Forth-83.
  ;
  ; Comparison to the Abersoft Forth version:
  ; Time:  1.04
  ; Size: -1

                                                ;   T  B
                                                ; --- --
  pop     hl        ; high part                 ;  10 01
  pop     de        ; low part                  ;  10 01
  push    hl        ; save copy                 ;  11 01
  ld      hl,$0000                              ;  10 03
  and     a                                     ;  04 01
  sbc     hl,de     ; HL = negated low part     ;  15 02
  pop     de        ; high part                 ;  10 01
  push    hl        ; negated low part          ;  11 01
  ld      hl,$0000                              ;  10 03
  sbc     hl,de     ; HL = negated high part    ;  15 02
  push    hl                                    ;  11 01
  _jp_next                                      ;  08 02 jp (ix)
                                                ; --- --
                                                ; 125 19 Total
else

  ; Credit:
  ; Code from Abersoft Forth, also found in White Lightning.

  ; XXX TODO optimize?

                                                ;   T  B
                                                ; --- --
  pop hl      ; high part                       ;  10 01
  pop de      ; low part                        ;  10 01
  sub a       ; zero                            ;  04 01
  sub e       ; two's complement to Fc          ;  04 01
  ld e,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,d     ; two's complement with carry     ;  04 01
  ld d,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,l     ; two's complement with carry     ;  04 01
  ld l,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,h     ; two's complement with carry     ;  04 01
  ld h,a                                        ;  04 01
  push de                                       ;  10 01
  push hl                                       ;  11 01
  _jp_next                                      ;  08 02 jp (ix)
                                                ; --- --
                                                ; 106 21 Total

endif

  ; Note: High level version from Z88 CamelForth (17 bytes):
  ;
  ; ----
  ; : dnegate ( d1 -- d2 ) swap invert swap invert 1 m+ ;
  ; ----

; ----------------------------------------------
  _code_header nip_,'nip'

; doc{
;
; nip ( x1 x2 -- x2 )
;
; Drop the first item below the top of stack.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `drop`, `tuck`, `2nip`.
;
; }doc

  pop hl
  pop de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header tuck_,'tuck'

; doc{
;
; tuck ( x1 x2 -- x2 x1 x2 )
;
; Copy the first (top) stack item below the second stack item.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `dup`, `over`, `nip`, `nup`.
;
; }doc

  pop hl
  pop de
  push hl
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header over_,'over'

; doc{
;
; over ( x1 x2 -- x1 x2 x1 )
;
; Place a copy of _x1_ on top of the stack.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `dup`, `swap`, `2over`.
;
; }doc

  pop de
  pop hl
  push hl
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header drop_,'drop'

; doc{
;
; drop ( x -- )
;
; Remove _x_ from the stack.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `2drop`, `nip`.
;
; }doc

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'swap'

; doc{
;
; swap ( x1 x2 -- x2 x1 )
;
; Exchange the top two stack items.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `2swap`, `over`, `tuck`.
;
; }doc

  ; Execution continues in `cs-swap`:

; ----------------------------------------------
  _code_header cs_swap_,'cs-swap',compile_only


; doc{
;
; cs-swap "c-s-swap"
;   ( C: orig#1|dest#1 orig#2|dest#2 -- orig#2|dest#2 orig#1|dest#1 )

;
; Exchange the top two control-flow stack items.
;
; ``cs-swap`` is a `compile-only` word.
;
; NOTE: In Solo Forth the control-flow stack is implemented
; using the data stack. Therefore ``cs-swap`` is an `alias`
; of `swap`.
;
; See: `cs-pick`, `cs-roll`, `cs-drop`.
;
; }doc

  pop hl
  ex (sp),hl
  push hl
  _jp_next

; ----------------------------------------------
  _code_header dup_,'dup'

; doc{
;
; dup ( x -- x x )
;
; Duplicate _x_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `?dup`, `2dup`, `tuck`, `over`, `0dup`, `-dup`,
; `nup`, `3dup`, `dup>r`.
;
; }doc

  pop hl
  push hl
  push hl
  _jp_next

; ----------------------------------------------
  _code_header two_dup_,'2dup'

; doc{
;
; 2dup ( x1 x2 -- x1 x2 x1 x2 ) "two-dup"
;
; Duplicate cell pair _x1 x2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
;
; See: `dup`, `2over`, `2drop`, `3dup`, `4dup`.
;
; }doc

  pop hl
  pop de
  push de
  push hl
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header plus_store_,'+!'

; doc{
;
; +! ( n|u a -- ) "plus-store"
;
; Add _n|u_ to the single-cell number at _a_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `c+!`, `@`, `+`, `!`.
;
; }doc

  pop hl ; address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'off'

; doc{
;
; off ( a -- )
;
; Store `false` at _a_.
;
; ``off`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : off ( a -- ) false swap ! ;
; ----

; Origin: Comus.
;
; See: `on`, `coff`.
;
; }doc

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'on'

; doc{
;
; on ( a -- )
;
; Store `true` at _a_.
;
; ``on`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : on ( a -- ) true swap ! ;
; ----

; Origin: Comus.
;
; See: `off`, `con`.
;
; }doc

  pop hl
  ld (hl),$FF
  inc hl
  ld (hl),$FF
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_and_question_,'c@and?'

; doc{
;
; c@and? ( b ca -- f ) "c-fetch-and-question"
;
; Fetch the caracter at _ca_ and do a bit-by-bit logical "and"
; of it with _b_. Return false if the result is zero, else
; true.
;
; ``c@and`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : c@and? ( b ca -- f ) c@ and 0<> ;
; ----

; See: `c@and`.
;
; }doc

  ; XXX REMARK -- This word could be moved to the library, but
  ; the alternative definition of `lex?` should be used.

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  and (hl)
  jp nz,true_
  jp false_

; ----------------------------------------------
  _code_header c_set_,'cset'

; doc{
;
; cset ( b ca -- ) "c-set"
;
; Set the bits at _ca_ specified by the bitmask _b_.
;
; ``cset`` is written in Z80. Its equivalent definition in
; Forth is the following.

; ----
; : cset ( b ca -- ) tuck c@ or swap c! ;
; ----

; See: `creset`, `ctoggle`, `c@and`.
;
; }doc

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  or (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header c_reset_,'creset'

; doc{
;
; creset ( b ca -- ) "c-reset"
;
; Reset the bits at _ca_ specified by the bitmask _b_.
;
; ``creset`` is written in Z80. Its equivalent definition in
; Forth is the following.

; ----
; : creset ( b ca -- ) tuck c@ swap invert and swap c! ;
; ----

; See: `cset`, `ctoggle`, `c@and`.
;
; }doc

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  cpl
  and (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header two_store_,'2!'

; doc{
;
; 2! ( x1 x2 a -- ) "two-store"
;
; Store the cell pair _x1 x2_ at _a_, with _x2_ at _a_ and _x1_
; at the next consecutive cell. It is equivalent to the sequence
; ``swap over ! cell+ !``.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `2@`, `!`, `c!`.
;
; }doc

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization
    jr store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _colon_header default_display_,'default-display'

  dw default_mode_,default_font_,default_colors_
  dw exit_

; doc{
;
; default-display ( -- )
;
; Set the default values of the display: mode, font and colors.
; ``default-display`` is executed by `cold`.
;
; Definition:

; ----
; : default-display ( -- )
;   default-mode default-font default-colors ;
; ----

; See: `default-mode`, `default-font`, `default-colors`.
;
; }doc

; ----------------------------------------------
  _code_header default_font_,'default-font'

; doc{
;
; default-font ( -- )
;
; Set the default font, which is the ROM font, by setting the
; system variable `os-chars` to 15360 ($3C00).
;
; See: `set-font`, `rom-font`, `default-display`,
; `default-mode`, `default-colors`.
;
; }doc

  ld hl,15360 ; bitmap address of character '0' in the ROM font
  push hl

  ; Execution continues in `set-font`:

; ----------------------------------------------
  _code_header set_font_,'set-font'

; doc{
;
; set-font ( a -- )
;
; Set address _a_ as the current font by setting the system
; variable `os-chars`
;
; ``set-font`` is used by all screen modes.  The character
; bitmap _a_ points to depends on the mode.
;
; The last character used from the font can be configured by
; `last-font-char`.
;
; See: `get-font`, `rom-font`, `default-font`, `mode-32`,
; `mode-32iso`, `mode-42pw`, `mode-64ao`.
;
; }doc

  ld hl,sys_chars
  jr store.into_hl_pointer

; ----------------------------------------------
  _code_header store_,'!'

; doc{
;
; ! ( x a -- ) "store"
;
; Store _x_ at _a_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `@`, `+!`, `2!`, `c!`.
;
; }doc

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'c!'

; doc{
;
; c! ( c ca -- ) "c-store"
;
; Store _c_ at _ca_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `!`, `2!`, `c@`.
;
; }doc

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _constant_header do_colon_,'docolon'

; doc{
;
; docolon ( -- a ) "do-colon"
;
; A `constant`. _a_ is the address of the colon interpreter.
;
; ``dolocon`` is used by `does>`.
;
; }doc

  dw do_colon

; ----------------------------------------------
  _colon_header colon_,':'

; doc{
;
; : ( "name" -- ) "colon"
;
; Parse _name_. Create a definition for _name_, called a "colon
; definition". Enter  compilation  `state` and  start  the
; current definition. Append  the initiation semantics given
; below to the current definition.
;
; Initiation: ``( i*x -- i*x ) ( R: -- nest-sys )``
;
; Save implementation-dependent information  _nest-sys_ about
; the calling  definition. The  stack effects  _i*x_ represent
; arguments to _name_.
;
; _name_ execution: ``( i*x -- j*x )``
;
; Execute the definition name. The stack effects _i*x_  and
; _j*x_ represent arguments to and results from _name_,
; respectively.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `;`, `does>`, `header`.
;
; }doc

; XXX TODO -- Finish documentation: simplify.

if 0 ; XXX TMP -- for debugging
  dw cr_
  dw blk_,fetch_,dot_
  dw latest_,question_dup_
  dw zero_branch_,colon.no_name
  dw dot_name_
colon.no_name:
  dw np_fetch_,u_dot_
  ; dw key_,drop_
endif

  dw store_csp_
  dw header_
  dw lit_,do_colon
  dw call_comma_
  dw right_bracket_
  dw paren_semicolon_code_
do_colon:
  ; Save the Forth IP to the return stack
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; Then point it to the dfa of the word that called here
  pop bc ; BC=dfa

  ; Copy of the inner interpreter:

  ; Execute the word whose xt is in the address pointed by the
  ; BC register:

  ; Forth: W  <-- (IP)
  ; Z80:   HL <-- (BC)

  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP

  ; BC = address of the next xt
  ; HL = xt

  ; Execute the word whose xt is in the HL register:

  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (HL)

  jp (hl)

; ----------------------------------------------
  _variable_header noname_question_,'noname?'

; doc{
;
; noname? ( -- a ) "no-name-question"
;
; A `variable`. _a_ is the address of a cell containing a flag:
; Was the word being defined created by `:noname`? ``noname?``
; is set by `:noname` and reset by `;`.
;
; }doc

; Credit:
; The idea for this variable was taken from hForth.

  dw false

; ----------------------------------------------
  _colon_header finish_code_,'finish-code'

; doc{
;
; finish-code ( -- )
;
; End the current definition, allow it to be found in the
; dictionary and enter interpretation state.
;
; ``finish-code`` is a factor of `;` and `;code`.
;
; Definition:

; ----
; : finish-code ( -- )
;   ?csp postpone [ noname? @ noname? off ?exit reveal ;
; ----

; Origin: Gforth.
;
; See: `reveal`, `noname?`, `?csp`, `[`, `no-exit`.
;
; }doc

  ; Credit:
  ;
  ; Name borrowed from Gforth.

  dw question_csp_
  dw left_bracket_
  dw noname_question_,fetch_
  dw noname_question_,off_
  dw question_exit_
  dw reveal_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate+compile_only

; doc{
;
; ; "semicolon"
;   Compilation: ( -- )
;   Run-time:    ( -- ) ( R: nest-sys -- )
;
; Compilation: Append the run-time semantics below to the
; current definition. End the current definition, allow it to be
; found in the dictionary and enter interpretation state.
;
; Run-time: Return to the calling definition specified by
; _nest-sys_.
;
; ``;`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : ; \ Compilation: ( -- )
;     \ Run-time:    ( -- ) ( R: nest-sys -- )
;   postpone exit finish-code ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `exit`, `:`, `finish-code`, `;code`.
;
; }doc

  dw compile_,exit_,finish_code_
  dw exit_

; ----------------------------------------------
  _colon_header c_constant_,'cconstant'

; doc{
;
; cconstant ( c "name" -- ) "c-constant"
;
; Parse _name_. Create a definition for _name_ that will place
; _c_ on the stack. _name_ is referred to as a "c-constant".
;
; Origin: Comus.
;
; See: `constant`, `2constant`, `c!>`, `cconst`,
; `[cconst]`, `cvalue`, `cvariable`.
;
; }doc

  dw create_,c_comma_
  dw paren_semicolon_code_
do_c_constant:

  ; Execution continues in `c@`:

; ----------------------------------------------
  _code_header c_fetch_,'c@'

; doc{
;
; c@ ( ca -- c ) "c-fetch"
;
; Fetch the character _c_ stored at _ca_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `@`, `2@`, `c!`, `c@1+`, `c@1-`, `c@2+`, `c@2-`.
;
; }doc

  pop hl
c_fetch.hl:
  ld l,(hl)
  ld h,$00
  push hl
  _jp_next

  ; XXX WARNING -- `c_fetch.hl` is used by `cvalue`. The address
  ; is calculated from the code field of `c@`.

; ----------------------------------------------
  _colon_header constant_,'constant'

; doc{
;
; constant ( x "name" -- )
;
; Parse _name_. `create` a definition for _name_ that will place
; _x_ on the stack. _name_ is referred to as a "constant".
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `2constant`, `cconstant`, `fconstant`, `!>`, `const`,
; `[const]`, `value`, `variable`.
;
; }doc

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:

  ; Execution continues in `@`:

; ----------------------------------------------
  _code_header fetch_,'@'

; doc{
;
; @ ( a -- x ) "fetch"
;
; _x_ is the value stored at _a_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `!`, `2@`, `c@`.
;
; }doc

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

  ; XXX WARNING -- `fetch.hl` is used by `value`. The address is
  ; calculated from the code field of `@`.

; ----------------------------------------------
  _colon_header variable_,'variable'

; doc{
;
; variable ( "name" -- )
;
; Parse _name_.  `create` a definition for _name_, which is
; referred to as a "variable".  `allot` one `cell` of data
; space, the data field of _name_, to hold the contents of the
; variable. When _name_ is later executed, the address of its
; data field is placed on the stack.
;
; The program is responsible for initializing the contents of
; the variable.
;
; Definition:

; ----
; : variable ( "name" -- ) create cell allot ;
; ----

; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `cvariable`, `2variable`, `constant`.
;
; }doc

  dw create_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header paren_user_,'(user'

; doc{
;
; (user ( +n "name" -- ) "paren-user"
;
; Create a user variable _name_.  _+n_ is the offset within the
; user area where the value for _name_ is stored.  Execution of
; _name_ leaves its absolute user area storage address. No user
; space is allocated.
;
; ``(user`` is a factor of `ucreate`.
;
; See: `user`, `2user`, `uallot`.
;
; }doc

  ; XXX TODO -- Rename?

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  pop hl
  ld e,(hl)
  ld d,$00        ; DE = index of the user variable
  ld hl,(up_dfa)  ; HL = address of the user area (the value of `up`)
  add hl,de       ; HL = address of the user variable
  push hl
  _jp_next

  ; WARNING: `do_user` is used in `ucreate-cf?`, which is part
  ; of the `see` tool. The address of `do_user` is calculated
  ; from the code field address of `(user`, after its current
  ; code.

; ----------------------------------------------
  _code_header one_,'1'

; doc{
;
; 1 ( -- 1 )
;
; Return _1_. ``1`` is not a `constant`, but a `code` word,
; which is faster.
;
; See: `-1`, `0`, `2`.
;
; }doc

  ld hl,1
  push hl
  _jp_next

; ----------------------------------------------
  _code_header two_,'2'

; doc{
;
; 2 ( -- 2 )
;
; Return _2_. ``2`` is not a `constant`, but a `code` word,
; which is faster.
;
; See: `-1`, `0`, `1`, `cell`.
;
; }doc

  ld hl,2
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header cell_,'cell',,two_

; doc{
;
; cell ( -- n )
;
; _n_ is the size in bytes of one cell. ``cell`` returns 2 in
; Solo Forth.
;
; Origin: Comus.
;
; See: `cells`, `cell+`, `cell-`, `cell/`, `cell-bits`.
;
; }doc

; ----------------------------------------------
  _c_constant_header b_l_,'bl'

; doc{
;
; bl ( -- c ) "b-l"
;
; A `cconstant`. _c_ is the character value for a space.
;
; Because space is used throughout Forth as the standard
; delimiter, ``bl`` is the only way a program has to find and
; use the character value of a space.
;
; See: `space`, `emit`.
;
; }doc

  db space_char

; ----------------------------------------------
  _c_constant_header c_slash_l_,'c/l'

; doc{
;
; c/l ( -- b ) "c-slash-l"
;
; A `cconstant`. _b_ is the number of characters per line in a
; `block` source: 64.
;
; See: `l/scr`.
;
; }doc

  ; XXX TODO -- Rename to `chars/line`.

  db characters_per_line

; ----------------------------------------------
  _c_constant_header l_slash_scr_,'l/scr'

; doc{
;
; l/scr ( -- b ) "l-slash-s-c-r"
;
; A `cconstant`. _b_ is the number of lines per `block`
; source: 16.
;
; See: `c/l`.
;
; }doc

  ; XXX TODO -- Rename to `lines/block`.

  db lines_per_screen

; ----------------------------------------------
  _constant_header disk_buffer_,'disk-buffer'

; doc{
;
; disk-buffer ( -- a )
;
; A `constant`. _a_ is the address of the disk `buffer`. The cell
; stored at _a_ is the disk buffer identifier.
;
; See: `buffer-data`.
;
; }doc

  dw disk_buffer

; ----------------------------------------------
  _constant_header buffer_data_,'buffer-data'

; doc{
;
; buffer-data ( -- ca )
;
; A `constant`. _ca_ is the address of the disk `buffer` data.
;
; See: `disk-buffer`, `b/buf`.
;
; }doc

  ; XXX TODO -- rename

  dw buffer_data

; ----------------------------------------------
  _constant_header b_slash_buf_,'b/buf'

; doc{
;
; b/buf ( -- n ) "b-slash-buf"
;
; A `constant`.  _n_ is the number of bytes per `block` `buffer`:
; 1024.
;
; Origin: fig-Forthfootnote:[In fig-Forth the size of each disk
; buffer was the size of a disk sector, usually 128 bytes by the
; time.], Forth-79 (Reference Word Set), Forth-83 (Uncontrolled
; Reference Words).
;
; See: `c/l`, `l/scr`.
;
; }doc

  dw bytes_per_buffer

; ----------------------------------------------
  _c_constant_header sectors_slash_track_,'sectors/track'

; doc{
;
; sectors/track ( -- b ) "sectors-slash-track"
;
; A `cconstant`. _b_ is the number of sectors per track.
;
; See: `b/sector`, `sectors/block`, `blocks/disk`.
;
; }doc

  db sectors_per_track

; ----------------------------------------------
  _c_constant_header sectors_slash_block_,'sectors/block'

; doc{
;
; sectors/block ( -- b ) "sectors-slash-block"
;
; A `cconstant`. _b_ is the number of sectors per block.
;
; See: `b/sector`, `sectors/track`, `blocks/disk`.
;
; }doc

  db sectors_per_block

; ----------------------------------------------
  _constant_header blocks_slash_disk_,'blocks/disk'

; doc{
;
; blocks/disk ( -- n ) "blocks-slash-disk"
;
; A `constant`. _n_ is the number of blocks per disk.
;
; See: `sectors/block`, `sectors/track`.
;
; }doc

  dw blocks_per_disk

; ----------------------------------------------
  _colon_header plus_origin_,'+origin'

; doc{
;
; +origin ( n -- a ) "plus-origin"
;
; Leave the memory address _a_ relative by _n_ bytes to the
; origin parameter area.  ``+origin`` is used to access or
; modify the boot-up parameters at the origin area.
;
; See the details in the source of the kernel.
;
; Origin: fig-Forth.
;
; }doc

; XXX TODO -- Finish the documentation: include the parameters
; that can be accessed.

  dw lit_,origin,plus_
  dw exit_

; ----------------------------------------------
  _user_variable_header sp0_,'sp0'

; doc{
;
; sp0 ( -- a ) "s-p-zero"
;
; A `user` variable. _a_ is the address of a cell containing the
; address of the bottom of the data stack.
;
; Origin: fig-Forth's ``s0``, Forth-79's ``s0``, Forth-83's
; ``s0``.
;
; See: `sp@`, `sp!`.
;
; }doc

  db $00

; ----------------------------------------------
  _user_variable_header rp0_,'rp0'

; doc{
;
; rp0 ( -- a ) "r-p-zero"
;
; A `user` variable. _a_ is the address of a cell containing the
; address of the bottom of the return stack.
;
; Origin: fig-Forth's ``r0``.
;
; }doc

  db $02

; ----------------------------------------------
; XXX REMARK -- free user variable
; XXX TODO -- move the rest of user variables

  ; db $04

; ----------------------------------------------
  _user_variable_header width_,'width'

; doc{
;
; width ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; maximum number of letters saved in the compilation of a
; definition name. It must be 1 thru 31, with a default value of
; 31. The name character count and its natural characters are
; saved, up to the value in ``width``.  The value may be changed
; at any time within the above limits.
;
; Origin: fig-Forth.
;
; }doc

  ; XXX TODO normal variable? constant?
  ; XXX TODO -- remove?

  db $06

; ----------------------------------------------
  _user_variable_header last_blk_,'lastblk'

; XXX TODO normal variable?

; doc{
;
; lastblk ( -- a ) "last-b-l-k"
;
; A `user` variable. _a_ is the address of a cell containing the
; `block` number of the block most recently or loaded (e.g. with
; `load`, `continued` or `load-program`). ``lastblk`` is updated
; by `(load` and used by `reload`.
;
; }doc

  db $08

; ----------------------------------------------
  _user_variable_header last_,'last'

; doc{
;
; last ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; name token of the last word defined.
;
; See: `latest`, `lastxt`.
;
; }doc

  db $0A

  ; XXX TODO -- Ordinary variable?

; ----------------------------------------------
  _user_variable_header dp_,'dp'

; doc{
;
; dp ( -- a ) "d-p"
;
; A `user` variable. _a_ is the address of a cell containing the
; data-space pointer.  The value may be read by `here` and
; altered by `there` and `allot`.
;
; Origin: fig-Forth.
;
; }doc

  db $0C

; ----------------------------------------------
  _user_variable_header udp_,'udp'

; doc{
;
; udp ( -- a ) "u-d-p"
;
; A `user` variable. _a_ is the address of a cell containing an
; offset from the start of the current user area to the free
; space in it.
;
; }doc

  db $0E

; ----------------------------------------------
  _user_variable_header lastxt_,'lastxt'

; doc{
;
; lastxt ( -- a ) "last-x-t"
;
; A `user` variable. _a_ is the address of a cell containing the
; execution token of the last word defined.
;
; See: `last`.
;
; }doc

  db $10

; ----------------------------------------------
  _user_variable_header to_in_,'>in'

; doc{
;
; >in ( -- a ) "to-in"
;
; A `user` variable. _a_ is the address of a cell containing the
; offset in characters from the start of the input buffer to the
; start of the parse area.
;
; }doc

  db $12

; ----------------------------------------------
  _user_variable_header blk_,'blk'

; doc{
;
; blk ( -- a ) "b-l-k"
;
; A `user` variable. _a_ is the address of a cell containing zero
; or the number of the disk `block` being interpreted.  If
; ``blk`` contains zero, the input source is not a block and
; can be identified by `source-id`.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (BLOCK), Forth-2012 (BLOCK).
;
; See: `load`, `loading?`, `?loading`.
;
; }doc

  ; XXX TODO normal variable?

  db $14

; ----------------------------------------------
  _user_variable_header scr_,'scr'

; doc{
;
; scr ( -- a ) "s-c-r"
;
; A `user` variable. _a_ is the address of a cell containing the
; number of the `block` most recently listed by `list`. ``scr``
; is used by the block editors.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (BLOCK EXT), Forth-2012
; (BLOCK EXT).
;
; See: `editor`.
;
; }doc

; XXX TODO -- Normal variable?
;
; XXX TODO -- Move to the library.

  db $16

; ----------------------------------------------
  _user_variable_header catcher_,'catcher'

; doc{
;
; catcher ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; return stack pointer for error handling. Used by `throw` and
; `catch`.
;
; }doc

  db $18

; ----------------------------------------------
  _user_variable_header hld_,'hld'

; doc{
;
; hld ( -- a ) "h-l-d"
;
; A `user` variable. _a_ is the address of a cell containing the
; address of the latest character of text during numeric output
; conversion.
;
; Origin: fig-Forth.
;
; See: `hold`, `<#`, `#>`.
;
; }doc

  db $1A

; ----------------------------------------------
  _user_variable_header current_,'current'

; doc{
;
; current ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; word list identifier of the compilation word list.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (System Extension Word Set).
;
; See: `get-current`.
;
; }doc

  db $1C

; ----------------------------------------------
  _user_variable_header state_,'state'

; doc{
;
; state ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; compilation-state flag, which is true when in compilation
; state, false otherwise.
;
; Origin: fig-Forth, Forth-89 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `compiling?`, `[`, `]`.
;
; }doc

  db $1E

; ----------------------------------------------
  _user_variable_header base_,'base'

; doc{
;
; base ( -- a )
;
; A `user` variable. _a_ is the address of a cell containing the
; current number-conversion radix.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `>number`, `number?`, `abase`.
;
; }doc

  db $20

; ----------------------------------------------
  _user_variable_header dpl_,'dpl'

; doc{
;
; dpl ( -- a ) "d-p-l"
;
; A `user` variable. _a_ is the address of a cell containing the
; number of places after the decimal point on double-integer
; input conversion.
;
; If ``dpl`` contains zero, the decimal point is the last
; character.  The default value of ``dpl`` on single-number
; input is -1.
;
; Origin: fig-Forth, Forth-83 (Uncontrolled Reference Words).
;
; See: `number-point?`, `>number`, `number?`.
;
; }doc

  db $22

; ----------------------------------------------
  _user_variable_header csp_,'csp'

; doc{
;
; csp ( -- a ) "c-s-p"
;
; A `user` variable. _a_ is the address of a cell containing the
; current data stack position saved by `!csp`.
;
; Origin: fig-Forth.
;
; }doc

  ; XXX TODO ordinary variable?

  db $24

; ----------------------------------------------
  _user_variable_header number_sign_order_,'#order'

; doc{
;
; #order ( -- a ) "number-sign-order"
;
; A `user` variable. _a_ is the address of a cell containing the
; number of word lists in the search `order`.
;
; See: `context`, `max-order`, `get-order`, `set-order`,
; `>order`, `wordlist`.
;
; }doc

  db $26

; ----------------------------------------------
  _user_variable_header context_,'context'

; doc{
;
; context ( -- a )
;
; A `user` variable.  _a_ is the address of an array of cells that
; represents the search `order`; its maximum length is hold in
; the `max-order` constant, and its current length is hold in
; the `#order` variable.  _a_ holds the word list at the top of
; the search order.
;
; See: `>order`, `get-order`, `set-order`.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (System Extension Word Set).
;
; }doc

  db $28

; ----------------------------------------------
  _variable_header last_wordlist_,'last-wordlist'

if 1 ; assembler_core_in_kernel
  dw assembler_wordlist_dfa
else
  dw forth_wordlist_dfa
endif

; doc{
;
; last-wordlist ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the data
; field address of the latest word list created.
;
; See:  `wordlist`, `latest`.
;
; }doc

; ----------------------------------------------
  _constant_header tib_,'tib'

; doc{
;
; tib ( -- a ) "t-i-b"
;
; A `constant`. _a_ is the address of the terminal input buffer.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE EXT,
; obsolescent).
;
; See: `/tib`, `#tib`.
;
; }doc

  dw terminal_input_buffer

; ----------------------------------------------
  _c_constant_header slash_tib_,'/tib'

; doc{
;
; /tib ( -- b ) "slash-t-i-b"
;
; A `cconstant`. _b_ is the maximum size of `tib`, the terminal
; input buffer,
;
; See: `#tib`.
;
; }doc

  db bytes_per_terminal_input_buffer

; ----------------------------------------------
  _variable_header number_sign_tib_,'#tib'

; doc{
;
; #tib ( -- a ) "number-sign-t-i-b"
;
; A `variable`. _a_ is the address of a cell containing the number
; of characters in 'tib', the terminal input buffer.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE EXT,
; obsolescent).
;
; See: `/tib`.
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header input_buffer_,'input-buffer'

; doc{
;
; input-buffer ( -- a )
;
; A `2variable`. _a_ is the address of a double cell
; containing the address and length of the current input buffer.
;
; See: `source`, `set-source`.
;
; }doc

  dw 0 ; length
  dw 0 ; address

; ----------------------------------------------
  _colon_header source_,'source'

; doc{
;
; source ( -- ca len )
;
; _ca_ is the address of, and _len_ is the number of characters
; in, the input buffer.
;
; Definition:

; ----
; : source ( -- ca len )
;   blk @ ?dup if block b/buf exit then
;   input-buffer 2@ ;
; ----

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `input-buffer`, `set-source`, `blk`, `stream`,
; `nest-source`, `unnest-source`.
;
; }doc

  dw blk_,fetch_,question_dup_
  dw zero_branch_,source.other
  ; disk block
  dw block_,b_slash_buf_
  dw exit_
source.other:
  dw input_buffer_,two_fetch_
  dw exit_

; ----------------------------------------------
  _code_header two_plus_,'2+'

; doc{
;
; 2+ ( n1 -- n2 ) "two-plus"
;
; Add 2 to _n1_, according to the operation of `+`, giving _n2_.
;
; ``2+`` is equivalent to ``2 +`` but faster.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set).
;
; See: `2-`, `1+`, `8+`, `c@2+`, `2`, `+`.
;
; }doc

              ;  T  B
              ; -- --
  pop hl      ; 10 01
  inc hl      ; 06 01
  inc hl      ; 06 01
  push hl     ; 11 01
  _jp_next    ; 08 02 jp (ix)
              ; -- --
              ; 41 06 Total

; ----------------------------------------------
  _alias_header cell_plus_,'cell+',,two_plus_

; doc{
;
; cell+ ( a1 -- a2 ) "cell-plus"
;
; Add the size in bytes of a cell to _a1_, giving _a2_.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `cell`, `cells`, `cell-`, `cell/`.
;
; }doc

; ----------------------------------------------
  _code_header one_minus_,'1-'

; doc{
;
; 1- ( n1 -- n2 ) "one-minus"
;
; Subtract 1 from _n1_, according to the operation of `-`,
; giving _n2_.
;
; ``1-`` is equivalent to ``1 -`` but faster.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set).
;
; See: `1+`, `2-`, `8-`, `c@1-`, `1`, `-`.
;
; }doc

  pop hl
  dec hl
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header char_minus_,'char-',,one_minus_

; doc{
;
; char- ( n1 -- n2 ) "char-minus"
;
; Subtract the size in bytes of a character to _n1_,
; giving _n2_.
;
; ``char-`` is an `alias` of `1-`.
;
; Origin: Comus.
;
; See: `char+`.
;
; }doc

  ; XXX TODO -- Move to the library? It uses no byte of
  ; code/data space.

; ----------------------------------------------
  _code_header one_plus_,'1+'

; doc{
;
; 1+ ( n1 -- n2 ) "one-plus"
;
; Add 1 to _n1_, according to the operation of `+`, giving _n2_.
;
; ``1+`` is equivalent to ``1 +`` but faster.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set).
;
; See: `1-`, `2+`, `8+`, `c@1+`, `1`, `+`.
;
; }doc

  pop hl
  inc hl
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header char_plus_,'char+',,one_plus_

; doc{
;
; char+ ( n1 -- n2 ) "char-plus"
;
; Add the size in bytes of a character to _n1_, giving
; _n2_.
;
; ``char+`` is an `alias` of `1+`.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `char-`, `chars`.
;
; }doc

  ; XXX TODO -- Move to the library? It uses no byte of
  ; code/data space.

; ----------------------------------------------
  _code_header two_minus_,'2-'

; doc{
;
; 2- ( n1 -- n2 ) "two-minus"
;
; Subtract 2 from _n1_, according to the operation of `-`,
; giving _n2_.
;
; ``2-`` is equivalent to ``2 -`` but faster.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set).
;
; See: `2+`, `1-`, `8-`, `c@2-`, `2`, `-`.
;
; }doc

  pop hl
  dec hl
  dec hl
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header cell_minus_,'cell-',,two_minus_

; doc{
;
; cell- ( a1 -- a2 ) "cell-minus"
;
; Subtract the size in bytes of a cell from _a1_, giving
; _a2_.
;
; Origin: Comus.
;
; See: `cell`, `cell+`, `cells`, `cell/`.
;
; }doc

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2* ( x1 -- x2 ) "two-star"
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; ``2*`` is equivalent to ``1 lshift``, but faster.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `lshift`, `8*`, `3*`, `*`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.
  ; Documentation partly based on lina.

  pop hl
  add hl,hl
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header cells_,'cells',,two_star_

; doc{
;
; cells ( n1 -- n2 )
;
; _n2_ is the size in bytes of _n1_ cells.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `cell`, `cell+`, `cell-`, `cell/`.
;
; }doc

; ----------------------------------------------
  _alias_header chars_,'chars',immediate,noop_

; doc{
;
; chars ( n1 -- n2 )
;
; _n2_ is the size in bytes of _n1_ characters.  In Solo
; Forth ``chars`` does nothing, therefore _n1_ equals _n2_.
;
; ``chars`` is an `immediate` word.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _colon_header allot_,'allot'

; doc{
;
; allot ( n -- )
;
; If _n_ is greater than zero, reserve _n_ bytes of data space.
; If _n_ is less than zero, release _n_ bytes of data space. If
; _n_ is zero, leave the data-space pointer unchanged.
;
; Definition:

; ----
; : allot ( n -- ) dp +! ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `allotted`, `dp`, here`, `reserve`.
;
; }doc

  dw dp_,plus_store_
  dw exit_

  ; Alternative non-standard definition:
  ; http://dxforth.netbay.com.au/allot.html

; ----------------------------------------------
  _colon_header s_comma_,'s,'

; doc{
;
; s, ( ca len -- ) "s-comma"
;
; Compile the string _ca len_.
;
; Definition:

; ----
; : s, ( ca len -- ) tuck here place char+ allot ;
; ----

; See: `c,`, `here`, `cmove`, `allot`, `count`, `fars,`.
;
; }doc

  dw tuck_,here_,place_,char_plus_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header two_comma_,'2,'

; doc{
;
; 2, ( x1 x2 -- ) "2-comma"
;
; Definition:

; ----
; : 2, ( x1 x2 -- ) here 2! [ 2 cells ] literal allot ;
; ----

; Reserve two cells of data space and store _x1 x2_ in them.
; _x2_ is stored in the first cell, and _x1_ is stored in the
; second cell.
;
; See: `,`, `c,`, `here`, `2!`, `cells`, `literal`,
; `allot`.
;
; }doc

  dw here_,two_store_
  _literal 2*cell
  dw allot_
  dw exit_

; ----------------------------------------------
  _colon_header c_comma_,'c,'

; doc{
;
; c, ( c -- ) "c-comma"
;
; Reserve space for one character in the data space and store
; _c_ in the space.
;
; Definition:

; ----
; : c, ( c -- ) here c! 1 allot ;
; ----

; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `,`, `2,`, `here`, `c!`, `allot`.
;
; }doc

  dw here_,c_store_
  _literal 1
  dw allot_
  dw exit_

; ----------------------------------------------
  _code_header minus_,'-'

; doc{
;
; - ( n1|u1 n2|u2 -- n3|u3 ) "minus"
;
; Substract _n2|u2_ from _n1|u1_, giving the difference _n3|u3_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `d-`, `2-`, `1-`, `+`.
;
; }doc

  pop de
  pop hl
  and a
  sbc hl,de
  push hl
  _jp_next

; ----------------------------------------------
  _code_header not_equals_,'<>'

; doc{
;
; <> ( x1 x2 -- f ) "not-equals"
;
; _f_ is true only and only if _x1_ is not bit-for-bit the
; same as _x1_.
;
; Origin: Forth-79 (Reference Word Set), Forth-83 (Uncontrolled
; Reference Words), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `=`, `>`, `<`.
;
; }doc

  pop de
  pop hl
  or a ; Fc=0
  sbc hl,de
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header equals_,'='

; doc{
;
; = ( x1 x2 -- f ) "equals"
;
; _f_ is true only and only if _x1_ is bit-for-bit the same as
; _x1_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `<>`, `>`, `<`.
;
; }doc

  pop de
  pop hl
  or a ; Fc=0
  sbc hl,de
  jp nz,false_

  ; Execution continues in `-1`, which is `true`:

; ----------------------------------------------
  _code_header minus_one_,'-1'

; doc{
;
; -1 ( -- -1 ) "minus-one"
;
; Return _-1_. ``-1`` is not a `constant`, but a `code` word,
; which is faster.
;
; See: `0`, `1`, `2`, `true`.
;
; }doc

  ld hl,-1
  push hl
  _jp_next

; ----------------------------------------------
  _alias_header true_,'true',,minus_one_

; doc{
;
; true ( -- true )
;
; Return a true flag, a single-cell value with all its bits
; set (equivalent to `-1`).
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `false`.
;
; }doc

; ----------------------------------------------
  _code_header less_than_,'<'

; doc{
;
; < ( n1 n2 -- f ) "less-than"
;
; _f_ is true if and only if _n1_ is less than _n2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `>`, `u<`, `0<`, `min`.
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth

  pop de
  pop hl
less_than.de_hl:

            ;  T  B
            ; -- --
  or a      ; 04 01 ; Fc=0
  sbc hl,de ; 15 02 ; n1-n2 in HL, SZVC valid

  ; negative & not OV:  HL<DE
  ; negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ; positive & not OV:  HL>=DE
  ; positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ; thus OV reverses the sense of the sign bit

  jp pe,less_than.reverse  ; if OV, jump
  ; not overflow
  jp p,false_    ; if +ve, result false
  jp true_       ; if -ve, result true

less_than.reverse:
  ; overflow
  jp m,false_    ; if -ve, result false
  jp true_       ; if +ve, result true

; ----------------------------------------------
  _code_header u_greater_than_,'u>'

; doc{
;
; u> ( u1 u2 -- f ) "u-greater-than"
;
; _f_ is true if and only if _u1_ is greater than _u2_.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `>`, `u<`, `0>`, `umax`.
;
; }doc

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'u<'

; doc{
;
; u< ( u1 u2 -- f ) "u-less-than"
;
; _f_ is true if and only if _u1_ is less than _u2_.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `<`, `u>`, `0<` ,`umin`.
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth.

  pop de
  pop hl
u_less_than.de_hl:
  or a            ; Fc=0
  sbc hl,de
  sbc a,a         ; propagate Fc through A
  ld h,a
  ld l,a          ; HL = $0000 (false) or $FFFF (true)
  push hl
  _jp_next

; ----------------------------------------------
  _code_header greater_than_,'>'

; doc{
;
; > ( n1 n2 -- f ) "greater-than"
;
; _f_ is true if and only if _n1_ is greater than _n2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `<`, `u>`, `0>`, `max`.
;
; }doc

  pop hl
  pop de
  jp less_than.de_hl

; ----------------------------------------------
  _code_header rot_,'rot'

; doc{
;
; rot ( x1 x2 x3 -- x2 x3 x1 )
;
; Rotate the top three stack entries.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `-rot`, `over`, `tuck`, `swap`, `roll`, `pick`.
;
; }doc

  pop de
  pop hl
  ex (sp),hl
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header space_,'space'

; doc{
;
; space ( -- )
;
; Display one space.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `bl`, `emit`.
;
; }doc

  dw b_l_,emit_
  dw exit_

; ----------------------------------------------
  _code_header question_dup_,'?dup'

; doc{
;
; ?dup ( x -- 0 | x x ) "question-dup"
;
; Duplicate _x_ if it is non-zero.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `dup`, `0dup`, `-dup`.
;
; }doc

  pop hl
  ld a,h
  or l
  jp z,push_hl
  push hl
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header latest_,'latest'

; doc{
;
; latest ( -- nt )
;
; _nt_ is the name token of the last word defined is the system.
;
; Definition:

; ----
; : latest ( -- nt ) last @ ;
; ----

; Origin: Gforth.
;
; See: `last`, `current-latest`, `fyi`.
;
; }doc

  dw last_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header current_latest_,'current-latest'

; doc{
;
; current-latest ( -- nt )
;
; _nt_ is the name token of the topmost word in the current
; compilation word list.
;
; Definition:

; ----
; : current-latest ( -- nt ) get-current @ ;
; ----

; Origin: fig-Forth's ``latest``.
;
; See: `latest`, `fyi`.
;
; }doc

  dw get_current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header latestxt_,'latestxt'

; doc{
;
; latestxt ( -- xt ) "latest-x-t"
;
; Leave the execution token of the last word defined.
;
; Origin: Gforth.
;
; }doc

  dw lastxt_,fetch_
  dw exit_

; ----------------------------------------------
  _c_constant_header banks_,'banks'

; doc{
;
; banks ( -- n )
;
; A `cconstant`. _n_ is the number of 16-KiB RAM memory
; banks:

; |===
; | Computer          | Banks
;
; | ZX Spectrum 128  >|     8
; | ZX Spectrum +2   >|     8
; | ZX Spectrum +2A  >|     8
; | ZX Spectrum +2B  >|     8
; | ZX Spectrum +3   >|     8
; | ZX Spectrum +3e  >|     8
; | Pentagon 128     >|     8
; | Scorpion ZS 256  >|    16
; | Pentagon 512     >|    32
; | Pentagon 1024    >|    64
; |===
;
;
; See: `bank`, `far-banks`, `default-bank`, `ram`.
;
; }doc

banks: equ (pentagon+scorpion+128*(!(pentagon || scorpion) and 1))/16

  ; XXX REMARK -- The calculation above is equivalent to the
  ; following code:
  ;
  ; if pentagon
  ;   banks: equ pentagon/16
  ; else
  ;   if scorpion
  ;     banks: equ scorpion/16
  ;   else
  ;     banks: equ 128/16
  ;   endif
  ; endif

  db banks

; ----------------------------------------------
  _constant_header ram_,'ram'

; doc{
;
; ram ( -- n )
;
; A `constant`. _n_ is the total RAM size in kibibytes.
;
; NOTE: On G+DOS, the RAM size includes the 8 KiB of the Plus D
; interface.
;
; See: `banks`.
;
; }doc

ram_kib: equ banks*16+(8*(gplusdos and 1))

  dw ram_kib

; ----------------------------------------------
  _code_header default_bank_,'default-bank'

; doc{
;
; default-bank ( -- )
;
; Page in the default memory `bank`, wich can be configured with
; `default-bank#`, at $C000 .. $FFFF.
;
; See: `banks`.
;
; }doc

  push ix           ; make next `ret` jump to `next`

bank.default:

  ; Page in the default memory bank at $C000..$FFFF.

  ; Output:
  ;   A E corrupted

  ; WARNING -- In order to make this routine usable by `code`
  ; words, its address is returned by the
  ; `default-bank_` constant, which is defined in the
  ; library. The actual address is calculated using an offset
  ; from the execution token of `default-bank`.

address_of_default_bank: equ $+1
  ld e,default_bank

bank.e:

  ; Page in the memory bank hold in the E register at
  ; $C000..$FFFF.

  ; Input:
  ;   E = bank number
  ;       On 128-KiB computers:  0 .. 7
  ;       On 256-KiB computers:  0 .. 15
  ;       On 512-KiB computers:  0 .. 31
  ;       On 1024-Kib computers: 0 .. 63
  ; Output:
  ;   A = corrupted
  ;   D = corrupted (only on Pentagon 512 and Pentagon 1024)

  ; WARNING -- In order to make this routine usable by `code`
  ; words, its address is returned by the `e-bank_`
  ; constant, which is defined in the library. The actual
  ; address is calculated using an offset from the execution
  ; token of `default-bank`.

  ; The 128-KiB ZX Spectrum and Pentagon computers use bits 0 ..
  ; 2 of port $EFF7 to select the memory bank (0 .. 7) to page
  ; in at addresses $C000 .. $FFFF. The Pentagon 512 and the
  ; Pentagon 1024 use additional bits to form the number of the
  ; memory bank, as follows:

  ;                           Bits written to the port  Page range
  ;                           ------------------------  ----------
  ; ZX Spectrum 128/+2/+3     .. .. .. .. .. D2 D1 D0   0 .. 7
  ; Pentagon 128              .. .. .. .. .. D2 D1 D0   0 .. 7
  ; Pentagon 512              D7 D6 .. .. .. D2 D1 D0   0 .. 31
  ; Pentagon 1024             D7 D6 D5 .. .. D2 D1 D0   0 .. 63

if pentagon=512 or pentagon=1024

  ; This routine converts a Pentagon bank number (0 .. 31 or
  ; 0 .. 63) to the bit layout that must be written to port $EFF7.

  ld a,e        ; bank number

if pentagon=512
  ; Pentagon 512
  rla           ; shift to the left...
  rla
  rla           ; ...3 bits
  and %11000000 ; keep only bits 6 .. 7
else
  ; Pentagon 1024
  rla           ; shift to the left...
  rla           ; ...2 bits
  and %11100000 ; keep only bits 5 .. 7
endif

  ld d,a        ; save the result
  ld a,e        ; get the bank again
  and %00000111 ; only bits 0 .. 2
  or d          ; combine both parts
  ld e,a        ; done

  ; E = bank number ready to be written to the port

  ld a,(sys_bankm) ; get the saved status of BANKM
if pentagon=512
  and %00111000    ; clear the bits used by Pentagon 512
else
  and %00011000    ; clear the bits used by Pentagon 1024
endif
  or e             ; modify the bits
  di
  ld (sys_bankm),a ; update BANKM
  push bc
  ld bc,bank1_port
  out (c),a
  pop bc
  ei
  ret

else

if scorpion=256

  ; The Scorpion ZS 256 uses bits 0 .. 2 of port $EFF7 and bit 4
  ; of port $1FFD to select the memory bank (0 .. 15) to page in
  ; at $C000 .. $FFFF.

  ; Port $7FFD (adressation - 01xxxxxx xx1xxx01):
  ;
  ; D0 = bit 0 of bank number
  ; D1 = bit 1 of bank number
  ; D2 = bit 2 of bank number
  ; D3 = videoram
  ; D4 = ROM
  ; D5 = disable paging
  ; D6 = unused
  ; D7 = unused
  ;
  ; Port $1FFD (adressation - 00xxxxxx xx1xxx01):
  ;
  ; D0 = set to disable ROM and connect RAM bank 0 at $0000 .. $3FFF
  ; D4 = bit 3 of bank number
  ; D6 = unused
  ; D7 = unused

  ; E = bank number (bits 0 .. 3)

  ld a,e           ; bank number
  rla              ; shift to the left to move bit 3 to bit 4
  and %00010000    ; keep only bit 4
  ld d,a           ; save the result
  ld a,e           ; bank number
  and %00000111    ; keep only bits 0 .. 2
  ld e,a           ; save the result

  ; D = bit 4 is the higher bit (bit 3) of the bank number,
  ;     other bits clear
  ; E = bits 0 .. 2 are the lower bits of the bank number,
  ;     other bits clear

  ld a,(sys_bankm) ; get the saved status of BANKM
  and %11111000    ; clear bits used by 128 KiB computers
  or e             ; update them

  di
  push bc
  ld (sys_bankm),a ; update BANKM
  ld bc,bank1_port
  out (c),a        ; page in the bank
  ld bc,bank2_port
if true
  ; XXX TODO -- Is this needed?
  ld a,(sys_bank678)
  and %11101111
  or d
  ld (sys_bank678),a
else
  ld a,d
endif
  out (c),a        ; page in the bank
  pop bc
  ei
  ret

else

  ; Paging routine for a 128-KiB computer: ZX Spectrum 128, ZX
  ; Spectrum +2, ZX Spectrum +3, ZX Spectrum +3e or Pentagon
  ; 128.

  ; E = bank number ready to be written to the port

  ld a,(sys_bankm)   ; get the saved status of BANKM
  and %11111000      ; clear bits used by 128-KiB computers
  or e               ; update them
  di
  ld (sys_bankm),a   ; update BANKM
  push bc
  ld bc,bank1_port
  out (c),a          ; page in the bank
  pop bc
  ei
  ret

endif ; scorpion=256

endif ; pentagon=512 or pentagon=1024

; ----------------------------------------------
  _code_header far_c_fetch_,'farc@'

; doc{
;
; farc@ ( ca -- c ) "far-c-fetch"
;
; Fetch _c_ from far-memory address _ca_.
;
; See: `far-banks`.
;
; }doc

  pop hl
  call far.hl
  ld l,(hl)
  ld h,0
  push hl
  call bank.default
  _jp_next

  ; XXX TODO -- smaller alternative for `size_optimization`,
  ; jumping to `push_a`

; ----------------------------------------------
  _code_header far_c_store_,'farc!'

; doc{
;
; farc! ( c ca -- ) "far-c-store"
;
; Store _c_ into far-memory address _ca_.
;
; See: `far-banks`.
;
; }doc

  pop hl
  call far.hl
  pop de
  ld (hl),e
  call bank.default
  _jp_next

; XXX REMARK -- `farc!` could be moved to the library, because
; it's not used in the kernel, but `farc@` is, and it makes
; sense to keep both of them together.

; ----------------------------------------------
  _code_header far_fetch_,'far@'

; doc{
;
; far@ ( a -- x ) "far-fetch"
;
; Fetch _x_ from far-memory address _a_.
;
; ``far@`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : far@ ( a -- x )
;   dup 1+ far c@ >r farc@ r> join ;
; ----

; Faster but larger definition:

; ----
; : far@ ( a -- x )
;   dup 1+ far c@ >r far c@ r> join default-bank ;
; ----

; See: `far-banks`.
;
; }doc

  exx
  pop hl
  call far.hl
  ld c,(hl)
  inc hl
  call question_next_bank
  ld b,(hl)
  push bc
  call bank.default
  exx
  _jp_next

; ----------------------------------------------
  _code_header far_store_,'far!'

; doc{
;
; far! ( x a -- ) "far-store"
;
; Store _x_ into far-memory address _a_.
;
; ``far!`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : far! ( x a -- )
;   >r split r@ 1+ far c! r> farc! ;
; ----

; Faster but larger definition:

; ----
; : far! ( x a -- )
;   >r split r@ 1+ far c! r> far c! default-bank ;
; ----

; See: `far-banks`.
;
; }doc

  exx
  pop hl
  call far.hl
  pop bc
  ld (hl),c
  inc hl
  call question_next_bank
  ld (hl),b
  call bank.default
  exx
  _jp_next

; ----------------------------------------------
  _colon_header from_name_,'name>'

; doc{
;
; name> ( nt -- xt ) "name-to"
;
; Definition:

; ----
; : name> ( nt -- xt ) [ 2 cells ] literal - far@ ;
; ----

; See: `>name`, `name>body`, `name>str`, `name>string`,
; `name>immediate?`, `name>name`.
;
; }doc

  _literal 2*cell
  dw minus_,far_fetch_
  dw exit_

; ----------------------------------------------

if 0 ; XXX TMP -- for debugging

  _colon_header name_to_str_,'name>str'

; XXX REMARK -- This word is in the library. This copy is
; preserved to be activated for debugging.

; name>str ( nt -- ca len ) "name-to-s-t-r"
;
; Convert the name token _nt_ to its name string _ca len_ in
; far memory.
;
; Definition:

; ----
; : name>str ( nt -- ca len ) farcount word-length-mask and ;
; ----

  dw far_count_,word_length_mask_,and_
  dw exit_

endif

; ----------------------------------------------

if 0 ; XXX TMP -- for debugging

  _colon_header name_to_string_,'name>string'

; XXX REMARK -- This word is in the library. This copy is
; preserved to be activated for debugging.

; name>string ( nt -- ca len ) "name-to-string"
;
; Convert the name token _nt_ to its name string _ca len_
; in the `stringer`.
;
; Definition:

; ----
; : name>string ( nt -- ca len )
;   name>str allocate-stringer ( ca1 len ca )
;   2dup swap 2>r ( R: ca len ) -rot ( ca ca1 len )
;   0 ?do ( ca ca1 )
;     2dup farc@ swap i + c! char+
;   loop  2drop default-bank 2r> ;
; ----

  dw name_to_str_  ; ( ca1 len )
  dw dup_,allocate_stringer_ ; ( ca1 len ca )
  dw two_dup_,swap_,two_to_r_ ; ( R: ca len )
  dw minus_rot_ ; ( ca ca1 len )
  _literal 0
  dw paren_question_do_,name_to_string.loop_exit ; ( ca ca1 )
  dw two_dup_,far_c_fetch_,swap_,i_,plus_,c_store_,char_plus_
  dw paren_loop_
name_to_string.loop_exit:
  dw two_drop_,two_from_r_
  dw exit_

endif

; ----------------------------------------------
  _colon_header store_csp_,'!csp'

; doc{
;
; !csp ( -- ) "store-c-s-p"
;
; Save the current data stack position, `sp@`, into `csp`, to be
; checked later by `?csp`.  ``!csp`` is used by `:`, `:noname`
; and `asm` for error checking.
;
; Definition:

; ----
; : !csp ( -- ) sp@ csp ! ;
; ----

; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,store_
  dw exit_

; ----------------------------------------------
  _colon_header question_throw_,'?throw'

; doc{
;
; ?throw ( f n -- ) "question-throw"
;
; If _f_ is non-zero, `throw` exception code _n_
;
; Definition:

; ----
; : ?throw ( f n -- ) swap if throw else drop then ;
; ----

; }doc

  dw swap_
  dw question_branch_,throw_dfa
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header compiling_question_,'compiling?'

; doc{
;
; compiling? ( -- f ) "compiling-question"
;
; _f_ is true if `state` is not zero, i.e. the Forth system is
; in compilation state.
;
; Definition:

; ----
; : compiling? ( -- f ) state @ 0<> ;
; ----

; }doc

  dw state_,fetch_,zero_not_equals_
  dw exit_

  ; XXX TODO -- Rewrite in Z80.

; ----------------------------------------------
  _colon_header executing_question_,'executing?'

; doc{
;
; executing? ( -- f ) "executing-question"
;
; _f_ is true if `state` is zero, i.e. the Forth system is not
; in compilation state.
;
; Definition:

; ----
; : executing? ( -- f ) state @ 0= ;
; ----

; See: `?executing`.
;
; }doc

  ; XXX TODO -- Rewrite in Z80.

  dw state_,fetch_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header question_csp_,'?csp'

; doc{
;
; ?csp ( -- ) "question-c-s-p"
;
; If the current data stack position does not match the value
; saved by `!csp`, `throw` an exception #-264 ("definition not
; finished").
;
; // XXX TODO and `checking` is not zero.
;
; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,fetch_,not_equals_
  ; dw checking(s)_,fetch_,and_ ; XXX TODO ?
  _question_throw error.definition_not_finished
  dw exit_

; ----------------------------------------------
  _colon_header question_loading_,'?loading'

; doc{
;
; ?loading ( -- ) "question-loading"
;
; If a `block` is not being loaded, i.e., if the content of
; `blk` is zero, `throw` exception code #-265 ("loading only").
;
; See: `loading?`, `load`.
;
; }doc

  dw loading_question_,zero_equals_
  _question_throw error.loading_only
  dw exit_

; ----------------------------------------------
  _colon_header loading_question_,'loading?'

; doc{
;
; loading? ( -- f ) "loading-question"
;
; If a `block` is being loaded, i.e., if the content of
; `blk` is non-zero, return true; else return false.
;
; See: `?loading`, `load`.
;
; }doc

  dw blk_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header compile_,'compile',compile_only

; doc{
;
; compile ( -- )
;
; Compile the cell following the compilation address of
; ``compile`` into the dictionary.
;
; ``compile`` allows specific compilation situations to be
; handled in addition to simply compiling an execution token
; (which the interpreter already does).
;
; ``compile`` is a `compile-only` word.
;
; Definition:

; ----
; : compile ( -- ) r> dup cell+ >r  @ compile, ;
; ----

; Typically used in the form:

; ----
; : name compile namex ;
; ----

; When _name_ is executed, the execution token of _namex_ is
; compiled, not executed. _name_ is tipically an `immediate`
; word and _namex_ is typically not an `immediate` word.
;
; ``compile`` has been superseded by `postpone`.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set).
;
; See: `[compile]`, `compile,`.
;
; }doc

  dw from_r_,dup_,cell_plus_,to_r_,fetch_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header postpone_,'postpone',immediate

; doc{
;
; postpone ( "name" -- )
;
; Skip leading space delimiters. Parse _name_ delimited by a
; space. Find _name_. Append the compilation semantics of _name_
; to the current definition.
;
; ``postpone`` is an `immediate` word.
;
; Definition:

; ----
; : postpone ( "name" -- )
;   defined dup ?defined
;   name>immediate? 0= if compile compile then compile, ;
;   immediate
; ----

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `[compile]`, `compile`, `defined`, `?defined`,
; `name>immediate?`, `compile,`, `0if`.
;
; }doc

  ; XXX REMARK -- `postpone` could be moved to the library, but
  ; it's used by 156 words in 39 library modules.

  dw defined_ ; ( nt | 0 )
  dw dup_,question_defined_ ; error if not found
  ; ( nt )
  dw name_to_immediate_question_ ; ( xt f )
  dw question_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw compile_comma_ ; compile xt
  dw exit_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

; doc{
;
; [ ( -- ) "left-bracket"
;
; Enter interpretation `state`.
;
; ``[`` is an `immediate` word.
;
; Definition:

; ----
; : [ ( -- ) state off ; immediate
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `]`.
;
; }doc

  dw state_,off_
  dw exit_

; ----------------------------------------------
  _colon_header right_bracket_,']'

; doc{
;
; ] ( -- ) "right-bracket"
;
; Enter compilation `state`.
;
; Definition:

; ----
; : ] ( -- ) state on ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `[`, `]l`, `]2l`, `]cl`, `]xl`.
;
; }doc

  dw state_,on_
  dw exit_

; ----------------------------------------------
  _colon_header revealed_,'revealed'

; doc{
;
; revealed ( nt -- )
;
; Reveal the definition _nt_ by resetting its `smudge` bit.
;
; See: `reveal`, `hidden`.
;
; }doc

  dw smudge_mask_,swap_
  dw far_,c_reset_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header reveal_,'reveal'

; doc{
;
; reveal ( -- )
;
; Reveal the `latest` definition by resetting its `smudge` bit.
;
; Definition:

; ----
; : reveal ( -- ) latest revealed ;
; ----

; See: `revealed`, `hide`.
;
; }doc

  dw latest_,revealed_
  dw exit_

; XXX TODO -- Improve after Gforth:
;
; : reveal
;   last?
;   IF     dup @ 1 and
;          IF     dup @ 1 xor 2dup >r name>string r> check-shadow dup 0 + @ 4 +
;                 perform
;          ELSE   drop
;          THEN
;   THEN ;
;
; : last?
;   latest ?dup ;

; ----------------------------------------------
  _colon_header hidden_,'hidden'

; doc{
;
; hidden ( nt -- )
;
; Hide the definition _nt_ by setting its `smudge` bit.
;
; Definition:

; ----
; : hidden ( nt -- ) smudge-mask swap lex! ;
; ----

; See: `revealed`, `hide`, `smudge-mask`, `lex!`.
;
; }doc

  dw smudge_mask_,swap_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header hide_,'hide'

; doc{
;
; hide ( -- )
;
; Hide the `latest` definition by setting its `smudge` bit.
;
; Definition:

; ----
; : hide ( -- ) latest hidden ;
; ----

; See: `hidden`, `reveal`.
;
; }doc

  dw latest_,hidden_
  dw exit_

; ----------------------------------------------
  _c_constant_header word_length_mask_,'word-length-mask'

; doc{
;
; word-length-mask ( -- b )
;
; A `cconstant`. _b_ is the bitmask of the word length.
;
; See: `smudge-mask`, `immediate-mask`, `compile-only-mask`.
;
; }doc

  db word_length_mask

; ----------------------------------------------
  _c_constant_header smudge_mask_,'smudge-mask'

; doc{
;
; smudge-mask ( -- b )
;
; A `cconstant`. _b_ is the bitmask of the `smudge` bit.
;
; See: `word-length-mask`, `immediate-mask`,
; `compile-only-mask`.
;
; }doc

  db smudge_mask

; ----------------------------------------------
  _colon_header hex_,'hex'

; doc{
;
; hex ( -- )
;
; Set contents of `base` to sixteen.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (CORE EXT), Forth-2012
; (CORE EXT).
;
; See: `decimal`, `binary`.
;
; }doc

  _literal $10
  dw branch_,base_store

; ----------------------------------------------
  _colon_header decimal_,'decimal'

; doc{
;
; decimal ( -- )
;
; Set contents of `base` to ten.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `hex`, `binary`.
;
; }doc

  _literal $0A
base_store:
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;code'

; doc{
;
; (;code ( -- ) ( R: a -- ) "paren-semicolon-code"
;
; Rewrite the code field of the most recently defined high-level
; word (it cannot be a `code` word) to point to the following
; machine code sequence, which is at _a_.
;
; ``(;code`` is the run-time procedure compiled by `;code` and
; `does>`.
;
; Definition:

; ----
; : (;code ( -- ) ( R: a -- ) r> latestxt 1+ ! ;
; ----

; See: `latestxt`.
;
; }doc

  dw from_r_,latestxt_,one_plus_,store_
  dw exit_

; ----------------------------------------------
  _colon_header does_,'does>',immediate+compile_only

; doc{
;
; does> "does"
;   Compilation: ( -- )
;   Run-time:    ( -- ) ( R: nest-sys -- )
;
; Define the execution-time action of a word created by a
; high-level defining word.  Used in the form:

; ----
; : namex ... create ... does> ... ;
;
; namex name
; ----

; where `create` could be also any user defined word which
; executes `create`.

; ``does>`` marks the termination of the defining part of the
; defining word _namex_ and then begins the definition of the
; execution-time action for words that will later be defined by
; _namex_.  When _name_ is later executed, the address of
; _name_'s parameter field is placed on the stack and then the
; sequence of words between ``does>`` and `;` are executed.
;
; ``does>`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : does> \ Compilation: ( -- )
;         \ Run-time:    ( -- ) ( R: nest-sys -- )
;   postpone (;code docolon call, ; immediate compile-only
; ----

; Detailed description:
;
; Compilation:
;
; Append the run-time  semantics below to the current
; definition.  Append the initiation semantics given below to
; the current definition.
;
; Run-time:
;
; Replace the execution semantics of the  most recent
; definition, referred to as _name_, with the _name_ execution
; semantics given  below. Return  control  to the  calling
; definition  specified  by _nest-sys1_.
;
; Initiation: ``( i*x -- i*x dfa ) ( R: -- nest-sys2 )``
;
; Save information _nest-sys2_  about the calling definition.
; Place _name_'s data field address _dfa_ on the stack. The
; stack effects _i*x_ represent arguments to name.
;
; _name_ execution: ``( i*x -- j*x )``
;
; Execute the portion of the definition  that begins with the
; initiation  semantics appended by the ``does>``  which
; modified _name_. The stack effects _i*x_ and _j*x_ represent
; arguments to and results from _name_, respectively.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `;`, `;code`, `create`, `(;code`, `call,`.
;
; }doc

  dw compile_,paren_semicolon_code_
  dw do_colon_,call_comma_
  dw exit_

; ----------------------------------------------
  _code_header far_count_,'farcount'

; doc{
;
; farcount ( ca1 -- ca2 len2 )
;
; A variant of `count` that works with far-memory addresses.
;
; See: `far-banks`.
;
; }doc

  pop hl
  inc hl
  push hl
  dec hl
  call far.hl
  ld d,0
  ld e,(hl)
  push de
  call bank.default
  _jp_next

; ----------------------------------------------
  _code_header count_,'count'

; doc{
;
; count ( ca1 -- ca2 len2 )
;
; Return the character string specification for the counted
; string stored at _ca1_. _ca2_ is the address of the first
; character after _ca1_. _len_ is the  contents of the character
; at _c1_, which is the  length in characters of the string at
; _c2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `farcount`.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
push_ahl:
  push hl
  jp push_a

; ----------------------------------------------
  _code_header bounds_,'bounds'

; doc{
;
; bounds ( ca len -- ca2 ca )
;
; Convert the string identifier _ca len_ to _ca2 ca_, being
; _ca2_ the address after the last character of the string.
; _ca2 ca_ are the parameters needed by `do` or `?do` to
; traverse the string _ca len_.
;
; ``bounds`` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : bounds ( ca len -- ca2 ca ) over + swap ;
; ----

; Origin: Comus.
;
; See: `count`.
;
; }doc

                ;  T  B
                ; -- --
  pop hl        ; 10 01
  pop de        ; 10 01
  add hl,de     ; 11 01
  push hl       ; 11 01
  push de       ; 11 01
  _jp_next      ; 08 02 = jp (ix)
                ; -- --
                ; 61 07

; ----------------------------------------------
  _colon_header type_,'type'

; doc{
;
; type ( ca len -- )
;
; If _len_ is greater than zero, display the character string
; _ca len_.
;
;----
; : type ( ca len -- )
;   bounds ?do i c@ emit loop ;
;----

; See: `type-udg`.
;
; }doc

  dw bounds_
  dw paren_question_do_,type.loop_exit ; ?do
  dw i_,c_fetch_,emit_
  dw paren_loop_ ; loop
type.loop_exit:
  dw exit_

; ----------------------------------------------

  _code_header minus_trailing_,'-trailing'

; doc{
;
; -trailing ( ca1 len1 -- ca2 len2 ) "minus-trailing"
;
; Adjust the length of a string _ca1 len1_ to suppress the
; trailing blanks, returning the result _ca2 len2_.
;
; If _len_ is greater  than zero, _len2_ is  equal to _len1_
; less the number of spaces  at the end of  the character string
; specified by _ca1 len1_. If _len1_ is zero or the entire
; string consists of spaces, _len2_ is zero.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `-leading`, `trim`.
;
; }doc

  ; XXX REMARK -- `-trailing` cannot be moved to the library,
  ; because `new-needed-word` needs it.

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
                          ; DE = address after the string
                          ; HL = length of the string
minus_trailing.begin:
  ld a,l
  or h                    ; exhausted?
  jp z,push_hl
  dec de                  ; next character
  ld a,(de)
  cp ' '                  ; space?
  jp nz,push_hl
  dec hl                  ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header minus_leading_,'-leading'

; doc{
;
; -leading ( ca1 len1 -- ca2 len2 ) "minus-leading"
;
; Adjust the start and length of a string _ca1 len1_ to suppress
; the leading blanks, returning the result _ca2 len2_.
;
; Definition:

; ----
; : -leading ( ca len -- ca' len' ) bl skip ;
; ----

; See: `-trailing`, `trim`, `bl`, `skip`.
;
; }doc

  dw b_l_,skip_
  dw exit_

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(."'

; doc{
;
; (." ( -- ) "paren-dot-quote"
;
; Type the compiled string that follows. ``(."`` is the
; run-time procedure compiled by `."`.
;
; Definition:

; ----
; : (." ( -- ) r@ count dup char+ r> + >r type ;
; ----

; See: `,"`, `type`, `count`.
;
; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,char_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_

  ; XXX TODO --
  ;   `r@ count dup char+ r> + >r` is what `slit` does, but
  ;   calling `slit` here cannot work.
  ;   See `string-param` in the library for a possible factor

  dw exit_

; ----------------------------------------------
  _colon_header comma_quote_,',"'

; doc{
;
; ," ( "ccc<quote>" -- ) "comma-quote"
;
; Parse "ccc" delimited by a double-quote and compile the
; string.
;
; Definition:

; ----
; : ," ( -- ) '"' parse s, ;
; ----

; See: `parse`, `s,`, `far,"`.
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  _literal '"'
  dw parse_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate+compile_only

; doc{
;
; ." "dot-quote"
;   Compilation: ( "ccc<quote>" -- )
;   Run-time: ( -- )

; Parse "ccc" delimited by a double-quote and compile the
; corresponding string and the execution procedure `(."`, which
; will display it at run-time.
;
; ``."`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : ." ( "ccc<quote> -- ) compile (." ," ; immediate
; ----

; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `s"`, `.(`, `,"`.
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  dw compile_,paren_dot_quote_,comma_quote_
  dw exit_

; ----------------------------------------------
  _defer_header accept_,'accept',,simple_accept_

; doc{
;
; accept ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when an implementation-defined line
; terminator is received. When input terminates, nothing is
; appended to the string or displayed on the screen.
;
; _len2_ is the length of the string stored at _ca1_.
;
; In Solo Forth ``accept`` is a deferred word. Its default
; action is `simple-accept`, which provides only the basic
; editing options. Alternative definitions are provided in the
; library.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header simple_accept_,'simple-accept'

; doc{
;
; simple-accept ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when the Return key is pressed.  When input
; terminates, nothing is appended to the string or displayed on
; the screen.
;
; The only control key accepted is Delete.
;
; _len2_ is the length of the string stored at _ca1_.
;
; ``simple-accept`` is the default action of the deferred word
; `accept`.
;
; Definition:

; ----
; : simple-accept ( ca len -- len' )
;   over + over ( bot eot cur )
;   begin  xkey dup 13 <> \ not carriage return?
;   while ( bot eot cur c )
;     dup 12 =  \ delete?
;     if    drop  >r over r@ < dup  \ any chars?
;           if  8 dup emit  bl emit  emit  then  r> +
;     else  \ maybe printable
;           >r  2dup <>  \ more?
;           r@ [ bl 1- ] literal > and  \ and printable?
;           if  r@ over c!  char+  r@ emit  then  r> drop
;     then
;   repeat ( bot eot cur c ) drop nip swap - ;
; ----

; See: `query`.
;
; }doc

  ; Credit:
  ;
  ; Code adapted from eForth.

  dw over_,plus_,over_
simple_accept.begin:                                   ; begin
  dw xkey_,dup_
  _literal carriage_return_char
  dw not_equals_
  dw zero_branch_,simple_accept.end                    ; while
  dw dup_
  _literal delete_char
  dw equals_                                           ; delete?
  dw zero_branch_,simple_accept.printable              ; if
  dw drop_,to_r_,over_,r_fetch_,less_than_,dup_        ; any chars?
  dw zero_branch_,simple_accept.delete_end             ; if
  _literal backspace_char
  dw dup_,emit_,b_l_,emit_,emit_
simple_accept.delete_end:                              ; then
  dw from_r_,plus_
  dw branch_,simple_accept.repeat
simple_accept.printable:                               ; else
  ; printable
  dw to_r_,two_dup_,not_equals_                        ; more?
  dw r_fetch_
  _literal space_char-1
  dw greater_than_,and_                                ; and printable?
  dw zero_branch_,simple_accept.printable_end          ; if
  dw r_fetch_,over_,c_store_,char_plus_,r_fetch_,emit_
simple_accept.printable_end:                           ; then
  dw r_drop_
simple_accept.repeat:
  dw branch_,simple_accept.begin                       ; repeat
simple_accept.end:
  ; ( bot eot cur c )
  dw drop_,nip_,swap_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header query_,'query'

; doc{
;
; query ( -- )
;
; Make the user input device the input source. Receive input
; into the terminal input buffer, replacing any previous
; contents. Make the result, whose address is returned by `tib`,
; the input buffer. Set `>in` to zero.
;
; The function of ``query`` may be performed with `accept` and
; `evaluate`.
;
; Definition:

; ----
; : query ( -- )
;   tib /tib 2dup blank accept #tib ! space terminal>source ;
; ----

; Origin: fig-forth, Forth-79 (Required Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (CORE EXT,
; obsolescent).
;
; }doc

  ; XXX TODO -- Document: `query` didn't work exactly the same
  ; way in fig-Forth, Forth-79 and Forth-83.

; XXX OLD -- old descriptions:
;
; Input 80 characters of text (or until a "return") from the
; operators terminal. Text is positioned at the address
; contained in TIB with IN set to zero.
;
; Transfer characters from the terminal to address returned by
; `tib`, until a "return" or the count contained in the `#tib`
; variable have been received. One or more nulls are added at
; the end of the text.
;
  ; XXX TODO -- Move to the library, when possible.

  dw tib_,slash_tib_
  dw two_dup_,blank_ ; clean the input buffer
  dw accept_,number_sign_tib_,store_,space_
  dw terminal_to_source_
  dw exit_

; ----------------------------------------------
  _constant_header paren_source_id_,'(source-id'

; doc{
;
; (source-id ( -- a ) "paren-source-i-d"
;
; A `constant`. _a_ is the address of a cell containinig the value
; returned by `source-id`.
;
; }doc

  dw source_id_dfa

; ----------------------------------------------
  _constant_header source_id_,'source-id'

; doc{
;
; source-id ( -- 0 | -1 ) "source-i-d"
;
; Identify the input source as follows:
;
; |===
; |  0 | User input device
; | -1 | String via `evaluate`
; |===
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

; XXX TODO -- Forth-2012: "An ambiguous condition exists if
; `source-id is used when `blk` contains a non-zero value."

  dw 0

; ----------------------------------------------
  _variable_header number_sign_block_drives_,'#block-drives'

; doc{
;
; #block-drives ( -- ca ) "number-sign-block-drives"
;
; A `cvariable`. _ca_ is the address of a byte containing
; the number of block drives defined in `block-drives`, i.e. the
; number of drives that are used for blocks.  ``#block-drives``
; could be modified manually, provided also `block-drives` is
; configured accordingly, but `set-block-drives` is provided for
; that.
;
; The default value of ``#block-drives`` is 1, which is restored
; by `cold`.
;
; See: `max-blocks`.
;
; }doc

  db 1

; ----------------------------------------------
  _colon_header max_blocks_,'max-blocks'

; doc{
;
; max-blocks ( -- u )
;
; Return the number _u_ of maximum blocks available in the
; system. The number depends on `#block-drives` and
; `blocks/disk`.
;
; }doc

  dw blocks_slash_disk_,number_sign_block_drives_,c_fetch_,star_
  dw exit_

; ----------------------------------------------
  _colon_header block_question_,'block?'

; doc{
;
; block? ( u -- f ) "block-question"
;
; _f_ is true if _u_ is a valid `block` number.
;
; Definition:

; ----
; : block? ( u -- f ) max-blocks u< ;
; ----

; }doc

  dw max_blocks_,u_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header refill_,'refill'

; doc{
;
; refill ( -- f )
;
; Definition:

; ----
; : refill ( -- f )
;   loading? if  blk @ 1+ dup block>source block? exit  then
;   false source-id ?exit 0= query ;
; ----

; Origin: Forth-94 (CORE EXT, BLOCK EXT); Forth-2012 (CORE EXT,
; BLOCK EXT).
;
; }doc

  ; XXX INFORMER {{{
  ; dw paren_dot_quote_
  ; _string "REFILL "
  ; XXX INFORMER }}}

  dw loading_question_ ; input source is a block?
  dw zero_branch_,refill.not_loading ; if not, branch

refill.block:
  dw blk_,fetch_,one_plus_,dup_,block_to_source_
  dw block_question_
  dw exit_

refill.not_loading:
  dw false_,source_id_,question_exit_
  dw zero_equals_,query_
  dw exit_

; ----------------------------------------------
  _code_header fill_,'fill'

; doc{
;
; fill ( ca len b -- )
;
; If _len_ is greater than zero, store _b_ in each of _len_
; consecutive bytes of memory beginning at _ca_.
;
; Origin: fig-Forth, Forth-83 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; See: `erase`, `farfill`, `move`.
;
; }doc

  exx                 ; save the Forth IP
  pop bc
  ld a,c              ; A = character
fill.a:
  pop bc              ; BC = count
  pop de              ; DE = address

  ld hl,$FFFF
  or a                ; Fc = 0
  adc hl,bc           ; test for count=0 or 1
  jr nc,fill.done     ; no Fc: count=0, skip
  ld (de),a           ; fill first byte
  jr z,fill.done      ; z: count=1, done
  dec bc              ; else adjust count
  ld h,d
  ld l,e              ; HL = start address
  inc de              ; DE = start address+1
  ldir                ; copy (HL)->(DE)
fill.done:
  exx                 ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header erase_,'erase'

; doc{
;
; erase ( ca len -- )
;
; If _len_ is greater than zero, clear all bits in each ol _len_
; consecutive bytes of memory beginning at _ca_.
;
; Origin: fig-Forth, Forth-83 (Controlled Reference Words), Forth-94
; (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `fill`, `move`.
;
; }doc

  exx
  xor a
  jp fill.a

; ----------------------------------------------
  _code_header blank_,'blank'

; doc{
;
; blank ( ca len -- )
;
; If _len_ is greater than zero, store the character value for
; space (`bl`) in _len_ consecutive character positions of
; memory beginning at _ca_.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  exx
  ld a,space_char
  jp fill.a

; ----------------------------------------------
  _colon_header hold_,'hold'

; doc{
;
; hold ( c -- )
;
; Insert character _c_ into a pictured numeric output string.
; Typically used between `<#` and `#>`.
;
; Definition:

; ----
; : hold ( c -- ) -1 hld +!  hld @ c! ;
; ----

; See: `holds`.
;
; }doc

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw exit_

; ----------------------------------------------
  _c_constant_header slash_hold_,'/hold'

; doc{
;
; /hold ( -- len ) "slash-hold"
;
; A 'cconstant`. _len_ is the length of the pictured
; output string buffer, which is located right below `pad`.
;
; The default value of ``/hold`` is 80. It may be changed by
; `c!>`.
;
; See: `hld`, `<#`, `/pad`.
;
; }doc

  db 80

; ----------------------------------------------
  _colon_header pad_,'pad'

; doc{
;
; pad ( -- ca )
;
; _ca_ is the address of a transient region that can be used to
; hold data for intermediate processing. It's a fixed offset
; (`/hold` bytes) above `here`.
;
;
; Definition:

; ----
; : pad ( -- ca ) here /hold + ;
; ----

; ``pad`` is  specifically intended as  a programmer
; convenience. No standard words use it.

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE EXT), Forth-2012 (CORE
; EXT).
;
; See: `/pad`.
;
; }doc

  dw here_,slash_hold_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header stream_,'stream'

; doc{
;
; stream ( -- ca len )
;
; String _ca len_ is the the remaining stream `source`.
;
; Definition:

; ----
; : stream ( -- ca len ) source >in @ /string ;
; ----

; See: `>in`, `/string`.
;
; }doc

  dw source_,to_in_,fetch_,slash_string_
  dw exit_

; ----------------------------------------------
  _code_header one_slash_string_,'1/string'

; doc{
;
; 1/string ( ca1 len1 -- ca1+1 len1-1 ) "one-slash-string"
;
; Adjust the character string _ca1 len1_ by 1 character.
;
; ``1/string`` is equivalent to the idiom ``1 /string`` but
; faster (0.9 the execution time).
;
; See: `/string`.
;
; }doc

  ld hl,1
  push hl

  ; Execution continues in `/string`:

; ----------------------------------------------
  _code_header slash_string_,'/string'

; doc{
;
; /string ( ca1 len1 n -- ca2 len2 ) "slash-string"
;
; Adjust the character string _ca1 len1_ by _n_ characters.  The
; resulting character string _ca2 len2_ begins at _ca1_ plus _n_
; characters and is _len1_ minus _n_ characters long.
;
; ``/string`` is written in Z80. Equivalent definitions in Forth
; are the following:

; ----
; : /string ( ca1 len1 n -- ca2 len2 ) rot over + -rot - ;
; ----

; ----
; : /string ( ca1 len1 n -- ca2 len2 ) dup >r - swap r> + swap ;
; ----

; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `1/string`, `-prefix`, `string/`.
;
; }doc

  pop de                  ; n
  pop hl                  ; len1
  and a                   ; Fc=0
  sbc hl,de               ; HL=len2
  ex (sp),hl              ; (SP)=len2 HL=ca1
  add hl,de               ; HL=ca2
  ex (sp),hl              ; (SP)=ca2 HL=len2
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header parsed_,'parsed'

; doc{
;
; parsed ( len -- )
;
; Add the given _len_ to `>in`.
;
; Definition:

; ----
; : parsed ( len -- ) >in +! ;
; ----

; See: `parse`.
;
; }doc

  dw to_in_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_,'parse'

; doc{
;
; parse ( char "ccc<char>" -- ca len )
;
; Parse _ccc_ delimited by the delimiter _char_.  _ca_ is the
; address (within the input buffer) and _len_ is the length of
; the parsed string. If the parse area was empty, the resulting
; string has a zero length.
;
; Definition:

; ----
; : parse ( char "ccc<char>" -- ca len )
;   stream 2dup 2>r rot scan
;   dup if  char-  then
;   2r> rot - parsed
;   tuck - ;
; ----

; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `stream`, `scan`, `parsed`, `parse-name`, `parse-char`,
; `parse-string`.
;
; }doc

  dw stream_,two_dup_,two_to_r_,rot_,scan_
  dw dup_,zero_branch_,parse.end
  dw char_minus_
parse.end:
  dw two_from_r_,rot_,minus_
  dw parsed_
  dw tuck_,minus_
  dw exit_

; ----------------------------------------------
  _two_variable_header parsed_name_,'parsed-name'

; doc{
;
; parsed-name ( -- a )
;
; A `variable`. _a_ is the address of a double cell containing the
; address and length of the most recently name parsed by
; `parse-name`. It is displayed by `.error-word`.
;
; As a special case, ``parsed-name`` is set also by `?located`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _defer_header header_,'header',,input_stream_header_

; doc{
;
; header ( "name" | -- )
;
; A deferred word that creates a dictionary header.  Its default
; action is `input-stream-header`, and it's set by
; `default-header`. Its alternative temporary action is
; `nextname-header`.
;
; See: `header,`, `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header input_stream_header_,'input-stream-header'

; doc{
;
; input-stream-header ( "name" -- )

; Create a dictionary header _name_.
;
; Definition:

; ----
; : input-stream-header ( "name" -- )
;   parse-name dup 0= #-16 ?throw header, ;
; ----

; See: `header`, `header,`, `nextname-header`, `parse-name`.
;
; }doc

if 0 ; XXX TMP -- for debugging
  dw cr_
  dw blk_,fetch_,dot_
  dw latest_,question_dup_
  dw zero_branch_,input_stream_header.no_name
  dw dot_name_
input_stream_header.no_name:
  dw np_fetch_,u_dot_
  ; dw key_,drop_
endif

  dw parse_name_,dup_,zero_equals_
  _question_throw error.zero_length_name
  dw header_comma_
  dw exit_

; ----------------------------------------------
  _colon_header default_header_,'default-header'

; doc{
;
; default-header ( -- )

; Set `header` to its default action: `input-stream-header`.
;
; Definition:

; ----
; : default-header ( -- )
;   ['] input-stream-header ['] header defer! ;
; ----

; }doc

  _literal input_stream_header_
  _literal header_
  dw defer_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_name_,'parse-name'

; doc{

; parse-name ( "name"  -- ca len )
;
; Parse _name_ and return it as string _ca len_ within the input
; buffer. If the parse area is empty or contains only white
; space, the _len_ is zero.
;
; Definition:

; ----
; : parse-name ( "name"  -- ca len )
;   stream                ( ca0 len0 )
;   dup >r   -leading     ( ca1 len1 ) ( R: len0 )
;   over >r  bl scan      ( ca2 len2 ) ( R: len0 ca1 )
;   dup if  char-  then   \ skip trailing delimiter
;   r> r> rot -  parsed   \ update ``>in``
;   tuck -                ( ca len )
;   2dup parsed-name 2! ;
; ----

; Origin: Forth-2012 (CORE EXT).
;
; See: `parse`, `parse-name-thru`, `parse-char`, `word`,
; `parse-string`, `stream`, `scan`, `parsed`, `parsed-name`,
; `>in`, `-leading`.
;
; }doc

  dw stream_              ; ( ca len )
  dw dup_,to_r_           ; ( ca len ) ( R: len )
  dw minus_leading_       ; ( ca1 len1 ) ( R: len )
  dw over_,to_r_          ; ( ca1 len1 ) ( R: len ca1 )
  dw b_l_,scan_           ; ( ca2 len2 ) ( R: len ca1 )
  dw dup_
  dw zero_branch_,parse_name.skip
  dw char_minus_
parse_name.skip:
  dw from_r_,from_r_      ; ( ca2 len2 ca1 len )
  dw rot_,minus_          ; ( ca2 ca1 len3 )
  dw parsed_              ; ( ca2 ca1 )
  dw tuck_,minus_         ; ( ca1 len4 )
  dw two_dup_,parsed_name_,two_store_
  dw exit_

; ----------------------------------------------
  _code_header lower_,'lower'

; doc{
;
; lower ( c -- c' )
;
; Convert _c_ to lowercase _c'_.
;
; See: `lowers`, `upper`.
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl
  ld a,l
  ld hl,push_a ; exit address
  push hl      ; make next `ret` jump to push_a

ascii_lower.a:

  ; Convert the ASCII character in the 'A' register to
  ; lowercase.
  ;
  ; Note: The address of this routine is returned by the
  ; `lower_` constant, defined in the `assembler-wordlist` word
  ; list.

  cp 'A'
  ret c
  cp 'Z'+1
  ret nc
  or  %00100000
  ret

; ----------------------------------------------
  _code_header far_lowers_,'farlowers'

; XXX TMP --
; XXX TODO -- improve to save push/pop

; doc{
;
; farlowers ( ca len -- )
;
; A variant of `lowers` that works in far memory.
;
; See: `far-banks`.
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl          ; len
  ex (sp),hl      ; HL = ca
  call far.hl     ; HL = actual address; bank paged in
  pop de          ; len
far_lowers.do:
  ld a,d
  or e
  jr z,far_lowers.end
  ld a,(hl)
  call ascii_lower.a
  ld (hl),a
  inc hl
  push de
  call question_next_bank
  pop de
  dec de
  _jump far_lowers.do
far_lowers.end:
  call bank.default
  _jp_next

; ----------------------------------------------
  _colon_header undefined_question_,'undefined?'

; doc{
;
; undefined? ( ca len -- f ) "undefined-question"
;
; Find name _ca len_.  If the definition is
; not found after searching the active search
; order, return true, else return false.
;
; Definition:

; ----
; : undefined? ( ca len -- f ) find-name 0= ;
; ----

; See: `defined?`, `defined`, `find-name`.
;
; }doc

  ; XXX REMARK -- `undefined?` cannot be moved to the library,
  ; because it's used by `needed`.

  dw find_name_,zero_equals_
  dw exit_

; ----------------------------------------------
  _code_header place_,'place'

; doc{
;
; place ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ as a counted string at _ca2_.  The
; source and destination strings are permitted to overlap.
;
; ``place`` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : place ( ca1 len1 ca2 -- ) 2dup c! char+ smove ;
; ----

; See: `+place`, `smove`.
;
; }doc

  ; XXX TODO -- `place` cannote be moved to the library because
  ; it's used be `s,` Beside, the address of `move_block` should
  ; be calculated from `move` or get by a constant.

  ; Credit:
  ; Code from DZX-Forth's `packed`.

  exx         ; save Forth IP
  pop de      ; DE=ca2
  pop bc      ; BC=len1
  pop hl      ; HL=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; E=len1
  ld (hl),e
  exx         ; restore Forth IP
  _jp_next

; ----------------------------------------------
  _code_header far_place_,'farplace'

; doc{
;
; farplace ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ (which must be below memory
; address $C000) as a counted string at far-memory address
; _ca2_.
;
; See: `far-banks`, `place`.
;
; }doc

  exx                      ; save Forth IP
  pop hl                   ; HL=ca2
  call far.hl              ; HL=ca2' (actual address in far memory)
  pop bc                   ; C=len1
  pop de                   ; DE=ca1
  ld (hl),c                ; set length of the destination string
far_place.copy_char:
  inc hl
  push de
  call question_next_bank
  pop de
  ld a,(de)
  ld (hl),a
  inc de
  djnz far_place.copy_char ; jump if length is not exhausted
  call bank.default
  exx                      ; restore Forth IP
  _jp_next

; ----------------------------------------------
  _variable_header error_number_sign_,'error#'

; doc{
;
; error# ( -- a ) "error-number-sign"
;
; A `variable`. _a_ is the address of a cell containing the number
; of the last error issued by `error`.
;
; See: `error-pos`, `where`.
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'error-pos'

; doc{
;
; error-pos ( -- a )
;
; A `2variable`. _a_ is the address of a double cell
; containing the position of the last error issued by `error`,
; as follows:

; - First cell = value of `blk`
; - Second cell  = value of `>in`

; See: `error#`, `where`.

; }doc

  dw 0 ; value of `blk`
  dw 0 ; value of `>in`

; ----------------------------------------------
  _colon_header dot_error_word_,'.error-word'

; doc{
;
; .error-word ( -- ) "dot-error-word"
;
; Display the string identified by the cell pair stored in
; `parsed-name`, followed by a question mark.
;
; Definition:

; ----
; : .error-word ( -- ) parsed-name 2@ cr type ."  ? " ;
; ----

; See: `error`, `.throw`.
;
; }doc

  dw parsed_name_,two_fetch_,cr_,type_ ; last parsed word
  dw paren_dot_quote_
  _string ' ? '
  dw exit_

; ----------------------------------------------
  _colon_header error_,'error'

; doc{
;
; error ( n -- )
;
; Save the `throw` code _n_ into `error#`, and the current
; block and line into `error-pos`, to be used by `where`.  Then
; perform the action required by `throw` code _n_ as follows:
;
; If _n_ is minus-one (-1), execute `(abort`.
;
; If _n_ is minus-two (-2), perform the function `abort"`,
; displaying the message associated with the `abort"` that
; generated the `throw`.
;
; Otherwise, execute `.error-word` and `.throw` to give
; information about the  condition associated with the `throw`
; code _n_. Subsequently, execute `(abort`.
;
; ``error`` is a factor of `throw`.
;
; Definition:

; ----
; : error ( n -- )
;   dup error# !
;   >in @ blk @ error-pos 2!
;   dup -1 = if (abort then
;   dup -2 = if space abort-message 2@ type (abort then
;   .error-word .throw (abort ;
; ----

; See: `abort-message`.
;
; }doc

  ; XXX TODO -- Factor in two parts: save the data used by
  ; `where`, and `throw`.
  ;
  ; XXX TODO -- Factor the `throw` part using an execution
  ; table. Maybe some memory can be saved.

  dw dup_,error_number_sign_,store_ ; save the error number
  dw to_in_,fetch_,blk_,fetch_,error_pos_,two_store_

  dw dup_
  _literal -1
  dw equals_
  dw question_branch_,paren_abort_dfa
  ; No return from `(abort`.

  dw dup_
  _literal -2
  dw equals_
  dw zero_branch_,error.message
  dw space_,abort_message_,two_fetch_,type_,paren_abort_
  ; No return from `(abort`.

error.message:
  dw dot_error_word_,dot_throw_,paren_abort_
  ; No return from `(abort`.

; ----------------------------------------------
  _two_variable_header abort_message_,'abort-message'

; doc{
;
; abort-message ( -- a )
;
; A `2variable`. _a_ is the address of a cell pair
; containing the address and length of the `abort"` message.
;
; }doc

  dw 0,0

; ----------------------------------------------

if 0 ; XXX TMP -- for debugging

  _colon_header dot_name_,'.name'

; XXX REMARK -- This word is in the library. This copy is
; preserved to be activated for debugging.

; .name ( nt -- ) "dot-name"
;
; Display the name of the word identified by _nt_.
;
; Definition:

; ----
; : .name ( nt -- ) name>string type space ;
; ----

; Note ``.name`` is called ``.id`` or ``id.`` in other Forth
; systems.

  dw name_to_string_,type_,space_
  dw exit_

endif

; ----------------------------------------------
  _defer_header warn_,'warn',,noop_

; doc{
;
; warn ( ca len -- ca len )
;
; Check if _ca len_ already exists in the compilation word list.
; If so, and if the content of `warnings` is not zero, do a
; configurable action, usually issue a warning message.
;
; ``warn`` is a deferred word which is called by `header,` and
; whose default action is `noop`. Alternative actions are
; provided by `warn.message`, `warn.throw` and `warn-throw`.
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _constant_header number_sign_words_,'#words'

; doc{
;
; #words ( -- n ) "number-sign-words"
;
; _n_ is the number of words currently defined in the system,
; which is updated by `header,`.
;
; See: `fyi`, `greeting`, `cold`.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header header_comma_,'header,'

; doc{
;
; header, ( ca len -- ) "header-comma"
;
; Create a definition header in the name space using the name
; _ca len_ and hide it by setting its `smudge` bit.
;
; The execution token pointer of the new header points to the
; data space pointer.
;
; See: `header`, `warn`.
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.zero_length_name
  dw warn_

header_comma.continue:

  ; ( ca len )

  dw here_,lastxt_,store_ ; update `lastxt`
  dw width_,fetch_,min_
  dw tuck_ ; ( len ca len )
if debugging
  _echo "NP = xtp = "
  dw np_fetch_,u_dot_ ; XXX INFORMER
endif
  dw here_,comma_np_ ; store a pointer to the xt
if debugging
  _echo "NP = lfa = "
  dw np_fetch_,u_dot_ ; XXX INFORMER
endif
  dw current_latest_,comma_np_ ; link field
if debugging
  _echo "NP = nfa = "
  dw np_fetch_,u_dot_ ; XXX INFORMER
endif

  dw np_fetch_,dup_,to_r_ ; ( len ca len nt ) ( R: nt )
  dw far_place_ ; store the name

  dw case_sensitive_,fetch_
  dw question_branch_,header_comma.name_ready
  dw r_fetch_,far_count_,far_lowers_ ; convert the name to lowercase
header_comma.name_ready:

  dw r_fetch_
if debugging
  _echo "NP = last = "
  dw dup_,u_dot_ ; XXX INFORMER
endif
  dw get_current_,store_ ; update the current word list
  dw from_r_,last_,store_ ; update `last`

  dw hide_
  dw one_plus_,np_,plus_store_ ; update the name-space pointer with the length+1
if debugging
  _echo "NP = next xtp = "
  dw np_fetch_,u_dot_ ; XXX INFORMER
endif

  ; Update the word count
  _literal 1
  _literal number_sign_words_dfa
  dw plus_store_

  dw exit_

; ----------------------------------------------
  _colon_header create_,'create'

; doc{
;
; create ( "name" -- )

; Parse _name_.  Create  a definition for _name_.  After _name_
; is created, the data-space pointer (returned by `here`),
; points to the first byte of __name__'s data field.  When
; _name_ is subsequently executed, the address of the first byte
; of __name__'s data field is left on the stack.
;
; ``create`` does not allocate data space in __name__'s data
; field. Reservation of data field space is tipically done with
; `allot`.
;
; The execution semantics of _name_ may be expanded by using
; `does>`.
;
; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `,`, `c,`, `2,`.
;
; }doc

  ; XXX TODO -- factor `header reveal` to `visible-header`?
  ; This phrase is used also by `defer` and `alias`.
  ; new word: 9 bytes used (3 for the call, plus 3 cells)
  ; one cell saved in 3 words: 6 bytes saved

  dw header_,reveal_
  dw lit_,do_create
  dw call_comma_
  dw exit_

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _colon_header code_,'code'

; doc{
;
; code ( "name -- )
;
; Parse _name_. Create a definition for _name_, called a code
; definition, and execute `asm` to enter `assembler` mode.
;
; Definition:

; ----
; : code ( "name -- ) header asm ;
; ----

; Origin: Forth-79 (Assembler Word Set), Forth-83 (Assembler
; Extension Word Set), Forth-94 (TOOLS EXT), Forth-2012 (TOOLS
; EXT).
;
; }doc

  ; XXX TODO -- `code` and `end-code` could be moved to the are
  ; used by 382 words in 64 library modules.

  dw header_,asm_
  dw exit_

endif

; ----------------------------------------------
  _code_header compare_,'compare'

; doc{
;
; compare ( ca1 len1 ca2 len2 -- n )
;
; Compare the string _ca1 len1_ to the string _ca2 len2_. The
; strings are compared, beginning at the given addresses _ca1_
; and _ca2_, character by character, up to the length of the
; shorter string or until a difference is found. If the two
; strings are identical, _n_ is zero. If the two strings are
; identical up to the length of the shorter string, _n_ is
; minus-one (-1) if _len1_ is less than _len2_ and one (1)
; otherwise. If the two strings are not identical up to the
; length of the shorter string, _n_ is minus-one (-1) if the
; first non-matching character in the string _ca1 len1_ has a
; lesser numeric value than the corresponding character in the
; string _ca2 len2_ and one (1) otherwise.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `str=`, `str<`, `str>`.
;
; }doc

; Credit:
; Adapted from DZX-Forth

  pop de                 ; DE = len2
  pop hl                 ; HL = ca2
  ex (sp),hl             ; HL = len1 -- ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
                         ; Fc = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
                         ; DE = length of the shorter string
                         ; HL = length of the longer string
  ld l,c
  ld h,b                 ; HL = Forth IP
  pop bc                 ; BC = ca2
  ex (sp),hl             ; HL = ca1 -- save Forth IP
  push af                ; save Fc (string2 is longer than string1?)
                         ; HL = ca1
                         ; BC = ca2
                         ; DE = length of the shorter string
compare.char:
  ld a,e
  or d                   ; end of string?
  jr z,compare.match     ; is so, all chars matched
  ld a,(bc)
  cp (hl)
  jr nz,compare.no_match ; a character doesn't match
  inc hl
  inc bc
  dec de
  jp compare.char

compare.match:           ; the smaller string matches
  pop af                 ; restore Fc (string2 is longer than string1?)
  jr compare.end

compare.no_match:        ; the smaller string does not match
  pop bc                 ; discard Fc

compare.end:
  pop bc                 ; restore Forth IP
  ld hl,1
  jp c,push_hl           ; jump if string2 is longer than string1?
  dec hl                 ; 0
  jp z,push_hl           ; jump if string1 equals string2
  dec hl                 ; -1
  push hl                ; string2 is longer than string2
  _jp_next

; ----------------------------------------------
  _colon_header str_equals_,'str='

; doc{
;
; str= ( ca1 len1 ca2 len2 -- f ) "s-t-r-equals"
;
; _f_ is true if string _ca1 len1_ is lexicographically equal to
; string _ca2 len2_.
;
; Definition:

; ----
; : str= ( ca1 len1 ca2 len2 -- f ) compare 0= ;
; ----

; See: `str<>`, `str<`, `str>`, `compare`.
;
; }doc

  dw compare_,zero_equals_
  dw exit_

; ----------------------------------------------
  _code_header search_,'search'

; doc{
;
; search ( ca1 len1 ca2 len2 -- ca3 len3 f )
;
; Search the string _ca1 len1_ for the string _ca2 len2_. If _f_
; is true, a match was found at _ca3_ with _len3_ characters
; remaining.  If _f_ is false there was no match and _ca3 len3_
; is _ca1 len1_.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `compare`, `hunt`.
;
; }doc

  ; XXX REMARK -- `search` could be moved to the library, but
  ; it's used by `contains`, part of the `need` tool. Besides,
  ; the assembly would be needed to compile this word, or at
  ; least the assembler labels.

  pop de
  pop hl                      ; HL/DE=substring
  ld a,d
  or e
  jr z,search.match           ; if zero length substring, immediate match

                              ; Exchange DE and BC:
if size_optimization

  push de
  push bc
  pop de                      ; DE = Forth IP
  pop bc                      ; HL/BC=substring
                              ; 42 T 04 B
else

  ld a,e
  ld e,c
  ld c,a
  ld a,d
  ld d,b                      ; DE = Forth IP
  ld b,a                      ; HL/BC=substring
                              ; 24 T 06 B
endif

  exx
  pop bc
  pop hl                      ; HL'/BC'=main string
  push hl
  push bc

search.substring:
  ld a,b
  or c                        ; end of main string?
  jr z,search.failed          ; no match if end of main string
  exx
  ld a,(hl)
  exx
  cpir                        ; search for first substring character
  jr nz,search.failed         ; no match if not found
  dec hl                      ; backup to matching character
  inc bc
  push bc
  exx
  ex (sp),hl
  and a
  sbc hl,bc                   ; test length left against substring length
  pop hl
  exx
  jr c,search.failed          ; no match if not long enough
  push hl
  exx
  ex de,hl
  ex (sp),hl                  ; save IP, get HL=main string, DE=substring
  push de                     ; save substring
  push bc
search.char:
  ld a,(de)
  cp (hl)
  jr nz,search.next_substring ; stop trying if character mismatch
  inc de
  inc hl
  dec bc
  ld a,b
  or c                        ; end of substring?
  jr nz,search.char           ; for rest of substring
  pop de
  pop de                      ; discard substring
  pop bc                      ; restore IP
  pop de
  pop de                      ; discard caddr1/u1
  exx
  push hl                     ; stack caddr3/u3
  push bc
  exx
search.match:
  jp true_

search.next_substring:
  pop bc                      ; restore substring
  pop hl
  pop de                      ; restore IP
  exx
  inc hl                      ; move past first matching character
  dec bc
  jr search.substring         ; back for another try

search.failed:
  exx
  ld b,d
  ld c,e                      ; restore IP
  jp false_

; ----------------------------------------------
  _colon_header s_literal_,'sliteral',immediate+compile_only

; doc{
;
; sliteral "s-literal"
;   Compilation: ( ca1 len1 -- )
;   Run-time:    ( -- ca2 len1 )

;
; Compile `slit` and string _ca len_ in the current definition.
; At run-time `slit` will return string _ca1 len1_ as _ca2
; len1_.
;
; ``sliteral`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : sliteral ( ca len -- )
;   postpone slit s, ; immediate compile-only
; ----

; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; See: `s,`, `csliteral`.
;
; }doc

  dw compile_,s_lit_,s_comma_
  dw exit_

; ----------------------------------------------
  _code_header byte_question_,'byte?'

; doc{
;
; byte? ( x -- f ) "byte-question"
;
; _f_ is true if _x_ is an 8-bit number. Used by `xliteral`.
;
; }doc

  ; Credit:
  ; Word adapted from DZX-Forth.

  pop hl
  ld l,h
  jp zero_equals.hl

; ----------------------------------------------
  _colon_header c_literal_,'cliteral',immediate+compile_only

; doc{
;
; cliteral ( b -- ) "c-literal"
;
; Compile _b_ in the current definition.
;
; ``cliteral`` does the same as `literal` but saves one byte of
; data space and _b_ is put on the stack a bit faster (0.97 of
; execution speed).
;
; ``cliteral`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : cliteral ( b -- ) postpone clit c, ; immediate compile-only
; ----

; Origin: Comus.
;
; See: `clit`, `2literal`, `xliteral`, `]cl`.
;
; }doc

  dw compile_,c_lit_,c_comma_
  dw exit_

; ----------------------------------------------
  _colon_header literal_,'literal',immediate+compile_only

; doc{
;
; literal ( x -- )
;
; Compile _x_ in the current definition.
;
; ``literal`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : literal ( x -- ) postpone lit , ; immediate compile-only
; ----

; See: `lit`, `cliteral`, `2literal`, `xliteral`, `]l`.
;
; }doc

  dw compile_,lit_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header x_literal_,'xliteral',immediate+compile_only

; doc{
;
; xliteral ( x -- ) "x-literal"
;
; If _x_ is a byte, execute `cliteral`, else execute `literal`.
;
; ``xliteral`` is used in `interpret-table` to compile the
; single-cell literals. It is useful as an alternative to
; `literal`, in order to optimize the code when _x_ is unknown.
;
; ``xliteral`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : xliteral ( x -- )
;   dup byte? if   postpone cliteral exit
;             then postpone literal ; immediate compile-only
; ----

; See: `2literal`, `]xl`, `byte?`.
;
; }doc

  dw dup_,byte_question_
  dw zero_branch_,literal_dfa
  dw branch_,c_literal_dfa

; ----------------------------------------------
  _colon_header two_literal_,'2literal',immediate+compile_only

; doc{
;
; 2literal ( x1 x2 -- ) "two-literal"
;
; Compile _x1 x2_ in the current definition.
;
; ``2literal`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : 2literal ( x1 x2 -- ) postpone 2lit 2, ; immediate compile-only
; ----

; See: `2lit`, `literal`, `cliteral`, `xliteral`, `]2l`.
;
; }doc

  dw compile_,two_lit_,two_comma_
  dw exit_

; ----------------------------------------------

if 0 ; developing

  _colon_header depth_,'depth'

  ; XXX REMARK -- This word is in the library. This copy is
  ; preserved to be activated for debugging.

; depth  ( -- +n )
;
; _+n_ is the number of single-cell values contained in the data
; stack before _+n_ was placed on the stack.
;
; Definition:

; ----
; : depth  ( -- +n ) sp@ sp0 @ - [ cell negate ] literal / ;
; ----

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw exit_

endif

; ----------------------------------------------

if 0

  ; XXX UNDER DEVELOPMENT

  _colon_header question_dictionary_,'?dictionary'

;
; ?dictionary ( -- )
;
; `throw` an error if the dictionary is out of bounds.
;

  _literal 0 ; XXX TMP
  _question_throw error.dictionary_overflow
  dw exit_

endif

; ----------------------------------------------
  _colon_header question_stack_,'?stack'

; doc{
;
; ?stack ( -- ) "question-stack"
;
; `throw` an error if the data stack is out of bounds.
;
; Origin: fig-Forth.
;
; See: `?rstack`.
;
; }doc

  ; XXX TODO -- Simplify?: check only underflow; use `depth`.

  ; XXX REMARK -- `sp@ sp0 @ swap <` cannot be replaced by `sp0
  ; @ sp@ <`, because `sp@` must be first in order to not
  ; include the cell added by `sp0 @`. `-cell` or `>=` could be
  ; used to adjust the calculation as well.

  dw sp_fetch_,sp0_,fetch_
  dw swap_,less_than_
  _question_throw error.stack_underflow
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_throw error.stack_overflow
  dw exit_

; ----------------------------------------------
  _colon_header question_r_stack_,'?rstack'

; doc{
;
; ?rstack ( -- ) "question-r-stack"
;
; `throw` an error if the return stack is out of bounds.
;
; Origin: fig-Forth's ``?stack``.
;
; See: `?stack`.
;
; }doc

  dw rp0_,fetch_
  dw rp_fetch_
  dw less_than_
  _question_throw error.return_stack_underflow

if 0
  dw rp_fetch_
  _literal return_stack_limit+8*cell
  ; XXX REMARK -- adding less than 8 cells doesn't work
  dw less_than_,zero_equals_
else
  _literal return_stack_limit+7*cell
  ; XXX REMARK -- adding less than 7 cells doesn't work
  dw rp_fetch_,less_than_
endif

  dw question_exit_

  dw rp0_,fetch_,rp_store_ ; empty the return stack
  ; XXX TODO -- Needed? Already done in `quit` <-- `error` <--
  ; `(abort` <--  `throw`.

  _throw error.return_stack_overflow ; no return from `throw`

; ----------------------------------------------
  _colon_header not_understood_,'not-understood'

; doc{
;
; not-understood ( -- )
;
; `throw` exception code #-256 ("not understood").
;
; ``not-understood`` is used in `interpret-table`.
;
; See: `compilation-only`.
;
; }doc

  _literal error.not_understood
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header compilation_only_,'compilation-only'

; doc{
;
; compilation-only ( -- )
;
; `throw` exception code #-14 ("interpreting a compile-only
; word").
;
; ``compilation-only`` is used in `interpret-table`.
;
; See: `not-understood`, `?compiling`.
;
; }doc

  _literal error.compilation_only
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header nest_source_,'nest-source',compile_only

; doc{
;
; nest-source ( R: -- source-sys )
;
; _source-sys_ describes the current source specification for
; later use by `unnest-source`.
;
; ``nest-source`` is a `compile-only` word.
;
; Definition:

; ----
; : nest-source ( R: -- source-sys )
;   r>
;   input-buffer 2@ 2>r
;   source-id >r
;   >in @ >r
;   blk @ >r
;   #tib @ >r
;   >r ; compile-only
; ----

; See: `#tib`, `blk`, `>in`, `(source-id`, `input-buffer`.
;
; }doc

  dw from_r_ ; save the return address
  dw input_buffer_,two_fetch_,two_to_r_
  dw source_id_,to_r_
  dw to_in_,fetch_,to_r_
  dw blk_,fetch_,to_r_
  dw number_sign_tib_,fetch_,to_r_
  dw to_r_ ; restore the return address
  ; dw question_r_stack_ ; XXX TMP -- for debugging
  dw exit_

  ; XXX TODO -- use a high-level branch, when implemented, instead of
  ; `>r exit`.

; ----------------------------------------------
  _colon_header unnest_source_,'unnest-source',compile_only

; doc{
;
; unnest-source ( R: source-sys -- )
;
; Restore the source specification described by _source-sys_,
; which was left by `nest-source`.
;
; ``unnest-source`` is a `compile-only` word.
;
; Definition:

; ----
; : unnest-source ( R: source-sys -- )
;   r>
;   r> #tib !
;   r> blk !
;   r> >in !
;   r> (source-id !
;   2r> input-buffer 2!
;   >r ; compile-only
; ----

; See: `#tib`, `blk`, `>in`, `(source-id`, `input-buffer`.

; }doc

  dw from_r_ ; save the return address
  dw from_r_,number_sign_tib_,store_
  dw from_r_,blk_,store_
  dw from_r_,to_in_,store_
  dw from_r_,paren_source_id_,store_
  dw two_from_r_,input_buffer_,two_store_
  dw to_r_ ; restore the return address
  dw exit_

  ; XXX TODO -- use a high-level branch, when implemented, instead of
  ; `>r exit`.

; ----------------------------------------------
  _variable_header interpret_table_,'interpret-table'

; doc{
;
; interpret-table ( -- a )
;
; _a_ is the zero-offset address of the execution table used by
; `interpret`.  The table contains 13 vectors.  The behaviour of
; the Forth text interpreter can be changed by replacing these
; vectors.  The structure and contents of the execution table is
; the following:

; |===
; | Cell offset | Execution token or zero | Condition
;
; | -6          | `execute`               | Compile an immediate and compile-only word
; | -5          | `compile,`              | Compile a compile-only word
; | -4          | `execute`               | Compile an immediate word
; | -3          | `compile,`              | Compile an ordinary word
; | -2          | `2literal`              | Compile a 2-cell number
; | -1          | `xliteral`              | Compile a 1-cell number
; |  0          | `not-understood`        | Not a word nor a number (error)
; |  1          | 0                       | Interpret a 1-cell number (do nothing)
; |  2          | 0                       | Interpret a 2-cell number (do nothing)
; |  3          | `execute`               | Interpret an ordinary word
; |  4          | `execute`               | Interpret an immediate word
; |  5          | `compilation-only`      | Interpret a compile-only word (error)
; |  6          | `compilation-only`      | Interpret an immediate and compile-only word (error)
; |===
;
; }doc

                        ; compiling...
  dw execute_           ; ...immediate and compile-only word
  dw compile_comma_     ; ...compile-only word
  dw execute_           ; ...immediate word
  dw compile_comma_     ; ...ordinary word
  dw two_literal_       ; ...2-cell number
  dw x_literal_         ; ...1-cell number

interpret_table.0:
  dw not_understood_    ; not a number (error)

                        ; interpreting...
  dw 0                  ; ...1-cell number (do nothing)
  dw 0                  ; ...2-cell number (do nothing)
  dw execute_           ; ...ordinary word
  dw execute_           ; ...immediate word
  dw compilation_only_  ; ...compile-only word (error)
  dw compilation_only_  ; ...immediate and compile-only word (error)

; ----------------------------------------------
  _colon_header interpret_,'interpret'

; doc{
;
; interpret ( -- )
;
; The text interpreter which sequentially executes or compiles
; text from the current input `stream` `source` (terminal or
; disk) depending on `state`. If the word name cannot be found
; in the search `order` it is converted to a number by
; `number?`, according to the current `base`.  That also
; failing, an `error` will happen.
;
; The actions of the text interpreter are determined by the
; configuration of `interpret-table`.
;
; See: `evaluate`, `execute-parsing`, `set-source`,
; `nest-source`.
;
; }doc

interpret.begin:
  ; _chk 'begin interpret, latest:' ; XXX INFORMER
  ; if debugging
  ;   dw latest_,cr_,dot_name_ ; XXX INFORMER
  ; endif

  dw question_stack_
if 1 ; developing
  dw question_r_stack_
endif
  dw parse_name_  ; ( ca len )
  ; _brk_type 'after parse-name' ; XXX INFORMER
  dw dup_ ; end of stream?
  dw zero_branch_,interpret.end ; if so, finish

  dw find_name_ ; ( nt | 0 )
  ; _brk 'after find-name' ; XXX INFORMER
  dw question_dup_ ; found?
  dw zero_branch_,interpret.word_not_found

  ; Word found
  ; ( nt )
  ; _chk 'word found' ; XXX INFORMER
  dw dup_,name_to_immediate_question_       ; ( nt xt f1 )
  dw rot_,compile_only_question_,two_star_  ; ( xt f1 n2 )
  dw plus_,abs_ ; ( xt +n )
  _literal 3
  dw plus_ ; adjust the table index

interpret.do_it:
  ; ( +n )
  ; Execute element _+n_ of `interpret-table`,
  ; depending on `state`.
  ; _brk 'do it' ; XXX INFORMER
  dw compiling_question_,question_negate_,cells_
  ; _brk 'before interpret-table' ; XXX INFORMER
  _literal interpret_table.0
  ; _brk 'before +' ; XXX INFORMER
  dw plus_,perform_
  ; _brk 'after perform' ; XXX INFORMER
  dw branch_,interpret.begin

interpret.word_not_found:
  ; _brk 'not found' ; XXX INFORMER
  dw parsed_name_,two_fetch_ ; ( ca len )
  dw number_question_ ; is it a number? ( 0 | n 1 | d 2 )
  ; _chk 'after number?' ; XXX INFORMER
  dw branch_,interpret.do_it

interpret.end:
  dw two_drop_
  ; _chk 'exit interpret' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _c_constant_header immediate_mask_,'immediate-mask'

; doc{
;
; immediate-mask ( -- b )
;
; A `cconstant`. _b_ is the bitmask of the precedence
; bit, set by `immediate`.
;
; See: `compile-only-mask`, `smudge-mask`, `word-length-mask`.
;
; }doc

  db immediate_mask

; ----------------------------------------------
  _colon_header lex_question_,'lex?'

; doc{
;
; lex? ( nt b -- f ) "lex-question"
;
; Test the bits at _nt_ specified by the bitmask _b_.
; Return true if the result is non-zero, else return false.
;
; See: `lex!`, `immediate?`, `compile-only?`.
;
; }doc

if 1

  dw swap_
  dw far_
  dw c_fetch_and_question_
  dw default_bank_
  dw exit_

else  ; XXX TMP alternative without `c@and?`

  dw swap_,far_c_fetch_,and_,zero_not_equals_
  dw exit_

endif

; ----------------------------------------------
  _colon_header lex_store_,'lex!'

; doc{
;
; lex! ( b nt -- ) "lex-store"
;
; Set the bits of the mask _b_ in the length byte of _nt_.
;
; See: `lex?`, `immediate`, `compile-only`.
;
; }doc

  ; Credit:
  ; Word adapted from eForth.

  dw far_
  dw c_set_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_,'immediate'

; doc{
;
; immediate ( -- )
;
; Make the most recent definition an immediate word.
;
; Definition:

; ----
; : immediate ( -- ) immediate-mask latest lex! ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `immediate-mask`, `latest`, `lex!`, `immediate?`,
; `compile-only`.
;
; }doc

  dw immediate_mask_,latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_question_,'immediate?'

; doc{
;
; immediate? ( nt -- f ) "immediate-question"
;
; _f_ is true if the word _nt_ is immediate.
;
; Definition:
;
; ----
; : immediate? ( nt -- f ) immediate-mask lex? ;
; ----
;
; See: `immediate`, `lex?`, `immediate-mask`.
;
; }doc

  dw immediate_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header name_to_immediate_question_,'name>immediate?'

; doc{
;
; name>immediate? ( nt -- xt f )
;
; _f_ is true if the word _nt_ is immediate.  _xt_ is the
; corresponding execution token of _nt_.
;
; Definition:

; ----
; : name>immediate? ( nt -- xt f ) dup name> swap immediate? ;
; ----

; See: `immediate?`, `name>`, `name>body`, `name>str`,
; `name>string`.
;
; }doc

  dw dup_,from_name_,swap_ ; ( xt nt )
  dw immediate_question_ ; ( xt f )
  dw exit_

; ----------------------------------------------
  _c_constant_header compile_only_mask_,'compile-only-mask'

; doc{
;
; compile-only-mask ( -- b )
;
; A `cconstant`. _b_ is the bitmask of the compile-only
; bit, set by `compile-only`.
;
; See: `immediate-mask`, `smudge-mask`, `word-length-mask`.
;
; }doc

  db compile_only_mask

; ----------------------------------------------
  _colon_header compile_only_,'compile-only'

; doc{
;
; compile-only ( -- )
;
; Make the most recent definition a compile-only word.
;
; Definition:

; ----
; : compile-only ( -- ) compile-only-mask latest lex! ;
; ----

; See: `compile-only?`, `compile-only-mask`, `?compiling`,
; `lex!`, `latest`, `immediate`.
;
; }doc

  dw compile_only_mask_,latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header compile_only_question_,'compile-only?'

; doc{
;
; compile-only? ( nt -- f ) "compile-only-question"
;
; _f_ is true if the word _nt_ is compile-only.
;
; Definition:

; ----
; : compile-only? ( nt -- f ) compile-only-mask lex? ;
; ----

; See: `compile-only`, `immediate?`.
;
; }doc

  dw compile_only_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_comma_,'wordlist,'

; doc{
;
; wordlist, ( -- ) "wordlist-comma"
;
; Compile in data space the contents of a new word list.
;
; Definition:

; ----
; : wordlist, ( -- )
;   here 0 , last-wordlist @ , last-wordlist ! 0 , ;
; ----

; See: `wordlist`, `last-wordlist`, `wordlist>last`,
; `wordlist>link`, `wordlist>name`, `/wordlist`.

; }doc

  dw here_                        ; new value of `last-wordlist`
  _literal 0
  dw comma_                       ; latest definition in the word list
  dw last_wordlist_,fetch_,comma_ ; previous word list
  dw last_wordlist_,store_        ; update it
  _literal 0
  dw comma_                       ; word list name
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_,'wordlist'

; Credit: Most code related to word lists has been adapted from
; eForth.

; doc{
;
; wordlist ( -- wid )
;
; Create a new word list and return its identifier _wid_, which
; is the address of the following data structure (`/wordlist`
; bytes long):

; |===
; | Cell | Description
;
; | 0    | _nt_ of the latest definition in the word list
; | 1    | _wid_ of the previous word list, or zero
; | 2    | _nt_ of the word-list name, or zero
; |===
;
; Definition:

; ----
; : wordlist ( -- wid ) here wordlist, ;
; ----

; See: `wordlist,`, `set-order`, `vocabulary`,
; `last-wordlist`, `wordlist>last`, `wordlist>link`,
; `wordlist>name`, `/wordlist`, `wordlists`, `dump-wordlists`.
;
; }doc

  dw here_,wordlist_comma_
  dw exit_

; ----------------------------------------------
  _colon_header do_vocabulary_,'dovocabulary'

; doc{
;
; dovocabulary ( -- ) "do-vocabulary"
;
; Change the behaviour of the latest word defined:
; Replace the first word list in the search order with
; the _wid_ stored in its body.
;
; Definition:

; ----
; : dovocabulary ( -- ) does> ( -- ) ( dfa ) @ context ! ;
; ----

; See: `vocabulary`, `wordlist>vocabulary`, `wordlist`.
;
; }doc

  dw paren_semicolon_code_
do_vocabulary:
  call do_colon
  dw fetch_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header get_current_,'get-current'

; doc{
;
; get-current ( -- wid )
;
; Return _wid_, the identifier of the compilation word list.
;
; Definition:

; ----
; : get-current ( -- wid ) current @ ;
; ----

; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; See: `current`.
;
; }doc

  dw current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header set_current_,'set-current'

; doc{
;
; set-current ( wid -- )
;
; Set the compilation word list to the word list identified by
; _wid_.
;
; Definition:

; ----
; : set-current ( wid -- ) current ! ;
; ----

; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; }doc

  dw current_,store_
  dw exit_

; ----------------------------------------------
  _colon_header definitions_,'definitions'

; doc{
;
; definitions ( -- )
;
; Make the compilation word list the same as the first  word
; list in the search order. The  names of subsequent definitions
; will be placed in the compilation word list. Subsequent
; changes in the search  order will not affect the compilation
; word list.
;
; Definition:

; ----
; : definitions ( -- ) context @ set-current ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; See: `context`, `set-current`, `wordlist`, `vocabulary`.
;
; }doc

  dw context_,fetch_,set_current_
  dw exit_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

  ; XXX TODO -- make `(` deferred and factor its default
  ; action to `core-(` (Forth-2012 CORE word wet), in order
  ; to let `load-app` change it to `file-(` (Forth-2012 FILE
  ; word set).

; doc{
;
; ( ( "ccc<paren>" -- ) "paren"
;
; Parse _ccc_ delimited by a right parenthesis.  The number of
; characters in _ccc_ may be zero to the number of characters in
; the parse area.
;
; ``(`` is an `immediate` word.
;
; Definition:
;
; ----
; : ( ( "ccc<paren>" -- ) ')' parse 2drop ; immediate
; ----
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `\`, `parse`.
;
; }doc

  _literal ')'
  dw parse_,two_drop_
  dw exit_

; ----------------------------------------------
  _alias_header question_right_paren_,'?)',immediate,noop_

; doc{
;
; ?) ( -- ) "question-right-paren"
;
; Do nothing. `?(` parses until ``?)`` is found.
;
; ``?)`` is an `immediate` word.
;
; }doc

; ----------------------------------------------
  _colon_header question_paren_,'?(',immediate

; doc{
;
; ?( ( f "ccc<space><question><paren><space>" -- ) "question-paren"

;
; If _f_ is not zero, parse and discard until "?)" is found or
; until the end of the parse area is reached. ``?(`` cannot be
; used across blocks.
;
; ``?(`` is used for conditional compilation, as a simpler but
; more compact alternative to the standard `[if]`.
;
; ``?(`` is an `immediate` word.
;
; Definition:

; ----
; : ?( ( f "ccc<space><question><paren><space>" -- )
;   0exit begin  parse-name dup
;         while  s" ?)" str= ?exit repeat 2drop ; immediate
; ----
;
; See: `?\`, `?-->`, `(`.
;
; }doc

  dw zero_exit_
question_paren.begin:
  dw parse_name_,dup_
  dw zero_branch_,question_paren.exit
  dw s_lit_
  _string '?)'
  dw str_equals_,question_exit_
  dw branch_,question_paren.begin
question_paren.exit:
  dw two_drop_
  dw exit_

; ----------------------------------------------
  _colon_header dot_ok_,'.ok'

; doc{
;
; .ok ( -- ) "dot-ok"
;
; Display "ok". ``.ok`` is the default action of `ok`.
;
; }doc

  dw paren_dot_quote_
  _string 'ok'
  dw exit_

; ----------------------------------------------
  _defer_header ok_,'ok',,dot_ok_

; doc{
;
; ok ( -- )
;
; A deferred word called by `quit` after interpreting a command.
; Its default action is the word `.ok`.
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header quit_,'quit'

; doc{
;
; quit ( -- )
;
; Empty the return stack, make the terminal the current source
; and enter interpretation `state`. Then repeat the following:
;
; - Accept a line from the input source into the input buffer,
;   set `>in` to zero and `interpret`.
; - Display the system prompt, if in interpretation `state`.
;
; Definition:

; ----
; : quit ( -- )
;   rp0 @ rp! postpone [
;   begin
;     cr query interpret
;     interpreting? if ok then
;   again ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `[`, `query`, `interpret`, `ok`, `abort`.
;
; }doc

  dw rp0_,fetch_,rp_store_
  ; dw terminal_to_source_ ; XXX OLD -- Done in `query`
  dw left_bracket_
quit.begin:
  dw cr_,query_ ; XXX TMP ; XXX TODO
  dw interpret_
  dw compiling_question_
  dw question_branch_,quit.begin
  dw ok_
  dw branch_,quit.begin

; ----------------------------------------------
  _colon_header paren_defer_,'(defer'

; doc{
;
; (defer ( -- ) "paren-defer"
;
; `throw` `error` #-261 ("deferred word is uninitialized".
; ``(defer`` is the default action of the uninitialized
; deferred words.
;
; Definition:

; ----
; : (defer ( -- ) #-261 error ;
; ----

; See: `defer`.
;
; }doc

  _literal error.deferred_word_uninitialized
  dw error_
  dw exit_

; ----------------------------------------------
  _colon_header defer_,'defer'

; doc{
;
; defer ( "name" -- )
;
; Create a deferred word _name_, whose action can be configured
; with `defer!` or `is`.  The default action of _name_ is
; `(defer`.
;
; Origin: Forth-2012 (CORE EXT).
;
; See: `defer@`, `action-of`, `>action`.
;
; }doc

  dw header_,reveal_
  _literal paren_defer_ ; default xt to execute
  dw jp_comma_
  dw exit_

; ----------------------------------------------
  _alias_header to_action_,'>action',,one_plus_

; doc{
;
; >action ( xt -- a ) "to-action"
;
; Return the address _a_ that contains the execution token
; currently associated to the deferred word _xt_.
;
; See: `defer`, `action-of`, `defer!`, `defer@`.
;
; }doc

; ----------------------------------------------
  _colon_header defer_store_,'defer!'

; doc{
;
; defer! ( xt1 xt2 -- ) "defer-store"
;
; Set the deferred word _xt2_ to execute _xt1_.
;
; Origin: Forth-2012 (CORE EXT).
;
; See: `defer@`, `defer`, `>action`.
;
; }doc

  dw to_action_,store_
  dw exit_

; ----------------------------------------------
  _variable_header version_,'version'

; doc{
;
; version ( -- ca )
;
; _ca_ is the address of a 9-byte data table containing the Solo
; Forth version, as follows:

; [horizontal]
; +0:: major (one byte)
; +1:: minor (one byte)
; +2:: patch (one byte)
; +3:: pre-release identifier (one byte):
;      'd' for "dev", 'p' for "pre", 'r' for "rc", zero if none
; +4:: pre-release (one cell)
; +6:: build (double-cell number)

; See: `.version`.
;
; }doc

  db version_major
  db version_minor
  db version_patch
  db version_prerelease_id
  dw version_prerelease
  dw version_build_high_part,version_build_low_part

; ----------------------------------------------
  _colon_header dot_version_,'.version'

; doc{
;
; .version ( -- ) "dot-version"
;
; Display the Solo Forth `version`.
;
; }doc

  dw version_

  dw count_,zero_dot_r_ ; major

  _literal '.'
  dw emit_
  dw count_,zero_dot_r_ ; minor

  _literal '.'
  dw emit_
  dw count_,zero_dot_r_ ; patch

if version_prerelease_id

  dw paren_dot_quote_

if version_prerelease_id='d'
  _string "-dev."
else
  if version_prerelease_id='p'
    _string "-pre."
  else
    if version_prerelease_id='r'
      _string "-rc."
    else
      .error "Invalid prerelease identifier"
    endif
  endif
endif

  dw char_plus_,dup_,fetch_,zero_dot_r_ ; prerelease

else

  dw char_plus_

endif

  _literal '+'
  dw emit_
  dw cell_plus_,two_fetch_,d_dot_ ; build

  dw exit_

; ----------------------------------------------
  _colon_header greeting_,'greeting'

; doc{
;
; greeting ( -- )
;
; Display the boot message.
;
; See: `cold`, `fyi`.
;
; }doc

  dw paren_dot_quote_
  _string "Solo Forth\r"
  dw dot_version_
  dw dos_,type_
  dw paren_dot_quote_
  _string "\rBy Marcos Cruz\r(programandala.net), 2015-2020\r"
  dw exit_

; ----------------------------------------------
  _defer_header boot_,'boot',,noop_

; doc{
;
; boot ( -- )
;
; A deferred word executed by `abort`. By default it does
; nothing. It is changed by `turnkey`.
;
; See: `cold`, `defer`.
;
; }doc

; ----------------------------------------------
  _variable_header previous_mode_,'previous-mode'

; doc{
;
; previous-mode ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; execution token of the word that activates the screen mode
; that was active before executing `bye` (e.g. `mode-32`,
; `mode-32iso`, `mode-64ao`).  ``previous-mode`` is updated by
; `bye`, and used by `warm` to restore the `current-mode`.
;
; }doc

  ; XXX TODO -- Convert to a deferred word? Then `restore-mode`
  ; could be removed.

  dw noop_

; ----------------------------------------------
  _variable_header current_mode_,'current-mode'

; doc{
;
; current-mode ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; execution token of the word that activates the current screen
; mode (e.g. `mode-32`, `mode-32iso`, `mode-42pw`, `mode-42rs`,
; `mode-64es`, `mode-64ao`). It's set to `noop` until the first
; mode change is done.
;
; See: `save-mode`, `restore-mode`.
;
; }doc

  ; XXX TODO -- Convert to a deferred word? But then `defer@`
  ; should be moved to the kernel.

  dw noop_

; ----------------------------------------------
  _colon_header save_mode_,'save-mode'

; doc{
;
; save-mode ( -- )
;
; Store the contents of `current-mode` into `previous-mode`.
;
; ``save-mode`` is executed by `bye` before setting the default
; screen mode (e.g. `mode-32`, `mode-32iso`, `mode-64ao`).
;
; Definition:

; ----
; : save-mode ( -- ) current-mode @ previous-mode ! ;
; ----

; See: `restore-mode`.
;
; }doc

  dw current_mode_,fetch_
  dw previous_mode_,store_
  dw exit_

; ----------------------------------------------
  _colon_header restore_mode_,'restore-mode'

; doc{
;
; restore-mode ( -- )
;
; Restore the screen mode that was saved in `previous-mode` by
; `save-mode`.
;
; ``restore-mode`` is executed by `warm`.
;
; Definition:

; ----
; : restore-mode ( -- ) previous-mode perform ;
; ----

; See: `current-mode`, `perform`.
;
; }doc

  dw previous_mode_,perform_
  dw exit_

; ----------------------------------------------
  _colon_header warm_,'warm'

; doc{
;
; warm ( -- )
;
; Do a "warm" restart of the Forth system: Make the `terminal`
; the current output device, restore the previous display mode
; (in case ``warm`` is automatically executed after reentering
; from BASIC), clear the screen and `abort`.
;
; Definition:

; ----
; : warm ( -- ) display restore-mode page abort ;
; ----

; See: `cold`, `restore-mode`, `page`.
;
; }doc

  dw terminal_
  dw restore_mode_
  dw page_ ; note: this must be after `terminal` and `restore-mode`
  dw abort_
  ; No return from `abort`.

warm_start:
  call common_start
  dw warm_

; ----------------------------------------------
  _code_header cold_,'cold'

; doc{
;
; cold ( -- )
;
; Restore the Forth system to its default status, i.e. as if it
; were just booted the first time, except the background picture
; is not displayed.
;
; Origin: fig-Forth.
;
; See: `warm`, `greeting`.
;
; }doc

  ; ............................
  ; First part

  ; The first part of `cold` contains the initialization actions
  ; that need less bytes in Z80 than in Forth.

  ; Init `farlimit`:
  if !plus3dos
    ld hl,$0000 ; use 64 KiB
  else
    ld hl,$C000 ; use 48 KiB (16 KiB are used for cache and RAM disk)
  endif
  ld (farlimit_dfa),hl

  ; Init the name-space pointer:
  ld hl,(names_pointer_init_value)
  ld (names_pointer),hl

  ; Restore the dictionary to its default state:
  ld hl,(latest_nt_in_root_word_list.init_value)
  ld (root_wordlist_dfa),hl
  ld hl,(latest_nt_in_forth_word_list.init_value)
  ld (forth_wordlist_dfa),hl
if 1 ; assembler_core_in_kernel
  ld hl,(latest_nt_in_assembler_word_list.init_value)
  ld (assembler_wordlist_dfa),hl
endif
  ld hl,(latest_wordlist.init_value)
  ld (last_wordlist_dfa),hl

  ; Restore the word count:
cold.number_sign_words: equ $+1
  ld hl,0
  ld (number_sign_words_dfa),hl

  ; Set `warn` and `init-asm` to their default action `noop`:
  ld hl,noop_
  ld (warn_+1),hl
  ld (init_asm_+1),hl

  ; Set the `last-font-char`:
  ld a,127
  ld (last_font_char_),a

  call do_colon ; execute the compiled words that follow

  ; ............................
  ; Second part

  ; The Second part of `cold` contains the initialization actions
  ; that need less bytes in Forth than in Z80.

if plus3dos
  ; Set the default configuration of memory banks for +3DOS:
  dw default_1346_
endif

  ; Init the memory configuration:
  dw limit_,off_

  ; Init the configuration of far-memory banks:
  dw two_lit_ ; a double number...
  dw $0301,$0604 ; ...equivalent to 1, 3, 4 and 6,...
  dw lit_,far_banks_dfa ; ...which are the default far-banks...
  dw two_store_ ; ...to be restored

  ; Empty the disk buffer:
  dw empty_buffers_

  ; Set the first drive as the current one:
  dw first_drive_,set_drive_

  ; Restore default value of `#block-drives`:
  _literal 1
  dw number_sign_block_drives_,c_store_

  ; Restore the default stringer:
  dw default_stringer_

  ; Init the user variables:
  dw lit_,default_user_variables_start ; from
  dw up_,fetch_ ; to
  _literal default_user_variables_end-default_user_variables_start ; length
  dw c_move_

  dw only_,forth_,definitions_  ; init the search order
  dw default_header_ ; set the default action of `header`
  dw decimal_

  ; Set the screen to its default status:
  dw terminal_,default_display_,reset_default_mode_

  ; Display the greeting message:
cold.home:
  dw home_ ; only the first time, to preserve the background
  dw lit_,page_ ; but next time use `page`...
  dw lit_,cold.home ; ...instead of `home`...
  dw store_ ; ...so patch it
  dw greeting_

if 1 ; XXX INFORMER

  ; dw hex_

  ; _literal $1622 ; nt of `.(`
  ; dw far_
  ; dw dup_
  ; dw cr_,u_dot_

  ; _literal $1620 ; lfa of `.(`
  ; dw far_fetch_
  ; dw cr_,u_dot_

  ; _literal $10BD ; nt of `definitions`
  ; dw far_count_
  ; dw cr_,dot_s_,cr_,type_

  ; dw decimal_

endif

  dw abort_
  ; No return from `abort`.

cold_start:
call_first_boot:
  call first_boot ; only once, after the first boot from disk
  call common_start
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  ; (SP) = xt of `cold` or `warm`

  im 1 ; interrupt mode 1
  pop bc ; get the return address, which holds the xt of `cold` or `warm`
  ld (system_stack_pointer),sp ; save the system stack pointer
  ld sp,(sp0_init_value)
  ld (iy+sys_df_sz_offset),0 ; no lines at the bottom part of the screen
  ld ix,next ; restore IX
  _jp_next ; jump to the xt pointed by the register pair BC

; ----------------------------------------------
  _alias_header d_to_s_,'d>s',,drop_

; doc{
;
; d>s ( d -- n ) "d-to-s"
;
; _n_ is the equivalent of _d_. The high cell of _d_ is
; discarded.
;
; Origin: Forth-94 (DOUBLE), Forth-2012 (DOUBLE).
;
; See: `s>d`, `u>ud`.
;
; }doc

; ----------------------------------------------
if size_optimization

  ; 9 bytes

  _colon_header s_to_d_,'s>d'

  dw dup_,zero_less_than_
  dw exit_

  ; XXX TODO -- benchmark

else

  ; 14 bytes

  _code_header s_to_d_,'s>d'

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,s_to_d.end ; jump if positive
  dec hl
s_to_d.end:
  push de
  push hl
  _jp_next

endif

; doc{
;
; s>d ( n -- d ) "s-to-d"
;
; Sign extend a single number _n_ to form a double number _d_.
;
; Definition:

; ----
; : s>d ( n -- d )
;   dup 0< ;
; ----

; Origin: fig-Forth's ``s->d``, Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `d>s`, `u>ud`.
;
; }doc

; ----------------------------------------------
  _code_header question_negate_,'?negate'

; doc{
;
; ?negate ( n1 n2 -- n1|n3 ) "question-negate"
;
; If _n2_ is negative, negate _n1_, giving its arithmetic
; inverse _n3_. Otherwise return _n1_.
;
; ``?negate`` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : ?negate ( n1 n2 -- n1|n3 ) 0< if negate then ;
; ----

; Origin: fig-Forth's ``+-``.
;
; See: `negate`, `?dnegate`.
;
; }doc

  pop hl
question_negate.hl:
  bit 7,h
  jp nz,negate_
  _jp_next

; ----------------------------------------------
  _code_header question_d_negate_,'?dnegate'

; doc{
;
; ?dnegate ( d1 n -- d1|d2 ) "question-d-negate"
;
; If _n_ is negative, negate _d1_, giving its arithmetic inverse
; _d2_. Otherwise return _d1_.
;
; ``?dnegate`` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : ?dnegate ( d1 n -- d1|d2 ) 0< if dnegate then ;
; ----

; Origin: fig-Forth's ``d+-``.
;
; See: `dnegate`, `?negate`.
;
; }doc

  pop hl
question_d_negate.hl:
  bit 7,h
  jp nz,d_negate_
  _jp_next

; ----------------------------------------------
  _code_header abs_,'abs'

; doc{
;
; abs ( n -- u )
;
; Leave the absolute value _u_ of a number _n_.
;
; Definition:

; ----
; : abs ( n -- u ) dup ?negate ;
; ----

; }doc

  pop hl
  push hl
  jp question_negate.hl

; ----------------------------------------------
  _code_header d_abs_,'dabs'

; doc{
;
; dabs ( d -- ud ) "d-abs"
;
; Leave the absolute value _ud_ of a double number _d_.
;
; Definition:

; ----
; : dabs ( d -- ud ) dup ?dnegate ;
; ----

; }doc

  pop hl
  push hl
  jp question_d_negate.hl

; ----------------------------------------------
  _code_header u_max_,'umax'

; doc{
;
; umax ( u1 u2 -- u1 | u2 ) "u-max"
;
; _u3_ is the greater of _u1_ and _u2_.
;
; See: `umin`, `max`, `dmax`, `u>`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header u_min_,'umin'

; doc{
;
; umin ( u1 u2 -- u1 | u2 ) "u-min"
;
; _u3_ is the lesser of _u1_ and _u2_.
;
; See: `umax`, `min`, `dmin`, `u<`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'min'

; doc{
;
; min ( n1 n2 -- n3 )
;
; _n3_ is the lesser of _n1_ and _n2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `max`, `umin`, `dmin`, `<`.
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'max'

; doc{
;
; max ( n1 n2 -- n3 )
;
; _n3_ is the greater of _n1_ and _n2_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `min`, `umax`, `dmax`, `0max`, `>`.
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  push de
  _jp_next

; ----------------------------------------------
  _colon_header m_star_,'m*'

; doc{
;
; m* ( n1 n2 -- d ) "m-star"
;
; Multiply _n1_ by _n2_, giving the result _d_.
;
; Definition:

; ----
; : m* ( n1 n2 -- d )
;   2dup xor >r
;   abs swap abs um*
;   r> ?dnegate ;
; ----

; Origin: fig-Forth, Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `*`, `um*`, `d*`, `?dnegate`.
;
; }doc

if 1 ; original_m_star

  ; Credit:
  ;
  ; Code adapted from Abersoft Forth; used also by Z88
  ; CamelForth and Z80 eForth.

  dw two_dup_,xor_,to_r_
  dw abs_,swap_,abs_,u_m_star_
  dw from_r_,question_d_negate_
  dw exit_

else

  ; XXX TODO -- code from DZX-Forth

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_signed
  push de
  push hl
  _jp_next

endif

; ----------------------------------------------
  _defer_header m_slash_,'m/',,s_m_slash_rem_

; doc{
;
; m/ ( d n1 -- n2 n3 ) "m-slash"
;
; A mixed magnitude math operator which leaves the signed
; remainder _n2_ and signed quotient _n3_ from a double number
; dividend _d_ and divisor _n1_.
;
; ``m/`` is a deferred word whose default action is `sm/rem`, so
; it does a symmetric division (the  remainder takes its sign
; from the dividend), as in fig-Forth and Forth-79.  It can be
; set to execute `fm/mod` instead.
;
; ``m/`` is executed by all other division operators.  Therefore
; setting it to execute either `sm/rem` or `fm/mod` will change
; the behaviour of all division operators.
;
; Rationale:
;
; The Forth-79 Standard specifies that the signed division
; operators (`/`, `/mod`, `mod`, `*/mod`, and `*/`) round
; non-integer quotients towards zero (symmetric division).
; Forth-83 changed the semantics of these operators to round
; towards negative infinity (floored division).  To resolve this
; issue, Forth-94 and Forth-2012 permit to supply either floored
; or symmetric operators, and include a floored division
; primitive (`fm/mod`), and a symmetric division primitive
; (`sm/rem`).
;
; Origin: fig-Forth.
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header s_m_slash_rem_,'sm/rem'

; doc{
;
; sm/rem ( d n1 -- n2 n3 ) "s-m-slash-rem"
;
; Symmetric division:
;
; ----
; D = n3*n1+n2;
;
; sign(n2) = sign(d1) or 0
; ----

; Divide _d_ by _n1_, giving the symmetric quotient _n3_ and the
; remainder _n2_. Input and output stack arguments are signed.

; [caption="Symmetric Division Example"]
; |===
; | Dividend   | Divisor  | Remainder  | Quotient
;
; >|       10  >|      7  >|        3  >|        1
; >|      -10  >|      7  >|       -3  >|       -1
; >|       10  >|     -7  >|        3  >|       -1
; >|      -10  >|     -7  >|       -3  >|        1
; |===

;
; Definition:

; ----
; : sm/rem ( d1 n1 -- n2 n3 ) \ symmetric signed division
;   2dup xor >r  \  sign of quotient
;   over >r      \  sign of remainder
;   abs >r dabs r> um/mod
;   swap r> ?negate
;   swap r> ?negate ;
; ----

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `fm/mod`, `m/`.
;
; }doc

  dw two_dup_,xor_,to_r_
  dw over_,to_r_
  dw abs_,to_r_,d_abs_,from_r_,u_m_slash_mod_
  dw swap_,from_r_,question_negate_
  dw swap_,from_r_,question_negate_
  dw exit_

; ----------------------------------------------
  _colon_header star_,'*'

; doc{
;
; * ( n1|u1 n2|u2 -- n3|u3 ) "star"
;
; Multiply _n1|u1_ by _n2|u2_ giving the product _n3|u3_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `m*`, `um*`, `d*`.
;
; }doc

if 1

  dw m_star_,d_to_s_
  dw exit_

else

  ; XXX TODO -- from DZX-Forth

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  push de
  _jp_next

endif

; ----------------------------------------------
  _colon_header slash_mod_,'/mod'

; doc{
;
; /mod ( n1 n2 -- n3 n4 ) "slash-mod"
;
; Divide _n1_ by _n2_, giving the remainder _n3_ and the
; quotient _n4_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; See: `m/`, `du/mod`, `/`, `mod`, `/-rem`, `/_mod`.
;
; }doc

  dw to_r_,s_to_d_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header slash_,'/'

; doc{
;
; / ( n1 n2 -- n3 ) "slash"
;
; Divide _n1_ by _n2_, giving the quotient _n3_.
;
; Definition:

; ----
; : / ( n1 n2 -- n3 ) /mod nip ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; See: `m/`, `/mod`, `/_`, `/-`, `gcd`.
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header mod_,'mod'

; doc{
;
; mod ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the remainder _n3_.
;
; Definition:

; ----
; : mod ( n1 n2 -- n3 ) /mod drop ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; See: `m/`, `/mod`, `/_mod`, `/-rem`, `gcd`.
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,drop_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/mod'

; doc{
;
; */mod ( n1 n2 n3 -- n4 n5 ) "star-slash-mod"
;
; Multiply _n1_ by _n2_ producing the intermediate
; result _d_. Divide _d_ by _n3_ producing the remainder
; _n4_ and the quotient _n5_.
;
; Definition:

; ----
; : */mod ( n1 n2 n3 -- n4 n5 ) >r m* r> m/ ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; See: `/mod`, `*/`, `*/_mod`, `*/-rem`, `m*`, `m/`.
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw to_r_,m_star_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header line_to_string_,'line>string'

; doc{
;
; line>string ( n1 n2 -- ca len ) "line-to-string"
;
; Convert the line number _n1_ and the screen number _n2_ to a
; string _ca len_ in the disk buffer containing the data.
;
; Definition:

; ----
; : line>string ( n1 n2 -- ca len )
;   >r c/l b/buf */mod r> + block + c/l ;
; ----

; Origin: fig-Forth's ``(line``.
;
; }doc

  ; XXX REMARK -- Could be moved to the library, but it's needed
  ; in `(located`. Otherwise also `*/mod` could be moved.

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_
  dw plus_
  dw block_,plus_,c_slash_l_
  dw exit_

; ----------------------------------------------
  _colon_header dec_dot_,'dec.'

; doc{
;
; dec. ( n -- ) "dec-dot"
;
; Display _n_ as a signed decimal number, followed by a space.
;
; Origin: Gforth.
;
; See: `hex.`, `bin.`, `.`.
;
; }doc

  dw base_,fetch_,swap_,decimal_,dot_,base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header dot_throw_number_sign_,'.throw#'

; doc{
;
; .throw# ( n -- ) "dot-throw-number-sign"
;
; Display the number of `throw` code _n_, as a decimal number,
; prefixed with a '#' and followed by a space.
;
; ``.throw#`` is the default action of `.throw`. Its alternative
; action `.throw-message` displays also the error description.
;
; }doc

  dw paren_dot_quote_
  _string "\r#" ; carriage return and number sign
  dw dec_dot_
  dw exit_

; ----------------------------------------------
  _defer_header dot_throw_,'.throw',,dot_throw_number_sign_

; doc{
;
; .throw ( n -- ) "dot-throw"
;
; Display a message giving information about the condition
; associated with the `throw` code _n_.
;
; ``.throw`` is executed by `error`. It's a deferred word whose
; default action is `.throw#`, which displays only the number.
; An alternative action is `.throw-message`, which displays also
; the description.
;
; See: `defer`.
;
; }doc

  ; Credit:
  ; Name from MPE Forth for TiniARM.

; ----------------------------------------------
  _colon_header updated_question_,'updated?'

; doc{
;
; updated? ( -- f ) "updated-question"
;
; _f_ is true if the current disk buffer is marked as
; modified.
;
; Definition:

; ----
; : updated? ( -- f ) buffer-id 0< ;
; ----

; See: `update`, `empty-buffers`, `buffer-id`.
;
; }doc

  dw buffer_id_,zero_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header empty_buffers_,'empty-buffers'

; doc{
;
; empty-buffers ( -- )
;
; Unassign all block buffers. Do not transfer the contents of
; any updated block to mass storage.
;
; Definition:

; ----
; : empty-buffers ( -- ) $7FFF disk-buffer ! ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (BLOCK EXT), Forth-2012
; (BLOCK EXT).
;
; See: `update`, `flush`, `disk-buffer`.
;
; }doc

  _literal buffer_block_id_mask
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_id_,'buffer-id'

; doc{
;
; buffer-id ( -- x ) "buffer-i-d"
;
; _x_ is the identifier of the disk buffer.
;
; See: `disk-buffer`.
;
; }doc

  dw disk_buffer_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_block_,'buffer-block'

; doc{
;
; buffer-block ( -- n )
;
; Return the block _n_ associated with the disk buffer.
;
; ---
; : buffer-block ( -- n ) buffer-id $7FFF literal and ;
; ---
;
; See: `buffer-id`, `buffer`, `block`.
;
; }doc

  dw buffer_id_
  _literal buffer_block_id_mask
  dw and_
  dw exit_

; ----------------------------------------------
  _defer_header to_drive_block_,'>drive-block',,noop_

; doc{
;
; >drive-block ( u1 -- u2 ) "to-drive-block"
;
; Convert block _u1_ to its equivalent _u2_ in its corresponding
; disk drive, which is set the current drive.
;
; ``>drive-block`` is a deferred word whose default action is
; `noop`.  Its action is set to `(>drive-block` when
; `block-drives` is loaded.
;
; See: `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header read_block_,'read-block'

; doc{
;
; read-block ( u -- )
;
; Read disk block _u_ to the buffer.
;
; Definition:

; ----
; : read-block ( u -- ) read-mode transfer-block ;
; ----

; See: `read-mode`, `transfer-block`, `write-block`,
; `block`.
;
; }doc

  dw read_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header write_block_,'write-block'

; doc{
;
; write-block ( n -- )
;
; Write the buffer to disk block _n_.
;
; Definition:

; ----
; : write-block ( n -- ) write-mode transfer-block ;
; ----

; See: `write-mode`, `transfer-block`, `read-block`,
; `block`.
;
; }doc

  dw write_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header free_buffer_,'free-buffer'

; doc{
;
; free-buffer ( n -- )
;
; If the current disk buffer has been updated, write its block
; to the disk. Assign block number _n_ to the disk buffer.
;
; Definition:

; ----
; : free-buffer ( n -- )
;   updated?  if    buffer-block write-buffer
;             then  disk-buffer ! ;
; ----

; }doc

  dw updated_question_
  dw zero_branch_,free_buffer.end
  dw buffer_block_,write_block_
  dw branch_,free_buffer.end
free_buffer.end:
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_,'buffer'

; doc{
;
; buffer ( u -- a )
;
; Assign the `block` buffer to block _u_.   If the contents of the
; buffer were marked as updated, it is written to the disk.  The
; block _u_ is not read from the disk.  The address _a_ left on
; stack is the first cell in the buffer for data storage.
;
; Definition:

; ----
; : buffer ( u -- a )
;   dup buffer-block =
;   if drop else free-buffer then buffer-data ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `buffer-block`, `free-buffer`, `buffer-data`.
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,buffer.not_equals
  ; The requested block is the one already in the buffer.
  dw drop_
  dw branch_,buffer.end
buffer.not_equals:
  dw free_buffer_
buffer.end:
  dw buffer_data_ ; first cell of data in the buffer
  dw exit_

; ----------------------------------------------
  _colon_header block_,'block'

; doc{
;
; block ( u -- a )

; If the block _u_ is already in memory, leave the address _a_
; of the first cell in the disk `buffer` for data storage.
;
; If the block _u_ is not already in memory, transfer it from
; disk to the buffer.  If the block occupying that buffer has
; been marked as updated, rewrite it to disk before block _u_ is
; read into the buffer.  Finally leave the address _a_ of the
; first cell in the disk buffer for data storage.
;
; Definition:

; ----
; : block ( u -- a )
;   dup buffer-block =
;   if    drop
;   else  save-buffers dup read-block disk-buffer !
;   then  buffer-data ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `buffer-block`, `save-buffers`, `read-block`,
; `disk-buffer`, `buffer-data`.
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,block.not_equals
  dw drop_
  dw branch_,block.end
block.not_equals:
  dw save_buffers_,dup_,read_block_
  dw disk_buffer_,store_
block.end:
  dw buffer_data_
  dw exit_

; ----------------------------------------------
  _code_header flip_,'flip'

; doc{
;
; flip ( x1 -- x2 )
;
; Exchange the low and high bytes within _x1_, resulting _x2_.
;
; Origin: eForth.
;
; NOTE: ``flip`` is called ``><`` in Forth-79 (Word Reference
; Set) and Forth-83 (Uncontrolled Reference Words), ``swab`` in
; LaForth (c. 1980) and ``cswap`` in other Forth systems.
;
; See: `split`, `join`.
;
; }doc

  ; Credit:
  ; The name "flip" was borrowed from eForth.

  pop hl
  ld a,h
  ld h,l
  ld l,a
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header save_buffers_,'save-buffers'

; doc{
;
; save-buffers ( -- )
;
; If the disk buffer has been modified, transfer its contents to
; disk and mark it as unmodified.
;
; Definition:

; ----
; : save-buffers ( -- )
;   updated? 0exit
;   buffer-block dup write-block disk-buffer ! ;
; ----

; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (BLOCK), Forth-2012 (BLOCK).
;
; See: `empty-buffers`, `flush`, `block`, `buffer`,
; `buffer-block`, `disk-buffer`.
;
; }doc

  dw updated_question_,zero_exit_
  ; Updated
  dw buffer_block_,dup_,write_block_
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header set_source_,'set-source'

; doc{
;
; set-source ( ca len -- )
;
; Set the memory zone _ca len_ as the current source by pointing
; `input-buffer` to it.
;
; Definition:

; ----
; : set-source ( ca len -- ) input-buffer 2! >in off ;
; ----

; See: `>in`, `terminal>source`, `block>source`.
;
; }doc

  dw input_buffer_,two_store_
  dw to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header terminal_to_source_,'terminal>source'

; doc{
;
; terminal>source ( -- ) "terminal-to-source"
;
; Set the terminal as the current source.
;
; Definition:

; ----
; : terminal>source ( -- )
;   blk off (source-id off tib #tib @ set-source ;
; ----

; See: `set-source`, `blk`, `tib`, `#tib`, `(source-id`,
; `block>source`.
;
; }doc

  dw blk_,off_,paren_source_id_,off_
  dw tib_,number_sign_tib_,fetch_,set_source_
  dw exit_

; ----------------------------------------------
  _colon_header block_to_source_,'block>source'

; doc{
;
; block>source ( u -- ) "block-to-source"
;
; Set `block` _u_ as the current source.
;
; Definition:

; ----
; : block>source ( u -- ) blk ! >in off ;
; ----

; See: `terminal>source`, `blk`, `>in`, `set-source`,
; `lineblock>source`.
;
; }doc

  dw blk_,store_,to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header paren_load_,'(load'

; doc{
;
; (load ( u -- ) "paren-load"
;
; Make block _u_ the current input source and interpret it.

; ``(load`` is a common factor of `load` and `continued`.
;
; Definition:

; ----
; : (load ( u -- ) dup lastblk ! block>source interpret ;
; ----
;
; See: `block>source`, `interpret`.
;
; }doc

  dw dup_,last_blk_,store_
  dw block_to_source_,interpret_
  dw exit_

; ----------------------------------------------
  _colon_header load_,'load'

; doc{
;
; load ( u -- )
;
; Save the current input-source specification. Store _u_ in `blk`
; (thus making block _u_ the input source and setting the input buffer
; to encompass its contents) and `lastblk`, set `>in` to zero, and
; interpret. When the parse area is exhausted, restore the prior input
; source specification.
;
; An error is issued if _u_ is zero.
;
; Definition:

; ----
; : load ( u -- )
;   dup 0= #-259 ?throw nest-source (load unnest-source ;
; ----

; See: `(load`, `nest-source`, `unnest-source`, `lineload`,
; `+load`, `thru`, `blk`.
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.loading_from_screen_0
  dw nest_source_,paren_load_,unnest_source_
  dw exit_

; ----------------------------------------------
  _colon_header next_block_,'-->',immediate

; doc{
;
; --> ( -- ) "next-block"
;
; Continue interpretation with the next block.
;
; ``-->`` is an `immediate` word.
;
; Definition:

; ----
; : --> ( -- )
;   ?loading refill 0= #-35 ?throw ; immediate
; ----

; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words).
;
; See: `?-->`, `load`, `continued`, `?loading`, `refill`.
;
; }doc

  dw question_loading_
  dw refill_,zero_equals_
  _literal error.invalid_block_number
  dw question_throw_
  dw exit_

; ----------------------------------------------
  _colon_header defined_,'defined'

; doc{
;
; defined ( "name" -- nt | 0 )
;
; Parse _name_ and find its definition.  If the definition is
; not found after searching all the word lists in the search
; order, return zero. If the definition is found,
; return its _nt_.
;
; Definition:

; ----
; : defined ( "name" -- nt | 0 ) parse-name find-name ;
; ----

; See: `undefined?`, `[defined]`, `parse-name`,
; `find-name`.
;
; }doc

  dw parse_name_,find_name_
  dw exit_

; ----------------------------------------------
  _colon_header question_defined_,'?defined'

; doc{
;
; ?defined ( f -- ) "question-defined"
;
; If _f_ is false, `throw` exception code #-13 (not found).
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  dw zero_equals_
  _question_throw error.not_found
  dw exit_

; ----------------------------------------------
  _colon_header tick_,"'"

; doc{
;
; ' ( "name" -- xt ) "tick"
;
; If _name_ is found in the current search order, return its
; execution token _xt_, else `throw` an exception.
;
; Definition:

; ----
; : ' ( "name" -- xt ) defined dup ?defined name> ;
; ----

; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `[']`, `''`, `defined`, `?defined`, `>`.
;
; }doc

  dw defined_,dup_,question_defined_,from_name_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate+compile_only

; doc{
;
; ['] "bracket-tick"
;   Compilation: ( "name" -- )
;
; Compilation: If _name_ is found in the current search order,
; compile its execution token as a literal, else `throw` an
; exception.
;
; ``[']`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : ['] \ Compilation: ( "name" -- )
;   ' postpone literal ; immediate
; ----

; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; See: `literal`, `'`, `['']`.
;
; }doc

  dw tick_,literal_
  dw exit_

; ----------------------------------------------
  _alias_header begin_,'begin',immediate+compile_only,backward_mark_

; doc{
;
; begin
;   Compilation: ( C: -- dest )
;   Run-time:    ( -- )
;
; Mark the start of a sequence for repetitive execution, leaving
; _dest_ to be resolved by the corresponding `until`, `again` or
; `repeat`.
;
; ``begin`` is an `immediate` and `compile-only` `alias` of
; `<mark`.
;
; Definition:

; ----
; ' <mark alias begin immediate compile-only
;   \ Compilation: ( C: -- dest )
;   \ Run-time:    ( -- )
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `while`, `do`.
;
; }doc

; ----------------------------------------------
  _alias_header then_,'then',immediate+compile_only,forward_resolve_

; doc{
;
; then
;   Compilation: ( C: orig -- )
;   Run-time:    ( -- )

;
; Resolve the forward reference _orig_, usually left by `if` or
; `while`.
;
; ``then`` is an `immediate` and `compile-only` `alias` of
; `>resolve`.
;
; Definition:

; ----
; ' >resolve alias then immediate compile-only
;   \ Compilation: ( C: orig -- )
;   \ Run-time:    ( -- )
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `else`, `ahead`.
;
; }doc

; ----------------------------------------------
  _colon_header until_,'until',immediate+compile_only

; doc{
;
; until
;   Compilation: ( C: dest -- )
;   Run-time:    ( f -- )

;
; Compilation: Compile a conditional `0branch` to the backward
; reference _dest_, usually left by `begin`.
;
; Run-time: If _f_ is zero, continue execution at the location
; specified by _dest_.
;
; ``until`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : until \ Compilation: ( C: dest -- )
;         \ Run-time:    ( f -- )
;   compile 0branch <resolve ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `while`, `again`, `repeat`, `<resolve`, `compile`,
; `0until`, `-until`, `+until`.
;
; }doc

  dw compile_,zero_branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header again_,'again',immediate+compile_only

; doc{
;
; again
;   Compilation: ( C: dest -- )
;   Run-time:    ( -- )

;
; Compilation: Compile an unconditional `branch`
; to the backward reference _dest_, usually left by `begin`.
;
; Run-time: Continue execution at the location specified by
; _dest_.
;
; ``again`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : again \ Compilation: ( C: dest -- )
;         \ Run-time:    ( -- )
;   compile branch <resolve ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Uncontrolled Reference Words), Forth-94 (CORE EXT),
; Forth-2012 (CORE EXT).
;
; See: `until`, `repeat`.
;
; }doc

  dw compile_,branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header repeat_,'repeat',immediate+compile_only

; doc{
;
; repeat
;   Compilation: ( C: orig dest -- )
;   Run-time:    ( -- )

;
; Compilation: Compile an unconditional `branch` to the backward
; reference _dest_, usually left by `begin`.  Resolve the
; forward reference _orig_, usually left by `while`.
;
; Run-time: Continue execution at the location specified by
; _dest_.
;
; ``repeat`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : repeat \ Compilation: ( C: orig dest -- )
;          \ Run-time:    ( -- )
;   postpone again postpone then ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `again`, `then`, `until`.
;
; }doc

  dw again_ ; unconditional branch back to `begin`
  dw then_ ; resolve the forward branching needed by `while`
  dw exit_

; ----------------------------------------------
  _colon_header if_,'if',immediate+compile_only

; doc{
;
; if
;   Compilation: ( C: -- orig )
;   Run-time:    ( f -- )

;
; Compilation: Compile a conditional `0branch` and put the
; location _orig_ of its unresolved destination on the
; control-flow stack, to be resolved by `else` or `then`.
;
; Run-time: If _f_ is zero, continue execution at the location
; specified by the resolution of _orig_.
;
; ``if`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : if \ Compilation: ( C: -- orig )
;      \ Run-time:    ( f -- )
;   compile 0branch >mark ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `again`, `until`, `ahead`, `0if`, `-if`, `+if`, `andif`,
; `orif`.
;
; }doc

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header ahead_,'ahead',immediate+compile_only

; doc{
;
; ahead
;   Compilation: ( C: -- orig )
;   Run-time:    ( -- )

;
; Compilation: Compile an unconditional `branch` and put the
; location _orig_ of its unresolved destination on the
; control-flow stack.
;
; Run-time: Continue execution at the location specified by the
; resolution of _orig_.
;
; ``ahead`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : ahead \ Compilation: ( C: -- orig )
;         \ Run-time:    ( -- )
;   compile branch >mark ; immediate compile-only
; ----

; Origin: Forth-94 (TOOLS EXT), Forth-2012 (TOOLS EXT).
;
; }doc

  dw compile_,branch_,forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header else_,'else',immediate+compile_only

; doc{
;
; else
;   Compilation: ( C: orig1 -- orig2 )
;   Run-time:    ( -- )

;
; Compilation: Resolve the forward reference _orig1_, usually
; left by `if`.  Put the location of a new unresolved forward
; reference _orig2_ onto the control-flow stack, usually to be
; resolved by `then`.
;
; Run-time: Continue execution at the location specified by the
; resolution of _orig2_.
;
; ``else`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : else \ Compilation: ( C: orig1 -- orig2 )
;        \ Run-time:    ( -- )
;   ahead cs-swap then ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `ahead`, `cs-swap`.
;
; }doc

  dw ahead_
  dw cs_swap_
  dw then_
  dw exit_

; ----------------------------------------------
  _colon_header while_,'while',immediate+compile_only

; doc{
;
; while
;   Compilation: ( C: dest -- orig dest )
;   Run-time:    ( f -- )

; Compilation: Put the location of a new unresolved forward
; reference _orig_ onto the control-flow stack, under the
; existing _dest_. Usually _orig_ and _dest_ are resolved by
; `repeat`.
;
; Run-time: If _f_ is zero, continue execution at the location
; specified by the resolution of _orig_.
;
; ``while`` is an `immediate` and `compile-only` word.
;
; Definition:

; ----
; : while \ Compilation: ( C: dest -- orig dest )
;         \ Run-time:    ( f -- )
;   postpone if cs-swap ; immediate compile-only
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `if`, `until`, `cs-swap`, `postpone`, `0while`, `-while`,
; `+while`.
;
; }doc

  dw if_
  dw swap_ ; XXX TODO -- `cs-swap`, an alias defined in the library
  dw exit_

; ----------------------------------------------
  _code_header spaces_,'spaces'

; doc{
;
; spaces ( n -- )
;
; If _n_ is greater than zero, display _n_ spaces.
;
; ``spaces`` is written in Z80. Its equivalent definition in
; Forth is the following:

; ----
; : spaces ( n -- ) bl swap emits ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `space`, `bl`, `emits`.
;
; }doc

                    ;  T  B
                    ; -- --
  ld hl,space_char  ; 10 03
  ex (sp),hl        ; 19 01
  push hl           ; 11 01
                    ; -- --
                    ; 40 05 Total

  ; Execution continues in `emits`:

; ----------------------------------------------
  _colon_header emits_,'emits'

; doc{
;
; emits ( c n -- )
;
; If _n_ is greater than zero, display _n_ characters _c_.
;
; Definition:

; ----
; : emits ( c n -- ) 0 max 0 ?do dup emit loop drop ;
; ----

; }doc

  _literal 0
  dw max_
  _literal 0
  dw paren_question_do_,emits.loop_exit ; do
  dw dup_,emit_
  dw paren_loop_ ; loop
emits.loop_exit:
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header less_number_sign_,'<#'

; doc{
;
; <# ( -- ) "less-number-sign"
;
; Initialize the pictured numeric output process:
; Set `hld` to its initial value, right below `pad`.
;
; Definition:

; ----
; : <# ( -- ) pad hld ! ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `/hold`, `#>`, `#`, `#s`, `hold`, `holds`, `sign`.
;
; }doc

  dw pad_,hld_,store_
  dw exit_

; ----------------------------------------------
  _colon_header number_sign_greater_,'#>'

; doc{
;
; #> ( xd -- ca len ) "number-sign-greater"
;
; End the pictured numeric output conversion that was started by
; `<#`: Drop _xd_ and make the pictured numeric output string
; available as the string _ca len_.
;
; Definition:

; ----
; : #> ( xd -- ca len ) 2drop hld @ pad over - ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `#`, `#s`, `hold`, `hld`, `sign`, `pad`.
;
; }doc

  dw two_drop_
  dw hld_,fetch_
  dw pad_,over_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header sign_,'sign'

; doc{

; sign ( n  --  )

; If _n_ is negative, add a minus sign to the beginning of the
; pictured numeric output string.
;
; Definition:

; ----
; : sign ( n -- ) 0< if '-' hold then ;
; ----

; Origin: Forth 94 (CORE), Forth-2012 (CORE).
;
; See: `<#`, `#>`, `hold`.
;
; }doc

  dw zero_less_than_
  dw zero_branch_,sign.end
  _literal '-'
  dw hold_
sign.end:
  dw exit_

; ----------------------------------------------
  _code_header to_digit_,'>digit'

; doc{
;
; >digit ( n -- c ) "to-digit"
;
; Convert a number to its character digit: 0 .. 9A .. Z.
;
; ``>digit`` is written in Z80. Its equivalent definition if
; Forth is the following:

; ----
; : >digit ( n -- c )
;   dup 9 > [ 'A' '0' - 1+ ] literal and + '0' + ;
; ----

; }doc

  ; Credit:
  ;
  ; Adapted from Z88 CamelForth.

  pop hl
  ld a,l
  cp 10
  jr c,to_digit.end
  add a,7
to_digit.end:
  add a,$30
  ld l,a
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header number_sign_,'#'

; doc{
;
; # ( ud1 -- ud2 ) "number-sign"
;
; Divide _ud1_ by the number in `base`, giving the quotient
; _ud2_ and the remainder _n_. (_n_ is the least significant
; digit of _ud1_.)  Convert _n_ to external form and add the
; resulting character to the beginning of the pictured numeric
; output string that was started by `<#`.
;
; ``#`` is tipically used between `<#` and `#>`.
;
; Definition:

; ----
; : # ( ud1 -- ud2 ) base @ ud/mod rot >digit hold ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `hold`, `ud/mod`, `>digit`.
;
; }doc

  dw base_,fetch_
  dw u_d_slash_mod_,rot_,to_digit_,hold_
  dw exit_

; ----------------------------------------------
  _colon_header u_d_slash_mod_,'ud/mod'

; doc{
;
; ud/mod ( ud1 u2 -- u3 ud4 ) "u-d-slash-mod"
;
; An unsigned mixed magnitude math operation which leaves a
; double quotient _ud4_ and remainder _u3_, from a double
; dividend _ud1_ and single divisor _u2_.
;
; Definition:

; ----
; : ud/mod ( ud1 u1 -- urem udquot )
;   >r 0 r@ um/mod -rot r> um/mod rot ;
; ----

; Origin: fig-Forth's ``m/mod``, Gforth, Z88 CamelForth.
;
; }doc

  ; Credit:
  ; Code modified from Z88 CamelForth.

; XXX REMARK -- Benchmarked on 2016-03-15 with this version from
; Gforth:

; : ud/mod ( ud1 u2 -- u3 ud4 )
;   >r 0 r@ um/mod r> swap >r um/mod r> ;

  dw to_r_
  _literal 0
  dw r_fetch_
  dw u_m_slash_mod_
  dw minus_rot_
  dw from_r_
  dw u_m_slash_mod_
  dw rot_
  dw exit_

; ----------------------------------------------
  _code_header minus_rot_,'-rot'

; doc{
;
; -rot ( x1 x2 x3 -- x3 x1 x2 ) "minus-rot"
;
; Rotate the top three stack entries in reverse order.
;
; See: `rot`, `over`, `tuck`, `swap`, `roll`, `pick`, `unpick`.
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Afera.

  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  push de
  push hl
  _jp_next

; ----------------------------------------------
  _colon_header number_sign_s_,'#s'

; doc{
;
; #s ( ud1 -- ud2 ) "number-sign-s"
;
; Convert one digit of _ud1_ according to the rule for `#`.
; Continue conversion until the quotient is zero. _ud2_ is zero.
; Used between `<#` and `#>`.
;
; Definition:

; ----
; #s ( ud1 -- ud2 ) begin # 2dup or 0until ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

number_sign_s.begin:
  dw number_sign_,two_dup_,or_
  dw question_branch_,number_sign_s.begin
  dw exit_

; ----------------------------------------------
  _colon_header d_to_str_,'d>str'

; doc{
;
; d>str ( d>str -- ca len ) "d-to-s-t-r"
;
; Convert _d_ to string _ca len_ in the pictured numeric output
; string buffer.
;
; ``d>str`` is a factor of `d.r`.
;
; Definition:

; ----
; : d>str ( d -- ca len ) tuck dabs <# #s rot sign #> ;
; ----

; WARNING: The pictured numeric output string buffer is a
; transient region (with maximum size `/hold` bytes below `pad`,
; and start pointed by `hld`). Therefore the string _ca len_
; must be used or preserved before the buffer is moved or
; overwritten.
;
; See: `<#`, `#s`, `sign` ,`#>`, `>stringer`, `s,`,
; `cmove`.
;
; }doc

  dw tuck_  ; save the high part of _d_ to calculate the sign
  dw d_abs_,less_number_sign_,number_sign_s_,rot_,sign_,number_sign_greater_
  dw exit_

; ----------------------------------------------
  _code_header zero_d_dot_r_,'0d.r'

; doc{
;
; 0d.r ( d -- ) "zero-d-dot-r"
;
; Display _d_ according to current base, with no leading or
; trailing spaces.  ``d0.r`` is a faster alternative to the
; idiom ``0 d.r``.
;
; ``0d.r`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : 0d.r ( d -- ) 0 d.r ;
; ----

; See: `d.r`, `0.r`.
;
; }doc

  ld hl,0
  push hl

  ; Execution continues in `d.r`:

; ----------------------------------------------
  _colon_header d_dot_r_,'d.r'

; doc{
;
; d.r ( d n -- ) "d-dot-r"
;
; Display _d_ right aligned in a field _n_ characters wide. If
; the number of characters required to display _d_ is greater
; than _n_, all digits are displayed with no leading spaces in a
; field as wide as necessary.
;
; Definition:

; ----
; : d.r ( d n -- ) >r d>str r> over - spaces type ;
; ----

; Origin: fig-Forth, Forth-79 (Double Number Word Set), Forth-83
; (Double Number Extension Word Set)footnote:[In Forth-83, if
; the number of characters required to display _d_ is greater
; than _n_, an error condition exists, which depends on the
; system.], Forth-94 (DOUBLE), Forth-2012 (DOUBLE).
;
; See: `d>str`, `ud.r`, `.r`, `0d.r`, `<#`.
;
; }doc

  dw to_r_ ; save _n_
  dw d_to_str_
  dw from_r_,over_,minus_,spaces_ ; preceding blanks
  dw type_
  dw exit_

; ----------------------------------------------
  _code_header zero_dot_r_,'0.r'

; doc{
;
; 0.r ( n -- ) "zero-dot-r"
;
; Display _n_ according to current base, with no leading or
; trailing spaces.  ``0.r`` is a faster alternative to the idiom
; ``0 .r``.
;
; ``0.r`` is written in Z80. Its equivalent definition in Forth
; is the following:

; ----
; : 0.r ( n -- ) 0 .r ;
; ----

; See: `.r`, `0d.r`.
;
; }doc

  ld hl,0
  push hl

  ; Execution continues in `.r`:

; ----------------------------------------------
  _colon_header dot_r_,'.r'

; doc{
;
; .r ( n1 n2 -- ) "dot-r"
;
; Display _n1_ right aligned in a field _n2_ characters wide. If
; the number of characters required to display _n1_ is greater
; than _n2_, all digits are displayed with no leading spaces in
; a field as wide as necessary.
;
; Definition:

; ----
; : .r ( n1 n2 -- ) >r s>d r> d.r ;
; ----

; Origin: Forth-79 (Reference Word Set)footnote:[In Forth-79, if
; _n2_ is less than 1, no leading blanks are supplied.],
; Forth-83 (Controlled Reference Word)footnote:[In Forth-83, if
; the number of characters required to display _n1_ is greater
; than _n2_, an error condition exists, which depends on the
; system.], Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `u.r`, `d.r`, `0.r`, `s>d`.
;
; }doc

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_,'d.'

; doc{
;
; d. ( d -- ) "d-dot"
;
; Display _d_ according to current base, followed by one blank.
;
; Origin: fig-Forth, Forth-79 (Double Number Word Set), Forth-83
; (Double Number Extension Word Set), Forth-94 (DOUBLE),
; Forth-2012 (DOUBLE).
;
; See: `ud.`, `.`, `f.`.
;
; }doc

  dw zero_d_dot_r_,space_
  dw exit_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; . ( n -- ) "dot"
;
; Display signed integer _n_ according to current `base`,
; followed by one blank.
;
; See: `?`, `u.`, `d.`, `f.`.
;
; }doc

  dw s_to_d_,d_dot_
  dw exit_

; ----------------------------------------------
  _colon_header u_dot_,'u.'

; doc{
;
; u. ( u -- ) "u-dot"
;
; Display _u_ in free field format.
;
; Definition:

; ----
; : u. ( u -- ) s>d ud. ;
; ----

; Origin: Forth-79 (Required Word Set), Forth-83 (Required Word
; Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; See: `u.r`, `ud.`, `.`.
;
; }doc

  _literal 0 ; XXX TODO -- `s>d`
  dw d_dot_ ; XXX TODO -- `ud.`
  dw exit_

; ----------------------------------------------

if 0 ; debugging

  _colon_header dot_s_,'.s'

  ; XXX REMARK -- This word is in the library. This copy is
  ; preserved to be activated for debugging.

  dw depth_,dup_
  _literal '<'
  dw emit_
  _literal 0
  dw dot_r_
  _literal '>'
  dw emit_
  dw space_

  _literal 1
  dw less_than_
  dw question_exit_

  dw sp_fetch_,sp0_,fetch_,cell_minus_
  dw paren_do_,dot_s.loop_exit ; do
  dw i_,fetch_
dot_s.dot:
  dw dot_
  _literal -cell
  dw paren_plus_loop_ ; loop
dot_s.loop_exit:

  dw exit_

endif

; ----------------------------------------------

if 0 ; developing

  _colon_header u_dot_s_,'u.s'

  ; XXX REMARK -- This word is in the library. This copy is
  ; preserved to be activated for debugging.

  dw lit_,u_dot_,lit_,dot_s.dot,store_ ; patch `.s`
  dw dot_s_
  dw lit_,dot_,lit_,dot_s.dot,store_ ; unpatch `.s`
  dw exit_

endif

; ----------------------------------------------

if 0 ; debugging

  ; XXX TMP -- for debugging

  _colon_header type_ascii_,'type-ascii'

  ; XXX REMARK -- `type-ascii` is in the library. It's also here
  ; because it's needed by `blks`.

  dw bounds_
  dw paren_question_do_,type_ascii.loop_exit
  dw i_,c_fetch_,dup_,dup_
  _literal 127
  dw greater_than_
  dw swap_,b_l_,less_than_,or_
  dw zero_branch_,type_ascii.then
  dw drop_
  _literal '.'
type_ascii.then:
  dw emit_
  dw paren_loop_
type_ascii.loop_exit:
  dw exit_

endif

; ----------------------------------------------

if 0 ; debugging

  ; XXX TMP -- for debugging

  _colon_header blks_,'blks'

; : blks ( u -- )
;   page
;   20 bounds ?do
;     i block drop
;     i 3 .r space buffer-data 28 type-ascii
;     \ key 'q' = if  unloop exit  then  \ XXX OLD
;   loop ;
; ----

; Read 20 blocks, starting from block _u_, and display the start
; of their first lines.  ``blks`` is useful when a new DOS is
; implemented, in order to check the disk access calculations.

  dw page_
  _literal 20
  dw bounds_
  dw paren_question_do_,blks.loop_exit
  dw i_,block_,drop_
  dw i_
  _literal 3
  dw dot_r_,space_
  dw buffer_data_
  _literal 28
  dw type_ascii_

if 0

  ; XXX OLD
  dw key_
  _literal 'q'
  dw equals_
  dw zero_branch_,blks.continue
  dw unloop_,exit_
blks.continue:

endif

  dw paren_loop_
blks.loop_exit:
  dw exit_

endif

; ----------------------------------------------
  _colon_header page_,'page'

; doc{
;
; page ( -- )
;
; Move to another page for output.  On a terminal, ``page`` clears
; the screen and resets the cursor position to the upper left
; corner. On a printer, ``page`` performs a form feed.
;
; Origin: Forth-79 (Reference Word Set), Forth-83 (Uncontrolled
; Reference Words), Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; See: `cls`.
;
; }doc

  dw printing_,fetch_
  dw zero_branch_,page.display
  _literal form_feed_char
  dw emit_
  dw exit_

page.display:
  dw cls_
  dw exit_

; ----------------------------------------------
  _variable_header os_sp_,'os-sp'

; doc{
;
; os-sp ( -- a ) "os-s-p"
;
; A `variable`. _a_ is the address of a cell containing a copy of
; the OS stack pointer, which is saved when the Forth system is
; entered from BASIC, and then restored by `(bye` before
; returning to BASIC.
;
; }doc

  ; XXX TMP -- For debugging of the TR-DOS support.  Formerly
  ; the OS stack pointer was stored in the code of `(bye`.

system_stack_pointer:
  dw 0

; ----------------------------------------------
  _code_header paren_bye_,'(bye'

; doc{
;
; (bye ( -- ) "paren-bye"
;
; Restore the two lower lines of the screen, as expected by
; BASIC, set interrupt mode 1, restore the OS stack pointer,
; restore the alternate HL Z80 register, and finally force a
; "STOP" BASIC error in order to return control to the host OS.
;
; ``(bye`` is the final low-level procedure of `bye`.
;
; }doc

  ld (iy+sys_df_sz_offset),$02 ; restore lines of the lower screen

  im 1 ; interrupt mode 1, normal situation of the OS

  ld sp,(system_stack_pointer) ; restore the system stack

; The Complete Spectrum ROM Disassembly
; (http://www.worldofspectrum.org/infoseekid.cgi?id=2000076),
; page 201, states:
;
; For a successful return to BASIC, H'L' must on exit from the
; machine code contain the address in SCANNING of the 'end-calc'
; instruction, 2758 hex (10072 decimal).

  ld hl,$2758
  exx

  ; Exit to BASIC:
  rst $08
  db $08 ; "STOP" BASIC error

; ----------------------------------------------
  _defer_header default_mode_,'default-mode',,noop_

; doc{
;
; default-mode ( -- )
;
; A deferred word that activates the default screen mode. It's
; set to `noop` until the first mode change is done. Then it's
; vectored to `mode-32`.  It's used by `bye` and `cold`.
;
; See: `reset-default-mode`, `defer`, `default-display`,
; `default-font`, `default-colors`.
;
; }doc

; ----------------------------------------------
  _code_header reset_default_mode_,'reset-default-mode'

; doc{
;
; reset-default-mode ( -- )
;
; Set `default-mode` to its default action `noop`.
; ``reset-default-mode`` is executed by `cold`.
;
; }doc

  ld hl,noop_
  ld (default_mode_+1),hl
  _jp_next

; ----------------------------------------------
  _colon_header bye_,'bye'

; doc{
;
; bye ( -- )
;
; Return control to the host OS.
;
; Definition:

; ----
; : bye ( -- ) save-mode default-mode (bye ;
; ----

; Origin: Forth-94 (TOOLS EXT), Forth-2012 (TOOLS EXT).
;
; See: `save-mode`, `default-mode`, `(bye`, `warm`,
; `cold`.
;
; }doc

  dw save_mode_
  dw default_mode_
  dw paren_bye_
  ; No return from `(bye`.

; ----------------------------------------------
  _code_header two_drop_,'2drop'

; doc{
;
; 2drop ( x1 x2 -- ) "two-drop"
;
; Remove cell pair _x1 x2_ from the stack.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `drop`, `nip`.
;
; }doc

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2swap'

; doc{
;
; 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 ) "two-swap"
;
; Exchange the top two cell pairs.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `swap`, `2over`.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth

                      ;   T  B
                      ; --- --
  exx                 ;  04 01
  pop hl  ; HL'=x4    ;  10 01
  pop de  ; DE'=x3    ;  10 01
  exx                 ;  04 01
  pop hl  ; HL=x2     ;  10 01
  pop de  ; DE=x1     ;  10 01
  exx                 ;  04 01
  push de ; x3        ;  11 01
  push hl ; x4        ;  11 01
  exx                 ;  04 01
  push de             ;  11 01
  push hl             ;  11 01
  _jp_next            ;  08 02 jp (ix)
                      ; --- --
                      ; 108 14 Total

; ----------------------------------------------
  _variable_header limit_,'limit'

; doc{
;
; limit ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; address above the highest address usable by the data space
; (the data space is the region addressed by `dp`). Its default
; value is zero, which is right above the highest memory address
; ($FFFF).
;
; ``limit`` can be modified by a program in order to reserve a
; memory zone for special purposes.
;
; Origin: Fig-Forth's ``limit`` constant.
;
; See: `unused`, `farlimit`, `fyi`, `greeting`.
;
; }doc

  dw 0

; ----------------------------------------------
  _variable_header farlimit_,'farlimit'

; doc{
;
; farlimit ( -- a )
;
; A `variable`. _a_ is the address of a cell containing the
; address above the highest address usable by the name space
; (the region addressed by `np`). Its default value, which is
; restored by `cold`, is $0000 on G+DOS and TR-DOS, and $C000 on
; +3DOS.
;
; ``farlimit`` can be modified by a program in order to reserve
; a far-memory zone for special purposes.
;
; Origin: Fig-Forth's ``limit`` constant.
;

; ifndef::plus3dos[]
;
; See: `farunused`, `limit`, `far-banks`, `fyi`, `greeting`.
;
; endif::[]

; ifdef::plus3dos[]
;
; See: `farunused`, `limit`, `far-banks`, `default-1346`,
; `fyi`, `greeting`.
;
; endif::[]

; }doc

if plus3dos
  dw $C000 ; use 48 KiB of far memory (16 KiB are used for cache and RAM disk)
else
  dw $0000 ; use 64 KiB of far memory
endif

; ----------------------------------------------
  _colon_header unused_,'unused'

; doc{
;
; unused ( -- u )
;
; _u_ is the amount of space remaining in the region addressed
; by `here`, in bytes.  This region includes the
; transient spaces addressed by `pad` and `hold`.
;
; Definition:

; ----
; : unused ( -- u ) limit @ here - ;
; ----

; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; See: `limit`, `here`, `farunused`, `os-unused`, `fyi`,
; `greeting`.
;
; }doc

  dw limit_,fetch_,here_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header farunused_,'farunused'

; doc{
;
; farunused ( -- u )
;
; Return the amount of far-memory space remaining in the region
; addressed by `np`, in bytes.
;
; Definition:

; ----
; : farunused ( -- u ) farlimit @ np @ - ;
; ----

; See: `farlimit`, `unused`, `os-unused`, `fyi`, `greeting`.
;
; }doc

  dw farlimit_,fetch_,np_fetch_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header mode_32_at_xy_,'mode-32-at-xy'

; doc{

; mode-32-at-xy ( col row -- ) "mode-32-at-x-y"
;
; Default action of `at-xy`, in `mode-32`.
;
; WARNING: The system will crash if the coordinates are out of
; screen.  For the sake of speed, no check is done.  If needed,
; the program can use a wrapper word.
;
; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  dw dup_
  _literal 23
  dw not_equals_ ; not the last row?
  dw zero_branch_,at_dfa.last_line
  ; not the last row
  _literal 22
  dw mode_32_emit_,mode_32_emit_,mode_32_emit_
  dw exit_

at_dfa.last_line:
  dw one_minus_,dup_,mode_32_emit_,mode_32_emit_
  _literal 0
  dw mode_32_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; the screen address of the display position
  dw plus_store_
  _literal 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for display position
  dw c_store_
  dw exit_

; ----------------------------------------------
  _code_header cls_,'cls'

; doc{
;
; cls ( -- ) "c-l-s"
;
; Clear the screen with the current attribute, reset the graphic
; coordinates at the lower left corner (gx 0, gy 0) and reset
; the cursor position at the upper left corner (column 0, row
; 0).
;
; See: `attr!`, `attr-cls`, `page`, `wcls`.
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

  exx ; save the Forth IP
  ld a,(sys_attr_t)
  jr attr_cls.a

; ----------------------------------------------
  _code_header attr_cls_,'attr-cls'

; doc{
;
; attr-cls ( b -- ) "attr-c-l-s"
;
; Clear the screen with the attribute _b_, reset the graphic
; coordinates at the lower left corner (x 0, y 0) and reset the
; cursor position at the top left corner (column 0, row 0).
;
; See: `cls`, `page`, `attr-wcls`.
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

; Credit:
;
; The attributes part was improved after code by Dean Belfield
; <http://wordpress.animatez.co.uk/programming/assembly-language/z80/z80-library-routines/204-2/>.
;
; The idea for `ld (hl),l` was found in David Webb's _Advanced
; Spectrum Machine Language_.

  exx ; save the Forth IP
  pop hl
  ld a,l

attr_cls.a: ; alternative entry point used by `cls`

  ; Erase the bitmap:
  ld hl,sys_screen
  ld de,sys_screen+1
  ld bc,sys_screen_bitmap_size
  ld (hl),l ; L=0 because sys_screen=$4000
  ldir
  ; Color with attribute in the A register:
  ld bc,sys_screen_attributes_size-1
  ld (hl),a
  ldir
  ld (sys_coords),bc ; reset the graphic coordinates to 0,0
  exx ; restore the Forth IP

  ; Execution continues in `home`:

; ----------------------------------------------
  _defer_header home_,'home',,paren_home_

; doc{
;
; home ( -- )
;
; Set the cursor position at the top left position (column 0,
; row 0).
;
; ``home`` is a deferred word, whose default action is `(home`.
;
; See: `at-xy`, `home?`, `defer`.
;
; }doc

; ----------------------------------------------
  _code_header paren_home_,'(home'

; doc{
;
; (home ( -- ) "paren-home"
;
; Default action of `home`: Set the cursor position at the
; top left position (column 0, row 0).
;
; }doc

  ld hl,$0000
  push hl
  push hl

  ; Execution continues in `at-xy`:

; ----------------------------------------------
  _defer_header at_xy_,'at-xy',,mode_32_at_xy_

; doc{
;
; at-xy ( col row -- ) "at-x-y"
;
; Set the cursor coordinates to column _col_ and row _row_.  The
; upper left corner is column zero, row zero.
;
; ``at-xy`` is a deferred word whose default action is
; `mode-32-at-xy`.
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; See: `home`, `defer`.
;
; }doc

; ----------------------------------------------
  _colon_header mode_32_xy_,'mode-32-xy'

; doc{
;
; mode-32-xy ( -- col row ) "mode-32-x-y"
;
; Return the current cursor coordinates _col row_ in `mode-32`
; and `mode-32iso`.
;
; ``mode-32-xy`` is the action of `xy` when `mode-32` or
; `mode-32iso` are active, or by default when no alternative
; display mode has been used (e.g. `mode-64ao`).
;
; Definition:

; ----
; : mode_32-xy ( -- col row )
;   24 23689 c@ -
;   33 23688 c@ - dup 32 = if  drop 1+ 0  then  swap ;
;   \ 23688 = OS variable S_POSX
;   \ 23689 = OS variable S_POSY
; ----

; }doc

  ; Credit:
  ; Code from the Spectrum Forth-83 manual.

  _literal 24
  _literal sys_s_posy
  dw c_fetch_,minus_
  _literal 33
  _literal sys_s_posx
  dw c_fetch_,minus_
  dw dup_
  _literal 32 ; XXX TODO -- Chars per line in the current mode,
              ;             in case this word can be reused
              ;             by other modes.
  dw equals_
  dw zero_branch_,mode_32_xy.end
  dw drop_,one_plus_
  _literal 0
mode_32_xy.end:
  dw swap_
  dw exit_

; ----------------------------------------------
  _defer_header xy_,'xy',,mode_32_xy_

; doc{
;
; xy ( -- col row ) "x-y"
;
; Return the current column and row of the text cursor.
;
; ``xy`` is a deferred word whose default action is `mode-32-xy`.
;
; See: `at-xy`, `defer`.
;
; }doc

; ----------------------------------------------
  _code_header default_colors_,'default-colors'

; doc{
;
; default-colors ( -- )
;
; Set the screen colors to the default values.
;
; See: `default-display`, `default-mode`, `default-font`.
;
; }doc

  ; Deactivate temporary and permanent display flags (over,
  ; inverse, contrast ink, contrast paper).

  xor a
  ld (sys_p_flag),a

  ; Set the default attribute and mask:

  ld hl,(default_attribute_and_mask)
  ; L = 128*flash + 64*bright + 8*paper + ink
  ; H = mask
  ld (sys_attr_p),hl ; permanent
  ld (sys_attr_t),hl ; temporary

  ; Set the border color to the paper color:

  ld a,l ; 128*flash + 64*bright + 8*paper + ink
  and a ; Fc=0
  rra
  rra
  rra ; A = paper
  jr border.a

; ----------------------------------------------
  _code_header border_,'border'

  ; XXX TODO -- Move to the library, but activate here for
  ; debugging.

; doc{
;
; border ( n -- )
;
; Set the border of the screen to color to _n_.  Only the 3
; lower bits of _n_ are used (for colors 0 .. 7).
;
; }doc

  pop hl
  ld a,l
border.a:
  and %00000111 ; force value 0 .. 7
  call $229B ; secondary entry point in the "BORDER" ROM routine
  _jp_next

  ; Note: The ROM routine at $229B also sets the system
  ; variable BORDCR, which holds the attributes of the lower
  ; part of the screen (paper after the border, and calculated
  ; constrast ink).  This is useful because: 1) G+DOS by
  ; default changes the border color during disk operations,
  ; and at the end restores it with the value of this system
  ; variable; 2) The lower screen will have contrast ink after
  ; returning to BASIC, no matter the border color used in
  ; Forth.

; ----------------------------------------------
  _colon_header two_constant_,'2constant'

; doc{
;
; 2constant ( x1 x2 "name" -- ) "two-constant"
;
; Parse _name_. `create` a definition for _name_ that will place
; _x1 x2_ on the stack.  _name_ is referred to as a
; "two-constant".
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (DOUBLE), Forth-2012
; (DOUBLE).
;
; See: `constant`, `cconstant`, `2!>`, `2const`,
; `[2const]`, `2value`, `2variable`.
;
; }doc

  dw create_,two_comma_
  dw paren_semicolon_code_
do_two_constant:

  ; Execution continues in `2@`:

; ----------------------------------------------
  _code_header two_fetch_,'2@'

; doc{
;
; 2@ ( a -- x1 x2 ) "two-fetch"
;
; Fetch the cell pair _x1 x2_ stored at _a_. _x2_ is stored at
; _a_ and _x1_ is stored at the next consecutive cell. It is
; equivalent to the sequence ``dup cell+ @ swap @``.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `2!`, `@`, `c@`.
;
; }doc

  pop hl        ; address
two_fetch.hl:
                ;  T  B
                ; -- --
  ld e,(hl)     ; 07  1
  inc hl        ; 06  1
  ld d,(hl)     ; 07  1 ; DE = low part
  inc hl        ; 06  1
  ld a,(hl)     ; 07  1
  inc hl        ; 06  1
  ld h,(hl)     ; 07  1
  ld l,a        ; 04  1 ; HL = high part
  ex de,hl      ; 04  1
  push de       ; 11  1
  push hl       ; 11  1
  _jp_next      ; 08  2 ; jp (ix)
                ; -- --
                ; 84 13 Total

  ; XXX WARNING -- `two_fetch.hl` is used by `2value`. The
  ; address is calculated from the code field of `2@`.

; ----------------------------------------------
  _code_header two_over_,'2over'

; doc{
;
; 2over ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 ) "two-over"
;
; Copy cell pair _x1 x2_ on top of the stack.
;
; Origin: Forth-79 (Double Number Word Set), Forth-83 (Double
; Number Extension Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `over`, `2swap`.
;
; }doc

  ; XXX REMARK -- `2over` could be moved to the library, using `' 2@
  ; 1+ jp,` to jump into `2@`, but it's needed in `(located`.

  ld hl,$0004
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _alias_header unnest_,'unnest',,r_drop_

; doc{
;
; unnest ( R: nest-sys -- )
;
; Discard the calling definition specified by _nest-sys_.
; Before exiting the current definition, a program shall remove
; any parameters the calling definition had placed on the return
; stack.
;
; ``unnest`` is an `alias` of `rdrop`.
;
; Origin: DX-Forth.
;
; See: `rp`, `exit`, `next`.
;
; }doc

  ; Credit:
  ; http://dxforth.netbay.com.au/unnest.html

; ----------------------------------------------
  _code_header exit_,'exit'

; doc{
;
; exit ( -- ) ( R: nest-sys -- )
;
; Return control to the calling definition, specified by
; _nest-sys_.
;
; Before executing ``exit`` within a `loop`, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; ``exit`` is compiled by `;`. When words contain and endless
; loop, the space used by ``exit`` can be recovered using
; `no-exit`.
;
; In Solo Forth ``exit`` can be used in interpretation mode to
; stop the interpretation of a block, like fig-Forth's ``;s``.
;
; Origin: fig-Forth's ``;s``, Forth-79 (Required Word Set),
; Forth-83 (Required Word Set), Forth-94 (CORE), Forth-2012
; (CORE).
;
; See: `?exit`, `0exit`, `-exit`, `+exit`.
;
; }doc

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl

  ; Inner interpreter:

next:
do_create:
do_variable:

  ; Execute the word whose xt is in the address pointed by the
  ; BC register:

  ; Forth: W  <-- (IP)
  ; Z80:   HL <-- (BC)

  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; BC = address of the next xt
  ; HL = xt

execute_hl:

  ; Execute the word whose xt is in the HL register:

  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (HL)

  jp (hl)

; ----------------------------------------------
  _code_header zero_exit_,'0exit'

; doc{
;
; 0exit ( f -- ) ( R: nest-sys | -- nest-sys | ) "zero-exit"
;
; If _f_ is zero, return control to the calling definition,
; specified by _nest-sys_.
;
; WARNING: ``0exit`` is not intended to be used within a
; `loop`.  Use ``0= if unloop exit then`` instead.
;
; ``0exit`` can be used in interpretation mode to stop the
; interpretation of a block.
;
; See: `?exit`, `exit`, `-exit` ,`+exit`, `0if`, `0while`,
; `0until`, `unloop`.
;
; }doc

  pop hl
  ld a,h
  or l
  jp z,exit_
  _jp_next

; ----------------------------------------------
  _code_header question_exit_,'?exit'

; doc{
;
; ?exit ( f -- ) ( R: nest-sys | -- nest-sys | ) "question-exit"
;
; If _f_ is zero, do nothing. Otherwise return control to the
; calling definition, specified by _nest-sys_.
;
; ``?exit`` is the conditional version of `exit`.
;
; ``?exit`` cannot be used within a `loop`. Use ``if unloop exit
; then`` instead.
;
; ``?exit`` can be used in interpretation mode to stop the
; interpretation of a block.
;
; See: `exit`, `0exit`, `-exit`, `+exit`.
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,exit_
  _jp_next

; ----------------------------------------------
  _colon_header throw_,'throw'

; doc{
;
; throw ( k*x n -- k*x | i*x n )
;
; If _n_ is zero, drop it and continue. Otherwise, pop the
; topmost exception frame from the exception stack, along with
; everything on the return stack above that frame.  Then restore
; the input source specification in use before the corresponding
; `catch` and adjust the depths of all stacks so that they are
; the same as the depths saved in the exception frame (_i_ is
; the same number as the _i_ in the input arguments to the
; corresponding `catch`), put _n_ on top of the data stack, and
; transfer control to a point just after the `catch` that pushed
; that exception frame.
;
; If the top of the stack is non-zero and there is no exception
; frame on the exception stack, i.e. the content of `catcher` is
; zero, `error` is executed with _n_ on top of the stack.
;
; Definition:

; ----
; : throw ( k*x n -- k*x | i*x n )
;   ?dup 0exit
;   catcher @ ?dup 0= \ no catcher?
;   if error then     \ ``error`` does not return
;   rp!               \ restore previous return stack
;   r> catcher !      ( n ) \ restore previous catcher
;   r> swap >r        ( saved-SP ) ( R: n )
;   sp! drop r>       ( n ) \ restore stack
;   unnest-source ;   \ restore previous source specification
; ----

; Origin: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).
;
; }doc

  ; Credit:
  ; Code adapted and improved from DZX-Forth.
  ; Comments from MPE Forth for TiniARM.

  dw question_dup_
  dw zero_exit_
  dw catcher_,fetch_
  dw question_dup_  ; catcher?
  dw question_branch_,throw.catcher ; if so, branch
  dw error_ ; no return from `error`.

throw.catcher:
  dw rp_store_                ; restore previous return stack
  dw from_r_,catcher_,store_  ; ( n ) restore previous catcher
  dw from_r_,swap_,to_r_      ; ( saved-SP ) ( R: n )
  dw sp_store_,drop_,from_r_  ; ( n ) restore stack
  dw unnest_source_
  dw exit_

; ----------------------------------------------
  _colon_header empty_stack_,'empty-stack'

; doc{
;
; empty-stack ( -- )
;
; Empty the data stack.
;
; Definition:

; ----
; : empty-stack ( -- ) sp0 @ sp! ;
; ----

; See: `sp0`, `sp!`, `(abort`.
;
; }doc

  dw sp0_,fetch_,sp_store_
  dw exit_

; ----------------------------------------------
  _colon_header paren_abort_,'(abort'

; doc{
;
; (abort ( -- ) "paren-abort"
;
; Restart the system by emptying the stack and performing
; `quit`.
;
; Definition:

; ----
; : (abort ( -- ) empty-stack boot quit ;
; ----

; See: `error`, `abort`, `boot`, `empty-stack`.
;
; }doc

  dw empty_stack_
  dw boot_  ; XXX TODO -- not here?
  dw quit_
  ; No return from `quit`.

; ----------------------------------------------
  _colon_header abort_,'abort'

; doc{
;
; abort ( -- )
;
; Empty the data stack and perform the function of `quit`, which
; includes emptying the return stack, without displaying a
; message.
;
; Definition:

; ----
; abort ( -- ) -1 throw ;
; ----

; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE, EXCEPTION EXT),
; Forth-2012 (CORE, EXCEPTION EXT).
;
; See: `(abort`, `abort"`, `throw`, `error`.
;
; }doc

  _literal -1
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header s_quote_,'s"',immediate

; doc{
;
; s" "s-quote"
;   Compilation:    ( "ccc<quote>" -- )
;   Interpretation: ( "ccc<quote>" -- ca len )
;   Run-time:       ( -- ca len )
;
; Parse _ccc_ delimited by a double quote.  If interpreting, copy
; the parsed string to the `stringer` and return it as _ca len_.
; If compiling, compile the parsed string and return it at
; run-time as _ca len_.
;
; ``s"`` is an `immediate` word.
;
; Definition:

; ----
; : s" \ Compilation:    ( "ccc<quote>" -- )
;      \ Interpretation: ( "ccc<quote>" -- ca len )
;      \ Run-time:       ( -- ca len )
;   '"' parse-string ; immediate
; ----

; Origin: Forth-94 (CORE, FILE), Forth-2012 (CORE, FILE).
;
; See: `parse-string`, `s\"`, `s'`, `s""`, `."`, `,"`.
;
; }doc

  _literal '"'
  dw parse_string_
  dw exit_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

; doc{
;
; ?\ ( f "ccc<eol>" -- ) "question-backslash"
;
; If _f_ is not zero, execute `\`, else do nothing.
;
; ``?\`` is an `immediate` word.
;
; ``?\`` is a conditional version of `\`, used for conditional
; compilation, as a simpler but more compact alternative to the
; standard `[if]`.
;
; Definition:

; ----
; : ?\ ( "ccc<eol>" -- ) 0exit postpone \ ; immediate
; ----
;
; See: `?(`, `?-->`, `\`.
;
; }doc

  dw zero_exit_
  dw backslash_
  dw exit_

; ----------------------------------------------
  _colon_header to_in_slash_l_,'>in/l'

; doc{
;
; >in/l ( -- n ) "to-in-slash-l"
;
; Return number _n_ of characters already interpreted in the
; current line of the block being interpreted.  No check is done
; whether any block is actually being interpreted.
;
; Definition:

; ----
; : >in/l ( -- n ) >in @ c/l mod ;
; ----

; See: `blk-line`, `->in/l`, `>in`, `c/l`.
;
; }doc

  dw to_in_,fetch_,c_slash_l_,mod_
  dw exit_

; ----------------------------------------------
  _colon_header minus_to_in_slash_l_,'->in/l'

; doc{
;
; ->in/l ( -- n ) "minus-to-in-slash-l"
;
; Return number _n_ of characters not interpreted yet in the
; current line of the block being interpreted.  No check is done
; whether any block is actually being interpreted.
;
; ``->in/l`` is a factor of `\`.
;
; Definition:

; ----
; : ->in/l ( -- n ) c/l >in/l - ;
; ----

; See: `blk-line`, `>in/l`, `>in`, `c/l`.
;
; }doc

  dw c_slash_l_,to_in_slash_l_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

; doc{
;
; \ ( "ccc<eol>" -- ) "backslash"
;
; If `blk` contains zero, parse and discard the remainder of the
; parse area; otherwise parse and discard the portion of the
; parse area corresponding to the remainder of the current line.
;
; ``\`` is an `immediate` word.
;
; Definition:

; ----
; : \ ( "ccc" -- )
;   loading? if ->in/l parsed exit then #tib @ >in ! ;
; ----

; Origin: Forth-94 (BLOCK EXT), Forth-2012 (BLOCK EXT).
;
; See: `(`, `->in/l`.
;
; }doc

  dw loading_question_ ; input stream from disk?
  dw zero_branch_,backslash.interpreting

  ; Loading
  dw minus_to_in_slash_l_,parsed_
  dw exit_

backslash.interpreting:
  ; Interpreting
  dw number_sign_tib_,fetch_,to_in_,store_
  dw exit_

; ----------------------------------------------

if 0

; XXX TMP -- 2019-03-14: Temporary code to check 'scan' and
; `parse`.

  _variable_header ctxt_,'ctxt'
  db 6
  db 'a'
  db 'b'
  db 'c'
  db 128
  db 'e'
  db '"'

  _colon_header txt_,'txt'

  dw ctxt_
  dw count_
  dw exit_

  _colon_header parse2_,'parse2'

; ----
; : parse2 ( char ca1 len1 -- ca len )
;   2dup 2>r rot scan
;   dup if  char-  then
;   2r> rot - drop
;   tuck - ;
; ----

  dw two_dup_,two_to_r_,rot_,scan_
  dw dup_,zero_branch_,parse2.end
  dw char_minus_
parse2.end:
  dw two_from_r_,rot_,minus_
  dw drop_
  dw tuck_,minus_
  dw exit_

endif

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .( ( "ccc<paren>" -- ) "dot-paren"
;
; Parse and display _ccc_ delimited by a right parenthesis.
;
; ``.(`` is an `immediate` word.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE EXT),
; Forth-2012 (CORE EXT).
;
; See: `."`, `(`.
;
; }doc

  _literal ')'
  dw parse_,type_
  dw exit_

  ; Name token of the latest word defined in `forth-wordlist`:
latest_nt_in_forth_word_list: equ dot_paren_nt

  ; Execution token of the latest word defined in `forth-wordlist`:
latest_xt_in_forth_word_list: equ dot_paren_

dictionary_pointer_after_cold:

; ==============================================================
; First-boot only tasks

; The following code is executed only the _first time_ Solo
; Forth boots from the disk.  At the end its call is deactivated
; with a patch; the code itself will be overwritten by the Forth
; dictionary.

first_boot:

; ----------------------------------------------
; Border color

  ld a,7      ; white...
  out($FE),a  ; ...border, just in case

; ----------------------------------------------
; Move the definition headers

; Move the definition headers, which were assembled in ordinary
; memory (from address $C000), to the far memory. The whole
; screen is used as intermediate buffer for copying the data.

  ld hl,bank_start      ; origin
  ld de,sys_screen      ; destination
  ld bc,sys_screen_size ; count
  ldir                  ; copy to the screen

  ld a,(far_banks_dfa)  ; first bank of far memory
  ld e,a
  call bank.e

  ld hl,sys_screen      ; origin
  ld de,bank_start      ; destination
  ld bc,sys_screen_size ; count
  ldir                  ; copy to the bank

  call bank.default

; ----------------------------------------------
; Show the background image

; Solo Forth shows a version-specific background image the first
; time it boots from disk.

  ld hl,background_image ; origin
  ld de,sys_screen ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the background to the screen

; ----------------------------------------------
; Clear memory

; Erase the background image and the zone that was used for the
; headers during the compilation of the kernel.

  ld hl,background_image        ; from the background image
  ld de,background_image+1
  ld bc,$FFFF-background_image  ; to the top of memory
  ld (hl),0
  ldir

; ----------------------------------------------
; Deactivate

; Remove the call to the `first_boot` routine, so it will not be
; executed in future.

  ld hl,call_first_boot
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop

  ret

; ----------------------------------------------
; The background image

background_image:
  incbin ../backgrounds/current.scr

; ==============================================================
; End

  ; Update the counter of words:
  org number_sign_words_dfa
  dw word_count
  org cold.number_sign_words
  dw word_count

end cold_entry

; vim: filetype=z80:textwidth=64
