; kernel.z80s

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; XXX UNDER DEVELOPMENT

; Last modified: 201611191940

include version.z80s

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2015, 2016.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; ==============================================================
; System description

; ----------------------------------------------
; Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before exit.
;       IX   Address of `next`.
;            May be used within Forth words if restored before exit.
;       IY   Address of the ERRNR ZX Spectrum system variable.
;            May be used within Forth words if restored before exit.

; ----------------------------------------------
; Header structure

; The headers are created in paged memory:

; xtp: dw xt               ; Pointer to xt in main memory.
; lfa: dw nt of the previous word
; nt:  db length+flags     ; Bits:      76543210
                           ; Bit names: CPSLLLLL
                           ; Legend:
                           ;   C: Compile-only bit.
                           ;      0 = non-restricted word
                           ;      1 = compile-only word
                           ;   P: Immediate bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;       ds length          ; name

; The code and parameter fields are created in the data space:

; xt:  code
; pfa: ...

; ==============================================================
; Glossary

; At the moment the description of Forth words is included in
; this source.  The markers `doc{` and `}doc` delimitate the
; comments that will be extracted to build the actual glossary.

; ==============================================================
; Configuration

  ; XXX Note: Pasmo issues strange errors (symbols not found)
  ; when some config flags are used in a nested `if`. A literal
  ; flag (0/1) is used instead, with the flag name in a comment;
  ; it is changed with a text substitution.

  ; Solo Forth can be compiled for G+DOS, +3DOS or TR-DOS.  This
  ; depends on three labels, `gplusdos`, `plus3dos` and `trdos`,
  ; defined with a parameter of the Pasmo assembler. See the
  ; Makefile files for details. Support for +3DOS and TR-DOS is
  ; not finished yet.

if (!defined gplusdos) and (!defined plus3dos) and (!defined trdos)
  gplusdos equ true ; G+DOS by default
endif

size_optimization: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

;assembler_core_in_kernel: equ true
  ; XXX REMARK -- this flag is harcoded in the code

developing: equ true
  ; true = include some words needed during the development
  ; false = don't

;far_memory: equ true
  ; XXX REMARK -- this flag is harcoded in the code
  ; XXX UNDER DEVELOPMENT
  ; How to store the dictionary headers?:
  ; true = use a virtual 64-KiB memory space built from 4 banks,
  ;        called "far memory"
  ; false = use one single 16-KiB bank, called "system bank"

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

default_origin:                   equ $5E00

if defined trdos

 ; TR-DOS needs 112 ($70) bytes of RAM for its system variables.
 ; It also uses a 256 ($100) bytes buffer when accessing the
 ; disk.  This buffer is allocated dynamically. Therefore, the
 ; default origin of the Forth system must be moved up.

  ;origin:                         equ default_origin+$170
  origin:                         equ default_origin+$800 ; XXX TMP --

else

  origin:                         equ default_origin

endif

ramtop:                           equ origin-1 ; used by the BASIC loader

false:                            equ $0000
true:                             equ $FFFF ; -1

cell:                             equ $02

cells_per_data_stack:             equ $50
cells_per_return_stack:           equ $56

  ; XXX REMARK -- 2016-11-19: The return stack has been
  ; increased from $50 to $55 cells. The loading of `tt` (a
  ; sample game) needs $55 cells; `blocked` (a block editor)
  ; needs $54 cells.  Formerly the terminal input buffer was
  ; below the return stack and worked as a pad for it, so the
  ; problem was unnoticed.  But the terminal input buffer was
  ; moved on 2016-11-15 in order to make all buffers contiguous
  ; so the circular string buffer can be expandable.
  ;
  ; As a temporary solution, also the return stack is checked in
  ; `?stack`, when the developing label is on.
  ;
  ; XXX TODO -- Move the terminal input buffer below the return
  ; stack? Moving the stacks to the top of the memory is
  ; incompatible with the far memory and with the future support
  ; of +3DOS.
  ;
  ; XXX TODO -- Write `?rstack` and make `?stack` configurable?

bytes_per_terminal_input_buffer:  equ $50

bytes_per_buffer:                 equ $0400

if defined gplusdos
  blocks_per_disk:                  equ 800
  sectors_per_block:                equ $02
  max_drives:                       equ 2
endif
if defined plus3dos
  blocks_per_disk:                  equ 720
  sectors_per_block:                equ $02
  max_drives:                       equ 2
endif
if defined trdos
  blocks_per_disk:                  equ 636 ; 640 minus 4 KiB of sector 0
  sectors_per_block:                equ $04
  max_drives:                       equ 4
endif

bytes_per_sector:                 equ bytes_per_buffer/sectors_per_block
; XXX TODO -- move to the library

characters_per_line:              equ $40
lines_per_screen:                 equ $10
max_search_order:                 equ $08 ; maximum number of word lists in the search order
bytes_per_user_variables:         equ $40

word_length_mask:                 equ %00011111
smudge_mask:                      equ %00100000
immediate_mask:                   equ %01000000
compile_only_mask:                equ %10000000

max_word_length:                  equ word_length_mask
valid_word_length_mask:           equ word_length_mask or smudge_mask

csb_size:                         equ 512 ; bytes, size of the circular string buffer

; Memory banks

bank_start                        equ $C000
bank_end                          equ $FFFF
bank_size:                        equ $4000 ; 16 KiB

default_bank:                     equ 0

if 1 ; far_memory
  system_bank:                      equ 1 ; XXX TMP --
  headers_pointer_bottom:           equ $0000
else
  system_bank:                      equ 1
  headers_pointer_bottom:           equ bank_start
endif

; Error codes used in the kernel

error.stack_overflow:               equ -003
error.stack_underflow:              equ -004
error.return_stack_overflow:        equ -005
error.return_stack_underflow:       equ -006
error.dictionary_overflow:          equ -008
error.not_found:                    equ -013
error.compilation_only:             equ -014
error.zero_length_name:             equ -016
error.conditionals_not_paired:      equ -022
error.invalid_block_number:         equ -035
error.not_understood:               equ -256
error.not_unique:                   equ -257
error.stack_unbalanced:             equ -258
error.loading_from_screen_0:        equ -259
error.wrong_digit:                  equ -260
error.deferred_word_uninitialized:  equ -261
error.assertion_failed:             equ -262
error.execution_only:               equ -263
error.definition_not_finished:      equ -264
error.loading_only:                 equ -265
error.off_current_editing_screen:   equ -266

; ----------------------------------------------
; ZX Spectrum

include inc/zx_spectrum_char_codes.z80s
include inc/zx_spectrum_rom_routines.z80s
include inc/zx_spectrum_system_variables.z80s
include inc/zx_spectrum_system_variables_offsets.z80s

sys_screen:                 equ $4000 ; address
sys_screen_size:            equ $1B00
sys_screen_bitmap_size:     equ $1800
sys_screen_attributes:      equ $5800 ; address
sys_screen_attributes_size: equ $0300

bank1_port:     equ $7FFD
border_port:    equ $FE

; ==============================================================
; Macros

; ----------------------------------------------
; Macros for headers

immediate:    equ immediate_mask
compile_only: equ compile_only_mask

nt_of_the_previous_word: defl 0 ; link to previous Forth word

_header: macro _base_label,_name,_flags,_xt

  ; In data space:

  if nul _xt
    _base_label: equ $ ; execution token
  else
    _base_label: equ _xt ; execution token of an alias
  endif

  local _dp_backup
  local _name_address
  local _address_after_name
  _dp_backup: equ $

  ; In memory bank:

if 1 ; far_memory
  org bank_start+(hp mod bank_size)
else
  org hp
endif

  ; Execution token pointer:
if 1 ; far_memory
  _base_label##xtp: equ $-bank_start
else
  _base_label##xtp: equ $
endif

  if nul _xt
    dw _base_label ; execution token pointer
  else
    dw _xt ; execution token pointer of an alias
  endif
  ; XXX TODO -- the `if` can be removed because `_base_label`
  ; has already been set at the start of the macro

  ; Link field address:
if 1 ; far_memory
  _base_label##lfa: equ $-bank_start
else
  _base_label##lfa: equ $
endif

    dw nt_of_the_previous_word ; link field

  ; Name token:
if 1 ; far_memory
  _base_label##nt: equ $-bank_start
else
  _base_label##nt: equ $
endif

  ; Length byte with optional immediate bit:

  if nul _flags
    db _address_after_name-_name_address
  else
    db _address_after_name-_name_address+_flags
  endif

  _name_address: equ $
    db _name
  _address_after_name: equ $

  ; Set new value of the headers pointer:
if 1 ; far_memory
  hp: defl $-bank_start
else
  hp: defl $
endif

  ; Update the headers pointer:
  org headers_pointer
  dw hp ; overwrite the contents of headers_pointer
  dw hp ; overwrite the contents of headers_pointer_init_value

  ; In dictionary:
  org _dp_backup

  nt_of_the_previous_word: defl _base_label##nt

  endm

_code_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags

  endm

_defer_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags
  jp _xt

  endm

_alias_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags,_xt

  endm

_colon_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name,_flags,_runtime_routine

  _header _base_label,_name,_flags

  call _runtime_routine ; code field ; XXX TODO confirm this
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_two_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_c_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_c_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_create ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name,_flags

  _variable_header _base_label,_name,_flags

  endm

; ----------------------------------------------
; Macros for literals

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_literal: macro _n

  ; Note: parenthesis are needed to prevent a strange problem of
  ; Pasmo with signs.

  if (_n)=(-1)
    dw minus_one_
  else
    if (_n)=0
      dw zero_
    else
      if (_n)=1
        dw one_
      else
        if (_n)=2
          dw two_
        else
          if (_n)>=0 && (_n)<=255
            dw c_lit_
            db _n
          else
            dw lit_
            dw _n
          endif
        endif
      endif
    endif
  endif

  endm

; ----------------------------------------------
; Macros for jumps

_jp_next: macro

  jp (ix)

  endm

_jp_pushhl macro

  ; Faster (2 T) than `jp push_hl`, and same size (3 B):

  push hl
  _jp_next

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address ; XXX TODO -- not used yet
  if size_optimization
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Macros for error messages

_throw: macro _error
  _literal (_error)
  dw throw_
  endm

_question_throw: macro _error
  _literal (_error)
  dw question_throw_
  endm

_message: macro _error
  _literal (_error)
  dw dot_throw_
  endm

; ----------------------------------------------
; Macros for debugging

debugging: equ 0

_z80_just_border: macro _color
  if debugging
    push af
    ld a,_color
    out($FE),a
    pop af
  endif
  endm

_z80_border: macro _color
  if debugging
    local _pause0
    push af
    push bc
    ld a,_color
    out($FE),a
    ld bc,0
    _pause0:
    dec bc
    ld a,b
    or c
    jr nz,_pause0
    pop bc
    pop af
  endif
  endm

_z80_border_wait: macro _color
  if debugging
    local _wait
    push af
    ld a,_color
    out($FE),a
    xor a
    ld (sys_last_k),a
    _wait:
    ld a,(sys_last_k)
    and a
    jr z,_wait
    pop af
  endif
  endm

_echo: macro _txt
  if debugging
    dw cr_,paren_dot_quote_
    _string _txt
  endif
  endm

  ; type the string on top of stack
_type: macro
  if debugging
    _echo 'TOS str= <'
    dw two_dup_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; type the counted string on top of stack
_ctype: macro
  if debugging
    _echo 'TOS cstr= <'
    dw dup_,count_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; check point
_chk: macro _message
  if debugging
    _echo _message
    dw base_,fetch_,to_r_,hex_
    dw cr_,dot_s_
    dw from_r_,base_,store_
  endif
  endm

_prompt: macro _message
  if debugging
    _echo _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
_brk: macro _message
  if debugging
    _chk _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the string on top of stack
_brk_type: macro _message
  if debugging
    _chk _message
    _type
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the counted string on top of stack
_brk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
    dw key_,drop_
  endif
  endm

  ; check point
  ; first type the string on top of stack
_chk_type: macro _message
  if debugging
    _chk _message
    _type
  endif
  endm

  ; check point
  ; first type the counted string on top of stack
_chk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
  endif
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; `$01 +origin` (destination address of the jump)
  jp cold_start
warm_entry:
  ; `$04 +origin` (destination address of the jump)
  jp warm_start

; ==============================================================
; Parameter area

latest_nt_in_root_voc.init_value:
  ; `$06 +origin`
  dw latest_nt_in_root_voc

latest_nt_in_forth_voc.init_value:
  ; `$08 +origin`
  dw latest_nt_in_forth_voc

  ; `$0A +origin`
if 1 ; assembler_core_in_kernel
latest_nt_in_assembler_voc.init_value:
  dw latest_nt_in_assembler_voc
else
  dw 0 ; XXX TMP --
endif

voc_link.init_value:
  ; `$0C +origin`
if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
endif

return_stack_pointer:
  ; `$0E +origin`
  dw return_stack_bottom

default_color_attribute:
  ; `$10 +origin`
  db 4          ; low byte: green paper, black ink
  ; `$11 +origin`
  db %00000000  ; high byte: no mask

  ; User variables default values

  ; The first 9 user variables have default values.  They are
  ; used by `cold` to overwrite the actual user variables and
  ; must be in the same order than them.

default_user_variables_start:

sp0_init_value:                               ; +$00
  ; `$12 +origin`
  dw data_stack_bottom
rp0_init_value:                               ; +$02
  ; `$14 +origin`
  dw return_stack_bottom
paren_wait_init_value:                        ; +$04
  ; `$16 +origin`
  dw noop_
width_init_value:                             ; +$06
  dw max_word_length
  ; `$18 +origin`
warnings_init_value:                          ; +$08
  ; `$1A +origin`
  dw true
last_init_value:                              ; +$0A
  ; `$1C +origin`
  dw latest_nt_in_forth_voc
dictionary_pointer_init_value:                ; +$0C
  ; `$1E +origin`
  dw dictionary_pointer_after_cold
user_data_pointer_init_value:                 ; +$0E
  ; `$20 +origin`
  dw user_data_pointer
lastxt_init_value:                            ; +$10
  ; `$22 +origin`
  dw latest_xt_in_forth_voc

default_user_variables_end:

ip_backup: ; temporary copy of Forth IP
  ; `$24 +origin`
  dw 0
  ; XXX OLD -- not used

hp: defl headers_pointer_bottom

headers_pointer:
  ; `$24 +origin`
  ; First free address in the system bank, restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw hp

headers_pointer_init_value:
  ; `$26 +origin`
  ; Init value of the headers pointer, used by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw hp

; ==============================================================
; User variables

user_variables:

  ; Note: the first 9 user variables are initialized with
  ; default values by `cold`.  They must be in the same order
  ; than their default values.

  ; User variables that are initialized by `cold`:

sp0_value:                                    ; +$00
  dw data_stack_bottom
rp0_value:                                    ; +$02
  dw return_stack_bottom
paren_wait:                                   ; +$04 ; XXX OLD
  dw $0000
width_value:                                  ; +$06
  dw max_word_length
warnings_value:                               ; +$08
  dw $0000
last_value:                                   ; +$0A
  dw latest_nt_in_forth_voc
dictionary_pointer_value:                     ; +$0C
  dw dictionary_pointer_after_cold
user_data_pointer_value:                      ; +$0E
  dw user_data_pointer
lastxt_value:                                 ; +$10
  dw latest_xt_in_forth_voc

  ; User variables that are not initialized by `cold`:

in_value:                                     ; +$12
  dw $0000
blk_value:                                    ; +$14
  dw $0000
scr_value:                                    ; +$16
  dw $0000
; XXX not used                                ; +$18
  dw $0000
hld_value:                                    ; +$1A
  dw $0000
current_value:                                ; +$1C
  dw $0000
state_value:                                  ; +$1E
  dw $0000
base_value:                                   ; +$20
  dw $000A
dpl_value:                                    ; +$22
  dw $0000
csp_value:                                    ; +$24
  dw $0000
hash_order_value:                             ; +$26
  dw $0000

context_value:                                ; +$28..+$36

  dw forth_pfa
  dw root_pfa
  ds (max_search_order-2)*cell

  ; Free space for more user variables:

user_data_pointer: equ $-user_variables
  ds bytes_per_user_variables-user_data_pointer

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Circular string buffer

csb0:
  ds csb_size

; ----------------------------------------------
; Disk buffer

buffer_block_id_mask: equ $7FFF

; A block id is the number of the associated block, with the
; sign bit indicating, when it's set, that the buffer has been
; modified.

disk_buffer:

  dw buffer_block_id_mask     ; Block id used when the  buffer
                              ; is not associated with a block.
  ds bytes_per_buffer         ; Actual content of the block.

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer

; ==============================================================
; Misc routines

; XXX TODO -- investigate if the code is optimized for Z80;
; the code of DZX-Forth is generic, also for 8080.

; ----------------------------------------------
; Compare DE and HL

; Credit:
; Code from DZX-Forth.

compare_de_hl_unsigned:

  ; Input:  DE, HL
  ; Output:
  ;  flag CY set if HL < DE
  ;  flag Z set if HL = DE

  ; Credit:
  ; Code from DZX-Forth

          ; T  B
          ; -- --
  ld a,h  ; 04 01
  cp d    ; 04 01
  ret nz  ; 11 01  05 01
  ld a,l  ; 04 01
  cp e    ; 04 01
  ret     ; 10 01
          ; -- --  -- --
          ; 37 06  31 06

compare_de_hl_signed:

  ; Input:  DE, HL
  ; Output: flag CY if HL < DE

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ----------------------------------------------
; Move block

; Credit:
; Code from DZX-Forth.

move_block:

  ; Input:
  ; HL = source
  ; DE = destination
  ; BC = count

  ; If BC is greater than zero, copy the contents of BC consecutive address
  ; units at HL to the BC consecutive address units at de. After the move
  ; completes, the BC consecutive address units at DE contain exactly what the
  ; BC consecutive address units at HL contained before the move.

  call compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

; Credit:
; Code from DZX-Forth.

move_block_upwards:

  ; Input:
  ; HL = source
  ; DE = destination
  ; BC = count

  ; If BC is greater than zero, copy BC consecutive characters from the data
  ; space starting at HL to that starting at DE, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

; Credit:
; Code from DZX-Forth.

  ; Input:
  ; HL = source
  ; DE = destination
  ; BC = count

  ; If BC is greater than zero, copy BC consecutive characters from the data
  ; space starting at HL to that starting at DE, proceeding
  ; character-by-character from higher addresses to lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ----------------------------------------------
; Multiplication primitives

; XXX TODO -- Improve -- the DZX-Forth routines are for 8080,
; not Z80

; Credit:
; Code from DZX-Forth.

; AHL <- A * DE

a_multiplied_by_de_to_ahl:
  ld hl,0
  ld c,8
a_multiplied_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_multiplied_by_de_to_ahl.2
  add hl,de
  adc a,0
a_multiplied_by_de_to_ahl.2:
  dec c
  jp nz,a_multiplied_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32-bit result

; HLDE <- HL * DE

if 1 ; original_u_m_star

hl_multiplied_by_de_to_hlde_unsigned:
  push bc ; save Forth IP
  ld b,h
  ld a,l
  call a_multiplied_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_multiplied_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc ; restore Forth IP
  ret

endif

if 1 ; original_m_star
else

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_multiplied_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde ; XXX TODO

endif

if 0

  ; XXX TODO -- code from DZX-Forth

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  ; two's complement
  ;       ; T  B
  ;       ; -- --
  dec hl  ; 06 01
negate_hl.1:
  ; one's complement
  ld a,l  ; 04 01
  cpl     ; 04 01
  ld l,a  ; 04 01
  ld a,h  ; 04 01
  cpl     ; 04 01
  ld h,a  ; 04 01
          ; -- --
          ; 30 07
  ret

endif

negate_hl:

  ; Credit:
  ;
  ; http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Signed_Math

  ;input: hl
  ;ouput: hl negated
  ;destroys a

  ;       ; T  B
  ;       ; -- --
  xor a   ; 04 01
  sub l   ; 04 01
  ld l,a  ; 04 01
  sbc a,a ; 04 01
  sub h   ; 04 01
  ld h,a  ; 04 01
          ; -- --
          ; 24 06
  ret

if 0

  ; XXX TODO -- adapt
  ;
  ; Credit:
  ; http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#1.3

  ; Input: DE = Multiplier, BC = Multiplicand, HL = 0
  ; Output: DE:HL = Product

de_multiplied_by_bc_to_dehl_unsigned:

  push bc

  sla e   ; optimised 1st iteration
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.continue
  ld  h,b
  ld  l,c

de_multiplied_by_bc_to_dehl_unsigned.continue:
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  rl  e
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  add hl,bc
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  inc de

de_multiplied_by_bc_to_dehl_unsigned.end:
  pop bc
  ret

endif

; ==============================================================
; Inner interpreter

push_hlde:
  push de
push_hl:
  push hl
next:
  ; Execute the word whose xt is in the address pointed by the BC register.
  ; Forth: W  <-- (IP)
  ; Z80:   HL <-- (BC)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; BC = address of the next xt
  ; HL = xt

execute_hl:
  ; Execute the word whose xt is in the HL register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (HL)
  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
; Start compiling in the `root` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _alias_header root_forth_,'FORTH',,forth_

; ----------------------------------------------
  _alias_header root_forth_wordlist_,'FORTH-WORDLIST',,forth_wordlist_

; ----------------------------------------------
  _alias_header root_set_order_,'SET-ORDER',,set_order_

  ; This symbol must be set with the value of the
  ; latest word defined in the `root` vocabulary:
latest_nt_in_root_voc: equ root_set_order_nt

if 1 ; assembler_core_in_kernel

; ----------------------------------------------
; Start compiling in the `assembler` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------

if 1 ; abase

  _variable_header abase_,'ABASE'

  ; XXX TODO use the return stack instead?

; doc{
;
; abase  ( -- a )
;
; A variable used to save the current value of `base` in
; assembler definitions.
;
; }doc

  dw 0

endif

; ----------------------------------------------
  _colon_header end_asm_,'END-ASM'

; doc{
;
; end-asm  ( -- )
;
; Exit the assembler mode.
;
; }doc

  dw question_csp_
  dw previous_ ; restore the search order ; XXX TODO better
if 1 ; abase
  dw abase_,fetch_,base_,store_ ; restore `base`
else
  dw base_,store_ ; restore `base`
endif

  dw exit_

; ----------------------------------------------
  _colon_header end_code_,'END-CODE'

  dw end_asm_,reveal_
  dw exit_

; ----------------------------------------------
  _constant_header next_,'NEXT'

  dw next

; ----------------------------------------------
  _constant_header pusha_,'PUSHA'

  dw push_a

; ----------------------------------------------
  _constant_header pushhl_,'PUSHHL'

  dw push_hl

; ----------------------------------------------
  _constant_header pushhlde_,'PUSHHLDE'

  dw push_hlde

; ----------------------------------------------
  _constant_header fetchhl_,'FETCHHL'

  dw fetch.hl

; ----------------------------------------------
  _colon_header jppushl_,'JPPUSHHL'

; doc{
;
; jppushl  ( -- )
;
; Compile a Z80 jump to `pushhl`.
;
; Actually two instructions are compiled: `push hl` and `jp
; (ix)`. The execution of these instructions is faster than an
; absolute jump to a push, and they need 3 bytes, same as a
; jump.
;
; }doc

  _literal $E5 ; opcode `push hl`
  dw c_comma_
  dw branch_,jpnext_pfa

; ----------------------------------------------
  _colon_header jpnext_,'JPNEXT'

; doc{
;
; jpnext  ( -- )
;
; Compile a Z80 jump to `next`.
;
; }doc

  _literal $E9DD ; opcode `jp (ix)`
  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header jp_comma_,'JP,'

; doc{
;
; jp,  ( a -- )
;
; Compile the Z80 opcode to jump to _a_.
;
; ----
; : code-field,  ( a -- )
;   $C3 c,  \ Z80 opcode for "jp"
;   ,  ;
; ----
;
; }doc

; XXX TODO -- This word is needed in the kernel, but it is
; defined in the `z80-asm-comma` variant of the assembler, which
; is intended to be the main assembler of the system, instead of
; the current variant `z80-asm`.

  _literal $C3 ; Z80 opcode for "call"
  dw c_comma_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header call_comma_,'CALL,'

; doc{
;
; call,  ( a -- )
;
; Compile the Z80 opcode to call _a_.
;
; ----
; : call,  ( a -- )
;   $CD c,  \ Z80 opcode for "call"
;   ,  ;
; ----
;
; }doc

; XXX TODO -- This word is needed in the kernel, but it is
; defined in the `z80-asm-comma` variant of the assembler, which
; is intended to be the main assembler of the system, instead of
; the current variant `z80-asm`.

  _literal $CD ; Z80 opcode for "call"
  dw c_comma_,comma_
  dw exit_

  ; This symbol must be set with the value of the
  ; latest word defined in the `assembler` vocabulary:
latest_nt_in_assembler_voc: equ call_comma_nt

endif

; ----------------------------------------------
; Start compiling in the `forth` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _colon_header dos_,'DOS'

; doc{
;
; dos  ( -- ca len )
;
; Return the name of the DOS.
;
; }doc

  dw s_lit_
if defined gplusdos
  _string 'G+DOS'
endif
if defined trdos
  _string 'TR-DOS'
endif
if defined plus3dos
  _string '+3DOS'
endif
  dw exit_

; ----------------------------------------------
  _c_constant_header max_drives_,'MAX-DRIVES'

  db max_drives

; doc{
;
; max-drives ( -- b )
;
; A constant that returns the maximum number of drives
; available in the DOS.
;
; }doc

; ----------------------------------------------
  _variable_header lib_order_,'LIB-ORDER'

; XXX NEW -- not used yet by `need`

if defined gplusdos
  db 1,2,0
endif
if defined plus3dos
  db 1,'b',0
endif
if defined trdos
  db 1,1,0,0,0
endif

; doc{
;
; lib-order  ( -- a )
;
; Address of the library order, which has the following
; structure:
;
; |===
; | Offset | Bytes        | Description
;
; | 0      | 1            | Number of library disks to be searched.
; | 1      | `max-drives` | Drives to search, in searching order.
; |===
;
; The value of `max-drives` depends on the DOS.  The
; format of the drive identifiers also depends on the DOS, as
; follows:
;
; - G+DOS: drives 1..2
; - +3DOS: drives 'A'..'B'
; - TR-DOS: drives 0..3
;
; }doc

; XXX TODO -- make TR-DOS drives 'A'..'C'; 0..3 is the internal
; format, but letters are used in filenames.

; ----------------------------------------------
  _colon_header set_lib_order_,'SET-LIB-ORDER'

; XXX NEW -- not used yet by `need`

; doc{
;
; set-lib-order  ( b[n] ... b[1] n -- )
;
; Set the library search order to the drives identified by
; _b[n]_ ... _b[1]_.  Subsequently, drive _b[1]_ will be
; searched first, and drive _b[n]_ searched last. If _n_  is
; zero, empty  the library search order.

; ----
; : set-lib-order  ( b[n] ... b[1] n -- )
;   dup lib-order c!
;   0 ?do  [ lib-order char+ ] literal i chars + c!  loop  ;
; ----
;
; }doc

  dw dup_,lib_order_,c_store_
  _literal 0
  dw paren_question_do_,set_lib_order.exit
  _literal lib_order_pfa+1
  dw i_,plus_,c_store_
  dw paren_loop_
set_lib_order.exit
  dw exit_

; ----------------------------------------------
  _colon_header get_lib_order_,'GET-LIB-ORDER'

; XXX NEW -- not used yet by `need`

; doc{
;
; get-lib-order  ( -- b[n] ... b[1] n )
;
; Return the number of drives _n_ in the library search order
; and the drive identifiers _b[n] ... b[1]_ identifying these
; drives. _b[1]_ identifies the drive that is searched first,
; and _b[n]_ the drive that is searched last. The library search
; order is unaffected.

; ----
; : get-lib-order  ( -- b[n] ... b[1] n )
;   lib-order c@ 0 ?do
;     lib-order c@ i - lib-order + c@
;   loop  lib-order c@  ;
; ----
;
; }doc

  dw lib_order_,c_fetch_
  _literal 0
  dw paren_question_do_,get_lib_order.exit
  dw lib_order_,c_fetch_,i_,minus_
  dw lib_order_,plus_,c_fetch_
  dw paren_loop_
get_lib_order.exit
  dw lib_order_,c_fetch_
  dw exit_

; ----------------------------------------------

; Note: Conditional `include` is not allowed in the Pasmo
; assembler. That's why all DOS files are included, and they
; check its own condition.

  include kernel.gplusdos.z80s
  include kernel.trdos.z80s
  include kernel.plus3dos.z80s

; ----------------------------------------------
if 1 ; far_memory

  _variable_header far_banks_,'FAR-BANKS'

  db 1,3,4,7

; doc{
;
; far-banks  ( -- ca )
;
; Address of an array of four bytes. It holds the four memory
; banks used as a virtual 64-KiB continuous space, called "far
; memory": The first bank in the array is used for addresses
; $0000..$3FFF, the second one for $4000..$7999, the third one
; for $8000..$BFFF and the fourth one for $C000..$FFFF.
;
; See: `far`, `far@`, `farc@`, `far!`, `farc!`, `farcount`,
; `farplace`, `fartype`, `faruppers`.
;
; }doc

; XXX TODO -- These banks are for ZX Spectrum 128K and +2.
; They are different for +2A, +3 and +3e.

  ; Credit:

  ; The "far" naming convention was borrowed from a post by Dr
  ; Jefyll in 6502.org (2010-02-16):
  ;
  ; http://forum.6502.org/viewtopic.php?f=9&t=1529&p=10079
  ;
  ; Also Garry Lancaster used the name "far memory" in his Z88
  ; CamelForth (2001):
  ;
  ; http://www.worldofspectrum.org/z88forever/camelforth/camel-pools.html

; ----------------------------------------------
  _code_header question_next_bank_,'?NEXT-BANK'

; doc{
;
; ?next-bank  ( a -- a|a' )
;
; If the actual far-memory address ($C000..$FFFF) _a_ has
; increased to the next bank ($0000..$3FFF), convert it to the
; correspondent actual address ($C000..$FFFF) _a'_ in the next
; bank and page in the next bank, else simply return _a_.
;
; See: `questionnextbank`.
;
; }doc

  pop hl
  call question_next_bank
  _jp_pushhl

question_next_bank:

  ; If the actual far-memory address ($C000..$FFFF) in the HL
  ; register has increased to the next bank ($0000..$3FFF),
  ; convert it to the correspondent actual address
  ; ($C000..$FFFF) in the next bank and page in the next bank,
  ; else do nothing.
  ;
  ; Input:
  ;   HL = address in a paged bank ($C000..$FFFF) or higher
  ;   ($0000..$3FFF).
  ; Output when HL is above the paged bank:
  ;   HL = correspondent address in the next bank, which is paged in
  ;   A corrupted
  ;   D = 0
  ;   E = bank
  ; Output when HL is an address in a paged bank:
  ;   HL preserved
  ;   A corrupted
  ;
  ; Note: the address of this routine is returned by
  ; `questionnextbank`, a constant defined in the assembler
  ; wordlist in the <memory.far.fsb> module of the library, so
  ; code words can call it.

  ld a,h
  cp $C0 ; is HL below $C000?
  ret nc

  ; Update HL to the next bank of the far memory:
  ld a,(bank_index_pfa)
  inc a
  ld de,bank_start
  add hl,de

new_bank:

  ; Input:
  ;   A = updated bank index (possibly out of range 0..3)
  ; Output:
  ;   A corrupted
  ;   D = 0
  ;   E = bank

  push hl
  and %11 ; force range 0..3
  ld (bank_index_pfa),a
  ld e,a
  ld hl,far_banks_pfa
  ld d,0
  add hl,de
  ld e,(hl) ; E = bank
  pop hl
  jp bank.e ; page in the bank E, then return

; ----------------------------------------------
  _code_header question_previous_bank_,'?PREVIOUS-BANK'

; doc{
;
; ?previous-bank  ( a -- a|a' )
;
; If the actual far-memory address ($C000..$FFFF) _a_ has
; decreased to the previous bank ($8000..$BFFF), convert it to
; the correspondent actual address ($C000..$FFFF) _a'_ in the
; previous bank and page in the next bank, else simply return
; _a_.
;
; See: `questionpreviousbank`.
;
; }doc

  pop hl
  call question_previous_bank
  _jp_pushhl

question_previous_bank:

  ; If the actual far-memory address ($C000..$FFFF) in the HL
  ; register has decreased to the previous bank ($8000..$BFFF),
  ; convert it to the correspondent actual address
  ; ($C000..$FFFF) in the previous bank and page in the next
  ; bank, else do nothing.
  ; 
  ; Input:
  ;   HL = address in a paged bank ($C000..$FFFF) or lower
  ;   ($8000..$BFFF).
  ; Output when HL is below the paged bank:
  ;   HL = correspondent address in the previous bank, which is paged in
  ;   A corrupted
  ;   D = 0
  ;   E = bank
  ; Output when HL is an address in a paged bank:
  ;   HL preserved
  ;   A corrupted
  ;
  ; Note: the address of this routine is returned by
  ; `questionpreviousbank`, a constant defined in the assembler
  ; wordlist in the <memory.far.fsb> module of the library, so
  ; code words can call it.

  ld a,h
  cp $C0 ; is HL below $C000?
  ret nc

  ; Update HL to the previous bank of the far memory:
  ld a,(bank_index_pfa)
  dec a
  ld de,bank_size
  add hl,de
  jr new_bank

endif

; ----------------------------------------------
if 0 ; XXX OLD

  _code_header bank_boundary_question,'BANK-BOUNDARY?'

  ; XXX TMP --

; doc{
;
; bank-boundary?  ( a -- f )
;
; }doc

  pop hl
  ld a,l
  and a  ; =$00?
  jr z,bank_boundary_question.xx00
  inc a  ; =$FF?
  jp nz,false_

bank_boundary_question.xxFF:
  ld a,h
  cp $7F      ; $7FFF?
  jp z,true_
  cp $BF      ; $BFFF?
  jp z,true_
  cp $FF      ; $FFFF?
  jp z,true_
  jp false_

bank_boundary_question.xx00:
  ld a,h
  cp $00      ; $0000?
  jp z,true_
  cp $40      ; $4000?
  jp z,true_
  cp $80      ; $8000?
  jp z,true_
  jp false_

endif

; ----------------------------------------------
if 1 ; far_memory

  _variable_header bank_index_,'BANK-INDEX'

; doc{
;
; bank-index  ( -- ca )
;
; A byte variable that holds the bank index (0..3) calculated by
; the latest execution of `far`.
;
; }doc

  db 0

endif

; ----------------------------------------------
if 1 ; far_memory

  _code_header far_,'FAR'

; doc{
;
; far  ( a1 -- a2 )
;
; Convert a far-memory address _a1_ ($0000..$FFFF) to its
; actual equivalent _a2_ ($C000..$FFFF) and page in the
; correspondent memory bank.
;
; This word is written in Z80, but the equivalent Forth code is
; the following:
;
; ----
; : far  ( a1 -- a2 )
;   u>ud $4000 um/mod  far-banks + c@ bank  $C000 +  ;
;   \ Notes: $4000 = size of one memory bank
;   \        $C000 = address where memory banks are paged in
; ----
;
; See: `farhl`.
;
; }doc

  pop hl
  call far.hl
  _jp_pushhl

far.hl:

  ; Convert a far-memory address ($0000..$FFFF) to its
  ; actual equivalent ($C000..$FFFF) and page in the
  ; correspondent memory bank.
  ;
  ; Input:
  ;   HL = far-memory address ($0000..$FFFF)
  ;
  ; Output:
  ;   HL = actual memory address ($C000..$FFFF)
  ;   A DE corrupted
  ;
  ; Note: the address of this routine is returned by `farhl`, a
  ; constant defined in the assembler wordlist in the
  ; <memory.far.fsb> module of the library, so code words can
  ; call it.

  ld e,h
  srl e
  srl e
  srl e
  srl e
  srl e
  srl e ; E = 0..3 (bank index)
  ld a,e
  ld (bank_index_pfa),a ; save the bank index
  push hl
  ld hl,far_banks_pfa
  ld d,0
  add hl,de
  ld e,(hl) ; E = bank
  call bank.e

  pop hl ; HL = far-memory address ($0000..$FFFF)
  ld a,h
far.hl.mod:
  sub $40 ; substract $4000 (16 KiB)...
  jr nc,far.hl.mod ; ...as many times as needed
  ld h,a ; HL = actual memory address ($C000..$FFFF)
  ret

endif

; ----------------------------------------------
  _colon_header asm_,'ASM'

; doc{
;
; asm  ( -- )
;
; Enter the assembler mode.
;
; }doc

  ; Credit:
  ; Idea taken from Coos Haak's Z80 Forth assembler.

  dw store_csp_
if 1 ; abase
  dw base_,fetch_,abase_,store_ ; save the current base
else
  dw base_,fetch_ ; save the current base
endif
  dw hex_
  dw also_,assembler_ ; XXX TODO better
  dw exit_

; ----------------------------------------------
  _colon_header also_,'ALSO'

; doc{
;
; also  ( -- )
;
; Duplicate the vocabulary at the top of the search order.
;
; ----
; : also  ( -- )
;   get-order over swap 1+ set-order  ;
; ----
;
; }doc

  ; XXX TODO -- check the limit, see Gforth

  dw get_order_,over_,swap_,one_plus_,set_order_
  dw exit_

  ; XXX TODO -- in Gforth:
  ; : also  ( -- )  context @ >order  ;

; ----------------------------------------------
  _colon_header only_,'ONLY'

; doc{
;
; only  ( -- )
;
; Set the search order to the minimum search order.
;
; ----
; : only  ( -- )
;   -1 set-order  ;
; ----
;
; }doc

  _literal -1
  dw set_order_
  dw exit_

; ----------------------------------------------
  _colon_header paren_set_order_,'(SET-ORDER)'

; doc{
;
; (set-order)  ( widn..wid1 n -- )
;
; Set the search order to the word lists identified by
; _widn..wid1_. Subsequently, word list _wid1_ will be
; searched first, and word list _widn_ searched last.
;
; }doc

; ----
; : (set-order)  ( widn..wid1 n -- )
;   0 ?do  context i cells + !  loop  ;
; ----

  _literal 0
  dw paren_question_do_,paren_set_order.loop_exit
  dw context_,i_,cells_,plus_,store_
  dw paren_loop_
paren_set_order.loop_exit
  dw exit_

; ----------------------------------------------
  _colon_header get_order_,'GET-ORDER'

; : get-order  ( -- 0 | widn..wid1 n )
;   #order @ 0 ?do
;     #order @ i - 1- cells context + @
;   loop  #order @  ;

  dw hash_order_,fetch_
  _literal 0
  dw paren_question_do_,get_order.exit
  dw hash_order_,fetch_,i_,minus_,one_minus_,cells_
  dw context_,plus_,fetch_
  dw paren_loop_
get_order.exit
  dw hash_order_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header set_order_,'SET-ORDER'

; doc{
;
; set-order  ( -1 | 0 | widn..wid1 n -- )
;
; Set the search order to the word lists identified by
; _widn..wid1_. Subsequently, word list _wid1_ will be
; searched first, and word list _widn_ searched last. If _n_
; is zero, empty the search order. If _n_ is minus one, set
; the search order to the implementation-defined minimum
; search order.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : set-order  ( -1 | 0 | widn..wid1 n -- )
;   dup -1 = if  drop root-wordlist dup 2  then
;   dup #order !
;   0 ?do  i cells context + !  loop  ;
; ----
;
; }doc

  ; XXX TODO -- Factor `root-wordlist dup 2` to `only-order`?
  ; Probably it will be changed to `forth-wordlist 1` anyway.

  dw dup_
  _literal -1
  dw equals_
  dw zero_branch_,set_order.do
  dw drop_,root_wordlist_,dup_
  _literal 2
set_order.do
  dw dup_,hash_order_,store_
  _literal 0
  dw paren_question_do_,set_order.exit
  dw i_,cells_,context_,plus_,store_
  dw paren_loop_
set_order.exit
  dw exit_

; ----------------------------------------------
  _colon_header to_order_,'>ORDER'

  ; XXX TODO -- move to the library?

; doc{
;
; >order  ( wid -- )
;
; Push _wid_ on the search order.
;
; ----
; : >order  ( wid -- )  also context !  ;
; ----
;
; Origin: Gforth.
;
; }doc

  ; XXX TODO -- alternative:
  ;
  ; : >order  ( wid -- )  get-order 1+ swap set-order  ;

  dw also_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header previous_,'PREVIOUS'

  ; XXX TODO -- move to the library? -- but it's used by `asm`

; doc{
;
; previous  ( -- )
;
; Remove the most recently referenced vocabulary from the search
; order.
;
; Origin: Forth-94 (SEARCH EXT), Forth-2012 (SEARCH EXT).
;
; ----
; : previous  ( -- )
;   get-order nip 1- set-order  ;
; ----
;
; }doc

  ; XXX TODO -- `get-order` is in the library, and it needs
  ; `recurse`; write a simpler version of `get-order`, after
  ; Gforth, and put it in the kernel
  ;
  ; XXX TODO -- add check

  dw get_order_,nip_,one_minus_,set_order_
  dw exit_

; XXX TODO -- from Gforth:
;
; : previous  ( -- )
;   vp @ 1- dup 0= -50 ?throw vp !  ;

; : get-order
;  vp @ 0 ?do  vp cell+ i cells + @  loop  vp @  ;

; ----------------------------------------------
  _colon_header seal_,'SEAL'

  ; XXX TODO -- move to the library

; doc{
;
; seal  ( -- )
;
; Change the search order such that only the vocabulary at the
; top of the search order will be searched.
;
; ----
; : seal  ( -- )
;   1 #order ! ;
; ----
;
; Remove all word list from the search order stack other than
; the word list that is currently on top of the search order
; stack.
;
; Origin: Gforth.
;
; }doc

  _literal 1
  dw hash_order_,store_
  dw exit_

  ; XXX TODO -- alternative definition, from Gforth
  ;
  ; : seal  ( -- )  context @ 1 set-order ;

; ----------------------------------------------
  _variable_header root_wordlist_,'ROOT-WORDLIST'

  dw latest_nt_in_root_voc
root_vocabulary_link:
  dw $0000
  dw root_nt

; ----------------------------------------------
  _does_header root_,'ROOT',,do_vocabulary

  dw root_wordlist_pfa

; ----------------------------------------------
  _variable_header forth_wordlist_,'FORTH-WORDLIST'

; doc{
;
; forth-wordlist  ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; all standard words provided by the implementation. This word
; list is initially the compilation word list and is part of the
; initial search order.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; }doc

  dw latest_nt_in_forth_voc
forth_vocabulary_link:
  dw root_vocabulary_link
  dw forth_nt

; ----------------------------------------------
  _does_header forth_,'FORTH',,do_vocabulary

  dw forth_wordlist_pfa

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _variable_header assembler_wordlist_,'ASSEMBLER-WORDLIST'

  dw latest_nt_in_assembler_voc
assembler_vocabulary_link:
  dw forth_vocabulary_link
  dw assembler_nt

endif

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _does_header assembler_,'ASSEMBLER',,do_vocabulary

  dw assembler_wordlist_pfa

endif

; ----------------------------------------------
  _colon_header s_lit_,'SLIT'

; doc{
;
; slit  ( -- ca len )
;
; Return a string that is compiled after the calling word, and
; adjust the instruction pointer to step over the inline string.
;
; ----
; : slit  ( -- ca len )
;   r@ count dup char+ r> + >r  ;
; ----
;
; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,char_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw exit_

; ----------------------------------------------
  _colon_header parse_string_,'PARSE-STRING'

; doc{
;
; parse-string ( Compilation: c "ccc<char>" -- ) ( Run-time:  -- ca len )
;
; }doc

  ; XXX WARNING -- state-smart

  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,parse_string.interpreting
  ; compiling
  dw s_literal_
  dw exit_
parse_string.interpreting:
  dw save_string_
  dw exit_

; ----------------------------------------------
  _code_header c_lit_,'CLIT',compile_only

  ld a,(bc)
  inc bc
push_a:
  ld l,a
  ld h,0
  _jp_pushhl

; ----------------------------------------------
  _code_header two_lit_,'2LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a ; HL = high part
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a ; DE = low part
  inc bc
  jp push_hlde

; ----------------------------------------------
  _code_header lit_,'LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  _jp_pushhl

; ----------------------------------------------
  _constant_header default_bank_hash_,'DEFAULT-BANK#'

  ; XXX TMP --

; doc{
;
; default-bank#  ( -- a )
;
; An 8-bit variable holding the value of the default bank.  Note
; this variable must be set with `c!` and fetched with `c@`.
;
; See: `set-default-bank`, `get-default-bank`.
;
; }doc

  dw address_of_default_bank

; ----------------------------------------------
if 1 ; far_memory
else

  _code_header system_bank_,'SYSTEM-BANK'

; doc{
;
; system-bank  ( -- )
;
; Page in the system bank at $C000..$FFFF.
; This memory bank is used to store the dictionary headers.
;
; }doc

  push ix ; make next `ret` jump to `next`

bank.system:

  ; Page in the system memory bank.

  ; Output:
  ;   A E corrupted

  ld e,system_bank
  jr bank.e

endif

bank.default:

  ; Page in the default memory bank.

  ; Output:
  ;   A E corrupted

address_of_default_bank equ $+1
  ld e,default_bank

bank.e:

  ; Page in the memory bank hold in the E register.

  ; Input:
  ;   E = bank
  ; Output:
  ;   A corrupted

  ld a,(sys_bankm) ; get the saved status of BANKM
  and %11111000 ; reset bits 0-2
  or e ; modify bits 0-2
  di
  ld (sys_bankm),a ; update BANKM
if defined plus3dos
  push bc
  ld bc,bank1_port
  out (c),a
  pop bc
else
  out (bank1_port),a ; page in the bank
endif
  ei
  ret

; ----------------------------------------------
  _constant_header bank_start_,'BANK-START'

; doc{
;
; bank-start  ( -- a )
;
; A constant: Memory address where banks are paged in: $C000.
;
; }doc

  dw bank_start

; ----------------------------------------------
  _code_header bank_,'BANK'

; doc{
;
; bank  ( n -- )
;
; Page in memory bank _n_ (0..7) at $C000..$FFFF.
;
; }doc

  pop de ; E = bank
  call bank.e
  _jp_next

; ----------------------------------------------
  _code_header unused_csb_,'UNUSED-CSB'

; doc{
;
; csb-unused  ( -- n )
;
; Return the number of free chars in the circular string-buffer.
;
; ----
; : csb-unused  ( -- n )
;   >csb @  ;
; ----
;
; See: `csb0`.
;
; }doc

  ld hl,(to_csb_pfa)
  _jp_pushhl

; ----------------------------------------------
  _constant_header csb_size_,'CSB-SIZE'

; doc{
;
; csb-size  ( -- n )
;
; Return the maximum size of the circular string-buffer, in
; chars.
;
; In order to reconfigure the circular string buffer, the
; constant can be modified with `!>`.
;
; See: `csb0`, `>csb`, `empty-csb`.
;
; }doc

  dw csb_size

; ----------------------------------------------
  _variable_header to_csb_,'>CSB'

; doc{
;
; to_csb  ( -- a )
;
; A variable that holds the circular string buffer pointer, an
; offset to the first free address in the buffer; the offset
; coincides with the number of free chars.
;
; }doc

  dw csb_size

; ----------------------------------------------
  _constant_header csb0_,'CSB0'

; doc{
;
; csb0  ( -- a )
;
; A constant that returns the base address of the circular
; string buffer.
;
; In order to move the circular string buffer, the constant
; can be modified with `!>`.
;
; See: `csb-size`, `>csb`, `empty-csb`, `unused-csb`, `?csb`,
; `allocate-string`, `save-string`.
;
; }doc

  dw csb0

; ----------------------------------------------
  _colon_header question_csb_,'?CSB'

; doc{
;
; ?csb  ( len -- )
;
; Make sure there's room in the circular string buffer for the
; given characters.
;
; ----
; : ?csb  ( len -- )
;   dup unused-csb >  \ not enough free space?
;   if  empty-csb >csb !  then  negate >csb +!  ;
; ----
;
; See: `csb0`.
;
; }doc

  ; XXX TODO -- rename to `csb-room`, `(allocate-string)` or something

  dw dup_,unused_csb_,greater_than_
  dw zero_branch_,question_csb_.enough
  ; not enough space
  dw empty_csb_

question_csb_.enough:
  dw negate_,to_csb_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header allocate_string_,'ALLOCATE-STRING'

; doc{
;
; allocate-string  ( len -- ca )

; Allocate _len_ chars in the circular string buffer and return
; the address _ca_ of the allocated space.
;
; ----
; : allocate-string  ( len -- ca )
;   ?csb csb0 unused-csb +  ;
; ----
;
; See: `save-string`, `csb0`.
;
; }doc

  ; XXX TODO -- return a ior; _len_ could be too big for the
  ; buffer

  dw question_csb_
  dw csb0_,unused_csb_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header save_string_,'SAVE-STRING'

; doc{
;
; save-string  ( ca1 len1 -- ca2 len1 )

; Save the string _ca1 len1_ in the circular string buffer and
; return it at its new address.
;
; ----
; : save-string  ( ca1 len1 -- ca2 len1 )
;   dup allocate-string swap 2dup 2>r move 2r>  ;
; ----
;
; See: `allocate-string`, `csb0`.
;
; }doc

  dw dup_,allocate_string_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw exit_

; ----------------------------------------------
  _colon_header empty_csb_,'EMPTY-CSB'

; doc{
;
; empty-csb  ( -- )
;
; Empty the circular string buffer,
; by initializing its pointer to the size of the buffer.
; The contents of the buffer are not modifed.
;
; See: `csb0`.
;
; }doc

  dw csb_size_,to_csb_,store_
  dw exit_

; ----------------------------------------------
  _code_header execute_,'EXECUTE'

; doc{
;
; execute  ( xt  -- )
;
; }doc

  pop hl
  jp (hl)

; ----------------------------------------------
  _code_header perform_,'PERFORM'

; doc{
;
; perform  ( a  -- )
;
; Execute the word whose xt is stored in _a_.  Do nothing if
; the content of _a_ is zero.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp nz,execute_hl

  ; Execution continues in `noop`:

; ----------------------------------------------
  _code_header noop_,'NOOP',

; doc{
;
; noop  ( -- )
;
; Do nothing.
;
; }doc

  _jp_next

; ----------------------------------------------
  _colon_header forward_mark_,'>MARK'

; doc{
;
; >mark  ( -- orig )
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; Origin: Forth-83.
;
; }doc

  dw here_
  _literal 0
  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLVE'

; doc{
;
; >resolve  ( orig -- )
;
; Resolve a forward branch by placing the address of the current
; data-space pointer into the space compiled by `>mark`.
;
; Origin: Forth-83.
;
; }doc

  dw here_,swap_,store_
  dw exit_

; ----------------------------------------------
  _alias_header backward_mark_,'<MARK',,here_

; doc{
;
; <mark  ( -- a )
;
; Leave the address of the current data-space pointer, as the
; the destination of a backward branch.  _a_ is typically
; only used by `<resolve` to compile a branch address.
;
; Origin: Forth-83 (System Extension Word Set).
;
; }doc

; ----------------------------------------------
  _alias_header backward_resolve_,'<RESOLVE',,comma_

; doc{
;
; <resolve  ( dest -- )
;
; Resolve a backward branch.  Compile a branch address using
; _dest_, the address left by `<mark`,  as the destination
; address.  Used at the source of a backward branch after either
; `branch` or `?branch` or `0branch`.
;
; Origin: Forth-83.
;
; }doc

; ----------------------------------------------
  _code_header zero_branch_,'0BRANCH'

; doc{
;
; 0branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_
; is false (zero), the following in-line address is copied to IP
; to branch forward or backward.
;
; Origin: fig-Forth.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_ ; branch if zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANCH'

; doc{
;
; ?branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ is not
; false (not zero), the following in-line address is copied to
; IP to branch forward or backward.
;
; Note: This is not Forth-83's `?branch`, which is equivalent to
; '0branch` in fig-Forth and Solo Forth.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_ ; branch if not zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header unloop_,'UNLOOP'

; doc{
;
; unloop  ( -- ) ( R: loop-sys -- )
;
; Discard the loop-control parameters for the current nesting
; level. An `unloop` is required for each nesting level before
; the definition may be exited with `exit`. An ambiguous
; condition exists if the loop-control parameters are
; unavailable.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*3
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header paren_question_do_,'(?DO)'

  ; Credit:
  ; Code based on Spectrum Forth-83.

  pop hl
  pop de
  and a
  sbc hl,de
  jp z,branch_
  add hl,de  ; reverse the substraction
  jp paren_do.de_hl

; ----------------------------------------------
  _colon_header question_do_,'?DO',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; ?do  ( n1 n2 -- )
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; ----
; : ?do  ( n1 n2 -- )
;   postpone (?do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_question_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header do_,'DO',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; do  ( n1 n2 -- )
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; ----
; : do  ( n1 n2 -- )
;   postpone (do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate+compile_only

  ; XXX TODO -- move to the library
  ; (it's only used by `.s`, which will be removed from the kernel
  ; after the development)

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_plus_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  pop hl                        ; init
  pop de                        ; limit
paren_do.de_hl:
  push hl
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push limit on return stack
  inc bc
  inc bc                        ; skip branch address
  dec hl
  ld (hl),B
  dec hl
  ld (hl),c                     ; push IP on return stack
  ex (sp),hl                    ; HL=init, (SP)=rp@
  and a
  sbc hl,de                     ; HL=init-limit
  ld a,h
  xor $80                      ; flip most significant bit
  ld d,a
  ld e,l
  pop hl                        ; HL=rp@
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push (init-limit) xor $8000 on return stack
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header i_,'I'

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
i.hl: ; entry point for `j` and `k`: cfa of `i` plus 3
  ld e,(hl)
  inc hl
  ld d,(hl) ; DE= current index, wich is: (index-limit) xor $8000
  inc hl
  inc hl
  inc hl
  ld a,(hl)
  add a,e   ; read limit and add to index
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  xor $80  ; flip most significant bit, getting true index value
  ld d,a
  push de ; result
  _jp_next

; doc{
;
; i  ( -- n|u ) ( R: do-sys -- do-sys )
;
; Return a copy of the current (innermost) loop index.
;
; Origin: Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _code_header question_leave_,'?LEAVE'

  ; XXX TODO -- move to the library

; doc{
;
; ?leave  ( f -- ) ( R: loop-sys -- | loop-sys )
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,leave_
  _jp_next

; ----------------------------------------------
  _code_header leave_,'LEAVE'

  ; XXX TODO -- move to the library?

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; BC = start address
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl ; write updated return stack pointer (6 was added)
  dec bc
  dec bc ; point IP to forward branch address

  ; Execution continues in `branch`:

; ----------------------------------------------
  _code_header branch_,'BRANCH'

; doc{
;
; branch  ( -- )
;
; The run-time procedure to branch unconditionally. The
; following in-line address is copied to IP to branch forward or
; backward.
;
; Origin: Forth-83 (System Extension Word Set).
;
; }doc

  ld h,b
  ld l,c ; HL = Forth IP, containing the address to jump to
  ld c,(hl)
  inc hl
  ld b,(hl) ; BC = New Forth IP
  _jp_next

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  ; XXX TODO -- move to the library
  ; (it's only used by `.s`, which will be removed from the kernel
  ; after the development)

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; DE = current index
  ex (sp),hl  ; HL = the increment value

  and a
  adc hl,de   ; add increment to index
  ; Note: `and a` and `adc` are used because `add` does not affect the po flag
  jp po,paren_plus_loop.continue

  ; If overflow, then boundary between limit-1 and limit is
  ; crossed, terminate loop.

  pop hl ; return stack pointer
  ld de,$0005
  add hl,de
  ld (return_stack_pointer),hl
  ; Increment return stack pointer by 5 (1 increment already done)
  _jp_next

paren_plus_loop.continue:
  ld d,h
  ld e,l ; DE = updated index
  pop hl ; return stack pointer

paren_loop.continue:

  ld (hl),d
  dec hl
  ld (hl),e  ; update the index on the return stack
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; IP = start address, repeat loop
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; DE = index value
  inc de      ; increment the index
  ld a,d
  xor $80
  or e        ; index=$8000?
  jp nz,paren_loop.continue

  ; limit reached
  ld de,$0005
  add hl,de ; increment RP by 5 (1 already done)
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header digit_question_,'DIGIT?'

; doc{
;
; digit?  ( c n -- u true | false )
;
; Convert the ascii character _c_ (using base _n_) to its binary
; equivalent _u_, accompanied by a true flag. If the conversion
; is invalid, leave only a false flag.
;
; Note: This word is equivalent to fig-Forth's `digit`.
;
; }doc

; XXX Note: alternative implementation in CamelForth:
;
;   \ silly looking but it works!
;   DUP $39 > $100 AND +
;   DUP $140 > $107 AND - $30 -
;   DUP BASE @ U< ;

  pop hl  ; l=base
  pop de  ; E=character
  ld a,e  ; character
  call ascii_upper.a
  sub '0' ; >="0"?
  jp c,false_ ; <"0" is invalid
  cp $0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub $07 ; gap between "9" & "A", now "A"=$0A
  cp $0A ; >="A"?
  jp c,false_ ; characters between "9" & "A" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_ ; no, invalid
  ld e,a ; converted digit
  push de
  jp true_

; ----------------------------------------------
  _colon_header number_base_,'NUMBER-BASE'

; doc{
;
; number-base  ( ca len -- ca' len' n )
;
; If the first char of string _ca len_ is a radix prefix, return
; its value _n_ and the updated string _ca' len'_ (which does
; not include the radix prefix).  Otherwise return _ca len_
; untouched and the current value of `base` _n_.
;
; ----
; : number-base  ( ca len -- ca' len' n )
;   dup if
;    over c@
;    dup '$' = if  drop 1 /string 16  exit  then
;    dup '%' = if  drop 1 /string  2  exit  then
;        '#' = if       1 /string 10  exit  then
;   then
;   base @  ;
; ----
;
; }doc

number_base.try_hex:
  dw dup_
  dw zero_branch_,number_base.current
  dw over_,c_fetch_
  dw dup_
  _literal '$'
  dw equals_,zero_branch_,number_base.try_binary
  dw drop_
  _literal 1
  dw slash_string_
  _literal 16
  dw exit_
number_base.try_binary:
  dw dup_
  _literal '%'
  dw equals_,zero_branch_,number_base.try_decimal
  dw drop_
  _literal 1
  dw slash_string_
  _literal 2
  dw exit_
number_base.try_decimal:
  _literal '#'
  dw equals_,zero_branch_,number_base.current
  _literal 1
  dw slash_string_
  _literal 10
  dw exit_
number_base.current:
  dw base_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header to_number_,'>NUMBER'

; doc{
;
; >number  ( ud1 ca1 len1 -- ud2 ca2 len2 )

; _ud2_ is the unsigned result of converting the characters
; within the string specified by _ca1 len1_ into digits, using
; the number in `base`, and adding each into _ud1_ after
; multiplying _ud1_ by the number in `base`. Conversion
; continues left-to-right until a character that is not
; convertible, including any "+" or "-", is encountered or the
; string is entirely converted. _ca2_ is the location of the
; first unconverted character or the first character past the
; end of the string if the string was entirely converted. _len2_
; is the number of unconverted characters in the string.

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : >number  ( d1 ca1 len1 -- d2 ca2 len2 )
;   begin  dup  while
;     over c@ base @ digit? while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string
;        \ 1 dpl +! \ XXX TODO
;   repeat then  ;
; ----
;
;
; }doc

; XXX TODO -- check:
; An ambiguous condition exists if _ud2_ overflows during the
; conversion.

  ; Credit:
  ; Code from DZX-Forth.

to_number.begin: ; begin
  dw dup_
  dw zero_branch_,to_number.end  ; while
; _chk '>number -- before digit' ; XXX INFORMER
  dw over_,c_fetch_,base_,fetch_,digit_question_
; _chk '>number -- after digit' ; XXX INFORMER
  dw zero_branch_,to_number.end  ; while
  dw to_r_,two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw u_m_star_,drop_
  dw rot_
  dw base_,fetch_
  dw u_m_star_
  dw d_plus_
  dw two_swap_
  _literal 1
  dw slash_string_
  ; dw one_,dpl_,plus_store_ ; XXX TODO why this?
  dw branch_,to_number.begin  ; repeat
to_number.end:
  ; then
  dw exit_

; ----------------------------------------------
  _defer_header number_point_question_,'NUMBER-POINT?',,standard_number_point_question_

; doc{
;
; number-point?  ( c -- f )
;
; Is character _c_ a valid point in a number?  This is a
; deferred word used in `number?`. Its default behaviour is
; `standard-number-point?`, which only allows the period.
;
; The library provides alternatives which accept more points.
;
; }doc

; ----------------------------------------------
  _colon_header standard_number_point_question_,'STANDARD-NUMBER-POINT?'

; doc{
;
; standard-number-point?  ( c -- f )
;
; Is character _c_ a valid point in a number?  The only allowed
; point is period.
;
; This is the default behaviour of the deferred word
; `number-point?`, which is used in `number?`.
;
; The library provides alternatives which accept more points.

; ----
; : number-point?  ( c -- f )
;   '.' =  ;
; ----
;
; }doc

; Credit:
;

  _literal '.'
  dw equals_
  dw exit_

; ----------------------------------------------
  _colon_header number_question_,'NUMBER?'

  ; XXX TODO make it a deferred word

; doc{
;
; number?   ( ca len -- 0 | n 1 | d 2 )
;
; Convert a string _ca len_ to a number. Return 0 if the
; conversion is not possible. If the result is a single number,
; return _n_ and 1. If the result is a double number, return _d_
; and 2.
;
; This word accepts valid point anywhere on the number and
; updates `dpl` with the position of the last one. If no
; point is found, `dpl` contains -1.
;
; Chars between single quotes are recognized, after Forth-2012.

; ----
; : number?   ( ca len -- 0 | n 1 | d 2 )
;
;   dup 0= if  2drop 0 exit  then  \ reject empty strings
;
;   2dup char? if  nip nip 1 exit  then  \ char format
;
;   over c@ number-point?  \ first char is a point?
;   if  2drop 0 exit  then  \ is so, reject the string
;
;   base @ >r  number-base base !  ( R: radix )
;   skip-sign? >r                  ( R: radix sign )
;   0 0 2swap  dpl on
;
;   begin  ( d ca len )  >number dup  while
;
;     over c@ number-point? 0=   \ invalid point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup dpl @ =   \ previous char was a point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup 1- dpl !  \ update the position of the last point
;     1 /string     \ skip the point
;
;   repeat
;
;   2drop                     \ discard the empty string
;   dpl @ 0<                  \ single-cell number?
;   if    d>s r> ?negate  1   \ single-cell number
;   else  r> ?dnegate  2      \ double-cell number
;   then  r> base !  ;        \ restore the radix
; ----

; }doc

  dw dup_,zero_equals_ ; empty string?
  dw zero_branch_,number_question.try_char
  ; reject an empty string
number_question.reject:
  dw two_drop_,false_
  dw exit_

number_question.try_char:
  dw two_dup_,char_question_ ; a char?
  dw zero_branch_,number_question.try_initial_point
  ; return the char code
  dw nip_,nip_
  _literal 1
  dw exit_

number_question.try_initial_point:
  dw over_,c_fetch_ ; first char...
  dw number_point_question_ ; ...is point?
  dw question_branch_,number_question.reject ; is so, reject the string

  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  dw two_lit_,0,0 ; initial value
  dw two_swap_,dpl_,on_

number_question.begin:
  dw to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question.done ; while

  ; The conversion was not completed, so it may be because of a
  ; point that indicates it's a double number.

  dw over_,c_fetch_ ; get the non-digit character
  dw number_point_question_ ; is it valid point?
  dw question_branch_,number_question.point

number_question.invalid_character:
  dw two_drop_,two_drop_,r_drop_,false_
  dw branch_,number_question.end

number_question.point:
  dw dup_,dpl_,fetch_,equals_ ; was the previous character a point?
  dw question_branch_,number_question.invalid_character ; if so, invalid

number_question.valid_point:
  dw dup_,one_minus_,dpl_,store_ ; update the position of the last point
  _literal 1
  dw slash_string_ ; skip the point

  dw branch_,number_question.begin ; repeat

number_question.done:
  dw two_drop_ ; discard the empty string
  dw dpl_,fetch_,zero_less_than_ ; single-cell number?
  dw zero_branch_,number_question.double

  ; single-cell number
  dw d_to_s_,from_r_,question_negate_
  _literal 1
  dw branch_,number_question.end

number_question.double:
  ; double-cell number
  dw from_r_,question_d_negate_
  _literal 2

number_question.end:
  dw from_r_,base_,store_  ; restore `base`

  dw exit_

; ----------------------------------------------
  _colon_header char_question_,'CHAR?'

; doc{
;
; char?  ( ca len -- c true | false )
;
; Is the string _ca len_ the representation of a character?
; If so return the character _c_ and _true_; else return
; _false_.
;
; ----
; : char?  ( ca len -- c true | false )
;   3 = if
;     dup c@ ''' <> if
;       dup [ 2 chars ] literal + c@ ''' <>
;       if  char+ c@ true exit  then
;     then
;   then
;   drop false ;
; ----
;
; }doc

  _literal 3
  dw equals_
  dw zero_branch_,char_question.not

char_question.right_length:
  dw dup_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.first_quote:
  dw dup_,two_plus_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.match:
  dw char_plus_,c_fetch_,true_,exit_

char_question.not:
  dw drop_,false_,exit_
  dw exit_

; ----------------------------------------------
  _colon_header skip_sign_question_,'SKIP-SIGN?'

; : sign?  ( ca len -- ca' len' f )
;   over c@ '-' = dup >r abs /string r>  ;
;   \ get optional sign
;   \ ca len = number
;   \ ca' len' = number without the minus sign
;   \ f = negative number?

  ; Credit:
  ; Code adapted from CamelForth.

  dw over_,c_fetch_
  _literal '-'
  dw equals_,dup_,to_r_,abs_
  dw slash_string_,from_r_
  dw exit_

; ----------------------------------------------
  _code_header find_name_from_,'FIND-NAME-FROM'

; doc{
;
; find-name-from  ( ca len nt1 -- nt2 | 0 )
;
; Find the definition named in the string _ca len_, starting at
; _nt1_. If the definition is found, return its _nt2_, else
; return zero.
;
; String _ca len_ must be below memory address $C000.
;
; }doc

if 1 ; far_memory

  ; XXX UNDER DEVELOPMENT

  ld (find_name_from.ip),bc ; save the Forth IP
  pop hl ; nt
  pop bc ; len; B is supposed to be 0
  ld (find_name_from.string_length.16_bits),bc
  ld a,c
  ld (find_name_from.string_length.8_bits),a
  pop de ; ca
  ld (find_name_from.string_address),de

find_name_from.begin:

  ; _z80_border 1 ; XXX INFORMER
  ; _z80_border 0 ; XXX INFORMER

  ; Compare the string with a word pointed by its nt.
  ; HL = nt of the word to compare with
  ;      (or zero if the end of the word list has been reached)
  ld (find_name_from.result),hl
  ld a,h
  or l ; end of word list? (nt=0)
  jr z,find_name_from.end
  call far.hl
  ; HL = actual address of the nt in the far memory, which is
  ;      paged in
  ld (find_name_from.converted_nt),hl

  ld a,(hl) ; length byte of the name field
  and valid_word_length_mask  ; mask the length and the smudge bit
find_name_from.string_length.8_bits: equ $+1
  cp $00 ; length of the string
  jr z,find_name_from.compare_characters
  ; Lengths differ.

find_name_from.not_a_match:
  ; Not a match, try the next word.
find_name_from.converted_nt: equ $+1
  ld hl,$0000 ; actual address of the nt in the far memory
  dec hl ; high address of the lfa
  call question_previous_bank
  ld b,(hl) ; high part of the next nt
  dec hl ; low address of the lfa
  call question_previous_bank
  ld l,(hl) ; low part of the next nt
  ld h,b ; HL = nt of the previous word
  jp find_name_from.begin ; continue

find_name_from.compare_characters:
  ; Lengths match, compare the characters.
  inc hl ; point to the first char of the name
  call question_next_bank
find_name_from.string_address: equ $+1
  ld de,$0000 ; string address
find_name_from.string_length.16_bits: equ $+1
  ld bc,$0000 ; string length
find_name_from.compare_next_char:
  ld a,(de)
  call ascii_upper.a
  cpi
  jr nz,find_name_from.not_a_match ; jump if the chars are different
  inc de ; point to next character of the string
  push de
  push af
  call question_next_bank
  pop af
  pop de
  jp pe,find_name_from.compare_next_char ; jump if length is not exhausted
  ; The length is exhausted, so the string and the name equal.

  ; _z80_border_wait 4 ; XXX INFORMER
  ; _z80_border 0 ; XXX INFORMER

find_name_from.end:
  call bank.default ; page in the default memory bank
find_name_from.result: equ $+1
  ld hl,$0000 ; result
  ; If match found:
  ;   HL = nt of the word found
  ; If no match found:
  ;   HL = false
find_name_from.ip: equ $+1
  ld bc,$0000 ; restore the Forth IP

  ; _z80_border_wait 2 ; XXX INFORMER
  ; _z80_border 0 ; XXX INFORMER

  _jp_pushhl

else

  ld (find_name_from.ip),bc ; save the Forth IP

  call bank.system ; page in the memory bank

  pop hl ; nt
  pop bc ; C=len, B is supposed to be 0
  ld a,c
  ld (find_name_from.string_length),a
  pop de ; ca
  ld (find_name_from.string_address),de

find_name_from.begin:
  ; Compare the string with a new word.
  ; HL = nt
  ld (find_name_from.nt),hl ; save the nt for later
  ld a,(hl) ; length byte of the name field
  and valid_word_length_mask  ; mask the length and the smudge bit
find_name_from.string_length: equ $+1
  ld c,$00 ; length of the string
  cp c ; same length?
  jr nz,find_name_from.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  inc hl ; point to the first char of the name in the dictionary
find_name_from.string_address: equ $+1
  ld de,$0000 ; string address
find_name_from.compare_next_char:
  ld a,(de)
  call ascii_upper.a
  cpi
  inc de ; point to next character of the string
  jp nz,find_name_from.not_a_match ; mismatch
  jp pe, find_name_from.compare_next_char ; count not exhausted

  ; The string matches.
  ld hl,(find_name_from.nt)
  jr find_name_from.end

find_name_from.not_a_match:
  ; Not a match, try the next word.

find_name_from.nt: equ $+1
                                        ;  T  B
  ld hl,$0000 ; nt                        10 03
  dec hl ; high address of lfa            06 01
  ld d,(hl) ; high part of the next nt    07 01
  dec hl ; low address of lfa             06 01
  ld e,(hl) ; low part of the next nt     07 01
  ex de,hl                              ; 04 01
  ld a,h                                ; 04 01
  or l ; end of dictionary? (next nt=0)   04 01
                                        ; 48 10 TOTAL

  jp nz,find_name_from.begin ; if not, continue

  ; End of dictionary, no match found.
  ld hl,false

find_name_from.end:
  ; If match found:
  ;   HL = nt
  ; If no match found:
  ;   HL = false
  exx
  call bank.default ; page in the default memory bank
  exx
find_name_from.ip: equ $+1
  ld bc,$0000 ; restore the Forth IP
  _jp_pushhl

endif

; ----------------------------------------------
  _colon_header search_wordlist_,'SEARCH-WORDLIST'

  ; XXX TODO -- move to the library, with `warnings`
  ; and the check done in `header,`.

; doc{
;
; search-wordlist  ( ca len wid -- 0 | xt 1 | xt -1 )
;
; Find the definition identified by the string _ca len_ in the
; word list identified by _wid_. If the definition is not found,
; return zero. If the definition is found, return its _xt_ and
; one (1) if the definition is immediate, minus-one (-1)
; otherwise.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : search-wordlist  ( ca len wid -- 0 | xt 1 | xt -1 )
;   @ find-name-from dup 0= ?exit
;   name>immediate? 0= 1 or  ;
; ----
;
; }doc

  dw fetch_
;  dw dup_,name_to_string_,cr_,type_ ; XXX INFORMER
  dw find_name_from_  ; ( nt | 0 )
  dw dup_,zero_equals_  ; ( nt false | 0 true )
  dw question_exit_  ; ( nt )
  dw name_to_immediate_question_ ; ( xt f )
  dw zero_equals_
  _literal 1
  dw or_ ; ( xt 1 | xt -1 )
  dw exit_

; ----------------------------------------------
  _colon_header find_name_,'FIND-NAME'

; doc{
;
; find-name  ( ca len -- nt | 0 )
;
; Find the definition identified by the string _ca len_ in the
; current search order. If the definition is not found after
; searching all the vocabularies in the search order, return
; zero.  If the definition is found, return its _nt_.
;
; ----
; : find-name  ( ca len -- nt | 0 )
;   #order @ 0 ?do
;     2dup context i cells + @ @ find-name-from ?dup
;     ( ca len nt nt | ca len 0 )
;     if  nip nip unloop exit  then
;   loop  2drop false  ;
; ----
;
; Origin: Gforth.
;
; }doc

  dw hash_order_,fetch_
  _literal 0
  dw paren_question_do_,find_name.loop_exit ; do

  ; ( ca len )
;  _chk_type 'find-name' ; XXX INFORMER
  dw two_dup_,context_,i_,cells_,plus_
;  _chk 'before first @' ; XXX INFORMER
  dw fetch_
;  _chk 'before second @' ; XXX INFORMER
  dw fetch_
;  _brk 'before find-name-from' ; XXX INFORMER
  dw find_name_from_
;  _chk 'after find-name-from' ; XXX INFORMER
  dw question_dup_ ; ( ca len nt nt | ca len 0 )
  dw zero_branch_,find_name.loop
  dw nip_,nip_,unloop_,exit_
find_name.loop:
  dw paren_loop_ ; loop

find_name.loop_exit:
  dw two_drop_,false_
  dw exit_

; ----------------------------------------------
  _code_header scan_,'SCAN'

; doc{
;
; scan  ( ca1 len1 c -- ca2 len2 )
;
; Scan the string _ca1 len1_ for the first occurence of
; character _c_.  Leave match address _ca2_ and length remaining
; _len2_.  If no match occurred then _len2_ is zero and _ca2_ is
; _ca1+len1_.
;
; }doc

  exx
  pop de ; E = char searched for
  pop bc ; len1, count
  ld a,c
  or b ; empty string?
  jr z,scan.nothing ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
  cpir ; scan until match or count=0
  jr nz,scan.no_match
  dec hl ; point to match char
  inc bc ; adjust the count
scan.no_match:
  push hl
scan.nothing:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header skip_,'SKIP'

; doc{
;
; skip  ( ca1 len1 c -- ca2 len2 | ca1 len1 )
;
; Skip over leading occurences of the character _c_ in the string
; _ca1 len1_.  Leave the address of the first non-matching
; character _ca2_ and length remaining _len2_.  If no characters were
; skipped leave _ca1 len1_.
;
; }doc

; Credit:
; Code adapted and modified from CamelForth.

  exx
  pop de ; E = char searched for
  pop bc ; len1
  ld a,c
  or b ; empty string?
  jr z,skip.end ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
skip.begin:
  cpi
  jr nz,skip.mismatch ; char mismatch, exit
  jp pe,skip.begin ; count not exhausted
  jr skip.done ; count 0, no mismatch
skip.mismatch:
  dec hl ; point at mismatch char
  inc bc ; adjust the count
skip.done:
  push hl
skip.end:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header channel_,'CHANNEL'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
  ; Credit:
  ; Code from Spectrum Forth-83.

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header mode32_emit_,'MODE32-EMIT'

; doc{
;
; mode32-emit  ( c -- )
;
; Send character _c_ to the current channel.
;
; }doc

  pop hl
  ; h = 0
  ; l = character code
  push bc

  ld (iy+sys_scr_ct_offset),$FF ; no scroll message

  ld a,l
  cp 128 ; control or ASCII character?
  jp nc,emit_udg.a ; if not, jump

  ; use the ROM routine to print a control or ASCII character
  rst $10
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header emit_udg_,'EMIT-UDG'

; doc{
;
; emit-udg  ( c -- )
;
; Print the User Defined Character _c_ (128..255).
;
; }doc

  pop hl
  push bc
  ; h = 0
  ld a,l

emit_udg.a
  ; a = UDG code (128..255)
  ; h = 0
  sub 128
  jr emit_0udg.a

; ----------------------------------------------
  _code_header emit_0udg_,'EMIT-0UDG'

; doc{
;
; emit-0udg  ( b -- )
;
; Print the User Defined Character _b_ (0..255).
;
; }doc

  pop hl
  push bc
  ; h = 0
  ld a,l

emit_0udg.a
  ; a = UDG code (0..255)
  ; h = 0
  ld l,a ; HL = UDG index code (0..255)
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; DE = char address in the font
  ld bc,(sys_s_posn) ; cursor position
  ld hl,(sys_df_cc) ; current screen address
  call rom_pr_all
  ld (sys_s_posn),bc
  ld (sys_df_cc),hl
  pop bc
  _jp_next

; ----------------------------------------------
  _defer_header emit_,'EMIT',,mode32_emit_

; XXX TODO -- Add multitasker's `pause` when available.

; ----------------------------------------------
  _variable_header printing_,'PRINTING'

; doc{
;
; printing  ( -- a )
;
; _a_ is the address of a cell containing the printer flag.
; This flag is set by `printer`, reset by `display` and checked
; by `page`. It should not be changed directly.
;
; }doc

  dw false

; ----------------------------------------------
  _colon_header display_,'DISPLAY'

; doc{
;
; display  ( -- )
;
; Select the display as output.
;
; }doc

  _literal 2
  dw channel_
  dw printing_,off_
  dw exit_

; ----------------------------------------------
  _variable_header key_translation_table_,'KEY-TRANSLATION-TABLE'

; doc{
;
; key-translation-table  ( -- a )
;
; A variable that holds the address of the current key
; translation table, used by `key`.
;
; The table consists of pairs of characters. The first one is
; the character that has to be translated and the second one is
; its translation. The table is finished with a zero.
;
; The default table makes it possible to access the following
; chars with Symbol Shift: '[', ']', '~', '|', '\', '{' and '}'.
;
; }doc

  dw default_key_translation_table

default_key_translation_table:

;  dw 0 ; no chained table ; XXX TODO
              ; Symbol Shift + Letter --> new char
  db $C6,'[' ; "Y" 198 ($C6) "AND"  --> 091 ($5B) "["
  db $C5,']' ; "U" 197 ($C5) "OR"   --> 093 ($5D) "]"
  db $E2,'~' ; "A" 226 ($E2) "STOP" --> 126 ($7E) "~"
  db $C3,'|' ; "S" 195 ($C3) "NOT"  --> 124 ($7C) "|"
  db $CD,'\' ; "D" 205 ($CD) "STEP" --> 092 ($5C) "\"
  db $CC,'{' ; "F" 204 ($CC) "TO"   --> 123 ($7B) "{"
  db $CB,'}' ; "G" 203 ($CB) "THEN" --> 125 ($7D) "}"
  db 0 ; end of data

  ; "I" 172 ($AC) "AT"   --> 127 ($7F) "(C)" ; XXX TODO

; ----------------------------------------------
  _code_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c1 | c2 )
;
; Translate char _c1_ using the current keyboard decoding table,
; pointed by `key-translation-table`.
;
; }doc

  pop de
  ld a,e
  call translate_char.a
  jp push_a

translate_char.a:
  ld hl,(key_translation_table_pfa)
  dec hl
translate_char.begin:
  inc hl    ; next record of the table
  ld e,(hl) ; char that must be translated, or zero
  inc e     ; is it...
  dec e     ; zero? (=end of table?)
  ret z
  cp e      ; match?
  inc hl    ; point to the char transalation
  jr nz,translate_char.begin ; no match yet, continue
  ; match
  ld a,(hl) ; translate char
  ret

if 0 ; XXX UNDER DEVELOPMENT

  ; improved version with support for chained tables

; ----------------------------------------------
  _colon_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c2 )
;
; }doc

  ; XXX TODO

  dw key_translation_table_
  dw fetch_
  dw question_dup_
  _literal 0

translate_char.do_it
  dw cell_plus_
  dw paren_translate_char_
  dw exit_

; ----------------------------------------------
  _code_header paren_translate_char_,'(TRANSLATE-CHAR)'

; doc{
;
; (translate-char)  ( c1 ca -- c1 false | c2 true )
;
; }doc

  pop hl  ; ca
  pop de  ; c1
  push de ; keep c1 on the stack, as default
  dec hl

translate_char.begin:
  inc hl
  ld a,(hl)
  and a ; end of table?
  jp z,false_ ; no match found
  cp e
  inc hl
  jr nz,translate_char.begin

  ; match found
  ld e,(hl)
translate_char.end:
  pop hl  ; discard c1
  push de
  jp true_

endif

; ----------------------------------------------
  ; _code_header paren_key_,'(KEY)'

  ; XXX not used yet

  ; ld a,(sys_last_k)
  ; ld (previous_key),a
; paren_key_.begin:
  ; ; call pause ; XXX TODO
  ; ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ; ld a,(sys_last_k)
; previous_key: equ $+1
  ; cp 0 ; a different key?
  ; jp z,paren_key_.begin
  ; ld h,0
  ; ld l,a
  ; xor a
  ; ld (sys_last_k),a ; delete the last key
  ; push hl
  ; jp translate_char_

; ----------------------------------------------
  _code_header default_break_key_question_,'DEFAULT-BREAK-KEY?'

; doc{
;
; default-break-key?  ( -- f )
;
; Is the default break key (Shift+Space) pressed?
; This is the default behaviour of the deferred word
; `break-key?`.
;
; }doc

  call rom_break_key
  jp nc,true_
  jp false_

; ----------------------------------------------
  _defer_header break_key_question_,'BREAK-KEY?',,default_break_key_question_

; doc{
;
; break-key?  ( -- f )
;
; Is the break key pressed? This is a deferred work that by
; default executes `default-break-key?`.
;
; }doc

; ----------------------------------------------
  _code_header key_question_,'KEY?'

; doc{
;
; key?  ( -- f )
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

  ; XXX -- This version works only when the system interrupts
  ; are on.

  bit 5,(iy+$01) ; new key available? (system variable FLAGS)
  jp z,false_
  jp true_

; ----------------------------------------------
  _variable_header cursor_char_,'CURSOR-CHAR'

; doc{
;
; cursor-char  ( -- a )
;
; A byte variable that holds the character code of the cursor
; used by `xkey`. Note this is a character variable, thus it has to
; be fetched with `c@` and modified with `c!`.
;
; }doc

  db $5F ; char code

; ----------------------------------------------
  _code_header key_,'KEY'

; doc{
;
; key  ( -- c )
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  call wait_for_key
  call translate_char.a ; XXX TODO
  jp push_a

; ----------------------------------------------
  _code_header xkey_,'XKEY'

; doc{
;
; xkey  ( -- c )
;
; Show a cursor, wait for the next terminal key struck; if it's
; the caps lock key, toggle caps and keep waiting; else leave
; the char code of the key struck.
;
; }doc

  ; XXX TODO -- rename to `a[ccept]key`, `c[aps]key`, `m[ode]key`?
  ; XXX TODO -- rewrite in Forth and move to the library

  push bc

  ; Print cursor:
  ld a,(cursor_char_pfa) ; cursor char code
  rst $10
  ld a,backspace_char
  rst $10

xkey.new_key:
  call wait_for_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,xkey.translate
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,$08
  xor (hl)
  ld (hl),a
  jr xkey.new_key

xkey.translate:
  ; Translate some chars
  call translate_char.a ; XXX TMP
  ld l,a
  ld h,$00

  ; delete the cursor
  ld a,space_char
  rst $10
  ld a,backspace_char
  rst $10

  pop bc
  _jp_pushhl

; ----------------------------------------------
  _code_header wait_for_key_,'WAIT-FOR-KEY'

; doc{
;
; wait-for-key  ( -- )
;
; Wait for a valid key and discard it.
;
; }doc

  ; XXX TODO -- make it compatible with the future multitasking

  push ix ; make next `ret` jump to `next`

wait_for_key:
  ; output: A = key code
  bit 5,(iy+1)      ; FLAGS system variable: new key available?
  jr z,wait_for_key
  ld a,(sys_last_k) ; return the key in register A
  res 5,(iy+1)      ; no new key available anymore
  ret

; ----------------------------------------------
  _colon_header paren_cr_,'(CR)'

  _literal carriage_return_char
  dw emit_
  dw exit_

; ----------------------------------------------
  _defer_header cr_,'CR',,paren_cr_

; doc{
;
; cr  ( -- )
;
; Transmit a carriage return to the selected output device.
;
; }doc

; ----------------------------------------------
  _code_header c_move_up_,'CMOVE>'

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header c_move_,'CMOVE'

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'MOVE'

; doc{
;
; move  ( a1 a2 len -- )
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header s_move_,'SMOVE'

; doc{
;
; smove  ( ca1 len1 ca2 -- )
;
; Move the string _ca1 len1_ to _ca2_.
;
; This word is the equivalent of the idiom `swap move`, but
; faster.
;
; }doc

  exx
  pop de
  pop bc
  _jump move.do

; ----------------------------------------------
  _code_header u_m_star_,'UM*'

; doc{
;
; um*  ( u1 u2 -- ud )
;
; Multiply _u1_ by _u2_, giving the unsigned double-cell product
; _ud_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 1 ; original_u_m_star

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  jp push_hlde

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX TODO version adapted from Z88 CamelForth

  exx
  pop bc      ; u2 in BC
  pop de      ; u1 in DE
  ld hl,0     ; result will be in HLDE
  ld a,17     ; loop counter
  or a        ; clear CY
u_m_star.do:
  rr h
  rr l
  rr d
  rr e
  jp nc,u_m_star.noadd
  add hl,bc
u_m_star.noadd:
  dec a
  jp nz,u_m_star.do
  push de     ; lo result
  push hl     ; hi result
  exx
  _jp_next

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX -- adapted from hForth

  exx
  pop bc          ; BC = u2
  pop de          ; DE = u1
  ld  hl,$0000
  ld  a,$10
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jp  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jp  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jp  nz,u_m_star.1
u_m_star.4:
  push hl
  push de
  exx
  _jp_next

endif

if 0 ; XXX OLD

  ; XXX -- Original version from hForth

  ; SP: data stack pointer
  ; IX: return stack pointer
  ; DE: Forth virtual machine instruction pointer
  ; BC: top of data stack item

                ; BC = u2, TOS = u1
  ex  de,hl     ; HL = IP, DE = ?
  ex  (sp),hl   ; TOS = IP,  HL = u1
  ex  de,hl     ; DE = u1, HL = ?
  ld  hl,0
  ld  a,010h
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jr  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jr  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jr  nz,u_m_star.1
u_m_star.4:
  ld  b,d
  ld  c,e
  ex  (sp),hl
  ; $nexthl

endif

; ----------------------------------------------
  _code_header u_m_slash_mod_,'UM/MOD'

; doc{
;
; um/mod ( ud u1 -- u2 u3 )
;
; Divide _ud_ by _u1_, giving the quotient _u3_ and the
; remainder _u2_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth.

  exx
  pop bc      ; BC = divisor
  pop hl      ; HLDE = dividend
  pop de
  ld a,16     ; loop counter
  sla e
  rl d        ; hi bit DE -> carry
u_m_slash_mod.do:
  adc hl,hl   ; rot left w/ carry
  jr nc,u_m_slash_mod.3
  ; case 1: 17 bit, CY:HL = 1xxxx
  or a        ; we know we can subtract
  sbc hl,bc
  or a        ; clear CY to indicate sub ok
  jr u_m_slash_mod.4
  ; case 2: 16 bit, CY:HL = $xxx
u_m_slash_mod.3:
  sbc hl,bc   ; try the subtract
  jr nc,u_m_slash_mod.4 ; if no CY, subtract ok
  add hl,bc   ; else cancel the subtract
  scf         ;   and set CY to indicate
u_m_slash_mod.4:
  rl e        ; rotate result bit into DE,
  rl d        ; and next bit of DE into CY
  dec a
  jr nz,u_m_slash_mod.do
  ; now have complemented quotient in DE,
  ; and remainder in HL
  ld a,d
  cpl
  ld b,a
  ld a,e
  cpl
  ld c,a
  push hl     ; remainder
  push bc     ; quotient
  exx
  _jp_next

; ----------------------------------------------
  _code_header and_,'AND'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _code_header or_,'OR'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _code_header xor_,'XOR'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _constant_header slash_user_,'/USER'

; doc{
;
; /user  ( -- n )
;
; Constant, the length of the user area.
;
; }doc

  dw bytes_per_user_variables

; ----------------------------------------------
  _variable_header up_,'UP'

; doc{
;
; up  ( -- a )
;
; A variable. _a_ holds the address of the user area pointer.
;
; Origin: fig-Forth.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header up0_,'UP0'

; doc{
;
; up0  ( -- a )
;
; Constant, the default address of the user area.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header hp_,'HP'

  ; XXX TODO -- update documentation for far memory
  ; XXX TODO -- user variable?

; doc{
;
; hp  ( -- a )
;
; Address that holds the headers-space pointer, which points to
; the next free address where the next word header will be
; stored.
;
; }doc

  dw headers_pointer

; ----------------------------------------------
  _constant_header hp0_,'HP0'

  dw headers_pointer_bottom

; ----------------------------------------------
  _code_header hp_fetch_,'HP@'

  ; XXX TODO -- remove?
  ;
  ; XXX TODO -- move to the library? (used in the modules of
  ; `indexer`, `-transient`, `module` and `marker`)

; doc{
;
; hp@  ( -- a )
;
; Fetch the content of the headers-space pointer.
;
; }doc

  ld hl,(headers_pointer)
  _jp_pushhl

; ----------------------------------------------
  _code_header hp_store_,'HP!'

  ; XXX TODO -- remove?
  ;
  ; XXX TODO -- move to the library? (used in the modules of
  ; `-transient` and `marker`)

; doc{
;
; hp!  ( a -- )
;
; Store _a_ into the headers-space pointer.
;
; }doc

  pop hl
  ld (headers_pointer),hl
  _jp_next

; ----------------------------------------------

  ; XXX TODO -- update documentation for far memory

  _colon_header comma_hp_,',HP'

; doc{
;
; ,hp  ( x -- )
;
; Store _x_ into the address pointed by the headers pointer,
; advancing the headers pointer.
;
; }doc

  dw hp_fetch_
if 1 ; far_memory
  dw far_store_
else
  ; Note: The system bank must be paged in.
  dw store_
endif
  dw cell_,hp_,plus_store_
  dw exit_

; ----------------------------------------------
  _code_header sp_fetch_,'SP@'

; doc{
;
; sp@  ( -- a )
;
; Fetch the content of the stack pointer.
;
; }doc

  ld hl,$0000
  add hl,sp
  _jp_pushhl

; ----------------------------------------------
  _code_header sp_store_,'SP!'

; doc{
;
; sp!  ( a -- )
;
; Store _a_ into the stack pointer.
;
; }doc

  pop hl
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'RP'

  ; XXX TODO -- convert to user variable

; doc{
;
; rp  ( -- a )
;
; Address of the return stack pointer.
;
; }doc

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP@'

; doc{
;
; rp@  ( -- a )
;
; Fetch the content of the return stack pointer.
;
; }doc

  ld hl,(return_stack_pointer)
  _jp_pushhl

; ----------------------------------------------
  _code_header rp_store_,'RP!'

; doc{
;
; rp!  ( a -- )
;
; Store _a_ into the return stack pointer.
;
; }doc

  pop hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header to_r_,'>R'

; doc{
;
; >r  ( x -- ) ( R: -- x )
;
; }doc

  pop de
to_r_.de ; entry point used (calculated) by `dup>r`, defined in the library
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R>'

; doc{
;
; r>  ( -- x ) ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDROP'

; doc{
;
; rdrop  ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>R'

; doc{
;
; 2>r  ( x1 x2 -- ) ( R: -- x1 x2 )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2R>'

; 2r>  ( -- x1 x2 ) ( R: x1 x2 -- )

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_

; ----------------------------------------------
  _code_header two_r_fetch_,'2R@'

  ; XXX TODO -- Move to the library? But the Z80 label
  ; `two_fetch.hl` should be returned by a constant.
  ; Alternative: write it in Forth.

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R@'

  ld hl,(return_stack_pointer)
  jp fetch.hl

; ----------------------------------------------
  _code_header zero_equals_,'0='

  pop hl
zero_equals.hl:
  ld a,l
  or h
  jp z,true_

  ; Execution continues in `0`, which is `false`:

; ----------------------------------------------
  _code_header zero_,'0'

; doc{
;
; 0  ( -- 0 )
;
; }doc

  ld hl,0
  _jp_pushhl

; ----------------------------------------------
  _alias_header false_,'FALSE',,zero_

; doc{
;
; false  ( -- false )
;
; }doc

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

  pop hl
  ld a,l
  or h
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization
    add hl,hl ; 11t, 1 byte
  else
    ; Credit:
    ; Idea from Ace Forth.
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_
  jp false_

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  ld hl,0
  jp less_than.de_hl

; ----------------------------------------------
  _code_header plus_,'+'

  pop de
  pop hl
  add hl,de
  _jp_pushhl

; ----------------------------------------------
  _code_header d_plus_,'D+'

; doc{
;
; d+  ( d1|ud1 d2|ud2 -- d3|ud3 )
;
; Add _d2|ud2_ to _d1|ud1_, giving the sum _d3|ud3_.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

                        ;  t  B
                        ;  -- --
  pop de                ;  10 01 ; DE=d2hi
  exx                   ;  04 01
  pop de                ;  10 01 ; DE'=d2lo
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL=d1hi,DE=d2hi
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL'=d1lo
  add hl,de             ;  11 01
  push hl               ;  11 01 ; 2OS=d1lo+d2lo=d3lo
  exx                   ;  04 01
  adc hl,de             ;  15 02 ; HL=d1hi+d2hi+CY=d3hi
  push hl               ;  11 01
  _jp_next              ;  08 02
                        ;  -- --
                        ; 112 15 TOTALS

; ----------------------------------------------
  _code_header invert_,'INVERT'

; doc{
;
; invert  ( x1 -- x2 )
;
; Invert all bits of _x1_ giving its logical inverse _x2_.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

  pop hl
  ld a,h
  cpl
  ld h,a
  ld a,l
  cpl
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _code_header negate_,'NEGATE'

; doc{
;
; negate  ( n1 -- n2 )
;
; Negate _n1_, giving its arithmetic inverse _n2_.
;
; Origin: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop hl
  call negate_hl
  _jp_pushhl

; ----------------------------------------------
  _code_header d_negate_,'DNEGATE'

; doc{
;
; dnegate  ( d1 -- d2 )
;
; Negate _d1_, giving its arithmetic inverse _d2_.
;
; Origin: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if size_optimization

  ; Credit:
  ; Code from Spectrum Forth-83.
  ;
  ; Comparison to the Abersoft Forth version:
  ; Time:  1.04
  ; Size: -1

                                                ; T   B
                                                ; --- --
  pop     hl        ; high part                 ;  10 01
  pop     de        ; low part                  ;  10 01
  push    hl        ; save copy                 ;  11 01
  ld      hl,$0000                              ;  10 03
  and     a                                     ;  04 01
  sbc     hl,de     ; HL = negated low part     ;  15 02
  pop     de        ; high part                 ;  10 01
  push    hl        ; negated low part          ;  11 01
  ld      hl,$0000                              ;  10 03
  sbc     hl,de     ; HL = negated high part    ;  15 02
  _jp_pushhl                                    ;  11 01 push hl
                                                ;  08 02 jp (ix)
                                                ; --- --
                                                ; 125 19
else

  ; Credit:
  ; Code from Abersoft Forth, also found in White Lightning.

  ; XXX TODO optimize?

                                                ; T   B
                                                ; --- --
  pop hl      ; high part                       ;  10 01
  pop de      ; low part                        ;  10 01
  sub a       ; zero                            ;  04 01
  sub e       ; two's complement to carry       ;  04 01
  ld e,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,d     ; two's complement with carry     ;  04 01
  ld d,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,l     ; two's complement with carry     ;  04 01
  ld l,a                                        ;  04 01
  ld a,$00                                      ;  07 02
  sbc a,h     ; two's complement with carry     ;  04 01
  ld h,a                                        ;  04 01
  jp push_hlde                                  ;  10 03
                                                ;  11 00 push de
                                                ;  11 00 push hl
                                                ; --- --
                                                ; 109 20

endif

  ; Note: High level version from Z88 CamelForth (17 bytes):
  ;
  ; ----
  ; : dnegate  ( d1 -- d2 )
  ;   swap invert swap invert 1 m+  ;
  ; ----

; ----------------------------------------------
  _code_header nip_,'NIP'

  pop hl
  pop de
  _jp_pushhl

; ----------------------------------------------
  _code_header tuck_,'TUCK'

  pop hl
  pop de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header over_,'OVER'

  pop de
  pop hl
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header drop_,'DROP'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWAP'

  pop hl
  ex (sp),hl
  _jp_pushhl

; ----------------------------------------------
  _code_header dup_,'DUP'

  pop hl
  push hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_dup_,'2DUP'

  pop hl
  pop de
  push de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header plus_store_,'+!'

; doc{
;
; +!  ( n|u a -- )
;
; Add _n|u_ to the single-cell number at _a_.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop hl ; address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OFF'

; doc{
;
; off  ( a -- )
;
; Store _false_ at _a_.
;
; Origin: Comus.
;
; }doc

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'ON'

; doc{
;
; on  ( a -- )
;
; Store _true_ at _a_.
;
; Origin: Comus.
;
; }doc

  pop hl
  ld (hl),$FF
  inc hl
  ld (hl),$FF
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_test_bits_question_,'C@TEST-BITS?'

; doc{
;
; c@test-bits?  ( b ca -- f )
;
; Test the bits at _ca_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

  ; XXX TODO -- rename
  ; XXX TODO -- move to the library

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  and (hl)
  jp nz,true_
  jp false_

; ----------------------------------------------
  _code_header c_store_set_bits_,'C!SET-BITS'

; doc{
;
; c!set-bits  ( b ca -- )
;
; Set the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  ; XXX TODO -- rename
  ; XXX TODO -- move to the library, when possible.

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  or (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header c_store_reset_bits_,'C!RESET-BITS'

; doc{
;
; c!reset-bits  ( b ca -- )
;
; Reset the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  ; XXX TODO -- rename
  ; XXX TODO -- move to the library, when possible.

  pop hl ; address
  pop de ; E = bitmask
  ld a,e
  cpl
  and (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header two_store_,'2!'

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _constant_header do_colon_,'DOCOLON'

; doc{
;
; docolon  ( -- a )
;
; A constant that returns the address of the colon interpreter.
;
; }doc

  dw do_colon

; ----------------------------------------------
  _colon_header colon_,':'

  dw store_csp_
  dw header_
  dw lit_,do_colon
  dw call_comma_
  dw right_bracket_
  dw paren_semicolon_code_
do_colon:
  ; Save the Forth IP to the return stack
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; Then point it to the pfa of the word that called here
  pop bc ; BC=pfa
  _jp_next

; ----------------------------------------------
  _variable_header noname_question_,'NONAME?'

; doc{
;
; noname?  ( -- a )
;
; A variable that holds a flag: Was the word being defined
; created by `:noname`? This flag is set by `:noname` and reset
; by `;`.
;
; }doc

; Credit:
; The idea for this variable was taken from hForth.

  dw false

; ----------------------------------------------
  _colon_header finish_code_,'FINISH-CODE'

; doc{
;
; finish-code  ( -- )
;
; ----
; : finish-code  ( -- )
;   ?csp  postpone [
;   noname? @  noname? off  ?exit
;   reveal  ;
; ----
;
; }doc

  ; Credit:
  ;
  ; Name borrowed from Gforth.

  dw question_csp_
  dw left_bracket_
  dw noname_question_,fetch_
  dw noname_question_,off_
  dw question_exit_
  dw reveal_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate+compile_only

; doc{
;
; ;  ( -- )
;
; ----
; : ;  ( -- )
;   postpone exit  finish-code  ;
; ----
;
; }doc

  dw compile_,exit_
  dw finish_code_
  dw exit_

; ----------------------------------------------
  _colon_header c_constant_,'CCONSTANT'

  dw create_,c_comma_
  dw paren_semicolon_code_
do_c_constant:

  ; Execution continues in `c@`:

; ----------------------------------------------
  _code_header c_fetch_,'C@'

  pop hl
c_fetch.hl:
  ld l,(hl)
  ld h,$00
  _jp_pushhl

; ----------------------------------------------
  _colon_header constant_,'CONSTANT'

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:

  ; Execution continues in `@`:

; ----------------------------------------------
  _code_header fetch_,'@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _colon_header variable_,'VARIABLE'

; doc{
;
; variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve one cell of data
; space.
;
;    _name_ is referred to as a variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the reserved cell. A program is
;    responsible for initializing the contents of the reserved
;    cell.
;
; Origin: Forth-94.
;
; }doc

  dw create_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header paren_user_,'(USER)'

  ; XXX TODO -- Rename to `user`? That was the original name in
  ; fig-Forth, Forth-79 and Forth-83. Choose an alternative
  ; for the current `user`, defined in the library.

; doc{
;
; (user)  ( +n "name" -- )
;
; Create a user variable _name_.  _+n_ is the offset within the
; user area where the value for _name_ is stored.  Execution of
; _name_ leaves its absolute user area storage address.
;
; This word is a factor of `ucreate`.
;
; See: `ucreate`, `user`, `2user`.
;
; Origin: This word is called `user` in fig-Forth, Forth-79
; (Reference Word Set) and Forth-83 (Uncontrolled Reference
; Words).
;
; }doc

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  pop hl
  ld e,(hl)
  ld d,$00        ; DE = index of the user variable
  ld hl,(up_pfa)  ; HL = address of the user area (the value of `up`)
  add hl,de       ; HL = address of the user variable
  _jp_pushhl

; ----------------------------------------------
  _code_header one_,'1'

; doc{
;
; 1  ( -- 1 )
;
; }doc

  ld hl,1
  _jp_pushhl

; ----------------------------------------------
  _code_header two_,'2'

; doc{
;
; 2  ( -- 2 )
;
; }doc

  ld hl,2
  _jp_pushhl

; ----------------------------------------------
  _c_constant_header b_l_,'BL'

; doc{
;
; bl  ( -- b )
;
; }doc

  db space_char

; ----------------------------------------------
  _c_constant_header c_slash_l_,'C/L'

  db characters_per_line

; ----------------------------------------------
  _c_constant_header l_slash_scr_,'L/SCR'

  db lines_per_screen

; ----------------------------------------------
  _constant_header disk_buffer_,'DISK-BUFFER'

; doc{
;
; disk-buffer  ( -- a )
;
; Address of the disk buffer, which is a cell that holds its id.
;
; }doc

  dw disk_buffer

; ----------------------------------------------
  _constant_header buffer_data_,'BUFFER-DATA'

  ; XXX TODO -- rename

; doc{
;
; buffer-data  ( -- ca )
;
; Address of the disk buffer contents.
;
; }doc

  dw disk_buffer+cell

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BUF'

  dw bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_rec_,'B/REC'

; XXX TODO -- move to the library?

  dw bytes_per_sector

; ----------------------------------------------
  _c_constant_header rec_slash_blk_,'REC/BLK'

; XXX TODO -- move to the library?

  db sectors_per_block

; ----------------------------------------------
  _constant_header blk_slash_disk_,'BLK/DISK'

  ; XXX FIXME -- also defined as `blocks`
  ; XXX TODO -- move to the library?

  dw blocks_per_disk

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGIN'

; doc{
;
; +origin  ( n -- a )
;
; Leave the memory address relative by _n_ bytes to the origin
; parameter area.  This definition is used to access or modify
; the boot-up parameters at the origin area.
;
; Origin: fig-Forth.
;
; }doc

  dw lit_,origin,plus_
  dw exit_

; ----------------------------------------------
  _user_variable_header sp0_,'SP0'

; doc{
;
; sp0  ( -- a )
;
; User variable that holds the address of the bottom of the data
; stack.
;
; Note: In fig-Forth, Forth-79 and Forth-83 it's called `S0`.
;
; }doc

  db $00

; ----------------------------------------------
  _user_variable_header rp0_,'RP0'

; doc{
;
; rp0  ( -- a )
;
; User variable that holds the address of the bottom of the
; return stack.
;
; Note: In fig-Forth it's called `R0`.
;
; }doc

  db $02

; ----------------------------------------------
  _user_variable_header paren_wait_,'(WAIT)'

; XXX TMP -- from Spectrum Forth-83.
; XXX TODO --

; doc{
;
; (wait)  ( -- a )
;
; User variable that holds the xt of a word to be executed by
; some words that accept user input, during multitasking.
;
; }doc

  db $04

; ----------------------------------------------
  _user_variable_header width_,'WIDTH'

  ; XXX TODO normal variable? constant?
  ; XXX TODO -- remove?

; doc{
;
; width  ( -- a )
;
; User variable that holds the maximum number of letters saved
; in the compilation of a definition name. It must be 1 thru 31,
; with a default value of 31. The name character count and its
; natural characters are saved, up to the value in `width`.  The
; value may be changed at any time within the above limits.
;
; Origin: fig-Forth.
;
; }doc

  db $06

; ----------------------------------------------
if 1 ; developing

  ; XXX TMP -- during the development

  _user_variable_header warnings_,'WARNINGS'

; doc{
;
; warnings  ( -- a )
;
; User variable that holds a flag. If it's zero, no warning is
; shown when a compiled word is not unique in the `current`
; vocabulary.
;
; }doc

  db $08

endif

; ----------------------------------------------
  _user_variable_header last_,'LAST'

; doc{
;
; last  ( -- a )
;
; User variable that holds the name token of the last word
; defined.
;
; }doc

  db $0A

; ----------------------------------------------
  _user_variable_header dp_,'DP'

; doc{
;
; dp  ( -- a )
;
; A variable, the data-space pointer, which contains its next
; free address.  The value may be read by `here` and altered by
; `there` and `allot`.
;
; Origin: fig-Forth (where `dp` is a user variable).
;
; }doc

  db $0C

; ----------------------------------------------
  _user_variable_header udp_,'UDP'

; doc{
;
; udp  ( -- a )
;
; User variable that holds an offset from the start of the
; current user area to the free space in it.
;
; }doc

  db $0E

; ----------------------------------------------
  _user_variable_header lastxt_,'LASTXT'

; doc{
;
; lastxt  ( -- a )
;
; User variable that holds the execution token of the last word
; defined.
;
; }doc

  db $10

; ----------------------------------------------
  _user_variable_header to_in_,'>IN'

; doc{
;
; >in  ( -- a )
;
; A user variable that contains the offset in characters from
; the start of the input buffer to the start of the parse area.
;
; }doc

  db $12

; ----------------------------------------------
  _user_variable_header blk_,'BLK'

  ; XXX TODO normal variable?

; doc{
;
; blk  ( -- a )
;
; User variable that holds the number of the disk block being
; interpreted. A disk block holds 1024 bytes. One source screen
; consists of one disk block.
;
; }doc

  db $14

; ----------------------------------------------
  _user_variable_header scr_,'SCR'

; XXX TODO normal variable?

; doc{
;
; scr  ( -- a )
;
; User variable that holds the screen number of the screen most
; recently listed (with `list`) or loaded (with `load` or
; `continued`). This is the value used by `reload`.
;
; }doc

  db $16

; ----------------------------------------------
  _user_variable_header catcher_,'CATCHER'

; doc{
;
; catcher  ( -- a )
;
; A user variable that holds the return stack pointer for error
; handling. Used by `throw`.
;
; }doc

  db $18

; ----------------------------------------------
  _user_variable_header hld_,'HLD'

; doc{
;
; hld  ( -- a )
;
; A user variable that holds the address of the latest character of
; text during numeric output conversion.
;
; Origin: fig-Forth.
;
; }doc

  db $1A

; ----------------------------------------------
  _user_variable_header current_,'CURRENT'

; doc{
;
; current  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $1C

; ----------------------------------------------
  _user_variable_header state_,'STATE'

; doc{
;
; state  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $1E

; ----------------------------------------------
  _user_variable_header base_,'BASE'

; doc{
;
; base  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $20

; ----------------------------------------------
  _user_variable_header dpl_,'DPL'

; doc{
;
; dpl  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $22

; ----------------------------------------------
  _user_variable_header csp_,'CSP'

  ; XXX TODO ordinary variable?

; doc{
;
; csp  ( -- a )
;
; User variable that holds the current data stack position saved
; by `!csp`.
;
; Origin: fig-Forth.
;
; }doc

  db $24

; ----------------------------------------------
  _user_variable_header hash_order_,'#ORDER'

; doc{
;
; #order  ( -- a )
;
; User variable that holds the number of word lists in the
; search order.
;
; }doc

  db $26

; ----------------------------------------------
  _user_variable_header context_,'CONTEXT'

; doc{
;
; context  ( -- a )
;
; User variable that holds... XXX TODO
;
; }doc

  db $28

; ----------------------------------------------
  _variable_header voc_link_,'VOC-LINK'

  ; XXX TODO 2015-12-26 -- rename to `latest-wordlist` after
  ; finishing the new implementation of `wordlist`, based on
  ; eForth.

if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
endif

; ----------------------------------------------
  _constant_header tib_,'TIB'

; doc{
;
; tib  ( -- ca )
;
; Address of the terminal input buffer.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT,
; obsolescent)
;
; }doc

  dw terminal_input_buffer

; ----------------------------------------------
  _c_constant_header slash_tib_,'/TIB'

; doc{
;
; /tib  ( -- n )
;
; Maximum size of the terminal input buffer.
;
; See `tib` and `#tib`.
;
; }doc

  db bytes_per_terminal_input_buffer

; ----------------------------------------------
  _variable_header number_tib_,'#TIB'

; doc{
;
; #tib  ( -- a )
;
; _a_ is the address of a cell containing the number of
; characters in the terminal input buffer.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT,
; obsolescent).
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header input_buffer_,'INPUT-BUFFER'

; doc{
;
; input-buffer  ( -- a )
;
; A double-cell variable that holds the address and length of
; the current input buffer.
;
; }doc

  dw 0 ; length
  dw 0 ; address

; ----------------------------------------------
  _colon_header source_,'SOURCE'

; doc{
;
; source  ( -- ca len )
;
; ----
; : source  ( -- ca len )
;   blk @ ?dup if  block b/buf exit  then
;   input-buffer 2@  ;
; ----
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw blk_,fetch_,question_dup_
  dw zero_branch_,source.other
  ; disk block
  dw block_,b_slash_buf_
  dw exit_
source.other:
  dw input_buffer_,two_fetch_
  dw exit_

; ----------------------------------------------
  _code_header one_plus_,'1+'

  pop hl
  inc hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_plus_,'2+'

              ;  T  B
              ; -- --
  pop hl      ; 10 01
  inc hl      ; 06 01
  inc hl      ; 06 01
  _jp_pushhl  ; 11 01 push hl
              ; 08 02 jp (ix)
              ; 41 06 TOTAL

; ----------------------------------------------
  _alias_header cell_minus_,'CELL-',,two_minus_

; ----------------------------------------------
  _alias_header cell_plus_,'CELL+',,two_plus_

; ----------------------------------------------
  _alias_header char_minus_,'CHAR-',,one_minus_

; ----------------------------------------------
  _alias_header char_plus_,'CHAR+',,one_plus_

; ----------------------------------------------
  _code_header one_minus_,'1-'

  pop hl
  dec hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_minus_,'2-'

  pop hl
  dec hl
  dec hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2*  ( x1 -- x2 )
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; This is the same as `1 lshift`.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.
  ; Documentation partly based on lina.

  pop hl
  add hl,hl
  _jp_pushhl

; ----------------------------------------------
  _alias_header chars_,'CHARS',immediate,noop_

; doc{
;
; chars  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ characters.
;
; In Solo Forth, this word does nothing.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _alias_header cells_,'CELLS',,two_star_

; doc{
;
; cells  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ cells.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _alias_header cell_,'CELL',,two_

; doc{
;
; cell  ( -- n )
;
; _n_ is the size in address units of one cell. This word
; returns 2 in Solo Forth.
;
; Origin: Comus.
;
; }doc

; ----------------------------------------------
  _colon_header here_,'HERE'

; doc{
;
; here  ( -- a )
;
; Return the address of the data-space pointer.
;
; See: `limit`, `unused`, `there`.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw dp_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header allot_,'ALLOT'

; doc{
;
; allot  ( n -- )
;
; If _n_ is greater than zero, reserve _n_ address units of
; data space. If _n_ is less than zero, release _n_ address
; units of data space. If _n_ is zero, leave the data-space
; pointer unchanged.
;
; ----
; : allot  ( n -- )
;   dp +!  ;
; ----
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw dp_,plus_store_
  dw exit_

  ; Alternative non-standard definition:
  ; http://dxforth.netbay.com.au/allot.html

; ----------------------------------------------
  _colon_header s_comma_,'S,'

; doc{
;
; s,  ( ca len -- )
;
; Compile a string.
;
; ----
; : s,  ( ca len -- )
;   dup c, tuck here swap cmove allot  ;
; ----
;
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,c_move_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header two_comma_,'2,'

  dw here_,two_store_
two_comma.allot:
  _literal 2*cell
  dw allot_
  dw exit_

; ----------------------------------------------
  _colon_header comma_,','

  dw here_,store_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _alias_header compile_comma_,'COMPILE,',,comma_

; doc{
;
; compile,  ( xt -- )
;
; }doc

; ----------------------------------------------
  _colon_header c_comma_,'C,'

  dw here_,c_store_
  _literal 1
  dw allot_
  dw exit_

; ----------------------------------------------
  _code_header minus_,'-'

  pop de
  pop hl
  and a
  sbc hl,de
  _jp_pushhl

; ----------------------------------------------
  _code_header not_equals_,'<>'

  pop de
  pop hl
  or a ; CY=0
  sbc hl,de
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header equals_,'='

  pop de
  pop hl
  or a ; CY=0
  sbc hl,de
  jp nz,false_

  ; Execution continues in `-1`, which is `true`:

; ----------------------------------------------
  _code_header minus_one_,'-1'

; doc{
;
; -1  ( -- -1 )
;
; }doc

  ld hl,-1
  _jp_pushhl

; ----------------------------------------------
  _alias_header true_,'TRUE',,minus_one_

; doc{
;
; true  ( -- true )
;
; }doc

; ----------------------------------------------
  _code_header less_than_,'<'

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth

  pop de
  pop hl
less_than.de_hl:

            ;  T  B
            ; -- --
  or a      ; 04 01 ; CY=0
  sbc hl,de ; 15 02 ; n1-n2 in HL, SZVC valid

  ; negative & not OV:  HL<DE
  ; negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ; positive & not OV:  HL>=DE
  ; positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ; thus OV reverses the sense of the sign bit

  jp pe,less_than.reverse  ; if OV, jump
  ; not overflow
  jp p,false_    ; if +ve, result false
  jp true_       ; if -ve, result true

less_than.reverse
  ; overflow
  jp m,false_    ; if -ve, result false
  jp true_       ; if +ve, result true

; ----------------------------------------------
  _code_header u_greater_than_,'U>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U<'

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth.

  pop de
  pop hl
u_less_than.de_hl:
  or a            ; CY=0
  sbc hl,de
  sbc a,a         ; propagate carry flag through A
  ld h,a
  ld l,a          ; HL = $0000 (false) or $FFFF (true)
  _jp_pushhl

; ----------------------------------------------
  _code_header greater_than_,'>'

  pop hl
  pop de
  jp less_than.de_hl

; ----------------------------------------------
  _code_header rot_,'ROT'

  pop de
  pop hl
  ex (sp),hl
  jp push_hlde

; ----------------------------------------------
  _colon_header space_,'SPACE'

  dw b_l_,emit_
  dw exit_

; ----------------------------------------------
  _code_header question_dup_,'?DUP'

  pop hl
  ld a,h
  or l
  jp z,push_hl
  push hl
  _jp_pushhl

; ----------------------------------------------
  _colon_header latest_,'LATEST'

; doc{
;
; latest ( -- nt )
;
; Leave the name token of the last word defined.
;
; Origin: Gforth.
;
; }doc

  dw last_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header current_latest_,'CURRENT-LATEST'

; doc{
;
; current-latest ( -- nt )
;
; Leave the name token of the topmost word in the current
; compilation word list.  This is different from `latest`,
; which returns the name token of the latest word defined in
; the system.
;
; Origin: fig-Forth's `latest`.
;
; ----
; : current-latest  ( -- nt )
;   get-current @  ;
; ----
;
; }doc

  dw get_current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header latestxt_,'LATESTXT'

  ; XXX TODO -- move to the library?
  ; Note: Used by `mode32` in the library.

; doc{
;
; latestxt ( -- xt )
;
; Leave the execution token of the last word defined.
;
; Origin: Gforth.
;
; }doc

  dw lastxt_,fetch_
  dw exit_

; ----------------------------------------------
  _code_header to_name_,'>NAME'

  ; XXX TODO -- move to the library, when the temporary code of
  ; the warning in `header,` is removed

; doc{
;
; >name  ( xt -- nt | 0 )
;
; Try to find the name token _nt_ of the word represented by
; execution token _xt_. Return 0 if it fails.
;
; This word searches all headers, from the oldest one to the
; newest one, for the first one whose _xtp_ (execution token
; pointer) contains _xt_.  This way, when a word has additional
; headers created by `alias` or `synonym`, its original name is
; found first.
;
; Origin: Gforth.
;
; }doc

if 1 ; far_memory

  pop de ; xt
  push bc ; save Forth IP

  ; Save the xt for later:

  ld a,e
  ld (to_name.xt_low_byte),a
  ld a,d
  ld (to_name.xt_high_byte),a

  ; Save the headers pointer for later:

  if 1

                                            ;  T  B
  ld hl,(headers_pointer)                   ; 20 03
  ld a,l                                    ; 04 01
  ld (to_name.headers_pointer_low_byte),a   ; 13 03
  ld a,h                                    ; 04 01
  ld (to_name.headers_pointer_high_byte),a  ; 13 03
                                            ; 54 11 TOTAL

  else

                                            ;  T  B
  ld a,(headers_pointer)                    ; 13 03
  ld (to_name.headers_pointer_low_byte),a   ; 13 03
  ld a,(headers_pointer+1)                  ; 13 03
  ld (to_name.headers_pointer_high_byte),a  ; 13 03
                                            ; 52 12 TOTAL

  endif

  ld b,0 ; init B to use BC later
  ld hl,headers_pointer_bottom ; xtp of the first word defined

to_name.begin:
  ; HL = xtp of the word to check
  ld (to_name.xtp),hl ; preserve it
  ; Compare HL with the headers pointer.
  ; If they are equal, there are no more names to check.
to_name.headers_pointer_high_byte equ $+1
  ld a,0 ; patched high byte of the headers pointer
  cp h ; equals high byte of the xtp?
  jr nz,to_name.check_xt ; jump if not
to_name.headers_pointer_low_byte equ $+1
  ld a,0 ; patched low byte of the headers pointer
  sub l ; equals low byte of the xtp?
  jr nz,to_name.check_xt ; jump if not

  ; The headers pointer has been reached. No words left.
  ; A = 0
  ld h,a
  ld l,a ; HL = 0
  jr to_name.end

to_name.check_xt
  ; Check if the xt pointed by HL is the one searched for
  ; HL = xtp
  call far.hl ; HL = actual address of xtp in far-memory bank
  ld a,(hl) ; low byte of xt
to_name.xt_low_byte equ $+1
  cp 0 ; equal? (patched low byte of the xt)
  jr nz,to_name.next ; not equal
  inc hl ; point  to high byte of xt
  call question_next_bank
  ld a,(hl) ; high byte of xt
to_name.xt_high_byte equ $+1
  cp 0 ; equal? (patched high byte of the xt)
  jr nz,to_name.next ; not equal

  ; The xt has been found.
to_name.xtp equ $+1
  ld hl,0 ; patched xtp
  ld de,2*cell
  add hl,de ; HL = nt

to_name.end:
  ; HL = nt or zero
  call bank.default ; page in the default memory bank
  pop bc ; restore Forth IP
  _jp_pushhl

to_name.next:
  ld hl,(to_name.xtp) ; xtp
  ld de,2*cell
  add hl,de ; nfa
  push hl
  call far.hl ; HL = actual address of nfa in far-memory bank
  ld a,(hl) ; name field byte length
  and word_length_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  pop hl ; nfa
  add hl,bc ; xtp of the next word
  jr to_name.begin

else

  call bank.system ; page in the memory bank

  pop de ; xt
  push bc ; save Forth IP

  ; Save the headers pointer for later:

  if 1

                                            ;  T  B
  ld hl,(headers_pointer)                   ; 20 03
  ld a,l                                    ; 04 01
  ld (to_name.headers_pointer_low_byte),a   ; 13 03
  ld a,h                                    ; 04 01
  ld (to_name.headers_pointer_high_byte),a  ; 13 03
                                            ; 54 11 TOTAL

  else

                                            ;  T  B
  ld a,(headers_pointer)                    ; 13 03
  ld (to_name.headers_pointer_low_byte),a   ; 13 03
  ld a,(headers_pointer+1)                  ; 13 03
  ld (to_name.headers_pointer_high_byte),a  ; 13 03
                                            ; 52 12 TOTAL

  endif

  ld b,0 ; init B to use BC later
  ld hl,headers_pointer_bottom ; xtp of the first word defined

to_name.begin:
  ; HL = xtp of the word to check
  ; Compare HL with the headers pointer.
  ; If they are equal, there are no more names to check.
to_name.headers_pointer_high_byte equ $+1
  ld a,0 ; patched high byte of the headers pointer
  cp h
  jr nz,to_name.check_xt
to_name.headers_pointer_low_byte equ $+1
  ld a,0 ; patched low byte of the headers pointer
  sub l
  jr nz,to_name.check_xt

  ; No words left.
  ; A = 0
  ld h,a
  ld l,a ; HL = 0
  _z80_border_wait 2
  jr to_name.end

to_name.check_xt
  ; Check if the xt pointed by HL is the one searched for
  ; HL = xtp
  ld a,(hl) ; low byte of xt
  inc hl
  cp e ; equal?
  jr nz,to_name.next ; not equal
  ld a,(hl) ; high byte of xt
  cp d ; equal?
  jr nz,to_name.next ; not equal

  ; xt found
  _z80_border_wait 4
  ; HL = xtp+1
  inc hl ; lfa
  inc hl
  inc hl ; nfa

to_name.end:
  ; HL = nt or zero
  call bank.default ; page in the default memory bank
  pop bc ; restore Forth IP
  _jp_pushhl

to_name.next:
  ; HL = xtp+1
  inc hl ; lfa
  inc hl
  inc hl ; nfa
  ld a,(hl) ; name field byte length
  and word_length_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  add hl,bc ; xtp of the next word
  jr to_name.begin

endif

; ----------------------------------------------
if 0 ; XXX OLD

  _colon_header c_store_bank_,'C!BANK'

  ; XXX TODO -- move to the library

; doc{
;
; c!bank  ( c ca n -- )
;
; Store _c_ into address _ca_ ($C000..$FFFF) of bank _n_ (0..7).
;
; }doc

  ; 13 bytes

  dw bank_,c_store_,default_bank_
  dw exit_

else

  _code_header c_store_bank_,'C!BANK'

  ; 10 bytes

  pop de
c_store_bank.e:
  call bank.e
  pop hl
  pop de
  ld (hl),e
  jp default_bank_

endif

; ----------------------------------------------
if 0 ; XXX OLD

  _colon_header store_bank_,'!BANK'

  ; XXX TODO -- move to the library

; doc{
;
; !bank  ( x a n -- )
;
; Store _x_ into address _a_ of bank _n_.
;
; ----
; : !bank  ( x a n -- )
;   bank ! default-bank  ;
; ----
;
; }doc

  ; 11 bytes

  dw bank_,store_,default_bank_
  dw exit_

else

  _code_header store_bank_,'!BANK'

  ; 12 bytes

  pop de
store_bank.e:
  call bank.e
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  jp default_bank_

endif

if 1 ; far_memory
else

; ----------------------------------------------
if 0 ; XXX OLD

  _colon_header c_fetch_bank_,'C@BANK'

; doc{
;
; c@bank  ( ca n -- c )
;
; Fetch _c_ from address _ca_ ($C000..$FFFF) of bank _n_ (0..7).
;
; ----
; : c@bank  ( ca n -- c )
;   bank c@ default-bank  ;
; ----
;
; }doc

  ; 11 bytes

  dw bank_,c_fetch_,default_bank_
  dw exit_

else

  _code_header c_fetch_bank_,'C@BANK'

  ; 10..11 bytes

  pop de
c_fetch_bank.e:
  call bank.e
  pop hl
  ld l,(hl)
  ld h,0
  _jump fetch_bank.end

endif

; ----------------------------------------------
if 0 ; XXX OLD

  _colon_header fetch_bank_,'@BANK'

; doc{
;
; @bank  ( a n -- x )
;
; Fetch _x_ from address _a_ ($C000..$FFFF) of bank _n_ (0..7).
;
; ----
; : @bank  ( a n -- x )
;   bank @ default-bank  ;
; ----
;
; }doc

  ; 11 bytes

  dw bank_,fetch_,default_bank_
  dw exit_

else

  _code_header fetch_bank_,'@BANK'

  ; 10 bytes

  pop de
fetch_bank.e:
  call bank.e
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
fetch_bank.end:
  push hl

  ; Execution continues in `default-bank`:

endif

endif

; ----------------------------------------------
  _code_header default_bank_,'DEFAULT-BANK'

; doc{
;
; default-bank  ( -- )
;
; Page in the default memory bank at $C000..$FFFF.
;
; }doc

if size_optimization

                    ;  T  B
  push ix           ; 15 02 ; make next `ret` jump to `next`
  jr bank.default   ; 12 02
                    ; 27 04 TOTAL

else

                    ;  T  B
  call bank.default ; 17 03
  _jp_next          ; 08 02
                    ; 25 05 TOTAL

endif

if 1 ; far_memory
else

; ----------------------------------------------
  _colon_header c_fetch_s_,'C@S'

  ; XXX TODO -- move to the library?
  ; Used only by an alternative version of `lex?`

; doc{
;
; c@s  ( a -- x )
;
; Fetch from the _a_ address of the system bank.
;
; }doc

  ; XXX 11 bytes:
  _literal system_bank
  dw c_fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,system_bank
  ; jp c_fetch_bank.e

; ----------------------------------------------
  _colon_header fetch_s_,'@S'

; doc{
;
; @s  ( a -- x )
;
; Fetch from the _a_ address of the system bank.
;
; }doc

  ; XXX 11 bytes:
  _literal system_bank
  dw fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,system_bank
  ; jp fetch_bank.e

endif

; ----------------------------------------------
if 1 ; far_memory

if 0 ; XXX OLD

  _colon_header far_c_fetch_,'FARC@'

; doc{
;
; farc@ ( ca -- c )
;
; Fetch _c_ from far-memory address _ca_.
;
; See: `far-banks`.
;
; ----
; : farc@  ( ca -- c )
;   far c@ default-bank  ;
; ----
;
; }doc


  ; 11 bytes

  dw far_,c_fetch_,default_bank_
  dw exit_

else

  _code_header far_c_fetch_,'FARC@'

; doc{
;
; farc@ ( ca -- c )
;
; Fetch _c_ from far-memory address _ca_.
;
; See: `far-banks`.
;
; }doc

  ; 13 bytes

  pop hl
  call far.hl
  ld l,(hl)
  ld h,0
  push hl
  call bank.default
  _jp_next

  ; XXX TODO -- smaller alternative for `size_optimization`,
  ; jumping to `push_a`

endif

; ----------------------------------------------
  _code_header far_c_store_,'FARC!'

; doc{
;
; farc! ( c ca -- )
;
; Store _c_ into far-memory address _ca_.
;
; See: `far-banks`.
;
; }doc

  pop hl
  call far.hl
  pop de
  ld (hl),e
  call bank.default
  _jp_next

; ----------------------------------------------
  _code_header far_fetch_,'FAR@'

; doc{
;
; far@ ( a -- x )
;
; Fetch _x_ from far-memory address _a_.
;
; See: `far-banks`.
;
; This word is written in Z80, but its equivalent Forth code
; is the following:
;
; ----
; : far@  ( a -- x )
;   dup 1+ far c@ >r farc@ r> join  ;
; ----
;
; Faster but larger version:
;
; ----
; : far@  ( a -- x )
;   dup 1+ far c@ >r far c@ r> join default-bank  ;
; ----
;
; }doc

  exx
  pop hl
  call far.hl
  ld c,(hl)
  inc hl
  call question_next_bank
  ld b,(hl)
  push bc
  call bank.default
  exx
  _jp_next

; ----------------------------------------------
  _code_header far_store_,'FAR!'

; doc{
;
; far!  ( x a -- )
;
; Store _x_ into far-memory address _a_.
;
; See: `far-banks`.
;
; This word is written in Z80, but its equivalent Forth code
; is the following:
;
; ----
; : far!  ( x a -- )
;   >r split r@ 1+ far c! r> farc!  ;
; ----
;
; Faster but larger version:
;
; ----
; : far!  ( x a -- )
;   >r split r@ 1+ far c! r> far c! default-bank  ;
; ----
;
; }doc

  exx
  pop hl
  call far.hl
  pop bc
  ld (hl),c
  inc hl
  call question_next_bank
  ld (hl),b
  call bank.default
  exx
  _jp_next

endif ; far_memory

; ----------------------------------------------
  _colon_header from_name_,'NAME>'

if 1 ; far_memory

; doc{
;
; name>  ( nt -- xt )
;
; ----
; : name>  ( nt -- xt )
;   [ 2 cells ] literal - far@  ;
; ----
;
; }doc

  _literal 2*cell
  dw minus_,far_fetch_
  dw exit_

else

; doc{
;
; name>  ( nt -- xt )
;
; ----
; : name>  ( nt -- xt )
;   [ 2 cells ] literal - @s  ;
; ----
;
; }doc

  _literal 2*cell
  dw minus_,fetch_s_
  dw exit_

endif

; ----------------------------------------------
  _colon_header name_to_string_,'NAME>STRING'

  ; XXX TODO -- move to the library, with `.name`

if 1 ; far_memory

; doc{
;
; name>string  ( nt -- ca len )
;
; Convert the name token _nt_ to its name string _ca len_.
;
; ----
; : name>string  ( nt -- ca len )
;   farcount word-length-mask and dup allocate-string  ( ca1 len ca )
;   2dup swap 2>r ( R: ca len )  -rot ( ca ca1 len )
;   0 ?do  ( ca ca1 )
;     2dup farc@ swap i + c! char+
;   loop  2drop default-bank 2r>  ;
; ----
;
; }doc

  dw far_count_
  _literal word_length_mask
  dw and_  ; ( ca1 len )
  dw dup_,allocate_string_ ; ( ca1 len ca )
  dw two_dup_,swap_,two_to_r_ ;  ( R: ca len )
  dw minus_rot_ ; ( ca ca1 len )
  _literal 0
  dw paren_question_do_,name_to_string.loop_exit ; ( ca ca1 )
  dw two_dup_,far_c_fetch_,swap_,i_,plus_,c_store_,char_plus_
  dw paren_loop_
name_to_string.loop_exit:
  dw two_drop_,two_from_r_
  dw exit_

else

; doc{
;
; name>string  ( nt -- ca len )
;
; Convert the name token _nt_ to its name string _ca len_.
;
; ----
; : name>string  ( nt -- ca len )
;   system-bank count word-length-mask and
;   save-string default-bank  ;
; ----
;
; }doc

  dw system_bank_
  dw count_
  _literal word_length_mask
  dw and_
  dw save_string_
  dw default_bank_
  dw exit_

endif

; ----------------------------------------------
  _colon_header store_csp_,'!CSP'

; doc{
;
; !csp  ( -- )
;
; Save the the current data stack position.
;
; Origin: fig-Forth.
;
; ----
; : !csp  ( -- )
;   sp@ csp !  ;
; ----
;
; }doc

  dw sp_fetch_,csp_,store_
  dw exit_

; ----------------------------------------------
  _colon_header question_throw_,'?THROW'

; doc{
;
; ?throw  ( f n -- )
;
; Perform a `throw` of value _n_ if the boolean flag _f_ is
; non-zero.
;
; ----
; : ?throw  ( f n -- )
;   swap if  throw  else  drop  then  ;
; ----
;
; }doc

  dw swap_
  dw question_branch_,throw_pfa
  dw drop_
  dw exit_

; XXX TODO -- benchmark, compare to `swap 0<> and throw`
; XXX TODO -- benchmark, compare to `and throw`

; ----------------------------------------------
  _colon_header compiling_question_,'COMPILING?'

; doc{
;
; compiling?  ( -- f )
;
; ----
; : compiling?  ( -- f )
;   state @ 0<>  ;
; ----
;
; }doc

  dw state_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header executing_question_,'EXECUTING?'

; doc{
;
; executing?  ( -- f )
;
; ----
; : executing?  ( -- f )
;   state @ 0=  ;
; ----
;
; }doc

  dw state_,fetch_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header question_csp_,'?CSP'

; doc{
;
; ?csp  ( -- )
;
; Issue error "definition unbalanced" if the current data stack
; position does not match the value saved by `!csp`.
;
; // XXX TODO and `checking` is not zero.
;
; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,fetch_,not_equals_
  ; dw checking(s)_,fetch_,and_ ; XXX TODO ?
  _question_throw error.definition_not_finished
  dw exit_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADING'

  dw loading_question_,zero_equals_
  _question_throw error.loading_only
  dw exit_

; ----------------------------------------------
  _colon_header loading_question_,'LOADING?'

  dw blk_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header compile_,'COMPILE',compile_only

; doc{
;
; compile  ( -- )
;
; : compile  ( -- )
;   ?compiling  r> dup cell+ >r  @ compile,  ;
;
; }doc

  dw from_r_,dup_,cell_plus_,to_r_,fetch_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header postpone_,'POSTPONE',immediate

; doc{
;
; postpone ( "name" -- )
;
; Skip leading space delimiters. Parse name delimited by a
; space. Find name. Append the compilation semantics of _name_ to
; the current definition.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw defined_ ; ( nt | 0 )
  dw dup_,question_defined_ ; error if not found
  ; ( nt )
  dw name_to_immediate_question_ ; ( xt f )
  dw question_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw compile_comma_ ; compile xt
  dw exit_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

  dw state_,off_
  dw exit_

; ----------------------------------------------
  _colon_header right_bracket_,']'

  dw state_,on_
  dw exit_

; ----------------------------------------------
  _colon_header revealed_,'REVEALED'

; doc{
;
; revealed  ( nt -- )
;
; Reveal the definition _nt_ by resetting its smudge bit.
;
; }doc

if 1 ; far_memory

  dw smudge_mask_,swap_
  dw far_,c_store_reset_bits_,default_bank_
  dw exit_

else

  dw smudge_mask_,swap_
  dw system_bank_,c_store_reset_bits_,default_bank_
  dw exit_

endif

; ----------------------------------------------
  _colon_header reveal_,'REVEAL'

; doc{
;
; reveal  ( -- )
;
; Reveal the latest definition by resetting its smudge bit.
;
; }doc

  dw latest_,revealed_
  dw exit_

; XXX TODO -- Improve after Gforth:
;
; : reveal
;   last?
;   IF     dup @ 1 and
;          IF     dup @ 1 xor 2dup >r name>string r> check-shadow dup 0 + @ 4 +
;                 perform
;          ELSE   drop
;          THEN
;   THEN ;
;
; : last?
;   latest ?dup ;

; ----------------------------------------------
  _colon_header hidden_,'HIDDEN'

; doc{
;
; hidden  ( nt -- )
;
; Hide the definition _nt_ by setting its smudge bit.
;
; }doc

  dw smudge_mask_,swap_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header hide_,'HIDE'

; doc{
;
; hide  ( -- )
;
; Hide the latest definition by setting its smudge bit.
;
; }doc

  dw latest_,hidden_
  dw exit_

; ----------------------------------------------
  _c_constant_header word_length_mask_,'WORD-LENGTH-MASK'

; doc{
;
; word-length-mask  ( -- b )
;
; Constant that holds the bitmask of the word length.
;
; }doc

  db word_length_mask

; ----------------------------------------------
  _c_constant_header smudge_mask_,'SMUDGE-MASK'

; doc{
;
; smudge-mask  ( -- b )
;
; Constant that holds the bitmask of the smudge bit.
;
; }doc

  db smudge_mask

; ----------------------------------------------
  _colon_header hex_,'HEX'

; doc{
;
; hex  ( -- )
;
; Set contents of `base` to sixteen.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words), Forth-94 (CORE EXT), Forth-2012
; (CORE EXT).
;
; }doc

  _literal $10
  dw branch_,base_store

; ----------------------------------------------
  _colon_header decimal_,'DECIMAL'

; doc{
;
; decimal  ( -- )
;
; Set contents of `base` to ten.
;
; Origin: fig-Forth, Forth-79 (Required Word Set), Forth-83
; (Required Word Set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  _literal $0A
base_store:
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE)'

; doc{
;
; (;code)  ( -- )
;
; Rewrite the code field of the most recently defined word to
; point to the following machine code sequence.  This word is
; the run-time procedure compiled by `;code`.

; ----
; : (;code)  ( -- ) ( R: a -- )
;   r> latest name> 1+ !  ;
; ----

; }doc

  dw from_r_
  dw latest_,from_name_,one_plus_
  dw store_
  dw exit_

; ----------------------------------------------
  _colon_header does_,'DOES>',immediate+compile_only

do_does equ do_colon

  dw compile_,paren_semicolon_code_
  _literal $CD ; Z80 opcode for "call"
  dw c_comma_ ; compile it
  dw lit_,do_does,comma_ ; compile the routine address
  dw exit_

; ----------------------------------------------
if 1 ; far_memory

  _code_header far_count_,'FARCOUNT'

; doc{
;
; farcount  ( ca1 -- ca2 len2 )
;
; A variant of `count` that works with far-memory addresses.
;
; See: `far-banks`, `count`.
;
; }doc

  pop hl
  inc hl
  push hl
  dec hl
  call far.hl
  ld d,0
  ld e,(hl)
  push de
  call bank.default
  _jp_next

endif

; ----------------------------------------------
  _code_header count_,'COUNT'

; doc{
;
; count  ( ca1 -- ca2 len2 )
;
; Return the character string specification for the counted
; string stored at _ca1_. _ca2_ is the address of the first
; character after _ca1_. _len_ is the  contents of the character
; at _c1_, which is the  length in characters of the string at
; _c2_.
;
; Origin: fig-Forth, Forth-79 (REQUIRED WORD SET), Forth-83
; (REQUIRED WORD SET), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
push_ahl:
  push hl
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUNDS'

  dw over_,plus_,swap_
  dw exit_

; ----------------------------------------------
if 1 ; far_memory

  _colon_header far_type_,'FARTYPE'

; XXX TODO -- move to the library

; doc{
;
; fartype  ( ca len -- )
;
; If _len_ is greater than zero, display the character string
; _ca len_, which is stored in the far memory.
;
; See: `far-banks`, `type`.
;
; }doc

  dw bounds_
  dw paren_question_do_,far_type.loop_exit ; ?do
  dw i_,far_c_fetch_,emit_
  dw paren_loop_ ; loop
far_type.loop_exit
  dw exit_

endif

; ----------------------------------------------
  _colon_header type_,'TYPE'

; doc{
;
; type  ( ca len -- )
;
; If _len_ is greater than zero, display the character string
; _ca len_.
;
;----
; : type  ( ca len -- )
;   bounds ?do  i c@ emit  loop  drop  ;
;----

; }doc

  dw bounds_
  dw paren_question_do_,type.loop_exit ; ?do
  dw i_,c_fetch_,emit_
  dw paren_loop_ ; loop
type.loop_exit
  dw exit_

; ----------------------------------------------

  _code_header minus_trailing_,'-TRAILING'

; doc{
;
; -trailing  ( ca1 len1 -- ca1 len2 )
;
; Adjust the length of a string to suppress the trailing blanks.
;
; If _len_ is greater  than zero, _len2_ is  equal to _len1_
; less the number of spaces  at the end of  the character string
; specified by _ca1 len1_. If _len1_ is zero or the entire
; string consists of spaces, _len2_ is zero.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
  ; DE = address after the string
  ; HL = length of the string
minus_trailing.begin:
  ld a,l
  or h ; exhausted?
  jp z,push_hl
  dec de ; next char
  ld a,(de)
  cp ' ' ; space?
  jp nz,push_hl
  dec hl ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header minus_leading_,'-LEADING'

; doc{
;
; -leading  ( ca len -- ca' len' )
;
; Adjust the start and length of a string to suppress the
; leading blanks.
;
; }doc

  dw b_l_,skip_
  dw exit_

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(.")'

; doc{
;
; (.")  ( -- )
;
; Type the compiled string that follows.
;
; ----
; : (.")  ( -- )
;   r@ count dup char+ r> + >r type  ;
; ----
;
; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,char_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_

  ; XXX TODO --
  ;   `r@ count dup char+ r> + >r` is what `slit` does, but
  ;   calling `slit` here can not work.
  ;   see `string-param` in the library for a possible factor

  dw exit_

; ----------------------------------------------
  _colon_header comma_quote_,',"'

; doc{
;
; ,"  ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote and compile the
; string.
;
; ----
; : ,"  ( -- )
;   '"' parse s,  ;
; ----
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  _literal '"'
  dw parse_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate+compile_only

; doc{
;
; ."
;
; Compilation: ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote. Append the run-time
; semantics given below to the current definition.
;
;       Run-time: ( -- )
;
; Display "ccc".
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : ."  ( "ccc<quote> -- )
;   compile (.") ,"  ;  immediate
; ----
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  dw compile_,paren_dot_quote_,comma_quote_
  dw exit_

; ----------------------------------------------
  _variable_header span_,'SPAN'

  ; XXX TODO -- move to the library

; doc{
;
; span  ( -- a )
;
; The address of a variable containing the count of characters
; actually received and stored by the last execution of
; `expect`.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT).
;
; }doc

  dw 0

; ----------------------------------------------
  _defer_header to_history_,'>HISTORY',,two_drop_

; XXX TODO -- not used yet

; doc{
;
; >history  ( -- ca len )
;
; A deferred word. When command line history is activated,
; store string _ca len_ into it, else drop it.
;
; }doc

; ----------------------------------------------
  _defer_header accept_,'ACCEPT',,simple_accept_

; doc{
;
; accept  ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when an implementation-defined line
; terminator is received. When input terminates, nothing is
; appended to the string or displayed on the screen.
;
; _len2_ is the length of the string stored at _ca1_.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; In Solo Forth `accept` is a deferred word. Its default
; behaviour is `simple-accept`, which provides only the basic
; editing options. Alternative definitions are provided in the
; library.
;
; }doc

; ----------------------------------------------
  _colon_header simple_accept_,'SIMPLE-ACCEPT'

; Credit:
;
; Code adapted from eForth.

; doc{
;
; simple-accept  ( ca1 len1 -- len2 )
;
; Default behaviour of the deferred word `accept`:
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when the Return key is pressed.  When input
; terminates, nothing is appended to the string or displayed on
; the screen.
;
; The only control key accepted is Delete.
;
; _len2_ is the length of the string stored at _ca1_.

; ----
; : simple-accept  ( ca len -- len' )
;   over + over  ( bot eot cur )
;   begin  xkey dup 13 <> \ not carriage return?
;   while  ( bot eot cur c )
;     dup 12 =  \ delete?
;     if    drop  >r over r@ < dup  \ any chars?
;           if  8 dup emit  bl emit  emit  then  r> +
;     else  \ maybe printable
;           >r  2dup <>  \ more?
;           r@ [ bl 1- ] literal > and  \ and printable?
;           if  r@ over c!  char+  r@ emit  then  r> drop
;     then
;   repeat  ( bot eot cur c )  drop nip swap -  ;
; ----
;
; }doc

  dw over_,plus_,over_
simple_accept.begin                                    ; begin
  dw xkey_,dup_
  _literal carriage_return_char
  dw not_equals_
  dw zero_branch_,simple_accept.end                    ; while
  dw dup_
  _literal delete_char
  dw equals_                                           ; delete?
  dw zero_branch_,simple_accept.printable              ; if
  dw drop_,to_r_,over_,r_fetch_,less_than_,dup_        ; any chars?
  dw zero_branch_,simple_accept.delete_end             ; if
  _literal backspace_char
  dw dup_,emit_,b_l_,emit_,emit_
simple_accept.delete_end                               ; then
  dw from_r_,plus_
  dw branch_,simple_accept.repeat
simple_accept.printable                                ; else
  ; printable
  dw to_r_,two_dup_,not_equals_                        ; more?
  dw r_fetch_
  _literal space_char-1
  dw greater_than_,and_                                ; and printable?
  dw zero_branch_,simple_accept.printable_end          ; if
  dw r_fetch_,over_,c_store_,char_plus_,r_fetch_,emit_
simple_accept.printable_end                            ; then
  dw from_r_,drop_
simple_accept.repeat
  dw branch_,simple_accept.begin                       ; repeat
simple_accept.end
  ; ( bot eot cur c )
  dw drop_,nip_,swap_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header query_,'QUERY'

; doc{
;
; query  ( -- )
;
; Make the user input device the input source. Receive input
; into the terminal input buffer, replacing any previous
; contents. Make the result, whose address is returned by `tib`,
; the input buffer. Set `>in` to zero.
;
; Origin: Forth-94 (CORE EXT, obsolescent).
;
; }doc

; XXX OLD -- old descriptions:
;
; Input 80 characters of text (or until a "return") from the
; operators terminal. Text is positioned at the address
; contained in TIB with IN set to zero.
;
; Transfer characters from the terminal to address returned by
; `tib`, until a "return" or the count contained in the `#tib`
; variable have been received. One or more nulls are added at
; the end of the text.
;
  ; XXX TODO move to the library, when possible

  dw tib_,slash_tib_
  dw two_dup_,blank_ ; clean the input buffer
  dw accept_,number_tib_,store_,space_
  dw terminal_to_source_
  dw exit_

; ----------------------------------------------
  _constant_header paren_source_id_,'(SOURCE-ID)'

  dw source_id_pfa

; doc{
;
; (source-id)  ( -- a )
;
; A variable that contains the value returned by `source-id`.
;
; }doc

; ----------------------------------------------
  _constant_header source_id_,'SOURCE-ID'

; doc{
;
; source-id  ( -- 0 | -1 )
;
; Identifies the input source as follows:
;
; |===
; |  0 | User input device
; | -1 | String via `evaluate`
; |===
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw 0

; ----------------------------------------------
  _constant_header blocks_,'BLOCKS'

  ; XXX FIXME -- also defined as `blk/disk`
  ; XXX TODO -- move to the library?

; doc{
;
; blocks  ( -- u )
;
; A constant. Number of blocks per disk.
;
; }doc

  dw blocks_per_disk

; ----------------------------------------------
  _colon_header block_question_,'BLOCK?'


; doc{
;
; block?  ( u -- f )
;
; Is _u_ a valid block number?
;
; }doc

  dw blocks_,u_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header refill_,'REFILL'

; doc{
;
; refill  ( -- f )
;
; ----
; : refill ( -- f )
;   loading? if  blk @ 1+ dup block>source block? exit  then
;   false source-id ?exit 0= query  ;
; ----
;
; Origin: Forth-94 (CORE EXT, BLOCK EXT); Forth-2012 (CORE EXT,
; BLOCK EXT).
;
; }doc

  ; XXX INFORMER {{{
  ; dw paren_dot_quote_
  ; _string "REFILL "
  ; XXX INFORMER }}}

  dw loading_question_ ; input source is a block?
  dw zero_branch_,refill.not_loading ; if not, branch

refill.block:
  dw blk_,fetch_,one_plus_,dup_,block_to_source_
  dw block_question_
  dw exit_

refill.not_loading
  dw false_,source_id_,question_exit_
  dw zero_equals_,query_
  dw exit_

; ----------------------------------------------
  _code_header fill_,'FILL'

; doc{
;
; fill  ( ca len b -- )
;
; If _u_ is not zero, store _b_ in each of _u_
; consecutive characters of memory beginning at _a_.
;
; Origin: fig-Forth, Forth-83 (Required Word Set), Forth-94
; (CORE), Forth-2012 (CORE).
;
; }doc

  exx                 ; save the Forth IP
  pop bc
  ld a,c              ; A = character
fill.a:
  pop bc              ; BC = count
  pop de              ; DE = address

  ld hl,$FFFF
  or a                ; clear carry flag
  adc hl,bc           ; test for count=0 or 1
  jr nc,fill.done     ; no CY: count=0, skip
  ld (de),a           ; fill first byte
  jr z,fill.done      ; z: count=1, done
  dec bc              ; else adjust count
  ld h,d
  ld l,e              ; HL = start address
  inc de              ; DE = start address+1
  ldir                ; copy (HL)->(DE)
fill.done:
  exx                 ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header erase_,'ERASE'

; doc{
;
; erase  ( ca len -- )
;
; If _len_ is greater than zero, clear all bits in each ol _len_
; consecutive address units of memory beginning at _ca_.
;
; Origin: fig-Forth, Forth-83 (Controlled Reference Words), Forth-94
; (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  exx
  xor a
  jp fill.a

; ----------------------------------------------
  _code_header blank_,'BLANK'

; doc{
;
; blank  ( ca len -- )
;
; If _len_ is greater than zero, store the character value for
; space in _len_ consecutive character positions of memory
; beginning at _ca_.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  exx
  ld a,space_char
  jp fill.a

; ----------------------------------------------
  _colon_header hold_,'HOLD'

; doc{
;
; hold  ( c -- )
;
; Insert char _c_ into a pictured numeric output string.
; Typically used between `<#` and `#>`.
;
; ----
; : hold  ( c -- )
;   -1 hld +!  hld @ c!  ;
; ----
;
; }doc

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw exit_

; ----------------------------------------------
  _variable_header slash_hold_,'/HOLD'

; XXX TODO -- not used yet

; doc{
;
; /hold  ( -- a )
;
; Variable that holds the length of the pictured output string
; buffer, which is located right below `pad`.
;
; }doc

  dw 68

; ----------------------------------------------
  _colon_header pad_,'PAD'

; doc{
;
; pad  ( -- ca )
;
; Return the address of a transient region that can be used to
; hold data for intermediate processing.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT),
; Forth-2012 (CORE EXT).
;
; : pad  ( -- ca )
;   here /hold @ +  ;
;
; }doc

  dw here_,slash_hold_,fetch_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header stream_,'STREAM'

; doc{
;
; stream  ( -- ca len )
;
; Return the address and length of the remaining stream source.
;
; }doc

  dw source_,to_in_,fetch_,slash_string_
  dw exit_

; ----------------------------------------------
  _code_header slash_string_,'/STRING'

; doc{
;
; /string  ( ca1 len1 n -- ca2 len2 )
;
; Adjust the character string at _ca1 len1_ by _n_ characters.
; The resulting character string _ca2 len2_ begins at _ca1_ plus
; _n_ characters and is _len1_ minus _n_ characters long.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   rot over + -rot -  ;
; ----
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   dup >r - swap r> + swap  ;
; ----
;
; }doc

  pop de                  ; n
  pop hl                  ; len1
  and a                   ; CY=0
  sbc hl,de               ; HL=len2
  ex (sp),hl              ; (SP)=len2 HL=ca1
  add hl,de               ; HL=ca2
  ex (sp),hl              ; (SP)=ca2 HL=len2
  _jp_pushhl

; ----------------------------------------------
  _colon_header parsed_,'PARSED'

; doc{
;
; parsed  ( len -- )
;
; Add the given _len_ to `>in`.
;
; ----
; : parsed  ( len -- )
;   >in +!  ;
; ----
;
; }doc

  dw to_in_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_,'PARSE'

; doc{
;
; parse  ( c "ccc<char>" -- ca len )
;
; Parse _ccc_ delimited by the delimiter _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
;
; If the parse area was empty, the resulting string has a zero length.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; ----
; : parse  ( c "ccc<char>" -- ca len )
;   stream 2dup 2>r rot scan
;   dup if  char-  then
;   2r> rot - parsed
;   tuck -  ;
; ----
;
; }doc

  dw stream_,two_dup_,two_to_r_,rot_,scan_
  dw dup_,zero_branch_,parse.end
  dw char_minus_
parse.end:
  dw two_from_r_,rot_,minus_
  dw parsed_
  dw tuck_,minus_
  dw exit_

; ----------------------------------------------
  _two_variable_header parsed_name_,'PARSED-NAME'

; doc{
;
; parsed-name  ( -- a )
;
; A double variable that holds the address and length of the
; most recently name parsed by `parse-name`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _defer_header header_,'HEADER',,input_stream_header_

; doc{
;
; header  ( "name" | -- )
;
; A deferred word that creates a dictionary header.  Its default
; behaviour is `stream-name-header`, and it's set by
; `default-header`. Its alternative temporary behaviour is
; `nextname-header`.
;
; }doc

; ----------------------------------------------
  _colon_header question_name_too_short_,'?NAME-TOO-SHORT'

; doc{
;
; ?name-too-short ( ca len -- )
;
; }doc

  dw dup_,zero_equals_
  _question_throw -16 ; attempt to use zero-length string as a name
  dw exit_

; ----------------------------------------------
  _colon_header input_stream_header_,'INPUT-STREAM-HEADER'

; doc{
;
; input-stream-header  ( "name" -- )

; Create a dictionary header "name".
;
; ----
; : input-stream-header  ( "name" -- )
;   parse-name ?name-too-short header,  ;
; ----
;
; }doc

  dw parse_name_,question_name_too_short_,header_comma_
  dw exit_

; ----------------------------------------------
  _colon_header default_header_,'DEFAULT-HEADER'

; doc{
;
; default-header  ( -- )

; Set `header` to its default behaviour: `input-stream-header`.

; ----
; : default-header  ( -- )
;   ['] input-stream-header ['] header defer!  ;
; ----
;
; }doc

  _literal input_stream_header_
  _literal header_
  dw defer_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_name_,'PARSE-NAME'

; doc{

; parse-name  ( "name"  -- ca len )
;
; ----
; : parse-name  ( "name"  -- ca len )
;   stream                 ( ca0 len0 )
;   dup >r   -leading      ( ca1 len1 ) ( R: len0 )
;   over >r  bl scan       ( ca2 len2 ) ( R: len0 ca1 )
;   dup if  char-  then    \ skip trailing delimiter
;   r> r> rot -  parsed    \ update `>in`
;   tuck -                 ( ca len )
;   2dup parsed-name 2!  ;
; ----
;
; }doc

  dw stream_              ; ( ca len )
  dw dup_,to_r_           ; ( ca len ) ( R: len )
  dw minus_leading_           ; ( ca1 len1 ) ( R: len )
  dw over_,to_r_          ; ( ca1 len1 ) ( R: len ca1 )
  dw b_l_,scan_           ; ( ca2 len2 ) ( R: len ca1 )
  dw dup_
  dw zero_branch_,parse_name.skip
  dw char_minus_
parse_name.skip:
  dw from_r_,from_r_      ; ( ca2 len2 ca1 len )
  dw rot_,minus_          ; ( ca2 ca1 len3 )
  dw parsed_              ; ( ca2 ca1 )
  dw tuck_,minus_         ; ( ca1 len4 )
  dw two_dup_,parsed_name_,two_store_
  dw exit_

; ----------------------------------------------
  _code_header upper_,'UPPER'

; doc{
;
; upper  ( c -- c' )
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl
  ld a,l
  ld hl,push_a ; exit address
  push hl      ; make next `ret` jump to push_a

ascii_upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  and %11011111
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPERS'

; doc{
;
; uppers  ( ca len -- )
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call ascii_upper.a
  ld (hl),a
  inc hl
  dec de
  _jump uppers.do

; ----------------------------------------------
if 1 ; far_memory

  _code_header far_uppers_,'FARUPPERS'

; XXX TMP --
; XXX TODO -- improve to save push/pop

; doc{
;
; faruppers  ( ca len -- )
;
; A variant of `uppers` that works in far memory.
;
; See: `far-banks`, `uppers`.
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl          ; len
  ex (sp),hl      ; HL = ca
  call far.hl     ; HL = actual address; bank paged in
  pop de          ; len
far_uppers.do:
  ld a,d
  or e
  jr z,far_uppers.end
  ld a,(hl)
  call ascii_upper.a
  ld (hl),a
  inc hl
  push de
  call question_next_bank
  pop de
  dec de
  _jump far_uppers.do
far_uppers.end:
  call bank.default
  _jp_next

endif

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; doc{
;
; undefined?  ( ca len -- f )
;
; }doc

  ; XXX TODO -- this may be moved to the library, but it's
  ; needed by `needed`.

  dw find_name_,zero_equals_
  dw exit_

; ----------------------------------------------
  _code_header place_,'PLACE'

; doc{
;
; place  ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ as a counted string at _ca2_.  The
; source and destination strings are permitted to overlap.
;
; An ambiguous condition exists if _len1_ is greater than 255 or
; the buffer at _ca2_ is less than _len1_+1 characters.
;
; This word is written in Z80, but the equivalent Forth code is
; the following:
;
; ----
; : place  ( ca1 len1 ca2 -- )
;   2dup c! char+ smove  ;
; ----
;
; }doc

  ; Credit:
  ; Code from DZX-Forth's `packed`.

  exx         ; save Forth IP
  pop de      ; DE=ca2
  pop bc      ; C=len1
  pop hl      ; HL=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; E=len1
  ld (hl),e
  exx         ; restore Forth IP
  _jp_next

; ----------------------------------------------
if 1 ; far_memory

  _code_header far_place_,'FARPLACE'

; doc{
;
; farplace  ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ (which must be below memory
; address $C000) as a counted string at far-memory address
; _ca2_.
;
; See: `far-banks`, `place`.
;
; }doc

  exx             ; save Forth IP
  pop hl          ; HL=ca2
  call far.hl     ; HL=ca2' (actual address in far memory)
  pop bc          ; C=len1
  pop de          ; DE=ca1
  ld (hl),c       ; set length of the destination string
far_place.copy_char:
  inc hl
  push de
  call question_next_bank
  pop de
  ld a,(de)
  ld (hl),a
  inc de
  djnz far_place.copy_char ; jump if length is not exhausted
  call bank.default
  exx         ; restore Forth IP
  _jp_next

endif

; ----------------------------------------------
  _variable_header error_number_,'ERROR#'

  ; XXX TODO -- useful? remove? user variable?

; doc{
;
; error# ( -- a )
;
; Variable that holds the number of the last error issued by
; `error`.
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-POS'

; doc{
;
; error-pos ( -- a )
;
; Double variable that holds the position of the last error
; issued by `error`:

; - high part = value of `blk`
; - low part = value of `>in`

; }doc

  dw 0 ; value of `blk`
  dw 0 ; value of `>in`

; ----------------------------------------------
  _colon_header dot_error_word_,'.ERROR-WORD'

  dw parsed_name_,two_fetch_,cr_,type_ ; last parsed word
  dw paren_dot_quote_
  _string ' ? '
  dw exit_

; ----------------------------------------------
  _colon_header error_,'ERROR'

; doc{
;
; error  ( n -- )
;
; Save the error number _n_ into `error-number`, and the current
; block and line into `error-pos`, to be used by `where`.  Issue
; error _n_ and restart the system.
;
; ----
; : error  ( n -- )
;   dup error-number !
;   >in @ blk @ error-pos 2!
;   dup -1 = if  (abort)  then
;   dup -2 = if  space abort-message 2@ type (abort)  then
;   .error-word .throw  (abort)  ;
; ----
;
; }doc

  dw dup_,error_number_,store_ ; save the error number
  dw to_in_,fetch_,blk_,fetch_,error_pos_,two_store_

  dw dup_
  _literal -1
  dw equals_
  dw question_branch_,paren_abort_pfa
  ; No return from `(abort)`.

  dw dup_
  _literal -2
  dw equals_
  dw zero_branch_,error.message
  dw space_,abort_message_,two_fetch_,type_,paren_abort_
  ; No return from `(abort)`.

error.message:
  dw dot_error_word_,dot_throw_,paren_abort_
  ; No return from `(abort)`.

; ----------------------------------------------
  _two_variable_header abort_message_,"ABORT-MESSAGE"

  dw 0,0

; ----------------------------------------------
  _colon_header dot_name_,'.NAME'

  ; XXX TODO -- move to the library, with `warnings`
  ; and the check done in `header,`.

  dw name_to_string_,type_,space_
  dw exit_

; ----------------------------------------------
  _defer_header warn_,'WARN',,noop_

; ----------------------------------------------
  _colon_header header_comma_,'HEADER,'

; doc{
;
; header,  ( ca len -- )
;
; Create a dictionary header with the name _ca len_.
;
; }doc

  ; XXX TODO -- complete the description, for DTC.

  dw dup_,zero_equals_
  _question_throw error.zero_length_name

if 1 ; developing

  ; XXX TMP -- during the development

  dw warnings_,fetch_
  dw zero_branch_,header_comma.continue

  ; `warnings` is on
  dw two_dup_,get_current_,search_wordlist_
  dw zero_branch_,header_comma.continue
  ; the word is not unique in `current`
  ; ( ca len xt )
  dw paren_dot_quote_
  _string "redefined "
  dw to_name_,dot_name_

  ; XXX INFORMER:
  ; dw paren_dot_quote_
  ; _string "latest "
  ; dw latest_,dot_name_

else ; XXX NEW

  dw warn_

endif

header_comma.continue:

  ; ( ca len )

if 1 ; far_memory

  dw here_,lastxt_,store_ ; update `lastxt`
  dw width_,fetch_,min_
  dw tuck_ ; ( len ca len )
if debugging
  _echo "HP = xtp = "
  dw hp_fetch_,u_dot_ ; XXX INFORMER
endif
  dw here_,comma_hp_ ; store a pointer to the xt
if debugging
  _echo "HP = lfa = "
  dw hp_fetch_,u_dot_ ; XXX INFORMER
endif
  dw current_latest_,comma_hp_ ; link field
if debugging
  _echo "HP = nfa = "
  dw hp_fetch_,u_dot_ ; XXX INFORMER
endif

  dw hp_fetch_,dup_,to_r_ ; ( len ca len nt ) ( R: nt )
  dw far_place_ ; store the name

  ; Convert the name to uppercase:
  dw r_fetch_
  dw far_count_,far_uppers_

  dw r_fetch_
if debugging
  _echo "HP = last = "
  dw dup_,u_dot_ ; XXX INFORMER
endif
  dw get_current_,store_ ; update the current word list
  dw from_r_,last_,store_ ; update `last`

  dw hide_
  dw one_plus_,hp_,plus_store_ ; update the headers pointer with the length+1
if debugging
  _echo "HP = next xtp = "
  dw hp_fetch_,u_dot_ ; XXX INFORMER
endif

  dw exit_

else

  dw here_,lastxt_,store_ ; update `lastxt`
  dw width_,fetch_,min_
  dw tuck_ ; ( len ca len )
  dw system_bank_
  dw here_,comma_hp_ ; store a pointer to the xt
  dw current_latest_,comma_hp_ ; link field

  dw hp_fetch_,dup_,to_r_ ; ( len ca len nt ) ( R: nt )
  dw place_ ; store the name
  dw r_fetch_,count_,uppers_ ; convert it to uppercase

  dw r_fetch_,get_current_,store_ ; update the current word list
  dw from_r_,last_,store_ ; and `last`

  dw hide_
  dw one_plus_,hp_,plus_store_ ; update the headers pointer with the length+1

  dw default_bank_

  dw exit_

endif

; ----------------------------------------------
  _colon_header create_,'CREATE'

  ; XXX TODO -- factor `header reveal` to `visible-header`?
  ; This phrase is used also by `defer` and `alias`.
  ; new word: 9 bytes used (3 for the call, plus 3 cells)
  ; one cell saved in 3 words: 6 bytes saved

  dw header_,reveal_
  dw lit_,do_create
  dw call_comma_
  dw paren_semicolon_code_
do_create:
  ; Note: `call do_create`, compiled first by `code-field,` and
  ; then modified by `(;code)`, already left the pfa on the
  ; stack.
  _jp_next

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _colon_header code_,'CODE'

  dw header_,asm_
  dw exit_

endif

; ----------------------------------------------
  _code_header compare_,'COMPARE'

  ; XXX TODO -- move to the library -- but needed by `[needed]`

; doc{
;
; compare ( ca1 len1 ca2 len2 -- n )
;
; Compare the string _ca1 len1_ to the string _ca2 len2_. The
; strings are compared, beginning at the given addresses,
; character by character, up to the length of the shorter string
; or until a difference is found. If the two strings are
; identical, _n_ is zero. If the two strings are identical up to
; the length of the shorter string, _n_ is minus-one (-1) if
; _len1_ is less than _len2_ and one (1) otherwise. If the two
; strings are not identical up to the length of the shorter
; string, _n_ is minus-one (-1) if the first non-matching
; character in the string _ca1 len1_ has a lesser numeric value
; than the corresponding character in the string _ca2 len2_ and
; one (1) otherwise.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

; Credit:
; Adapted from DZX-Forth

  pop de      ; DE = len2
  pop hl      ; HL = ca2
  ex (sp),hl  ; HL = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; CY = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; DE = length of the shorter string
  ; HL = length of the longer string
  ld l,c
  ld h,b ; HL = Forth IP
  pop bc ; BC = ca2
  ex (sp),hl ; HL = ca1 ; save Forth IP
  push af ; save CY (string2 is longer than string1?)
  ; HL = ca1
  ; BC = ca2
  ; DE = length of the shorter string
compare.char
  ld a,e
  or d ; end of string?
  jr z,compare.match ; is so, all chars matched
  ld a,(bc)
  cp (hl)
  jr nz,compare.no_match ; a char doesn't match
  inc hl
  inc bc
  dec de
  jp compare.char

compare.match:
  ; The smaller string matches.
  pop af ; restore CY (string2 is longer than string1?)
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl ; jump if string2 is longer than string1?
  dec hl ; 0
  jp z,push_hl ; jump if string1 equals string2
  dec hl ; -1
  _jp_pushhl ; string2 is longer than string2

; ----------------------------------------------
  _code_header search_,'SEARCH'

  ; XXX TODO -- move to the library -- but needed by `contains`

; doc{
;
; search  ( ca1 len1 ca2 len2 -- ca3 len3 f )
;
; Search the string _ca1 len1_ for the string _ca2 len2_. If _f_
; is true, a match was found at _ca3_ with _len3_ characters
; remaining.  If _f_ is false there was no match and _ca3 len3_
; is _ca1 len1_.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  ld d,b
  ld e,c ; save IP in DE
  pop bc
  pop hl ; HL/BC=substring
  ld a,b
  or c
  jr z,search.match ; if zero length substring, immediate match
  exx
  pop bc
  pop hl
  push hl
  push bc ; HL'/BC'=main string

search.substring:
  ld a,b
  or c ; end of main string?
  jr z,search.failed ; no match if end of main string
  exx
  ld a,(hl)
  exx
  cpir ; search for first substring char
  jr nz,search.failed ; no match if not found
  dec hl ; backup to matching char
  inc bc
  push bc
  exx
  ex (sp),hl
  and a
  sbc hl,bc ; test length left against substring length
  pop hl
  exx
  jr c,search.failed ; no match if not long enough
  push hl
  exx
  ex de,hl
  ex (sp),hl ; save IP, get HL=main string, DE=substring
  push de ; save substring
  push bc
search.char:
  ld a,(de)
  cp (hl)
  jr nz,search.next_substring ; stop trying if char mismatch
  inc de
  inc hl
  dec bc
  ld a,b
  or c ; end of substring?
  jr nz,search.char ; for rest of substring
  pop de
  pop de ; discard substring
  pop bc ; restore IP
  pop de
  pop de ; discard caddr1/u1
  exx
  push hl ; stack caddr3/u3
  push bc
  exx
search.match:
  jp true_

search.next_substring:
  pop bc ; restore substring
  pop hl
  pop de ; restore IP
  exx
  inc hl ; move past first matching char
  dec bc
  jr search.substring ; back for another try

search.failed:
  exx
  ld b,d
  ld c,e ; restore IP
  jp false_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERAL',immediate+compile_only

  ; ----
  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate
  ; ----

  dw compile_,s_lit_,s_comma_
  dw exit_

; ----------------------------------------------
  _code_header byte_question_,'BYTE?'

; doc{
;
; byte?  ( n|b -- f )
;
; Is _n|b_ an 8-bit number?
;
; }doc

  ; Credit:
  ; Word adapted from DZX-Forth.

  pop hl
  ld l,h
  jp zero_equals.hl

; ----------------------------------------------
  _colon_header c_literal_,'CLITERAL',immediate+compile_only

; doc{
;
; cliteral  ( b -- )
;
; Compile _b_ in the current definition.
;
; This word does the same than `literal` but saves one byte
; of data space and is a bit faster at run-time (0.97 of
; execution speed).
;
; ----
; : cliteral  ( b -- )
;   postpone clit c,  ;
; ----
;
; Origin: Comus.
;
; }doc

  dw compile_,c_lit_,c_comma_
  dw exit_

; ----------------------------------------------
  _colon_header literal_,'LITERAL',immediate+compile_only

; doc{
;
; literal  ( n -- )
;
; Compile _n_ in the current definition.
;
; ----
; : literal  ( n -- )
;   postpone lit ,  ;
; ----
;
; }doc

  dw compile_,lit_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header one_literal_,'1LITERAL',immediate+compile_only

; doc{
;
; 1literal  ( n|b -- )
;
; Compile _n|b_ in the current definition.
;
; ----
; : 1literal  ( n|b -- )
;   dup byte? if  postpone cliteral exit  then  postpone literal  ;
; ----
;
; }doc

  dw dup_,byte_question_
  dw zero_branch_,literal_pfa
  dw branch_,c_literal_pfa

; ----------------------------------------------
  _colon_header two_literal_,'2LITERAL',immediate+compile_only

; doc{
;
; 2literal  ( d -- )
;
; Compile _d_ in the current definition.
;
; ----
; : 2literal  ( d -- )
;   postpone 2lit 2,  ;
; ----
;
; }doc

  dw compile_,two_lit_,two_comma_
  dw exit_

; ----------------------------------------------
if 1 ; developing

  ; XXX TMP -- during the development

  _colon_header depth_,'DEPTH'

  ; XXX TMP -- only during the development, then move to the
  ; library.

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw exit_

endif

; ----------------------------------------------
  _colon_header question_dictionary_,'?DICTIONARY'

; doc{
;
; ?dictionary  ( -- )
;
; Issue an error message if the dictionary is out of bounds.
;
; }doc

  ; XXX UNDER DEVELOPMENT

  _literal 0 ; XXX TMP
  _question_throw error.dictionary_overflow
  dw exit_

; ----------------------------------------------
  _colon_header question_stack_,'?STACK'

; doc{
;
; ?stack  ( -- )
;
; Issue an error message if the stack is out of bounds.
;
; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,sp0_,fetch_
  dw swap_,less_than_
  _question_throw error.stack_underflow
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_throw error.stack_overflow

if developing
  
  ; Check also the return stack

  dw rp0_,fetch_
  dw rp_fetch_
  dw less_than_
  _question_throw error.return_stack_underflow

if 0
  dw rp_fetch_
  _literal return_stack_limit+8*cell
  ; XXX REMARK -- adding less than 8 cells doesn't work
  dw less_than_,zero_equals_
else
  _literal return_stack_limit+7*cell
  ; XXX REMARK -- adding less than 7 cells doesn't work
  dw rp_fetch_,less_than_
endif

  dw question_exit_
  dw rp0_,fetch_,rp_store_ ; empty the return stack
  _throw error.return_stack_overflow ; no return from `throw`

else

  dw exit_

endif

; ----------------------------------------------
  _colon_header not_understood_,'NOT-UNDERSTOOD'

  _literal error.not_understood
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header compilation_only_,'COMPILATION-ONLY'

  _literal error.compilation_only
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header nest_source_,'NEST-SOURCE',compile_only

; doc{
;
; nest-source  ( R: -- source-sys )
;
; _source-sys_ describe the current source specification for
; later use by `unnest-source`.

; ----
; : nest-source  ( R: -- source-sys )
;   r>
;   source 2>r
;   source-id >r
;   >in @ >r
;   blk @ >r
;   #tib @ >@
;   >r  ; compile-only
; ----

; }doc

  dw from_r_ ; save the return address
  dw source_,two_to_r_
  dw source_id_,to_r_
  dw to_in_,fetch_,to_r_
  dw blk_,fetch_,to_r_
  dw number_tib_,fetch_,to_r_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _colon_header unnest_source_,'UNNEST-SOURCE',compile_only

; doc{
;
; unnest-source  ( R: source-sys -- )
;
; Restore the source specification described by _source-sys_.

; ----
; : unnest-source  ( R: source-sys -- )
;   r>
;   r> #tib !
;   r> blk !
;   r> >in !
;   r> (source-id) !
;   2r> input-buffer 2!
;   >r  ; compile-only
; ----

; }doc

  dw from_r_ ; save the return address
  dw from_r_,number_tib_,store_
  dw from_r_,blk_,store_
  dw from_r_,to_in_,store_
  dw from_r_
  dw paren_source_id_,store_
  dw two_from_r_,input_buffer_,two_store_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _variable_header interpret_table_,'INTERPRET-TABLE'

; doc{
;
; interpret-table  ( -- a )
;
; Return the address of the execution table used by `interpret`.
; The table contains 13 vectors.  The behaviour of the Forth
; text interpreter can be changed by replacing these vectors.
; See the kernel source for details on the position and function
; of the vectors.
;
; See: `interpret`.
;
; }doc

                        ; compiling...
  dw execute_           ; ...immediate and compile-only word
  dw compile_comma_     ; ...compile-only word
  dw execute_           ; ...immediate word
  dw compile_comma_     ; ...ordinary word
  dw two_literal_       ; ...2-cell number
  dw one_literal_       ; ...1-cell number

interpret_table.0:
  dw not_understood_    ; not a number (error)

                        ; interpreting...
  dw 0                  ; ...1-cell number (do nothing)
  dw 0                  ; ...2-cell number (do nothing)
  dw execute_           ; ...ordinary word
  dw execute_           ; ...immediate word
  dw compilation_only_  ; ...compile-only word (error)
  dw compilation_only_  ; ...immediate and compile-only word (error)

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'

; doc{
;
; interpret  ( -- )
;
; The text interpreter which sequentially executes or compiles
; text from the input stream (terminal or disk) depending on
; `state`. if the word name cannot be found after a search of
; the `context` search order it is converted to a number
; according to the current `base`.  That also failing, an error
; message will be given.
;
; }doc

interpret.begin:
  ; _chk 'begin interpret, latest:' ; XXX INFORMER
  ; if debugging
  ;   dw latest_,cr_,dot_name_ ; XXX INFORMER
  ; endif

  dw question_stack_
  dw parse_name_  ; ( ca len )
  ; _chk_type 'after parse-name' ; XXX INFORMER
  dw dup_ ; end of stream?
  dw zero_branch_,interpret.end ; if so, finish

  dw find_name_ ; ( nt | 0 )
  ; _chk 'after find-name' ; XXX INFORMER
  dw question_dup_ ; found?
  dw zero_branch_,interpret.word_not_found

  ; Word found
  ; ( nt )
  ; _chk 'word found' ; XXX INFORMER
  dw dup_,name_to_immediate_question_       ; ( nt xt f1 )
  dw rot_,compile_only_question_,two_star_  ; ( xt f1 n2 )
  dw plus_,abs_ ; ( xt +n )
  _literal 3
  dw plus_ ; adjust the table index

interpret.do_it:
  ; ( +n )
  ; Execute element _+n_ of `interpret-table`,
  ; depending on `state`.
  ;_brk 'do it' ; XXX INFORMER
  dw compiling_question_,question_negate_,cells_
  _literal interpret_table.0
  ;_brk 'before +' ; XXX INFORMER
  dw plus_,perform_
  ; _chk 'after perform' ; XXX INFORMER
  dw branch_,interpret.begin

interpret.word_not_found:
  ; _brk 'not found' ; XXX INFORMER
  dw parsed_name_,two_fetch_ ; ( ca len )
  dw number_question_ ; is it a number?  ( 0 | n 1 | d 2 )
  ; _chk 'after number?' ; XXX INFORMER
  dw branch_,interpret.do_it

interpret.end:
  dw two_drop_
  ; _chk 'exit interpret' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _c_constant_header immediate_mask_,'IMMEDIATE-MASK'

; doc{
;
; immediate-mask  ( -- b )
;
; Constant that holds the bitmask of the precedence bit.
;
; }doc

  db immediate_mask

; ----------------------------------------------
  _colon_header lex_question_,'LEX?'

; doc{
;
; lex?  ( nt b -- f )
;
; Test the bits at _nt_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

if 1

  dw swap_
if 1 ; far_memory
  dw far_
else
  dw system_bank_
endif
  dw c_fetch_test_bits_question_
  dw default_bank_
  dw exit_

else  ; XXX TMP alternative without `c@test-bits?`

if 1 ; far_memory
  dw swap_,far_c_fetch_,and_,zero_not_equals_
  dw exit_
else
  dw system_bank_
  dw swap_,c_fetch_s_,and_,zero_not_equals_
  dw default_bank_
  dw exit_
endif

endif

; ----------------------------------------------
  _colon_header lex_store_,'LEX!'

; doc{
;
; lex!  ( b nt -- )
;
; Set the bits of the mask _b_ in the length byte of _nt_.
;
; }doc

  ; Credit:
  ; Word adapted from eForth.

if 1 ; far_memory
  dw far_
else
  dw system_bank_
endif
  dw c_store_set_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIATE'

  dw immediate_mask_,latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_question_,'IMMEDIATE?'

; doc{
;
; immediate?  ( nt -- f )
;
; Is the word _nt_ immediate?
;
; }doc

  dw immediate_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header name_to_immediate_question_,'NAME>IMMEDIATE?'

; doc{
;
; name>immediate?  ( nt -- xt f )
;
; Is the word _nt_ immediate?
;
; }doc

  dw dup_,from_name_,swap_ ; ( xt nt )
  dw immediate_question_ ; ( xt f )
  dw exit_

; ----------------------------------------------
  _c_constant_header compile_only_mask_,'COMPILE-ONLY-MASK'

; doc{
;
; compile-only-mask  ( -- b )
;
; Constant that holds the bitmask of the compile-only bit.
;
; }doc

  db compile_only_mask

; ----------------------------------------------
  _colon_header compile_only_,'COMPILE-ONLY'

  dw compile_only_mask_,latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header compile_only_question_,'COMPILE-ONLY?'

; doc{
;
; compile-only?  ( nt -- f )
;
; Is the word _nt_ compile-only?
;
; }doc

  dw compile_only_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_comma_,'WORDLIST,'

; doc{
;
; wordlist,  ( -- )
;
; Compile the contents of a new word list.
; The structure is the following:
;
; |===
; | +0 | _nt_ of last definition
; | +2 | _wid|0_, next wordlist in chain, or zero
; | +4 | _nt|0_, word list name pointer, or zero
; |===
;
; ----
; : wordlist,  ( -- )
;   0 ,  here voc-link @ , voc-link !  0 ,  ;
; ----
;
; }doc

  _literal 0
  dw comma_                   ; nt of the latest word defined in the vocabulary
  dw here_                    ; new value of `voc-link`
  dw voc_link_,fetch_,comma_  ; compile the previous value of `voc-link`
  dw voc_link_,store_         ; update `voc-link`
  _literal 0
  dw comma_                   ; nt of the wordlist, or zero
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_,'WORDLIST'

; Credit: Most code related to word lists has been adapted from
; eForth.

; doc{
;
; wordlist  ( -- wid )
;
; : wordlist ( -- wid )
;   here wordlist, ;
;
; }doc

  dw here_,wordlist_comma_
  dw exit_

; ----------------------------------------------
  _colon_header do_vocabulary_,'DOVOCABULARY'

; doc{
;
; dovocabulary  ( -- )
;
; Change the behaviour of the latest word defined:
; Replace the first word list in the search order with
; the _wid_ stored in its body.
;
; See `vocabulary`, `wid>vocabulary`, `wordlist`.
;
; ----
; : dovocabulary  ( -- )
;   does>   ( -- )  ( pfa ) @ context !  ;
; ----
;
; }doc

  dw paren_semicolon_code_
do_vocabulary:
  call do_does
  dw fetch_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header get_current_,'GET-CURRENT'

; doc{
;
; get-current  ( -- wid )
;
; Return _wid_, the identifier of the compilation word list.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : get-current  ( -- wid )
;   current @  ;
; ----
;
; }doc

  dw current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header set_current_,'SET-CURRENT'

; doc{
;
; set-current  ( wid -- )
;
; Set the compilation word list to the word list identified by
; _wid_.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : set-current  ( wid -- )
;   current !  ;
; ----
;
; }doc

  dw current_,store_
  dw exit_

; ----------------------------------------------
  _colon_header definitions_,'DEFINITIONS'

; doc{
;
; definitions  ( -- )
;
; Make the compilation word list the same as the first  word
; list in the search order. The  names of subsequent definitions
; will be placed in the compilation word list. Subsequent
; changes in the search  order will not affect the compilation
; word list.
;
; ----
; : definitions  ( -- )
;   context @ set-current  ;
; ----
;
; }doc

  dw context_,fetch_,set_current_
  dw exit_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

  ; XXX TODO -- make this word deferred and factor its default
  ; behaviour to `core-(` (Forth-2012 CORE word set), in order
  ; to let `load-app` change it to `file-(` (Forth-2012 FILE
  ; word set).

; doc{
;
; (  ( f "ccc<paren>" -- )
;
; Parse until a right paren is found.  The number of parsed
; characters may be zero to the number of characters in the
; parse area.
;
; }doc

  _literal ')'
  dw parse_,two_drop_
  dw exit_

; ----------------------------------------------
  _colon_header dot_ok_,'.OK'

; doc{
;
; .ok  ( -- )
;
; Print "ok". This is the default behaviour of `ok`, the word
; called by `quit` after interpreting a command.
;
; }doc

  dw paren_dot_quote_
  _string 'ok'
  dw exit_

; ----------------------------------------------
  _defer_header ok_,'OK',,dot_ok_

; doc{
;
; ok  ( -- )
;
; A deferred word called by `quit` after interpreting a command.
; Its default behaviour is the word `.ok`.
;
; }doc

; ----------------------------------------------
  _colon_header quit_,'QUIT'

  dw terminal_to_source_
  dw left_bracket_
quit.begin:
  dw rp0_,fetch_,rp_store_
  dw cr_,query_ ; XXX TMP ; XXX TODO
  dw interpret_
  dw compiling_question_
  dw question_branch_,quit.begin
  dw ok_
  dw branch_,quit.begin

; ----------------------------------------------
  _colon_header paren_defer_,'(DEFER)'

; doc{
;
; (defer)  ( -- )
;
; Default behaviour of an uninitialized deferred word: error.
;
; }doc

; XXX TODO -- move to the library

  _literal error.deferred_word_uninitialized
  dw error_
  dw exit_

; ----------------------------------------------
  _colon_header defer_,'DEFER'

; doc{
;
; defer  ( "name" -- )
;
; Create a deferred word.
;
; Origin: Forth-2012 (CORE EXT).
;
; }doc

  dw header_,reveal_
  _literal paren_defer_ ; default xt to execute
  dw jp_comma_
  dw exit_

; ----------------------------------------------
  _alias_header to_defer_,'>DEFER',,one_plus_

; XXX TODO -- rename to `>action`, after the standard
; `action-of`?

; doc{
;
; >defer  ( xt -- a )
;
; Return the address _a_ that holds the xt currently associated
; to the deferred word _xt_.
;
; }doc

; ----------------------------------------------
  _colon_header defer_store_,'DEFER!'

; doc{
;
; defer!  ( xt1 xt2 -- )
;
; Change the deferred word _xt2_ to execute _xt1_.
;
; Origin: Forth-2012 (CORE EXT).
;
; }doc

  dw to_defer_,store_
  dw exit_

; ----------------------------------------------
  _variable_header version_,'VERSION'

; doc{
;
; version  ( -- a )
;
; Return an address that holds the Solo Forth version, as
; follows:
;
; +0: major (one byte)
; +1: minor (one byte)
; +2: patch (one byte)
; +3: pre-release (one byte), zero if none
; +4: build (double-cell number)
;
; }doc

  db version_major
  db version_minor
  db version_patch
  db version_prerelease
  dw version_build_high_part,version_build_low_part

; ----------------------------------------------
  _colon_header dot_version_,'.VERSION'

; doc{
;
; .version  ( -- )
;
; Print the Solo Forth version.
;
; }doc

  dw version_
  dw dup_,c_fetch_,zero_dot_r_
  _literal '.'
  dw emit_
  dw one_plus_,dup_,c_fetch_,zero_dot_r_
  _literal '.'
  dw emit_
  dw one_plus_,dup_,c_fetch_,zero_dot_r_
  dw one_plus_
if version_prerelease
  dw paren_dot_quote_
  _string "-pre."
  dw dup_,c_fetch_,zero_dot_r_
endif
dot_version.build
  _literal '+'
  dw emit_
  dw one_plus_,two_fetch_,d_dot_
  dw exit_

; ----------------------------------------------
  _colon_header greeting_,'GREETING'

; doc{
;
; greeting  ( -- )
;
; Print the boot message.
;
; }doc

  dw paren_dot_quote_
  _string "Solo Forth\rv"
  dw dot_version_
  dw dos_,type_
  dw paren_dot_quote_
  _string "\rBy Marcos Cruz\r(programandala.net), 2015-2016\r"
if 1 ; developing
  ; XXX TMP -- during the development
  dw dot_unused_
endif
  dw exit_

; ----------------------------------------------
if 1 ; developing
  ; XXX TMP -- during the development
  _colon_header dot_unused_,'.UNUSED'

; doc{
;
; .unused ( -- )
;
; Display the amount of space remaining in the region addressed
; by `here`, in address units.
;
; ----
; : .unused  ( -- )
;   unused u. ." B free"  ;
; ----
;
; }doc

  dw unused_,u_dot_
  dw paren_dot_quote_
  _string "B free"
  dw exit_

endif
; ----------------------------------------------
  _defer_header boot_,'BOOT',,noop_

; doc{
;
; boot  ( -- )
;
; A deferrer word executed by `abort`. By default it does
; nothing. It is changed by `turnkey`.
;
; }doc

; ----------------------------------------------
  _variable_header previous_mode_,'PREVIOUS-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; previous-mode  ( -- a )
;
; Variable that holds the xt of the word that activates the
; screen mode that was active before executing `bye`.  It's
; updated by `bye`, and used by `warm` to restore the current
; mode.
;
; }doc

  dw noop_

; ----------------------------------------------
  _variable_header current_mode_,'CURRENT-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; current-mode  ( -- a )
;
; Variable that holds the xt of the word that activates the
; current screen mode. It's set to `noop` until the first mode
; change is done.
;
; }doc

  dw noop_

; ----------------------------------------------
  _colon_header save_mode_,'SAVE-MODE'

  dw current_mode_,fetch_
  dw previous_mode_,store_
  dw exit_

; ----------------------------------------------
  _colon_header restore_mode_,'RESTORE-MODE'

  dw previous_mode_,perform_
  dw exit_

; ----------------------------------------------
  _colon_header warm_,'WARM'

; doc{
;
; warm  ( -- )
;
; }doc

  dw display_
  dw restore_mode_
  dw page_ ; note: this must be after changing the screen mode
  dw abort_
  ; No return from `abort`.

warm_start:
  call common_start
  dw warm_

; ----------------------------------------------
  _colon_header cold_,'COLD'

; doc{
;
; cold  ( -- )
;
; }doc

  ; Init the headers pointer.
  dw lit_,headers_pointer_init_value,fetch_
  dw lit_,headers_pointer,store_

  ; Init the disk buffers.
  dw empty_buffers_

  ; Init the circular string buffer.
  dw empty_csb_

  ; Init the user variables.
  dw lit_,default_user_variables_start ; from
  dw up_,fetch_ ; to
  _literal default_user_variables_end-default_user_variables_start ; length
  dw c_move_

  ; Restore the vocabularies to the default state.
  dw lit_,latest_nt_in_root_voc.init_value,fetch_
  dw lit_,root_wordlist_pfa,store_
  dw lit_,latest_nt_in_forth_voc.init_value,fetch_
  dw lit_,forth_wordlist_pfa,store_
if 1 ; assembler_core_in_kernel
  dw lit_,latest_nt_in_assembler_voc.init_value,fetch_
  dw lit_,assembler_wordlist_pfa,store_
endif
  dw lit_,voc_link.init_value,fetch_
  dw lit_,voc_link_pfa,store_

  dw only_,forth_,definitions_  ; init the search order
  dw default_header_ ; set the default behaviour of `header`
  dw decimal_

  dw display_,default_colors_,page_
  dw greeting_

if 1 ; XXX INFORMER

  ; dw hex_

  ; _literal $1622 ; nt of `.(`
  ; dw far_
  ; dw dup_
  ; dw cr_,u_dot_

  ; _literal $1620 ; lfa of `.(`
  ; dw far_fetch_
  ; dw cr_,u_dot_

  ; _literal $10BD ; nt of `definitions`
  ; dw far_count_
  ; dw cr_,dot_s_,cr_,type_

  ; dw decimal_

endif

  dw abort_

cold_start:
call_move_definition_headers_to_memory_bank:
  call move_definition_headers_to_memory_bank ; only the first time
  call common_start
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  ; (SP) = xt of `cold` or `warm`

  im 1 ; interrupt mode 1
  pop bc ; get the return address, which holds the xt of `cold` or `warm`
  ld (system_stack_pointer),sp ; save the system stack pointer
  ld sp,(sp0_init_value)
  ld (iy+sys_df_sz_offset),0 ; no lines at the bottom part of the screen
  ld ix,next ; restore IX
  _jp_next ; jump to the xt pointed by the register pair BC

; ----------------------------------------------
  _alias_header d_to_s_,'D>S',,drop_

; doc{
;
; d>s  ( d -- n )
;
; _n_ is the equivalent of _d_. The high cell of _d_ is
; discarded.
;
; See: `s>d`, `u>ud`.
;
; Origin: Forth-94 (DOUBLE), Forth-2012 (DOUBLE).
;
; }doc

; ----------------------------------------------
if size_optimization

  ; 9 bytes

  _colon_header s_to_d_,'S>D'

  dw dup_,zero_less_than_
  dw exit_

else

  ; 13 bytes

  _code_header s_to_d_,'S>D'

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_hlde ; jump if positive
  dec hl
  jp push_hlde

endif

; doc{
;
; s>d  ( n -- d )
;
; Sign extend a single number _n_ to form a double number _d_.
;
; See: `d>s`, `u>ud`.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : s>d  ( n -- d )
;   dup 0<  ;
; ----
;
; }doc

; ----------------------------------------------
  _code_header question_negate_,'?NEGATE'

; doc{
;
; ?negate  ( n1 n2 -- n1|n3 )
;
; If _n2_ is negative, negate _n1_, giving its arithmetic
; inverse _n3_.
;
; ----
; : ?negate  ( n1 n2 -- n1|n3 )
;   0< if  negate  then  ;
; ----
;
; Origin: fig-Forth's `+-`.
;
; }doc

  pop hl
question_negate.hl:
  bit 7,h
  jp nz,negate_
  _jp_next

; ----------------------------------------------
  _code_header question_d_negate_,'?DNEGATE'

; doc{
;
; ?dnegate  ( d1 n -- d1|d2 )
;
; If _n_ is negative, negate _d1_, giving its arithmetic inverse
; _d2_.
;
; ----
; : ?dnegate  ( d1 n -- d1|d2 )
;   0< if  dnegate  then  ;
; ----
;
; Origin: fig-Forth's `d+-`.
;
; }doc

  pop hl
question_d_negate.hl:
  bit 7,h
  jp nz,d_negate_
  _jp_next

; ----------------------------------------------
  _code_header abs_,'ABS'

; doc{
;
; abs  ( n -- u )
;
; Leave the absolute value _u_ of a number _n_.
;
; ----
; : abs  ( n -- u )
;   dup ?negate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_negate.hl

; ----------------------------------------------
  _code_header d_abs_,'DABS'

; doc{
;
; dabs  ( d -- ud )
;
; Leave the absolute value _ud_ of a double number _d_.
;
; ----
; : dabs  ( d -- ud )
;   dup ?dnegate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_d_negate.hl

; ----------------------------------------------
  _code_header umax_,'UMAX'

; doc{
;
; umax  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMIN'

; doc{
;
; umin  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MIN'

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MAX'

  ; Credit:
  ; Code adapted from DZX-Forth.

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  push de
  _jp_next

; ----------------------------------------------
  _colon_header m_star_,'M*'

; doc{
;
; m*  ( n1 n2 -- d )
;
; Multiply _n1_ by _n2_ producing the result _d_.
;
; Origin: fig-Forth, Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : m*  ( n1 n2 -- d )
;   2dup xor >r
;   abs swap abs um*
;   r> ?dnegate  ;
; ----
;
; }doc

if 1 ; original_m_star

  ; Credit:
  ; Code from Abersoft Forth.

  ; XXX Note: this code is used also by Z88 CamelForth.

  dw two_dup_,xor_,to_r_
  dw abs_,swap_,abs_,u_m_star_
  dw from_r_,question_d_negate_
  dw exit_

else

  ; XXX TODO -- code from DZX-Forth

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_signed
  jp push_hlde

endif

; ----------------------------------------------
  _defer_header m_slash_,'M/',,s_m_slash_rem_

; doc{
;
; m/  ( d n1 -- n2 n3 )
;
; A mixed magnitude math operator which leaves the signed
; remainder _n2_ and signed quotient _n3_ from a double number
; dividend and divisor _n1_.
;
; This word is deferred and by default it's set to execute
; `sm/rem`, so it does a symmetric division (the  remainder
; takes its sign from the dividend), as in fig-Forth.  It can be
; set to execute `fm/mod` instead.
;
; This word is executed by all other division operators.
; Therefore setting it to execute either `sm/rem` or `fm/mod`
; will change the behaviour of all division operators.
;
; Origin: fig-Forth.
;
; }doc

; ----------------------------------------------
  _colon_header s_m_slash_rem_,'SM/REM'

; doc{
;
; sm/rem  ( d n1 -- n2 n3 )
;
; Symmetric division:
;
;   d = n3*n1+n2;

;   sign(n2) = sign(d1) or 0
;
; Divide _d_ by _n1_, giving the symmetric quotient _n3_ and the
; remainder _n2_. Input and output stack arguments are signed.

; [caption="Symmetric Division Example"]
;
;  |===
;  | Dividend   | Divisor  | Remainder  | Quotient

; >|       10  >|      7  >|        3  >|        1
; >|      -10  >|      7  >|       -3  >|       -1
; >|       10  >|     -7  >|        3  >|       -1
; >|      -10  >|     -7  >|       -3  >|        1
;  |===

; Origin: Forth-94 (CORE), Forth-2012 (CORE).

; ----
; : sm/rem  ( d1 n1 -- n2 n3 )
;   \ symmetric signed division
;   2dup xor >r  \  sign of quotient
;   over >r      \  sign of remainder
;   abs >r dabs r> um/mod
;   swap r> ?negate
;   swap r> ?negate  ;
; ----

; }doc

  dw two_dup_,xor_,to_r_
  dw over_,to_r_
  dw abs_,to_r_,d_abs_,from_r_,u_m_slash_mod_
  dw swap_,from_r_,question_negate_
  dw swap_,from_r_,question_negate_
  dw exit_

; ----------------------------------------------
  _colon_header star_,'*'

; doc{
;
; *  ( n1|u1 n2|u2 -- n3|u3 )
;
; Multiply n1|u1 by n2|u2 giving the product n3|u3.
;
; Origin: fig-Forth, Forth-79, Forth-83, Forth-94, Forth-2012.
;
; }doc

if 1

  dw m_star_,drop_
  dw exit_

else

  ; XXX TODO -- from DZX-Forth

  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

endif

; ----------------------------------------------
  _colon_header slash_mod_,'/MOD'

; doc{
;
; /mod  ( n1 n2 -- n3 n4 )
;
; Divide _n1_ by _n2_ and leave the remainder _n3_ and quotient
; _n4_.
;
; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; }doc

  dw to_r_,s_to_d_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header slash_,'/'

; doc{
;
; /  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the quotient _n3_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : /  ( n1 n2 -- n3 )
;   /mod nip  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header mod_,'MOD'

; doc{
;
; mod  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the single-cell remainder _n3_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : mod  ( n1 n2 -- n3 )
;   /mod drop  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,drop_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MOD'

; doc{
;
; */mod  ( n1 n2 n3 -- n4 n5 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; result _d_. Divide _d_ by _n3_ producing the remainder
; _n4_ and the quotient _n5_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */mod  ( n1 n2 n3 -- n4 n5 )
;   >r m* r> m/  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw to_r_,m_star_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_,'*/'

; doc{
;
; */  ( n1 n2 n3 -- n4 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; _d_. Divide _d_ by _n3_ giving the quotient _n4_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */  ( n1 n2 n3 -- n4 )
;   */mod nip  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw star_slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header line_to_string_,'LINE>STRING'

; doc{
;
; line>string  ( n1 n2 -- ca len )
;
; Convert the line number _n1_ and the screen number _n2_ to a
; string _ca len_ in the disk buffer containing the data.
;
; Note: in fig-Forth, this word is called `(line)`.
;
; ----
; : line>string  ( n1 n2 -- ca len )
;   >r  c/l b/buf */mod  r> +
;   block + c/l  ;
; ----
; }doc

  ; XXX TODO -- move to the library?
  ; the problem is `located` needs it,
  ; thus it can not be loaded with `need`.

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_
  dw plus_
  dw block_,plus_,c_slash_l_
  dw exit_

; ----------------------------------------------
  _colon_header dec_dot_,'DEC.'

  dw base_,fetch_,swap_,decimal_,dot_,base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header dot_throw_hash_,'.THROW#'

; doc{
;
; .throw#  ( n -- )
;
; Print the number of throw error _n_.
;
; }doc

  dw paren_dot_quote_
  _string "\r#" ; carriage return, backslash, space and hash
  dw dec_dot_
  dw exit_

; ----------------------------------------------
  _defer_header dot_throw_,'.THROW',,dot_throw_hash_

  ; Credit:
  ; Name from MPE Forth for TiniARM.

; doc{
;
; .throw  ( n -- )
;
; Deferred word that prints error message _n_. By default it
; prints only the number.
;
; }doc

; ----------------------------------------------
  _colon_header updated_question_,'UPDATED?'

; doc{
;
; updated?  ( -- f )
;
; Is the current disk buffer marked as modified?
;
; ----
; : updated?  ( -- f )
;   buffer-id 0<  ;
; ----
; }doc

  dw buffer_id_,zero_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFERS'

; doc{
;
; empty-buffers  ( -- )
;
; Unassign all block buffers. Do not transfer the contents of
; any updated block to mass storage.
;
; ----
; : empty-buffers  ( -- )
;   $7FFF disk-buffer !  ;
; ----
;
; Origin: fig-Forth, Forth-79 (REQUIRED WORD SET), Forth-83
; (CONTROLLED REFERENCE WORDS), Forth-94 (BLOCK EXT), Forth-2012
; (BLOCK EXT).
;
; }doc

  _literal buffer_block_id_mask
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_id_,'BUFFER-ID'

; doc{
;
; buffer-id  ( -- x )
;
; Id of the disk buffer.
;
; }doc

  dw disk_buffer_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_block_,'BUFFER-BLOCK'

; doc{
;
; buffer-block  ( -- n )
;
; Return the block _n_ associated with the disk buffer.
;
; ---
; : buffer-block  ( -- n )
;   buffer-id $7FFF literal and  ;
; ---
;
; }doc

  dw buffer_id_
  _literal buffer_block_id_mask
  dw and_
  dw exit_

; ----------------------------------------------
  _colon_header free_buffer_,'FREE-BUFFER'

; doc{
;
; free-buffer  ( n -- )
;
; If the current disk buffer has been updated, write its block
; to the disk. Assign block number _n_ to the disk buffer.
;
; ----
; : free-buffer  ( n -- )
;   updated?  if    buffer-block write-buffer
;             then  disk-buffer !  ;
; ----
;
; }doc

  dw updated_question_
  dw zero_branch_,free_buffer.end
  dw buffer_block_,write_block_
  dw branch_,free_buffer.end
free_buffer.end:
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_,'BUFFER'

; doc{
;
; buffer  ( n -- a )
;
; Assign the block buffer to block _n_.   If the contents of the
; buffer were marked as updated, it is written to the disk.  The
; block _n_ is not read from the disk.  The address _a_ left on
; stack is the first cell in the buffer for data storage.
;
; ----
; : buffer  ( n -- a )
;   dup buffer-block =
;   if  drop  else  free-buffer  then  buffer-data  ;
; ----
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,buffer.not_equals
  ; The requested block is the one already in the buffer.
  dw drop_
  dw branch_,buffer.end  ; XXX TODO -- exit, faster?
buffer.not_equals:
  dw free_buffer_
buffer.end:
  dw buffer_data_ ; first cell of data in the buffer
  dw exit_

; ----------------------------------------------
  _colon_header block_,'BLOCK'

; doc{
;
; block  ( n -- a )

; If the block _n_ is already in memory, leave the address _a_
; of the first cell in the disk buffer for data storage.
;
; If the block _n_ is not already in memory, transfer it from
; disk to the buffer.  If the block occupying that buffer has
; been marked as updated, rewrite it to disk before block _n_ is
; read into the buffer.  Finally leave the address _a_ of the
; first cell in the disk buffer for data storage.
;
; ----
; : block ( n -- a )
;   dup buffer-block =
;   if    drop
;   else  save-buffers  dup read-block  disk-buffer !
;   then  buffer-data  ;
; ----
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,block.not_equals
  dw drop_
  dw branch_,block.end
block.not_equals:
  dw save_buffers_,dup_,read_block_
  dw disk_buffer_,store_
block.end:
  dw buffer_data_
  dw exit_

; ----------------------------------------------
  _code_header flip_,'FLIP'

; doc{
;
; flip  ( n1 -- n2 )
;
; Exchange the low and high bytes within _n1_.
;
; Note: This word is called `><` or `cswap` in other Forth
; systems.
;
; Origin: eForth.
;
; }doc

; Credit:
; The name "flip" was borrowed from eForth.

  pop hl
  ld a,h
  ld h,l
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _colon_header save_buffers_,'SAVE-BUFFERS'

; doc{
;
; save-buffers  ( -- )
;
; If the disk buffer has been modified, transfer its contents to
; disk and mark it as unmodified.
;
; ----
; : save-buffers ( -- )
;   updated? 0= ?exit \ exit if not updated
;   buffer-block dup write-block  disk-buffer !  ;
; ----
;
; Origin: Forth-94.
;
; }doc

  dw updated_question_,zero_equals_ ; not updated?
  dw question_exit_ ; exit if not updated
  ; Updated
  dw buffer_block_,dup_,write_block_
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header set_source_,'SET-SOURCE'

; doc{
;
; set-source  ( ca len -- )
;
; Set the memory zone _ca len_ as the current source by pointing
; the input buffer to it.

; ----
; : set-source  ( ca len -- )
;   input-buffer 2!  >in off  ;
; ----
;
; }doc

  dw input_buffer_,two_store_
  dw to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header terminal_to_source_,'TERMINAL>SOURCE'

; doc{
;
; terminal>source  ( -- )
;
; Set the terminal as the current source.
;
; ----
; : terminal>source  ( -- )
;   blk off  (source-id) off  tib #tib @ set-source  ;
; ----
;
; }doc

  dw blk_,off_,paren_source_id_,off_
  dw tib_,number_tib_,fetch_,set_source_
  dw exit_

; ----------------------------------------------
  _colon_header block_to_source_,'BLOCK>SOURCE'

; doc{
;
; block>source  ( u -- )
;
; Set block _u_ as the current source.
;
; ----
; : block>source  ( u -- )
;   blk !  >in off  ;
; ----
;
; }doc

  ; XXX INFORMER {{{
  ; _literal '['
  ; dw emit_
  ; dw dup_,base_,fetch_
  ; _literal 10
  ; dw base_,store_
  ; dw swap_,dot_,base_,store_
  ; _literal ']'
  ; dw emit_
  ; XXX INFORMER }}}


  dw blk_,store_,to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header paren_load_,'(LOAD)'

; doc{
;
; (load)  ( u -- )
;
; Make block _u_ the current input source and interpret it.

; This word is a common factor of `load` and `continued`.
;
; ----
; : (load)  ( u -- )
;   block>source interpret  ;
; ----
;
; }doc

  dw block_to_source_,interpret_
  dw exit_

; ----------------------------------------------
  _colon_header load_,'LOAD'

; doc{
;
; load  ( u -- )
;
; XXX TODO update the description
;
; Save the current input-source specification. Store the first
; disk block of screen _u_ in `blk` (thus making screen _u_ the
; input source and setting the input buffer to encompass its
; contents), set `>in` to zero, and interpret. When the parse
; area is exhausted, restore the prior input source
; specification.
;
; An error is issued if _u_ is zero.
;
; ----
; : load  ( u -- )
;   dup 0= #-259 ?throw  dup scr !
;   nest-source (load) unnest-source  ;
; ----
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.loading_from_screen_0
  dw dup_,scr_,store_
  dw nest_source_,paren_load_,unnest_source_
  dw exit_

; ----------------------------------------------
  _colon_header next_block_,'-->',immediate

; doc{
;
; -->  ( -- )  \ "next-screen"
;
; Continue interpretation with the next block.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words).
;
; ----
; : -->  ( -- )
;   ?loading refill 0= #-35 ?throw  ; immediate
; ----
;
; }doc

  dw question_loading_
  dw refill_,zero_equals_
  _literal error.invalid_block_number
  dw question_throw_
  dw exit_

; ----------------------------------------------
  _colon_header defined_,'DEFINED'

; doc{
;
; defined  ( "name" -- nt | 0 )
;
; Parse "name" and find its definition.  If the definition is
; not found after searching all the word lists in the search
; order, return zero. If the definition is found,
; return its _nt_.
;
; ----
; : defined  ( "name" -- nt | 0 )
;   parse-name find-name  ;
; ----
;
; }doc

  dw parse_name_,find_name_
  dw exit_

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINED'

; doc{
;
; ?defined  ( f -- )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  dw zero_equals_
  _question_throw error.not_found
  dw exit_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

; doc{
;
; [defined]  ( "name" -- f )
;
; ----
; : [defined]  ( "name" -- f )
;   defined 0<>  ; immediate
; ----
;
; }doc

  dw defined_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED]',immediate

  ; XXX TODO make this the main word instead of `[defined]`, and
  ; move `[defined]` to the library?

; doc{
;
; [undefined]  ( "name" -- f )
;
; ----
; : [undefined]  ( "name" -- f )
;   postpone [defined] 0=  ; immediate
; ----
;
; }doc

  dw bracket_defined_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header tick_,"'"

; doc{
;
; '  ( "name" -- xt )
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : '  ( "name" -- xt )
;   defined dup ?defined name>  ;
; ----
;
; }doc

  dw defined_,dup_,question_defined_,from_name_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate+compile_only

; doc{
;
; [']  ( "name" -- xt )
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : [']  ( "name" -- xt )
;   ' postpone literal  ; immediate
; ----
;
; }doc

  dw tick_,literal_
  dw exit_

; ----------------------------------------------
  _alias_header begin_,'BEGIN',immediate+compile_only,backward_mark_

; doc{
;
; begin  ( Compilation: -- a n )
;
; At compile time `begin` leaves the dictionary address on
; stack with an error checking number _n_.  It does not compile
; anything to the dictionary.
;
; }doc

; ----------------------------------------------
  _alias_header then_,'THEN',immediate+compile_only,forward_resolve_

; ----------------------------------------------
  _colon_header until_,'UNTIL',immediate+compile_only

  dw compile_,zero_branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header again_,'AGAIN',immediate+compile_only

; doc{
;
; again  ( Compilation: a -- )
;
; End of an infinite loop.  Compile an unconditional jump
; instruction to branch backward to _a_.
;
; }doc

  dw compile_,branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header repeat_,'REPEAT',immediate+compile_only

; doc{
;
; repeat
;
;   Compilation: ( orig dest -- )
;
; Compile `branch` to jump back to `begin`.  Resolve also  the
; branching offset required by `while`.
;
; }doc

  dw again_ ; unconditional branch back to `begin`
  dw then_ ; resolve the forward branching needed by `while`
  dw exit_

; ----------------------------------------------
  _colon_header if_,'IF',immediate+compile_only

; doc{
;
; if  ( Compilation: -- orig ) ( Run-time: x -- )
;
; }doc

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header ahead_,'AHEAD',immediate+compile_only

; doc{
;
; ahead
;
;   Compilation: ( C: -- orig )
;   Run-time: ( -- )
;
; Origin: Forth-94 (TOOLS EXT), Forth-2012 (TOOLS EXT).
;
; }doc

  dw compile_,branch_,forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header else_,'ELSE',immediate+compile_only

  dw ahead_
  dw swap_ ; XXX TODO `cs-swap`
  dw then_
  dw exit_

; ----------------------------------------------
  _colon_header while_,'WHILE',immediate+compile_only

  dw if_
  dw swap_ ; XXX TODO `cs-swap`
  dw exit_

; ----------------------------------------------
  _colon_header spaces_,'SPACES'

; doc{
;
; spaces  ( n -- )
;
; If _n_ is greater than zero, display _n_ spaces.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw b_l_,swap_,emits_
  dw exit_

; ----------------------------------------------
  _colon_header emits_,'EMITS'

; doc{
;
; emits  ( c n -- )
;
; If _n_ is greater than zero, display _n_ characters _c_.
;
; ----
; : emits  ( c n -- )
;   0 max 0 ?do  dup emit  loop  drop  :
; ----
;
; }doc

  _literal 0
  dw max_
  _literal 0
  dw paren_question_do_,emits.loop_exit ; do
  dw dup_,emit_
  dw paren_loop_ ; loop
emits.loop_exit:
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header less_hash_,'<#'

  dw pad_,hld_,store_
  dw exit_

; ----------------------------------------------
  _colon_header hash_greater_,'#>'

  dw two_drop_
  dw hld_,fetch_
  dw pad_,over_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header sign_,'SIGN'

; doc{

; sign  ( n  --  )

; If _n_ is negative, add a minus sign to the beginning of the
; pictured numeric output string.
;
; See: `<#`, `#>`.
;
; Origin: Forth 94 (CORE), Forth-2012 (CORE).
;
; ----
; : sign  ( n -- )
;   0< if  '-' hold  then  ;
; ----
;
; }doc

  dw zero_less_than_
  dw zero_branch_,sign.end
  _literal '-'
  dw hold_
sign.end:
  dw exit_

; ----------------------------------------------
  _code_header to_digit_,'>DIGIT'

; doc{
;
; >digit  ( n -- c )
;
; Convert a number to its character digit: 0..9A..Z.
;
; ----
; : >digit  ( n -- c )
;   dup 9 > [ 'A' '0' - 1+ ] literal and + '0' +  ;
; ----
;
; }doc

  ; Credit:
  ;
  ; Adapted from Z88 CamelForth.

  pop hl
  ld a,l
  cp 10
  jr c,to_digit.end
  add a,7
to_digit.end
  add a,$30
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _colon_header hash_,'#'

; doc{
;
; #  ( d1 -- d2 )
;
; Divide _d1_ by current base.  The remainder is converted to
; an ASCII character and appended to the output text string.
; The quotient _d2_ is left on stack.
;
; ----
; : #  ( d1 -- d2 )
;   base @ ud/mod rot >digit hold  ;
; ----
;
; }doc

  dw base_,fetch_
  dw u_d_slash_mod_,rot_,to_digit_,hold_
  dw exit_

; ----------------------------------------------
  _colon_header u_d_slash_mod_,'UD/MOD'

; doc{
;
; ud/mod ( ud1 u2 -- u3 ud4 )
;
; An unsigned mixed magnitude math operation which leaves a
; double quotient _ud4_ and remainder _u3_, from a double
; dividend _ud1_ and single divisor _u2_.

; ----
; : ud/mod  ( ud1 u1 -- urem udquot )
;   >r 0 r@ um/mod -rot r> um/mod rot  ;
; ----
;
; Origin: fig-Forth (`m/mod`), Gforth, Z88 CamelForth.
;
; }doc

  ; Credit:
  ; Code modified from Z88 CamelForth.

; XXX TODO -- compare with this version from Gforth
; and save `-rot` in the kernel:
;
; : ud/mod
;   >r 0 r@ um/mod r> swap >r um/mod r> ;

  dw to_r_
  _literal 0
  dw r_fetch_
  dw u_m_slash_mod_
  dw minus_rot_
  dw from_r_
  dw u_m_slash_mod_
  dw rot_
  dw exit_

; ----------------------------------------------
  _code_header minus_rot_,'-ROT'

; doc{
;
; -rot  ( x1 x2 x3 -- x3 x1 x2 )
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Afera.

  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  jp push_hlde

; ----------------------------------------------
  _colon_header hash_s_,'#S'

; doc{
;
; #S  ( d1 -- d2 )
;
; }doc

hash_s.begin:
  dw hash_,two_dup_,or_
  dw question_branch_,hash_s.begin
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.R'

; doc{
;
; d.r  ( d n -- )
;
; Print a signed double number _d_ right justified in a field of
; _n_ characters.
;
; ----
; : d.r  ( d n -- )
;   >r tuck dabs <# #s rot sign #> over - spaces type  ;
; ----
;
; }doc

  dw to_r_ ; save _n_
  dw tuck_  ; save the high part of _d_ to calculate the sign
  dw d_abs_,less_hash_,hash_s_,rot_,sign_,hash_greater_
  dw from_r_,over_,minus_,spaces_ ; preceding blanks
  dw type_
  dw exit_

; ----------------------------------------------
  _colon_header dot_r_,'.R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header zero_dot_r_,'0.R'

; doc{
;
; 0.r  ( n -- )
;
; Print signed integer _n_ according to current base,
; without any trailing blank.
;
; }doc

  _literal 0
  dw dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header zero_d_dot_r_,'0D.R'

; doc{
;
; 0d.r  ( d -- )
;
; Print signed double integer _d_ according to current base,
; without any trailing blank.
;
; }doc

  _literal 0
  dw d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_,'D.'

; doc{
;
; d.  ( d -- )
;
; Print signed double integer _d_ according to current base,
; followed by only one blank.
;
; }doc

  dw zero_d_dot_r_,space_
  dw exit_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; .  ( n -- )
;
; Print signed integer _n_ according to current base, followed
; by only one blank.
;
; }doc

  dw s_to_d_,d_dot_
  dw exit_

; ----------------------------------------------
  _colon_header question_,'?'

  dw fetch_,dot_
  dw exit_

; ----------------------------------------------
  _colon_header u_dot_,'U.'

  _literal 0
  dw d_dot_
  dw exit_

; ----------------------------------------------
if 1 ; developing

  ; XXX TMP -- during the development

  _colon_header dot_s_,'.S'

  ; XXX TMP -- only during the development, then remove
  ; It is in the library.

  dw depth_,dup_
  _literal '<'
  dw emit_
  _literal 0
  dw dot_r_
  _literal '>'
  dw emit_

  dw space_
  _literal 1
  dw less_than_
  dw question_branch_,dot_s.end

  dw sp_fetch_,sp0_,fetch_,cell_minus_
  dw paren_do_,dot_s.loop_exit ; do
  dw i_,fetch_,u_dot_ ; XXX TMP `u.`
  _literal -cell
  dw paren_plus_loop_ ; loop
dot_s.loop_exit:

dot_s.end:
  dw exit_

; ----------------------------------------------
  _colon_header type_ascii_,'TYPE-ASCII'

; : type-ascii  ( ca len -- )
;   bounds ?do
;     i c@ dup dup ascii-char? 0= swap control-char? or
;     if  drop '.'  then  emit
;   loop  ;

; XXX REMARK -- This word is in the library. It's also here because
; it's needed by `blks`.

  dw bounds_
  dw paren_question_do_,type_ascii.loop_exit
  dw i_,c_fetch_,dup_,dup_
  _literal 127
  dw greater_than_
  dw swap_,b_l_,less_than_,or_
  dw zero_branch_,type_ascii.then
  dw drop_
  _literal '.'
type_ascii.then
  dw emit_
  dw paren_loop_
type_ascii.loop_exit
  dw exit_

; ----------------------------------------------
  _colon_header blks_,'BLKS'

  ; XXX TMP -- for debugging

; : blks  ( u -- )
;   page
;   20 bounds ?do
;     i block drop
;     i 3 .r space buffer-data 28 type-ascii
;     \ key 'q' = if  unloop exit  then  \ XXX OLD
;   loop  ;
; ----

; Read 20 blocks, starting from block _u_, and prints the start
; of their first lines.  This tool is useful when a new DOS is
; implemented, in order to check the disk access calculations.

  dw page_
  _literal 20
  dw bounds_
  dw paren_question_do_,trdos_tester.loop_exit
  dw i_,block_,drop_
  dw i_
  _literal 3
  dw dot_r_,space_
  dw buffer_data_
  _literal 28
  dw type_ascii_

if 0

  ; XXX OLD
  dw key_
  _literal 'q'
  dw equals_
  dw zero_branch_,trdos_tester.continue
  dw unloop_,exit_
trdos_tester.continue

endif

  dw paren_loop_
trdos_tester.loop_exit
  dw exit_

endif

; ----------------------------------------------
  _colon_header page_,'PAGE'

; doc{
;
; page  ( -- )
;
; Move to another page for output.  On a terminal, `page` clears
; the screen and resets the cursor position to the upper left
; corner. On a printer, `page` performs a form feed.
;
; Origin: Forth-79 (Reference Word Set), Forth-83 (Uncontrolled
; Reference Words), Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

  dw printing_,fetch_
  dw zero_branch_,page.display
  _literal form_feed_char
  dw emit_
  dw exit_

page.display
  dw cls_
  dw exit_

; ----------------------------------------------
  _code_header paren_bye_,'(BYE)'

  ld (iy+sys_df_sz_offset),$02 ; restore lines of the lower screen

  im 1 ; interrupt mode 1, normal situation of the OS

system_stack_pointer: equ $+1
  ld sp,0 ; restore the system stack

; The Complete Spectrum ROM Disassembly
; (http://www.worldofspectrum.org/infoseekid.cgi?id=2000076),
; page 201, states:
;
; For a successful return to BASIC, H'L' must on exit from the
; machine code contain the address in SCANNING of the 'end-calc'
; instruction, 2758 hex (10072 decimal).

  ld hl,$2758
  exx

  ; Exit to BASIC:
  rst $08
  db $08 ; "STOP" BASIC error

; ----------------------------------------------
  _defer_header default_mode_,'DEFAULT-MODE',,noop_

; doc{
;
; default-mode  ( -- )
;
; A deferred word that activates the default screen mode. It's
; set to `noop` until the first mode change is done. Then it's
; vectored to `mode32`.  It's used by `bye`.
;
; }doc

; ----------------------------------------------
  _colon_header bye_,'BYE'

  dw save_mode_
  dw default_mode_
  dw paren_bye_
  ; No return from `(bye)`.

; ----------------------------------------------
  _code_header two_drop_,'2DROP'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWAP'

; doc{
;
; 2swap  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth

                      ; T   B
                      ; --- --
  exx                 ;  04 01
  pop hl  ; HL'=x4    ;  10 01
  pop de  ; DE'=x3    ;  10 01
  exx                 ;  04 01
  pop hl  ; HL=x2     ;  10 01
  pop de  ; DE=x1     ;  10 01
  exx                 ;  04 01
  push de ; x3        ;  11 01
  push hl ; x4        ;  11 01
  exx                 ;  04 01
  jp push_hlde        ;  10 03
                      ;  11 00 push de
                      ;  11 00 push hl
                      ; --- --
                      ; 110 13 TOTAL

; ----------------------------------------------
  _variable_header limit_,'LIMIT'

; doc{
;
; limit  ( -- a )
;
; Variable that holds the address above the highest address
; usable by the data space, which is the region addressed by
; `here`. Its default value is zero, which is right above the
; highest memory address ($FFFF).
;
; This variable can be modified by a program in order to reserve
; a memory zone for special purposes.
;
; See: `here`, `unused`.
;
; Origin: Fig-Forth's `limit` constant.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header unused_,'UNUSED'

; doc{
;
; unused ( -- u )
;
; Return the amount of space remaining in the region addressed
; by `here`, in address units.
;
; See: `here`, `limit`.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw limit_,fetch_,here_,minus_
  dw exit_

; ----------------------------------------------
if 1 ; developing
  ; XXX TMP -- during the development

  _colon_header where_,'WHERE'

  ; XXX TMP -- needed only during the development
  ; XXX TODO -- remove; already copied to the library

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw exit_

where.do_it:
  dw dup_
  dw paren_dot_quote_
  _string 'Scr #'
  dw dec_dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  _literal '^'
  dw emit_
  dw exit_

endif

; ----------------------------------------------
  _colon_header mode32_at_xy_,'MODE32-AT-XY'

; doc{

; (mode32-at-xy) ( col row -- )
;
; Default behaviour of `at-xy`, in mode 32.
;
; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  dw dup_
  _literal 23
  dw not_equals_ ; not the last row?
  dw zero_branch_,at_pfa.last_line
  ; not the last row
  _literal 22
  dw mode32_emit_,mode32_emit_,mode32_emit_
  dw exit_

at_pfa.last_line:
  dw one_minus_,dup_,mode32_emit_,mode32_emit_
  _literal 0
  dw mode32_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  _literal 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw exit_

; ----------------------------------------------
  _code_header cls_,'CLS'

; doc{
;
; cls  ( -- )
;
; Clear the screen with the current colors and reset the cursor
; position to the upper left corner (column 0, row 0).
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

; Credit:
; The attributes part was improved after code by Dean Belfield
; <http://wordpress.animatez.co.uk/programming/assembly-language/z80/z80-library-routines/204-2/>.
; The idea for `ld (hl),l` was found in David Webb's _Advanced
; Spectrum Machine Language_.

  exx ; save the Forth IP
  ; Erase the bitmap.
  ld hl,sys_screen
  ld de,sys_screen+1
  ld bc,sys_screen_bitmap_size
  ld (hl),l ; l=0 because sys_screen=$4000
  ldir
  ; Color with the permanent attributes.
  ld bc,sys_screen_attributes_size-1
  ld a,(sys_attr_p)
  ld (hl),a
  ldir
  ld (sys_coords),bc ; reset the graphic coordinates
  exx ; restore the Forth IP

  ; Execution continues in `home`:

; ----------------------------------------------
  _defer_header home_,'HOME',,paren_home_

; doc{
;
; home  ( -- )
;
; Set the cursor position at the top left position (column 0,
; row 0).
;
; `home` is a deferred word, which default behaviour is
; `(home)`.
;
; See: `(home)`.
;
; }doc

; ----------------------------------------------
  _code_header paren_home_,'(HOME)'

; doc{
;
; (home)  ( -- )
;
; Default behaviour of `home`: Set the cursor position at the
; top left position (column 0, row 0).
;
; See: `home`.
;
; }doc

  ld hl,$0000
  push hl
  push hl

  ; Execution continues in `at-xy`:

; ----------------------------------------------
  _defer_header at_xy_,'AT-XY',,mode32_at_xy_

; doc{
;
; at-xy ( col row -- )
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

; ----------------------------------------------
  _colon_header mode32_xy_,'MODE32-XY'

; doc{
;
; (mode32-xy)  ( -- col row )

; Return the current column and row, in mode 32.
;
; ----
; : (mode32-xy)  ( -- col row )
;   24 23689 c@ -
;   33 23688 c@ - dup 32 = if  drop 1+ 0  then  swap  ;
; ----
;
; }doc

  ; Credit:
  ; Code from the Spectrum Forth-83 manual.

  _literal 24
  _literal sys_s_posy
  dw c_fetch_,minus_
  _literal 33
  _literal sys_s_posx
  dw c_fetch_,minus_
  dw dup_
  _literal 32 ; XXX TODO -- chars per line in the current mode
  dw equals_
  dw zero_branch_,mode32_xy.end
  dw drop_,one_plus_
  _literal 0
mode32_xy.end:
  dw swap_
  dw exit_

; ----------------------------------------------
  _defer_header xy_,'XY',,mode32_xy_

; doc{
;
; xy ( -- col row )
;
; Return the current column and row of the text cursor.
;
; }doc

; ----------------------------------------------
  _code_header default_colors_,'DEFAULT-COLORS'

; doc{
;
; default-colors  ( -- )
;
; Set the screen colors to the default values.
;
; }doc

  ; Deactivate temporary and permanent print flags (over,
  ; inverse, contrast ink, contrast paper).

  xor a
  ld (sys_p_flag),a

  ; Set the colors and their masks.

  ld hl,(default_color_attribute)
  ; l = 128*flash + 64*bright + 8*paper + ink
  ; h = mask
  ld (sys_attr_p),hl ; permanent
  ld (sys_attr_t),hl ; temporary

  ; Set the border color to the paper color.

  ld a,l ; 128*flash + 64*bright + 8*paper + ink
  and a ; CY=0
  rra
  rra
  rra ; a = paper
  jr border.a

; ----------------------------------------------
  _code_header border_,'BORDER'

; doc{
;
; border  ( n -- )
;
; Set the border of the screen to color to _n_.  Only the 3
; lower bits of _n_ are used (for colors 0..7).
;
; }doc

  pop hl
  ld a,l
border.a:
  and %00000111 ; force value 0..7
  call $229B ; secondary entry point in the "BORDER" ROM routine
  _jp_next

  ; Note: The ROM routine at $229B also sets the system variable
  ; BORDCR, which holds the attributes of the lower part of the
  ; screen (paper after the border, and calculated constrast
  ; ink).  This is needed because: 1) G+DOS by default changes
  ; the border color during disk operations, and at the end
  ; restores it with the value of this system variable; 2) The
  ; lower screen will have contrast ink after returning to
  ; BASIC, no matter the border color used in Forth.

; ----------------------------------------------
  _code_header flash_,'FLASH'

; doc{
;
; flash  ( n -- )
;
; If _n_ is zero, reset the flash color attribute.
; If bit 0 of _n_ is set, set the flash color attribute.
;
; }doc

  ld a,flash_char
  jr color1

; ----------------------------------------------
  _code_header bright_,'BRIGHT'

; doc{
;
; bright  ( n -- )
;
; If _n_ is zero, reset the bright color attribute.
; If bit 0 of _n_ is set, set the bright color attribute.
;
; }doc

  ld a,bright_char

color1:

  ; Set a boolean color attribute (bright, flash)
  ;
  ; Input:
  ;   A = attribute control char
  ;   (tos) = color attribute value

  rst $10
  pop hl
  ld a,l
  and %00000001 ; force value 0..1
  rst $10
  jr permanent_colors_

; ----------------------------------------------
  _code_header paper_,'PAPER'

; doc{
;
; paper  ( n -- )
;
; Set paper color to _n_ (0..9). If _n_ is greater than 9, 9 is
; used.
;
; }doc

  ld a,paper_char
  jr color9

; ----------------------------------------------
  _code_header ink_,'INK'

; doc{
;
; ink  ( n -- )
;
; Set ink color to _n_ (0..9). If _n_ is greater than 9, 9 is
; used.
;
; }doc

  ld a,ink_char

color9:

  ; Set a color attribute (ink, paper)
  ;
  ; Input:
  ;   A = attribute control char
  ;   (tos) = color attribute value

  rst $10
  pop hl
  ld a,l
  cp $0A ; value is 0..9?
  jr c,color9.valid
  ld a,$09
color9.valid:
  rst $10

  ; Execution continues in `permanent-colors`:

; ----------------------------------------------
  _code_header permanent_colors_,'PERMANENT-COLORS'

; doc{
;
; permanent-colors  ( -- )
;
; Make the current temporary color attributes permanent.
;
; }doc

  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTANT'

  dw create_,two_comma_
  dw paren_semicolon_code_
do_two_constant:

  ; Execution continues in `2@`:

; ----------------------------------------------
  _code_header two_fetch_,'2@'

  pop hl ; address
two_fetch.hl:
  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1 ; DE = low part
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1 ; HL = high part
  ex de,hl      ; 04t  1
  jp push_hlde  ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL


; ----------------------------------------------
  _colon_header two_variable_,'2VARIABLE'

; doc{
;
; 2variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve two consecutive
; cells of data space.
;
;    _name_ is referred to as a two-variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the first (lowes address) cell of two
;    consecutive cells. A program is responsible for
;    initializing the contents.
;
; Origin: Forth-94.
;
; }doc

  dw create_
  dw branch_,two_comma.allot

; ----------------------------------------------
  _colon_header u_dot_r_,'U.R'

  ; XXX TODO -- move to the library

  dw to_r_
  _literal 0
  dw from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _code_header two_over_,'2OVER'

  ; XXX TODO -- Move to the library? But the Z80 label
  ; `two_fetch.hl` should be returned by a constant.
  ; Alternatives: write it in Forth; write it in Z80 with a call
  ; to `2@`, using `execute-xt`.

; doc{
;
; 2over  ( d1 d2 -- d1 d2 d1 )
;
; }doc

  ld hl,$0004
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _alias_header unnest_,'UNNEST',,r_drop_

  ; XXX NEW -- experimental

  ; Credit:
  ; http://dxforth.netbay.com.au/unnest.html

; ----------------------------------------------
  _code_header exit_,'EXIT'

; doc{
;
; exit  ( -- ) ( R: nest-sys -- )

; Return control to the calling definition, specified by
; _nest-sys_.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; In Solo Forth `exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header question_exit_,'?EXIT'

; doc{
;
; ?exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by _nest-sys_.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; In Solo Forth `?exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,exit_
  _jp_next

; ----------------------------------------------
  _colon_header catch_,'CATCH'

  ; XXX TODO -- move to the library?

; doc{

; catch  ( xt -- 0 | err# )

; Push an exception frame on the exception stack and then
; execute _xt_ (as with `execute`) in such a way that control
; can be transferred to a point just after `catch` if `throw` is
; executed during the execution of _xt_.
;
; If the execution of _xt_ completes normally (i.e., the
; exception frame pushed by this `catch` is not popped by an
; execution of `throw`) pop the exception frame and return zero
; on top of the data stack, above whatever stack items would
; have been returned by the execution of _xt_. Otherwise, the
; remainder of the execution semantics are given by `throw`.
;
; Origin: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).

;----
; : catch  ( xt -- exception# | 0 )
;   sp@ >r          ( xt )  \ save data stack pointer
;   catcher @ >r    ( xt )  \ save previous catcher
;   rp@ catcher !   ( xt )  \ set current catcher
;   execute         ( )     \ `execute` returns if no `throw`
;   r> catcher !    ( )     \ restore previous catcher
;   r> drop         ( )     \ discard saved stack pointer
;   0  ;            ( 0 )   \ normal completion, no error
;----
; }doc

  ; Credit: Code from DZX-Forth, MPE Forth for TiniARM and
  ; Forth-2012 documentation.

  dw sp_fetch_,to_r_ ; save data stack pointer
  dw catcher_,fetch_,to_r_ ; save previous catcher
  dw rp_fetch_,catcher_,store_ ; set current catcher
  dw execute_ ; `execute` returns if no `throw`
  dw from_r_,catcher_,store_  ; restore error frame
  dw from_r_,drop_ ; discard saved stack pointer
  _literal 0  ; normal completion, no error
  dw exit_

; ----------------------------------------------
  _colon_header throw_,'THROW'

  ; Credit:
  ; Code from DZX-Forth.
  ; Comments from MPE Forth for TiniARM.

; doc{
;
; throw  ( n -- )
;
; Origin: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).
;
; ----
; : throw  ( n -- )
;   ?dup if
;     catcher @ ?dup 0=   \ no catcher?
;     if  error  then     \ `error` does not return
;     rp!                 \ restore previous return stack
;     r> catcher !        ( n )  \ restore previous catcher
;     r> swap >r          ( saved-SP ) ( R: n )
;     sp! drop r>         ( n )  \ restore stack
;     \ Return to the caller of `catch` because return stack is
;     \ restored to the state that existed when `catch` began
;     \ execution.
;   then  ;
; ----
;
; }doc

  dw question_dup_
  dw zero_branch_,throw.end
  dw catcher_,fetch_,question_dup_  ; catcher?
  dw question_branch_,throw.catcher ; if so, branch
  dw error_ ; no return from `error`.

throw.catcher:
  dw rp_store_                ; restore previous return stack
  dw from_r_,catcher_,store_  ; ( n )  restore previous catcher
  dw from_r_,swap_,to_r_      ; ( saved-SP ) ( R: n )
  dw sp_store_,drop_,from_r_  ; ( n )  restore stack

  ; Return to the caller of `catch` because return stack is
  ; restored to the state that existed when `catch` began
  ; execution.

throw.end:
  dw exit_

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT)'

  dw sp0_,fetch_,sp_store_
  dw boot_  ; XXX TODO -- not here?
  dw quit_
  ; No return from `quit`.

; ----------------------------------------------
  _colon_header abort_,'ABORT'

  _literal -1
  dw throw_ ; no return from this `throw`

; ----------------------------------------------
  _colon_header s_quote_,'S"',immediate

  ; : s"  ( Compilation: "ccc<">" -- ) ( Run-time:  -- ca len )
  ;   '"' parse-string  ; immediate

  _literal '"'
  dw parse_string_
  dw exit_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

; doc{
;
; ?\  ( f "ccc<eol>" -- )
;
; If _f_ is not false, parse and discard the rest of the parse
; area.  This word is used for conditional compilation.
;
; }doc

  ; XXX TODO move to the library?

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw exit_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

; doc{
;
; \  ( "ccc<eol>" -- )
;
; Parse and discard the rest of the parse area.
;
; Origin: Forth-94 (BLOCK EXT), Forth-2012 (BLOCK EXT).
;
; }doc

  dw loading_question_ ; input stream from disk?
  dw question_branch_,backslash.loading

  ; Interpreting
  dw number_tib_,fetch_,to_in_,store_
  dw exit_

backslash.loading:
  ; Loading
  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw parsed_
  dw exit_

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .(  ( 'text<paren>' -- )  \ immediate
;
; }doc

  _literal ')'
  dw parse_,type_
  dw exit_

  ; These symbols must be set with the values of the
  ; latest word defined in the `forth` vocabulary:
latest_nt_in_forth_voc: equ dot_paren_nt
latest_xt_in_forth_voc: equ dot_paren_

dictionary_pointer_after_cold:

; ==============================================================
; Definition headers

move_definition_headers_to_memory_bank:

  ; Move the definition headers, assembled in ordinary memory,
  ; to the system bank. This routine is needed only once,
  ; therefore its call is patched with `noop` at the end; the
  ; routine itself will be overwritten by the Forth dictionary.

  ; The whole screen is used as intermediate buffer for copying
  ; the data.

if defined plus3dos

  ; +3DOS uses RAM pages 1, 3, 4 and 6 as an array of 128 sector
  ; buffers (numbered 0...127), each of 512 bytes, thus 32
  ; buffers per RAM page. The cache and RAM disk occupy two
  ; separate (contiguous) areas of this array. In order to free
  ; RAM page 1 for Solo Forth, the default configuration must be
  ; modified, moving everything up and making the RAM disk 32
  ; buffers smaller:

  ; XXX TODO -- adapt to the far-memory system

if system_bank!=1
  .error "`system_bank` is not 1. +3DOS's cold start must be reconfigured."
endif

  ld de,$2008 ; $08 sectors for the cache, from sector $20
  ld hl,$2858 ; $58 sectors for the RAM disk, from sector $28
  ld ix,dos_set_1346 ; set RAM pages 1, 3, 4 and 6
  call dos

endif

  ld hl,bank_start ; origin
  ld de,sys_screen ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the definition headers to the screen

if 1 ; far_memory
  ld a,(far_banks_pfa) ; first bank used as far memory
  ld e,a
  call bank.e
else
  call bank.system
endif

  ld hl,sys_screen ; origin
  ld de,bank_start ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the definition headers to the bank

  call bank.default

  ; Erase the memory that was used for the headers
  ; during the compilation of the kernel:
  ld hl,bank_start
  ld de,bank_start+1
  ld bc,bank_size
  ld (hl),l ; L=0 because bank_start=$C000
  ldir

  ; Remove the call to this routine,
  ; so it will not be executed in future 
  ld hl,call_move_definition_headers_to_memory_bank
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  ret

; ==============================================================
; End

end cold_entry

; vim: filetype=z80:textwidth=64
