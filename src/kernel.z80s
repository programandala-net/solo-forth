; Solo Forth kernel

; This file is part of Solo Forth
; http://programandala.net/en.program.solo_forth.html

; XXX UNDER DEVELOPMENT

; Last modified: 201604141429

; ==============================================================
; Author

; Marcos Cruz (programandala.net), 2015, 2016.

; ==============================================================
; License

; You may do whatever you want with this work, so long as you
; retain every copyright, credit and authorship notice, and this
; license.  There is no warranty.

; ==============================================================
; Version

; Semantic Versioning (http://semver.org)

version_major:                equ 0
version_minor:                equ 5
version_patch:                equ 0

version_prerelease:           equ 6 ; zero if none

version_build_high_part:      equ $0133
version_build_low_part:       equ $9F9F  ; build 20160415

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; ==============================================================
; System description

; ----------------------------------------------
; Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before exit.
;       IX   Address of `next`.
;            May be used within Forth words if restored before exit.
;       IY   Address of the ERRNR ZX Spectrum system variable.
;            May be used within Forth words if restored before exit.

; ----------------------------------------------
; Header structure

; The name and link fields are created in a memory bank:

; xtp: dw xt               ; Pointer to xt in main memory.
; lfa:  dw nt of the previous word
; nt:  db length+flags     ; Bits:      76543210
                           ; Bit names: CPSLLLLL
                           ; Legend:
                           ;   C: Compile-ony bit.
                           ;      0 = non-restricted word
                           ;      1 = compile-only word
                           ;   P: Immediate bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;       ds length          ; name

; The code and parameter fields are created in the dictionary:

; xt: dw code_address
; pfa:    ...              ; data or code

; ==============================================================
; Glossary

; At the moment the description of Forth words is included in
; this source.  The markers `doc{` and `}doc` delimitate the
; comments that will be extracted to build the actual glossary.

; ==============================================================
; Configuration

  ; XXX FIXME Pasmo gives strange errors (symbols not found)
  ; when some config flags are used in nested `if`. A literal
  ; flag (0/1) is used instead, with the flag name in a comment;
  ; it is changed with a text substitution.  Some Vim mappings
  ; are created to turn them on and off.

  ; Solo Forth can be compiled for G+DOS or +3DOS.
  ; This depends on two labels, `gplusdos` and `plus3dos`,
  ; defined with a parameter of the Pasmo assembler. See the
  ; Makefile files for details. Support for +3DOS is not
  ; finished yet.

if (!defined gplusdos) and (!defined plus3dos)
  gplusdos equ true ; G+DOS by default
endif

  ; XXX experimental
size_optimization: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

  ; XXX the flag is harcoded in the code
  ; XXX OLD
;assembler_core_in_kernel: equ true

  ; XXX UNDER DEVELOPMENT
;new_wordlists: false
  ; new = simpler implementation of `wordlist`, based on eForth

developing: equ true
  ; true = include some words needed during the development
  ; false = don't

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

;origin:                           equ $5E00
origin:                           equ $5F00 ; XXX TMP -- for debugging

ramtop:                           equ origin-1 ; used by the BASIC loader

false:                            equ $0000
true:                             equ $FFFF ; -1

cell:                             equ $02

cells_per_data_stack:             equ $50
cells_per_return_stack:           equ $50

bytes_per_terminal_input_buffer:  equ $50

bytes_per_sector:                 equ $0200 ; 512-byte sectors in G+DOS and +3DOS
sectors_per_block:                equ $02

bytes_per_buffer:                 equ $0400

if defined gplusdos
  blocks_per_disk:                  equ 800 ; KiB per disk in G+DOS
endif
if defined plus3dos
  blocks_per_disk:                  equ 720 ; KiB per disk in +3DOS
endif

characters_per_line:              equ $40
lines_per_screen:                 equ $10
max_search_order:                 equ $08 ; maximum number of vocabularies in the search order
bytes_per_user_variables:         equ $40

word_length_mask:                 equ %00011111
smudge_mask:                      equ %00100000
immediate_mask:                   equ %01000000
compile_only_mask:                equ %10000000

max_word_length:                  equ word_length_mask
valid_word_length_mask:           equ word_length_mask or smudge_mask

csb_size:                         equ 256 ; bytes, size of the circular string buffer

; Memory banks ($C000..0xFFFF)

bank_start                        equ $C000

default_bank:                     equ 0
system_bank:                      equ 1

names_bank_address:               equ bank_start ; names pointers

; Charset

charset_size:                     equ 224*8 ; 224 chars ($20..0xFF) * 8 bitmap rows
charset_address:                  equ $FFFF-charset_size+1

; Error codes used in the kernel

error.stack_overflow:               equ -003
error.stack_underflow:              equ -004
error.dictionary_overflow:          equ -008
error.not_found:                    equ -013
error.compilation_only:             equ -014
error.zero_length_name:             equ -016
error.conditionals_not_paired:      equ -022
error.not_understood:               equ -256
error.not_unique:                   equ -257
error.stack_unbalanced:             equ -258
error.loading_from_screen_0:        equ -259
error.wrong_digit:                  equ -260
error.deferred_word_uninitialized:  equ -261
error.assertion_failed:             equ -262
error.execution_only:               equ -263
error.definition_not_finished:      equ -264
error.loading_only:                 equ -265
error.off_current_editing_screen:   equ -266

; ----------------------------------------------
; ZX Spectrum

include inc/zx_spectrum_char_codes.z80s
include inc/zx_spectrum_rom_routines.z80s
include inc/zx_spectrum_system_variables.z80s
include inc/zx_spectrum_system_variables_offsets.z80s

sys_screen:                 equ $4000 ; address
sys_screen_size:            equ $1B00
sys_screen_bitmap_size:     equ $1800
sys_screen_attributes:      equ $5800 ; address
sys_screen_attributes_size: equ $0300

bank1_port:   equ $7FFD
border_port:  equ $FE

; ==============================================================
; Macros

; ----------------------------------------------
; Header macros

immediate:    equ immediate_mask
compile_only: equ compile_only_mask

nt_of_the_previous_word: defl 0 ; link to previous Forth word

_header: macro _base_label,_name,_flags

  ; In dictionary:

  _base_label: ; execution token
  local _dp_backup
  local _name_address
  local _address_after_name
  _dp_backup: equ $

  ; In memory bank:

  org np
  _base_label##xtp:
    dw _base_label ; execution token pointer
  _base_label##lfa: ; link field address
    dw nt_of_the_previous_word ; link field
  _base_label##nt: ; name token

  ; Length byte with optional immediate bit:

  if nul _flags
    db _address_after_name-_name_address
  else
    db _address_after_name-_name_address+_flags
  endif

  _name_address: equ $
    db _name ; name field
  _address_after_name: equ $

  np: defl $ ; new value of the names pointer

  ; Update the names pointer:
  org names_pointer
  dw np ; overwrite names_pointer
  dw np ; overwrite names_pointer_init_value

  ; In dictionary:
  org _dp_backup

  nt_of_the_previous_word: defl _base_label##nt

  endm

_code_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags

  endm

_defer_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags
  jp _xt

  endm

_alias_header: macro _base_label,_name,_flags,_xt

  _header _base_label,_name,_flags
  jp _xt

  endm

_colon_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name,_flags,_runtime_routine

  _header _base_label,_name,_flags

  call _runtime_routine ; code field ; XXX TODO confirm this
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_two_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_c_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_c_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  call do_create ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name,_flags

  _variable_header _base_label,_name,_flags

  endm

; ----------------------------------------------
; Literals macros

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_literal: macro _n

  ; Note: parenthesis are needed to prevent a strange problem of
  ; Pasmo with signs.

  if (_n)=0
    dw zero_
  else
    if (_n)=1
      dw one_
    else
      if (_n)=2
        dw two_
      else
        if (_n)>=0 && (_n)<=255
          dw c_lit_
          db _n
        else
          dw lit_
          dw _n
        endif
      endif
    endif
  endif
  endm

; ----------------------------------------------
; Jump macros

_jp_next: macro

  jp (ix)

  endm

_jp_pushhl macro

  ; Faster (2 T less) than `jp push_hl`.

  push hl
  _jp_next

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Code macros

_compare_de_hl_unsigned: macro

  ; XXX TODO -- confirm that everything is fine, and use the
  ; code directly

  if 0

    ; XXX TODO -- can not work, because the ouput flags are
    ; different

    or a
    sbc hl,de

  else

    call compare_de_hl_unsigned

  endif
  endm

; ----------------------------------------------
; Error message macros

_question_throw: macro _error
  _literal (_error)
  dw question_throw_
  endm

_message: macro _error
  _literal (_error)
  dw dot_throw_
  endm

; ----------------------------------------------
; Debug macros

debugging: equ 1

_z80_just_border: macro _color
  if debugging
    push af
    ld a,_color
    out($FE),a
    pop af
  endif
  endm

_z80_border: macro _color
  if debugging
    local _pause0
    push af
    push bc
    ld a,_color
    out($FE),a
    ld bc,0
    _pause0:
    dec bc
    ld a,b
    or c
    jr nz,_pause0
    pop bc
    pop af
  endif
  endm

_z80_border_wait: macro _color
  if debugging
    local _wait
    push af
    ld a,_color
    out($FE),a
    xor a
    ld (sys_last_k),a
    _wait:
    ld a,(sys_last_k)
    and a
    jr z,_wait
    pop af
  endif
  endm

_echo: macro _txt
  if debugging
    dw cr_,paren_dot_quote_
    _string _txt
  endif
  endm

  ; type the string on top of stack
_type: macro
  if debugging
    _echo 'TOS str= <'
    dw two_dup_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; type the counted string on top of stack
_ctype: macro
  if debugging
    _echo 'TOS cstr= <'
    dw dup_,count_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; check point
_chk: macro _message
  if debugging
    _echo _message
    dw base_,fetch_,to_r_,hex_
    dw cr_,dot_s_
    dw from_r_,base_,store_
  endif
  endm

_prompt: macro _message
  if debugging
    _echo _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
_brk: macro _message
  if debugging
    _chk _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the string on top of stack
_brk_type: macro _message
  if debugging
    _chk _message
    _type
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the counted string on top of stack
_brk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
    dw key_,drop_
  endif
  endm

  ; check point
  ; first type the string on top of stack
_chk_type: macro _message
  if debugging
    _chk _message
    _type
  endif
  endm

  ; check point
  ; first type the counted string on top of stack
_chk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
  endif
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location (of the destination address): `$01 +origin`
  jp cold_start
warm_entry:
  ; Location (of the destination address): `$04 +origin`
  jp warm_start

; ==============================================================
; Parameter area

  ; XXX TODO document the `+origin` index

latest_nt_in_root_voc.init_value:
  dw latest_nt_in_root_voc
  ; `$06 +origin`

latest_nt_in_forth_voc.init_value:
  dw latest_nt_in_forth_voc
  ; `$08 +origin`

if 1 ; assembler_core_in_kernel

latest_nt_in_assembler_voc.init_value:
  dw latest_nt_in_assembler_voc
  ; `$0A +origin`

endif

voc_link.init_value:
if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
  ; `$0C +origin`
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
  ; `$0C +origin`
endif

user_variables_pointer:
  dw user_variables
  ; `$0E +origin`

return_stack_pointer:
  dw return_stack_bottom
  ; `$10 +origin`

default_color_attribute:
  dw 4 ; low byte: green paper, black ink; high byte: no mask
  ; `$12 +origin`

  ; User variables default values

  ; The first 8 user variables have default values.  They are
  ; used by `cold` to overwrite the actual user variables and
  ; must be in the same order than them.

default_user_variables_start:

sp0_init_value:                               ; +$00
  dw data_stack_bottom
  ; `$14 +origin`
rp0_init_value:                               ; +$02
  dw return_stack_bottom
  ; `$16 +origin`
paren_wait_init_value:                        ; +$04
  dw noop_
  ; `$18 +origin`
width_init_value:                             ; +$06
  dw max_word_length
  ; `$1A +origin`
warnings_init_value:                          ; +$08
  dw true
  ; `$1C +origin`
; XXX TODO free                                    ; +$0A
  dw +$0000
  ; `$1E +origin`
dictionary_pointer_init_value:                ; +$0C
  dw dictionary_pointer_after_cold
  ; `$1F +origin`
user_data_pointer_init_value:                 ; +$0E
  dw user_data_pointer
  ; `$20 +origin`

default_user_variables_end:


ip_backup: ; temporary copy of Forth IP
  dw 0
  ; `$22 +origin`

np: defl names_bank_address+1

names_pointer:
  ; First free address in the system bank,  restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np
  ; `$24 +origin`

names_pointer_init_value:
  ; Init value of the names pointer, used by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np
  ; `$26 +origin`


; ==============================================================
; User variables

user_variables:

  ; Note: the first 8 user variables are initialized with
  ; default values by `cold`.  They must be in the same order
  ; than their default values.

sp0_value:                                    ; +$00
  dw data_stack_bottom
rp0_value:                                    ; +$02
  dw return_stack_bottom
paren_wait:                                   ; +$04
  dw $0000
width_value:                                  ; +$06
  dw max_word_length
warnings_value:                               ; +$08
  dw $0000
; XXX TODO free                                    ; +$0A
  dw $0000
dictionary_pointer_value:                     ; +$0C
  dw dictionary_pointer_after_cold
user_data_pointer_value:                      ; +$0E
  dw user_data_pointer
blk_value:                                    ; +$10
  dw $0000
in_value:                                     ; +$12
  dw $0000
hash_emit_value:                              ; +$14
  dw $0000
scr_value:                                    ; +$16
  dw $0000
r_hash_value:                                 ; +$18
  dw $0000 ; XXX OLD -- used by the editor, remove?
hld_value:                                    ; +$1A
  dw $0000
current_value:                                ; +$1C
  dw $0000
state_value:                                  ; +$1E
  dw $0000
base_value:                                   ; +$20
  dw $000A
dpl_value:                                    ; +$22
  dw $0000
csp_value:                                    ; +$24
  dw $0000

context_value:                                ; +$28..+$36

  dw forth_pfa
  dw root_pfa
  ds (max_search_order-2)*cell

  dw $0000 ; end of search order, required by `find`
            ; XXX TODO improve `find` and remove this

  ; Free space for more user variables:

user_data_pointer: equ $-user_variables
  ds bytes_per_user_variables-user_data_pointer,$FF

; XXX OLD
; if ($-user_variables) != bytes_per_user_variables
;  .error "The space reserved for user variables is wrong."
; endif

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Circular string buffer

csb:
to_csb:
  dw csb_size ; unused space in the buffer
csb0:
  ds csb_size
csb_total_size: equ $-csb

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffer

buffer_block_id_mask: equ $7FFF

; A block id is the number of the associated block, with the
; sign bit indicating, when it's set, that the buffer has been
; modified.

disk_buffer:

  dw buffer_block_id_mask     ; Block id used when the  buffer
                              ; is not associated with a block.
  ds bytes_per_buffer    ; Actual content of the block.

; ==============================================================
; Misc routines

; Credit:
; Code from DZX-Forth.

; XXX TODO -- investigate if the code is optimized for Z80;
; the code of DZX-Forth is generic, also for 8080.

; ----------------------------------------------
; Compare de and hl

compare_de_hl_unsigned:

if 1

  ; Input:  DE, HL
  ; Output:
  ;  flag CY set if HL < DE
  ;  flag Z set if HL = DE

  ; Credit:
  ; Code from DZX-Forth

          ; T  B
          ; -- --
  ld a,h  ; 04 01
  cp d    ; 04 01
  ret nz  ; 11 01  05 01
  ld a,l  ; 04 01
  cp e    ; 04 01
  ret     ; 10 01
          ; -- --  -- --
          ; 37 06  31 06

else

  ; XXX TODO

  ; Credit:
  ; Code from Z88 CamelForth.

  ; The routine is so short that it's better to use the
  ; instructions directly. The problem is the output flags are
  ; different from the DZX-Forth version, and more complex to
  ; use. Beside, it modifies HL.

  ; Input:  DE, HL
  ; Output:
  ;   negative & not OV:  HL<DE
  ;   negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ;   positive & not OV:  HL>=DE
  ;   positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ;   thus OV reverses the sense of the sign bit

            ; T  B
            ; -- --
  or a      ; 04 01
  sbc hl,de ; 15 02
  ret       ; 10 01
            ; -- --
            ; 29 04

endif

compare_de_hl_signed:

  ; Input:  DE, HL
  ; Output: flag CY if HL < DE

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ----------------------------------------------
; Move block

move_block:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy the contents of bc consecutive address
  ; units at hl to the bc consecutive address units at de. After the move
  ; completes, the bc consecutive address units at de contain exactly what the
  ; bc consecutive address units at hl contained before the move.

  _compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

move_block_upwards:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from higher addresses to lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ----------------------------------------------
; Multiplication primitives

; AHL <- A * DE

a_multiplied_by_de_to_ahl:
  ld hl,0
  ld c,8
a_multiplied_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_multiplied_by_de_to_ahl.2
  add hl,de
  adc a,0
a_multiplied_by_de_to_ahl.2:
  dec c
  jp nz,a_multiplied_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32-bit result

; HLDE <- HL * DE

if 1 ; original_u_m_star

hl_multiplied_by_de_to_hlde_unsigned:
  push bc ; save Forth IP
  ld b,h
  ld a,l
  call a_multiplied_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_multiplied_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc ; restore Forth IP
  ret

endif

if 1 ; original_m_star
else

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_multiplied_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde ; XXX TODO

endif

if 0

  ; XXX TODO -- code from DZX-Forth

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  ; two's complement
  ;       ; T  B
  ;       ; -- --
  dec hl  ; 06 01
negate_hl.1:
  ; one's complement
  ld a,l  ; 04 01
  cpl     ; 04 01
  ld l,a  ; 04 01
  ld a,h  ; 04 01
  cpl     ; 04 01
  ld h,a  ; 04 01
          ; -- --
          ; 30 07
  ret

endif

if 0

  ; Credit:
  ;
  ; http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Signed_Math

  ;input: hl
  ;ouput: hl negated
  ;destroys a

negate_hl:
  ;       ; T  B
  ;       ; -- --
  xor a   ; 04 01
  sub l   ; 04 01
  ld l,a  ; 04 01
  sbc a,a ; 04 01
  sub h   ; 04 01
  ld h,a  ; 04 01
          ; -- --
          ; 24 06
  ret
endif

if 0

  ; XXX TODO -- adapt
  ;
  ; Credit:
  ; http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#1.3

  ; Input: DE = Multiplier, BC = Multiplicand, HL = 0
  ; Output: DE:HL = Product

de_multiplied_by_bc_to_dehl_unsigned:

  push bc

  sla e   ; optimised 1st iteration
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.continue
  ld  h,b
  ld  l,c

de_multiplied_by_bc_to_dehl_unsigned.continue:
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  rl  e
  rl  d
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  add hl,bc
  jr  nc,de_multiplied_by_bc_to_dehl_unsigned.end
  inc de

de_multiplied_by_bc_to_dehl_unsigned.end:
  pop bc
  ret

endif

; ==============================================================
; :Inner interpreter

push_hlde:
  push de

push_hl:
  push hl

  ; XXX TODO -- replace `jp push_hl` (3 bytes, 10+11 T) with
  ; faster `push hl` and `jp (ix)` (3 bytes in total 11+8 T).

next:
  ; Execute the word whose xt is in the address pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next xt
  ; hl = xt

execute_hl:
  ; Execute the word whose xt is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
; Start compiling in the `root` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _alias_header root_forth_,'FORTH',,forth_

; ----------------------------------------------
  _alias_header root_forth_wordlist_,'FORTH-WORDLIST',,forth_wordlist_

; ----------------------------------------------
  _alias_header root_set_order_,'SET-ORDER',,set_order_

latest_nt_in_root_voc: equ root_set_order_nt

if 1 ; assembler_core_in_kernel

; ----------------------------------------------
; Start compiling in the `assembler` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------

if 1 ; abase

  _variable_header abase_,'ABASE'

  ; XXX TODO use the return stack instead?

; doc{
;
; abase  ( -- a )
;
; A variable used to save the current value of `base` in
; assembler definitions.
;
; }doc

  dw 0

endif

; ----------------------------------------------
  _colon_header end_asm_,'END-ASM'

; doc{
;
; end-asm  ( -- )
;
; Exit the assembler mode.
;
; }doc

  dw question_csp_
  dw previous_ ; restore the search order ; XXX TODO better
if 1 ; abase
  dw abase_,fetch_,base_,store_ ; restore `base`
else
  dw base_,store_ ; restore `base`
endif

  dw exit_

; ----------------------------------------------
  _colon_header end_code_,'END-CODE'

  dw end_asm_,reveal_
  dw exit_

; ----------------------------------------------
  _constant_header next_,'NEXT'

  dw next

; ----------------------------------------------
  _constant_header pusha_,'PUSHA'

  dw push_a

; ----------------------------------------------
  _constant_header pushhl_,'PUSHHL'

  dw push_hl

; ----------------------------------------------
  _constant_header pushhlde_,'PUSHHLDE'

  dw push_hlde

; ----------------------------------------------
  _constant_header fetchhl_,'FETCHHL'

  dw fetch.hl

; ----------------------------------------------
  _colon_header jppushl_,'JPPUSHHL'

; doc{
;
; jppushl  ( -- )
;
; Compile a Z80 jump to `pushhl`.
;
; Actually two instructions are compiled, which is faster: `push
; hl` and `jp (ix)`.
;
; }doc

  _literal $E5 ; opcode `push hl`
  dw c_comma_
  dw branch_,jpnext_pfa

; ----------------------------------------------
  _colon_header jpnext_,'JPNEXT'

; doc{
;
; jpnext  ( -- )
;
; Compile a Z80 jump to `next`.
;
; }doc

  _literal $E9DD ; opcode `jp (ix)`
  dw comma_
  dw exit_

latest_nt_in_assembler_voc: equ jpnext_nt

endif

; ----------------------------------------------
; Start compiling in the `forth` vocabulary

nt_of_the_previous_word: defl 0

; ----------------------------------------------
  _colon_header asm_,'ASM'

; doc{
;
; asm  ( -- )
;
; Enter the assembler mode.
;
; }doc

  ; Credit:
  ; Idea taken from Coos Haak's Z80 Forth assembler.

  dw store_csp_
if 1 ; abase
  dw base_,fetch_,abase_,store_ ; save the current base
else
  dw base_,fetch_ ; save the current base
endif
  dw hex_
  dw also_,assembler_ ; XXX TODO better
  dw exit_

; ----------------------------------------------
  _colon_header also_,'ALSO'

; doc{
;
; also  ( -- )
;
; Duplicate the vocabulary at the top of the search order.
;
; ----
; : also  ( -- )
;   context dup cell+ [ #vocs 2- cells ] literal cmove>  ;
; ----
;
; }doc

  ; Credit:
  ; Code adapted from F83.

  ; XXX TODO -- check the limit

  dw context_,dup_,cell_plus_
  _literal (max_search_order-cell)*cell
  dw c_move_up_
  dw exit_

  ; XXX TODO rewrite after eForth:
  ; : also ( -- ) get-order over swap 1+ set-order ;

; ----------------------------------------------
  _colon_header minus_order_,'-ORDER'

; doc{
;
; -order  ( -- )
;
; Erase the search order.
;
; ----
; : -order  ( -- )
;   context [ #vocs cells ] literal erase  ;
; ----
;
; }doc


  dw context_
  _literal max_search_order*cell
  dw erase_
  dw exit_

; ----------------------------------------------
  _colon_header only_,'ONLY'

; doc{
;
; only  ( -- )
;
; Set the search order to the minimum search order: Forces the
; `root` vocabulary to be the first and second.
;
; ----
; : only  ( -- )
;   -order root also  ;
; ----
;
; }doc

  dw minus_order_,root_,also_
  dw exit_

  ; XXX TODO rewrite `only` and `set-order`?
  ; : only ( -- ) -1 set-order ;

; ----------------------------------------------
  _colon_header paren_set_order_,'(SET-ORDER)'

; doc{
;
; (set-order)  ( widn..wid1 n -- )
;
; Set the search order to the word lists identified by
; _widn..wid1_. Subsequently, word list _wid1_ will be
; searched first, and word list _widn_ searched last.
;
; }doc

; ----
; : (set-order)  ( widn..wid1 n -- )
;   0 ?do  context i cells + !  loop  ;
; ----

  _literal 0
  dw paren_question_do_,paren_set_order.loop_exit
  dw context_,i_,cells_,plus_,store_
  dw paren_loop_
paren_set_order.loop_exit
  dw exit_

; ----------------------------------------------
  _colon_header set_order_,'SET-ORDER'

; doc{
;
; set-order  ( -1 | 0 | widn..wid1 n -- )
;
; Set the search order to the word lists identified by
; _widn..wid1_. Subsequently, word list _wid1_ will be
; searched first, and word list _widn_ searched last. If _n_
; is zero, empty the search order. If _n_ is minus one, set
; the search order to the implementation-defined minimum
; search order.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : set-order  ( -1 | 0 | widn..wid1 n -- )
;   ?dup if    dup -1 = if  drop only  else  (set-order)  then
;        else  -order  then  ;
; ----
;
; }doc

  dw question_dup_
  dw zero_branch_,minus_order_pfa ; 0
  dw dup_
  _literal -1
  dw equals_
  dw zero_branch_,paren_set_order_pfa ; <>-1
  dw drop_,only_ ; -1
  dw exit_

; ----------------------------------------------
  _colon_header to_order_,'>ORDER'

; doc{
;
; >order  ( wid -- )
;
; Push _wid_ on the search order.
;
; ----
; : >order  ( wid -- )  also context !  ;
; ----
;
; Origin: Gforth.
;
; }doc

; Credit:
; Word from Gforth.

  ; XXX FIXME --

  dw also_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header previous_,'PREVIOUS'

if 1 ; XXX OLD

; doc{
;
; previous  ( -- )
;
; Remove the most recently referenced vocabulary from the search
; order.
;
; Origin: Forth-94 (SEARCH EXT), Forth-2012 (SEARCH EXT).
;
; ----
; : previous  ( -- )
;   context dup cell+ swap [ #vocs 2- cells dup ] literal cmove
;   context literal + off  ;
; ----
;
; }doc

  ; Credit:
  ; Code adapted from F83.

  dw context_,dup_,cell_plus_,swap_
  _literal (max_search_order-cell)*cell
  dw c_move_
  dw context_
  _literal (max_search_order-cell)*cell
  dw plus_,off_
  dw exit_

else ; XXX NEW

; doc{
;
; previous  ( -- )
;
; Remove the most recently referenced vocabulary from the search
; order.
;
; Origin: Forth-94 (SEARCH EXT), Forth-2012 (SEARCH EXT).
;
; ----
; : previous  ( -- )
;   get-order nip 1- set-order  ;
; ----
;
; }doc

  ; XXX TODO -- `get-order` is in the library

  dw get_order_,nip_,one_minus_,set_order_
  dw exit_

; XXX TODO -- from Gforth:
;
; : previous  ( -- )
;   vp @ 1- dup 0= -50 ?throw vp !  ;

endif

; ----------------------------------------------
  _colon_header seal_,'SEAL'

; doc{
;
; seal  ( -- )
;
; Change the search order such that only the vocabulary at the
; top of the search order will be searched.
;
; ----
; : seal  ( -- )
;   context @ -order context !  ;
; ----
;
; }doc

  ; Credit:
  ; Code adapted from F83.

  dw context_,fetch_,minus_order_,context_,store_
  dw exit_

; ----------------------------------------------
  _does_header root_,'ROOT',,do_vocabulary

  dw latest_nt_in_root_voc
root_vocabulary_link:
  dw $0000
  dw root_nt

; ----------------------------------------------
  _does_header forth_,'FORTH',,do_vocabulary

forth_wid:
  dw latest_nt_in_forth_voc
forth_vocabulary_link:
  dw root_vocabulary_link
  dw forth_nt

; ----------------------------------------------
  _constant_header forth_wordlist_,'FORTH-WORDLIST'

; doc{
;
; forth-wordlist  ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; all standard words provided by the implementation. This word
; list is initially the compilation word list and is part of the
; initial search order.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; }doc

  dw forth_wid

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _does_header assembler_,'ASSEMBLER',,do_vocabulary

  dw latest_nt_in_assembler_voc
assembler_vocabulary_link:
  dw forth_vocabulary_link
  dw assembler_nt

endif

; ----------------------------------------------
  _colon_header s_lit_,'SLIT'

; doc{
;
; slit  ( -- ca len )
;
; Return a string that is compiled after the calling word, and
; adjust the instruction pointer to step over the inline string.
;
; ----
; : slit  ( -- ca len )
;   r@ count dup 1+ r> + >r  ;
; ----
;
; }doc

  dw r_fetch_,count_,dup_,one_plus_,from_r_,plus_,to_r_
  dw exit_

; ----------------------------------------------
  _colon_header parse_string_,'PARSE-STRING'

; doc{
;
; parse-string ( compilation: c "ccc<char>" -- ) ( run-time:  -- ca len )
;
; }doc

  ; XXX WARNING -- state-smart

  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,parse_string.interpreting
  ; compiling
  dw s_literal_
  dw exit_
parse_string.interpreting:
  dw save_string_
  dw exit_

; ----------------------------------------------
  _code_header c_lit_,'CLIT',compile_only

  ld a,(bc)
  inc bc
push_a:
  ld l,a
  ld h,0
  _jp_pushhl

; ----------------------------------------------
  _code_header two_lit_,'2LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  push hl
  jp lit_

; ----------------------------------------------
  _code_header lit_,'LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  _jp_pushhl

; ----------------------------------------------
  _constant_header default_bank_hash_,'DEFAULT-BANK#'

  ; XXX TMP --

; doc{
;
; default-bank#  ( -- a )
;
; An 8-bit variable holding the value of the default bank.  Note
; this variable must be set with `c!` and fetched with `c@`.
;
; }doc

  dw address_of_default_bank

; ----------------------------------------------
  _code_header set_default_bank_,'SET-DEFAULT-BANK'

  ; XXX TMP --

; doc{
;
; set-default-bank  ( +n -- )
;
; Set _+n_ (0..7) as the default memory bank to be paged at
; $C000..0xFFFF.
;
; }doc

  pop hl
  ld a,l
  ld (address_of_default_bank),a
  _jp_next

; ----------------------------------------------
  _code_header get_default_bank_,'GET-DEFAULT-BANK'

  ; XXX TMP --

; doc{
;
; get-default-bank  ( -- +n )
;
; Get the current default bank _+n_ (0..7) paged at
; $C000..0xFFFF.
;
; }doc

  ld a,(address_of_default_bank)
  jp push_a

; ----------------------------------------------
  _code_header default_bank_,'DEFAULT-BANK'

; doc{
;
; default-bank  ( -- )
;
; Page the default memory bank in at $C000..0xFFFF.
;
; }doc

  call bank.default
  _jp_next

; ----------------------------------------------
  _code_header system_bank_,'SYSTEM-BANK'

; doc{
;
; names-bank  ( -- )
;
; Page the system bank in at $C000..0xFFFF.
; This memory bank is used to store the word names and,
; optionally, also the command line history.
;
; }doc

  call bank.system
  _jp_next

; ----------------------------------------------
  _constant_header bank_start_,'BANK-START'

; doc{
;
; bank-start  ( -- a )
;
; A constant: Memory address where banks are paged in.
;
; }doc

  dw bank_start

; ----------------------------------------------
  _code_header bank_,'BANK'

; doc{
;
; bank  ( n -- )
;
; Page memory bank _n_ (0..7) in at $C000..0xFFFF.
;
; }doc

  pop de ; E = bank
  call bank.e
  _jp_next

bank.system:
  ld e,system_bank
  jr bank.e
bank.default:
address_of_default_bank equ $+1
  ld e,default_bank
bank.e:
  ld a,(sys_bankm) ; get the saved status of BANKM
  and %11111000 ; erase bits 0-2
  or e ; modify bits 0-2
  di
  ld (sys_bankm),a ; update BANKM
  out (bank1_port),a ; page the bank
  ei
  ret

; ----------------------------------------------
  _code_header unused_csb_,'UNUSED-CSB'

; doc{
;
; csb-unused  ( -- n )
;
; Return the number of free chars in the circular string-buffer.
;
; ----
; : csb-unused  ( -- n )
;   >csb @  ;
; ----
;
; }doc

  ld hl,(to_csb)
  _jp_pushhl

; ----------------------------------------------
  _constant_header csb_size_,'CSB-SIZE'

; doc{
;
; csb-size  ( -- n )
;
; Return the size of the circular string-buffer, in chars.
;
; }doc

  dw csb_size

; ----------------------------------------------
  _constant_header to_csb_,'>CSB'

; doc{
;
; to_csb  ( -- a )
;
; Address of the circular string buffer pointer. It holds an
; offset to the first free address in the buffer; the offset
; coincides with the number of free chars.
;
; }doc

  dw to_csb

; ----------------------------------------------
  _constant_header csb0_,'CSB0'

; doc{
;
; csb0  ( -- a )
;
; Address of the data space of the circular string buffer.
;
; }doc

  dw csb0

; ----------------------------------------------
  _colon_header question_csb_,'?CSB'

; doc{
;
; ?csb  ( len -- )
;
; Make sure there's room in the circular string buffer for the
; given characters.
;
; ----
; : ?csb  ( len -- )
;   dup unused-csb >  \ not enough free space?
;   if  csb-size >csb !  then  negate >csb +!  ;
; ----
; }doc

  ; XXX TODO -- rename to `csb-room` or something

  dw dup_,unused_csb_,greater_than_
  dw zero_branch_,question_csb_.enough
  ; not enough space
  dw csb_size_,to_csb_,store_ ; reset the pointer ; XXX TODO -- factor out

question_csb_.enough:
  dw negate_,to_csb_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header allocate_string_,'ALLOCATE-STRING'

; doc{
;
; allocate-string  ( len -- ca )

; Allocate _len_ chars in the circular string buffer and return
; the address _ca_ of the allocated space.
;
; ----
; : allocate-string  ( len -- ca )
;   ?csb csb0 unused-csb +  ;
; ----
;
; }doc

  dw question_csb_
  dw csb0_,unused_csb_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header save_string_,'SAVE-STRING'

; doc{
;
; save-string  ( ca1 len1 -- ca2 len1 )

; Save the string _ca1 len1_ in the circular string buffer and
; return it at its new address.
;
; ----
; : save-string  ( ca1 len1 -- ca2 len1 )
;   dup allocate-string swap 2dup 2>r move 2r>  ;
; ----
;
; }doc

  dw dup_,allocate_string_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw exit_

; ----------------------------------------------
  _colon_header empty_csb_,'EMPTY-CSB'

; doc{
;
; empty-csb  ( -- )
;
; Empty the circular string buffer.
;
; }doc

  _literal csb
  _literal csb_total_size
  dw erase_
  dw exit_

; ----------------------------------------------
  _code_header execute_,'EXECUTE'

; doc{
;
; execute  ( xt  -- )
;
; }doc

  pop hl
  jp (hl)

; ----------------------------------------------
  _code_header perform_,'PERFORM'

; doc{
;
; perform  ( a  -- )
;
; Execute the word whose xt is stored in _a_.  Do nothing if
; the content of _a_ is zero.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp nz,execute_hl
  _jp_next

; ----------------------------------------------
  _colon_header forward_mark_,'>MARK'

; doc{
;
; >mark  ( -- orig )
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; Origin: Forth-83.
;
; }doc

  dw here_,zero_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLVE'

; doc{
;
; >resolve  ( orig -- )
;
; Resolve a forward branch by placing the address of the current
; data-space pointer into the space compiled by `>mark`.
;
; Origin: Forth-83.
;
; }doc

  dw here_,swap_,store_
  dw exit_

; ----------------------------------------------
  _alias_header backward_mark_,'<MARK',,here_

; doc{
;
; <mark  ( -- a )
;
; Leave the address of the current data-space pointer, as the
; the destination of a backward branch.  _a_ is typically
; only used by `<resolve` to compile a branch address.
;
; Origin: Forth-83 (System Extension Word Set).
;
; }doc

; ----------------------------------------------
  _alias_header backward_resolve_,'<RESOLVE',,comma_

; doc{
;
; <resolve  ( dest -- )
;
; Resolve a backward branch.  Compile a branch address using
; _dest_, the address left by `<mark`,  as the destination
; address.  Used at the source of a backward branch after either
; `branch` or `?branch` or `0branch`.
;
; Origin: Forth-83.
;
; }doc

; ----------------------------------------------
  _code_header branch_,'BRANCH'

; doc{
;
; branch  ( -- )
;
; The run-time procedure to branch unconditionally. The
; following in-line address is copied to IP to branch forward or
; backward.
;
; Origin: Forth-83 (System Extension Word Set).
;
; }doc

  ld h,b
  ld l,c ; hl = Forth IP, containing the address to jump to
  ld c,(hl)
  inc hl
  ld b,(hl) ; bc = New Forth IP
  _jp_next

; ----------------------------------------------
  _code_header zero_branch_,'0BRANCH'

; doc{
;
; 0branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_
; is false (zero), the following in-line address is copied to IP
; to branch forward or backward.
;
; Origin: fig-Forth.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_ ; branch if zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANCH'

; doc{
;
; ?branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ is not
; false (not zero), the following in-line address is copied to
; IP to branch forward or backward.
;
; Note: This is not Forth-83's `?branch`, which is equivalent to
; '0branch` in fig-Forth's and Solo Forth.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_ ; branch if not zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header unloop_,'UNLOOP'

; doc{
;
; unloop  ( -- ) ( R: loop-sys -- )
;
; Discard the loop-control parameters for the current nesting
; level. An `unloop` is required for each nesting level before
; the definition may be exited with `exit`. An ambiguous
; condition exists if the loop-control parameters are
; unavailable.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*3
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header paren_question_do_,'(?DO)'

  ; Credit:
  ; Code based on Spectrum Forth-83.

  pop hl
  pop de
  and a
  sbc hl,de
  jp z,branch_
  add hl,de  ; reverse the substraction
  jp paren_do.de_hl

; ----------------------------------------------
  _colon_header question_do_,'?DO',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; ?do  ( n1 n2 -- )
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; ----
; : ?do  ( n1 n2 -- )
;   postpone (?do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_question_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header do_,'DO',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; do  ( n1 n2 -- )
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; ----
; : do  ( n1 n2 -- )
;   postpone (do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate+compile_only

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Origin: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_plus_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  pop hl                        ; init
  pop de                        ; limit
paren_do.de_hl:
  push hl
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push limit on return stack
  inc bc
  inc bc                        ; skip branch address
  dec hl
  ld (hl),B
  dec hl
  ld (hl),c                     ; push IP on return stack
  ex (sp),hl                    ; hl=init, (sp)=rp@
  and a
  sbc hl,de                     ; hl=init-limit
  ld a,h
  xor $80                      ; flip most significant bit
  ld d,a
  ld e,l
  pop hl                        ; hl=rp@
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e                     ; push (init-limit) xor $8000 on return stack
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header i_,'I'

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
i.hl: ; entry point for `j` and `k`
  ld e,(hl)
  inc hl
  ld d,(hl) ; de= current index, wich is: (index-limit) xor $8000
  inc hl
  inc hl
  inc hl
  ld a,(hl)
  add a,e   ; read limit and add to index
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  xor $80  ; flip most significant bit, getting true index value
  ld d,a
  push de ; result
  _jp_next

; doc{
;
; i  ( -- n|u ) ( R: do-sys -- do-sys )
;
; Return a copy of the current (innermost) loop index.
;
; Origin: Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _constant_header paren_i,'(I)'

; doc{
;
; (i)  ( -- a )
;
; A constant that holds the address of the machine code entry
; point of `i` that calculates the `do` index from the address
; pointed by the HL register. Used by `j` and `k`.
;
; }doc

  dw i.hl

; ----------------------------------------------
  _code_header j_,'J'

  ld hl,(return_stack_pointer)
  ld de,3*cell
  add hl,de
  jp i.hl

; ----------------------------------------------
  _code_header k_,'K'

  ld hl,(return_stack_pointer)
  ld de,6*cell
  add hl,de
  jp i.hl

; ----------------------------------------------
  _code_header question_leave_,'?LEAVE'

; doc{
;
; ?leave  ( f -- ) ( R: loop-sys -- | loop-sys )
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,leave_
  _jp_next

; ----------------------------------------------
  _code_header leave_,'LEAVE'

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; bc = start address
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl ; write updated return stack pointer (6 was added)
  dec bc
  dec bc ; point IP to forward branch address
  jp branch_

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; de = current index
  ex (sp),hl  ; hl = the increment value

  and a
  adc hl,de   ; add increment to index
  ; Note: `and a` and `adc` are used because `add` does not affect the po flag
  jp po,paren_plus_loop.continue

  ; If overflow, then boundary between limit-1 and limit is
  ; crossed, terminate loop.

  pop hl ; return stack pointer
  ld de,$0005
  add hl,de
  ld (return_stack_pointer),hl
  ; Increment return stack pointer by 5 (1 increment already done)
  _jp_next

paren_plus_loop.continue:
  ld d,h
  ld e,l ; de = updated index
  pop hl ; return stack pointer

paren_loop.continue:

  ld (hl),d
  dec hl
  ld (hl),e  ; update the index on the return stack
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; IP = start address, repeat loop
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

  ; Credit:
  ; Code adapted from spectrum Forth-83.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; de = index value
  inc de      ; increment the index
  ld a,d
  xor $80
  or e        ; index=$8000?
  jp nz,paren_loop.continue

  ; limit reached
  ld de,$0005
  add hl,de ; increment RP by 5 (1 already done)
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header digit_question_,'DIGIT?'

; doc{
;
; digit?  ( c n -- u true | false )
;
; Convert the ascii character _c_ (using base _n_) to its binary
; equivalent _u_, accompanied by a true flag. If the conversion
; is invalid, leave only a false flag.
;
; Note: This word is equivalent to fig-Forth's `digit`.
;
; }doc

; XXX Note: alternative implementation in CamelForth:
;
;   \ silly looking but it works!
;   DUP $39 > $100 AND +
;   DUP $140 > $107 AND - $30 -
;   DUP BASE @ U< ;

  pop hl  ; l=base
  pop de  ; e=character
  ld a,e  ; character
  call ascii_upper.a
  sub '0' ; >="0"?
  jp c,false_ ; <"0" is invalid
  cp $0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub $07 ; gap between "9" & "A", now "A"=$0A
  cp $0A ; >="A"?
  jp c,false_ ; characters between "9" & "A" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_ ; no, invalid
  ld e,a ; converted digit
  push de
  jp true_

; ----------------------------------------------
  _colon_header number_base_,'NUMBER-BASE'

; doc{
;
; number-base  ( ca len -- ca' len' n )
;
; If the first char of string _ca len_ is a radix prefix, return
; its value _n_ and the updated string _ca' len'_ (which does
; not include the radix prefix).  Otherwise return _ca len_
; untouched and the current value of `base`.
;
; ----
; : number-base  ( ca len -- ca' len' n )
;   dup if
;    over c@
;    dup [char] $ = if  drop 1 /string 16  exit  then
;    dup [char] % = if  drop 1 /string  2  exit  then
;        [char] # = if       1 /string 10  exit  then
;   then
;   base @  ;
; ----
;
; }doc

number_base.try_hex:
  dw dup_
  dw zero_branch_,number_base.current
  dw over_,c_fetch_
  dw dup_
  _literal '$'
  dw equals_,zero_branch_,number_base.try_binary
  dw drop_
  _literal 1
  dw slash_string_
  _literal 16
  dw exit_
number_base.try_binary:
  dw dup_
  _literal '%'
  dw equals_,zero_branch_,number_base.try_decimal
  dw drop_
  _literal 1
  dw slash_string_
  _literal 2
  dw exit_
number_base.try_decimal:
  _literal '#'
  dw equals_,zero_branch_,number_base.current
  _literal 1
  dw slash_string_
  _literal 10
  dw exit_
number_base.current:
  dw base_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header to_number_,'>NUMBER'

; doc{
;
; >number  ( ud1 ca1 len1 -- ud2 ca2 len2 )

; _ud2_ is the unsigned result of converting the characters
; within the string specified by _ca1 len1_ into digits, using
; the number in `base`, and adding each into _ud1_ after
; multiplying _ud1_ by the number in `base`. Conversion
; continues left-to-right until a character that is not
; convertible, including any "+" or "-", is encountered or the
; string is entirely converted. _ca2_ is the location of the
; first unconverted character or the first character past the
; end of the string if the string was entirely converted. _len2_
; is the number of unconverted characters in the string.

; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : >number  ( d1 ca1 len1 -- d2 ca2 len2 )
;   begin  dup  while
;     over c@ base @ digit? while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string
;        \ 1 dpl +! \ XXX TODO
;   repeat then  ;
; ----
;
;
; }doc

; XXX TODO -- check:
; An ambiguous condition exists if _ud2_ overflows during the
; conversion.

  ; Credit:
  ; Code from DZX-Forth.

to_number.begin: ; begin
  dw dup_
  dw zero_branch_,to_number.end  ; while
; _chk '>number -- before digit' ; XXX INFORMER
  dw over_,c_fetch_,base_,fetch_,digit_question_
; _chk '>number -- after digit' ; XXX INFORMER
  dw zero_branch_,to_number.end  ; while
  dw to_r_,two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw u_m_star_,drop_
  dw rot_
  dw base_,fetch_
  dw u_m_star_
  dw d_plus_
  dw two_swap_
  dw one_,slash_string_
  ; dw one_,dpl_,plus_store_ ; XXX TODO why this?
  dw branch_,to_number.begin  ; repeat
to_number.end:
  ; then
  dw exit_

; ----------------------------------------------
  _defer_header number_point_question_,'NUMBER-POINT?',,standard_number_point_question_

; doc{
;
; number-point?  ( c -- f )
;
; Is character _c_ a valid point in a number?  This is a
; deferred word used in `number?`. Its default behaviour is
; `standard-number-point?`, which only allows the period.
;
; The library provides alternatives which accept more points.
;
; }doc

; ----------------------------------------------
  _colon_header standard_number_point_question_,'STANDARD-NUMBER-POINT?'

; doc{
;
; standard-number-point?  ( c -- f )
;
; Is character _c_ a valid point in a number?  The only allowed
; point is period.
;
; This is the default behaviour of the deferred word
; `number-point?`, which is used in `number?`.
;
; The library provides alternatives which accept more points.

; ----
; : number-point?  ( c -- f )
;   [char] . =  ;
; ----
;
; }doc

; Credit:
;

  _literal '.'
  dw equals_
  dw exit_

; ----------------------------------------------
  _colon_header number_question_,'NUMBER?'

  ; XXX TODO make it a deferred word

; doc{
;
; number?   ( ca len -- 0 | n 1 | d 2 )
;
; Convert a string _ca len_ to a number. Return 0 if the
; conversion is not possible. If the result is a single number,
; return _n_ and 1. If the result is a double number, return _d_
; and 2.
;
; This word accepts valid point anywhere on the number and
; updates `dpl` with the position of the last one. If no
; point is found, `dpl` contains -1.
;
; Chars between single quotes are recognized, after Forth-2012.

; ----
; : number?   ( ca len -- 0 | n 1 | d 2 )
;
;   dup 0= if  2drop 0 exit  then  \ reject empty strings
;
;   2dup char? if  nip nip 1 exit  then  \ char format
;
;   over c@ number-point?  \ first char is a point?
;   if  2drop 0 exit  then  \ is so, reject the string
;
;   base @ >r  number-base base !  ( R: radix )
;   skip-sign? >r                  ( R: radix sign )
;   0 0 2swap  dpl on
;
;   begin  ( d ca len )  >number dup  while
;
;     over c@ number-point? 0=   \ invalid point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup dpl @ =   \ previous char was a point?
;     if  2drop 2drop rdrop r> base ! 0 exit  then
;
;     dup 1- dpl !  \ update the position of the last point
;     1 /string     \ skip the point
;
;   repeat
;
;   2drop                     \ discard the empty string
;   dpl @ 0<                  \ single-cell number?
;   if    d>s r> ?negate  1   \ single-cell number
;   else  r> ?dnegate  2      \ double-cell number
;   then  r> base !  ;        \ restore the radix
; ----

; }doc

  dw dup_,zero_equals_ ; empty string?
  dw zero_branch_,number_question.try_char
  ; reject an empty string
number_question.reject:
  dw two_drop_,false_
  dw exit_

number_question.try_char:
  dw two_dup_,char_question_ ; a char?
  dw zero_branch_,number_question.try_initial_point
  ; return the char code
  dw nip_,nip_
  _literal 1
  dw exit_

number_question.try_initial_point:
  dw over_,c_fetch_ ; first char...
  dw number_point_question_ ; ...is point?
  dw question_branch_,number_question.reject ; is so, reject the string

  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  dw two_lit_,0,0 ; initial value
  dw two_swap_,dpl_,on_

number_question.begin:
  dw to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question.done ; while

  ; The conversion was not completed, so it may be because of a
  ; point that indicates it's a double number.

  dw over_,c_fetch_ ; get the non-digit character
  dw number_point_question_ ; is it valid point?
  dw question_branch_,number_question.point

number_question.invalid_character:
  dw two_drop_,two_drop_,r_drop_,false_
  dw branch_,number_question.end

number_question.point:
  dw dup_,dpl_,fetch_,equals_ ; was the previous character a point?
  dw question_branch_,number_question.invalid_character ; if so, invalid

number_question.valid_point:
  dw dup_,one_minus_,dpl_,store_ ; update the position of the last point
  _literal 1
  dw slash_string_ ; skip the point

  dw branch_,number_question.begin ; repeat

number_question.done:
  dw two_drop_ ; discard the empty string
  dw dpl_,fetch_,zero_less_than_ ; single-cell number?
  dw zero_branch_,number_question.double

  ; single-cell number
  dw d_to_s_,from_r_,question_negate_
  _literal 1
  dw branch_,number_question.end

number_question.double:
  ; double-cell number
  dw from_r_,question_d_negate_
  _literal 2

number_question.end:
  dw from_r_,base_,store_  ; restore `base`

  dw exit_

; ----------------------------------------------
  _colon_header char_question_,'CHAR?'

; doc{
;
; char?  ( ca len -- c true | false )
;
; Is the string _ca len_ the representation of a character?
; If so return the character _c_ and _true_; else return
; _false_.
;
; ----
; : char?  ( ca len -- c true | false )
;   3 = if
;     dup c@ [char] ' <> if
;       dup [ 2 chars ] literal + c@ [char] ' <>
;       if  char+ c@ true exit  then
;     then
;   then
;   drop false ;
; ----
;
; }doc

  _literal 3
  dw equals_
  dw zero_branch_,char_question.not

char_question.right_length:
  dw dup_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.first_quote:
  dw dup_,two_plus_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.match:
  dw char_plus_,c_fetch_,true_,exit_

char_question.not:
  dw drop_,false_,exit_
  dw exit_

; ----------------------------------------------
  _colon_header skip_sign_question_,'SKIP-SIGN?'

; : sign?  ( ca len -- ca' len' f )
;   over c@ [char] - = dup >r abs /string r>  ;
;   \ get optional sign
;   \ ca len = number
;   \ ca' len' = number without the minus sign
;   \ f = negative number?

  ; Credit:
  ; Code adapted from CamelForth.

  dw over_,c_fetch_
  _literal '-'
  dw equals_,dup_,to_r_,abs_
  dw slash_string_,from_r_
  dw exit_

; ----------------------------------------------
  _code_header find_name_from_,'FIND-NAME-FROM'

; doc{
;
; find-name-from  ( ca len nt -- nt | 0 )
;
; Find the definition named in the string at _ca len_, starting
; at _nt_. If the definition is found, return its _nt_, else
; return zero.
;
; The search is case-sensitive.
;
; }doc

  ld (find_name_from.ip_backup),bc ; save the Forth IP

  call bank.system ; page the memory bank in

  pop hl ; nt
  pop bc ; C=len, B is supposed to be 0
  ld a,c
  ld (find_name_from.string_length),a
  pop de ; ca
  ld (find_name_from.string_address),de

  ; XXX FIXME the string searched for must be in the string
  ; buffer, below $C000! This is not a problem now, during the
  ; development, because the dictionary is small.

find_name_from.begin:
  ; Compare the string with a new word.
  ; hl = nt
  ld (find_name_from.nt_backup),hl ; save the nt for later
find_name_from.string_address: equ $+1
  ld de,$0000 ; string address
  ld a,(hl) ; length byte of the name field
  and valid_word_length_mask  ; mask the length and the smudge bit
find_name_from.string_length: equ $+1
  ld c,$00 ; length of the string
  cp c ; same length?
  jr nz,find_name_from.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  inc hl ; point to the first char of the name in the dictionary
find_name_from.compare_next_char:
  ld a,(de)
  call ascii_upper.a ; XXX NEW experimental
  cpi
  inc de ; point to next character of the string
  jp nz,find_name_from.not_a_match ; mismatch
  jp pe, find_name_from.compare_next_char ; count not exhausted

  ; The string matches.
  ld hl,(find_name_from.nt_backup)
  jr find_name_from.end

find_name_from.not_a_match:
  ; Not a match, try the next word.

find_name_from.nt_backup: equ $+1
                                        ;  T  B
  ld hl,$0000 ; nt                      10 03
  dec hl ; high address of lfa            06 01
  ld d,(hl) ; high part of the next nt    07 01
  dec hl ; low address of lfa             06 01
  ld e,(hl) ; low part of the next nt     07 01
  ex de,hl                              ; 04 01
  ld a,h                                ; 04 01
  or l ; end of dictionary? (next nt=0)   04 01
                                        ; 48 10 TOTAL

  jp nz,find_name_from.begin ; if not, continue

  ; End of dictionary, no match found.
  ld hl,false

find_name_from.end:
  ; If match found:
  ;   hl = nt
  ; If no match found:
  ;   hl = false
  exx
  call bank.default ; page the default memory bank in
  exx
find_name_from.ip_backup: equ $+1
  ld bc,$0000 ; restore the Forth IP
  _jp_pushhl

; ----------------------------------------------
  _colon_header search_wordlist_,'SEARCH-WORDLIST'

; doc{
;
; search-wordlist  ( ca len wid -- 0 | xt 1 | xt -1 )
;
; Find the definition identified by the string _ca len_ in the
; word list identified by _wid_. If the definition is not found,
; return zero. If the definition is found, return its _xt_ and
; one (1) if the definition is immediate, minus-one (-1)
; otherwise.
;
; The search is case-insensitive.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : search-wordlist  ( ca len wid -- 0 | xt 1 | xt -1 )
;   @ find-name-from dup 0= ?exit
;   name>immediate? 0= 1 or  ;
; ----
;
; }doc

  ; XXX -- can not be moved to the library because `header` uses
  ; it.

  dw fetch_,find_name_from_  ; ( nt | 0 )
  dw dup_,zero_equals_  ; ( nt false | 0 true )
  dw question_exit_  ; ( nt )
  dw name_to_immediate_question_ ; ( xt f )
  dw zero_equals_
  _literal 1
  dw or_ ; ( xt 1 | xt -1 )
  dw exit_

; ----------------------------------------------
  _colon_header find_name_,'FIND-NAME'

; doc{

; find-name  ( ca len -- nt | 0 )
;
; Find the definition identified by the string _ca len_ in the
; current search order. If the definition is not found after
; searching all the vocabularies in the search order, return
; zero.  If the definition is found, return its _nt_.
;
; The search is case-insensitive.
;
; ----
; : find-name  ( ca len -- nt | 0 )
;   2dup uppers
;   #vocs 0 do
;     context i cells + @  ?dup
;     if  @ >r 2dup r> @ find-name-from ?dup
;         ( ca len nt nt | ca len 0 )
;         if  nip nip unloop exit  then
;     then
;   loop  2drop false  ;
; ----
;
; Origin: Gforth.
;
; }doc

;  _chk_type 'find-name -- start' ; XXX INFORMER
  dw hash_vocs_,zero_
  dw paren_do_,find_name.loop_exit ; do

  ; ( ca len )
  dw context_,i_,cells_,plus_,fetch_
  dw question_dup_ ; a vocabulary in the search order?

  dw zero_branch_,find_name.loop ; if not, next
  ; ( ca len wid )
  ; valid vocabulary in the search order
  dw fetch_,to_r_,two_dup_,from_r_
;  _chk 'find-name -- before find-name-from' ; XXX INFORMER
  dw find_name_from_,question_dup_ ; ( nt nt | 0 ) word found?
  dw zero_branch_,find_name.loop
;  _chk 'find-name -- found' ; XXX INFORMER
  dw nip_,nip_,unloop_,exit_
find_name.loop:
  dw paren_loop_ ; loop
find_name.loop_exit:

  dw two_drop_,false_
  dw exit_

; ----------------------------------------------
  _code_header scan_,'SCAN'

; doc{
;
; scan  ( ca1 len1 c -- ca2 len2 )
;
; Scan the string _ca1 len1_ for the first occurence of
; character _c_.  Leave match address _ca2_ and length remaining
; _len2_.  If no match occurred then _len2_ is zero and _ca2_ is
; _ca1+len1_.
;
; }doc

  exx
  pop de ; E = char searched for
  pop bc ; len1, count
  ld a,c
  or b ; empty string?
  jr z,scan.nothing ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
  cpir ; scan until match or count=0
  jr nz,scan.no_match
  dec hl ; point to match char
  inc bc ; adjust the count
scan.no_match:
  push hl
scan.nothing:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header skip_,'SKIP'

; doc{
;
; skip  ( ca1 len1 c -- ca2 len2 | ca1 len1 )
;
; Skip over leading occurences of the character _c_ in the string
; _ca1 len1_.  Leave the address of the first non-matching
; character _ca2_ and length remaining _len2_.  If no characters were
; skipped leave _ca1 len1_.
;
; }doc

; Credit:
; Code adapted and modified from CamelForth.

  exx
  pop de ; E = char searched for
  pop bc ; len1
  ld a,c
  or b ; empty string?
  jr z,skip.end ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
skip.begin:
  cpi
  jr nz,skip.mismatch ; char mismatch, exit
  jp pe,skip.begin ; count not exhausted
  jr skip.done ; count 0, no mismatch
skip.mismatch:
  dec hl ; point at mismatch char
  inc bc ; adjust the count
skip.done:
  push hl
skip.end:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header chan_,'CHAN'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
  ; Credit:
  ; Code from Spectrum Forth-83.

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header mode32_emit_,'MODE32-EMIT'

; doc{
;
; mode32-emit  ( b -- )
;
; Send the character _b_ to the current channel.
;
; }doc

if 0

  ; Credit:
  ; Code from Spectrum Forth-83's `TOCH`.


  ; XXX default printing system, with the ZX Spectrum charset
  ; XXX OLD

  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),$FF ; no scroll message
  rst $10
  _jp_next

endif

if 0

  ; XXX alternative 1

  ; XXX OLD -- this uses UDG as a fake charset, but it can not
  ; work fine, because block chars and UDG are shown anyway,
  ; with higher codes.

  pop hl
  ld a,l
  ld hl,(sys_chars)
  push hl
  cp 128
  jr c,mode32_emit.print_a
  sub 96
  ld hl,(sys_udg)
  dec h
  ld (sys_chars),hl
mode32_emit.print_a
  ld (iy+sys_scr_ct_offset),$FF ; no scroll message
  rst $10
  pop hl
  ld (sys_chars),hl
  _jp_next

endif

if 0

  ; XXX alternative 2
  ; XXX OLD
  ; the coords get wrong after printing UDGs and scrolling

  pop hl
  push bc

  ld (iy+sys_scr_ct_offset),$FF ; no scroll message

  ld a,l
  cp 128 ; control or ASCII character?
  jp nc,mode32_emit.print_udg ; is not, jump

  ; use the ROM routine to print a control or ASCII character
  rst $10
  pop bc
  _jp_next

mode32_emit.print_udg:
  ; hl = UDG code (128..255)
  sub 128
  ld l,a ; hl = UDG index code (0..127)
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; de = char address in the font
  ld hl,(sys_df_cc) ; current screen address
  ld b,8 ; char scans
mode32_emit.print_udg_scan
  ld a,(de) ; get UDG scan
  ld (hl),a ; put it on the screen
  inc de ; address of next scan of the UDG
  inc h ; address of next pixel row on the screen
  djnz mode32_emit.print_udg_scan

  ; Update
  ld de,(sys_s_posn)
  ld hl,$1821 ; $18 = 24 - row
               ; $21 = 33 - column
  sbc hl,de
  ex de,hl
  inc e
  ld a,e
  cp 32 ; last col?
  jp c,mode32_emit.update2 ; if not, jump
  ; last col
  ld e,0
  inc d
  ld a,d
  cp 23 ; last row?
  jp c,mode32_emit.update2 ; if not, jump
  ; last row
  call $0DFE ; ROM scroll routine
  ; XXX FIXME wrong coords after the scroll
  ld de, $1400

mode32_emit.update2:
  push de
  ld a,d
  and $07
  rrca
  rrca
  rrca
  or e
  ld e,a
  ld a,d
  and $18
  or $40
  ld d,a
  ld (sys_df_cc),de
  pop de
  ld hl,$1821 ; $18 = 24 - row
               ; $21 = 33 - column
  sbc hl,de
  ld (sys_s_posn),hl
  pop bc
  _jp_next

endif

if 1

  ; XXX alternative 3

  pop hl
  ; h = 0
  ; l = character code
  push bc

  ld (iy+sys_scr_ct_offset),$FF ; no scroll message

  ld a,l
  cp 128 ; control or ASCII character?
  jp nc,emit_udg.a ; if not, jump

  ; use the ROM routine to print a control or ASCII character
  rst $10
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header emit_udg_,'EMIT-UDG'

; doc{
;
; emit-udg  ( b -- )
;
; Print the User Defined Character _b_ (128..255).
;
; }doc

  pop hl
  push bc
  ; h = 0
  ld a,l

emit_udg.a
  ; a = UDG code (128..255)
  ; h = 0
  sub 128
  ld l,a ; hl = UDG index code (0..127)
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; de = char address in the font
  ld bc,(sys_s_posn) ; cursor position
  ld hl,(sys_df_cc) ; current screen address
  call rom_pr_all
  ld (sys_s_posn),bc
  ld (sys_df_cc),hl
  pop bc
  _jp_next

endif

; ----------------------------------------------
  _defer_header emit_,'EMIT',,mode32_emit_

; XXX TODO -- Add multitasker's `pause` when available.

; ----------------------------------------------
  _variable_header printing_,'PRINTING'

; XXX TODO -- make it a user variable?
; but the open channel would be common!

  dw false

; ----------------------------------------------
  _colon_header printer_,'PRINTER'

; doc{
;
; printer  ( -- )
;
; Select the printer as output.
;
; }doc

; XXX TODO -- move to the library?

  _literal 3
  dw chan_
  dw printing_,on_
  dw exit_

; ----------------------------------------------
  _colon_header display_,'DISPLAY'

; doc{
;
; display  ( -- )
;
; Select the display as output.
;
; }doc

  _literal 2
  dw chan_
  dw printing_,off_
  dw exit_

; ----------------------------------------------
  _variable_header key_translation_table_,'KEY-TRANSLATION-TABLE'

; doc{
;
; key-translation-table  ( -- a )
;
; A variable that holds the address of the current key
; translation table, used by `key`.
;
; The table consists of pairs of characters. The first one is
; the character that has to be translated and the second one is
; its translation. The table is finished with a zero.
;
; The default table makes it possible to access the following
; chars with Symbol Shift: '[', ']', '~', '|', '\', '{' and '}'.
;
; }doc

  dw default_key_translation_table

default_key_translation_table:

;  dw 0 ; no chained table ; XXX TODO
              ; Symbol Shift + Letter --> new char
  db $C6,'[' ; "Y" 198 ($C6) "AND"  --> 091 ($5B) "["
  db $C5,']' ; "U" 197 ($C5) "OR"   --> 093 ($5D) "]"
  db $E2,'~' ; "A" 226 ($E2) "STOP" --> 126 ($7E) "~"
  db $C3,'|' ; "S" 195 ($C3) "NOT"  --> 124 ($7C) "|"
  db $CD,'\' ; "D" 205 ($CD) "STEP" --> 092 ($5C) "\"
  db $CC,'{' ; "F" 204 ($CC) "TO"   --> 123 ($7B) "{"
  db $CB,'}' ; "G" 203 ($CB) "THEN" --> 125 ($7D) "}"
  db 0 ; end of data

  ; "I" 172 ($AC) "AT"   --> 127 ($7F) "(C)" ; XXX TODO

; ----------------------------------------------
  _code_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c1 | c2 )
;
; Translate char _c1_ using the current keyboard decoding table,
; pointed by `key-translation-table`.
;
; }doc

  pop de
  ld a,e
  call translate_char.a
  jp push_a

translate_char.a:
  ld hl,(key_translation_table_pfa)
  dec hl
translate_char.begin:
  inc hl    ; next record of the table
  ld e,(hl) ; char that must be translated, or zero
  inc e     ; is it...
  dec e     ; zero? (=end of table?)
  ret z
  cp e      ; match?
  inc hl    ; point to the char transalation
  jr nz,translate_char.begin ; no match yet, continue
  ; match
  ld a,(hl) ; translate char
  ret

if 0 ; XXX UNDER DEVELOPMENT

  ; improved version with support for chained tables

; ----------------------------------------------
  _colon_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c2 )
;
; }doc

  ; XXX TODO

  dw key_translation_table_
  dw fetch_
  dw question_dup_
  dw zero_

translate_char.do_it
  dw cell_plus_
  dw paren_translate_char_
  dw exit_

; ----------------------------------------------
  _code_header paren_translate_char_,'(TRANSLATE-CHAR)'

; doc{
;
; (translate-char)  ( c1 ca -- c1 false | c2 true )
;
; }doc

  pop hl  ; ca
  pop de  ; c1
  push de ; keep c1 on the stack, as default
  dec hl

translate_char.begin:
  inc hl
  ld a,(hl)
  and a ; end of table?
  jp z,false_ ; no match found
  cp e
  inc hl
  jr nz,translate_char.begin

  ; match found
  ld e,(hl)
translate_char.end:
  pop hl  ; discard c1
  push de
  jp true_

endif

; ----------------------------------------------
  ; _code_header paren_key_,'(KEY)'

  ; XXX not used yet

  ; ld a,(sys_last_k)
  ; ld (previous_key),a
; paren_key_.begin:
  ; ; call pause ; XXX TODO
  ; ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ; ld a,(sys_last_k)
; previous_key: equ $+1
  ; cp 0 ; a different key?
  ; jp z,paren_key_.begin
  ; ld h,0
  ; ld l,a
  ; xor a
  ; ld (sys_last_k),a ; delete the last key
  ; push hl
  ; jp translate_char_

; ----------------------------------------------
  _code_header default_break_key_question_,'DEFAULT-BREAK-KEY?'

; doc{
;
; default-break-key?  ( -- f )
;
; Is the default break key (Shift+Space) pressed?
;
; }doc

  call rom_break_key
  jp nc,true_
  jp false_

; ----------------------------------------------
  _defer_header break_key_question_,'BREAK-KEY?',,default_break_key_question_

; doc{
;
; break-key?  ( -- f )
;
; Is the break key pressed? This is a deferred work that bye
; default checks the standard break key (Shift+Space).
;
; }doc

; ----------------------------------------------
  _code_header key_question_,'KEY?'

; doc{
;
; key?  ( -- wf )
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

  ; XXX -- This version works only when the system interrupts
  ; are on.

  bit 5,(iy+$01) ; new key available? (system variable FLAGS)
  jp z,false_
  jp true_

; ----------------------------------------------
  _variable_header cursor_char_,'CURSOR-CHAR'

; doc{
;
; cursor-char  ( -- a )
;
; A byte variable that holds the character code of the cursor
; used by `xkey`. Note this is a _byte_ variable, thus it has to
; be fetched with `c@` and modified with `c!`.
;
; }doc

  db $5F ; char code

; ----------------------------------------------
  _code_header key_,'KEY'

; doc{
;
; key  ( -- c )
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 1
  call wait_for_a_key
  call translate_char.a ; XXX TODO
  jp push_a
endif

if 0 ; XXX OLD

key.begin:
if 0
  ld a,(sys_last_k)
  and a
else
  bit 5,(iy+$01) ; system variable FLAGS
endif
  jr z,key.begin
  ld hl,sys_last_k
  ld (hl),0
  jp push_a

endif

if 0 ; XXX OLD

; XXX -- This version works also when the system interrupts are off.
; XXX TODO -- Add multitasker's `pause` when available.

  ; XXX TODO move to the library; rename to `get-key`?

  push bc
key.begin:
  call rom_key_scan
  jr nz,key.begin
  call rom_key_test
  jr nc,key.begin
  dec d
  ld e,a
  call rom_key_decode
key.end:
  ld hl,sys_last_k
  ld (hl),0
  ld ix,next ; XXX TMP
  pop bc
  jp push_a

endif

; ----------------------------------------------
  _code_header xkey_,'XKEY'

; doc{
;
; xkey  ( -- c )
;
; Show a cursor, wait for the next terminal key struck; if it's
; the caps lock key, toggle caps and keep waiting; else leave
; the char code of the key struck.
;
; }doc

  ; XXX TODO -- rename to `a[ccept]key`, `c[aps]key`, `m[ode]key`?
  ; XXX TODO -- rewrite in Forth and move to the library

  push bc

  ; Print cursor:
  ld a,(cursor_char_pfa) ; cursor char code
  rst $10
  ld a,backspace_char
  rst $10

xkey.new_key:
  call wait_for_a_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,xkey.translate
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,$08
  xor (hl)
  ld (hl),a
  jr xkey.new_key

xkey.translate:
  ; Translate some chars
  call translate_char.a ; XXX TMP
  ld l,a
  ld h,$00

  ; delete the cursor
  ld a,space_char
  rst $10
  ld a,backspace_char
  rst $10

  pop bc
  _jp_pushhl

if 0

  ; XXX OLD

wait_for_a_key:
  ; call delete_last_key ; XXX OLD -- not Forth-94
wait_for_a_key.begin:
  ld a,(sys_last_k)
  and a
  jr z,wait_for_a_key.begin
delete_last_key:
  push af
  xor a
  ld (sys_last_k),a
  pop af
  ret

else

  ; XXX NEW
  ; XXX TODO -- change this into a code word
  ; XXX TODO -- make it compatible with the future multitasking

wait_for_a_key:
  bit 5,(iy+1) ; bit 5 of FLAGS?: new key available?
  jr z,wait_for_a_key
  ld a,(sys_last_k)
  res 5,(iy+1) ; no new key available anymore
  ret

endif

; ----------------------------------------------
  _colon_header paren_cr_,'(CR)'

  _literal carriage_return_char
  dw emit_,hash_emit_,off_ ; XXX OLD
  dw exit_

; ----------------------------------------------
  _defer_header cr_,'CR',,paren_cr_

; doc{
;
; cr  ( -- )
;
; Transmit a carriage return to the selected output device.
;
; }doc

; ----------------------------------------------
  _code_header c_move_up_,'CMOVE>'

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header c_move_,'CMOVE'

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'MOVE'

; doc{
;
; move  ( a1 a2 len -- )
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header s_move_,'SMOVE'

; doc{
;
; smove  ( ca1 len1 ca2 -- )
;
; Move the string _ca1 len1_ to _ca2_.
;
; This word is the equivalent of the idiom `swap move`, but
; faster.
;
; }doc

  exx
  pop de
  pop bc
  jp move.do

; ----------------------------------------------
  _code_header u_m_star_,'UM*'

; doc{
;
; um*  ( u1 u2 -- ud )
;
; Multiply _u1_ by _u2_, giving the unsigned double-cell product
; _ud_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 1 ; original_u_m_star

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  jp push_hlde

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX TODO version adapted from Z88 CamelForth

  exx
  pop bc      ; u2 in BC
  pop de      ; u1 in DE
  ld hl,0     ; result will be in HLDE
  ld a,17     ; loop counter
  or a        ; clear cy
u_m_star.do:
  rr h
  rr l
  rr d
  rr e
  jp nc,u_m_star.noadd
  add hl,bc
u_m_star.noadd:
  dec a
  jp nz,u_m_star.do
  push de     ; lo result
  push hl     ; hi result
  exx
  _jp_next

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX -- adapted from hForth

  exx
  pop bc          ; BC = u2
  pop de          ; DE = u1
  ld  hl,$0000
  ld  a,$10
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jp  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jp  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jp  nz,u_m_star.1
u_m_star.4:
  push hl
  push de
  exx
  _jp_next

endif

if 0 ; XXX OLD

  ; XXX -- Original version from hForth

  ; SP: data stack pointer
  ; IX: return stack pointer
  ; DE: Forth virtual machine instruction pointer
  ; BC: top of data stack item

                ; BC = u2, TOS = u1
  ex  de,hl     ; HL = IP, DE = ?
  ex  (sp),hl   ; TOS = IP,  HL = u1
  ex  de,hl     ; DE = u1, HL = ?
  ld  hl,0
  ld  a,010h
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jr  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jr  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jr  nz,u_m_star.1
u_m_star.4:
  ld  b,d
  ld  c,e
  ex  (sp),hl
  ; $nexthl

endif

; ----------------------------------------------
  _code_header u_m_slash_mod_,'UM/MOD'

; doc{
;
; um/mod ( ud u1 -- u2 u3 )
;
; Divide _ud_ by _u1_, giving the quotient _u3_ and the
; remainder _u2_.  All values and arithmetic are unsigned.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Z88 CamelForth.

  exx
  pop bc      ; BC = divisor
  pop hl      ; HLDE = dividend
  pop de
  ld a,16     ; loop counter
  sla e
  rl d        ; hi bit DE -> carry
u_m_slash_mod.do:
  adc hl,hl   ; rot left w/ carry
  jr nc,u_m_slash_mod.3
  ; case 1: 17 bit, cy:HL = 1xxxx
  or a        ; we know we can subtract
  sbc hl,bc
  or a        ; clear cy to indicate sub ok
  jr u_m_slash_mod.4
  ; case 2: 16 bit, cy:HL = $xxx
u_m_slash_mod.3:
  sbc hl,bc   ; try the subtract
  jr nc,u_m_slash_mod.4 ; if no cy, subtract ok
  add hl,bc   ; else cancel the subtract
  scf         ;   and set cy to indicate
u_m_slash_mod.4:
  rl e        ; rotate result bit into DE,
  rl d        ; and next bit of DE into cy
  dec a
  jr nz,u_m_slash_mod.do
  ; now have complemented quotient in DE,
  ; and remainder in HL
  ld a,d
  cpl
  ld b,a
  ld a,e
  cpl
  ld c,a
  push hl     ; remainder
  push bc     ; quotient
  exx
  _jp_next

; ----------------------------------------------
  _code_header and_,'AND'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _code_header or_,'OR'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _code_header xor_,'XOR'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  _jp_pushhl

; ----------------------------------------------
  _constant_header slash_user_,'/USER'

; doc{
;
; /user  ( -- n )
;
; Constant, the length of the user variables.
;
; }doc

  dw bytes_per_user_variables

; ----------------------------------------------
  _constant_header up_,'UP'

; doc{
;
; up  ( -- a )
;
; Constant, the address of the user area pointer.
;
; Origin: fig-Forth.
;
; }doc

  dw user_variables_pointer

; ----------------------------------------------
  _constant_header up0_,'UP0'

; doc{
;
; up0  ( -- a )
;
; Constant, the default address of the user area.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header np_,'NP'

; doc{
;
; np  ( -- a )
;
; Address of the names pointer.
;
; }doc

  dw names_pointer

; ----------------------------------------------
  _constant_header np0_,'NP0'

  dw names_bank_address

; ----------------------------------------------
  _code_header np_fetch_,'NP@'

; doc{
;
; np@  ( -- a )
;
; Fetch the content of the names pointer.
;
; }doc

  ld hl,(names_pointer)
  _jp_pushhl

; ----------------------------------------------
  _code_header np_store_,'NP!'

  pop hl
  ld (names_pointer),hl
  _jp_next

; ----------------------------------------------

  _colon_header comma_np_,',NP'

; doc{
;
; ,np  ( x -- )
;
; Store _x_ into the next available names memory cell, advancing
; the names pointer.
;
; Note: The names memory is supposed to be paged in.
;
; }doc

  dw np_fetch_,store_,two_,np_,plus_store_
  dw exit_

; ----------------------------------------------
  _code_header sp_fetch_,'SP@'

; doc{
;
; sp@  ( -- a )
;
; Fetch the content of the stack pointer.
;
; }doc

  ld hl,$0000
  add hl,sp
  _jp_pushhl

; ----------------------------------------------
  _code_header sp_store_,'SP!'

; doc{
;
; sp!  ( a -- )
;
; Store _a_ into the stack pointer.
;
; }doc

  pop hl
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'RP'

  ; XXX TODO -- convert to user variable

; doc{
;
; rp  ( -- a )
;
; Address of the return stack pointer.
;
; }doc

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP@'

; doc{
;
; rp@  ( -- a )
;
; Fetch the content of the return stack pointer.
;
; }doc

  ld hl,(return_stack_pointer)
  _jp_pushhl

; ----------------------------------------------
  _code_header rp_store_,'RP!'

; doc{
;
; rp!  ( a -- )
;
; Store _a_ into the return stack pointer.
;
; }doc

  pop hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header pick_,'PICK'

; doc{
;
; pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
;
; }doc

  ; XXX TODO move to the library, use `fetchhl`.
  ; but maybe `acceptx` needs `pick`.

  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

; ----------------------------------------------
  _code_header to_r_,'>R'

; doc{
;
; >r  ( x -- ) ( R: -- x )
;
; }doc

  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R>'

; doc{
;
; r>  ( -- x ) ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header two_r_drop_,'2RDROP'

; doc{
;
; 2rdrop  ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDROP'

; doc{
;
; rdrop  ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>R'

; doc{
;
; 2>r  ( x1 x2 -- ) ( R: -- x1 x2 )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2R>'

; 2r>  ( -- x1 x2 ) ( R: x1 x2 -- )

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_

; ----------------------------------------------
  _code_header two_r_fetch_,'2R@'

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R@'

  ld hl,(return_stack_pointer)
  jp fetch.hl

; ----------------------------------------------
  _code_header zero_equals_,'0='

  pop hl
zero_equals.hl:
  ld a,l
  or h
  jp z,true_
  jp false_

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

  pop hl
  ld a,l
  or h
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization
    add hl,hl ; 11t, 1 byte
  else
    ; Credit:
    ; Idea from Ace Forth.
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_
  jp false_

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  ld hl,0
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header plus_,'+'

  pop de
  pop hl
  add hl,de
  _jp_pushhl

; ----------------------------------------------
  _code_header d_plus_,'D+'

; doc{
;
; d+  ( d1|ud1 d2|ud2 -- d3|ud3 )
;
; Add _d2|ud2_ to _d1|ud1_, giving the sum _d3|ud3_.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

                        ;  t  B
                        ;  -- --
  pop de                ;  10 01 ; DE=d2hi
  exx                   ;  04 01
  pop de                ;  10 01 ; DE'=d2lo
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL=d1hi,DE=d2hi
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL'=d1lo
  add hl,de             ;  11 01
  push hl               ;  11 01 ; 2OS=d1lo+d2lo=d3lo
  exx                   ;  04 01
  adc hl,de             ;  15 02 ; HL=d1hi+d2hi+cy=d3hi
  push hl               ;  11 01
  _jp_next              ;  08 02
                        ;  -- --
                        ; 112 15 TOTALS

; ----------------------------------------------
  _code_header invert_,'INVERT'

; doc{
;
; invert  ( x1 -- x2 )
;
; Invert all bits of _x1_ giving its logical inverse _x2_.
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth.

  pop hl
  ld a,h
  cpl
  ld h,a
  ld a,l
  cpl
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _code_header negate_,'NEGATE'

; doc{
;
; negate  ( n1 -- n2 )
;
; Negate _n1_, giving its arithmetic inverse _n2_.
;
; Origin: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop de
                ; t  B
  ld hl,$0000  ; 10 03
  and a         ; 04 01
  sbc hl,de     ; 15 02
                ; 29 06 total
  _jp_pushhl

; ----------------------------------------------
  _code_header d_negate_,'DNEGATE'

; doc{
;
; dnegate  ( d1 -- d2 )
;
; Negate _d1_, giving its arithmetic inverse _d2_.
;
; Origin: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 0

  ; Credit:
  ; Code from Abersoft Forth, also found in White Lightning.

  ; XXX TODO optimize?

                                                ; T   B
                                                ; --- --
  pop hl      ; high part                       ;  10 01
  pop de      ; low part                        ;  10 01
  sub a       ; zero                            ;  04 01
  sub e       ; two's complement to carry       ;  04 01
  ld e,a                                        ;  04 01
  ld a,$00                                     ;  07 02
  sbc a,d     ; two's complement with carry     ;  04 01
  ld d,a                                        ;  04 01
  ld a,$00                                     ;  07 02
  sbc a,l     ; two's complement with carry     ;  04 01
  ld l,a                                        ;  04 01
  ld a,$00                                     ;  07 02
  sbc a,h     ; two's complement with carry     ;  04 01
  ld h,a                                        ;  04 01
  jp push_hlde                                  ;  10 03
                                                ;  11 00 push de
                                                ;  11 00 push hl
                                                ; --- --
                                                ; 109 20

else

  ; Credit:
  ; Code from Spectrum Forth-83.
  ;
  ; Comparison to the Abersoft Forth version:
  ; Speed: 1.04
  ; Size:  -1

                                                ; T   B
                                                ; --- --
  pop     hl        ; high part                 ;  10 01
  pop     de        ; low part                  ;  10 01
  push    hl        ; save copy                 ;  11 01
  ld      hl,$0000                             ;  10 03
  and     a                                     ;  04 01
  sbc     hl,de     ; hl = negated low part     ;  15 02
  pop     de        ; high part                 ;  10 01
  push    hl        ; negated low part          ;  11 01
  ld      hl,$0000                             ;  10 03
  sbc     hl,de     ; hl = negated high part    ;  15 02
if 0 ; XXX OLD
  jp push_hl                                    ;  10 03
                                                ;  11 00 push hl
                                                ; --- --
                                                ; 127 19
else ; XXX NEW
  _jp_pushhl                                    ; 11 01 push hl
                                                ; 08 02
                                                ; --- --
                                                ; 125 19
endif

endif

; ----------------------------------------------
  _code_header nip_,'NIP'

  pop hl
  pop de
  _jp_pushhl

; ----------------------------------------------
  _code_header tuck_,'TUCK'

  pop hl
  pop de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header over_,'OVER'

  pop de
  pop hl
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header drop_,'DROP'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWAP'

  pop hl
  ex (sp),hl
  _jp_pushhl

; ----------------------------------------------
  _code_header dup_,'DUP'

  pop hl
  push hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_dup_,'2DUP'

  pop hl
  pop de
  push de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header plus_store_,'+!'

; doc{
;
; +!  ( n|u a -- )
;
; Add _n|u_ to the single-cell number at _a_.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OFF'

; doc{
;
; off  ( a -- )
;
; Store _false_ at _a_.
;
; Origin: Comus.
;
; }doc

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'ON'

; doc{
;
; on  ( a -- )
;
; Store _true_ at _a_.
;
; Origin: Comus.
;
; }doc

  pop hl
  ld (hl),$FF
  inc hl
  ld (hl),$FF
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_test_bits_question_,'C@TEST-BITS?'

; doc{
;
; c@test-bits?  ( b ca -- wf )
;
; Test the bits at _ca_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  and (hl)
  jp nz,true_
  jp false_

; ----------------------------------------------
  _code_header c_store_set_bits_,'C!SET-BITS'

; doc{
;
; c!set-bits  ( b ca -- )
;
; Set the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  or (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header c_store_reset_bits_,'C!RESET-BITS'

; doc{
;
; c!reset-bits  ( b ca -- )
;
; Reset the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  cpl
  and (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header fetch_,'@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_,'C@'

  pop hl
c_fetch.hl:
  ld l,(hl)
  ld h,$00
  _jp_pushhl

; ----------------------------------------------
  _code_header two_fetch_,'2@'

  pop hl ; address
two_fetch.hl:
  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1 ; de = low part
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1 ; hl = high part
  ex de,hl      ; 04t  1
  jp push_hlde  ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL

; ----------------------------------------------
  _code_header two_store_,'2!'

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _constant_header do_colon_,'DOCOLON'

; doc{
;
; docolon  ( -- a )
;
; A constant that returns the address of the colon interpreter.
;
; }doc

  dw do_colon

; ----------------------------------------------
  _colon_header colon_,':'

  dw store_csp_
  dw header_
  dw lit_,do_colon
  dw code_field_comma_
  dw right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  pop bc ; bc=pfa

do_colon.end: ; XXX TMP for debugging
  _jp_next

; ----------------------------------------------
  _variable_header noname_question_,'NONAME?'

; doc{
;
; noname?  ( -- a )
;
; A variable that holds a flag: was the word being defined
; created by `:noname`? This flag is set by `:noname` and reset
; by `;`.
;
; }doc

; Credit:
; The idea for this variable was taken from hForth.

  dw false

; ----------------------------------------------
  _colon_header colon_no_name_,':NONAME',immediate

; doc{
;
; :noname  ( -- xt )
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; ----
; }doc

  ; Credit:
  ; Code from the Afera library.

  ; XXX TODO move to the library?
  ; first `do_colon` must be defined as a constant

  dw here_ ; xt
  dw store_csp_
  dw lit_,do_colon
  dw code_field_comma_ ; create the code field
  dw noname_question_,on_
  dw right_bracket_
  dw exit_

; ----------------------------------------------
  _colon_header finish_code_,'FINISH-CODE',compile_only

; doc{
;
; finish-code  ( -- )
;
; ----
; : finish-code  ( -- )
;   ?csp  postpone [
;   noname? @  noname? off  ?exit
;   reveal  ;
; ----
;
; }doc

  ; Credit:
  ;
  ; Name borrowed from Gforth.

  dw question_csp_
  dw left_bracket_
  dw noname_question_,fetch_
  dw noname_question_,off_
  dw question_exit_
  dw reveal_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate+compile_only

; doc{
;
; ;  ( -- )
;
; ----
; : ;  ( -- )
;   postpone exit  finish-code  ;
; ----
;
; }doc

  dw compile_,exit_
  dw finish_code_
  dw exit_

; ----------------------------------------------
  _code_header noop_,'NOOP'

; doc{
;
; noop  ( -- )
;
; }doc

  _jp_next

; ----------------------------------------------
  _colon_header c_constant_,'CCONSTANT'

  dw create_,c_comma_
  dw paren_semicolon_code_
do_c_constant:
  pop hl
  jp c_fetch.hl

; ----------------------------------------------
  _colon_header constant_,'CONSTANT'

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:
  pop hl
  jp fetch.hl

; ----------------------------------------------
  _colon_header variable_,'VARIABLE'

; doc{
;
; variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve one cell of data
; space.
;
;    _name_ is referred to as a variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the reserved cell. A program is
;    responsible for initializing the contents of the reserved
;    cell.
;
; Origin: Forth-94.
;
; }doc

  dw create_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header user_,'USER'

if 0 ; old_user

; doc{
;
; user  ( +n "name" -- )
;
; Create a user variable _name_.  _+n_ is the offset within the
; user area where the value for _name_ is stored.  Execution of
; _name_ leaves its absolute user area storage address.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Uncontrolled Reference Words).
;
; }doc

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,$00   ; de = index of the user variable
  ld hl,(user_variables_pointer)
  add hl,de   ; hl= address of the user variable
  _jp_pushhl

else

; doc{
;
; user  ( "name" -- )
;
; Create a user variable _name_ in the first available offset
; within the user area.  Execution of _name_ leaves its absolute
; user area storage address.
;
; }doc

  ; XXX UNDER DEVELOPMENT
  ; XXX TODO

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  pop hl
  ld e,(hl)
  ld d,$00   ; de = index of the user variable
  ld hl,(user_variables_pointer)
  add hl,de   ; hl= address of the user variable
  _jp_pushhl

endif

; ----------------------------------------------
if 0 ; old_user
else

  _colon_header uallot_,'UALLOT'

; doc{
;
; uallot  ( n -- )
;
; If _n_ is greater than zero, reserve _n_ address units of user
; data space. If _n_ is less than zero, release _n_ address
; units of user data space. If _n_ is zero, leave the user
; data-space pointer unchanged.
;
; ----
; : uallot  ( n -- )
;   udp +!  ;
; ----
;
; }doc

  dw udp_,plus_store_
  dw exit_

endif

; ----------------------------------------------
  _c_constant_header zero_,'0'

  db $00

; ----------------------------------------------
  _c_constant_header one_,'1'

  db $01

; ----------------------------------------------
  _c_constant_header two_,'2'

  db $02

; ----------------------------------------------
  _code_header false_,'FALSE'

  ; XXX TODO -- convert to cconstant?

; doc{
;
; false  ( -- false )
;
; }doc

  ld hl,false
  _jp_pushhl

; ----------------------------------------------
  _code_header true_,'TRUE'

  ; XXX TODO -- convert to constant?

; doc{
;
; true  ( -- true )
;
; }doc

  ld hl,true
  _jp_pushhl

; ----------------------------------------------
  _c_constant_header b_l_,'BL'

; doc{
;
; bl  ( -- b )
;
; }doc

  db space_char

; ----------------------------------------------
  _c_constant_header c_slash_l_,'C/L'

  db characters_per_line

; ----------------------------------------------
  _c_constant_header l_slash_scr_,'L/SCR'

  db lines_per_screen

; ----------------------------------------------
  _constant_header disk_buffer_,'DISK-BUFFER'

  dw disk_buffer

; ----------------------------------------------
  _constant_header buffer_data_,'BUFFER-DATA'

  dw disk_buffer+cell

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BUF'

  dw bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_rec_,'B/REC'

  ; XXX TODO -- remove? used only once, and may be harcoded

  dw bytes_per_sector

; ----------------------------------------------
  _c_constant_header rec_slash_blk_,'REC/BLK'

  db sectors_per_block

; ----------------------------------------------
  _constant_header blk_slash_disk_,'BLK/DISK'

  dw blocks_per_disk

; ----------------------------------------------
  _c_constant_header hash_vocs_,'#VOCS'

  ; XXX TODO -- rename to `/order`?

  db max_search_order

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGIN'

; doc{
;
; +origin  ( n -- a )
;
; Leave the memory address relative by _n_ to the origin
; parameter area.  _n_ is the minimum address unit, either byte
; or word.  This definition is used to access or modify the
; boot-up parameters at the origin area.
;
; Origin: fig-Forth.
;
; }doc

  dw lit_,origin,plus_
  dw exit_

; ----------------------------------------------
  _user_variable_header sp0_,'SP0'

; doc{
;
; sp0  ( -- a )
;
; User variable that holds the address of the bottom of the data
; stack.
;
; Note: In fig-Forth, Forth-79 and Forth-83 it's called `S0`.
;
; }doc

  db $00

; ----------------------------------------------
  _user_variable_header rp0_,'RP0'

; doc{
;
; rp0  ( -- a )
;
; User variable that holds the address of the bottom of the
; return stack.
;
; Note: In fig-Forth it's called `R0`.
;
; }doc

  db $02

; ----------------------------------------------
  _user_variable_header paren_wait_,'(WAIT)'

; XXX TMP -- from Spectrum Forth-83.

; doc{
;
; (wait)  ( -- a )
;
; User variable that holds the xt of a word to be executed by
; some words that accept user input, during multitasking.
;
; }doc

  db $04

; ----------------------------------------------
  _user_variable_header width_,'WIDTH'

  ; XXX TODO normal variable?

; doc{
;
; width  ( -- a )
;
; User variable that holds the maximum number of letters saved
; in the compilation of a definitions' name. It must be 1 thru
; 31, with a default value of 31. The name character count and
; its natural characters are saved, up to the value in `width`.
; The value may be changed at any time within the above limits.
;
; Origin: fig-Forth.
;
; }doc

  db $06

; ----------------------------------------------
  _user_variable_header warnings_,'WARNINGS'

; doc{
;
; warnings  ( -- a )
;
; User variable that holds a flag. If it's zero, no warning is
; shown when a compiled word is not unique in the `current`
; vocabulary.
;
; }doc

  db $08

; XXX OLD
; ; ----------------------------------------------
;   _user_variable_header msg_scr_,'MSG-SCR'

; ; doc{
; ;
; ; msg-scr  ( -- a )
; ;
; ; User variable that holds the screen number where the error
; ; messages start, or zero. If it's zero, only the message number
; ; will be shown.
; ;
; ; }doc

;   db $0A

; ----------------------------------------------
  _user_variable_header dp_,'DP'

; doc{
;
; dp  ( -- a )
;
; A variable, the data-space pointer, which contains its next
; free address.  The value may be read by `here` and altered by
; `there` and `allot`.
;
; Origin: fig-Forth (where `dp` is a user variable).
;
; }doc

  db $0C

; ----------------------------------------------
  _user_variable_header udp_,'UDP'

; doc{
;
; udp  ( -- a )
;
; User variable that holds an offset from the start of the
; current user area to the free space in it.
;
; }doc

  db $0E

; ----------------------------------------------
  _user_variable_header blk_,'BLK'

  ; XXX TODO normal variable?

; doc{
;
; blk  ( -- a )
;
; User variable that holds de number of the disk block being
; interpreted. A disk block holds 1024 bytes. One source screen
; consists of one disk block.
;
; }doc

  db $10

; ----------------------------------------------
  _user_variable_header to_in_,'>IN'

  ; XXX TODO normal variable?

; doc{
;
; >in  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $12

; ----------------------------------------------
  _user_variable_header hash_emit_,'#EMIT'

; doc{
;
; #emit  ( -- a )
;
; User variable that contains a value incremented by `emit`
; and reseted by `cr`. The user may alter and examine `#emit` to
; control display formating.
;
; Note: In fig-Forth it's called `out`; in Forth-83 it's called
; `#out`.
;
; }doc

  db $14

; ----------------------------------------------
  _user_variable_header scr_,'SCR'

; XXX TODO normal variable?

; doc{
;
; scr  ( -- a )
;
; User variable that holds the screen number of the screen most
; recently listed (with `list`) or loaded (with `load` or
; `continued`). This is the value used by `reload`.
;
; }doc

  db $16

; ----------------------------------------------
  _user_variable_header catcher_,'CATCHER'

; doc{
;
; catcher  ( -- a )
;
; A user variable that holds the return stack pointer for error
; handling. Used by `throw`.
;
; }doc

  db $18

; ----------------------------------------------
  _user_variable_header hld_,'HLD'

; doc{
;
; hld  ( -- a )
;
; A user variable that holds the address of the latest character of
; text during numeric output conversion.
;
; Origin: fig-Forth.
;
; }doc

  db $1A

; ----------------------------------------------
  _user_variable_header current_,'CURRENT'

; doc{
;
; current  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $1C

; ----------------------------------------------
  _user_variable_header state_,'STATE'

; doc{
;
; state  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $1E

; ----------------------------------------------
  _user_variable_header base_,'BASE'

; doc{
;
; base  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $20

; ----------------------------------------------
  _user_variable_header dpl_,'DPL'

; doc{
;
; dpl  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db $22

; ----------------------------------------------
  _user_variable_header csp_,'CSP'

  ; XXX TODO ordinary variable?

; doc{
;
; csp  ( -- a )
;
; User variable that holds the current data stack position saved
; by `!csp`.
;
; Origin: fig-Forth.
;
; }doc

  db $24

; ----------------------------------------------
  _user_variable_header context_,'CONTEXT'

; doc{
;
; context  ( -- a )
;
; User variable that holds... XXX TODO
;
; }doc

  db $26

; ----------------------------------------------
  _variable_header voc_link_,'VOC-LINK'

  ; XXX TODO 2015-12-26 -- rename to `latest-wordlist` after
  ; finishing the new implementation of `wordlist`, based on
  ; eForth.

if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
endif

; ----------------------------------------------
  _constant_header tib_,'TIB'

; doc{
;
; tib  ( -- ca )
;
; Address of the terminal input buffer.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT).
;
; }doc

  dw terminal_input_buffer


; ----------------------------------------------
  _c_constant_header slash_tib_,'/TIB'

; doc{
;
; /tib  ( -- n )
;
; Maximum size of the terminal input buffer.
;
; See `tib` and `#tib`.
;
; }doc

  db bytes_per_terminal_input_buffer

; ----------------------------------------------
  _variable_header number_tib_,'#TIB'

; doc{
;
; #tib  ( -- a )
;
; _a_ is the address of a cell containing the number of
; characters in the terminal input buffer.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT).
;
; }doc

  dw bytes_per_terminal_input_buffer

; ----------------------------------------------
  _two_variable_header input_buffer_,'INPUT-BUFFER'

; doc{
;
; input-buffer  ( -- a )
;
; A double-cell variable that holds the address and length of
; the current input buffer.
;
; }doc

  dw 0 ; len
  dw 0 ; address

; ----------------------------------------------
  _colon_header source_,'SOURCE'

; doc{
;
; source  ( -- ca len )
;
; ----
; : source  ( -- ca len )
;   blk @ ?dup if  block b/buf exit  then
;   input-buffer 2@  ;
; ----
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw blk_,fetch_,question_dup_
  dw zero_branch_,source.other
  ; disk block
  dw block_,b_slash_buf_,exit_
source.other:
  dw input_buffer_,two_fetch_
  dw exit_

; ----------------------------------------------
  _colon_header recurse_,'RECURSE',immediate+compile_only

; doc{
;
; recurse  ( -- )
;
; Origin: Forth-83 (Controlled Reference Words), Forth-94
; (CORE), Forth-2012 (CORE).
;
; }doc

  dw latest_,from_name_,compile_comma_
  dw exit_

; ----------------------------------------------
  _code_header one_plus_,'1+'

  pop hl
  inc hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_plus_,'2+'

  pop hl
  inc hl
  inc hl
  _jp_pushhl

; ----------------------------------------------
  _alias_header cell_minus_,'CELL-',,two_minus_

; ----------------------------------------------
  _alias_header cell_plus_,'CELL+',,two_plus_

; ----------------------------------------------
  _alias_header char_minus_,'CHAR-',,one_minus_

; ----------------------------------------------
  _alias_header char_plus_,'CHAR+',,one_plus_

; ----------------------------------------------
  _code_header one_minus_,'1-'

  pop hl
  dec hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_minus_,'2-'

  pop hl
  dec hl
  dec hl
  _jp_pushhl

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2*  ( x1 -- x2 )
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; This is the same as `1 lshift`.
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.
  ; Documentation partly based on lina.

  pop hl
  add hl,hl
  _jp_pushhl

; ----------------------------------------------
  _code_header chars_,'CHARS',immediate

; doc{
;
; chars  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ characters.
;
; In Solo Forth, this word does nothing.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  _jp_next

; ----------------------------------------------
  _alias_header cells_,'CELLS',,two_star_

; doc{
;
; cells  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ cells.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _c_constant_header cell_,'CELL'

  db cell

; ----------------------------------------------
  _colon_header here_,'HERE'

; doc{
;
; here  ( -- a )
;
; Return the address of the data-space pointer.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw dp_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header there_,'THERE'

; doc{
;
; there  ( a -- )
;
; Set the address of the data-space pointer.
;
; }doc

  dw dp_,store_
  dw exit_

; ----------------------------------------------
  _colon_header allot_,'ALLOT'

; doc{
;
; allot  ( n -- )
;
; If _n_ is greater than zero, reserve _n_ address units of
; data space. If _n_ is less than zero, release _n_ address
; units of user space. If _n_ is zero, leave the data-space
; pointer unchanged.
;
; ----
; : allot  ( n -- )
;   dp +!  ;
; ----
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw dp_,plus_store_
  dw exit_

  ; Alternative non-standard definition:
  ; http://dxforth.netbay.com.au/allot.html

; ----------------------------------------------
  _colon_header s_comma_,'S,'

; doc{
;
; s,  ( ca len -- )
;
; Compile a string.
;
; ----
; : s,  ( ca len -- )
;   dup c, tuck here swap cmove allot  ;
; ----
;
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,c_move_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header two_comma_,'2,'

if size_optimization

  dw comma_,comma_
  dw exit_

else

  dw here_,two_store_
two_comma.allot:
  _literal 2*cell
  dw allot_
  dw exit_

endif

; ----------------------------------------------
  _colon_header comma_,','

  dw here_,store_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _alias_header compile_comma_,'COMPILE,',,comma_

; doc{
;
; compile,  ( xt -- )
;
; }doc

; ----------------------------------------------
  _colon_header c_comma_,'C,'

  dw here_,c_store_,one_,allot_
  dw exit_

; ----------------------------------------------
  _code_header minus_,'-'

  pop de
  pop hl
  and a
  sbc hl,de
  _jp_pushhl

; ----------------------------------------------
  _code_header not_equals_,'<>'

  pop de
  pop hl
  _compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_
  jp true_

; ----------------------------------------------
  _code_header equals_,'='

  pop de
  pop hl
  _compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_
  jp false_

; ----------------------------------------------
  _code_header less_than_,'<'

  pop de
  pop hl
is_de_less_than_hl:
  call compare_de_hl_signed
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

if 0

  ; XXX TODO
  ;
  ; Code adapted from Z88 CamelForth

  pop de
  pop hl
  or a
  sbc hl,de       ; n1-n2 in HL, SZVC valid

  ; negative & not OV:  HL<DE
  ; negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ; positive & not OV:  HL>=DE
  ; positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ; thus OV reverses the sense of the sign bit

  jp pe,less_than.reverse  ; if OV, jump
  ; not overflow
  jp p,false_    ; if +ve, result false
  jp true_       ; if -ve, result true

less_than.reverse
  ; overflow
  jp m,false_    ; if -ve, result false
  jp true_       ; if +ve, result true

endif

; ----------------------------------------------
  _code_header u_greater_than_,'U>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U<'

if 0 ; XXX OLD -- code adapted from DZX-Forth

  pop de
  pop hl
u_less_than.de_hl:
  _compare_de_hl_unsigned
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

else ; XXX NEW -- code adapted from Z88 CamelForth

  ; XXX TODO benchmark

  pop de
  pop hl
u_less_than.de_hl:
  _compare_de_hl_unsigned
  sbc a,a         ; propagate carry flag through A
  ld h,a
  ld l,a          ; HL = $0000 or $FFFF
  _jp_pushhl

endif

; ----------------------------------------------
  _code_header greater_than_,'>'

  pop hl
  pop de
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header rot_,'ROT'

  pop de
  pop hl
  ex (sp),hl
  jp push_hlde

; ----------------------------------------------
  _colon_header space_,'SPACE'

  dw b_l_,emit_
  dw exit_

; ----------------------------------------------
  _code_header question_dup_,'?DUP'

  pop hl
  ld a,h
  or l
  jp z,push_hl
  push hl
  _jp_pushhl

; ----------------------------------------------
  _colon_header latest_,'LATEST'

; doc{
;
; latest ( -- nt )
;
; Leave the name token of the topmost word in the
; `current` vocabulary.
;
; Origin: Forth-94.
;
; }doc

  dw get_current_,fetch_
  dw exit_

; ----------------------------------------------
  _code_header from_body_,'BODY>'
  pop hl
  dec hl
  dec hl
  dec hl
  _jp_pushhl

; ----------------------------------------------
  _code_header to_body_,'>BODY'
  pop hl
  inc hl
  inc hl
  inc hl
  _jp_pushhl

; ----------------------------------------------
  _code_header to_name_,'>NAME'

; doc{
;
; >name  ( xt -- nt )
; >name  ( xt -- nt | 0 ) \ XXX TODO
;
; Warning: No check is done wether xt belongs to a definition
; created with `:noname`; if so, the name assoctiated to _nt_,
; returned by `name>string`, will be empty.
;
; }doc

  ; XXX FIXME -- make it return 0 if xt has no name associated

  call bank.system ; page the memory bank in

  pop de ; xt
;  ld (to_name.xt),de ; save xt for later ; XXX OLD

  ld a,(np_pfa) ; low byte of the names pointer
  ld (to_name.names_pointer_low_byte),a ; save it for later
  ld a,(np_pfa+1) ; hight byte of the names pointer
  ld (to_name.names_pointer_high_byte),a ; save it for later

  push bc ; save Forth IP
  ld b,0
  ld hl, names_bank_address-4

to_name.begin_0:
  ; hl = address of the xt pointer

  ; XXX NEW -- compare hl with  np: if equals, exit
  ; XXX FIXME -- not working yet
  ; XXX TODO use the Fuse's debugger

  ; compare the xt pointer with the names pointer
  ; if they are equals, there are no more names to check
to_name.names_pointer_high_byte equ $+1
  ld a,0
  cp h
  jr nz,to_name.names_not_finished
to_name.names_pointer_low_byte equ $+1
  ld a,0
  cp l
  jr nz,to_name.names_not_finished
  ; more names left, not found!
  ld hl,0
  jr to_name.end

to_name.names_not_finished:
  inc hl
to_name.begin_1:
  inc hl ; hl = lfa
  inc hl
  inc hl ; hl = nt
  ld a,(hl) ; name field byte length
  and word_length_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  add hl,bc ; point to the xt pointer of the next word

; XXX OLD
; to_name.xt equ $+1
;  ld de,0 ; xt searched for

  ld a,(hl) ; low byte of xt
  cp e ; equal?
  jr nz,to_name.begin_0 ; not equal
  inc hl
  ld a,(hl) ; high byte of xt
  cp d ; equal?
  jr nz,to_name.begin_1 ; not equal

  ; xt found
  inc hl
  inc hl
  inc hl ; nt

to_name.end:
  call bank.default ; page the default memory bank
  pop bc ; restore Forth IP
  _jp_pushhl

; ----------------------------------------------

  _colon_header c_store_bank_,'C!BANK'

; doc{
;
; c!bank  ( b a n -- )
;
; Store _b_ into address _a_ of bank _n_.
;
; }doc

  dw bank_,c_store_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; c_store_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; call bank.default
  ; _jp_pushhl

; ----------------------------------------------
  _colon_header store_bank_,'!BANK'

; doc{
;
; !bank  ( x a n -- )
;
; Store _x_ into address _a_ of bank _n_.
;
; }doc

  dw bank_,store_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header c_fetch_bank_,'C@BANK'

; doc{
;
; c@bank  ( a n -- b )
;
; Fetch the 8-bit content of address _a_ of the bank _n_.
;
; }doc

  dw bank_,c_fetch_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; c_fetch_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; call bank.default
  ; _jp_pushhl

; ----------------------------------------------
  _colon_header fetch_bank_,'@BANK'

; doc{
;
; @bank  ( a n -- x )
;
; Fetch the 16-bit content of address _a_ of bank _n_.
;
; }doc

  dw bank_,fetch_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; fetch_bank.e
  ; call bank.e
  ; pop hl
  ; ld a,(hl)
  ; inc hl
  ; ld h,(hl)
  ; ld l,a
  ; call bank.default
  ; _jp_pushhl

; ----------------------------------------------
  _colon_header c_fetch_s_,'C@S'

; doc{
;
; c@s  ( a -- x )
;
; Fetch from the _a_ address of the system bank.
;
; }doc

  ; XXX 7 bytes:
  _literal system_bank
  dw c_fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,system_bank
  ; jp c_fetch_bank.e

; ----------------------------------------------
  _colon_header fetch_s_,'@S'

; doc{
;
; @s  ( a -- x )
;
; Fetch from the _a_ address of the system bank.
;
; }doc

  ; XXX 7 bytes:
  _literal system_bank
  dw fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,system_bank
  ; jp fetch_bank.e

; ----------------------------------------------
  _colon_header c_store_s_,'C!S'

; doc{
;
; c!s  ( c a -- )
;
; Store _c_ into the _a_ address of the system bank.
;
; }doc

  ; XXX TODO -- move to the library?

  _literal system_bank
  dw c_store_bank_
  dw exit_

; ----------------------------------------------
  _colon_header store_s_,'!S'

; doc{
;
; !s  ( x a -- )
;
; Store _x_ into the _a_ address of the system bank.
;
; }doc

  ; XXX TODO -- move to the library?

  _literal system_bank
  dw store_bank_
  dw exit_

; ----------------------------------------------
  _colon_header from_name_,'NAME>'

; doc{
;
; name>  ( nt -- xt )
;
; }doc

  _literal 4
  dw minus_,fetch_s_
  dw exit_

; ----------------------------------------------
  _colon_header name_to_string_,'NAME>STRING'

; doc{
;
; name>string  ( nt -- ca len )
;
; }doc

  dw system_bank_
  dw count_
  _literal word_length_mask
  dw and_
  dw save_string_
  dw default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header store_csp_,'!CSP'

; doc{
;
; !csp  ( -- )
;
; Save the the current data stack position.
;
; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,store_
  dw exit_

; ----------------------------------------------
  _colon_header question_throw_,'?THROW'

; doc{
;
; ?throw  ( f n -- )
;
; Perform a `throw` of value _n_ if the boolean flag _f_ is
; non-zero.
;
; ----
; : ?throw  ( f n -- )
;   swap if  throw  else  drop  then  ;
; ----
;
; }doc

  dw swap_
  dw question_branch_,throw_pfa
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header compiling_question_,'COMPILING?'

; doc{
;
; compiling?  ( -- wf )
;
; ----
; : compiling?  ( -- wf )
;   state @ 0<>  ;
; ----
;
; }doc

  dw state_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header executing_question_,'EXECUTING?'

; doc{
;
; executing?  ( -- wf )
;
; ----
; : executing?  ( -- wf )
;   state @ 0=  ;
; ----
;
; }doc

  dw state_,fetch_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header question_csp_,'?CSP'

; doc{
;
; ?csp  ( -- )
;
; Issue error "definition unbalanced" if the current data stack
; position does not match the value saved by `!csp`.
;
; // XXX TODO and `checking` is not zero.
;
; Origin: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,fetch_,not_equals_
  ; dw checking(s)_,fetch_,and_ ; XXX TODO ?
  _question_throw error.definition_not_finished
  dw exit_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADING'

  dw loading_question_,zero_equals_
  _question_throw error.loading_only
  dw exit_

; ----------------------------------------------
  _colon_header loading_question_,'LOADING?'

  dw blk_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header compile_,'COMPILE',compile_only

; doc{
;
; compile  ( -- )
;
; : compile  ( -- )
;   ?compiling  r> dup cell+ >r  @ compile,  ;
;
; }doc

  dw from_r_,dup_,cell_plus_,to_r_,fetch_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header postpone_,'POSTPONE',immediate

; doc{
;
; postpone ( "name" -- )
;
; Skip leading space delimiters. Parse name delimited by a
; space. Find name. Append the compilation semantics of _name_ to
; the current definition.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw defined_ ; ( nt | 0 )
  dw dup_,question_defined_ ; error if not found
  ; ( nt )
  dw name_to_immediate_question_ ; ( xt f )
  dw question_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw compile_comma_ ; compile xt
  dw exit_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

  dw state_,off_
  dw exit_

; ----------------------------------------------
  _colon_header right_bracket_,']'

  dw state_,on_
  dw exit_

; ----------------------------------------------
  _colon_header revealed_,'REVEALED'

; doc{
;
; revealed  ( nt -- )
;
; Reveal the definition _nt_ by resetting its smudge bit.
;
; }doc

  dw smudge_mask_,swap_
  dw system_bank_,c_store_reset_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header reveal_,'REVEAL'

; doc{
;
; reveal  ( -- )
;
; Reveal the latest definition by resetting its smudge bit.
;
; }doc

  dw latest_,revealed_
  dw exit_

; ----------------------------------------------
  _colon_header hided_,'HIDED'

; doc{
;
; hided  ( nt -- )
;
; Hide the definition _nt_ by setting its smudge bit.
;
; }doc

  dw smudge_mask_,swap_
  dw system_bank_,c_store_set_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header hide_,'HIDE'

; doc{
;
; hide  ( -- )
;
; Hide the latest definition by setting its smudge bit.
;
; }doc

  dw latest_,hided_
  dw exit_

; ----------------------------------------------
  _c_constant_header smudge_mask_,'SMUDGE-MASK'

; doc{
;
; smudge-mask  ( -- b )
;
; Constant that holds the bitmask of the smudge bit.
;
; }doc

  db smudge_mask

; ----------------------------------------------
  _colon_header hex_,'HEX'

  _literal $10
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header decimal_,'DECIMAL'

  _literal $0A
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE)'

; doc{
;
; (;code)  ( -- )
;
; The run-time procedure compiled by `;code`. Rewrite the code
; field of the most recently defined word to point to the
; following machine code sequence.

; ----
; : (;code)  ( -- )
;   r> latest name> 1+ !  ;
; ----

; }doc

  dw from_r_,latest_,from_name_,one_plus_,store_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_code_,';CODE',immediate+compile_only

; XXX TODO move to the library?
; XXX TODO -- documentation
; doc{
;
; ;code  ( -- )
;
; Stop compilation and terminate a new defining word by
; compiling the run-time routine `(;code)`.
;
; ----
; : ;code  ( -- )
;   postpone (;code)  finish-code  ;
; ----
;
; }doc

  dw compile_,paren_semicolon_code_
  dw finish_code_
  dw exit_

; ----------------------------------------------
  _colon_header does_,'DOES>',immediate+compile_only

do_does equ do_colon

  dw compile_,paren_semicolon_code_
  _literal $CD ; Z80 opcode for "call"
  dw c_comma_ ; compile it
  dw lit_,do_does,comma_ ; compile the routine address
  dw exit_

;do_does:
  ; XXX UNDER DEVELOPMENT
  ; XXX FIXME
;  pop de
;  push de
;  push de
;  jp do_colon

; ----------------------------------------------
  _code_header count_,'COUNT'

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUNDS'

  dw over_,plus_,swap_
  dw exit_

; ----------------------------------------------
  _colon_header type_,'TYPE'

  ; XXX TODO Rewrite in Z80, with the ROM routine?

  dw question_dup_
  dw zero_branch_,type.empty_string

  dw bounds_
  dw paren_do_,type.loop_exit ; do
  dw i_,c_fetch_,emit_
  dw paren_loop_ ; loop
type.loop_exit
  dw exit_

type.empty_string:
  dw drop_
type.end:
  dw exit_

; ----------------------------------------------

  _code_header minus_trailing_,'-TRAILING'

; doc{
;
; -trailing  ( ca1 len1 -- ca1 len2 )
;
; Adjust the length of a string to suppress the trailing blanks.
;
; If _len_ is greater  than zero, _len2_ is  equal to _len1_
; less the number of spaces  at the end of  the character string
; specified by _ca1 len1_. If _len1_ is zero or the entire
; string consists of spaces, _len2_ is zero.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
  ; de = address after the string
  ; hl = length of the string
minus_trailing.begin:
  ld a,l
  or h ; exhausted?
  jp z,push_hl
  dec de ; next char
  ld a,(de)
  cp ' ' ; space?
  jp nz,push_hl
  dec hl ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header minus_leading_,'-LEADING'

; doc{
;
; -leading  ( ca len -- ca' len' )
;
; Adjust the start and length of a string to suppress the
; leading blanks.
;
; }doc

  dw b_l_,skip_
  dw exit_

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(.")'

; doc{
;
; (.")  ( -- )
;
; Type the compiled string that follows.
;
; ----
; : (.")  ( -- ca len )
;   r@ count dup 1+ r> + >r type  ;
; ----
;
; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,one_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_

  ; XXX TODO --
  ;   `r@ count dup 1+ r> + >r` is what `slit` does, but
  ;   calling `slit` here can not work:
  ;
  ; dw s_lit_,type_ ; XXX TODO -- this alternative can not work

  dw exit_

if 0 ; XXX OLD

  ; This version allows `."` in interpretation mode.
  ; This version needs 4 more bytes.

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate

; doc{
;
; ."
;
; Interpretation: ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote and display it.
;
; Compilation: ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote. Append the run-time
; semantics given below to the current definition.
;
;       Run-time: ( -- )
;
; Display "ccc".
;
; Origin: Forth-79, Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  _literal '"'
  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,dot_quote.interpreting
  ; Compiling.
  dw compile_,paren_dot_quote_,s_comma_
  dw exit_
dot_quote.interpreting:
  dw type_
  dw exit_

else

  ; This version causes an error when `."` is used in
  ; interpretation mode.
  ; This version saves 4 bytes.

; ----------------------------------------------
  _colon_header comma_quote_,',"'

; doc{
;
; ,"  ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote and compile the
; string.
;
; ----
; : ,"  ( -- )
;   [char] " parse s,  ;
; ----
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  _literal '"'
  dw parse_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate+compile_only

; doc{
;
; ."
;
; Compilation: ( "ccc<quote>" -- )
;
; Parse "ccc" delimited by a double-quote. Append the run-time
; semantics given below to the current definition.
;
;       Run-time: ( -- )
;
; Display "ccc".
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : ."  ( "ccc<quote> -- )
;   compile (.") ,"  ;  immediate
; ----
;
; }doc

  ; Credit:
  ; Code adapted from DZX-Forth.

  dw compile_,paren_dot_quote_,comma_quote_
  dw exit_

endif

; ----------------------------------------------
  _variable_header span_,'SPAN'

; doc{
;
; span  ( -- a )
;
; The address of a variable containing the count of characters
; actually received and stored by the last execution of
; `accept`.
;
; }doc

  dw 0

; ----------------------------------------------
  _defer_header to_history_,'>HISTORY',,two_drop_

; doc{
;
; >history  ( -- ca len )
;
; A deferred word. When command line history is activated,
; store string _ca len_ into it, else drop it.
;
; }doc

; ----------------------------------------------
  _colon_header s_quote_quote_,'S""'

; XXX OLD

; doc{
;
; s""  ( -- ca len )
;
; Return an empty string in the circular string buffer.
;
; }doc

  _literal 0
  dw allocate_string_
  _literal 0
  dw exit_

; ----------------------------------------------
  _defer_header accept_,'ACCEPT',,simple_accept_

; doc{
;
; accept  ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when an implementation-defined line
; terminator is received. When input terminates, nothing is
; appended to the string or displayed on the screen.
;
; _len2_ is the length of the string stored at _ca1_.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; In Solo Forth `accept` is a deferred word. Its default
; behaviour is `default-accept`, which provides only the basic
; editing options Alternative definitions are provided in the
; library.
;
; }doc

; ----------------------------------------------
  _colon_header simple_accept_,'SIMPLE-ACCEPT'

; Credit:
;
; Code adapted from eForth.

; doc{
;
; simple-accept  ( ca1 len1 -- len2 )
;
; Default behaviour of the deferred word `accept`:
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when the Return key is pressed.  When input
; terminates, nothing is appended to the string or displayed on
; the screen.
;
; The only control key accepted is Delete.
;
; _len2_ is the length of the string stored at _ca1_.

; ----
; : simple-accept  ( ca len -- len' )
;   over + over  ( bot eot cur )
;   begin  xkey dup 13 <> \ not carriage return?
;   while  ( bot eot cur c )
;     dup 12 =  \ delete?
;     if    drop  >r over r@ < dup  \ any chars?
;           if  8 dup emit  bl emit  emit  then  r> +
;     else  \ maybe printable
;           >r  2dup <>  \ more?
;           r@ [ bl 1- ] literal > and  \ and printable?
;           if  r@ over c!  char+  r@ emit  then  r> drop
;     then
;   repeat  ( bot eot cur c )  drop nip swap -  ;
; ----
;
; }doc

  dw over_,plus_,over_
simple_accept.begin                                    ; begin
  dw xkey_,dup_
  _literal carriage_return_char
  dw not_equals_
  dw zero_branch_,simple_accept.end                    ; while
  dw dup_
  _literal delete_char
  dw equals_                                           ; delete?
  dw zero_branch_,simple_accept.printable              ; if
  dw drop_,to_r_,over_,r_fetch_,less_than_,dup_        ; any chars?
  dw zero_branch_,simple_accept.delete_end             ; if
  _literal backspace_char
  dw dup_,emit_,b_l_,emit_,emit_
simple_accept.delete_end                               ; then
  dw from_r_,plus_
  dw branch_,simple_accept.repeat
simple_accept.printable                                ; else
  ; printable
  dw to_r_,two_dup_,not_equals_                        ; more?
  dw r_fetch_
  _literal space_char-1
  dw greater_than_,and_                                ; and printable?
  dw zero_branch_,simple_accept.printable_end          ; if
  dw r_fetch_,over_,c_store_,char_plus_,r_fetch_,emit_
simple_accept.printable_end                            ; then
  dw from_r_,drop_
simple_accept.repeat
  dw branch_,simple_accept.begin                       ; repeat
simple_accept.end
  ; ( bot eot cur c )
  dw drop_,nip_,swap_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header query_,'QUERY'

; doc{
;
; query  ( -- )
;
; Make the user input device the input source. Receive input
; into the terminal input buffer, replacing any previous
; contents. Make the result, whose address is returned by `tib`,
; the input buffer. Set `>in` to zero.
;
; Origin: Forth-94 (CORE EXT, obsolescent).
;
; }doc

; XXX OLD -- old descriptions:
;
; Input 80 characters of text (or until a "return") from the
; operators terminal. Text is positioned at the address
; contained in TIB with IN set to zero.
;
; Transfer characters from the terminal to address returned by
; `tib`, until a "return" or the count contained in the `#tib`
; variable have been received. One or more nulls are added at
; the end of the text.
;
  ; XXX TODO move to the library

  dw tib_,slash_tib_
  dw two_dup_,blank_ ; clean the input buffer
  dw accept_,number_tib_,store_,space_
  dw terminal_to_source_
  dw exit_

; ----------------------------------------------
  _constant_header source_id_,'SOURCE-ID'

  ; XXX TODO -- move `value` to the kernel for this?

; doc{
;
; source-id  ( -- 0 | -1 )
;
; Identifies the input source as follows:
;
; |===
; |  0 | User input device
; | -1 | String via `evaluate`
; |===
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header refill_,'REFILL'

  ; XXX UNDER DEVELOPMENT

; doc{

; refill  ( -- wf )

; }doc


; XXX TMP -- From Z88 CamelForth (version w/o files)
;   SOURCE-ID BLK @ OR 0= DUP
;   IF  TIB DUP 80 ACCEPT SPACE
; 'SOURCE 2!  0 >IN !
;   THEN ;

  ; XXX NEW
  ; XXX TODO -- try, check, complete

; : refill ( -- f )
;   loading?
;   if    1 blk +!  >in off
;   else  query
;   then  true  ;

  dw loading_question_ ; input stream from disk?
  dw zero_branch_,refill.terminal ; if not, branch

refill.block:
  _literal 1
  dw blk_,plus_store_
  dw to_in_,off_
  dw branch_,refill.end

refill.terminal:
  dw query_
refill.end:
  dw true_
  dw exit_

; XXX TMP -- From Z88 CamelForth (version with files)
;X REFILL   -- f
;   BLK @ IF  1 BLK +!                          ; for block input, use next
;       BLK @ BLOCK PAUSE 1024 TRUE
;   ELSE
;   SOURCE-ID CASE
;     0 OF  TIB DUP 80 ACCEPT SPACE TRUE  ENDOF
;    -1 OF  FALSE  ENDOF
;    >R
;    INPUT-FBUF INPUT-FLEN R@ READ-LINE THROW PAUSE ; read a line
;    IF  INPUT-FBUF SWAP TRUE  THEN   ; leave source-spec
;    R>
;   ENDCASE
;   THEN
;   DUP IF  >R 'SOURCE 2!  0 >IN ! R>  THEN ;

; From hForth
;
;   : refill  ( f )
;     source-id true = if  0 exit  then
;     memtop [ size-of-pad chars ] literal - dup
;     size-of-pad accept sourcevar 2!
;     >in off  true  ;

; ----------------------------------------------
  _code_header fill_,'FILL'

; doc{
;
; fill  ( a u b -- )
;
; If _u_ is not zero, store _b_ in each of _u_
; consecutive characters of memory beginning at _a_.
;
; Origin: fig-Forth, Forth-83.
;
; }doc

  ; XXX TODO consult in clf the differences of the standards and
  ; the Forth-2012 stack notation, also for `erase` and `blank`.

  exx                 ; save the Forth IP
  pop bc
  ld a,c              ; A = character
fill.a:
  pop bc              ; BC = count
  pop de              ; DE = address

  ; XXX TODO -- this check is necessary for Forth-94 and
  ; Forth-2012:

  ;bit 7,b             ; negative count?
  ;jr nz,fill.done     ; if so, skip

  ld hl,$FFFF
  or a                ; clear carry flag
  adc hl,bc           ; test for count=0 or 1
  jr nc,fill.done     ; no cy: count=0, skip
  ld (de),a           ; fill first byte
  jr z,fill.done      ; z: count=1, done
  dec bc              ; else adjust count
  ld h,d
  ld l,e              ; HL = start address
  inc de              ; DE = start address+1
  ldir                ; copy (HL)->(DE)
fill.done:
  exx                 ; restore the Forth IP
  _jp_next

; ----------------------------------------------

  _code_header erase_,'ERASE'

  exx
  xor a
  jp fill.a

; ----------------------------------------------
  _code_header blank_,'BLANK'

  exx
  ld a,space_char
  jp fill.a

; ----------------------------------------------
  _colon_header hold_,'HOLD'

; doc{
;
; hold  ( c -- )
;
; Insert char _c_ into a pictured numeric output string.
; Typically used between `<#` and `#>`.
;
; ----
; : hold  ( c -- )
;   -1 hld +!  hld @ c!  ;
; ----
;
; }doc

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw exit_

; ----------------------------------------------
  _colon_header pad_,'PAD'

; doc{
;
; pad  ( -- ca )
;
; Return the address of a transient region that can be used to
; hold data for intermediate processing.
;
; Origin: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT),
; Forth-2012 (CORE EXT).
;
; }doc

  dw here_
  _literal $44
  dw plus_
  dw exit_

; ----------------------------------------------
  _colon_header stream_,'STREAM'

; doc{
;
; stream  ( -- ca len )
;
; Return the address and length of the remaining stream source.
;
; }doc

  dw source_,to_in_,fetch_,slash_string_
;  _brk 'stream' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _code_header slash_string_,'/STRING'

; doc{
;
; /string  ( ca1 len1 n -- ca2 len2 )
;
; Adjust the character string at _ca1 len1_ by _n_ characters.
; The resulting character string _ca2 len2_ begins at _ca1_ plus
; _n_ characters and is _len1_ minus _n_ characters long.
;
; Origin: Forth-94 (STRING), Forth-2012 (STRING).
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   rot over + -rot -  ;
; ----
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   dup >r - swap r> + swap  ;
; ----
;
; }doc

  pop de                  ; n
  pop hl                  ; len1
  and a                   ; cy=0
  sbc hl,de               ; hl=len2
  ex (sp),hl              ; (sp)=len2 hl=ca1
  add hl,de               ; hl=ca2
  ex (sp),hl              ; (sp)=ca2 hl=len2
  _jp_pushhl

; ----------------------------------------------
  _colon_header parsed_,'PARSED'

; doc{
;
; parsed  ( len -- )
;
; Add the given _len_ to `>in`.
;
; ----
; : parsed  ( len -- )
;   >in +!  ;
; ----
;
; }doc

  dw to_in_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_,'PARSE'

; doc{
;
; parse  ( c "ccc<char>" -- ca len )
;
; Parse _ccc_ delimited by the delimiter _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
;
; If the parse area was empty, the resulting string has a zero length.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; ----
; : parse  ( c "ccc<char>" -- ca len )
;   stream 2dup 2>r rot scan
;   dup if  char-  then
;   2r> rot - parsed
;   tuck -  ;
; ----
;
; }doc


  dw stream_,two_dup_,two_to_r_,rot_,scan_
  dw dup_,zero_branch_,parse.end
  dw char_minus_
parse.end:
  dw two_from_r_,rot_,minus_
  dw parsed_
  dw tuck_,minus_
  dw exit_

; ----------------------------------------------
  _two_variable_header parsed_name_,'PARSED-NAME'

; doc{
;
; parsed-name  ( -- a )
;
; A double variable that holds the address and length of the
; most recently name parsed by `parse-name`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _two_variable_header nextname_string_,'NEXTNAME-STRING'

; doc{
;
; next-name  ( -- a )
;
; A double variable that may hold the address and length of a
; name to be used by the next defining word.  This variable is
; set by `nextname`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _defer_header header_,'HEADER',,input_stream_header_

; ----------------------------------------------
  _colon_header question_name_too_short_,'?NAME-TOO-SHORT'

; doc{
;
; ?name-too-short ( ca len -- )
;
; }doc

  dw dup_,zero_equals_
  _question_throw -16 ; attempt to use zero-length string as a name
  dw exit_

; ----------------------------------------------
  _colon_header input_stream_header_,'INPUT-STREAM-HEADER'

; doc{
;
; input-stream-header  ( "name" -- )

; Create a dictionary header "name" with its code field
; pointing to its parameter field.
;
; ----
; : input-stream-header  ( "name" | -- )
;   parse-name ?name-too-short header,  ;
; ----
;
; }doc

  dw parse_name_
  dw question_name_too_short_
  dw header_comma_
  dw exit_

; ----------------------------------------------
  _colon_header default_header_,'DEFAULT-HEADER'

; doc{
;
; default-header  ( -- )

; Set `header` to its default behaviour: `input-stream-header`.

; ----
; : default-header  ( -- )
;   ['] input-stream-header ['] header defer!  ;
; ----
;
; }doc

  _literal input_stream_header_
  _literal header_
  dw defer_store_
  dw exit_

; ----------------------------------------------
  _colon_header nextname_header_,'NEXTNAME-HEADER'

; doc{
;
; nextname-header  ( -- )

; Create a dictionary header with its code field pointing to its
; parameter field, using the name string set by `nextname`.
;
; ----
; : nextname-header  ( -- )
;   nextname-string 2@ header,  default-header  ;
; ----
;
; }doc

  dw nextname_string_,two_fetch_,header_comma_
  dw default_header_ ; restore the default behaviour of `header`
  dw exit_

; ----------------------------------------------
  _colon_header nextname_,'NEXTNAME'

; doc{
;
; nextname  ( ca len -- )
;
; The next defined word will have the name _ca len_; the
; defining word will leave the input stream alone. `nextname`
; works with any defining word.
;
; ----
; : nextname  ( ca len -- )
;   nextname-string 2!
;   ['] nextname-header ['] header defer!  ;
; ----
;
; Origin: Gforth.
;
; }doc

  ; Credit:
  ; This word is borrowed from Gforth.

  dw nextname_string_,two_store_
  _literal nextname_header_
  _literal header_
  dw defer_store_ ; change the default behaviour of `header`
  dw exit_

; ----------------------------------------------
  _colon_header parse_name_,'PARSE-NAME'

; doc{

; parse-name  ( "name"  -- ca len )
;
; ----
; : parse-name  ( "name"  -- ca len )
;   stream                 ( ca0 len0 )
;   dup >r   -leading      ( ca1 len1 ) ( R: len0 )
;   over >r  bl scan       ( ca2 len2 ) ( R: len0 ca1 )
;   dup if  char-  then    \ skip trailing delimiter
;   r> r> rot -  parsed    \ update `>in`
;   tuck -                 ( ca len )
;   2dup parsed-name 2!  ;
; ----
;
; }doc

  dw stream_              ; ( ca len )
; _brk 'parse-name -- after stream' ; XXX INFORMER
  dw dup_,to_r_           ; ( ca len ) ( R: len )
; _brk 'parse-name -- before skip' ; XXX INFORMER
  dw minus_leading_           ; ( ca1 len1 ) ( R: len )
; _brk 'parse-name -- after skip' ; XXX INFORMER
  dw over_,to_r_          ; ( ca1 len1 ) ( R: len ca1 )
  dw b_l_,scan_           ; ( ca2 len2 ) ( R: len ca1 )
; _brk 'parse-name -- after scan' ; XXX INFORMER
  dw dup_
  dw zero_branch_,parse_name.skip
; _brk 'parse-name -- before char-' ; XXX INFORMER
  dw char_minus_
parse_name.skip:
  dw from_r_,from_r_      ; ( ca2 len2 ca1 len )
  dw rot_,minus_          ; ( ca2 ca1 len3 )
; _brk 'parse-name -- before updating >in' ; XXX INFORMER
  dw parsed_              ; ( ca2 ca1 )
  dw tuck_,minus_         ; ( ca1 len4 )
  dw two_dup_,parsed_name_,two_store_
;  _brk_type 'parse-name -- end' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _code_header upper_,'UPPER'

; doc{
;
; upper  ( c -- c' )
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl
  ld a,l
  call ascii_upper.a
  jp push_a

ascii_upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  and %11011111
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPERS'

; doc{
;
; uppers  ( ca len -- )
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call ascii_upper.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; doc{
;
; undefined?  ( ca len -- wf )
;
; }doc

  ; XXX TODO -- this may be moved to the library, but it's
  ; needed by `needed`.

  dw find_name_,zero_equals_
  dw exit_

; ----------------------------------------------
  _code_header place_,'PLACE'

; doc{
;
; place  ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ as a counted string at _ca2_.  The
; source and destination strings are permitted to overlap.
;
; An ambiguous condition exists if _len1_ is greater than 255 or
; the buffer at _ca2_ is less than _len1_+1 characters.
;
; ----
; : place  ( ca1 len1 ca2 -- )
;   2dup c! char+ smove  ;
; ----
;
; }doc

; XXX TODO -- alternative in Forth Dimensions 20-3 p.29
;   2dup c! char+ swap chars move

  ; Credit:
  ; Code from DZX-Forth's `packed`.

  exx         ; save Forth IP
  pop de      ; de=ca2
  pop bc      ; c=len1
  pop hl      ; hl=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; e=len1
  ld (hl),e
  exx         ; restore Forth IP
  _jp_next

; ----------------------------------------------
  _variable_header error_number_,'ERROR#'

  ; XXX TODO -- useful? remove? user variable?

; doc{
;
; error# ( -- a )
;
; Variable that holds the number of the last error issued by
; `error`.
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-POS'

; doc{
;
; error-pos ( -- a )
;
; Double variable that holds the position of the last error
; issued by `error`:

; - high part = value of `blk`
; - low part = value of `>in`

; }doc

  dw 0 ; value of `blk`
  dw 0 ; value of `>in`

; ----------------------------------------------
  _colon_header error_,'ERROR'

; doc{
;
; error  ( n -- )
;
; Save the error number _n_ into `error-number`, and the current
; block and line into `error-pos`, to be used by `where`.  Issue
; error _n_ and restart the system.
;
; ----
; : error  ( n -- )
;   dup error-number !
;   >in @ blk @ error-pos 2!
;   dup -1 = if  (abort)  then
;   dup -2 = if  abort-message 2@ type (abort)  then
;   parsed-name 2@ type ." ? " .throw  (abort)  ;
; ----
;
; }doc

  dw dup_,error_number_,store_ ; save the error number
  dw to_in_,fetch_,blk_,fetch_,error_pos_,two_store_

  dw dup_
  _literal -1
  dw equals_
  dw question_branch_,paren_abort_pfa
  ; No return from `(abort)`.

  dw dup_
  _literal -2
  dw equals_
  dw zero_branch_,error.message
  dw space_,abort_message_,two_fetch_,type_,paren_abort_
  ; No return from `(abort)`.

error.message:
  dw parsed_name_,two_fetch_,type_ ; last parsed word
  dw paren_dot_quote_
  _string '? '
  dw dot_throw_,paren_abort_
  ; No return from `(abort)`.

; ----------------------------------------------
  _two_variable_header abort_message_,"ABORT-MESSAGE"

  dw 0,0

; ----------------------------------------------
  _colon_header dot_name_,'.NAME'

  dw name_to_string_,type_,space_
  dw exit_

; ----------------------------------------------
  _colon_header code_field_comma_,'CODE-FIELD,'

; doc{
;
; code-field,  ( a -- )
;
; Compile a code field for a high-level word, to execute the
; actual Z80 code at _a_.

; ----
; : code-field,  ( a -- )
;   $CD c,  \ Z80 opcode for "call"
;   ,  ;
; ----
;
; }doc

  _literal $CD ; Z80 opcode for "call"
  dw c_comma_ ; compile it
  dw comma_  ; compile _a_
  dw exit_

; ----------------------------------------------
  _colon_header header_comma_,'HEADER,'

; doc{
;
; header,  ( ca len -- )
;
; Create a dictionary header with the name _ca len_.
;
; }doc

  ; XXX TODO -- complete the description, for DTC.

  dw dup_,zero_equals_
  _question_throw error.zero_length_name

  dw warnings_,fetch_
  dw zero_branch_,header_comma.continue

  ; `warnings` is on
  dw two_dup_,get_current_,search_wordlist_
  dw zero_branch_,header_comma.continue
  ; the word is not unique in `current`
  ; ( ca len xt )
  dw to_name_,dot_name_
  _literal error.not_unique
  dw dot_throw_ ; XXX TMP -- `warning`?

header_comma.continue:

  ; ( ca len )

  dw width_,fetch_,min_
  dw tuck_ ; ( len ca len )
  dw system_bank_
  dw here_,comma_np_ ; store a pointer to the xt
  dw latest_,comma_np_ ; link field
  ; Now `np` contains the address of the nt.
  dw np_fetch_
  dw dup_,to_r_
  dw place_ ; store the name
  dw from_r_,count_,uppers_

  dw np_fetch_,get_current_,store_ ; update contents of `latest` in the current vocabulary
  dw hide_
  dw one_plus_,np_,plus_store_ ; update the names pointer with the length+1

  dw exit_

; ----------------------------------------------
  _colon_header create_,'CREATE'

  ; XXX TODO factor `header reveal` to `visible-header`? it's
  ; used also by `defer`.

  dw header_
  dw lit_,do_create
  dw code_field_comma_
  dw reveal_
  dw paren_semicolon_code_
do_create:
  ; XXX Note: `call do_create` already left the pfa on the stack.
  _jp_next

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _colon_header code_,'CODE'

;  _chk 'code -- before header' ; XXX INFORMER
  dw header_
;  _chk 'code -- after header' ; XXX INFORMER
  dw asm_
;  _chk 'code -- end' ; XXX INFORMER
  dw exit_

endif

; ----------------------------------------------
  _code_header compare_,'COMPARE'

  ; Forth-94
  ; Adapted from DZX-Forth

  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  pop de      ; de = len2
  pop hl      ; hl = ca2
  ex (sp),hl  ; hl = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; cy = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; de = length of the short string
  ; hl = length of the long string
  ld l,c
  ld h,b ; hl = Forth IP
  pop bc ; bc = ca2
  ex (sp),hl ; hl = ca1 ; save Forth IP
  push af ; save carry flag
compare.compare_strings: equ $+1 ; XXX not used
  call compare_strings_case_sensitive
  jr nz,compare.no_match

compare.match:
  ; The smaller string matches.
  pop af ; restore flags
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl
  dec hl ; 0
  jp z,push_hl ; string1 equals string2
  dec hl ; -1
  _jp_pushhl

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ; Credit:
  ; Code from DZX-Forth.
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; ----------------------------------------------
  _code_header search_,'SEARCH'

  ; search  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  ; Forth-94

  ; Adapted from DZX-Forth.
  ;
  ; XXX TODO -- do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.  Use shorter
  ; internal code instead.  When case insensitive comparation is
  ; needed, `uppers` can be used.
  ;
  ; XXX TODO --  2015-09-12: make the case mode comparison
  ; configurable seems a better option, easier than customize
  ; several version of the same code with `uppers`, not to
  ; mention `uppers` with parsed strings must use tthe circular
  ; string buffer, what is a limitation.

  exx ; save Forth IP
  pop hl
  ld (search.string_2_len),hl
  ld a,l
  or h ; len2 is zero?
  pop bc ; ca2
  pop hl ; len1
  ld (search.string_1_len),hl
  ex de,hl ; de = len1
  pop hl ; ca1
  ld (search.string_1_addr),hl
  jp z,search.match ; if len2 is zero, match
  dec hl
  inc de
search.1:
  inc hl ; address of current char of string 1
  dec de ; remaining length of string 1
  ld a,e
  or d ; end of string 1?
  jp z,search.no_match
; XXX OLD -- already commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
search.string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings_case_sensitive
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.match:
  ld bc,true
search.end:
  push hl
  push de
  push bc
  exx ; restore Forth IP
  _jp_next

search.no_match:
  ld bc,false
search.string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
search.string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.end

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE]',immediate

  dw tick_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERAL',immediate+compile_only

  ; ----
  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate
  ; ----

  dw compile_,s_lit_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header c_literal_,'CLITERAL',immediate+compile_only

; doc{
;
; cliteral  ( b -- )
;
; If compiling, then compile the stack value _b_ as a 8-bit literal.
; `cliteral` does the same than `literal` but saves one byte of
; dictionary space.
;
; }doc

  ; XXX TODO -- move to the library?

  dw compile_,c_lit_,c_comma_
  dw exit_

; ----------------------------------------------

  ; XXX TODO not used yet
  ; XXX TODO rename to `byte?` (there's a `char?` used by
  ; `number?`)

  ; _code_header char_question_,'CHAR?'

  ; ; Credit:
  ; ; Word adapted from DZX-Forth.

; ; doc{
; ;
; ; char?  ( n -- f )
; ;
; ; Is _n_ an 8-bit number?
; ;
; ; }doc

  ; ; XXX TODO -- use with `interpret` or `literal`?

  ; pop hl
  ; ld l,h
  ; jp zero_equals.hl

; ----------------------------------------------
  _colon_header literal_,'LITERAL',immediate+compile_only

; doc{
;
; literal  ( n -- )
;
; If compiling, then compile the stack value _n_ as a 16-bit literal.
;
; Origin: fig-Forth.
;
; }doc

  dw compile_,lit_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header two_literal_,'2LITERAL',immediate+compile_only

; doc{
;
; 2literal  ( d -- )  \ I
;
; If compiling, then compile the stack value _d_ as a 32-bit literal.
;
; }doc

  dw compile_,two_lit_
  dw swap_,comma_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header depth_,'DEPTH'

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw exit_

; ----------------------------------------------
  _colon_header dictionary_stack_,'?DICTIONARY'

; doc{
;
; ?dictionary  ( -- )
;
; Issue an error message if the dictionary is out of bounds.
;
; }doc

  ; XXX UNDER DEVELOPMENT

  dw zero_ ; XXX TMP
  _question_throw error.dictionary_overflow
  dw exit_

; ----------------------------------------------
  _colon_header question_stack_,'?STACK'

; doc{
;
; ?stack  ( -- )
;
; Issue an error message if the stack is out of bounds.

; Origin: fig-Forth.
;
; }doc

;  dw cr_,blk_,fetch_,dot_ ; XXX INFORMER
;  dw to_in_,fetch_,c_slash_l_,slash_,dot_ ; XXX INFORMER
;  dw dot_s_ ; XXX INFORMER
  dw sp_fetch_
  dw sp0_,fetch_
  dw swap_,less_than_
  _question_throw error.stack_underflow
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_throw error.stack_overflow
  dw exit_

; ----------------------------------------------
  _colon_header not_understood_,'NOT-UNDERSTOOD'

  _literal error.not_understood
  dw throw_

; ----------------------------------------------
  _colon_header compilation_only_,'COMPILATION-ONLY'

  _literal error.compilation_only
  dw throw_

; ----------------------------------------------
  _colon_header nest_source_,'NEST-SOURCE',compile_only

; doc{
;
; nest-source  ( R: -- source-sys )
;
; _source-sys_ describe the current source specification for
; later use by `unnest-source`.

; ----
; : nest-source  ( R: -- source-sys )
;   r>
;   source 2>r
;   source-id >r
;   >in @ >r
;   blk @ >r
;   #tib @ >@
;   >r  ; compile-only
; ----

; }doc

  dw from_r_ ; save the return address
  dw source_,two_to_r_
  dw source_id_,to_r_
  dw to_in_,fetch_,to_r_
  dw blk_,fetch_,to_r_
  dw number_tib_,fetch_,to_r_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _colon_header unnest_source_,'UNNEST-SOURCE',compile_only

; doc{
;
; unnest-source  ( R: source-sys -- )
;
; Restore the source specification described by _source-sys_.

; ----
; : unnest-source  ( R: source-sys -- )
;   r>
;   r> #tib !
;   r> blk !
;   r> >in !
;   r> [ ' source-id >body ] literal !
;   2r> input-buffer 2!
;   >r  ; compile-only
; ----

; }doc

  dw from_r_ ; save the return address
  dw from_r_,number_tib_,store_
  dw from_r_,blk_,store_
  dw from_r_,to_in_,store_
  dw from_r_
  _literal source_id_pfa
  dw store_
  dw two_from_r_,input_buffer_,two_store_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _colon_header evaluate_,'EVALUATE'

; doc{
;
; evaluate  ( i*x ca len -- j*x )
;
; Save the current input source specification. Store minus-one
; (-1) in `source-id`. Make the  string
; described by _ca len_ both the input source and input
; buffer,  set `>in` to zero,  and interpret.  When the  parse
; area  is  empty, restore the prior input source
; specification.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).

; ----
; : evaluate  ( i*x ca len -- j*x )
;   nest-source string>source interpret unnest-source  ;
; ----

; }doc

  dw nest_source_
  dw string_to_source_
  dw interpret_
  dw unnest_source_
  dw exit_

; ----------------------------------------------
  _variable_header interpret_table_,'INTERPRET-TABLE'

; doc{
;
; interpret-table  ( -- a )
;
; Return the address of the execution table used by `interpret`.
; The table contains 13 vectors.  The behaviour of the Forth
; text interpreter can be changed by replacing these vectors.
; See the kernel source for details on the position and function
; of the vectors.
;
; }doc

                        ; compiling...
  dw execute_           ; ...immediate and compile-only word
  dw compile_comma_     ; ...compile-only word
  dw execute_           ; ...immediate word
  dw compile_comma_     ; ...ordinary word
  dw two_literal_       ; ...2-cell number
  dw literal_           ; ...1-cell number

interpret_table.0:
  dw not_understood_    ; not a number (error)

                        ; interpreting...
  dw 0                  ; ...1-cell number (do nothing)
  dw 0                  ; ...2-cell number (do nothing)
  dw execute_           ; ...ordinary word
  dw execute_           ; ...immediate word
  dw compilation_only_  ; ...compile-only word (error)
  dw compilation_only_  ; ...immediate and compile-only word (error)

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'

; doc{
;
; interpret  ( -- )
;
; The text interpreter which sequentially executes or compiles
; text from the input stream (terminal or disk) depending on
; `state`. if the word name cannot be found after a search of
; the `context` search order it is converted to a number
; according to the current `base`.  That also failing, an error
; message will be given.
;
; }doc

interpret.begin:

  dw question_stack_
  dw parse_name_  ; ( ca len )
  dw dup_ ; end of stream?
  dw zero_branch_,interpret.end ; if so, finish

  dw find_name_ ; ( nt | 0 )
  dw question_dup_ ; found?
  dw zero_branch_,interpret.word_not_found

  ; Word found
  ; ( nt )
  dw dup_,name_to_immediate_question_       ; ( nt xt f1 )
  dw rot_,compile_only_question_,two_star_  ; ( xt f1 n2 )
  dw plus_,abs_ ; ( xt +n )
  _literal 3
  dw plus_ ; adjust the table index

interpret.do_it:
  ; ( +n )
  ; Execute element _+n_ of `interpret-table`,
  ; depending on `state`.
  dw compiling_question_,question_negate_,cells_
  _literal interpret_table.0
  dw plus_,perform_
  dw branch_,interpret.begin

interpret.word_not_found:
  dw parsed_name_,two_fetch_ ; ( ca len )
  dw number_question_ ; is it a number?  ( 0 | n 1 | d 2 )
  dw branch_,interpret.do_it

interpret.end:
  dw two_drop_
  dw exit_

; ----------------------------------------------
  _c_constant_header immediate_mask_,'IMMEDIATE-MASK'

; doc{
;
; immediate-mask  ( -- b )
;
; Constant that holds the bitmask of the precedence bit.
;
; }doc

  db immediate_mask

; ----------------------------------------------
  _colon_header lex_question_,'LEX?'

; doc{
;
; lex?  ( nt b -- )
;
; Test the bits at _nt_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

if 1

  dw system_bank_
  dw swap_,c_fetch_test_bits_question_
  dw default_bank_
  dw exit_

else  ; XXX TMP alternative without `c@test-bits?`

  dw system_bank_
  dw swap_,c_fetch_s_,and_,zero_not_equals_
  dw default_bank_
  dw exit_

endif

; ----------------------------------------------
  _colon_header lex_store_,'LEX!'

; doc{
;
; lex!  ( b nt -- )
;
; Set the bits of the mask _b_ in the length byte of _nt_.
;
; }doc

  ; Credit:
  ; Word adapted from eForth.

  dw system_bank_,c_store_set_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header set_latest_lex_,'SET-LATEST-LEX'

; doc{
;
; set-latest-lex  ( b -- )
;
; Set the bits of the mask _b_ in the length byte of the latest
; defined word.
;
; }doc

  dw latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIATE'

  dw immediate_mask_,set_latest_lex_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_question_,'IMMEDIATE?'

; doc{
;
; immediate?  ( nt -- wf )
;
; Does the word with the given _nt_ is immediate?
;
; }doc

  dw immediate_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header name_to_immediate_question_,'NAME>IMMEDIATE?'

; doc{
;
; name>immediate?  ( nt -- xt wf )
;
; Does the word with the given _nt_ is immediate?
;
; }doc

  ; XXX TODO better name!
  ; this name is confusing, compared to `immediate?`,
  ; which converts a nt to a flag.

  dw dup_,from_name_,swap_ ; ( xt nt )
  dw immediate_question_ ; ( xt wf )
  dw exit_

; ----------------------------------------------
  _c_constant_header compile_only_mask_,'COMPILE-ONLY-MASK'

; doc{
;
; compile-only-mask  ( -- b )
;
; Constant that holds the bitmask of the compile-only bit.
;
; }doc

  db compile_only_mask

; ----------------------------------------------
  _colon_header compile_only_,'COMPILE-ONLY'

  dw compile_only_mask_,set_latest_lex_
  dw exit_

; ----------------------------------------------
  _colon_header compile_only_question_,'COMPILE-ONLY?'

; doc{
;
; compile-only?  ( nt -- wf )
;
; Does the word with the given _nt_ is compile-only?
;
; }doc

  dw compile_only_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_comma_,'WORDLIST,'

; doc{
;
; wordlist,  ( -- )
;
; Compile the contents of a new word list.
; The structure is the following:
;
; |===
; | +0 | _nt_ of last definition
; | +2 | _wid|0_, next wordlist in chain, or zero
; | +4 | _nt|0_, wordlist name pointer, or zero
; |===
;
; ----
; : wordlist,  ( -- )
;   0 ,  here voc-link @ , voc-link !  0 ,  ;
; ----
;
; }doc

  _literal 0
  dw comma_                   ; nt of the latest word defined in the vocabulary
  dw here_                    ; new contents of vocabulary link
  dw voc_link_,fetch_,comma_  ; compile the previous contents of `voc-link`
  dw voc_link_,store_         ; update `voc-link`
  _literal 0
  dw comma_                   ; nt of the wordlist, or zero
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_,'WORDLIST'

; Credit: Most code related to word lists has been adapted from
; eForth.

; doc{
;
; wordlist  ( -- wid )
;
; : wordlist ( -- wid )
;   here wordlist, ;
;
; }doc

  dw here_,wordlist_comma_
  dw exit_

; ----------------------------------------------
  _colon_header vocabulary_,'VOCABULARY'

; doc{
;
; vocabulary  ( "name" -- )
;
; Create a dictionary entry for "name" which specifies a new
; ordered list of word definitions.  Subsequent execution of
; "name" replaces the first vocabulary in the search order with
; "name", or just add it if the search order is empty.
;
; ----
; : vocabulary  ( "name" -- )
;   create  wordlist,
;   does>   ( -- )  ( pfa ) context !  ;
; ----
;
; }doc

; XXX TODO -- Check what Forth-83 systems do when the search
; order is empty and a vocabulary is executed.

; XXX REMARK -- This word can not be moved to the library,
; because `root`, `forth` and `assembler` are vocabularies,
; and they point to `do_vocabulary`:

  dw create_,wordlist_comma_
  dw paren_semicolon_code_
do_vocabulary:
  call do_does
  ; The following words are to be executed when the vocabulary is invoked.
  dw context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header get_current_,'GET-CURRENT'

; doc{
;
; get-current  ( -- wid )
;
; Return _wid_, the identifier of the compilation word list.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : get-current  ( -- wid )
;   current @  ;
; ----
;
; }doc

  dw current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header set_current_,'SET-CURRENT'

; doc{
;
; set-current  ( wid -- )
;
; Set the compilation word list to the word list identified by
; _wid_.
;
; Origin: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : set-current  ( wid -- )
;   current !  ;
; ----
;
; }doc

  dw current_,store_
  dw exit_

; ----------------------------------------------
  _colon_header definitions_,'DEFINITIONS'

; doc{
;
; definitions  ( -- )
;
; Make the compilation word list the same as the first  word
; list in the search order. The  names of subsequent definitions
; will be placed in the compilation word list. Subsequent
; changes in the search  order will not affect the compilation
; word list.
;
; ----
; : definitions  ( -- )
;   context @ set-current  ;
; ----
;
; }doc

  dw context_,fetch_,set_current_
  dw exit_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

; doc{
;
; (  ( f "ccc<paren>" -- )
;
; Parse until a right paren is found.  The number of parsed
; characters may be zero to the number of characters in the
; parse area.
;
; }doc

  _literal ')'
  dw parse_,two_drop_
  dw exit_

; ----------------------------------------------
  _colon_header dot_ok_,'.OK'

; doc{
;
; .ok  ( -- )
;
; Print "ok". This is the default behaviour of `ok`, the word
; called by `quit` after interpreting a command.
;
; }doc

  dw paren_dot_quote_
  _string 'ok'
  dw exit_

; ----------------------------------------------
  _defer_header ok_,'OK',,dot_ok_

; doc{
;
; ok  ( -- )
;
; A deferred word called by `quit` after interpreting a command.
; Its default behaviour is the word `.ok`.
;
; }doc

; ----------------------------------------------
  _colon_header quit_,'QUIT'

  dw terminal_to_source_
  dw left_bracket_
quit.begin:
  dw rp0_,fetch_,rp_store_
  dw cr_,query_ ; XXX TMP ; XXX TODO
  dw interpret_
  dw compiling_question_
  dw question_branch_,quit.begin
  dw ok_
  dw branch_,quit.begin

; ----------------------------------------------
  _colon_header paren_defer_,'(DEFER)'

; doc{
;
; (defer)  ( -- )
;
; Default behaviour of an uninitialized deferred word: error.
;
; }doc

  _literal error.deferred_word_uninitialized
  dw error_
  dw exit_

; ----------------------------------------------
  _colon_header defer_,'DEFER'

; doc{
;
; defer  ( "name" -- )
;
; Create a deferred word.
;
; Origin: Forth-2012 (CORE EXT).
;
; }doc

  dw header_,reveal_
  _literal $C3 ; Z80 opcode for `jp NN`
  dw c_comma_
  _literal paren_defer_ ; default xt to execute
  dw comma_

  dw exit_


; ----------------------------------------------
  _alias_header to_defer_,'>DEFER',,one_plus_

; doc{
;
; >defer  ( xt1 -- a )
;
; Return the address _a_ that holds the xt currently associated
; to the deferred word _xt1_.
;
; }doc

; ----------------------------------------------
  _colon_header defer_fetch_,'DEFER@'

; doc{
;
; defer@  ( xt1 -- xt2 )
;
; Return the word _xt2_ currently associated to the deferred
; word _xt1_.
;
; Origin: Forth-2012 (CORE EXT).
;
; }doc

  dw to_defer_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header defer_store_,'DEFER!'

; doc{
;
; defer!  ( xt1 xt2 -- )
;
; Change the deferred word _xt2_ to execute _xt1_.
;
; Origin: Forth-2012 (CORE EXT).
;
; }doc

  dw to_defer_,store_
  dw exit_

; ----------------------------------------------
  _variable_header version_,'VERSION'

; doc{
;
; version  ( -- a )
;
; Return an address that holds the Solo Forth version, as
; follows:
;
; +0: major (one byte)
; +1: minor (one byte)
; +2: patch (one byte)
; +3: pre-release (one byte), zero if none
; +4: build (two cells)
;
; }doc

  db version_major
  db version_minor
  db version_patch
  db version_prerelease
  dw version_build_high_part
  dw version_build_low_part

; ----------------------------------------------
  _colon_header dot_version_,'.VERSION'

; doc{
;
; .version  ( -- )
;
; Print the Solo Forth version.
;
; }doc

  dw version_
  dw dup_,c_fetch_,zero_dot_r_
  _literal '.'
  dw emit_
  dw one_plus_,dup_,c_fetch_,zero_dot_r_
  _literal '.'
  dw emit_
  dw one_plus_,dup_,c_fetch_,zero_dot_r_
  dw one_plus_
if version_prerelease
  dw paren_dot_quote_
  _string "-pre."
  dw dup_,c_fetch_,zero_dot_r_
endif
dot_version.build
  _literal '+'
  dw emit_
  dw one_plus_,two_fetch_,d_dot_

  dw exit_

; ----------------------------------------------
  _colon_header greeting_,'GREETING'

; doc{
;
; greeting  ( -- )
;
; Print the boot message.
;
; }doc

  dw paren_dot_quote_
  _string "Solo Forth\rVersion "
  dw dot_version_
  dw paren_dot_quote_
  _string "\rBy Marcos Cruz\r(programandala.net), 2015, 2016\r"

  dw unused_,u_dot_
  dw paren_dot_quote_
  _string "B free"

  dw exit_

; ----------------------------------------------
  _defer_header boot_,'BOOT',,noop_

; doc{
;
; boot  ( -- )
;
; A deferrer word executed by `abort`. By default it does
; nothing. It is changed by `turnkey`.
;
; }doc

; ----------------------------------------------
  _variable_header previous_mode_,'PREVIOUS-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; previous-mode  ( -- a )
;
; Variable that holds the xt of the word that activates the
; screen mode that was active before executing `bye`.  It's
; updated by `bye`, and used by `warm` to restore the current
; mode.
;
; }doc

  dw noop_

; ----------------------------------------------
  _variable_header current_mode_,'CURRENT-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; current-mode  ( -- a )
;
; Variable that holds the xt of the word that activates the
; current screen mode. It's set to `noop` until the first mode
; change is done.
;
; }doc

  dw noop_

; ----------------------------------------------
  _colon_header save_mode_,'SAVE-MODE'

  dw current_mode_,fetch_
  dw previous_mode_,store_
  dw exit_

; ----------------------------------------------
  _colon_header restore_mode_,'RESTORE-MODE'

  dw previous_mode_,perform_
  dw exit_

; ----------------------------------------------
  _colon_header warm_,'WARM'

; doc{
;
; warm  ( -- )
;
; }doc

  dw display_
  dw restore_mode_
  dw page_ ; note: this must be after changing the screen mode
  dw abort_
  ; No return from `abort`.

warm_start:
  call common_start
  dw warm_

; ----------------------------------------------
  _colon_header cold_,'COLD'

; doc{
;
; cold  ( -- )
;
; }doc

  ; Init the names pointer.
  dw lit_,names_pointer_init_value,fetch_
  dw lit_,names_pointer,store_

;  _brk 'cold -- before empty-buffers' ; XXX INFORMER

  ; Init the disk buffers.
  dw empty_buffers_

  ; Init the circular string buffer.
  dw empty_csb_

  ; Init the user variables.
  dw lit_,default_user_variables_start ; from
  dw up_,fetch_ ; to
  _literal default_user_variables_end-default_user_variables_start ; length
  dw c_move_

;  _brk 'cold -- after cmove' ; XXX INFORMER

  ; Restore the vocabularies to the default state.
  dw lit_,latest_nt_in_root_voc.init_value,fetch_
  dw lit_,root_pfa,store_
  dw lit_,latest_nt_in_forth_voc.init_value,fetch_
  dw lit_,forth_pfa,store_
if 1 ; assembler_core_in_kernel
  dw lit_,latest_nt_in_assembler_voc.init_value,fetch_
  dw lit_,assembler_pfa,store_
endif
  dw lit_,voc_link.init_value,fetch_
  dw lit_,voc_link_pfa,store_

  dw only_,forth_,definitions_  ; init the search order
  dw default_header_ ; restore the default behaviour of `header`
  dw decimal_

  dw display_,default_colors_,page_
  dw greeting_

  dw abort_

cold_start:
only_first_cold: ; XXX TMP -- temporary label
  call move_name_fields_to_memory_bank ; (only the first time)
  call common_start
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  ; (SP) = xt of `cold` or `warm`

  im 1 ; interrupt mode 1
  pop bc ; get the return address, which holds the xt of `cold` or `warm`
  ld (system_stack_pointer),sp ; save the system stack pointer
  ld sp,(sp0_init_value)
  ld (iy+sys_df_sz_offset),0 ; no lines at the bottom part of the screen
  ld ix,next ; restore IX
  _jp_next ; jump to the xt pointed by the register pair BC

; ----------------------------------------------
  _alias_header d_to_s_,'D>S',,drop_

; doc{
;
; d>s  ( d -- n )
;
; Origin: Forth-94 (DOUBLE), Forth-2012 (DOUBLE).
;
; ----
; : d>s  ( d -- n )
;   drop  ;
; ----
; }doc

; ----------------------------------------------
  _code_header s_to_d_,'S>D'

; doc{
;
; s>d  ( n -- d )
;
; Sign extend a single number _n_ to form a double number _d_.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : s>d  ( n -- d )
;   dup 0<  ;
; ----
;
; }doc

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_hlde ; jump if positive
  dec hl
  jp push_hlde

; ----------------------------------------------
  _code_header question_negate_,'?NEGATE'

; doc{
;
; ?negate  ( n1 n2 -- n1|n3 )
;
; If _n2_ is negative, negate _n1_, giving its arithmetic
; inverse _n3_.
;
; ----
; : ?negate  ( n1 n2 -- n1|n3 )
;   0< if  negate  then  ;
; ----
;
; Origin: fig-Forth's `+-`.
;
; }doc

  pop hl
question_negate.hl:
  bit 7,h
  jp nz,negate_
  _jp_next

; ----------------------------------------------
  _code_header question_d_negate_,'?DNEGATE'

; doc{
;
; ?dnegate  ( d1 n -- d1|d2 )
;
; If _n_ is negative, negate _d1_, giving its arithmetic inverse
; _d2_.
;
; ----
; : ?dnegate  ( d1 n -- d1|d2 )
;   0< if  dnegate  then  ;
; ----
;
; Origin: fig-Forth's `d+-`.
;
; }doc

  pop hl
question_d_negate.hl:
  bit 7,h
  jp nz,d_negate_
  _jp_next

; ----------------------------------------------
  _code_header abs_,'ABS'

; doc{
;
; abs  ( n -- u )
;
; Leave the absolute value _u_ of a number _n_.
;
; ----
; : abs  ( n -- u )
;   dup ?negate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_negate.hl

if 0

  ; XXX OLD -- from DZX-Forth

  pop hl
  call abs_hl
  _jp_pushhl

endif

; ----------------------------------------------
  _code_header d_abs_,'DABS'

; doc{
;
; dabs  ( d -- ud )
;
; Leave the absolute value _ud_ of a double number _d_.
;
; ----
; : dabs  ( d -- ud )
;   dup ?dnegate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_d_negate.hl

; ----------------------------------------------
  _code_header umax_,'UMAX'

; doc{
;
; umax  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  _compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMIN'

; doc{
;
; umin  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  _compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MIN'

  ; Credit:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MAX'

  ; Credit:
  ; Code adapted from DZX-Forth.

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  push de
  _jp_next

; ----------------------------------------------
  _colon_header m_star_,'M*'

; doc{
;
; m*  ( n1 n2 -- d )
;
; Multiply _n1_ by _n2_ producing the result _d_.
;
; Origin: fig-Forth, Forth-94, Forth-2012.
;
; ----
; : m*  ( n1 n2 -- d )
;   2dup xor >r
;   abs swap abs um*
;   r> ?dnegate  ;
; ----
;
; }doc

if 1 ; original_m_star

  ; Credit:
  ; Code from Abersoft Forth.

  ; XXX Note: this code is used also by Z88 CamelForth.

  dw two_dup_,xor_,to_r_
  dw abs_,swap_,abs_,u_m_star_
  dw from_r_,question_d_negate_
  dw exit_

else

  ; XXX TODO -- code from DZX-Forth

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_signed
  jp push_hlde

endif

; ----------------------------------------------
  _defer_header m_slash_,'M/',,s_m_slash_rem_

; doc{
;
; m/  ( d n1 -- n2 n3 )
;
; A mixed magnitude math operator which leaves the signed
; remainder _n2_ and signed quotient _n3_ from a double number
; dividend and divisor _n1_.
;
; This word is deferred and by default it's set to execute
; `sm/rem`, so it does a symmetric division (the  remainder
; takes its sign from the dividend), as in fig-Forth.  It can be
; set to execute `fm/mod` instead.
;
; This word is executed by all other division operators.
; Therefore setting it to execute either `sm/rem` or `fm/mod`
; will change the behaviour of all division operators.
;
; Origin: fig-Forth.
;
; }doc

; ----------------------------------------------
  _colon_header s_m_slash_rem_,'SM/REM'

; doc{
;
; sm/rem  ( d n1 -- n2 n3 )
;
; Symmetric division:
;
;   d = n3*n1+n2;

;   sign(n2) = sign(d1) or 0
;
; Divide _d_ by _n1_, giving the symmetric quotient _n3_ and the
; remainder _n2_. Input and output stack arguments are signed.

; [caption="Symmetric Division Example"]
;
;  |===
;  | Dividend   | Divisor  | Remainder  | Quotient

; >|       10  >|      7  >|        3  >|        1
; >|      -10  >|      7  >|       -3  >|       -1
; >|       10  >|     -7  >|        3  >|       -1
; >|      -10  >|     -7  >|       -3  >|        1
;  |===

; Origin: Forth-94 (CORE), Forth-2012 (CORE).

; ----
; : sm/rem  ( d1 n1 -- n2 n3 )
;   \ symmetric signed division
;   2dup xor >r  \  sign of quotient
;   over >r      \  sign of remainder
;   abs >r dabs r> um/mod
;   swap r> ?negate
;   swap r> ?negate  ;
; ----

; }doc


  dw two_dup_,xor_,to_r_
  dw over_,to_r_
  dw abs_,to_r_,d_abs_,from_r_,u_m_slash_mod_
  dw swap_,from_r_,question_negate_
  dw swap_,from_r_,question_negate_
  dw exit_

; ----------------------------------------------
  _colon_header star_,'*'


; doc{
;
; *  ( n1|u1 n2|u2 -- n3|u3 )
;
; Multiply n1|u1 by n2|u2 giving the product n3|u3.
;
; Origin: fig-Forth, Forth-79, Forth-83, Forth-94, Forth-2012.
;
; }doc

if 1

  dw m_star_,drop_
  dw exit_

else

  ; XXX TODO -- from DZX-Forth

  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

endif

; ----------------------------------------------
  _colon_header slash_mod_,'/MOD'

; doc{
;
; /mod  ( n1 n2 -- n3 n4 )
;
; Divide _n1_ by _n2_ and leave the remainder _n3_ and quotient
; _n4_.
;
; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; }doc

  dw to_r_,s_to_d_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header slash_,'/'

; doc{
;
; /  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the quotient _n3_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : /  ( n1 n2 -- n3 )
;   /mod nip  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header mod_,'MOD'

; doc{
;
; mod  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the single-cell remainder _n3_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : mod  ( n1 n2 -- n3 )
;   /mod drop  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw slash_mod_,drop_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MOD'

; doc{
;
; */mod  ( n1 n2 n3 -- n4 n5 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; result _d_. Divide _d_ by _n3_ producing the remainder
; _n4_ and the quotient _n5_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */mod  ( n1 n2 n3 -- n4 n5 )
;   >r m* r> m/  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw to_r_,m_star_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_,'*/'

; doc{
;
; */  ( n1 n2 n3 -- n4 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; _d_. Divide _d_ by _n3_ giving the quotient _n4_.

; Origin: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */  ( n1 n2 n3 -- n4 )
;   */mod nip  ;
; ----
;
; }doc

  ; Credit:
  ; Code from Abersoft Forth.

  dw star_slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header line_to_string_,'LINE>STRING'

; doc{
;
; line>string  ( n1 n2 -- ca len )
;
; Convert the line number _n1_ and the screen number _n2_ to a
; string _ca len_ in the disk buffer containing the data.
;
; Note: in fig-Forth, this word is called `(line)`.
;
; ----
; : line>string  ( n1 n2 -- ca len )
;   >r  c/l b/buf */mod  r> +
;   block + c/l  ;
; ----
; }doc

  ; XXX TODO -- move to the library?
  ; the problem is `located` needs it,
  ; thus it can not be loaded with `need`.

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_
  dw plus_
  dw block_,plus_,c_slash_l_
  dw exit_

; XXX OLD
; ; ----------------------------------------------
;   _colon_header warning_,'WARNING'

; ; doc{
; ;
; ; warning  ( n -- )
; ;
; ; ----
; ; : warning  ( n -- )
; ;   warnings @ if  message  else  drop  then  ;
; ; ----
; ; }doc

;   dw warnings_,fetch_
;   dw question_branch_,message_pfa
;   dw drop_
;   dw exit_


; ----------------------------------------------
  _colon_header dec_dot_,'DEC.'

  dw base_,fetch_,swap_,decimal_,dot_,base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header dot_throw_hash_,'.THROW#'

; doc{
;
; .throw#  ( n -- )
;
; Print the number of throw error _n_.
;
; }doc

  dw paren_dot_quote_
  _string 'Exception #'
  dw dec_dot_
  dw exit_

; ----------------------------------------------
  _defer_header dot_throw_,'.THROW',,dot_throw_hash_

  ; Credit:
  ; Name from MPE Forth for TiniARM.

; doc{
;
; .throw  ( n -- )
;
; Deferred word that prints error message _n_. By default it
; prints only the number.
;
; }doc

; ----------------------------------------------
  _colon_header updated_question_,'UPDATED?'

; doc{
;
; updated?  ( -- f )
;
; Is the current disk buffer marked as modified?
;
; ----
; : updated?  ( -- f )
;   buffer-id 0<  ;
; ----
; }doc

  dw buffer_id_,zero_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFERS'

; doc{
;
; empty-buffers  ( -- )
;
; Unassign all block buffers. Do not transfer the contents of
; any updated block to mass storage.
;
; ----
; : empty-buffers  ( -- )
;   $7FFF block disk-buffer !  ;
; ----
; }doc

  _literal buffer_block_id_mask
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_id_,'BUFFER-ID'

; doc{
;
; buffer-id  ( -- x )
;
; Id of the disk buffer.
;
; }doc

  dw disk_buffer_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_block_,'BUFFER-BLOCK'

; doc{
;
; buffer-block  ( -- n )
;
; Return the block _n_ associated with the disk buffer.
;
; ---
; : buffer-block  ( -- n )
;   buffer-id $7FFF literal and  ;
; ---
;
; }doc

  dw buffer_id_
  _literal buffer_block_id_mask
  dw and_
  dw exit_

; ----------------------------------------------
  _colon_header free_buffer_,'FREE-BUFFER'

; doc{
;
; free-buffer  ( n -- )
;
; If the current disk buffer has been updated, write its block
; to the disk. Assign block number _n_ to the disk buffer.
;
; ----
; : free-buffer  ( n -- )
;   updated?  if    buffer-block write-buffer
;             then  disk-buffer !  ;
; ----
;
; }doc

;  _chk "free-buffer -- start" ; XXX INFORMER
  dw updated_question_
  dw zero_branch_,free_buffer.end
  dw buffer_block_,write_block_
  dw branch_,free_buffer.end
free_buffer.end:
;  _chk "free-buffer.end" ; XXX INFORMER
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_,'BUFFER'

; doc{
;
; buffer  ( n -- a )
;
; Assign the block buffer to block _n_.   If the contents of the
; buffer were marked as updated, it is written to the disk.  The
; block _n_ is not read from the disk.  The address _a_ left on
; stack is the first cell in the buffer for data storage.
;
; ----
; : buffer  ( n -- a )
;   dup buffer-block =
;   if  drop  else  (buffer)  then  buffer-data  ;
; ----
;
; }doc

;  _chk "buffer -- start" ; XXX INFORMER
  dw dup_,buffer_block_,equals_
  dw zero_branch_,buffer.not_equals
  ; The requested block is the one already in the buffer.
  dw drop_
  dw branch_,buffer.end
buffer.not_equals:
;  _chk "buffer.not_equals" ; XXX INFORMER
  dw free_buffer_
buffer.end:
;  _chk "buffer.end" ; XXX INFORMER
  dw buffer_data_ ; first cell of data in the buffer
  dw exit_

; ----------------------------------------------
  _colon_header block_,'BLOCK'

; doc{
;
; block  ( n -- a )

; If the block _n_ is already in memory, leave the address _a_
; of the first cell in the disk buffer for data storage.
;
; If the block _n_ is not already in memory, transfer it from
; disk to the buffer.  If the block occupying that buffer has
; been marked as updated, rewrite it to disk before block _n_ is
; read into the buffer.  Finally leave the address _a_ of the
; first cell in the disk buffer for data storage.
;
; ----
; : block ( n -- a )
;   dup buffer-block =
;   if    drop
;   else  save-buffers  dup read-block  disk-buffer !
;   then  buffer-data  ;
; ----
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,block.not_equals
  dw drop_
  dw branch_,block.end
block.not_equals:
;  _brk "block.not_equals" ; XXX INFORMER
  dw save_buffers_,dup_,read_block_
  dw disk_buffer_,store_
block.end:
;  _brk "block.end" ; XXX INFORMER
  dw buffer_data_
  dw exit_

; ----------------------------------------------
  _code_header flip_,'FLIP'

; doc{
;
; flip  ( n1 -- n2 )
;
; Exchange the low and high bytes within _n1_.
;
; Note: This word is called `><` or `cswap` in other Forth
; systems.
;
; Origin: eForth.
;
; }doc

; Credit:
; The name "flip" was borrowed from eForth.

  pop hl
  ld a,h
  ld h,l
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _colon_header sector_id_,'SECTOR-ID'

; doc{

; sector-id  ( n1 -- n2 )

; Convert the sequential disk sector _n1_ to the disk sector id
; _n2_, in the format required by G+DOS: The high byte of _n2_
; is the track (0..79 for side 0; 128..207 for side 1); the low
; byte of _n2_ is the sector (1..10).
;
; ----
; : sector-id  ( n1 -- n2 )
;   \ n2 (high byte) = track 0..79 for side 0, 128..207 for side 1
;   \    (low byte)  = sector 1..10
;   \ track0 = 0..79
;   \ track = 0..207
;   \ side = 0..1
;   dup 10 mod 1+       ( n1 sector )
;   swap dup 20 /       ( sector n1 track0 )
;   swap 10 / 1 and     ( sector track0 side )
;   128                 ( sector track 128 )
;   negate 128 and or   ( sector track )
;   flip or  ;
; ----
;
; }doc

  dw dup_
  _literal 10
  dw mod_,one_plus_,swap_,dup_
  _literal 20
  dw slash_,swap_
  _literal 10
  dw slash_,one_,and_

  dw negate_
  _literal 128
  dw and_,or_

  dw flip_,or_
  dw exit_

; ----------------------------------------------
  _colon_header read_block_,'READ-BLOCK'

; doc{
;
; read-block  ( n -- )
;
; Read disk block _n_ to the buffer.
;
; ----
; : read-block  ( n -- )
;   disk> transfer-block  ;
; ----
;
; }doc

  dw read_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header write_block_,'WRITE-BLOCK'

; doc{
;
; write-block  ( n -- )
;
; Write the buffer to disk block _n_.
;
; ----
; : write-block  ( n -- )
;   >disk transfer-block  ;
; ----
;
; }doc

  dw write_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header transfer_block_,'TRANSFER-BLOCK'

; doc{
;
; transfer-block  ( n -- )
;
; The block-level disk read-write linkage.
; Transfer block _n_ to or from disk.
; The read or write mode must be previously set
; by `>disk` or `disk>`.
;
; }doc

  ; XXX TODO restore the current drive

  dw rec_slash_blk_,star_ ; sequential number of the first sector of the block
  dw dup_
  dw sector_id_
  dw buffer_data_
  dw transfer_sector_

  dw one_plus_,sector_id_

  ; XXX TODO -- benchmark again
  dw buffer_data_,b_slash_rec_,plus_ ; XXX 23768 frames
  ;_literal disk_buffer+cell+bytes_per_sector ; XXX 24425 frames??

  dw transfer_sector_

  dw exit_

; ----------------------------------------------
  _code_header transfer_sector_,'TRANSFER-SECTOR'

; doc{
;
; transfer-sector  ( x a -- )
;
; The sector-level disk read-write linkage.
; Transfer sector _x_ to or from disk.
; The read or write mode must be previously set
; by `>disk` or `disk>`.
;
; x = sector to read or write
;     high byte = track 0..79, +128 if side 1
;     low byte  = sector 1..10
; a = source or destination address
;
; }doc

; XXX TODO -- format the parameters list of the documentation,
; and other similar cases as well

  pop ix ; address
  pop de ; d = track 0..79, +128 if side 1
         ; e = sector 1..10
  push bc ; save the Forth IP
  ld a,2 ; drive
  rst 8 ; G+DOS hook
transfer_sector.command:
  ; G+DOS command already patched:
  db $44 ; $44 = read ; $45 = write
  pop bc ; restore the Forth IP
  ld ix,next
  _jp_next

; ----------------------------------------------
  _colon_header transfer_mode_,'TRANSFER-MODE'

; doc{
;
; transfer-mode  ( b -- )
;
; Set read or write mode for `transfer-sector` and
; `transfer-block`.
;
; b = $44 (read) or $45 (write)
;
; }doc

  dw lit_,transfer_sector.command,c_store_
  dw exit_

; ----------------------------------------------
  _colon_header write_mode_,'WRITE-MODE'

; doc{
;
; write-mode  ( -- )
;
; Set the write mode for `transfer-sector` and `transfer-block`.
;
; }doc

  _literal $45 ; G+DOS write sector command
  dw transfer_mode_
  dw exit_

; ----------------------------------------------
  _colon_header read_mode_,'READ-MODE'

; doc{
;
; read-mode  ( -- )
;
; Set the read mode for `transfer-sector` and `transfer-block`.
;
; }doc

  _literal $44 ; G+DOS read sector command
  dw transfer_mode_
  dw exit_

; **************************************************************
; +3DOS

; XXX UNDER DEVELOPMENT

if defined plus3dos and false  ; XXX TMP

back_from_dos:
  ; cy = no error?
  ; a  = error code
  jp c,false_   ; no error

back_from_dos.error:
  ; a = error code
  call convert_dos_error_code
  ; hl = error code
  _jp_pushhl

convert_dos_error_code:
  ; Input:   a  = original DOS error code (0..36)
  ; Outptut: hl = DOS error code converted to Forth range (-1000..-1036)
  ; XXX TODO use standard codes?
  ; XXX TODO make a Forth word to access this code?
  ld h,0
  ld l,a
convert_dos_error_code.hl:
  ld de,1000
  add hl,de
  jp negate_hl

get_current_drive:
  ld a,$FF

set_current_drive:
  ; a = drive (ASCII 'A'..'P' to set it; $FF to get it)
  ld ix,dos_set_drive
  jr do_dos

get_current_user:
  ld a,$FF

set_current_user:
  ; a = user ($00..0x0F to set it; $FF to get it)
  ld ix,dos_set_user

; ------------------------------
; DOS call

dos:

  ; Adapted from the ZX Spectrum +3 manual.

  ; IX holds the address of the DOS routine to be run. All other registers are
  ; passed intact to the DOS routine and are returned from it.

  ; Stack must be somewhere in central 32K (conforming to DOS requirements), so
  ; saved AF and BC will not be switched out.

  push af
  push bc                  ; temp save registers while switching
  ld   a,(sys_bankm)       ; RAM/ROM switching system variable
  or   7                   ; want RAM page 7
  res  4,a                 ; and DOS ROM
  ld   bc,bank1_port       ; port used for horiz ROM switch and RAM paging
  di
  ld   (sys_bankm),a       ; keep system variables up to date
  out  (c),a               ; RAM page 7 to top and DOS ROM
  ei
  pop  bc
  pop  af

  call call_dos.ix         ; go sub routine address in IX

  push af
  push bc
  ld   a,(sys_bankm)
  and  0F8h                ; reset bits for page 0
  set  4,a                 ; switch to ROM 3 (48 BASIC)
  ld   bc,bank1_port
  di
  ld   (sys_bankm),a
  out  (c),a               ; switch back to RAM page 0 and 48 BASIC
  ei
  pop  bc
  pop  af
  ret

call_dos.ix:

  jp   (ix)                ; standard way to CALL (IX), by calling this jump

; ------------------------------
; DOS call preserving the Forth IP

; This is used when the BC register (the Forth IP) is not a parameter of the
; DOS routine

do_dos:
  ; IX = DOS routine to run
  push bc
  call dos
  pop bc
  ret

; **************************************************************

endif

; ----------------------------------------------
  _colon_header save_buffers_,'SAVE-BUFFERS'

; doc{
;
; save-buffers  ( -- )
;
; If the disk buffer has been modified, transfer its contents to
; disk and mark it as unmodified.
;
; ----
; : save-buffers ( -- )
;   updated? 0= ?exit \ exit if not updated
;   buffer-block dup write-block  disk-buffer !  ;
; ----
;
; Origin: Forth-94.
;
; }doc

  dw updated_question_,zero_equals_ ; not updated?
  dw question_exit_ ; exit if not updated
  ; Updated
  dw buffer_block_,dup_,write_block_
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header set_source_,'SET-SOURCE'

; doc{
;
; set-source  ( ca len -- )
;
; Set the memory zone _ca len_ as the current source by pointing
; the input buffer to it.

; ----
; : set-source  ( ca len -- )
;   input-buffer 2!  >in off  ;
; ----
;
; }doc

  dw input_buffer_,two_store_
  dw to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header string_to_source_,'STRING>SOURCE'

; doc{
;
; string>source  ( ca len -- )
;
; Set the string _ca len_ as the current source.
;
; ----
; : string>source  ( ca len -- )
;   blk off
;   [ ' source-id >body ] literal on
;   set-source  ;
; ----
; }doc

  dw blk_,off_
  _literal source_id_pfa
  dw on_
  dw set_source_
  dw exit_

; ----------------------------------------------
  _colon_header terminal_to_source_,'TERMINAL>SOURCE'

; doc{
;
; terminal>source  ( -- )
;
; Set the terminal as the current source.
;
; ----
; : terminal>source  ( -- )
;   blk off
;   [ ' source-id >body ] literal off
;   tib #tib @ set-source  ;
; ----
;
; }doc

  dw blk_,off_
  _literal source_id_pfa
  dw off_
  dw tib_,number_tib_,fetch_,set_source_
  dw exit_

; ----------------------------------------------
  _colon_header block_to_source_,'BLOCK>SOURCE'

; doc{
;
; block>source  ( u -- )
;
; Set block _u_ as the current source.
;
; ----
; : block>source  ( u -- )
;   blk !  >in off  ;
; ----
;
; }doc

  dw blk_,store_,to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header paren_load_,'(LOAD)'

; doc{
;
; (load)  ( u -- )
;
; Making block _u_ the current input source and interpret it.

; This word is a common factor of `load` and `continued`.
;
; ----
; : (load)  ( u -- )
;   block>source interpret  ;
; ----
;
; }doc

  dw block_to_source_,interpret_
  dw exit_

; ----------------------------------------------
  _colon_header load_,'LOAD'

; doc{
;
; load  ( u -- )
;
; XXX TODO update the description
;
; Save the current input-source specification. Store the first
; disk block of screen _u_ in `blk` (thus making screen _u_ the
; input source and setting the input buffer to encompass its
; contents), set `>in` to zero, and interpret. When the parse
; area is exhausted, restore the prior input source
; specification.
;
; An error is issued if _u_ is zero.
;
; ----
; : load  ( u -- )
;   dup 0= 9 ?throw  dup scr !
;   nest-source (load) unnest-source  ;
; ----
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.loading_from_screen_0
  dw dup_,scr_,store_
  dw nest_source_,paren_load_,unnest_source_
  dw exit_

; ----------------------------------------------
  _colon_header next_block_,'-->',immediate

; doc{
;
; -->  ( -- )  \ "next-screen"
;
; Continue interpretation with the next disk screen.
;
; Origin: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words).
;
; ----
; : -->  ( -- )
;   ?loading  blk @ 1+ block>source  ; immediate
; ----
;
; }doc

  ; XXX TODO -- In Gforth the definition is `refill drop`

  dw question_loading_
  dw blk_,fetch_,one_plus_
  dw block_to_source_
  dw exit_

; ----------------------------------------------
  _colon_header defined_,'DEFINED'

; doc{
;
; defined  ( "name" -- nt | 0 )
;
; Parse "name" and find its definition.  If the definition is
; not found after searching all the word lists in the search
; order, return _ca len_ and _false_.  If the definition is found,
; return its _xt_, its length byte _b_ and _true_.
;
; ----
; : defined  ( "name" -- nt | 0 )
;   parse-name find-name  ;
; ----
;
; }doc

  dw parse_name_,find_name_
  dw exit_

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINED'

; doc{
;
; ?defined  ( f -- )
;
; }doc

  ; Credit:
  ; Code from DZX-Forth.

  dw zero_equals_
  _question_throw error.not_found
  dw exit_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

; doc{
;
; [defined]  ( "name" -- wf )
;
; ----
; : [defined]  ( "name" -- wf )
;   defined 0<>  ; immediate
; ----
;
; }doc

  dw defined_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED]',immediate

  ; XXX TODO make this the main word, not `[defined]`, and move
  ; `[defined]` to the library

; doc{
;
; [undefined]  ( "name" -- wf )
;
; ----
; : [undefined]  ( "name" -- wf )
;   [defined] 0=  ; immediate
; ----
;
; }doc

  dw bracket_defined_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header tick_,"'"

; doc{
;
; '  ( "name" -- xt )
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : '  ( "name" -- xt )
;   defined dup ?defined name>  ;
; ----
;
; }doc

  dw defined_,dup_,question_defined_,from_name_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate+compile_only

; doc{
;
; [']  ( "name" -- xt )
;
; Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : [']  ( "name" -- xt )
;   ' postpone literal  ; immediate
; ----
;
; }doc

  dw tick_,literal_
  dw exit_

; ----------------------------------------------
  _alias_header begin_,'BEGIN',immediate+compile_only,backward_mark_

; doc{
;
; begin  ( compilation: -- a n )
;
; At compile time `begin` leaves the dictionary address on
; stack with an error checking number _n_.  It does not compile
; anything to the dictionary.
;
; }doc

; ----------------------------------------------
  _alias_header then_,'THEN',immediate+compile_only,forward_resolve_

; ----------------------------------------------
  _colon_header until_,'UNTIL',immediate+compile_only

  dw compile_,zero_branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header again_,'AGAIN',immediate+compile_only

; doc{
;
; again  ( compilation: a n -- )
;
; End of an infinite loop.  Compile an unconditional jump
; instruction to branch backward to _a_.
;
; }doc

  dw compile_,branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header repeat_,'REPEAT',immediate+compile_only

; doc{
;
; repeat
;
;   Compilation: ( orig dest -- )
;
; Compile `branch` to jump back to `begin`.  Resolve also  the
; branching offset required by `while`.
;
; }doc

  dw again_ ; unconditional branch back to `begin`
  dw then_ ; resolve the forward branching needed by `while`
  dw exit_

; ----------------------------------------------
  _colon_header if_,'IF',immediate+compile_only

; doc{
;
; if  ( Compilation: -- orig ) ( Run-time: x -- )
;
; }doc

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header ahead_,'AHEAD',immediate+compile_only

; doc{
;
; ahead
;   Compilation: ( -- )
;
; Origin: Forth-94, Forth-2012.
;
; }doc

  dw compile_,branch_,forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header else_,'ELSE',immediate+compile_only

  dw ahead_
  dw swap_ ; XXX TODO `cs-swap`
  dw then_
  dw exit_

; ----------------------------------------------
  _colon_header while_,'WHILE',immediate+compile_only

  dw if_
  dw swap_ ; XXX TODO `cs-swap`
  dw exit_

; ----------------------------------------------
  _colon_header spaces_,'SPACES'

; doc{
;
; spaces  ( n -- )
;
; If _n_ is greater than zero, display _n_ spaces.
;
; Origin: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw b_l_,swap_,emits_
  dw exit_

; ----------------------------------------------
  _colon_header emits_,'EMITS'

; doc{
;
; emits  ( c n -- )
;
; If _n_ is greater than zero, display _n_ characters _c_.
;
; }doc

  dw zero_,max_
  dw zero_

  dw paren_question_do_,emits.loop_exit ; do
  dw dup_,emit_
  dw paren_loop_ ; loop
emits.loop_exit:

emits.end:
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header less_hash_,'<#'

  ; XXX FIXME -- don't use `pad`

  dw pad_,hld_,store_
  dw exit_

; ----------------------------------------------
  _colon_header hash_greater_,'#>'

  dw two_drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw exit_

; ----------------------------------------------
  _colon_header sign_,'SIGN'

; doc{

; sign  ( n  --  )

; If _n_ is negative, add a minus sign to the beginning of the
; pictured numeric output string.
;
; Origin: Forth 94 (CORE), Forth-2012 (CORE).
;
; See: `<#`, `#>`.
;
; ----
; : sign  ( n -- )
;   0< if  [char] - hold  then  ;
; ----
;
; }doc

  dw zero_less_than_
  dw zero_branch_,sign.end
  _literal '-'
  dw hold_
sign.end:
  dw exit_

; ----------------------------------------------
  _code_header to_digit_,'>DIGIT'

; doc{
;
; >digit  ( n -- c )
;
; Convert a number to its character digit: 0..9A..Z.
;
; ----
; : >digit  ( n -- c )
;   dup 9 > [ 'A' '0' - 1+ ] literal and + '0' +  ;
; ----
;
; }doc

  ; Credit:
  ;
  ; Adapted from Z88 CamelForth.

  pop hl
  ld a,l
  cp 10
  jr c,to_digit.end
  add a,7
to_digit.end
  add a,$30
  ld l,a
  _jp_pushhl

; ----------------------------------------------
  _colon_header hash_,'#'

; doc{
;
; #  ( d1 -- d2 )
;
; Divide _d1_ by current base.  The remainder is converted to
; an ASCII character and appended to the output text string.
; The quotient _d2_ is left on stack.
;
; ----
; : #  ( d1 -- d2 )
;   base @ ud/mod rot >digit hold  ;
; ----
;
; }doc

  dw base_,fetch_
  dw u_d_slash_mod_,rot_,to_digit_,hold_
  dw exit_

; ----------------------------------------------
  _colon_header u_d_slash_mod_,'UD/MOD'

; doc{
;
; ud/mod ( ud1 u2 -- u3 ud4 )
;
; An unsigned mixed magnitude math operation which leaves a
; double quotient _ud4_ and remainder _u3_, from a double
; dividend _ud1_ and single divisor _u2_.

; ----
; : ud/mod  ( ud1 u1 -- urem udquot )
;   >r 0 r@ um/mod -rot r> um/mod rot  ;
; ----
;
; Origin: fig-Forth (`m/mod`), comus: Gforth, Z88 CameForth.
;
; }doc

  ; Credit:
  ; Code modified from Z88 CamelForth.

  dw to_r_
  _literal 0
  dw r_fetch_
  dw u_m_slash_mod_
  dw minus_rot_
  dw from_r_
  dw u_m_slash_mod_
  dw rot_
  dw exit_

; ----------------------------------------------
  _code_header minus_rot_,'-ROT'

; doc{
;
; -rot  ( x1 x2 x3 -- x3 x1 x2 )
;
; }doc

  ; Credit:
  ;
  ; Code adapted from Afera.

  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  jp push_hlde

; ----------------------------------------------
  _colon_header hash_s_,'#S'

; doc{
;
; #S  ( d1 -- d2 )
;
; }doc

hash_s.begin:
  dw hash_,two_dup_,or_
  dw question_branch_,hash_s.begin
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.R'

; doc{
;
; d.r  ( d n -- )
;
; Print a signed double number _d_ right justified in a field of
; _n_ characters.
;
; ----
; : d.r  ( d n -- )
;   >r tuck dabs <# #s rot sign #> over - spaces type  ;
; ----
;
; }doc

  dw to_r_ ; save _n_
  dw tuck_  ; save the high part of _d_ to calculate the sign
  dw d_abs_,less_hash_,hash_s_,rot_,sign_,hash_greater_
  dw from_r_,over_,minus_,spaces_ ; preceding blanks
  dw type_
  dw exit_

; ----------------------------------------------
  _colon_header dot_r_,'.R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header zero_dot_r_,'0.R'

; doc{
;
; 0.r  ( n -- )
;
; Print signed integer _n_ according to current base,
; without any trailing blank.
;
; }doc

  _literal 0
  dw dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header zero_d_dot_r_,'0D.R'

; doc{
;
; 0d.r  ( d -- )
;
; Print signed double integer _d_ according to current base,
; without any trailing blank.
;
; }doc

  _literal 0
  dw d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_,'D.'

; doc{
;
; d.  ( d -- )
;
; Print signed double integer _d_ according to current base,
; followed by only one blank.
;
; }doc

  dw zero_d_dot_r_,space_
  dw exit_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; .  ( n -- )
;
; Print signed integer _n_ according to current base, followed
; by only one blank.
;
; }doc

  dw s_to_d_,d_dot_
  dw exit_

; ----------------------------------------------
  _colon_header question_,'?'

  dw fetch_,dot_
  dw exit_

; ----------------------------------------------
  _colon_header u_dot_,'U.'

  dw zero_,d_dot_
  dw exit_

; ----------------------------------------------

if 1 ; developing

  _colon_header dot_s_,'.S'

  ; XXX TMP -- only during the development, then remove
  ; It is in the library.

  dw depth_,dup_
  _literal '<'
  dw emit_
  _literal 0
  dw dot_r_
  _literal '>'
  dw emit_

  dw space_
  _literal 1
  dw less_than_
  dw question_branch_,dot_s.end

  dw sp_fetch_,sp0_,fetch_,cell_minus_
  dw paren_do_,dot_s.loop_exit ; do
  dw i_,fetch_,dot_ ; XXX TMP `u.`
  _literal -cell
  dw paren_plus_loop_ ; loop
dot_s.loop_exit:

dot_s.end:
  dw exit_

endif

; ----------------------------------------------
  _code_header default_colors_,'DEFAULT-COLORS'

; doc{
;
; colors0  ( -- )
;
; Set the screen colors to the default values.
;
; }doc

  ; XXX TODO deactivate inverse mode.

  ; Set the colors and their masks.

  ld hl,(default_color_attribute)
  ; l = 128*flash + 64*bright + 8*paper + ink
  ; h = mask
  ld (sys_attr_p),hl ; permanent
  ld (sys_attr_t),hl ; temporary

  ; Set the system variable that holds the attributes of the
  ; lower part of the screen.  It is needed only because G+DOS
  ; by default changes the border color during disk operations,
  ; and at the end restores it with the value of this system
  ; variable.

  ld a,l
  ld (sys_bordcr),a ; lower screen colors

  ; Set the border color to the paper color.

  ; a = 128*flash + 64*bright + 8*paper + ink
  and a ; cy=0
  rra
  rra
  rra ; a = paper
  out($FE),a ; set the border color

  _jp_next

; ----------------------------------------------
  _code_header mode32_home_,'MODE32-HOME'

; doc{
;
; (mode32-home)  ( -- )
;
; Behaviour of `home` in `mode32`.
;
; }doc

if 0

  ; XXX OLD -- This method works only with the default ROM
  ; printing routines.

  ld hl,$1821 ; $18 = 24 - row
               ; $21 = 33 - column
  ld (sys_s_posn),hl
  _jp_next

endif

if 1

  ; XXX NEW -- This method works with any printing routine
  ; associated to a chanel.

  ld a,at_char
  rst $10
  xor a
  rst $10
  xor a
  rst $10
  _jp_next

endif

if 0

  ; XXX TODO -- adapt this from DZX-Forth?
  ; slower?

  ld hl,$0000
  push hl
  push hl
  jp at_xy_

endif

; ----------------------------------------------
  _defer_header home_,'HOME',,mode32_home_

; doc{
;
; home  ( -- )
;
; Set the cursor position at the top left position (column 0,
; row 0).
;
; }doc

; ----------------------------------------------
  _code_header cls_,'CLS'

; doc{
;
; cls  ( -- )
;
; Clear the screen with the current colors and reset the cursor
; position to the upper left corner (column 0, row 0).
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

; Credit:
; The attributes part was improved after code by Dean Belfield
; <http://wordpress.animatez.co.uk/programming/assembly-language/z80/z80-library-routines/204-2/>.
; The idea for `ld (hl),l` was found in David Webb's _Advanced
; Spectrum Machine Language_.

  exx ; save the Forth IP
  ; Erase the bitmap.
  ld hl,sys_screen
  ld de,sys_screen+1
  ld bc,sys_screen_bitmap_size
  ld (hl),l ; l=0 because sys_screen=$4000
  ldir
  ; Color with the permanent attributes.
  ld bc,sys_screen_attributes_size-1
  ld a,(sys_attr_p)
  ld (hl),a
  ldir
  ld (sys_coords),bc ; reset the graphic coordinates
  exx ; restore the Forth IP

  jp home_ ; continue at `home`

  ; The Z80 version above uses 29 bytes;
  ; the following Forth version uses 30 bytes:

  ; _colon_header cls_,'CLS'
  ; dw lit_,sys_screen,lit_,sys_screen_bitmap_size,erase
  ; dw lit_,sys_screen_attributes,lit_,sys_screen_attributes_size
  ; dw lit_,sys_attr_p,c_fetch_,fill_
  ; dw home_
  ; dw exit_

; ----------------------------------------------
  _colon_header page_,'PAGE'

; doc{
;
; page  ( -- )
;
; Move to another page for output.  On a terminal, `page` clears
; the screen and resets the cursor position to the upper left
; corner. On a printer, `page` performs a form feed.
;
; Origin: Forth-94.
;
; }doc

  dw printing_,fetch_
  dw zero_branch_,page.display
  _literal form_feed_char
  dw emit_
  dw exit_

page.display
  dw cls_
  dw exit_

; ----------------------------------------------
  _code_header paren_bye_,'(BYE)'

  ld (iy+sys_df_sz_offset),$02 ; restore lines of the lower screen

  im 1 ; interrupt mode 1, normal situation of the OS

system_stack_pointer: equ $+1
  ld sp,0 ; restore the system stack

; The Complete Spectrum ROM Disassembly
; (http://www.worldofspectrum.org/infoseekid.cgi?id=2000076),
; page 201, states:
;
; For a successful return to BASIC, H'L' must on exit from the
; machine code contain the address in SCANNING of the 'end-calc'
; instruction, 2758 hex (10072 decimal).

  ld hl,$2758
  exx

  ; Exit to BASIC:
  rst $08
  db $08 ; "STOP" BASIC error

; ----------------------------------------------
  _defer_header default_mode_,'DEFAULT-MODE',,noop_

; doc{
;
; default-mode  ( -- )
;
; A deferred word that activates the default screen mode. It's
; set to `noop` until the first mode change is done. Then it's
; vectored to `mode32`.  It's used by `bye`.
;
; }doc

; ----------------------------------------------
  _colon_header bye_,'BYE'

  dw save_mode_
  dw default_mode_
  dw paren_bye_
  ; No return from `(bye)`.

; ----------------------------------------------
  _code_header two_drop_,'2DROP'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWAP'

; doc{
;
; 2swap  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
;
; }doc

  ; Credit:
  ; Code adapted from Z88 CamelForth

                      ; T   B
                      ; --- --
  exx                 ;  04 01
  pop hl  ; hl'=x4    ;  10 01
  pop de  ; de'=x3    ;  10 01
  exx                 ;  04 01
  pop hl  ; hl=x2     ;  10 01
  pop de  ; de=x1     ;  10 01
  exx                 ;  04 01
  push de ; x3        ;  11 01
  push hl ; x4        ;  11 01
  exx                 ;  04 01
  jp push_hlde        ;  10 03
                      ;  11 00 push de
                      ;  11 00 push hl
                      ; --- --
                      ; 110 13 TOTAL

; ----------------------------------------------
  _variable_header limit_,'LIMIT'

; doc{
;
; limit  ( -- a )
;
; Variable that holds the address above the highest address
; usable by the region addressed by `here`.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header unused_,'UNUSED'

; doc{
;
; unused ( -- u )
;
; Return the amount of space remaining in the region addressed
; by `here`, in address units.
;
; Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw limit_,fetch_,here_,minus_
  dw exit_

; ----------------------------------------------
if 1 ; developing

  _colon_header where_,'WHERE'

  ; XXX TMP -- needed only during the development
  ; XXX TODO -- remove; already copied to the disk

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw exit_

where.do_it:
  dw dup_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_,dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  _literal '^'
  dw emit_
  dw exit_

endif

; ----------------------------------------------
  _colon_header mode32_at_xy_,'MODE32-AT-XY'

; doc{

; (mode32-at-xy) ( col row -- )
;
; Default behaviour of `at-xy`, in mode 32.
;
; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

  ; Credit:
  ; Code adapted from Spectrum Forth-83.

  dw dup_
  _literal 23
  dw not_equals_ ; not the last row?
  dw zero_branch_,at_pfa.last_line
  ; not the last row
  dw lit_,22,mode32_emit_,mode32_emit_,mode32_emit_
  dw exit_ ; XXX TODO exit_

at_pfa.last_line:
  dw one_minus_,dup_,mode32_emit_,mode32_emit_,zero_,mode32_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  _literal 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw exit_

; ----------------------------------------------
  _defer_header at_xy_,'AT-XY',,mode32_at_xy_

; doc{
;
; at-xy ( col row -- )
;
; Origin: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

; ----------------------------------------------
  _colon_header mode32_xy_,'MODE32-XY'

; doc{
;
; (mode32-xy)  ( -- col row )

; Return the current column and row, in mode 32.
;
; ----
; : (mode32-xy)  ( -- col row )
;   24 23689 c@ -
;   33 23688 c@ - dup 32 = if  drop 1+ 0  then  swap  ;
; ----
;
; }doc

  ; Credit:
  ; Code from the Spectrum Forth-83 manual.

  _literal 24
  _literal sys_s_posy
  dw c_fetch_,minus_
  _literal 33
  _literal sys_s_posx
  dw c_fetch_,minus_
  dw dup_
  _literal 32 ; XXX TODO -- chars per line in the current mode
  dw equals_
  dw zero_branch_,mode32_xy.end
  dw drop_,one_plus_
  _literal 0
mode32_xy.end:
  dw swap_
  dw exit_

; ----------------------------------------------
  _defer_header xy_,'XY',,mode32_xy_

; doc{
;
; xy ( -- col row )
;
; Return the current column and row of the text cursor.
;
; }doc

; ----------------------------------------------
  _code_header border_,'BORDER'

; doc{
;
; border  ( +n -- )
;
; Set the border of the screen to color to _+n_ (0..7).
;
; }doc

  pop hl
  ld a,l
  out (border_port),a

  ; The system variable that holds the attributes of the lower
  ; part of the screen, unnecessary in Solo Forth, must be
  ; updated.  The reason is G+DOS, after disk operations that
  ; make the border change, restores the border color with the
  ; value of this system variable.  We use the border color as
  ; paper and set a a contrast ink (black or white), to make
  ; sure the lower part of the screen is usable after returning
  ; to BASIC.

if 0 ; XXX OLD

  ; XXX TODO move this (contrast ink calculation) to `bye` or
  ; simply remove it:

  cp 4 ; cy = dark color (0..3)?
  ld a,7 ; white ink
  jr c,border.end
  xor a ; black ink
border.end:
  ; Note: slower than shifting the register, but saves three bytes.
  add hl,hl
  add hl,hl
  add hl,hl ; l = paper (bits 3..5)
  or l ; combine with ink
  ld (sys_bordcr),a

endif

  _jp_next

; ----------------------------------------------
  _code_header overprint_,'OVERPRINT'

  ld a,over_char
  jr color

; ----------------------------------------------
  _code_header flash_,'FLASH'

  ld a,flash_char
  jr color

; ----------------------------------------------
  _code_header inverse_,'INVERSE'

  ld a,inverse_char
  jr color

; ----------------------------------------------
  _code_header bright_,'BRIGHT'

  ld a,bright_char
  jr color

; ----------------------------------------------
  _code_header paper_,'PAPER'

  ld a,paper_char
  jr color

; ----------------------------------------------
  _code_header ink_,'INK'

  ; XXX FIXME -- crash when out of range

  ld a,ink_char

color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or
  ; overprint).
  ; Input:
  ;   a = attribute control char
  ;   (tos) = color attribute value
  rst $10
  pop hl
  ld a,l
  rst $10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTANT'

  dw create_,two_comma_
  dw paren_semicolon_code_
do_two_constant:
  pop hl
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header two_variable_,'2VARIABLE'

; doc{
;
; 2variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve two consecutive
; cells of data space.
;
;    _name_ is referred to as a two-variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the first (lowes address) cell of two
;    consecutive cells. A program is responsible for
;    initializing the contents.
;
; Origin: Forth-94.
;
; }doc

  dw create_
  dw branch_,two_comma.allot

; ----------------------------------------------
  _colon_header u_dot_r_,'U.R'

  dw to_r_,zero_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _code_header two_over_,'2OVER'

; doc{
;
; 2over  ( d1 d2 -- d1 d2 d1 )
;
; }doc

  ld hl,4
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _alias_header unnest_,'UNNEST',,r_drop_

  ; XXX NEW -- experimental

  ; Credit:
  ; http://dxforth.netbay.com.au/unnest.html

; ----------------------------------------------
  _code_header exit_,'EXIT'

; doc{
;
; exit  ( -- ) ( R: nest-sys -- )

; Return control to the calling definition, specified by
; _nest-sys_.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; In Solo Forth `exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; Origin: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header question_exit_,'?EXIT'

; doc{
;
; ?exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by _nest-sys_.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; In Solo Forth `?exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,exit_
  _jp_next

; ----------------------------------------------
  _colon_header catch_,'CATCH'

  ; XXX TODO -- move to the library?

; doc{

; catch  ( xt -- 0 | err# )

; Push an exception frame on the exception stack and then
; execute _xt_ (as with `execute`) in such a way that control
; can be transferred to a point just after `catch` if `throw` is
; executed during the execution of _xt_.
;
; If the execution of _xt_ completes normally (i.e., the
; exception frame pushed by this `catch` is not popped by an
; execution of `throw`) pop the exception frame and return zero
; on top of the data stack, above whatever stack items would
; have been returned by the execution of _xt_. Otherwise, the
; remainder of the execution semantics are given by `throw`.
;
; Origin: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).

;----
; : catch  ( xt -- exception# | 0 )
;   sp@ >r          ( xt )  \ save data stack pointer
;   catcher @ >r    ( xt )  \ save previous catcher
;   rp@ catcher !   ( xt )  \ set current catcher
;   execute         ( )     \ `execute` returns if no `throw`
;   r> catcher !    ( )     \ restore previous catcher
;   r> drop         ( )     \ discard saved stack pointer
;   0  ;            ( 0 )   \ normal completion, no error
;----
; }doc

  ; Credit: Code from DZX-Forth, MPE Forth for TiniARM and
  ; Forth-2012 documentation.

  dw sp_fetch_,to_r_ ; save data stack pointer
  dw catcher_,fetch_,to_r_ ; save previous catcher
  dw rp_fetch_,catcher_,store_ ; set current catcher
  dw execute_ ; `execute` returns if no `throw`
  dw from_r_,catcher_,store_  ; restore error frame
  dw from_r_,drop_ ; discard saved stack pointer
  _literal 0  ; normal completion, no error
  dw exit_

; ----------------------------------------------
  _colon_header throw_,'THROW'

  ; Credit:
  ; Code from DZX-Forth.
  ; Comments from MPE Forth for TiniARM.

; doc{
;
; throw  ( n -- )
;
; Origin: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).
;
; ----
; : throw  ( n -- )
;   ?dup if
;     catcher @ ?dup 0=   \ no catcher?
;     if  error  then     \ `error` does not return
;     rp!                 \ restore previous return stack
;     r> catcher !        ( n )  \ restore previous catcher
;     r> swap >r          ( saved-sp ) ( R: n )
;     sp! drop r>         ( n )  \ restore stack
;     \ Return to the caller of `catch` because return stack is
;     \ restored to the state that existed when `catch` began
;     \ execution.
;   then  ;
; ----
;
; }doc

  dw question_dup_
  dw zero_branch_,throw.end
  dw catcher_,fetch_,question_dup_  ; catcher?
  dw question_branch_,throw.catcher ; if so, branch
  dw error_ ; no return from `error`.

throw.catcher:
  dw rp_store_                ; restore previous return stack
  dw from_r_,catcher_,store_  ; ( n )  restore previous catcher
  dw from_r_,swap_,to_r_      ; ( saved-sp ) ( R: n )
  dw sp_store_,drop_,from_r_  ; ( n )  restore stack

  ; Return to the caller of `catch` because return stack is
  ; restored to the state that existed when `catch` began
  ; execution.

throw.end:
  dw exit_

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT)'

  dw sp0_,fetch_,sp_store_
  dw boot_  ; XXX TODO -- not here?
  dw quit_
  ; No return from `quit`, no need for `exit`.

; ----------------------------------------------
  _colon_header abort_,'ABORT'

  _literal -1
  dw throw_
  ; No return from `-1 throw`, no need for `exit`.

; ----------------------------------------------
  _colon_header char_,'CHAR'

  dw parse_name_,drop_,c_fetch_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_char_,'[CHAR]',immediate+compile_only

  dw char_,literal_
  dw exit_

; ----------------------------------------------
  _colon_header s_quote_,'S"',immediate

  ; : s"  ( compilation: "ccc<">" -- ) ( run-time:  -- ca len )
  ;  [char] " parse-string  ; immediate

  _literal '"'
  dw parse_string_
  dw exit_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

; doc{
;
; ?\  ( f "ccc<eol>" -- )
;
; If _f_ is not false, parse and discard the rest of the parse
; area.  This word is used for conditional compilation.
;
; }doc

  ; XXX TODO move to the library?

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw exit_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

; doc{
;
; \  ( "ccc<eol>" -- )
;
; Parse and discard the rest of the parse area.
;
; Origin: Forth-94 (BLOCK EXT), Forth-2012 (BLOCK EXT).
;
; }doc

  dw loading_question_ ; input stream from disk?
  dw question_branch_,backslash.loading
  ; Interpreting
  dw span_,fetch_ ; XXX TODO -- use `#tib` instead?
;  _chk '\ tib -- before updating >in' ; XXX INFORMER
  dw to_in_,store_
  dw exit_

backslash.loading:
  ; Loading
  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
;  _chk '\ disk -- before updating >in' ; XXX INFORMER
  dw parsed_
  dw exit_

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .(  ( 'text<paren>' -- )  \ immediate
;
; }doc

  _literal ')'
  dw parse_,type_
  dw exit_

latest_nt_in_forth_voc: equ dot_paren_nt

dictionary_pointer_after_cold:

; ==============================================================
; Name and link fields

move_name_fields_to_memory_bank:

  ; Move the name fields, assembled in ordinary memory, to the
  ; system bank. This routine is needed only once, therefore its
  ; call is patched with `noop` at the end; the routine itself
  ; will be overwritten by the Forth dictionary.

  ; The whole screen is used as intermediate buffer for copying
  ; the data.

  ld hl,names_bank_address ; origin
  ld de,sys_screen ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the data to the screen
  call bank.system
  ld hl,sys_screen ; origin
  ld de,names_bank_address ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the name fields to the bank
  call bank.default

  ; Remove the call to this routine:
  ld hl,only_first_cold ; address of the call to this routine
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  ret

  org names_bank_address

  db 0 ; fake length byte, needed by the algorithm used in `>name`

; ==============================================================
; End

end cold_entry

; ==============================================================
; Debug tools

; dw lit_,2,border_,key_,drop_,lit_,7,border_ ; XXX INFORMER
; dw lit_,0,border_,key_,drop_ ; XXX INFORMER
; dw lit_,1,border_,key_,drop_ ; XXX INFORMER
; dw lit_,2,border_,key_,drop_ ; XXX INFORMER
; dw lit_,4,border_,key_,drop_ ; XXX INFORMER
; dw lit_,5,border_,key_,drop_ ; XXX INFORMER
; dw lit_,6,border_,key_,drop_ ; XXX INFORMER
; dw lit_,7,border_,key_,drop_ ; XXX INFORMER

; dw two_dup_,two_,ink_,type_,zero_,ink_ ; XXX INFORMER

; ==============================================================
; Development notes
;
; 2015-06-25:
;
; Number  Times compiled (not including error numbers)
; 0       20
; 1       11
; 2       11
; 3       6

; vim: filetype=z80:textwidth=64
