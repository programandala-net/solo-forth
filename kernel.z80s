; Solo Forth

; A Forth system for:
;
;   ZX Spectrum 128K with G+DOS
;   ZX Spectrum +3
;
; http://programandala.net/en.program.solo_forth.html

; XXX UNDER DEVELOPMENT

; ==============================================================
; Version

  ; Version numbers are a ISO date format "YYYYMMDD[HH[MM]]".

  ; Version:        20151216
version_high_part:  equ 0x0133
version_low_part:   equ 0x7BB0

  ; Last modified:  201512170217
  ;
  ; XXX FIXME: Forth-83 loops worked fine when the had diffent
  ; names, but when I substituted the fig-Forth loops, the
  ; system crashes. The compiled loops in the definitions have
  ; been adapted.

; ==============================================================
; Author and license

; Copyright (C) 2015 Marcos Cruz (programandala.net)

; You may do whatever you want with this work, so long as you
; retain all copyright notices, all credit notices, and this
; license in all files of all redistributed copies and derived
; works. There is no warranty.

; ==============================================================
; Acknowledgments

; See the file <ACKNOWLEDGMENTS.adoc>.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; ==============================================================
; System description

; ----------------------------------------------
; Forth Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before exit.
;       DE   Input only when pushhlde called. ; XXX TODO
;       HL   Input only when pushhl called. ; XXX TODO
;       IX   Address of `next`.
;            May be used within Forth words if restored before exit.
;       IY   Address of the ERRNR ZX Spectrum system variable.
;            May be used within Forth words if restored before exit.

; ----------------------------------------------
; Header structure

; The name and link fields are created in a memory bank:

; cfap: dw cfa             ; Pointer to cfa in main memory.
; lfa:  dw nfa of the previous word
; nfa:  db length+flags    ; Bits:      76543210
                           ; Bit names: CPSLLLLL
                           ; Legend:
                           ;   C: Compile-ony bit.
                           ;      0 = non-restricted word
                           ;      1 = compile-only word
                           ;   P: Immediate bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;       ds length          ; name

; The code and parameter fields are created in the dictionary:

; cfa: dw code_address
; pfa:    ...              ; data or code

; ==============================================================
; Glossary

; The description of Forth words is included in this source.
; The markers `doc{` and `}doc` delimitate the comments that
; form the glossary.

; ----------------------------------------------
; Stack notation

; Symbol  Data type                                       Size
; ------  ----------------------------------------------- ------

; a        = address                                      1 cell
; ca       = character-aligned address                    1 cell

; f        = flag (false is 0; true is any other value)   1 cell
; true     = true flag (-1)                               1 cell
; false    = false flag (0)                               1 cell
; wf       = well-formed flag (false is 0; true is -1)    1 cell

; b        = 8-bit byte                                   1 cell
; c        = 8-bit character                              1 cell

; u        = 16-bit unsigned number                       1 cell
; len      = 16-bit unsigned number,                      1 cell
;            length of memory zone or string              1 cell
; n        = 16-bit signed number                         1 cell
; +n       = 16-bit non-negative number                   1 cell
; n|u      = 16-bit signed or unsigned number             1 cell
; x        = 16-bit unspecified number                    1 cell

; ca len   = string                                       2 cells

; d        = 32-bit signed double number                  2 cells
; d|ud     = 32-bit signed or unsigned double number      2 cells
; +d       = 32-bit non-negative double number            2 cells
; ud       = 32-bit unsigned double number                2 cells
; xd       = 32-bit unspecified number                    2 cells

; xc       = 8-bit graphic x coordinate (0..255)          1 cell
; yc       = 8-bit graphic y coordinate (0..191)          1 cell
; row      = 8-bit cursor row (0..n)                      1 cell
;            (maximum value depends on the screen mode)
; col      = 8-bit cursor column (0..n)                   1 cell
;            (maximum value depends on the screen mode)

; cfa      = code field address                           1 cell
; lfa      = link field address                           1 cell
; nfa      = name field address                           1 cell
; pfa      = parameter field address                      1 cell
; cfap     = code field address pointer                   1 cell

; wid      = wordlist identifier                          1 cell
;            (in Solo forth, the pfa of a vocabulary)

; orig     = address of an unresolved forward branch      1 cell
; dest     = address of a backward branch target          1 cell

; cs-id    = control structure identifier                 1 cell
; loop-sys = loop control parameters                      2 cells
; nest-sys = definition call                              1 cell
; source-sys = source identifier                          several cells
; XXX TODO -- fix typo "definition cells" in Forth-2012 document (Table 3.1)

; op       = Z80 8-bit opcode, generally a jump           1 cell
; r        = Z80 8-bit register identifier                1 cell
; rp       = Z80 16-bit register pair identifier          1 cell

; ----------------------------------------------
; Parsed text notation

; XXX TODO

; <char>          the delimiting character marking the end of the
;                 string being parsed
; <chars>         zero or more consecutive occurrences of the
;                 character char
; <space>         a delimiting space character
; <spaces>        zero or more consecutive occurrences of the
;                 character space
; <quote>         a delimiting double quote
; <paren>         a delimiting right parenthesis
; <eol>           an implied delimiter marking the end of a line
; ccc             a parsed sequence of arbitrary characters,
;                 excluding the delimiter character
; text            same as ccc
; name            a token delimited by space, equivalent to
;                 ccc<space> or ccc<eol> ; XXX TODO

; ----------------------------------------------
; Word attributes

; XXX OLD -- not used

; The capital letters on the right show definition characteristics:

; C      May only be used within a colon definition. A digit indicates number
;        of memory addresses used, if other than one. A plus sign indicates
;        a variable number of memory addresses used.
; E      Intended for execution only.
; I      Immediate. Has immediate bit set. Will execute even when compiling.
; U      A user variable.

; ==============================================================
; Configuration

  ; XXX FIXME Pasmo gives strange errors (symbols not found)
  ; when some config flags are used in nested `if`. A literal
  ; flag (0/1) is used instead, with the flag name in a comment;
  ; it is changed with a text substitution.  Some Vim mappings
  ; are created to turn them on and off.

  ; Solo Forth can be compiled for G+DOS or +3DOS.
  ; This depends on two labels, `gplusdos` and `plus3dos`,
  ; defined with a parameter of the Pasmo assembler. See the
  ; Makefile files for details.

if (!defined gplusdos) and (!defined plus3dos)
  gplusdos equ true ; G+DOS by default
endif

  ; XXX experimental
size_optimization: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

  ; XXX the flag is harcoded in the code
  ; XXX OLD
;assembler_core_in_kernel: equ true

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

origin:                           equ 0x5E00

false:                            equ 0x0000
true:                             equ 0xFFFF ; -1

cell:                             equ 0x02

cells_per_data_stack:             equ 0x50
cells_per_return_stack:           equ 0x50

bytes_per_terminal_input_buffer:  equ 0x50

bytes_per_sector:                 equ 0x0200 ; 512-byte sectors in G+DOS and +3DOS
sectors_per_block:                equ 0x02

bytes_per_buffer:                 equ 0x0400

if defined gplusdos
  blocks_per_disk:                  equ 800 ; KiB per disk in G+DOS
endif
if defined plus3dos
  blocks_per_disk:                  equ 720 ; KiB per disk in +3DOS
endif

characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10
max_search_order:                 equ 0x08 ; maximum number of vocabularies in the search order
bytes_per_user_variables:         equ 0x40

word_length_mask:                 equ %00011111
smudge_mask:                      equ %00100000
immediate_mask:                   equ %01000000
compile_only_mask:                equ %10000000

max_word_length:                  equ word_length_mask
valid_word_length_mask:           equ word_length_mask or smudge_mask

csb_size:                         equ 256 ; bytes, size of the circular string buffer

; Memory banks (0xC000..0xFFFF)

default_bank:                     equ 0
names_bank:                       equ 1

names_bank_address:               equ 0xC000 ; names pointers

; Charset

charset_size:                     equ 224*8 ; 224 chars (0x20..0xFF) * 8 bitmap rows
charset_address:                  equ 0xFFFF-charset_size+1

; Control structure check numbers

; XXX TODO
;begin_structure_check_number:    equ 1
;if_structure_check_number:       equ 2
;do_structure_check_number:       equ 3
;case_structure_check_number:     equ 4
;of_structure_check_number:       equ 5
;for_structure_check_number:      equ 6

; Error codes used in the kernel

error.stack_overflow:               equ -003
error.stack_underflow:              equ -004
error.dictionary_overflow:          equ -008
error.not_found:                    equ -013
error.compilation_only:             equ -014
error.zero_length_name:             equ -016
error.conditionals_not_paired:      equ -022
error.not_understood:               equ -256
error.not_unique:                   equ -257
error.stack_unbalanced:             equ -258
error.loading_from_screen_0:        equ -259
error.wrong_digit:                  equ -260
error.deferred_word_uninitialized:  equ -261
error.assertion_failed:             equ -262
error.execution_only:               equ -263
error.definition_not_finished:      equ -264
error.loading_only:                 equ -265
error.off_current_editing_screen:   equ -266

; ----------------------------------------------
; ZX Spectrum

include inc/zx_spectrum_char_codes.z80s
include inc/zx_spectrum_rom_routines.z80s
include inc/zx_spectrum_system_variables.z80s
include inc/zx_spectrum_system_variables_offsets.z80s

sys_screen:                 equ 0x4000 ; address
sys_screen_size:            equ 0x1B00
sys_screen_bitmap_size:     equ 0x1800
sys_screen_attributes:      equ 0x5800 ; address
sys_screen_attributes_size: equ 0x0300

bank1_port:   equ 0x7FFD
border_port:  equ 0xFE

; ==============================================================
; Macros

; ----------------------------------------------
; Header macros

immediate:    equ immediate_mask
compile_only: equ compile_only_mask

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa \ XXX OLD

_header: macro _base_label,_name,_flags

  ; In dictionary:

  _base_label: ; code field address
  local _dp_backup
  local _name_address
  local _address_after_name
  _dp_backup: equ $

  ; In memory bank:

  org np
  _base_label##cfap:
    dw _base_label ; code field address pointer
  _base_label##lfa: ; link field address
    dw nfa_of_the_previous_word ; link field
  _base_label##nfa: ; name field address

  ; Length byte with optional immediate bit:

  if nul _flags
    db _address_after_name-_name_address
  else
    db _address_after_name-_name_address+_flags
  endif

  _name_address: equ $
    db _name ; name field
  _address_after_name: equ $

  np: defl $ ; new value of the names pointer

  ; Update the names pointer:
  org names_pointer
  dw np ; overwrite names_pointer
  dw np ; overwrite names_pointer_init_value

  ; In dictionary:
  org _dp_backup

  nfa_of_the_previous_word: defl _base_label##nfa

  endm

_code_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw _base_label##pfa ; code field
  _base_label##pfa: ; parameter field address

  endm

_defer_header: macro _base_label,_name,_flags,_cfa

  _code_header _base_label,_name,_flags
  ld hl,_cfa
  jp next2

  endm

_code_alias_header: macro _base_label,_name,_flags,_cfa

  _header _base_label,_name,_flags
  dw _cfa##pfa ; code field

; XXX TODO
; _raw_code_alias_header: macro _base_label,_name,_flags,_alias

;   ; Special macro used to create alias of code words that don't
;   ; have a parameter field, e.g. `noop`.

;   _header _base_label,_name,_flags
;   dw _alias ; code field

;_base_label##pfa: equ _alias##pfa ; XXX TODO

  endm

_colon_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name,_flags,_runtime_routine

  _header _base_label,_name,_flags

  dw _runtime_routine ; code field
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_two_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_c_constant_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_c_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name,_flags

  _header _base_label,_name,_flags
  dw do_create ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name,_flags

  _variable_header _base_label,_name,_flags

  endm

; ----------------------------------------------
; Literals macros

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_literal: macro _n

  ; Note: parenthesis are needed to prevent a strange problem of
  ; Pasmo with signs.

  if (_n)=0
    dw zero_
  else
    if (_n)=1
      dw one_
    else
      if (_n)=2
        dw two_
      else
        if (_n)>=0 && (_n)<=255
          dw c_lit_
          db _n
        else
          dw lit_
          dw _n
        endif
      endif
    endif
  endif
  endm

; ----------------------------------------------
; Jumps macros

_jp_next: macro

  jp (ix)

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Code macros

_compare_de_hl_unsigned: macro

  ; XXX TODO -- confirm that everything is fine, and use the
  ; code directly

  if 0

    ; XXX TODO -- can not work, because the ouput flags are
    ; different

    or a
    sbc hl,de

  else

    call compare_de_hl_unsigned

  endif
  endm

; ----------------------------------------------
; Error messages macros

_question_throw: macro _error
  _literal (_error)
  dw question_throw_
  endm

_message: macro _error
  _literal (_error)
  dw dot_throw_
  endm

; ----------------------------------------------
; Debug macros

debugging: equ 1

_z80_just_border: macro _color
  if debugging
    push af
    ld a,_color
    out(0xFE),a
    pop af
  endif
  endm

_z80_border: macro _color
  if debugging
    local _pause0
    push af
    push bc
    ld a,_color
    out(0xFE),a
    ld bc,0
    _pause0:
    dec bc
    ld a,b
    or c
    jr nz,_pause0
    pop bc
    pop af
  endif
  endm

_z80_border_wait: macro _color
  if debugging
    local _wait
    push af
    ld a,_color
    out(0xFE),a
    xor a
    ld (sys_last_k),a
    _wait:
    ld a,(sys_last_k)
    and a
    jr z,_wait
    pop af
  endif
  endm

_echo: macro _txt
  if debugging
    dw cr_,paren_dot_quote_
    _string _txt
  endif
  endm

  ; type the string on top of stack
_type: macro
  if debugging
    _echo 'TOS str= <'
    dw two_dup_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; type the counted string on top of stack
_ctype: macro
  if debugging
    _echo 'TOS cstr= <'
    dw dup_,count_,type_
    _literal '>'
    dw emit_
  endif
  endm

  ; check point
_chk: macro _message
  if debugging
    _echo _message
    dw base_,fetch_,to_r_,hex_
    dw cr_,dot_s_
    dw from_r_,base_,store_
  endif
  endm

_prompt: macro _message
  if debugging
    _echo _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
_brk: macro _message
  if debugging
    _chk _message
    _echo "Press any key to continue"
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the string on top of stack
_brk_type: macro _message
  if debugging
    _chk _message
    _type
    dw key_,drop_
  endif
  endm

  ; break point
  ; first type the counted string on top of stack
_brk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
    dw key_,drop_
  endif
  endm

  ; check point
  ; first type the string on top of stack
_chk_type: macro _message
  if debugging
    _chk _message
    _type
  endif
  endm

  ; check point
  ; first type the counted string on top of stack
_chk_ctype: macro _message
  if debugging
    _chk _message
    _ctype
  endif
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location (of the destination address): `0x01 +origin`
  jp cold_start
warm_entry:
  ; Location (of the destination address): `0x04 +origin`
  jp warm_start

; ==============================================================
; Parameter area

  ; XXX TODO document the `+origin` index

latest_nfa_in_root_voc.init_value:
  dw latest_nfa_in_root_voc

latest_nfa_in_forth_voc.init_value:
  dw latest_nfa_in_forth_voc

if 1 ; assembler_core_in_kernel

latest_nfa_in_assembler_voc.init_value:
  dw latest_nfa_in_assembler_voc

endif

voc_link.init_value:
if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
endif

user_variables_pointer:
  dw user_variables

return_stack_pointer:
  dw return_stack_bottom

default_color_attribute:
  dw 4 ; low byte: green paper, black ink; high byte: no mask

  ; User variables default values

  ; The first 8 user variables have default values.  They are
  ; used by `cold` to overwrite the actual user variables and
  ; must be in the same order than them.

default_user_variables_start:

sp0_init_value:                               ; +0x00
  dw data_stack_bottom
rp0_init_value:                               ; +0x02
  dw return_stack_bottom
paren_wait_init_value:                        ; +0x04
  dw noop_
width_init_value:                             ; +0x06
  dw max_word_length
warnings_init_value:                          ; +0x08
  dw true
; XXX TODO free                                    ; +0x0A
  dw +0x0000
dictionary_pointer_init_value:                ; +0x0C
  dw dictionary_pointer_after_cold
user_data_pointer_init_value:                 ; +0x0E
  dw user_data_pointer

default_user_variables_end:


ip_backup: ; temporary copy of Forth IP
  dw 0

np: defl names_bank_address+1

names_pointer:
  ; First free address in the names bank,  restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

names_pointer_init_value:
  ; Init value of the names pointer, used by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np


; ==============================================================
; User variables

user_variables:

  ; Note: the first 8 user variables are initialized with
  ; default values by `cold`.  They must be in the same order
  ; than their default values.

sp0_value:                                    ; +0x00
  dw data_stack_bottom
rp0_value:                                    ; +0x02
  dw return_stack_bottom
paren_wait:                                   ; +0x04
  dw 0x0000
width_value:                                  ; +0x06
  dw max_word_length
warnings_value:                               ; +0x08
  dw 0x0000
; XXX TODO free                                    ; +0x0A
  dw 0x0000
dictionary_pointer_value:                     ; +0x0C
  dw dictionary_pointer_after_cold
user_data_pointer_value:                      ; +0x0E
  dw user_data_pointer
blk_value:                                    ; +0x10
  dw 0x0000
in_value:                                     ; +0x12
  dw 0x0000
hash_emit_value:                              ; +0x14
  dw 0x0000
scr_value:                                    ; +0x16
  dw 0x0000
r_hash_value:                                 ; +0x18
  dw 0x0000 ; XXX OLD -- used by the editor, remove?
hld_value:                                    ; +0x1A
  dw 0x0000
current_value:                                ; +0x1C
  dw 0x0000
state_value:                                  ; +0x1E
  dw 0x0000
base_value:                                   ; +0x20
  dw 0x000A
dpl_value:                                    ; +0x22
  dw 0x0000
csp_value:                                    ; +0x24
  dw 0x0000

context_value:                                ; +0x28..+0x36

  dw forth_pfa
  dw root_pfa
  ds (max_search_order-2)*cell

  dw 0x0000 ; end of search order, required by `find`
            ; XXX TODO improve `find` and remove this

  ; Free space for more user variables:

user_data_pointer: equ $-user_variables
  ds bytes_per_user_variables-user_data_pointer,0xFF

; XXX OLD
; if ($-user_variables) != bytes_per_user_variables
;  .error "The space reserved for user variables is wrong."
; endif

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Circular string buffer

csb:
to_csb:
  dw csb_size ; unused space in the buffer
csb0:
  ds csb_size
csb_total_size: equ $-csb

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffer

buffer_block_id_mask: equ 0x7FFF

; A block id is the number of the associated block, with the
; sign bit indicating, when it's set, that the buffer has been
; modified.

disk_buffer:

  dw buffer_block_id_mask     ; Block id used when the  buffer
                              ; is not associated with a block.
  ds bytes_per_buffer    ; Actual content of the block.

; ==============================================================
; Misc routines

; Credits:
; Code from DZX-Forth.

; XXX TODO -- investigate if the code is optimized for Z80;
; the code of DZX-Forth is generic, also for 8080.

; ----------------------------------------------
; Compare de and hl

compare_de_hl_unsigned:

if 1

  ; Input:  DE, HL
  ; Output:
  ;  flag CY set if HL < DE
  ;  flag Z set if HL = DE

  ; Code from DZX-Forth

          ; t  B
          ; -- --
  ld a,h  ; 04 01
  cp d    ; 04 01
  ret nz  ; 11 01  05 01
  ld a,l  ; 04 01
  cp e    ; 04 01
  ret     ; 10 01
          ; -- --  -- --
          ; 37 06  31 06

else

  ; XXX TODO

  ; Code from Z88 CamelForth.

  ; The routine is so short that it's better to use the
  ; instructions directly. The problem is the output flags are
  ; different from the DZX-Forth version, and more complex to
  ; use.

  ; Input:  DE, HL
  ; Output:
  ;   negative & not OV:  HL<DE
  ;   negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ;   positive & not OV:  HL>=DE
  ;   positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ;   thus OV reverses the sense of the sign bit

            ; -- --
  or a      ; 04 01
  sbc hl,de ; 15 02
  ret       ; 10 01
            ; -- --
            ; 29 04

endif

compare_de_hl_signed:

  ; Input:  DE, HL
  ; Output: flag CY if HL < DE

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ----------------------------------------------
; Move block

move_block:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy the contents of bc consecutive address
  ; units at hl to the bc consecutive address units at de. After the move
  ; completes, the bc consecutive address units at de contain exactly what the
  ; bc consecutive address units at hl contained before the move.

  _compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

move_block_upwards:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from higher addresses to lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ----------------------------------------------
; Multiplication primitives

; AHL <- A * DE

a_multiplied_by_de_to_ahl:
  ld hl,0
  ld c,8
a_multiplied_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_multiplied_by_de_to_ahl.2
  add hl,de
  adc a,0
a_multiplied_by_de_to_ahl.2:
  dec c
  jp nz,a_multiplied_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32-bit result

; HLDE <- HL * DE

if 1 ; original_u_m_star

hl_multiplied_by_de_to_hlde_unsigned:
  push bc ; save Forth IP
  ld b,h
  ld a,l
  call a_multiplied_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_multiplied_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc ; restore Forth IP
  ret

endif

if 1 ; original_m_star
else

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde ; XXX TODO

endif

if 0

  ; XXX TODO -- code from DZX-Forth

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  ; two's complement
  dec hl
negate_hl.1:
  ; one's complement
  ld a,l
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  ret

endif

; ==============================================================
; :Inner interpreter

push_hlde:
  push de

push_hl:
  push hl

next:
  ; Execute the word whose cfa is in the address pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa

next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa) = address of the code
  ; de = cfa+1 = pfa-1

next2_end: ; XXX TMP label for debugging
  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
; Start compiling in the `root` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl root_pfa

; ----------------------------------------------
  _colon_header root_forth_,'FORTH'

  dw forth_
  dw exit_

; ----------------------------------------------
  _colon_header root_forth_wordlist_,'FORTH-WORDLIST'

  dw forth_wordlist_
  dw exit_

; ----------------------------------------------
  _colon_header root_definitions_,'DEFINITIONS'

  dw definitions_
  dw exit_

latest_nfa_in_root_voc: equ root_definitions_nfa

if 1 ; assembler_core_in_kernel

; ----------------------------------------------
; Start compiling in the `assembler` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa

; ----------------------------------------------

if 1 ; abase

  _variable_header abase_,'ABASE'

  ; XXX TODO use the return stack instead?
  ; but after removing `abase` the system crashes during the
  ; loading of `base64`.

; doc{
;
; abase  ( -- a )
;
; A variable used to save the current value of `base` in
; assembler definitions.
;
; }doc

  dw 0

endif

; ----------------------------------------------
  _colon_header end_asm_,'END-ASM'

; doc{
;
; end-asm  ( -- )
;
; Exit the assembler mode.
;
; }doc

  dw question_csp_
  dw previous_ ; restore the search order ; XXX TODO better
if 1 ; abase
  dw abase_,fetch_,base_,store_ ; restore `base`
else
  dw from_r_,base_,store_ ; restore `base`
endif

  dw exit_

; ----------------------------------------------
  _colon_header end_code_,'END-CODE'

  dw end_asm_,reveal_
  dw exit_

; ----------------------------------------------
  _constant_header next_,'NEXT'

  dw next

; ----------------------------------------------
  _constant_header next2_,'NEXT2'

  ; XXX OLD -- added for the second version of `defer`
  ; XXX -- used by `pause`

  dw next2

; ----------------------------------------------
  _constant_header pusha_,'PUSHA'

  dw push_a

; ----------------------------------------------
  _constant_header pushhl_,'PUSHHL'

  dw push_hl

; ----------------------------------------------
  _constant_header pushhlde_,'PUSHHLDE'

  dw push_hlde

; ----------------------------------------------
  _constant_header fetchhl_,'FETCHHL'

  dw fetch.hl

; ----------------------------------------------
  _colon_header jpnext_,'JPNEXT'

; doc{
;
; jpnext  ( -- )
;
; Compile a Z80 jump to `next`.
;
; }doc

  dw lit_,0xE9DD ; opcode `jp (ix)`
  dw comma_
  dw exit_

if 0 ; XXX OLD

; ----------------------------------------------
  _colon_header jppushhl_,'JPPUSHHL'

; doc{
;
; jppushhl  ( -- )
;
; Compile a Z80 jump to `pushhl`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,push_hl,comma_
  dw exit_

; ----------------------------------------------
  _colon_header jppushhlde_,'JPPUSHHLDE'

; doc{
;
; jppushhlde  ( -- )
;
; Compile a Z80 jump to `pushhlde`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,push_hlde,comma_
  dw exit_

; ----------------------------------------------
  _colon_header jpfetchhl_,'JPFETCHHL'

; doc{
;
; jpfetchhl  ( -- )
;
; Compile a Z80 jump to `fetchhl`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,fetch.hl,comma_
  dw exit_

latest_nfa_in_assembler_voc: equ fetchhl_comma_nfa

else

latest_nfa_in_assembler_voc: equ jpnext_nfa

endif

endif

; ----------------------------------------------
; Start compiling in the `forth` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa

; ----------------------------------------------
  _colon_header asm_,'ASM'

; doc{
;
; asm  ( -- )
;
; Enter the assembler mode.
;
; }doc

  ; Credits:
  ; Idea taken from Coos Haak's Z80 Forth assembler.

  dw store_csp_
if 1 ; abase
  dw base_,fetch_,abase_,store_ ; save the current base
else
  dw base_,fetch_,to_r_ ; save the current base
endif
  dw hex_
  dw also_,assembler_ ; XXX TODO better
  dw exit_

; ----------------------------------------------
  _colon_header also_,'ALSO'

; doc{
;
; also  ( -- )
;
; Duplicate the vocabulary at the top of the search order.
;
; ----
; : also  ( -- )
;   context dup cell+ [ #vocs 2- cells ] literal cmove>  ;
; ----
;
; }doc

  ; Credits:
  ; Code adapted from F83.

  ; XXX TODO -- check the limit

  dw context_,dup_,cell_plus_
  dw lit_,(max_search_order-cell)*cell
  dw cmove_up_
  dw exit_

; ----------------------------------------------
  _colon_header minus_order_,'-ORDER'

; doc{
;
; -order  ( -- )
;
; Erase the search order.
;
; ----
; : -order  ( -- )
;   context [ #vocs cells ] literal erase  ;
; ----
;
; }doc


  dw context_,lit_,max_search_order*cell,erase_
  dw exit_

; ----------------------------------------------
  _colon_header only_,'ONLY'

; doc{
;
; only  ( -- )
;
; Set the search order to the minimum search order: Forces the
; `root` vocabulary to be the first and second.
;
; ----
; : only  ( -- )
;   -order root also  ;
; ----
;
; }doc

  dw minus_order_,root_,also_
  dw exit_

; ----------------------------------------------
  _colon_header to_order_,'>ORDER'

; doc{
;
; >order  ( wid -- )
;
; Push _wid_ on the search order.
; 
; ----
; : >order  ( wid -- )  also context !  ;
; ----
;
; }doc

; Credits:
; Word from Gforth.

  dw also_,context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header previous_,'PREVIOUS'

; doc{
;
; previous  ( -- )
;
; Remove the most recently referenced vocabulary from the search
; order.
;
; ----
; : previous  ( -- )
;   context dup cell+ swap [ #vocs 2- cells dup ] literal cmove
;   context literal + off  ;
; ----
;
; }doc

  ; Credits:
  ; Code adapted from F83.

  dw context_,dup_,cell_plus_,swap_
  dw lit_,(max_search_order-cell)*cell,cmove_
  dw context_,lit_,(max_search_order-cell)*cell,plus_,off_
  dw exit_

; ----------------------------------------------
  _colon_header seal_,'SEAL'

; doc{
;
; seal  ( -- )
;
; Change the search order such that only the vocabulary at the
; top of the search order will be searched.
;
; ----
; : seal  ( -- )
;   context @ -order context !  ;
; ----
;
; }doc

  ; Credits:
  ; Code adapted from F83.

  dw context_,fetch_,minus_order_,context_,store_
  dw exit_

; ----------------------------------------------

  _does_header root_,'ROOT',,do_vocabulary

  dw latest_nfa_in_root_voc

root_vocabulary_link:
  dw 0x0000

; ----------------------------------------------
  _does_header forth_,'FORTH',,do_vocabulary

  dw latest_nfa_in_forth_voc ; nfa of the latest word defined in this vocabulary

forth_vocabulary_link:
  dw root_vocabulary_link

; ----------------------------------------------
  _constant_header forth_wordlist_,'FORTH-WORDLIST'

; doc{
;
; forth-wordlist  ( -- wid )
;
; Return _wid_, the identifier of the word list that includes
; all standard words provided by the implementation. This word
; list is initially the compilation word list and is part of the
; initial search order.
;
; Standard: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; }doc

  dw forth_pfa

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _does_header assembler_,'ASSEMBLER',,do_vocabulary

  dw latest_nfa_in_assembler_voc
assembler_vocabulary_link:
  dw forth_vocabulary_link

endif

; ----------------------------------------------
  _colon_header s_lit_,'SLIT'

; doc{
;
; slit  ( -- ca len )
;
; Return a string that is compiled after the calling word, and
; adjust the instruction pointer to step over the inline string.
;
; ----
; : slit  ( -- ca len )
;   r@ count dup 1+ r> + >r  ;
; ----
;
; }doc

  dw r_fetch_,count_,dup_,one_plus_,from_r_,plus_,to_r_
  dw exit_

; ----------------------------------------------
  _colon_header parse_string_,'PARSE-STRING'

; doc{
;
; parse-string ( compilation: c "text<c>" -- ) ( run-time:  -- ca len )
;
; }doc

  ; XXX WARNING -- state-smart

  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,parse_string.interpreting
  ; compiling
  dw s_literal_
  dw exit_
parse_string.interpreting:
  dw save_string_
  dw exit_

; ----------------------------------------------
  _code_header c_lit_,'CLIT',compile_only

  ld a,(bc)
  inc bc
push_a:
  ld l,a
push_l: ; XXX TMP -- not used yet
  ld h,0
  jp push_hl

; ----------------------------------------------
  _code_header two_lit_,'2LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  push hl
  jp lit_pfa

; ----------------------------------------------
  _code_header lit_,'LIT',compile_only

  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  jp push_hl

; ----------------------------------------------
  _code_header default_bank_,'DEFAULT-BANK'

; doc{
;
; default-bank  ( -- )
;
; Page the default memory bank in at 0xC000..0xFFFF.
;
; }doc

  call bank.default
  _jp_next

; ----------------------------------------------
  _code_header names_bank_,'NAMES-BANK'

; doc{
;
; names-bank  ( -- )
;
; Page the names memory bank in at 0xC000..0xFFFF.
;
; }doc

  call bank.names
  _jp_next

; ----------------------------------------------
  _code_header bank_,'BANK'

; doc{
;
; bank  ( n -- )
;
; Page memory bank _n_ (0..7) in at 0xC000..0xFFFF.
;
; }doc

  pop de ; E = bank
  call bank.e
  _jp_next

bank.names:
  ld e,names_bank
  jr bank.e
bank.default:
  ld e,default_bank
bank.e:
  ld a,(sys_bankm) ; get the saved status of BANKM
  and %11111000 ; erase bits 0-2
  or e ; modify bits 0-2
  di
  ld (sys_bankm),a ; update BANKM
  out (bank1_port),a ; page the bank
  ei
  ret

; ----------------------------------------------
  _code_header unused_csb_,'UNUSED-CSB'

; doc{
;
; csb-unused  ( -- n )
;
; Return the number of free chars in the circular string-buffer.
;
; ----
; : csb-unused  ( -- n )
;   >csb @  ;
; ----
;
; }doc

  ld hl,(to_csb)
  jp push_hl

; ----------------------------------------------
  _constant_header csb_size_,'CSB-SIZE'

; doc{
;
; csb-size  ( -- n )
;
; Return the size of the circular string-buffer, in chars.
;
; }doc

  dw csb_size

; ----------------------------------------------
  _constant_header to_csb_,'>CSB'

; doc{
;
; to_csb  ( -- a )
;
; Address of the circular string buffer pointer. It holds an
; offset to the first free address in the buffer; the offset
; coincides with the number of free chars.
;
; }doc

  dw to_csb

; ----------------------------------------------
  _constant_header csb0_,'CSB0'

; doc{
;
; csb0  ( -- a )
;
; Address of the data space of the circular string buffer.
;
; }doc

  dw csb0

; ----------------------------------------------
  _colon_header question_csb_,'?CSB'

; doc{
;
; ?csb  ( len -- )
;
; Make sure there's room in the circular string buffer for the
; given characters.
;
; ----
; : ?csb  ( len -- )
;   dup unused-csb >  \ not enough free space?
;   if  csb-size >csb !  then  negate >csb +!
; ----
; }doc

  dw dup_,unused_csb_,greater_than_
  dw zero_branch_,question_csb_.enough
  ; not enough space
  dw csb_size_,to_csb_,store_ ; reset the pointer

question_csb_.enough:
  dw negate_,to_csb_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header allocate_string_,'ALLOCATE-STRING'

; doc{
;
; allocate-string  ( len -- ca )

; Allocate _len_ chars in the circular string buffer and return
; the address _ca_ of the allocated space.
;
; ----
; : allocate-string  ( len -- ca )
;   ?csb csb0 unused-csb +  ;
; ----
;
; }doc

  dw question_csb_
  dw csb0_,unused_csb_,plus_
  dw exit_

; ----------------------------------------------
  _colon_header save_string_,'SAVE-STRING'

; doc{
;
; save-string  ( ca1 len1 -- ca2 len1 )

; Save the string _ca1 len1_ in the circular string buffer and
; return it at its new address.
;
; ----
; : save-string  ( ca1 len1 -- ca2 len1 )
;   dup allocate-string swap 2dup 2>r move 2r>  ;
; ----
;
; }doc

  dw dup_,allocate_string_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw exit_

; ----------------------------------------------
  _colon_header empty_csb_,'EMPTY-CSB'

; doc{
;
; empty-csb  ( -- )
;
; Empty the circular string buffer.
;
; }doc

  dw lit_,csb
  _literal csb_total_size
  dw erase_
  dw exit_

; ----------------------------------------------
  _code_header execute_,'EXECUTE'

; doc{
;
; execute  ( cfa  -- )
;
; }doc

  pop hl
  jp next2

; ----------------------------------------------
  _code_header perform_,'PERFORM'

; doc{
;
; perform  ( a  -- )
;
; Execute the word whose cfa is stored in _a_.  Do nothing if
; the content of _a_ is zero.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp nz,next2
  _jp_next

; ----------------------------------------------
  _colon_header forward_mark_,'>MARK'

; doc{
;
; >mark  ( -- orig )
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; Standard: Forth-83.
;
; }doc

  dw here_,zero_,comma_
  dw exit_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLVE'

; doc{
;
; >resolve  ( orig -- )
;
; Resolve a forward branch by placing the address of the current
; dictionary pointer into the space compiled by `>mark`.
;
; Standard: Forth-83.
;
; }doc

  dw here_,swap_,store_
  dw exit_

; ----------------------------------------------
  _colon_header backward_mark_,'<MARK'

  ; XXX TODO convert to an alias

; doc{
;
; <mark  ( -- dest )
;
; Leave the address of the current dictionary pointer, as the
; the destination of a backward branch.  _dest_ is typically
; only used by `<resolve` to compile a branch address.
;
; Standard: Forth-83.
;
; }doc

  ; XXX TODO convert to an alias

  dw here_
  dw exit_

; ----------------------------------------------
  _colon_header backward_resolve_,'<RESOLVE'

  ; XXX TODO convert to an alias

; doc{
;
; <resolve  ( dest -- )
;
; Resolve a backward branch.  Compile a branch address using
; _dest_, the address left by `<mark`,  as the destination
; address.  Used at the source of a backward branch after either
; `branch` or `?branch` or `0branch`.
;
; Standard: Forth-83.
;
; }doc

  dw comma_
  dw exit_

; ----------------------------------------------
  _code_header branch_,'BRANCH'

; doc{
;
; branch  ( -- )
;
; The run-time procedure to branch unconditionally. An in-line
; offset is copied to the interpretive pointer IP to branch
; forward or backward.
;
; Standard: Forth-94.
;
; }doc

  ld h,b
  ld l,c ; hl = Forth IP, containing the address to jump to
  ld c,(hl)
  inc hl
  ld b,(hl) ; bc = New Forth IP
  _jp_next

; ----------------------------------------------
  _code_header zero_branch_,'0BRANCH'

; doc{
;
; 0branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is false (zero), the following in-line address is copied to IP
; to branch forward or  backward.
;
; Standard: fig-Forth.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_pfa ; branch if zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANCH'

; doc{
;
; ?branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is not zero, the following in-line address is copied to IP to
; branch forward or backward.
;
; Note: This is not Forth-83's `?branch`: Forth-83's `?branch`
; does the same than fig-Forth's `0branch`: the branch is done
; when the flag is zero. Solo Forth includes fig-Forth's
; `0branch` and also `?branch`, that branches when the flag is
; not zero.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_pfa ; branch if not zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next


; ==============================================================
if 0 ; old_loops

; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; Credits:
  ; Code from CP/M fig-Forth 1.1g.

  exx                           ; 04t 01b
  pop de                        ; 10t 01b
  pop bc                        ; 10t 01b
  ld hl,(return_stack_pointer)  ; 20t 03b
  dec hl                        ; 06t 01b
  ld (hl),b                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),c                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),d                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),e                     ; 07t 01b
  ld (return_stack_pointer),hl  ; 16t 03b
  exx                           ; 04t 01b
                                ;116t 18b TOTAL
  _jp_next

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate+compile_only

; doc{
;
; +loop  ( n -- )
;
; Add the  signed  increment  _n_ to the  loop  index  using
; the convention for `+`,  and compare the total to the limit.
; Return execution to the corresponding `do` until the new index
; is equal to or greater than the limit (n>0),  or until the new
; index is less  than the limit (n<0).   Upon the exiting from
; the  loop, discard  the  loop control  parameters,  continuing
; execution ahead.   Index and  limit are  signed  integers in
; the  range {-32,768..32,767}.
;
; Standard: fig-Forth, Forth-79.
;
; }doc

  dw compile_,paren_plus_loop_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate+compile_only

; XXX TODO documentation
; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Standard: fig-Forth, Forth-79.
;
; }doc

  dw compile_,paren_loop_
  dw backward_resolve_
  dw exit_

; ; ----------------------------------------------
;   _code_header paren_question_do_,'(?DO)'

; ; XXX UNDER DEVELOPMENT
; ; A `(?do)` after Forth-79

;   ; Credits:
;   ; Code based on Spectrum Forth-83.

; if 0

;   pop hl
;   pop de
;   and a
;   sbc hl,de
;   jp z,branch_pfa
;   add hl,de  ; reverse the substraction
;   jp paren_do.de_hl

; endif

;   _jp_next

; ; ----------------------------------------------
;   _colon_header question_do_,'?DO',immediate+compile_only

; ; XXX UNDER DEVELOPMENT
; ; A `?do` after Forth-79

; ; doc{
; ;
; ; ?do  ( n1 n2 -- )
; ;
; ; }doc

;   dw compile_,paren_question_do_
;   dw backward_mark_
;   dw exit_
;   _colon_header do_,'DO',immediate+compile_only

; ----------------------------------------------
  _colon_header do_,'DO',immediate+compile_only

; doc{
;
; do  ( n1 n2 -- )
;
; Standard: fig-Forth, Forth-79.
;
; }doc

  dw compile_,paren_do_
  dw backward_mark_
  dw exit_

; ----------------------------------------------
  _code_alias_header i_,'I',,r_fetch_

; doc{
;
; i  ( -- x ) ( R: loop-sys -- loop-sys )
;
; Return a copy of the current (innermost) loop index.
;
; }doc

; ----------------------------------------------
  _code_header exhaust_,'EXHAUST'

; doc{
;
; exhaust  ( -- ) ( R: n1 n2 -- n2 n2 )
;
;   n1 = loop limit
;   n2 = loop index
;
; Force termination of a do-loop at the next opportunity by
; setting the loop limit equal to the current value of the
; index. The index itself remains unchanged, and execution
; proceeds normally until `loop` or `+loop` is encountered.
;
; Note: This is the equivalent of fig-Forth's `leave`.
;
; }doc

  ; XXX TODO rename to `leave-next`.

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header question_exhaust_,'?EXHAUST'

; doc{
;
; ?exhaust  ( f -- ) ( R: n1 n2 -- n1 n2 | n2 n2 )
;
; n1 = loop limit
; n2 = loop index
;
; If _f_ is not false, force termination of a do-loop at the
; next opportunity by setting the loop limit equal to the
; current value of the index. The index itself remains
; unchanged, and execution proceeds normally until `loop` or
; `+loop` is encountered.
;
; }doc

  ; XXX TODO rename to `?leave-next`.

  pop hl
  ld a,h
  or l
  jp nz,exhaust_pfa
  _jp_next

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  pop de
  jp paren_loop.step_in_de

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

; doc{
;
; (loop)  ( n -- )
;
; Add the  signed  increment  _n_ to the  loop  index  using
; the convention for `+`,  and compare the total to the limit.
; Return execution to the corresponding `do` until the new index
; is equal to or greater than the limit (n>0),  or until the new
; index is less  than the limit (n<0).   Upon the exiting from
; the  loop, discard  the  loop control  parameters,  continuing
; execution ahead.   Index and  limit are  signed  integers in
; the  range {-32,768..32,767}.
;
; }doc

  ; Credits:
  ;
  ; This code is from Abersoft Forth.  It's the same code used
  ; in `(+loop)` in fig-Forth 1.1g.  The author of Abersoft
  ; Forth used it to write `(loop)` and wrote `(+loop)` with a
  ; simple call to it, what saves code.

  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_stack_pointer)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl ; (hl) = limit
  inc d
  dec d
  ld d,a ; de = new index
  jp m,paren_loop.negative_step

  ; increment>0
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp paren_loop.end

paren_loop.negative_step:
  ; increment<0
  ld a,(hl) ; limit-index
  sub e
  inc hl
  ld a,(hl)
  sbc a,d ; a<0?

paren_loop.end:
  jp m,branch_pfa ; loop again if a<0
  ; done, discard loop parameters
  inc hl
  ld (return_stack_pointer),hl
  ; skip branch offset
  inc bc
  inc bc
  _jp_next

; ==============================================================
else ; new loops


; ----------------------------------------------
  _code_header paren_question_do_,'(?DO)'

  ; Credits:
  ; Code based on Spectrum Forth-83.

  pop hl
  pop de
  and a
  sbc hl,de
  jp z,branch_pfa
  add hl,de  ; reverse the substraction
  jp paren_do.de_hl

; ----------------------------------------------
  _colon_header question_do_,'?DO',immediate+compile_only

; doc{
;
; ?do  ( n1 n2 -- )
;
; Standard: Forth-83, Forth-94, Forth-2012.
;
; ----
; : ?do  ( n1 n2 -- )
;   postpone (?do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_question_do_
  dw forward_mark_
  dw exit_

  _colon_header do_,'DO',immediate+compile_only

; doc{
;
; do  ( n1 n2 -- )
;
; Standard: Forth-83, Forth-94, Forth-2012.
;
; ----
; : do  ( n1 n2 -- )
;   postpone (do) >mark  ;  immediate compile-only
; ----
;
; }doc

  dw compile_,paren_do_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate+compile_only

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Standard: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate+compile_only

; doc{
;
; loop  ( -- )
;
; Increment the `do-loop` index by one, terminating the loop  if
; the new index is equal to or greater than  the  limit.
;
; Standard: Forth-83, Forth-94, Forth-2012.
;
; }doc

  dw compile_,paren_plus_loop_
  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; Credits:
  ; Code from Spectrum Forth-83.

  pop hl                        ; 10t 01b ; init
  pop de                        ; 10t 01b ; limit
paren_do.de_hl:
  push hl                       ; 11t 01b
  ld hl,(return_stack_pointer)  ; 20t 03b
  dec hl                        ; 06t 01b
  ld (hl),d                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),e                     ; 07t 01b ; push limit on return stack
  inc bc
  inc bc                        ; skip branch address
  dec hl                        ; 06t 01b
  ld (hl),b                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),c                     ; 07t 01b ; push IP on return stack
  ex (sp),hl                    ; hl=init, (sp)=rp@
  and a
  sbc hl,de                     ; hl=init-limit
  ld a,h
  xor 0x80                      ; flip most significant bit
  ld d,a
  ld e,l
  pop hl                        ; hl=rp@
  dec hl
  ld (hl),d                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),e                     ; 07t 01b ; push (init-limit) xor 0x8000 on return stack
  ld (return_stack_pointer),hl  ; 16t 03b
                                ;116t 18b TOTAL
  _jp_next


; ----------------------------------------------
  _code_header i_,'I'

  ld hl,(return_stack_pointer)
  ; J jumps here. ; XXX TODO
  ld e,(hl)
  inc hl
  ld d,(hl) ; de= current index, wich is: (index-limit) xor 0x8000
  inc hl
  inc hl
  inc hl
  ld a,(hl)
  add a,e   ; read limit and add to index
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  xor 0x80  ; flip most significant bit, getting true index value
  ld d,a
  push de ; result
  _jp_next

; ----------------------------------------------
  _code_header leave_,'LEAVE'

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; bc = start address
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl ; write updated return stack pointer (6 was added)
  dec bc
  dec bc ; point IP to forward branch address
  jp branch_pfa

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; de = current index
  ex (sp),hl  ; hl = the increment value

  and a
  adc hl,de   ; add increment to index
  ; Note: `and a` and `adc` are used because `add` does not affect the po flag
  jp po,paren_plus_loop.continue

  ; If overflow, then boundary between limit-1 and limit is
  ; crossed, terminate loop.

  pop hl ; return stack pointer
  ld de,0x0005
  add hl,de
  ld (return_stack_pointer),hl
  ; Increment return stack pointer by 5 (1 increment already done)
  _jp_next

paren_plus_loop.continue:
  ld d,h
  ld e,l ; de = updated index
  pop hl ; return stack pointer

paren_loop.continue:

  ld (hl),d
  dec hl
  ld (hl),e  ; update the index on the return stack
  inc hl
  inc hl
  ld c,(hl)
  inc hl
  ld b,(hl) ; IP = start address, repeat loop
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)   ; de = index value
  inc de      ; increment the index
  ld a,d
  xor 0x80
  or e        ; index=0x8000?
  jp nz,paren_loop.continue

  ; limit reached
  ld de,0x0005
  add hl,de ; increment RP by 5 (1 already done)
  ld (return_stack_pointer),hl
  _jp_next

endif

; ----------------------------------------------
  _code_header digit_question_,'DIGIT?'

; doc{
;
; digit?  ( c n -- u true | false )
;
; Convert the ascii character _c_ (using base _n_) to its binary
; equivalent _u_, accompanied by a true flag. If the conversion
; is invalid, leave only a false flag.
;
; Note: This word is equivalent to fig-Forth's `digit`.
;
; }doc

; XXX Note: alternative implementation in CamelForth:
;
;   \ silly looking but it works!
;   DUP $39 > $100 AND +
;   DUP $140 > $107 AND - $30 -
;   DUP BASE @ U< ;

  pop hl  ; l=base
  pop de  ; e=character
  ld a,e  ; character
  call upper.a
  sub '0' ; >="0"?
  jp c,false_pfa ; <"0" is invalid
  cp 0x0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub 0x07 ; gap between "9" & "A", now "A"=0x0A
  cp 0x0A ; >="A"?
  jp c,false_pfa ; characters between "9" & "A" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_pfa ; no, invalid
  ld e,a ; converted digit
  push de
  jp true_pfa

; ----------------------------------------------
  _colon_header number_base_,'NUMBER-BASE'

; doc{
;
; number-base  ( ca len -- ca' len' n )
;
; If the first char of string _ca len_ is a radix prefix, return
; its value _n_ and the updated string _ca' len'_ (which does
; not include the radix prefix).  Otherwise return _ca len_
; untouched and the current value of `base`.
;
; ----
; : number-base  ( ca len -- ca' len' n )
;   dup if
;    over c@
;    dup [char] $ = if  drop 1 /string 16  exit  then
;    dup [char] % = if  drop 1 /string  2  exit  then
;        [char] # = if       1 /string 10  exit  then
;   then
;   base @  ;
; ----
;
; }doc

number_base.try_hex:
  dw dup_
  dw zero_branch_,number_base.current
  dw over_,c_fetch_
  dw dup_
  _literal '$'
  dw equals_,zero_branch_,number_base.try_binary
  dw drop_
  _literal 1
  dw slash_string_
  _literal 16
  dw exit_
number_base.try_binary:
  dw dup_
  _literal '%'
  dw equals_,zero_branch_,number_base.try_decimal
  dw drop_
  _literal 1
  dw slash_string_
  _literal 2
  dw exit_
number_base.try_decimal:
  _literal '#'
  dw equals_,zero_branch_,number_base.current
  _literal 1
  dw slash_string_
  _literal 10
  dw exit_
number_base.current:
  dw base_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header to_number_,'>NUMBER'

; doc{
;
; >number  ( ud1 ca1 len1 -- ud2 ca2 len2 )

; _ud2_ is the unsigned result of converting the characters
; within the string specified by _ca1 len1_ into digits, using
; the number in `base`, and adding each into _ud1_ after
; multiplying _ud1_ by the number in `base`. Conversion
; continues left-to-right until a character that is not
; convertible, including any "+" or "-", is encountered or the
; string is entirely converted. _ca2_ is the location of the
; first unconverted character or the first character past the
; end of the string if the string was entirely converted. _len2_
; is the number of unconverted characters in the string.

; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : >number  ( d1 ca1 len1 -- d2 ca2 len2 )
;   begin  dup  while
;     over c@ base @ digit? while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string
;        \ 1 dpl +! \ XXX TODO
;   repeat then  ;
; ----
;
;
; }doc

; XXX TODO -- check:
; An ambiguous condition exists if _ud2_ overflows during the
; conversion.

  ; Credits:
  ; Code from DZX-Forth.

to_number.begin: ; begin
  dw dup_
  dw zero_branch_,to_number.end  ; while
; _chk '>number -- before digit' ; XXX INFORMER
  dw over_,c_fetch_,base_,fetch_,digit_question_
; _chk '>number -- after digit' ; XXX INFORMER
  dw zero_branch_,to_number.end  ; while
  dw to_r_,two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw u_m_star_,drop_
  dw rot_
  dw base_,fetch_
  dw u_m_star_
  dw d_plus_
  dw two_swap_
  dw one_,slash_string_
  ; dw one_,dpl_,plus_store_ ; XXX TODO why this?
  dw branch_,to_number.begin  ; repeat
to_number.end:
  ; then
  dw exit_

; ----------------------------------------------
  _colon_header number_question_,'NUMBER?'

  ; XXX TODO convert this to a deferred word, to
  ; make it hackable.

if 0 ; XXX OLD -- version adapted from pForth

  ; XXX Note: this version ocuppies 26 bytes less than the
  ; next one, improved, inspired by fig-Forth.

; doc{
;
; number?   ( ca len -- 0 | n 1 | d 2 )
;
; Convert a string _ca len_ to a number. Return 0 if the
; conversion is not possible. If the result is a single number,
; return _n_ and 1. If the result is a double number, return _d_
; and 2.

; : number?   ( ca len -- 0 | n 1 | d 2 )
;   dup 0= if  2drop 0 exit  then
;   base @ >r number-base base !
;   skip-sign? >r
;   dpl on  0 0 2swap >number dup
;   if
;     1 =  \ one non-converted character left?
;     swap c@ [char] . =  and  \ and is it '.'?
;     if    r@ ?dnegate  dpl off  2  \ if so, it's a double number
;     else  2drop 0  then
;   else
;     2drop d>s r@ ?negate  1
;   then  rdrop  r> base !  ;

;
; }doc

  ; Credits:
  ; Code adapted from pForth.

  dw dup_
  dw question_branch_,number_question.not_empty
  dw two_drop_
  _literal 0
  dw exit_

number_question.not_empty:

  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  dw dpl_,on_
  _literal 0
  _literal 0
  dw two_swap_,to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question.single

  ; The conversion was not completed, so it may be because of
  ; the final dot that indicates it's a double number.

  _literal 1
  dw equals_ ; only one character left?
  dw swap_,c_fetch_
  _literal '.'
  dw equals_,and_ ; and is it a dot?
  dw zero_branch_,number_question.failed_conversion

number_question.double:
  ; double number
  dw r_fetch_,question_d_negate_
  dw dpl_,off_
  _literal 2
  dw branch_,number_question.end

number_question.failed_conversion:
  dw two_drop_
  _literal 0
  dw branch_,number_question.end

number_question.single:
  ; single number
  dw two_drop_,d_to_s_
  dw r_fetch_,question_negate_
  _literal 1

number_question.end:
  dw r_drop_               ; discard the sign flag
  dw from_r_,base_,store_  ; restore `base`
  dw exit_

endif

if 0 ; XXX NEW -- improved version inspired by fig-Forth

  ; This improved version:
  ;
  ; - Accepts a "." at any position and updates `dpl` accordingly.

  ; XXX Note: this version ocuppies 26 bytes more than the
  ; one based on pForth.

; doc{
;
; number?   ( ca len -- 0 | n 1 | d 2 )
;
; Convert a string _ca len_ to a number. Return 0 if the
; conversion is not possible. If the result is a single number,
; return _n_ and 1. If the result is a double number, return _d_
; and 2.

; : number?   ( ca len -- 0 | n 1 | d 2 )
;   dup 0= if  2drop 0 exit  then
;   base @ >r  number-base base !  ( R: radix )
;   skip-sign? >r                  ( R: radix sign )
;   0 0 2swap  dpl on
;   begin                          ( d ca len )
;     >number dup
;   while
;     over c@ [char] . <>   \ not a decimal point?
;     dpl @ 0< 0=  or       \ or not the first decimal point?
;     if  2drop 2rdrop 0 exit  then
;     dup 1- dpl !  \ update the position of the decimal point
;     1 /string     \ skip the decimal point
;   repeat
;   2drop     \ discard the empty string
;   dpl @ 0<  \ single-cell number?
;   if    d>s r> ?negate  1   \ single-cell number
;   else  r> ?dnegate  2      \ double-cell number
;   then  r> base !  ;        \ restore the radix

; }doc

  dw dup_,zero_equals_
  dw zero_branch_,number_question2.not_empty
  dw two_drop_
  _literal 0
  dw exit_

number_question2.not_empty:

  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  _literal 0
  _literal 0
  dw two_swap_,dpl_,on_
number_question2.begin:
  dw to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question2.done ; while

  ; The conversion was not completed, so it may be because of
  ; the final dot that indicates it's a double number.

  dw over_,c_fetch_
  _literal '.'
  dw not_equals_ ; not a decimal point?
  dw dpl_,fetch_,zero_less_than_,zero_equals_ ; not the first decimal point?
  dw or_
  dw zero_branch_,number_question2.decimal_point
  dw two_drop_,two_r_drop_
  _literal 0
  dw exit_

number_question2.decimal_point:
  dw dup_,one_minus_,dpl_,store_ ; update the position of the decimal point
  _literal 1
  dw slash_string_ ; skip the decimal point

  dw branch_,number_question2.begin ; repeat

number_question2.done:
  dw two_drop_ ; discard the empty string
  dw dpl_,fetch_,zero_less_than_ ; single-cell number?
  dw zero_branch_,number_question2.double

  ; single-cell number
  dw d_to_s_,from_r_,question_negate_
  _literal 1
  dw branch_,number_question2.end

number_question2.double:
  ; double-cell number
  dw from_r_,question_d_negate_
  _literal 2

number_question2.end:
  dw from_r_,base_,store_  ; restore `base`

  dw exit_

endif

if 1 ; XXX NEW

  ; This improved version:
  ;
  ; - Accepts a "." at any position and updates `dpl` accordingly.
  ; - Recognizes chars between single quotes, after Forth-2012.

; doc{
;
; number?   ( ca len -- 0 | n 1 | d 2 )
;
; Convert a string _ca len_ to a number. Return 0 if the
; conversion is not possible. If the result is a single number,
; return _n_ and 1. If the result is a double number, return _d_
; and 2.

; : number?   ( ca len -- 0 | n 1 | d 2 )
;   dup 0= if  2drop 0 exit  then
;   2dup char? if nip nip 1 exit  then
;   base @ >r  number-base base !  ( R: radix )
;   skip-sign? >r                  ( R: radix sign )
;   0 0 2swap  dpl on
;   begin                          ( d ca len )
;     >number dup
;   while
;     over c@ [char] . <>   \ not a decimal point?
;     dpl @ 0< 0=  or       \ or not the first decimal point?
;     if  2drop 2rdrop 0 exit  then
;     dup 1- dpl !  \ update the position of the decimal point
;     1 /string     \ skip the decimal point
;   repeat
;   2drop     \ discard the empty string
;   dpl @ 0<  \ single-cell number?
;   if    d>s r> ?negate  1   \ single-cell number
;   else  r> ?dnegate  2      \ double-cell number
;   then  r> base !  ;        \ restore the radix

; }doc

  dw dup_,zero_equals_
  dw zero_branch_,number_question2.not_empty
  dw two_drop_
  _literal 0
  dw exit_

number_question2.not_empty:
  dw two_dup_,char_question_
  dw zero_branch_,number_question2.not_char
  dw nip_,nip_
  _literal 1
  dw exit_

number_question2.not_char:
  dw base_,fetch_,to_r_
  dw number_base_,base_,store_

  dw skip_sign_question_,to_r_
  _literal 0
  _literal 0
  dw two_swap_,dpl_,on_
number_question2.begin:
  dw to_number_
  dw dup_ ; are there non-recognized chars?
  dw zero_branch_,number_question2.done ; while

  ; The conversion was not completed, so it may be because of
  ; the final dot that indicates it's a double number.

  dw over_,c_fetch_
  _literal '.'
  dw not_equals_ ; not a decimal point?
  dw dpl_,fetch_,zero_less_than_,zero_equals_ ; not the first decimal point?
  dw or_
  dw zero_branch_,number_question2.decimal_point
  dw two_drop_,two_r_drop_
  _literal 0
  dw exit_

number_question2.decimal_point:
  dw dup_,one_minus_,dpl_,store_ ; update the position of the decimal point
  _literal 1
  dw slash_string_ ; skip the decimal point

  dw branch_,number_question2.begin ; repeat

number_question2.done:
  dw two_drop_ ; discard the empty string
  dw dpl_,fetch_,zero_less_than_ ; single-cell number?
  dw zero_branch_,number_question2.double

  ; single-cell number
  dw d_to_s_,from_r_,question_negate_
  _literal 1
  dw branch_,number_question2.end

number_question2.double:
  ; double-cell number
  dw from_r_,question_d_negate_
  _literal 2

number_question2.end:
  dw from_r_,base_,store_  ; restore `base`

  dw exit_

endif

; ----------------------------------------------
  _colon_header char_question_,'CHAR?'

; doc{
;
; char?  ( ca len -- c true | false )
;
; ----
; : char?  ( ca len -- c true | false )
;   3 <> if
;     dup c@ [char] ' <> if
;       dup [ 2 chars ] literal + c@ [char] ' <>
;       if  char+ c@ true exit  then
;     then
;   then
;   drop false ;
; }doc

  _literal 3
  dw equals_
  dw zero_branch_,char_question.not

char_question.right_length:
  dw dup_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.first_quote:
  dw dup_,two_plus_,c_fetch_
  _literal "'"
  dw equals_
  dw zero_branch_,char_question.not

char_question.match:
  dw char_plus_,c_fetch_,true_,exit_

char_question.not:
  dw drop_,false_,exit_
  dw exit_

; ----------------------------------------------
  _colon_header skip_sign_question_,'SKIP-SIGN?'

; : sign?  ( ca len -- ca' len' f )
;   \ get optional sign
;   \ ca len = number
;   \ ca' len' = number without the minus sign
;   \ f = negative number?
;   over c@ [char] - = dup >r abs /string r>  ;

  ; Credits:
  ; Code adapted from CamelForth.

;  _prompt 'sign? -- start' ; XXX INFORMER
  dw over_,c_fetch_
  _literal '-'
;  _prompt 'sign? -- before =' ; XXX INFORMER
  dw equals_,dup_,to_r_,abs_
  dw slash_string_,from_r_
;  _prompt 'sign? -- end' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _code_header find_name_from_,'FIND-NAME-FROM'

; doc{
;
; find-name-from  ( ca len nfa -- nfa | 0 )
;
; Find the definition named in the string at _ca len_, starting
; at _nfa_. If the definition is found, return its _nfa_, else
; return zero.
;
; The search is case-sensitive.
;
; }doc

  ; XXX TODO --
  ; in comp.lang.forth, thread "description of Forth-2012's
  ; `synonym`", there are some suggestions:
  ; 
  ; found  ( ca len -- nfa | 0 ) \ Albert van der Horst
  ; find-name-in ( ca len wid -- nfa | 0 ) \ Bernd Paysan
  ; search-name  ( ca len wid -- nfa | 0 ) \ Mathias Trute, amforth

  ld (find_name_from.ip_backup),bc ; save the Forth IP

  call bank.names ; page the memory bank in

  pop hl ; nfa
  pop bc ; C=len, B is supposed to be 0
  ld a,c
  ld (find_name_from.string_length),a
  pop de ; ca
  ld (find_name_from.string_address),de

  ; XXX FIXME the string searched for must be in the string
  ; buffer, below 0xC000! This is not a problem now, during the
  ; development, because the dictionary is small.

find_name_from.begin:
  ; Compare the string with a new word.
  ; hl = nfa
  ld (find_name_from.nfa_backup),hl ; save the nfa for later
find_name_from.string_address: equ $+1
  ld de,0x0000 ; string address
  ld a,(hl) ; length byte of the name field
  and valid_word_length_mask  ; mask the length and the smudge bit
find_name_from.string_length: equ $+1
  ld c,0x00 ; length of the string
  cp c ; same length?
  jr nz,find_name_from.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  inc hl ; point to the first char of the name in the dictionary
find_name_from.compare_next_char:
  ld a,(de)
  call upper.a ; XXX NEW experimental
  cpi
  inc de ; point to next character of the string
  jp nz,find_name_from.not_a_match ; mismatch
  jp pe, find_name_from.compare_next_char ; count not exhausted

  ; The string matches.
  ld hl,(find_name_from.nfa_backup)
  jr find_name_from.end

find_name_from.not_a_match:
  ; Not a match, try the next word.

find_name_from.nfa_backup: equ $+1
                                        ;  T  B
  ld hl,0x0000 ; nfa                      10 03
  dec hl ; high address of lfa            06 01
  ld d,(hl) ; high part of the next nfa   07 01
  dec hl ; low address of lfa             06 01
  ld e,(hl) ; low part of the next nfa    07 01
  ex de,hl                              ; 04 01
  ld a,h                                ; 04 01
  or l ; end of dictionary? (next nfa=0)  04 01
                                        ; 48 10 TOTAL

  jp nz,find_name_from.begin ; if not, continue

  ; End of dictionary, no match found.
  ld hl,false

find_name_from.end:
  ; If match found:
  ;   hl = nfa
  ; If no match found:
  ;   hl = false
  exx
  call bank.default ; page the default memory bank in
  exx
find_name_from.ip_backup: equ $+1
  ld bc,0x0000 ; restore the Forth IP
  jp push_hl

; ----------------------------------------------
  _colon_header search_wordlist_,'SEARCH-WORDLIST'

; doc{
;
; search-wordlist  ( ca len wid -- 0 | cfa 1 | cfa -1 )
;
; Find the definition identified by the string _ca len_ in the
; word list identified by _wid_. If the definition is not found,
; return zero. If the definition is found, return its _cfa_ and
; one (1) if the definition is immediate, minus-one (-1)
; otherwise.
;
; The search is case-insensitive.
;
; Standard: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : search-wordlist  ( ca len wid -- 0 | cfa 1 | cfa -1 )
;   @ find-name-from dup 0= ?exit
;   name>immediate? 0= 1 or  ;
; ----
;
; }doc

  ; XXX -- can not be moved to the library because `header` uses
  ; it.

  dw fetch_,find_name_from_  ; ( nfa | 0 )
  dw dup_,zero_equals_  ; ( nfa false | 0 true )
  dw question_exit_  ; ( nfa )
  dw name_to_immediate_question_ ; ( cfa f )
  dw zero_equals_
  _literal 1
  dw or_ ; ( cfa 1 | cfa -1 )
  dw exit_

; ----------------------------------------------
  _colon_header find_name_,'FIND-NAME'

; doc{

; find-name  ( ca len -- nfa | 0 )
;
; Find the definition identified by the string _ca len_ in the
; current search order. If the definition is not found after
; searching all the vocabularies in the search order, return
; zero.  If the definition is found, return its _nfa_.
;
; The search is case-insensitive.
;
; ----
; : find-name  ( ca len -- nfa | 0 )
;   2dup uppers
;   #vocs 0 do
;     context i cells + @  ?dup
;     if  @ >r 2dup r> @ find-name-from ?dup
;         ( ca len nfa nfa | ca len 0 )
;         if  nip nip unloop exit  then
;     then
;   loop  2drop false  ;
; ----
;
; }doc

;  _chk_type 'find-name -- start' ; XXX INFORMER
  dw hash_vocs_,zero_
  dw paren_do_,find_name.loop_exit ; do

  ; ( ca len )
  dw context_,i_,cells_,plus_,fetch_
  dw question_dup_ ; a vocabulary in the search order?

  dw zero_branch_,find_name.loop ; if not, next
  ; ( ca len wid )
  ; valid vocabulary in the search order
  dw fetch_,to_r_,two_dup_,from_r_
;  _chk 'find-name -- before find-name-from' ; XXX INFORMER
  dw find_name_from_,question_dup_ ; ( nfa nfa | 0 ) word found?
  dw zero_branch_,find_name.loop
;  _chk 'find-name -- found' ; XXX INFORMER
  dw nip_,nip_,unloop_,exit_
find_name.loop:
  dw paren_loop_ ; loop
find_name.loop_exit:

  dw two_drop_,false_
  dw exit_

; ----------------------------------------------
  _code_header scan_,'SCAN'

; doc{
;
; scan  ( ca1 len1 c -- ca2 len2 )
;
; Scan the string _ca1 len1_ for the first occurence of
; character _c_.  Leave match address _ca2_ and length remaining
; _len2_.  If no match occurred then _len2_ is zero and _ca2_ is
; _ca1+len1_.
;
; }doc

  exx
  pop de ; E = char searched for
  pop bc ; len1, count
  ld a,c
  or b ; empty string?
  jr z,scan.nothing ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
  cpir ; scan until match or count=0
  jr nz,scan.no_match
  dec hl ; point to match char
  inc bc ; adjust the count
scan.no_match:
  push hl
scan.nothing:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header skip_,'SKIP'

; doc{
;
; skip  ( ca1 len1 c -- ca2 len2 | ca1 len1 )
;
; Skip over leading occurences of the character _c_ in the string
; _ca1 len1_.  Leave the address of the first non-matching
; character _ca2_ and length remaining _len2_.  If no characters were
; skipped leave _ca1 len1_.
;
; }doc

; Credits:
; Code adapted and modified from CamelForth.

  exx
  pop de ; E = char searched for
  pop bc ; len1
  ld a,c
  or b ; empty string?
  jr z,skip.end ; if so, exit
  pop hl ; ca1
  ld a,e ; A = char searched for
skip.begin:
  cpi
  jr nz,skip.mismatch ; char mismatch, exit
  jp pe,skip.begin ; count not exhausted
  jr skip.done ; count 0, no mismatch
skip.mismatch:
  dec hl ; point at mismatch char
  inc bc ; adjust the count
skip.done:
  push hl
skip.end:
  push bc
  exx
  _jp_next

; ----------------------------------------------
  _code_header chan_,'CHAN'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
  ; Credits:
  ; Code from Spectrum Forth-83.

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header paren_mode32_emit_,'(MODE32-EMIT)'

; doc{
;
; (emit)  ( b -- )
;
; Send the character _b_ to the current channel.
;
; }doc

if 0

  ; Credits:
  ; Code from Spectrum Forth-83's `TOCH`.


  ; XXX default printing system, with the ZX Spectrum charset
  ; XXX OLD

  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
  _jp_next

endif

if 0

  ; XXX alternative 1

  ; XXX OLD -- this uses UDG as a fake charset, but it can not
  ; work fine, because block chars and UDG are shown anyway,
  ; with higher codes.

  pop hl
  ld a,l
  ld hl,(sys_chars)
  push hl
  cp 128
  jr c,paren_mode32_emit.print_a
  sub 96
  ld hl,(sys_udg)
  dec h
  ld (sys_chars),hl
paren_mode32_emit.print_a
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
  pop hl
  ld (sys_chars),hl
  _jp_next

endif

if 0

  ; XXX alternative 2
  ; XXX OLD
  ; the coords get wrong after printing UDGs and scrolling

  pop hl
  push bc

  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message

  ld a,l
  cp 128 ; control or ASCII character?
  jp nc,paren_mode32_emit.print_udg ; is not, jump

  ; use the ROM routine to print a control or ASCII character
  rst 0x10
  pop bc
  _jp_next

paren_mode32_emit.print_udg:
  ; hl = UDG code (128..255)
  sub 128
  ld l,a ; hl = UDG index code (0..127)
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; de = char address in the font
  ld hl,(sys_df_cc) ; current screen address
  ld b,8 ; char scans
paren_mode32_emit.print_udg_scan
  ld a,(de) ; get UDG scan
  ld (hl),a ; put it on the screen
  inc de ; address of next scan of the UDG
  inc h ; address of next pixel row on the screen
  djnz paren_mode32_emit.print_udg_scan

  ; Update
  ld de,(sys_s_posn)
  ld hl,0x1821 ; 0x18 = 24 - row
               ; 0x21 = 33 - column
  sbc hl,de
  ex de,hl
  inc e
  ld a,e
  cp 32 ; last col?
  jp c,paren_mode32_emit.update2 ; if not, jump
  ; last col
  ld e,0
  inc d
  ld a,d
  cp 23 ; last row?
  jp c,paren_mode32_emit.update2 ; if not, jump
  ; last row
  call 0x0DFE ; ROM scroll routine
  ; XXX FIXME wrong coords after the scroll
  ld de, 0x1400

paren_mode32_emit.update2:
  push de
  ld a,d
  and 0x07
  rrca
  rrca
  rrca
  or e
  ld e,a
  ld a,d
  and 0x18
  or 0x40
  ld d,a
  ld (sys_df_cc),de
  pop de
  ld hl,0x1821 ; 0x18 = 24 - row
               ; 0x21 = 33 - column
  sbc hl,de
  ld (sys_s_posn),hl
  pop bc
  _jp_next

endif

if 1

  ; XXX alternative 3

  pop hl
  ; h = 0
  ; l = character code
  push bc

  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message

  ld a,l
  cp 128 ; control or ASCII character?
  jp nc,emit_udg.a ; if not, jump

  ; use the ROM routine to print a control or ASCII character
  rst 0x10
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header emit_udg_,'EMIT-UDG'

; doc{
;
; emit-udg  ( b -- )
;
; Print the User Defined Character _b_ (128..255).
;
; }doc

  ; XXX TODO benchmark, compared to `emit`.

  pop hl
  push bc
  ; h = 0
  ld a,l

emit_udg.a
  ; a = UDG code (128..255)
  ; h = 0
  sub 128
  ld l,a ; hl = UDG index code (0..127)
  ld de,(sys_udg)
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,de
  ex de,hl ; de = char address in the font
  ld bc,(sys_s_posn) ; cursor position
  ld hl,(sys_df_cc) ; current screen address
  call rom_pr_all
  ld (sys_s_posn),bc
  ld (sys_df_cc),hl
  pop bc
  _jp_next

endif

; ----------------------------------------------
  _defer_header emit_,'EMIT',,paren_mode32_emit_

; XXX TODO -- Add multitasker's `pause` when available.

; ----------------------------------------------
  _variable_header printing_,'PRINTING'

; XXX TODO make it a user variable?
; but the open channel would be common!

  dw false

; ----------------------------------------------
  _colon_header printer_,'PRINTER'

; doc{
;
; printer  ( -- )
;
; Select the printer as output.
;
; }doc

  _literal 3
  dw chan_
  dw printing_,on_
  dw exit_

; ----------------------------------------------
  _colon_header display_,'DISPLAY'

; doc{
;
; display  ( -- )
;
; Select the display as output.
;
; }doc

  _literal 2
  dw chan_
  dw printing_,off_
  dw exit_

; ----------------------------------------------
  _variable_header key_translation_table_,'KEY-TRANSLATION-TABLE'

; doc{
;
; key-translation-table  ( -- a )
;
; A variable that holds the address of the current key
; translation table, used by `key`.
;
; The table consists of pairs of characters. The first one is
; the character that has to be translated and the second one is
; its translation. The table is finished with a zero.
;
; The default table makes it possible to access the following
; chars with Symbol Shift: '[', ']', '~', '|', '\', '{' and '}'.
;
; }doc

  dw default_key_translation_table

default_key_translation_table:

;  dw 0 ; no chained table ; XXX TODO
              ; Symbol Shift + Letter --> new char
  db 0xC6,'[' ; "Y" 198 (0xC6) "AND"  --> 091 (0x5B) "["
  db 0xC5,']' ; "U" 197 (0xC5) "OR"   --> 093 (0x5D) "]"
  db 0xE2,'~' ; "A" 226 (0xE2) "STOP" --> 126 (0x7E) "~"
  db 0xC3,'|' ; "S" 195 (0xC3) "NOT"  --> 124 (0x7C) "|"
  db 0xCD,'\' ; "D" 205 (0xCD) "STEP" --> 092 (0x5C) "\"
  db 0xCC,'{' ; "F" 204 (0xCC) "TO"   --> 123 (0x7B) "{"
  db 0xCB,'}' ; "G" 203 (0xCB) "THEN" --> 125 (0x7D) "}"
  db 0 ; end of data

  ; "I" 172 (0xAC) "AT"   --> 127 (0x7F) "(C)" ; XXX TODO

; ----------------------------------------------
  _code_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c1 | c2 )
;
; Translate char _c1_ using the current keyboard decoding table,
; pointed by `key-translation-table`.
;
; }doc

  pop de
  ld a,e
  call translate_char.a
  jp push_a

translate_char.a:
  ld hl,(key_translation_table_pfa)
  dec hl
translate_char.begin:
  inc hl    ; next record of the table
  ld e,(hl) ; char that must be translated, or zero
  inc e     ; is it...
  dec e     ; zero? (=end of table?)
  ret z
  cp e      ; match?
  inc hl    ; point to the char transalation
  jr nz,translate_char.begin ; no match yet, continue
  ; match
  ld a,(hl) ; translate char
  ret

if 0 ; XXX UNDER DEVELOPMENT

  ; improved version with support for chained tables

; ----------------------------------------------
  _colon_header translate_char_,'TRANSLATE-CHAR'

; doc{
;
; translate-char  ( c1 -- c2 )
;
; }doc

  ; XXX TODO

  dw key_translation_table_
  dw fetch_
  dw question_dup_
  dw zero_

translate_char.do_it
  dw cell_plus_
  dw paren_translate_char_
  dw exit_

; ----------------------------------------------
  _code_header paren_translate_char_,'(TRANSLATE-CHAR)'

; doc{
;
; (translate-char)  ( c1 ca -- c1 false | c2 true )
;
; }doc

  pop hl  ; ca
  pop de  ; c1
  push de ; keep c1 on the stack, as default
  dec hl

translate_char.begin:
  inc hl
  ld a,(hl)
  and a ; end of table?
  jp z,false_pfa ; no match found
  cp e
  inc hl
  jr nz,translate_char.begin

  ; match found
  ld e,(hl)
translate_char.end:
  pop hl  ; discard c1
  push de
  jp true_pfa

endif

; ----------------------------------------------
  ; _code_header paren_key_,'(KEY)'

  ; XXX not used yet

  ; ld a,(sys_last_k)
  ; ld (previous_key),a
; paren_key_.begin:
  ; ; call pause ; XXX TODO
  ; ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ; ld a,(sys_last_k)
; previous_key: equ $+1
  ; cp 0 ; a different key?
  ; jp z,paren_key_.begin
  ; ld h,0
  ; ld l,a
  ; xor a
  ; ld (sys_last_k),a ; delete the last key
  ; push hl
  ; jp translate_char_

; ----------------------------------------------
  _code_header key_question_,'KEY?'

; doc{
;
; key?  ( -- wf )
;
; Standard: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

  ; XXX -- This version works only when the system interrupts
  ; are on.

  bit 5,(iy+0x01) ; new key available? (system variable FLAGS)
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _variable_header cursor_char_,'CURSOR-CHAR'

; doc{
;
; cursor-char  ( -- a )
;
; A byte variable that holds the character code of the cursor
; used by `xkey`. Note this is a _byte_ variable, thus it has to
; be fetched with `c@` and modified with `c!`.
;
; }doc

  db 0x5F ; char code

; ----------------------------------------------
  _code_header key_,'KEY'

; doc{
;
; key  ( -- c )
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 1
  call wait_for_a_key
  call translate_char.a ; XXX TODO
  jp push_a
endif

if 0 ; XXX OLD

key.begin:
if 0
  ld a,(sys_last_k)
  and a
else
  bit 5,(iy+0x01) ; system variable FLAGS
endif
  jr z,key.begin
  ld hl,sys_last_k
  ld (hl),0
  jp push_a

endif

if 0 ; XXX OLD

; XXX -- This version works also when the system interrupts are off.
; XXX TODO -- Add multitasker's `pause` when available.

  ; XXX TODO move to the library; rename to `get-key`?

  push bc
key.begin:
  call rom_key_scan
  jr nz,key.begin
  call rom_key_test
  jr nc,key.begin
  dec d
  ld e,a
  call rom_key_decode
key.end:
  ld hl,sys_last_k
  ld (hl),0
  ld ix,next ; XXX TMP
  pop bc
  jp push_a

endif

; ----------------------------------------------
  _code_header xkey_,'XKEY'

; doc{
;
; xkey  ( -- c )
;
; Show a cursor, wait for the next terminal key struck; if it's
; the caps lock key, toggle caps and keep waiting; else leave
; the char code of the key struck.
;
; }doc

  ; XXX TODO rename to `a[ccept]key`, `c[aps]key`, `m[ode]key`?

  push bc

  ; Print cursor:
  ld a,(cursor_char_pfa) ; cursor char code
  rst 0x10
  ld a,backspace_char
  rst 0x10

xkey.new_key:
  call wait_for_a_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,xkey.translate
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a
  jr xkey.new_key

xkey.translate:
  ; Translate some chars
  call translate_char.a ; XXX TMP
  ld l,a
  ld h,0x00

  ; delete the cursor
  ld a,space_char
  rst 0x10
  ld a,backspace_char
  rst 0x10

  pop bc
  jp push_hl

if 0

  ; XXX OLD

wait_for_a_key:
  ; call delete_last_key ; XXX OLD -- not Forth-94
wait_for_a_key.begin:
  ld a,(sys_last_k)
  and a
  jr z,wait_for_a_key.begin
delete_last_key:
  push af
  xor a
  ld (sys_last_k),a
  pop af
  ret

else

  ; XXX NEW
  ; XXX TODO -- change this into a code word
  ; XXX TODO -- make it compatible with the future multitasking

wait_for_a_key:
  bit 5,(iy+1) ; bit 5 of FLAGS?: new key available?
  jr z,wait_for_a_key
  ld a,(sys_last_k)
  res 5,(iy+1) ; no new key available anymore
  ret

endif

; ----------------------------------------------
  _colon_header paren_cr_,'(CR)'

  _literal carriage_return_char
  dw emit_,hash_emit_,off_ ; XXX OLD
  dw exit_

; ----------------------------------------------
  _defer_header cr_,'CR',,paren_cr_

; doc{
;
; cr  ( -- )
;
; Transmit a carriage return to the selected output device.
;
; }doc

; ----------------------------------------------
  _code_header cmove_up_,'CMOVE>'

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header cmove_,'CMOVE'

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'MOVE'

; doc{
;
; move  ( a1 a2 len -- )
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header smove_,'SMOVE'

; doc{
;
; smove  ( ca1 len1 ca2 -- )
;
; Move the string _ca1 len1_ to _ca2_.
;
; This word is the equivalent of the idiom `swap move`, but
; faster.
;
; }doc

; swap move

  exx
  pop de
  pop bc
  jp move.do

; ----------------------------------------------
  _code_header u_m_star_,'UM*'

; doc{
;
; um*  ( u1 u2 -- ud )
;
; Multiply _u1_ by _u2_, giving the unsigned double-cell product
; _ud_.  All values and arithmetic are unsigned.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 1 ; original_u_m_star

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  jp push_hlde

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX TODO version adapted from Z88 CamelForth

  exx
  pop bc      ; u2 in BC
  pop de      ; u1 in DE
  ld hl,0     ; result will be in HLDE
  ld a,17     ; loop counter
  or a        ; clear cy
u_m_star.do:
  rr h
  rr l
  rr d
  rr e
  jp nc,u_m_star.noadd
  add hl,bc
u_m_star.noadd:
  dec a
  jp nz,u_m_star.do
  push de     ; lo result
  push hl     ; hi result
  exx
  _jp_next

endif

if 0 ; XXX OLD -- slower than the DZX-Forth code

  ; XXX -- adapted from hForth

  exx
  pop bc          ; BC = u2
  pop de          ; DE = u1
  ld  hl,0x0000
  ld  a,0x10
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jp  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jp  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jp  nz,u_m_star.1
u_m_star.4:
  push hl
  push de
  exx
  _jp_next

endif

if 0 ; XXX OLD

  ; XXX -- Original version from hForth

  ; SP: data stack pointer
  ; IX: return stack pointer
  ; DE: Forth virtual machine instruction pointer
  ; BC: top of data stack item

                ; BC = u2, TOS = u1
  ex  de,hl     ; HL = IP, DE = ?
  ex  (sp),hl   ; TOS = IP,  HL = u1
  ex  de,hl     ; DE = u1, HL = ?
  ld  hl,0
  ld  a,010h
u_m_star.1:
  add  hl,hl
  ex  de,hl
  adc  hl,hl
  ex  de,hl
  jr  nc,u_m_star.3
u_m_star.2:
  add  hl,bc
  jr  nc,u_m_star.3
u_m_star.5:
  inc  de
u_m_star.3:
  dec  a
  jr  nz,u_m_star.1
u_m_star.4:
  ld  b,d
  ld  c,e
  ex  (sp),hl
  ; $nexthl

endif

; ----------------------------------------------
  _code_header u_m_slash_mod_,'UM/MOD'

; doc{
;
; um/mod ( ud u1 -- u2 u3 )
;
; Divide _ud_ by _u1_, giving the quotient _u3_ and the
; remainder _u2_.  All values and arithmetic are unsigned.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ; Credits:
  ;
  ; Code adapted from Z88 CamelForth.

  exx
  pop bc      ; BC = divisor
  pop hl      ; HLDE = dividend
  pop de
  ld a,16     ; loop counter
  sla e
  rl d        ; hi bit DE -> carry
u_m_slash_mod.do:
  adc hl,hl   ; rot left w/ carry
  jr nc,u_m_slash_mod.3
  ; case 1: 17 bit, cy:HL = 1xxxx
  or a        ; we know we can subtract
  sbc hl,bc
  or a        ; clear cy to indicate sub ok
  jr u_m_slash_mod.4
  ; case 2: 16 bit, cy:HL = 0xxxx
u_m_slash_mod.3:
  sbc hl,bc   ; try the subtract
  jr nc,u_m_slash_mod.4 ; if no cy, subtract ok
  add hl,bc   ; else cancel the subtract
  scf         ;   and set cy to indicate
u_m_slash_mod.4:
  rl e        ; rotate result bit into DE,
  rl d        ; and next bit of DE into cy
  dec a
  jr nz,u_m_slash_mod.do
  ; now have complemented quotient in DE,
  ; and remainder in HL
  ld a,d
  cpl
  ld b,a
  ld a,e
  cpl
  ld c,a
  push hl     ; remainder
  push bc     ; quotient
  exx
  _jp_next

; ----------------------------------------------
  _code_header and_,'AND'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header or_,'OR'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header xor_,'XOR'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _constant_header slash_user_,'/USER'

; doc{
;
; /user  ( -- n )
;
; Constant, the length of the user variables.
;
; }doc

  dw bytes_per_user_variables

; ----------------------------------------------
  _constant_header up_,'UP'

; doc{
;
; up  ( -- a )
;
; Constant, the address of the user area pointer.
;
; Standard: fig-Forth.
;
; }doc

  dw user_variables_pointer

; ----------------------------------------------
  _constant_header up0_,'UP0'

; doc{
;
; up0  ( -- a )
;
; Constant, the default address of the user area.
;
; }doc

  dw user_variables

; ----------------------------------------------
  _constant_header np_,'NP'

; doc{
;
; np  ( -- a )
;
; Address of the names pointer.
;
; }doc

  dw names_pointer

; ----------------------------------------------
  _constant_header np0_,'NP0'

  dw names_bank_address

; ----------------------------------------------
  _code_header np_fetch_,'NP@'

; doc{
;
; np@  ( -- a )
;
; Fetch the content of the names pointer.
;
; }doc

  ld hl,(names_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header np_store_,'NP!'

  pop hl
  ld (names_pointer),hl
  _jp_next

; ----------------------------------------------

  _colon_header comma_np_,',NP'

; doc{
;
; ,np  ( x -- )
;
; Store _x_ into the next available names memory cell, advancing
; the names pointer.
;
; Note: The names memory is supposed to be paged in.
;
; }doc

  dw np_fetch_,store_,two_,np_,plus_store_
  dw exit_

; ----------------------------------------------
  _code_header sp_fetch_,'SP@'

; doc{
;
; sp@  ( -- a )
;
; Fetch the content of the stack pointer.
;
; }doc

  ld hl,0x0000
  add hl,sp
  jp push_hl

; ----------------------------------------------
  _code_header sp_store_,'SP!'

; doc{
;
; sp!  ( a -- )
;
; Store _a_ into the stack pointer.
;
; }doc

  pop hl
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'RP'

  ; XXX TODO -- convert to user variable

; doc{
;
; rp  ( -- a )
;
; Address of the return stack pointer.
;
; }doc

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP@'

; doc{
;
; rp@  ( -- a )
;
; Fetch the content of the return stack pointer.
;
; }doc

  ld hl,(return_stack_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header rp_store_,'RP!'

; doc{
;
; rp!  ( a -- )
;
; Store _a_ into the return stack pointer.
;
; }doc

  pop hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header pick_,'PICK'

; doc{
;
; pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
;
; }doc

  ; XXX TODO move to the library, use `fetchhl`.
  ; but maybe `acceptx` needs `pick`.

  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

; ----------------------------------------------
  _code_alias_header unloop_,'UNLOOP',,two_r_drop_

; doc{
;
; unloop  ( -- ) ( R: loop-sys -- )
;
; Discard the loop-control parameters for the current nesting
; level. An `unloop` is required for each nesting level before
; the definition may be exited with `exit`. An ambiguous
; condition exists if the loop-control parameters are
; unavailable.
;
; In Solo Forth, the stack effect is:
;
; unloop  ( -- ) ( R: n1 n2 -- )
;
;   n1 = loop index
;   n2 = loop limit
;
; Standard: Forth-94.
;
; }doc

; ----------------------------------------------
  _code_header to_r_,'>R'

; doc{
;
; >r  ( x -- ) ( R: -- x )
;
; }doc

  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R>'

; doc{
;
; r>  ( -- x ) ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header two_r_drop_,'2RDROP'

; doc{
;
; 2rdrop  ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDROP'

; doc{
;
; rdrop  ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>R'

; doc{
;
; 2>r  ( x1 x2 -- ) ( R: -- x1 x2 )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2R>'

; 2r>  ( -- x1 x2 ) ( R: x1 x2 -- )

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_pfa

; ----------------------------------------------
  _code_header two_r_fetch_,'2R@'

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R@'

  ld hl,(return_stack_pointer)
  jp fetch.hl

; ----------------------------------------------
  _code_header zero_equals_,'0='

  pop hl
zero_equals.hl:
  ld a,l
  or h
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

  pop hl
  ld a,l
  or h
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization
    add hl,hl ; 11t, 1 byte
  else
    ; Credits:
    ; Idea from Ace Forth.
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  ld hl,0
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header plus_,'+'

  pop de
  pop hl
  add hl,de
  jp push_hl

; ----------------------------------------------
  _code_header d_plus_,'D+'

; doc{
;
; d+  ( d1|ud1 d2|ud2 -- d3|ud3 )
;
; Add _d2|ud2_ to _d1|ud1_, giving the sum _d3|ud3_.
;
; }doc

  ; Credits:
  ; Code adapted from Z88 CamelForth.

                        ;  t  B
                        ;  -- --
  pop de                ;  10 01 ; DE=d2hi
  exx                   ;  04 01
  pop de                ;  10 01 ; DE'=d2lo
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL=d1hi,DE=d2hi
  exx                   ;  04 01
  pop hl                ;  10 01 ; HL'=d1lo
  add hl,de             ;  11 01
  push hl               ;  11 01 ; 2OS=d1lo+d2lo
  exx                   ;  04 01
  adc hl,de             ;  15 02 ; HL=d1hi+d2hi+cy
  push hl               ;  11 01
  _jp_next              ;  08 02
                        ;  -- --
                        ; 112 15 TOTALS

; ----------------------------------------------
  _code_header invert_,'INVERT'

; doc{
;
; invert  ( x1 -- x2 )
;
; Invert all bits of _x1_ giving its logical inverse _x2_.
;
; }doc

  ; Credits:
  ; Code adapted from Z88 CamelForth.

  pop hl
  ld a,h
  cpl
  ld h,a
  ld a,l
  cpl
  ld l,a
  jp push_hl

; ----------------------------------------------
  _code_header negate_,'NEGATE'

; doc{
;
; negate  ( n1 -- n2 )
;
; Negate _n1_, giving its arithmetic inverse _n2_.
;
; Standard: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop de
                ; t  B
  ld hl,0x0000  ; 10 03
  and a         ; 04 01
  sbc hl,de     ; 15 02
                ; 29 06 total
  jp push_hl

; ----------------------------------------------
  _code_header d_negate_,'DNEGATE'

; doc{
;
; dnegate  ( d1 -- d2 )
;
; Negate _d1_, giving its arithmetic inverse _d2_.
;
; Standard: Forth-79 (Required word set), Forth-83 (Required
; word set), Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

if 0

  ; Credits:
  ; Code from Abersoft Forth, also found in White Lightning.

  ; XXX TODO optimize?

                                                ; T   B
                                                ; --- --
  pop hl      ; high part                       ;  10 01
  pop de      ; low part                        ;  10 01
  sub a       ; zero                            ;  04 01
  sub e       ; two's complement to carry       ;  04 01
  ld e,a                                        ;  04 01
  ld a,0x00                                     ;  07 02
  sbc a,d     ; two's complement with carry     ;  04 01
  ld d,a                                        ;  04 01
  ld a,0x00                                     ;  07 02
  sbc a,l     ; two's complement with carry     ;  04 01
  ld l,a                                        ;  04 01
  ld a,0x00                                     ;  07 02
  sbc a,h     ; two's complement with carry     ;  04 01
  ld h,a                                        ;  04 01
  jp push_hlde                                  ;  10 03
                                                ;  11 00 push de
                                                ;  11 00 push hl
                                                ; --- --
                                                ; 109 20

else

  ; Credits:
  ; Code from Spectrum Forth-83.
  ;
  ; Comparison to the Abersoft Forth version:
  ; Speed: 1.04
  ; Size:  -1

                                                ; T   B
                                                ; --- --
  pop     hl        ; high part                 ;  10 01
  pop     de        ; low part                  ;  10 01
  push    hl        ; save copy                 ;  11 01
  ld      hl,0x0000                             ;  10 03
  and     a                                     ;  04 01
  sbc     hl,de     ; hl = negated low part     ;  15 02
  pop     de        ; high part                 ;  10 01
  push    hl        ; negated low part          ;  11 01
  ld      hl,0x0000                             ;  10 03
  sbc     hl,de     ; hl = negated high part    ;  15 02
  jp push_hl                                    ;  10 03
                                                ;  11 00 push hl
                                                ; --- --
                                                ; 127 19

endif

; ----------------------------------------------
  _code_header nip_,'NIP'

  pop hl
  pop de
  jp push_hl

; ----------------------------------------------
  _code_header tuck_,'TUCK'

  pop hl
  pop de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header over_,'OVER'

  pop de
  pop hl
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header drop_,'DROP'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWAP'

  pop hl
  ex (sp),hl
  jp push_hl

; ----------------------------------------------
  _code_header dup_,'DUP'

  pop hl
  push hl
  jp push_hl

; ----------------------------------------------
  _code_header two_dup_,'2DUP'

  pop hl
  pop de
  push de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header plus_store_,'+!'

; doc{
;
; +!  ( n|u a -- )
;
; Add _n|u_ to the single-cell number at _a_.
;
; Standard: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OFF'

; doc{
;
; off  ( a -- )
;
; Store _false_ at _a_.
;
; }doc

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'ON'

; doc{
;
; on  ( a -- )
;
; Store _true_ at _a_.
;
; }doc

  pop hl
  ld (hl),0xFF
  inc hl
  ld (hl),0xFF
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_test_bits_question_,'C@TEST-BITS?'

; doc{
;
; c!test-bits?  ( b ca -- wf )
;
; Test the bits at _ca_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  and (hl)
  jp nz,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header c_store_set_bits_,'C!SET-BITS'

; doc{
;
; c!set-bits  ( b ca -- )
;
; Set the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  or (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header c_store_reset_bits_,'C!RESET-BITS'

; doc{
;
; c!reset-bits  ( b ca -- )
;
; Reset the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,e
  cpl
  and (hl)
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header fetch_,'@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_,'C@'

  pop hl
c_fetch.hl:
  ld l,(hl)
  ld h,0x00
  jp push_hl

; ----------------------------------------------
  _code_header two_fetch_,'2@'

  pop hl ; address
two_fetch.hl:
  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1 ; de = low part
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1 ; hl = high part
  ex de,hl      ; 04t  1
  jp push_hlde  ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL

; ----------------------------------------------
  _code_header two_store_,'2!'

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _colon_header colon_,':'

  ; XXX TODO -- `(:)` or `DOCOLON` constants to access
  ; `do_colon`.

  dw store_csp_
  dw header_,right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
do_colon.end: ; XXX TMP for debugging
  _jp_next

; ----------------------------------------------
  _variable_header noname_question_,'NONAME?'

; doc{
;
; noname?  ( -- a )
;
; A variable that holds a flag: was the word being defined
; created by `:noname`? This flag is set by `:noname` and reset
; by `;`.
;
; }doc

; Credits:
; The idea for this variable was taken from hForth.

  dw false

; ----------------------------------------------
  _colon_header colon_no_name_,':NONAME',immediate


; doc{
;
; :noname  ( -- cfa )
;
; Standard: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; ----
; }doc


  ; Credits:
  ; Code from the Afera library.

  ; XXX TODO move to the library?
  ; first `do_colon` must be defined as a constant

  dw here_ ; cfa
  dw store_csp_
  dw lit_,do_colon,comma_ ; create the code field
  dw noname_question_,on_
  dw right_bracket_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate+compile_only

; doc{
;
; ;  ( -- )
;
; ----
; : ;  ( -- )
;   ?csp
;   postpone ;s  postpone [
;   noname? @  noname? off  ?exit
;   reveal  ;
; }doc

  dw question_csp_
  dw compile_,exit_
  dw left_bracket_
  dw noname_question_,fetch_
  dw noname_question_,off_
  dw question_exit_
  dw reveal_
  dw exit_

; ----------------------------------------------
  _header noop_,'NOOP'

; doc{
;
; noop  ( -- )
;
; }doc

  dw next ; code field

; ----------------------------------------------
  _colon_header c_constant_,'CCONSTANT'

  dw create_,c_comma_
  dw paren_semicolon_code_
do_c_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp c_fetch.hl

; ----------------------------------------------
  _colon_header constant_,'CONSTANT'

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp fetch.hl

; ----------------------------------------------
  _colon_header variable_,'VARIABLE'

; doc{
;
; variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve one cell of data
; space.
;
;    _name_ is referred to as a variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the reserved cell. A program is
;    responsible for initializing the contents of the reserved
;    cell.
;
; Standard: Forth-94.
;
; }doc

  ; XXX TODO `create 0 comma` ?

  dw create_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header user_,'USER'

if 0 ; old_user

; doc{
;
; user  ( +n "name" -- )
;
; Create a user variable _name_.  _+n_ is the offset within the
; user area where the value for _name_ is stored.  Execution of
; _name_ leaves its absolute user area storage address.
;
; Standard: fig-Forth, Forth-79, Forth-83.
;
; }doc

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00   ; de = index of the user variable
  ld hl,(user_variables_pointer)
  add hl,de   ; hl= address of the user variable
  jp push_hl

else

; doc{
;
; user  ( "name" -- )
;
; Create a user variable _name_ in the first available offset
; within the user area.  Execution of _name_ leaves its absolute
; user area storage address.
;
; }doc

  ; XXX UNDER DEVELOPMENT
  ; XXX TODO

  dw c_constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00   ; de = index of the user variable
  ld hl,(user_variables_pointer)
  add hl,de   ; hl= address of the user variable
  jp push_hl

endif

; ----------------------------------------------
if 0 ; old_user
else

  _colon_header uallot_,'UALLOT'

; doc{
;
; uallot  ( n -- )
;
; If _n_ is greater than zero, reserve _n_ address units of user
; data space. If _n_ is less than zero, release _n_ address
; units of user data space. If _n_ is zero, leave the user
; data-space pointer unchanged.
;
; ----
; : uallot  ( n -- )
;   udp +!  ;
; ----
;
; }doc

  dw udp_,plus_store_
  dw exit_

endif

; ----------------------------------------------
  _c_constant_header zero_,'0'

  db 0x00

; ----------------------------------------------
  _c_constant_header one_,'1'

  db 0x01

; ----------------------------------------------
  _c_constant_header two_,'2'

  db 0x02

; ----------------------------------------------
  _code_header false_,'FALSE'

; doc{
;
; false  ( -- false )
;
; }doc

  ld hl,false
  jp push_hl

; ----------------------------------------------
  _code_header true_,'TRUE'

; doc{
;
; true  ( -- true )
;
; }doc

  ld hl,true
  jp push_hl

; ----------------------------------------------
  _c_constant_header b_l_,'BL'

; doc{
;
; bl  ( -- b )
;
; }doc

  db space_char

; ----------------------------------------------
  _c_constant_header c_slash_l_,'C/L'

  db characters_per_line

; ----------------------------------------------
  _c_constant_header l_slash_scr_,'L/SCR'

  db lines_per_screen

; ----------------------------------------------
  _constant_header disk_buffer_,'DISK-BUFFER'

  dw disk_buffer

; ----------------------------------------------
  _constant_header buffer_data_,'BUFFER-DATA'

  dw disk_buffer+cell

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BUF'

  dw bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_rec_,'B/REC'

  ; XXX TODO -- remove? used only once, and may be harcoded

  dw bytes_per_sector

; ----------------------------------------------
  _c_constant_header rec_slash_blk_,'REC/BLK'

  db sectors_per_block

; ----------------------------------------------
  _constant_header blk_slash_disk_,'BLK/DISK'

  dw blocks_per_disk

; ----------------------------------------------
  _c_constant_header hash_vocs_,'#VOCS'

  db max_search_order

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGIN'

; doc{
;
; +origin  ( n -- a )
;
; Leave the memory address relative by _n_ to the origin
; parameter area.  _n_ is the minimum address unit, either byte
; or word.  This definition is used to access or modify the
; boot-up parameters at the origin area.
;
; Standard: fig-Forth.
;
; }doc

  dw lit_,origin,plus_
  dw exit_

; ----------------------------------------------
  _user_variable_header sp0_,'SP0'

; doc{
;
; sp0  ( -- a )
;
; User variable that holds the address of the bottom of the data
; stack.
;
; Note: In fig-Forth, Forth-79 and Forth-83 it's called `S0`.
;
; }doc

  db 0x00

; ----------------------------------------------
  _user_variable_header rp0_,'RP0'

; doc{
;
; rp0  ( -- a )
;
; User variable that holds the address of the bottom of the
; return stack.
;
; Note: In fig-Forth it's called `R0`.
;
; }doc

  db 0x02

; ----------------------------------------------
  _user_variable_header paren_wait_,'(WAIT)'

; XXX TMP -- from Spectrum Forth-83.

; doc{
;
; (wait)  ( -- a )
;
; User variable that holds the cfa of a word to be executed by
; some words that accept user input, during multitasking.
;
; }doc

  db 0x04

; ----------------------------------------------
  _user_variable_header width_,'WIDTH'

  ; XXX TODO normal variable?

; doc{
;
; width  ( -- a )
;
; User variable that holds the maximum number of letters saved
; in the compilation of a definitions' name. It must be 1 thru
; 31, with a default value of 31. The name character count and
; its natural characters are saved, up to the value in `width`.
; The value may be changed at any time within the above limits.
;
; Standard: fig-Forth.
;
; }doc

  db 0x06

; ----------------------------------------------
  _user_variable_header warnings_,'WARNINGS'

; doc{
;
; warnings  ( -- a )
;
; User variable that holds a flag. If it's zero, no warning is
; shown when a compiled word is not unique in the `current`
; vocabulary.
;
; }doc

  db 0x08

; XXX OLD
; ; ----------------------------------------------
;   _user_variable_header msg_scr_,'MSG-SCR'

; ; doc{
; ;
; ; msg-scr  ( -- a )
; ;
; ; User variable that holds the screen number where the error
; ; messages start, or zero. If it's zero, only the message number
; ; will be shown.
; ;
; ; }doc

;   db 0x0A

; ----------------------------------------------
  _user_variable_header dp_,'DP'

; doc{
;
; dp  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x0C

; ----------------------------------------------
  _user_variable_header udp_,'UDP'

; doc{
;
; udp  ( -- a )
;
; User variable that holds an offset from the start of the
; current user area to the free space in it.
;
; }doc

  db 0x0E

; ----------------------------------------------
  _user_variable_header blk_,'BLK'

  ; XXX TODO normal variable?

; doc{
;
; blk  ( -- a )
;
; User variable that holds de number of the disk block being
; interpreted. A disk block holds 1024 bytes. One source screen
; consists of one disk block.
;
; }doc

  db 0x10

; ----------------------------------------------
  _user_variable_header to_in_,'>IN'

  ; XXX TODO normal variable?

; doc{
;
; >in  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x12

; ----------------------------------------------
  _user_variable_header hash_emit_,'#EMIT'

; doc{
;
; #emit  ( -- a )
;
; User variable that contains a value incremented by `emit`
; and reseted by `cr`. The user may alter and examine `#emit` to
; control display formating.
;
; Note: In fig-Forth it's called `out`; in Forth-83 it's called
; `#out`.
;
; }doc

  db 0x14

; ----------------------------------------------
  _user_variable_header scr_,'SCR'

; XXX TODO normal variable?

; doc{
;
; scr  ( -- a )
;
; User variable that holds the screen number of the screen most
; recently listed (with `list`) or loaded (with `load` or
; `continued`). This is the value used by `reload`.
;
; }doc

  db 0x16

; ----------------------------------------------
  _user_variable_header catcher_,'CATCHER'

; doc{
;
; catcher  ( -- a )
;
; A user variable that holds the return stack pointer for error
; handling. Used by `throw`.
;
; }doc

  db 0x18

; ----------------------------------------------
  _user_variable_header hld_,'HLD'

; doc{
;
; hld  ( -- a )
;
; A user variable that holds the address of the latest character of
; text during numeric output conversion.
;
; Standard: fig-Forth.
;
; }doc

  db 0x1A

; ----------------------------------------------
  _user_variable_header current_,'CURRENT'

; doc{
;
; current  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x1C

; ----------------------------------------------
  _user_variable_header state_,'STATE'

; doc{
;
; state  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x1E

; ----------------------------------------------
  _user_variable_header base_,'BASE'

; doc{
;
; base  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x20

; ----------------------------------------------
  _user_variable_header dpl_,'DPL'

; doc{
;
; dpl  ( -- a )
;
; User variable that holds XXX TODO
;
; }doc

  db 0x22

; ----------------------------------------------
  _user_variable_header csp_,'CSP'

  ; XXX TODO ordinary variable?

; doc{
;
; csp  ( -- a )
;
; User variable that holds the current data stack position saved
; by `!csp`.
;
; Standard: fig-Forth.
;
; }doc

  db 0x24

; ----------------------------------------------
  _user_variable_header context_,'CONTEXT'

; doc{
;
; context  ( -- a )
;
; User variable that holds... XXX TODO
;
; }doc

  db 0x26

; ----------------------------------------------
  _variable_header voc_link_,'VOC-LINK'

  ; XXX TODO -- this is used only by `.vocs`. use a brute search
  ; instead in `.vocs` and remove this?

if 1 ; assembler_core_in_kernel
  dw assembler_vocabulary_link ; link to the latest vocabulary defined
else
  dw forth_vocabulary_link ; link to the latest vocabulary defined
endif

; ----------------------------------------------
  _constant_header tib_,'TIB'

; doc{
;
; tib  ( -- ca )
;
; Address of the terminal input buffer.
;
; Standard: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT).
;
; }doc

  dw terminal_input_buffer


; ----------------------------------------------
  _c_constant_header slash_tib_,'/TIB'

; doc{
;
; /tib  ( -- n )
;
; Maximum size of the terminal input buffer.
;
; See `tib` and `#tib`.
;
; }doc

  db bytes_per_terminal_input_buffer

; ----------------------------------------------
  _variable_header number_tib_,'#TIB'

; doc{
;
; #tib  ( -- a )
;
; _a_ is the address of a cell containing the number of
; characters in the terminal input buffer.
; 
; Standard: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT).
;
; }doc

  dw bytes_per_terminal_input_buffer

; ----------------------------------------------
  _two_variable_header input_buffer_,'INPUT-BUFFER'

; doc{
;
; input-buffer  ( -- a )
;
; A double-cell variable that holds the address and length of
; the current input buffer.
;
; }doc

  dw 0 ; len
  dw 0 ; address

; ----------------------------------------------
  _colon_header source_,'SOURCE'

; doc{
;
; source  ( -- ca len )
;
; ----
; : source  ( -- ca len )
;   blk @ ?dup if  block b/buf exit  then
;   input-buffer 2@  ;
; ----
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw blk_,fetch_,question_dup_
  dw zero_branch_,source.other
  ; disk block
  dw block_,b_slash_buf_,exit_
source.other:
  dw input_buffer_,two_fetch_
  dw exit_

; ----------------------------------------------
  _colon_header recurse_,'RECURSE',immediate+compile_only

; doc{
;
; recurse  ( -- )
;
; Standard: Forth-94.
;
; }doc

  dw latest_,from_name_,compile_comma_
  dw exit_

; ----------------------------------------------
  _code_header one_plus_,'1+'

  pop hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_header two_plus_,'2+'

  pop hl
  inc hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cell_minus_,'CELL-',,two_minus_

; ----------------------------------------------
  _code_alias_header cell_plus_,'CELL+',,two_plus_

; ----------------------------------------------
  _code_alias_header char_minus_,'CHAR-',,one_minus_

; ----------------------------------------------
  _code_alias_header char_plus_,'CHAR+',,one_plus_

; ----------------------------------------------
  _code_header one_minus_,'1-'

  pop hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_minus_,'2-'

  pop hl
  dec hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2*  ( x1 -- x2 )
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; This is the same as `1 lshift`.
;
; Standard: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; }doc

  ; Credits:
  ; Code from DZX-Forth.
  ; Documentation partly based on lina.

  pop hl
  add hl,hl
  jp push_hl

; ----------------------------------------------

; XXX TODO
;  _raw_code_alias_header chars_,'CHARS',immediate,noop_

  _code_header chars_,'CHARS',immediate

; doc{
;
; chars  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ characters.
;
; In Solo Forth, this word does nothing.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  _jp_next

; ----------------------------------------------
  _code_alias_header cells_,'CELLS',,two_star_

; doc{
;
; cells  ( n1 -- n2 )
;
; _n2_ is the size in address units of _n1_ cells.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

; ----------------------------------------------
  _c_constant_header cell_,'CELL'

  db cell

; ----------------------------------------------
  _colon_header here_,'HERE'

  dw dp_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header allot_,'ALLOT'

; doc{
;
; allot  ( n -- )
;
; If _n_ is greater than zero, reserve _n_ address units of
; data space. If _n_ is less than zero, release _n_ address
; units of user space. If _n_ is zero, leave the data-space
; pointer unchanged.
;
; ----
; : allot  ( n -- )
;   dp +!  ;
; ----
;
; }doc

  dw dp_,plus_store_
  dw exit_

  ; Alternative non-standard definition:
  ; http://dxforth.netbay.com.au/allot.html

; ----------------------------------------------
  _colon_header s_comma_,'S,'

; doc{
;
; s,  ( ca len -- )
;
; Compile a string.
;
; ----
; : s,  ( ca len -- )
;   dup c, tuck here swap cmove allot  ;
; ----
;
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,cmove_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header two_comma_,'2,'

if size_optimization

  dw comma_,comma_
  dw exit_

else

  dw here_,two_store_
two_comma.allot:
  _literal 2*cell
  dw allot_
  dw exit_

endif

; ----------------------------------------------
  _colon_header comma_,','

  dw here_,store_,cell_,allot_
  dw exit_

; ----------------------------------------------
  _colon_header compile_comma_,'COMPILE,'

; doc{
;
; compile,  ( cfa -- )
;
; }doc

  ; XXX TODO alias

  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header c_comma_,'C,'

  dw here_,c_store_,one_,allot_
  dw exit_

; ----------------------------------------------
  _code_header minus_,'-'

  pop de
  pop hl
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header not_equals_,'<>'

  pop de
  pop hl
  _compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header equals_,'='

  pop de
  pop hl
  _compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header less_than_,'<'

  pop de
  pop hl
is_de_less_than_hl:
  call compare_de_hl_signed
  if size_optimization
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

if 0

  ; XXX TODO
  ;
  ; Code adapted from Z88 CamelForth

  pop de
  pop hl
  or a
  sbc hl,de       ; n1-n2 in HL, SZVC valid

  ; negative & not OV:  HL<DE
  ; negative & OV:      HL +ve, DE -ve, result -ve, so HL>DE
  ; positive & not OV:  HL>=DE
  ; positive & OV:      HL -ve, DE +ve, result +ve, so HL<DE
  ; thus OV reverses the sense of the sign bit

  jp pe,less_than.reverse  ; if OV, jump
  ; not overflow
  jp p,false_pfa    ; if +ve, result false
  jp true_pfa       ; if -ve, result true

less_than.reverse
  ; overflow
  jp m,false_pfa    ; if -ve, result false
  jp true_pfa       ; if +ve, result true

endif

; ----------------------------------------------
  _code_header u_greater_than_,'U>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U<'

if 0 ; XXX OLD -- code adapted from DZX-Forth

  pop de
  pop hl
u_less_than.de_hl:
  _compare_de_hl_unsigned
  if size_optimization
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

else ; XXX NEW -- code adapted from Z88 CamelForth

  ; XXX TODO benchmark

  pop de
  pop hl
u_less_than.de_hl:
  _compare_de_hl_unsigned
  sbc a,a         ; propagate carry flag through A
  ld h,a
  ld l,a          ; HL = 0x0000 or 0xFFFF
  jp push_hl

endif

; ----------------------------------------------
  _code_header greater_than_,'>'

  pop hl
  pop de
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header rot_,'ROT'

  pop de
  pop hl
  ex (sp),hl
  jp push_hlde

; ----------------------------------------------
  _colon_header space_,'SPACE'

  dw b_l_,emit_
  dw exit_

; ----------------------------------------------
  _colon_header question_dup_,'?DUP'

  dw dup_
  dw zero_branch_,question_dup.end
  dw dup_
question_dup.end:
  dw exit_

; ----------------------------------------------
  _colon_header latest_,'LATEST'

; doc{
;
; latest ( -- nfa )
;
; Leave the name field address of the topmost word in the
; `current` vocabulary.
;
; Standard: Forth-94.
;
; }doc

  dw get_current_,fetch_
  dw exit_

; ----------------------------------------------
  _code_alias_header from_body_,'BODY>',,two_minus_

; ----------------------------------------------
  _code_alias_header to_body_,'>BODY',,two_plus_

; ----------------------------------------------
  _code_header to_name_,'>NAME'

; doc{
;
; >name  ( cfa -- nfa )
; >name  ( cfa -- nfa | 0 ) \ XXX TODO
;
; Warning: No check is done wether cfa belongs to a definition
; created with `:noname`; if so, the name assoctiated to _nfa_,
; returned by `name>string`, will be empty.
;
; }doc

  ; XXX FIXME -- make it return 0 if cfa has no name associated

  call bank.names ; page the memory bank in

  pop de ; cfa
;  ld (to_name.cfa),de ; save cfa for later ; XXX OLD

  ld a,(np_pfa) ; low byte of the names pointer
  ld (to_name.names_pointer_low_byte),a ; save it for later
  ld a,(np_pfa+1) ; hight byte of the names pointer
  ld (to_name.names_pointer_high_byte),a ; save it for later

  push bc ; save Forth IP
  ld b,0
  ld hl, names_bank_address-4

to_name.begin_0:
  ; hl = address of the cfa pointer

  ; XXX NEW -- compare hl with  np: if equals, exit
  ; XXX FIXME -- not working yet
  ; XXX TODO use the Fuse's debugger

  ; compare the cfa pointer with the names pointer
  ; if they are equals, there are no more names to check
to_name.names_pointer_high_byte equ $+1
  ld a,0
  cp h
  jr nz,to_name.names_not_finished
to_name.names_pointer_low_byte equ $+1
  ld a,0
  cp l
  jr nz,to_name.names_not_finished
  ; more names left, not found!
  ld hl,0
  jr to_name.end

to_name.names_not_finished:
  inc hl
to_name.begin_1:
  inc hl ; hl = lfa
  inc hl
  inc hl ; hl = nfa
  ld a,(hl) ; name field byte length
  and word_length_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  add hl,bc ; point to the cfa pointer of the next word

; XXX OLD
; to_name.cfa equ $+1
;  ld de,0 ; cfa searched for

  ld a,(hl) ; low byte of cfa
  cp e ; equal?
  jr nz,to_name.begin_0 ; not equal
  inc hl
  ld a,(hl) ; high byte of cfa
  cp d ; equal?
  jr nz,to_name.begin_1 ; not equal

  ; cfa found
  inc hl
  inc hl
  inc hl ; nfa

to_name.end:
  call bank.default ; page the default memory bank
  pop bc ; restore Forth IP
  jp push_hl

; ----------------------------------------------

  _colon_header c_store_bank_,'C!BANK'

; doc{
;
; c!bank  ( b a n -- )
;
; Store _b_ into address _a_ of bank _n_.
;
; }doc

  dw bank_,c_store_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; c_store_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; call bank.default
  ; jp pushhl

; ----------------------------------------------
  _colon_header store_bank_,'!BANK'

; doc{
;
; !bank  ( x a n -- )
;
; Store _x_ into address _a_ of bank _n_.
;
; }doc

  dw bank_,store_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header c_fetch_bank_,'C@BANK'

; doc{
;
; c@bank  ( a n -- b )
;
; Fetch the 8-bit content of address _a_ of the bank _n_.
;
; }doc

  dw bank_,c_fetch_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; c_fetch_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; call bank.default
  ; jp pushhl

; ----------------------------------------------
  _colon_header fetch_bank_,'@BANK'

; doc{
;
; @bank  ( a n -- x )
;
; Fetch the 16-bit content of address _a_ of bank _n_.
;
; }doc

  dw bank_,fetch_,default_bank_
  dw exit_

  ; XXX TODO -- faster version:
  ; pop de
  ; fetch_bank.e
  ; call bank.e
  ; pop hl
  ; ld a,(hl)
  ; inc hl
  ; ld h,(hl)
  ; ld l,a
  ; call bank.default
  ; jp pushhl

; ----------------------------------------------
  _colon_header c_fetch_n_,'C@N'

; doc{
;
; c@n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw c_fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,names_bank
  ; jp c_fetch_bank.e

; ----------------------------------------------
  _colon_header fetch_n_,'@N'

; doc{
;
; @n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw fetch_bank_
  dw exit_

  ; XXX TODO -- 5 bytes -- faster version:
  ; ld e,names_bank
  ; jp fetch_bank.e

; ----------------------------------------------
  _colon_header c_store_n_,'C!N'

; doc{
;
; c!n  ( c a -- )
;
; Store _c_ into the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw c_store_bank_
  dw exit_

; ----------------------------------------------
  _colon_header store_n_,'!N'

; doc{
;
; !n  ( x a -- )
;
; Store _x_ into the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw store_bank_
  dw exit_

; ----------------------------------------------
  _colon_header from_name_,'NAME>'

; doc{
;
; name>  ( nfa -- cfa )
;
; }doc

  _literal 4
  dw minus_,fetch_n_
  dw exit_

; ----------------------------------------------
; doc{
;
; name>string  ( nfa -- ca len )
;
; }doc

  _colon_header name_to_string_,'NAME>STRING'

  dw names_bank_
  dw count_
  _literal word_length_mask
  dw and_
  dw save_string_
  dw default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header store_csp_,'!CSP'

; doc{
;
; !csp  ( -- )
;
; Save the the current data stack position.
;
; Standard: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,store_
  dw exit_

; ----------------------------------------------
  _colon_header question_throw_,'?THROW'

; doc{
;
; ?throw  ( f n -- )
;
; Perform a `throw` of value _n_ if the boolean flag _f_ is
; non-zero.
;
; ----
; : ?throw  ( f n -- )
;   swap if  throw  else  drop  then  ;
; ----
;
; }doc

  dw swap_
  dw question_branch_,throw_pfa
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header compiling_question_,'COMPILING?'

; doc{
;
; compiling?  ( -- wf )
;
; ----
; : compiling?  ( -- wf )
;   state @ 0<>  ;
; ----
;
; }doc

  dw state_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header executing_question_,'EXECUTING?'

; doc{
;
; executing?  ( -- wf )
;
; ----
; : executing?  ( -- wf )
;   state @ 0=  ;
; ----
;
; }doc

  dw state_,fetch_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header question_csp_,'?CSP'

; doc{
;
; ?csp  ( -- )
;
; Issue error "definition unbalanced" if the current data stack
; position does not match the value saved by `!csp`.
;
; // XXX TODO and `checking` is not zero.
;
; Standard: fig-Forth.
;
; }doc

  dw sp_fetch_,csp_,fetch_,not_equals_
  ; dw checking(s)_,fetch_,and_ ; XXX TODO ?
  _question_throw error.definition_not_finished
  dw exit_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADING'

  dw loading_question_,zero_equals_
  _question_throw error.loading_only
  dw exit_

; ----------------------------------------------
  _colon_header loading_question_,'LOADING?'

  dw blk_,fetch_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header compile_,'COMPILE',compile_only

; doc{
;
; compile  ( -- )
;
; : compile  ( -- )
;   ?compiling  r> dup cell+ >r  @ compile,  ;
;
; }doc

  dw from_r_,dup_,cell_plus_,to_r_,fetch_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header postpone_,'POSTPONE',immediate

; doc{
;
; postpone ( "name" -- )
;
; Skip leading space delimiters. Parse name delimited by a
; space. Find name. Append the compilation semantics of _name_ to
; the current definition.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw defined_ ; ( nfa | 0 )
  dw dup_,question_defined_ ; error if not found
  ; ( nfa )
  dw name_to_immediate_question_ ; ( cfa f )
  dw question_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw compile_comma_ ; compile cfa
  dw exit_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

  dw state_,off_
  dw exit_

; ----------------------------------------------
  _colon_header right_bracket_,']'

  dw state_,on_
  dw exit_

; ----------------------------------------------
  _colon_header revealed_,'REVEALED'

; doc{
;
; revealed  ( nfa -- )
;
; Reveal the definition _nfa_ by resetting its smudge bit.
;
; }doc

  dw smudge_mask_,swap_
  dw names_bank_,c_store_reset_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header reveal_,'REVEAL'

; doc{
;
; reveal  ( -- )
;
; Reveal the latest definition by resetting its smudge bit.
;
; }doc

  dw latest_,revealed_
  dw exit_

; ----------------------------------------------
  _colon_header hided_,'HIDED'

; doc{
;
; hided  ( nfa -- )
;
; Hide the definition _nfa_ by setting its smudge bit.
;
; }doc

  dw smudge_mask_,swap_
  dw names_bank_,c_store_set_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header hide_,'HIDE'

; doc{
;
; hide  ( -- )
;
; Hide the latest definition by setting its smudge bit.
;
; }doc

  dw latest_,hided_
  dw exit_

if 0 ; XXX OLD

; ----------------------------------------------
  _code_header c_store_toggle_bits_,'C!TOGGLE-BITS'

; doc{
;
; c!toggle-bits  ( b ca -- )
;
; Invert the bits at _ca_ specified by the bitmask _b_.
;
; }doc

  pop hl ; address
  pop de ; e = bitmask
  ld a,(hl)
  xor e
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _colon_header smudged_,'SMUDGED'

  ; XXX OLD
  ; XXX TODO move to the library

; doc{
;
; smudged  ( nfa -- )
;
; Toggle the "smudge bit" of the given name field address.
;
; }doc

  dw smudge_mask_,swap_
  dw names_bank_,c_store_toggle_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header smudge_,'SMUDGE'

  ; XXX OLD
  ; XXX TODO move to the library

; doc{
;
; smudge  ( -- )
;
; Toggle the "smudge bit" of the latest definition's name field.
; This prevents an uncompleted definition from being found
; during dictionary searches, until compiling is completed
; without error.
;
; Standard: fig-Forth.
;
; }doc

  dw latest_,smudged_
  dw exit_

endif

; ----------------------------------------------
  _c_constant_header smudge_mask_,'SMUDGE-MASK'

  ; XXX TMP -- added for the port of pForth's `privatize` in the
  ; library, but finally it's not needed, because `(smudge)`
  ; toggles the bit. It may be useful anyway.

  db smudge_mask

; ----------------------------------------------
  _colon_header hex_,'HEX'

  _literal 0x10
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header decimal_,'DECIMAL'

  _literal 0x0A
  dw base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE)'

; doc{
;
; (;code)  ( -- )
;
; The run-time procedure compiled by `;code`. Rewrite the code
; field of the most recently defined word to point to the
; following machine code sequence.
;
; }doc

; : (;code)       --
;   r>        \ Pop the address of the next instruction off the return stack,
;             \ which is the starting address of the run-time code routine.
;   latest    \ Get the name field address of the word under construction.
;   nfa>cfa ! \ Find its code field address and store in it the address of
;             \ the code routine to be executed at run-time.
;   ;

  dw from_r_,latest_,from_name_,store_
  dw exit_

; ----------------------------------------------
  _colon_header semicolon_code_,';CODE',immediate+compile_only

; XXX TODO move to the library?
; XXX TODO -- documentation
; doc{
;
; ;code  ( -- )
;
; Stop compilation and terminate a new defining word by
; compiling the run-time routine `(;code)`.
;
; }doc

  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw left_bracket_,reveal_
  dw exit_

; ----------------------------------------------
  _colon_header does_,'DOES>',immediate+compile_only

  dw compile_,paren_semicolon_code_
  _literal 0xCD ; Z80 opcode for "call"
  dw c_comma_ ; compile it
  dw lit_,do_does,comma_ ; compile the routine address
  dw exit_

do_does:
  ; Save the IP in the return stack.
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; Pop the address of the run-time routine
  ; (put there bye `call do_does`) in IP.
  pop bc ; new Forth IP
  ; Push the pfa.
  inc de  ; de=pfa
  push de
  ; Execute the run-time routine.
  _jp_next

; ----------------------------------------------
  _code_header count_,'COUNT'

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUNDS'

  dw over_,plus_,swap_
  dw exit_

; ----------------------------------------------
  _colon_header type_,'TYPE'

  ; XXX TODO Rewrite in Z80, with the ROM routine?

  dw question_dup_
  dw zero_branch_,type.empty_string

  dw bounds_
  dw paren_do_,type.loop_exit ; do
  dw i_,c_fetch_,emit_
  dw paren_loop_ ; loop
type.loop_exit
  dw exit_

type.empty_string:
  dw drop_
type.end:
  dw exit_

; ----------------------------------------------

  _code_header minus_trailing_,'-TRAILING'

; doc{
;
; -trailing  ( ca1 len1 -- ca1 len2 )
;
; Adjust the length of a string to suppress the trailing blanks.
;
; If _len_ is greater  than zero, _len2_ is  equal to _len1_
; less the number of spaces  at the end of  the character string
; specified by _ca1 len1_. If _len1_ is zero or the entire
; string consists of spaces, _len2_ is zero.
;
; Standard: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (STRING), Forth-2012 (STRING).
;
; }doc

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
  ; de = address after the string
  ; hl = length of the string
minus_trailing.begin:
  ld a,l
  or h ; exhausted?
  jp z,push_hl
  dec de ; next char
  ld a,(de)
  cp ' ' ; space?
  jp nz,push_hl
  dec hl ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header minus_leading_,'-LEADING'

; doc{
;
; -leading  ( ca1 len1 -- ca2 len2 )
;
; Adjust the start and length of a string to suppress the
; leading blanks.
;
; }doc

  dw b_l_,skip_
  dw exit_

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(.")'

; doc{
;
; (.")  ( -- )
;
; Type the compiled string that follows.
;
; ----
; : (.")  ( -- ca len )
;   r@ count dup 1+ r> + >r type  ;
; ----
;
; }doc

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,one_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_

  ; XXX TODO --
  ;   `r@ count dup 1+ r> + >r` is what `slit` does, but
  ;   calling `slit` here can not work:
  ;
  ; dw s_lit_,type_ ; XXX TODO -- this alternative can not work

  dw exit_

if 0 ; XXX OLD

  ; This version allows `."` in interpretation mode.
  ; This version needs 4 more bytes.

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate

; doc{
;
; ."
;
; Interpretation: ( "text<quote>" -- )
;
; Parse "text" delimited by a double-quote and display it.
;
; Compilation: ( "text<quote>" -- )
;
; Parse "text" delimited by a double-quote. Append the run-time
; semantics given below to the current definition.
;
;       Run-time: ( -- )
;
; Display "text".
;
; Standard: Forth-79, Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  _literal '"'
  dw parse_ ; ( ca len )
  dw compiling_question_
  dw zero_branch_,dot_quote.interpreting
  ; Compiling.
  dw compile_,paren_dot_quote_,s_comma_
  dw exit_
dot_quote.interpreting:
  dw type_
  dw exit_

else

  ; This version causes an error when `."` is used in
  ; interpretation mode.
  ; This version saves 4 bytes.

; ----------------------------------------------
  _colon_header comma_quote_,',"'

; doc{
;
; ,"  ( "text<quote>" -- )
;
; Parse "text" delimited by a double-quote and compile the
; string.
;
; ----
; : ,"  ( -- )
;   [char] " parse s,  ;
; ----
;
; }doc

  ; Credits:
  ; Code adapted from DZX-Forth.

  _literal '"'
  dw parse_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate+compile_only

; doc{
;
; ."
;
; Compilation: ( "text<quote>" -- )
;
; Parse "text" delimited by a double-quote. Append the run-time
; semantics given below to the current definition.
;
;       Run-time: ( -- )
;
; Display "text".
;
; Standard: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : ."  ( "text<quote> -- )
;   compile (.") ,"  ;  immediate
; ----
;
; }doc

  ; Credits:
  ; Code adapted from DZX-Forth.

  dw compile_,paren_dot_quote_,comma_quote_
  dw exit_

endif

; ----------------------------------------------
  _variable_header span_,'SPAN'

; doc{
;
; span  ( -- a )
;
; The address of a variable containing the count of characters
; actually received and stored by the last execution of
; `accept`.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header acceptx_,'ACCEPTX'

; XXX UNDER DEVELOPMENT -- to substitute the current
; implementation of `accept`

; doc{
;
; accept  ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when an implementation-defined line
; terminator is received. When input terminates, nothing is
; appended to the string or displayed on the screen.
;
; _len2_ is the length of the string stored at _ca1_.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ; XXX UNDER DEVELOPMENT

  dw dup_,span_,store_
  dw swap_,zero_ ; ( len count left )
acceptx.begin:
  _literal 2
  dw pick_,over_,minus_ ; ( len a count left )

  dw xkey_ ; ( ca c )

  dw branch_,acceptx.begin

  dw two_drop_,drop_

  dw exit_

; ----------------------------------------------
  _colon_header accept_,'ACCEPT'

; doc{
;
; accept  ( ca1 len1 -- len2 )
;
; Receive a string of at most _len1_ characters.  No characters
; are received or transferred if _len1_ is zero.  Display
; graphic characters as they are received.
;
; Input terminates when an implementation-defined line
; terminator is received. When input terminates, nothing is
; appended to the string or displayed on the screen.
;
; _len2_ is the length of the string stored at _ca1_.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw span_,off_
  dw question_dup_
  dw zero_branch_,accept.end

  dw to_r_ ; ( ca1 ) ( R: len1 )
accept.begin: ; ( ca )
  dw xkey_ ; ( ca c )

  dw dup_ ; ( ca c c )
  _literal delete_char
  dw equals_ ; delete key?
  dw zero_branch_,accept.maybe_carriage_return

  ; Delete key ( ca c )
  dw drop_
  dw span_,fetch_
  dw zero_branch_,accept.begin ; nothing to delete
  ; Do delete the last char
  dw one_minus_ ; update the current address
  _literal -1
  dw span_,plus_store_ ; update `span`
  _literal backspace_char
  dw branch_,accept.emit

accept.maybe_carriage_return: ; ( ca c )
  dw dup_
  _literal carriage_return_char
  dw equals_ ; carriage return?
  dw zero_branch_,accept.ordinary_key

  ; Carriage return ( ca c )
  dw drop_,r_drop_
  dw branch_,accept.end

accept.ordinary_key: ; ( ca c )

  dw dup_,b_l_,less_than_ ; control key?
  dw zero_branch_,accept.printable_key
  ; Control key ( ca c )
  dw drop_
  dw branch_,accept.begin

  ; Printable key
accept.printable_key ; ( ca c )
  dw span_,fetch_,r_fetch_,less_than_
  dw zero_branch_,accept.begin ; the string is full
  _literal 1
  dw span_,plus_store_ ; update `span`
  dw two_dup_,swap_,c_store_
  dw swap_,one_plus_,swap_

accept.emit: ; ( ca c )
  dw emit_
  dw branch_,accept.begin

accept.end:
  dw drop_
  dw span_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header query_,'QUERY'

; doc{
;
; query  ( -- )
;
; XXX TODO description in Forth-94:
;
; Make the user input device the input source. Receive input
; into the terminal input buffer, replacing any previous
; contents. Make the result, whose address is returned by `tib`,
; the input buffer. Set `>in` to zero.
;
; XXX OLD -- old descriptions:
;
; Input 80 characters of text (or until a "return") from the
; operators terminal. Text is positioned at the address
; contained in TIB with IN set to zero.
;
; Transfer characters from the terminal to address returned by
; `tib`, until a "return" or the count contained in the `#tib`
; variable have been received. One or more nulls are added at
; the end of the text.
;
; Standard: Forth-83, Forth-94 (CORE EXT, obsolescent).
;
; }doc

  ; XXX TODO move to the library

  dw tib_,slash_tib_
  dw two_dup_,blank_ ; clean the input buffer
  dw accept_,number_tib_,store_,space_
  dw terminal_to_source_
  dw exit_

; ----------------------------------------------
  _constant_header source_id_,'SOURCE-ID'

  ; XXX TODO -- move `value` to the kernel for this?

; doc{
;
; source-id  ( -- 0 | -1 )
;
; Identifies the input source as follows:
;
; |===
; | 0  | User input device
; | -1 | String via `evaluate`
; |===
;
; Standard: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header refill_,'REFILL'

  ; XXX UNDER DEVELOPMENT

; doc{

; refill  ( -- wf )

; }doc


; XXX TMP -- From Z88 CamelForth (version w/o files)
;   SOURCE-ID BLK @ OR 0= DUP
;   IF  TIB DUP 80 ACCEPT SPACE
; 'SOURCE 2!  0 >IN !
;   THEN ;

  ; XXX NEW
  ; XXX TODO -- try, check, complete

  dw loading_question_ ; input stream from disk?
  dw zero_branch_,refill.terminal ; if not, branch

refill.block:
  _literal 1
  dw blk_,plus_store_
  dw to_in_,off_
  dw branch_,refill.end

refill.terminal:
  dw query_
refill.end:
  dw true_
  dw exit_

; XXX TMP -- From Z88 CamelForth (version with files)
;X REFILL   -- f
;   BLK @ IF  1 BLK +!                          ; for block input, use next
;       BLK @ BLOCK PAUSE 1024 TRUE
;   ELSE
;   SOURCE-ID CASE
;     0 OF  TIB DUP 80 ACCEPT SPACE TRUE  ENDOF
;    -1 OF  FALSE  ENDOF
;    >R
;    INPUT-FBUF INPUT-FLEN R@ READ-LINE THROW PAUSE ; read a line
;    IF  INPUT-FBUF SWAP TRUE  THEN   ; leave source-spec
;    R>
;   ENDCASE
;   THEN
;   DUP IF  >R 'SOURCE 2!  0 >IN ! R>  THEN ;

; From hForth
;
;   : refill  ( f )
;     source-id true = if  0 exit  then
;     memtop [ size-of-pad chars ] literal - dup
;     size-of-pad accept sourcevar 2!
;     >in off  true  ;

; ----------------------------------------------
  _code_header fill_,'FILL'

; doc{
;
; fill  ( a u b -- )
;
; If _u_ is not zero, store _b_ in each of _u_
; consecutive characters of memory beginning at _a_.
;
; Standard: fig-Forth, Forth-83.
;
; }doc

  ; XXX TODO consult in clf the differences of the standards and
  ; the Forth-2012 stack notation, also for `erase` and `blank`.

  exx                 ; save the Forth IP
  pop bc
  ld a,c              ; A = character
fill.a:
  pop bc              ; BC = count
  pop de              ; DE = address

  ; XXX TODO -- this check is necessary for Forth-94 and
  ; Forth-2012:

  ;bit 7,b             ; negative count?
  ;jr nz,fill.done     ; if so, skip

  ld hl,0xFFFF
  or a                ; clear carry flag
  adc hl,bc           ; test for count=0 or 1
  jr nc,fill.done     ; no cy: count=0, skip
  ld (de),a           ; fill first byte
  jr z,fill.done      ; z: count=1, done
  dec bc              ; else adjust count
  ld h,d
  ld l,e              ; HL = start address
  inc de              ; DE = start address+1
  ldir                ; copy (HL)->(DE)
fill.done:
  exx                 ; restore the Forth IP
  _jp_next

; ----------------------------------------------

  _code_header erase_,'ERASE'

  exx
  xor a
  jp fill.a

; ----------------------------------------------
  _code_header blank_,'BLANK'

  exx
  ld a,space_char
  jp fill.a

; ----------------------------------------------
  _colon_header hold_,'HOLD'

; doc{
;
; hold  ( c -- )
;
; Insert char _c_ into a pictured numeric output string.
; Typically used between `<#` and `#>`.
;
; ----
; : hold  ( c -- )
;   -1 hld +!  hld @ c!  ;
; ----
;
; }doc

  ; XXX TODO don't use `pad`

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw exit_

; ----------------------------------------------
  _colon_header pad_,'PAD'

; doc{
;
; pad  ( -- ca )
;
; Return the address of a transient region that can be used to
; hold data for intermediate processing.
;
; Standard: Forth-83 (REQUIRED WORD SET), Forth-94 (CORE EXT),
; Forth-2012 (CORE EXT).
;
; }doc

  dw here_
  _literal 0x44
  dw plus_
  dw exit_

; ----------------------------------------------
  _colon_header stream_,'STREAM'

; doc{
;
; stream  ( -- ca len )
;
; Return the address and length of the remaining stream source.
;
; }doc

  dw source_,to_in_,fetch_,slash_string_
;  _brk 'stream' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _code_header slash_string_,'/STRING'

; doc{
;
; /string  ( ca1 len1 n -- ca2 len2 )
;
; Adjust the character string at _ca1 len1_ by _n_ characters.
; The resulting character string _ca2 len2_ begins at _ca1_ plus
; _n_ characters and is _len1_ minus _n_ characters long.
;
; Standard: Forth-94 (STRING), Forth-2012 (STRING).
;
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   rot over + -rot -  ;
; ----
;
; ----
; : /string  ( ca1 len1 n -- ca2 len2 )
;   dup >r - swap r> + swap  ;
; ----
;
; }doc

  pop de                  ; n
  pop hl                  ; len1
  and a                   ; cy=0
  sbc hl,de               ; hl=len2
  ex (sp),hl              ; (sp)=len2 hl=ca1
  add hl,de               ; hl=ca2
  ex (sp),hl              ; (sp)=ca2 hl=len2
  jp push_hl

; ----------------------------------------------
  _colon_header parsed_,'PARSED'

; doc{
;
; parsed  ( len -- )
;
; Add the given _len_ to `>in`.
;
; ----
; : parsed  ( len -- )
;   >in +!  ;
; ----
;
; }doc

  dw to_in_,plus_store_
  dw exit_

; ----------------------------------------------
  _colon_header parse_,'PARSE'

; doc{
;
; parse  ( c "text<c>" -- ca len )
;
; Parse _text_ delimited by the delimiter char _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
;
; If the parse area was empty, the resulting string has a zero length.
;
; Standard: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; ----
; : parse  ( c "text<c>" -- ca len )
;   stream 2dup 2>r rot scan
;   dup if  char-  then
;   2r> rot - parsed
;   tuck -  ;
; ----
;
; }doc


  dw stream_,two_dup_,two_to_r_,rot_,scan_
  dw dup_,zero_branch_,parse.end
  dw char_minus_
parse.end:
  dw two_from_r_,rot_,minus_
  dw parsed_
  dw tuck_,minus_
  dw exit_

; ----------------------------------------------
  _two_variable_header parsed_name_,'PARSED-NAME'

; doc{
;
; parsed-name  ( -- a )
;
; A double variable that holds the address and length of the
; most recently name parsed by `parse-name`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _two_variable_header nextname_string_,'NEXTNAME-STRING'

; doc{
;
; next-name  ( -- a )
;
; A double variable that may hold the address and length of a
; name to be used by the next defining word.  This variable is
; set by `nextname`.
;
; }doc

  dw 0,0

; ----------------------------------------------
  _defer_header header_,'HEADER',,input_stream_header_

; ----------------------------------------------
  _colon_header question_name_too_short_,'?NAME-TOO-SHORT'

; doc{
;
; ?name-too-short ( ca len -- )
;
; }doc

  dw dup_,zero_equals_
  _question_throw -16 ; attempt to use zero-length string as a name
  dw exit_

; ----------------------------------------------
  _colon_header input_stream_header_,'INPUT-STREAM-HEADER'

; doc{
;
; header  ( "name" -- )

; Create a dictionary header "name" with its code field
; pointing to its parameter field.
;
; ----
; : input-stream-header  ( "name" | -- )
;   parse-name header,  ;
; ----
;
; }doc

  dw parse_name_
  dw question_name_too_short_
  dw header_comma_
  dw exit_

; ----------------------------------------------
  _colon_header nextname_header_,'NEXTNAME-HEADER'

; doc{
;
; nextname-header  ( -- )

; Create a dictionary header with its code field pointing to its
; parameter field, using the name string set by `nextname`.
;
; ----
; : nextname-header  ( -- )
;   nextname-string 2@ header,
;   ['] input-stream-header ['] header defer!  ;
; ----
;
; }doc

  dw nextname_string_,two_fetch_,header_comma_
  _literal input_stream_header_
  _literal header_
  dw defer_store_ ; restore the default behaviour of `header`
  dw exit_

; ----------------------------------------------
  _colon_header nextname_,'NEXTNAME'

; doc{
;
; nextname  ( ca len -- )
;
; ----
; : nextname  ( ca len -- )
;   nextname-string 2!
;   ['] nextname-header ['] header defer!  ;
;
; The next defined word will have the name _ca len_; the
; defining word will leave the input stream alone. `nextname`
; works with any defining word.
;
; ----
;
; }doc

  ; Credits:
  ; This word is borrowed from Gforth.

  dw nextname_string_,two_store_
  _literal nextname_header_
  _literal header_
  dw defer_store_ ; change the default behaviour of `header`
  dw exit_

; ----------------------------------------------
  _colon_header parse_name_,'PARSE-NAME'

; doc{

; parse-name  ( "name"  -- ca len )
;
; ----
; : parse-name  ( "name"  -- ca len )
;   stream                 ( ca0 len0 )
;   dup >r   -leading      ( ca1 len1 ) ( R: len0 )
;   over >r  bl scan       ( ca2 len2 ) ( R: len0 ca1 )
;   dup if char- then      \ skip trailing delimiter
;   r> r> rot -  parsed    \ update `>in`
;   tuck -                 ( ca len )
;   2dup parsed-name 2!  ;
; ----
;
; }doc

  dw stream_              ; ( ca len )
; _brk 'parse-name -- after stream' ; XXX INFORMER
  dw dup_,to_r_           ; ( ca len ) ( R: len )
; _brk 'parse-name -- before skip' ; XXX INFORMER
  dw minus_leading_           ; ( ca1 len1 ) ( R: len )
; _brk 'parse-name -- after skip' ; XXX INFORMER
  dw over_,to_r_          ; ( ca1 len1 ) ( R: len ca1 )
  dw b_l_,scan_           ; ( ca2 len2 ) ( R: len ca1 )
; _brk 'parse-name -- after scan' ; XXX INFORMER
  dw dup_
  dw zero_branch_,parse_name.skip
; _brk 'parse-name -- before char-' ; XXX INFORMER
  dw char_minus_
parse_name.skip:
  dw from_r_,from_r_      ; ( ca2 len2 ca1 len )
  dw rot_,minus_          ; ( ca2 ca1 len3 )
; _brk 'parse-name -- before updating >in' ; XXX INFORMER
  dw parsed_              ; ( ca2 ca1 )
  dw tuck_,minus_         ; ( ca1 len4 )
  dw two_dup_,parsed_name_,two_store_
;  _brk_type 'parse-name -- end' ; XXX INFORMER
  dw exit_

; ----------------------------------------------
  _code_header upper_,'UPPER'

; doc{
;
; upper  ( c -- c' )
;
; }doc

  ; XXX TODO convert to deferred, to let it be customized for
  ; 8-bit charsets.

  pop hl
  ld a,l
  call upper.a
  ; XXX TODO `jp push_a` to save 1 byte?
  ld l,a
  jp push_hl

upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  and %11011111
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPERS'

; doc{
;
; uppers  ( ca len -- )
;
; }doc

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upper.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; doc{
;
; undefined?  ( ca len -- wf )
;
; }doc

  ; XXX TODO -- this may be moved to the library, but it's
  ; needed by `needed`.

  dw find_name_,zero_equals_
  dw exit_

; ----------------------------------------------
  _code_header place_,'PLACE'

; doc{
;
; place  ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ as a counted string at _ca2_.  The
; source and destination strings are permitted to overlap.
;
; An ambiguous condition exists if _len1_ is greater than 255 or
; the buffer at _ca2_ is less than _len1_+1 characters.
;
; ----
; : place  ( ca1 len1 ca2 -- )
;   2dup c! 1+ smove  ;
; ----
;
; }doc

  ; Credits:
  ; Code from DZX-Forth's `packed`.

  exx         ; save Forth IP
  pop de      ; de=ca2
  pop bc      ; c=len1
  pop hl      ; hl=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; e=len1
  ld (hl),e
  exx         ; restore Forth IP
  _jp_next

; ----------------------------------------------
  _variable_header error_number_,'ERROR#'

  ; XXX TODO -- useful? remove? user variable?

; doc{
;
; error# ( -- a )
;
; Variable that holds the number of the last error issued by
; `error`.
;
; }doc

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-POS'

; doc{
;
; error-pos ( -- a )
;
; Double variable that holds the position of the last error
; issued by `error`:

; - high part = value of `blk`
; - low part = value of `>in`

; }doc

  dw 0 ; value of `blk`
  dw 0 ; value of `>in`

; ----------------------------------------------
  _colon_header error_,'ERROR'

; doc{
;
; error  ( n -- )
;
; Save the error number _n_ into `error-number`, and the current
; block and line into `error-pos`, to be used by `where`.  Issue
; error _n_ and restart the system.
;
; ----
; : error  ( n -- )
;   dup error-number !
;   >in @ blk @ error-pos 2!
;   dup -1 = if  (abort)  then
;   dup -2 = if  abort-message 2@ type (abort)  then
;   parsed-name 2@ type ." ? " message  (abort)  ;
; ----
;
; }doc

  dw dup_,error_number_,store_ ; save the error number
  dw to_in_,fetch_,blk_,fetch_,error_pos_,two_store_

  dw dup_
  _literal -1
  dw equals_
  dw question_branch_,paren_abort_pfa
  ; No return from `(abort)`.

  dw dup_
  _literal -2
  dw equals_
  dw zero_branch_,error.message
  dw space_,abort_message_,two_fetch_,type_,paren_abort_
  ; No return from `(abort)`.

error.message:
  dw parsed_name_,two_fetch_,type_ ; last parsed word
  dw paren_dot_quote_
  _string '? '
  dw dot_throw_,paren_abort_
  ; No return from `(abort)`.

; ----------------------------------------------
  _two_variable_header abort_message_,"ABORT-MESSAGE"

  dw 0,0

; ----------------------------------------------
  _colon_header id_dot_,'ID.'

  dw name_to_string_,type_,space_
  dw exit_

; ----------------------------------------------
  _colon_header header_comma_,'HEADER,'

; doc{
;
; header,  ( ca len -- )
;
; Create a dictionary header with the name _ca len_, with its
; code field pointing to its parameter field.
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.zero_length_name

  dw warnings_,fetch_
  dw zero_branch_,header_comma.continue

  ; `warnings` is on
  dw two_dup_,get_current_,search_wordlist_
  dw zero_branch_,header_comma.continue
  ; the word is not unique in `current`
  ; ( ca len cfa )
  dw to_name_,id_dot_
  _literal error.not_unique
  dw dot_throw_ ; XXX TMP -- `warning`?

header_comma.continue:

  ; ( ca len )

  dw width_,fetch_,min_
  dw tuck_ ; ( len ca len )
  dw names_bank_
  dw here_,comma_np_ ; store a pointer to the cfa
  dw latest_,comma_np_ ; link field
  ; Now `np` contains the address of the nfa.
  dw np_fetch_
  dw dup_,to_r_
  dw place_ ; store the name
  dw from_r_,count_,uppers_

  dw np_fetch_,get_current_,store_ ; update contents of `latest` in the current vocabulary
  dw hide_
  dw one_plus_,np_,plus_store_ ; update the names pointer with the length+1
  dw here_,two_plus_,comma_ ; compile the pfa into code field
  dw exit_

; ----------------------------------------------
  _colon_header create_,'CREATE'

  ; XXX TODO factor `header smudge` to `visible-header`? it's
  ; used also by `defer`.

  dw header_,reveal_
  dw paren_semicolon_code_
do_create:
  inc de  ; de=pfa
  push de
  _jp_next

; ----------------------------------------------
if 1 ; assembler_core_in_kernel

  _colon_header code_,'CODE'

;  _chk 'code -- before header' ; XXX INFORMER
  dw header_
;  _chk 'code -- after header' ; XXX INFORMER
  dw asm_
;  _chk 'code -- end' ; XXX INFORMER
  dw exit_

endif

; ----------------------------------------------
  _code_header compare_,'COMPARE'

  ; Forth-94
  ; Adapted from DZX-Forth

  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  pop de      ; de = len2
  pop hl      ; hl = ca2
  ex (sp),hl  ; hl = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; cy = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; de = length of the short string
  ; hl = length of the long string
  ld l,c
  ld h,b ; hl = Forth IP
  pop bc ; bc = ca2
  ex (sp),hl ; hl = ca1 ; save Forth IP
  push af ; save carry flag
compare.compare_strings: equ $+1 ; XXX not used
  call compare_strings_case_sensitive
  jr nz,compare.no_match

compare.match:
  ; The smaller string matches.
  pop af ; restore flags
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl
  dec hl ; 0
  jp z,push_hl ; string1 equals string2
  dec hl ; -1
  jp push_hl

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ; Credits:
  ; Code from DZX-Forth.
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; ----------------------------------------------
  _code_header search_,'SEARCH'

  ; search  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  ; Forth-94

  ; Adapted from DZX-Forth.
  ;
  ; XXX TODO -- do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.  Use shorter
  ; internal code instead.  When case insensitive comparation is
  ; needed, `uppers` can be used.
  ;
  ; XXX TODO --  2015-09-12: make the case mode comparison
  ; configurable seems a better option, easier than customize
  ; several version of the same code with `uppers`, not to
  ; mention `uppers` with parsed strings must use tthe circular
  ; string buffer, what is a limitation.

  exx ; save Forth IP
  pop hl
  ld (search.string_2_len),hl
  ld a,l
  or h ; len2 is zero?
  pop bc ; ca2
  pop hl ; len1
  ld (search.string_1_len),hl
  ex de,hl ; de = len1
  pop hl ; ca1
  ld (search.string_1_addr),hl
  jp z,search.match ; if len2 is zero, match
  dec hl
  inc de
search.1:
  inc hl ; address of current char of string 1
  dec de ; remaining length of string 1
  ld a,e
  or d ; end of string 1?
  jp z,search.no_match
; XXX OLD -- already commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
search.string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings_case_sensitive
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.match:
  ld bc,true
search.end:
  push hl
  push de
  push bc
  exx ; restore Forth IP
  _jp_next

search.no_match:
  ld bc,false
search.string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
search.string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.end

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE]',immediate

  dw tick_,compile_comma_
  dw exit_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERAL',immediate+compile_only

  ; ----
  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate
  ; ----

  dw compile_,s_lit_,s_comma_
  dw exit_

; ----------------------------------------------
  _colon_header c_literal_,'CLITERAL',immediate+compile_only

; doc{
;
; cliteral  ( b -- )
;
; If compiling, then compile the stack value _b_ as a 8-bit literal.
; `cliteral` does the same than `literal` but saves one byte of
; dictionary space.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`
  ; XXX TODO -- move to the library?

  if 0 ; XXX OLD
    dw compiling_question_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    dw compile_,c_lit_,comma_
  endif
  dw exit_

; ----------------------------------------------

  ; XXX TODO not used yet
  ; XXX TODO rename to `byte?` (there's a `char?` used by
  ; `number?`)

  ; _code_header char_question_,'CHAR?'

  ; ; Credits:
  ; ; Word adapted from DZX-Forth.

; ; doc{
; ;
; ; char?  ( n -- f )
; ;
; ; Is _n_ an 8-bit number?
; ;
; ; }doc

  ; ; XXX TODO -- use with `interpret` or `literal`?

  ; pop hl
  ; ld l,h
  ; jp zero_equals.hl

; ----------------------------------------------
  _colon_header literal_,'LITERAL',immediate+compile_only

; doc{
;
; literal  ( n -- )
;
; If compiling, then compile the stack value _n_ as a 16-bit literal.
;
; Standard: fig-Forth.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 0 ; XXX OLD
    dw compiling_question_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    ; XXX TODO -- 8-bit (`cliteral`) and 16-bit, after DZX-Forth
    dw compile_,lit_,comma_
  endif
  dw exit_

; ----------------------------------------------
  _colon_header two_literal_,'2LITERAL',immediate+compile_only

; doc{
;
; 2literal  ( d -- )  \ I
;
; If compiling, then compile the stack value _d_ as a 32-bit literal.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 0 ; XXX OLD
    dw compiling_question_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    dw compile_,two_lit_
    dw swap_,comma_,comma_
  endif
  dw exit_

; ----------------------------------------------
  _colon_header depth_,'DEPTH'

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw exit_

; ----------------------------------------------
  _colon_header dictionary_stack_,'?DICTIONARY'

; doc{
;
; ?dictionary  ( -- )
;
; Issue an error message if the dictionary is out of bounds.
;
; }doc

  ; XXX UNDER DEVELOPMENT

  dw zero_ ; XXX TMP
  _question_throw error.dictionary_overflow
  dw exit_

; ----------------------------------------------
  _colon_header question_stack_,'?STACK'

; doc{
;
; ?stack  ( -- )
;
; Issue an error message if the stack is out of bounds.

; Standard: fig-Forth.
;
; }doc

;  dw cr_,blk_,fetch_,dot_ ; XXX INFORMER
;  dw to_in_,fetch_,c_slash_l_,slash_,dot_ ; XXX INFORMER
;  dw dot_s_ ; XXX INFORMER
  dw sp_fetch_
  dw sp0_,fetch_
  dw swap_,less_than_
  _question_throw error.stack_underflow
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_throw error.stack_overflow
  dw exit_

; ----------------------------------------------
  _colon_header not_understood_,'NOT-UNDERSTOOD'

  _literal error.not_understood
  dw throw_

; ----------------------------------------------
  _colon_header compilation_only_,'COMPILATION-ONLY'

  _literal error.compilation_only
  dw throw_

; ----------------------------------------------
  _colon_header nest_source_,'NEST-SOURCE',compile_only

; doc{
;
; nest-source  ( R: -- source-sys )
;
; _source-sys_ describe the current source specification for
; later use by `unnest-source`.

; ----
; : nest-source  ( R: -- source-sys )
;   r>
;   source 2>r
;   source-id >r
;   >in @ >r
;   blk @ >r
;   #tib @ >@
;   >r  ;
; ----

; }doc

  dw from_r_ ; save the return address
  dw source_,two_to_r_
  dw source_id_,to_r_
  dw to_in_,fetch_,to_r_
  dw blk_,fetch_,to_r_
  dw number_tib_,fetch_,to_r_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _colon_header unnest_source_,'UNNEST-SOURCE',compile_only

; doc{
;
; unnest-source  ( R: source-sys -- )
;
; Restore the source specification described by _source-sys_.

; ----
; : unnest-source  ( R: source-sys -- )
;   r>
;   r> #tib !
;   r> blk !
;   r> >in !
;   r> [ ' source-id >body ] literal !
;   2r> input-buffer 2!
;   >r  ;
; ----

; }doc

  dw from_r_ ; save the return address
  dw from_r_,number_tib_,store_
  dw from_r_,blk_,store_
  dw from_r_,to_in_,store_
  dw from_r_
  _literal source_id_pfa
  dw store_
  dw two_from_r_,input_buffer_,two_store_
  dw to_r_ ; restore the return address
  dw exit_

; ----------------------------------------------
  _colon_header evaluate_,'EVALUATE'

; doc{
;
; evaluate  ( i*x ca len -- j*x )
;
; Save the current input source specification. Store minus-one
; (-1) in `source-id`. Make the  string
; described by _ca len_ both the input source and input
; buffer,  set `>in` to zero,  and interpret.  When the  parse
; area  is  empty, restore the prior input source
; specification.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
 
; ----
; : evaluate  ( i*x ca len -- j*x )
;   nest-source string>source interpret unnest-source  ;
; ----

; }doc

  dw nest_source_ 
  dw string_to_source_
  dw interpret_
  dw unnest_source_
  dw exit_

; ----------------------------------------------
  _variable_header interpret_table_,'INTERPRET-TABLE'

; doc{
;
; interpret-table  ( -- a )
;
; Return the address of the execution table used by `interpret`.
; The table contains 13 vectors.  The behaviour of the Forth
; text interpreter can be changed by replacing these vectors.
; See the kernel source for details on the position and function
; of the vectors.
;
; }doc

                        ; compiling...
  dw execute_           ; ...immediate and compile-only word
  dw compile_comma_     ; ...compile-only word
  dw execute_           ; ...immediate word
  dw compile_comma_     ; ...ordinary word
  dw two_literal_       ; ...2-cell number
  dw literal_           ; ...1-cell number

interpret_table.0:
  dw not_understood_    ; not a number (error)

                        ; interpreting...
  dw 0                  ; ...1-cell number (do nothing)
  dw 0                  ; ...2-cell number (do nothing)
  dw execute_           ; ...ordinary word
  dw execute_           ; ...immediate word
  dw compilation_only_  ; ...compile-only word (error)
  dw compilation_only_  ; ...immediate and compile-only word (error)

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'

; doc{
;
; interpret  ( -- )
;
; The text interpreter which sequentially executes or compiles
; text from the input stream (terminal or disk) depending on
; `state`. if the word name cannot be found after a search of
; the `context` search order it is converted to a number
; according to the current `base`.  That also failing, an error
; message will be given.
;
; }doc

interpret.begin:

  dw question_stack_
  dw parse_name_  ; ( ca len )
  dw dup_ ; end of stream?
  dw zero_branch_,interpret.end ; if so, finish

  dw find_name_ ; ( nfa | 0 )
  dw question_dup_ ; found?
  dw zero_branch_,interpret.word_not_found

  ; Word found
  ; ( nfa )
  dw dup_,name_to_immediate_question_       ; ( nfa cfa f1 )
  dw rot_,compile_only_question_,two_star_  ; ( cfa f1 n2 )
  dw plus_,abs_ ; ( cfa +n )
  _literal 3
  dw plus_ ; adjust the table index

interpret.do_it:
  ; ( +n )
  ; Execute element _+n_ of `interpret-table`,
  ; depending on `state`.
  dw compiling_question_,question_negate_,cells_
  _literal interpret_table.0
  dw plus_,perform_
  dw branch_,interpret.begin

interpret.word_not_found:
  dw parsed_name_,two_fetch_ ; ( ca len )
  dw number_question_ ; is it a number?  ( 0 | n 1 | d 2 )
  dw branch_,interpret.do_it

interpret.end:
  dw two_drop_
  dw exit_

; ----------------------------------------------
  _c_constant_header immediate_mask_,'IMMEDIATE-MASK'

  db immediate_mask

; ----------------------------------------------
  _colon_header lex_question_,'LEX?'

; doc{
;
; lex?  ( nfa b -- )
;
; Test the bits at _nfa_ specified by the bitmask _b_.
; Return _true_ if the result is non-zero, else return _false_.
;
; }doc

if 1

  dw names_bank_
  dw swap_,c_fetch_test_bits_question_
  dw default_bank_
  dw exit_

else  ; XXX TMP alternative without `c@test-bits?`

  dw swap_,c_fetch_n_,and_,zero_not_equals_
  dw exit_

endif

; ----------------------------------------------
  _colon_header lex_store_,'LEX!'

; doc{
;
; lex!  ( b nfa -- )
;
; Set the bits of the mask _b_ in the length byte of _nfa_.
;
; }doc

  ; Credits:
  ; Word adapted from eForth.

  dw names_bank_,c_store_set_bits_,default_bank_
  dw exit_

; ----------------------------------------------
  _colon_header set_latest_lex_,'SET-LATEST-LEX'

; doc{
;
; set-latest-lex  ( b -- )
;
; Set the bits of the mask _b_ in the length byte of the latest
; defined word.
;
; }doc

  dw latest_,lex_store_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIATE'

  dw immediate_mask_,set_latest_lex_
  dw exit_

; ----------------------------------------------
  _colon_header immediate_question_,'IMMEDIATE?'

; doc{
;
; immediate?  ( nfa -- wf )
;
; Does the word with the given _nfa_ is immediate?
;
; }doc

  dw immediate_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header name_to_immediate_question_,'NAME>IMMEDIATE?'

; doc{
;
; name>immediate?  ( nfa -- cfa wf )
;
; Does the word with the given _nfa_ is immediate?
;
; }doc

  ; XXX TODO better name!
  ; this name is confusing, compared to `immediate?`,
  ; which converts a nfa to a flag.

  dw dup_,from_name_,swap_ ; ( cfa nfa )
  dw immediate_question_ ; ( cfa wf )
  dw exit_

; ----------------------------------------------
  _c_constant_header compile_only_mask_,'COMPILE-ONLY-MASK'

  db compile_only_mask

; ----------------------------------------------
  _colon_header compile_only_,'COMPILE-ONLY'

  dw compile_only_mask_,set_latest_lex_
  dw exit_

; ----------------------------------------------
  _colon_header compile_only_question_,'COMPILE-ONLY?'

; doc{
;
; compile-only?  ( nfa -- wf )
;
; Does the word with the given _nfa_ is compile-only?
;
; }doc

  dw compile_only_mask_,lex_question_
  dw exit_

; ----------------------------------------------
  _colon_header paren_vocabulary_,'(VOCABULARY)'

; doc{
;
; (vocabulary)  ( -- )
;
; Create the parameter field of a vocabulary or word list just created.
;
; ----
; : (vocabulary)  ( -- )
;   0 ,  here voc-link @ , voc-link !  ;
; ----
;
; }doc

  _literal 0
  dw comma_                   ; nfa of the latest word defined in the vocabulary
  dw here_                    ; new contents of vocabulary link
  dw voc_link_,fetch_,comma_  ; compile the previous contents of `voc-link`
  dw voc_link_,store_         ; update `voc-link`
  dw exit_

; ----------------------------------------------
  _colon_header vocabulary_,'VOCABULARY'

; doc{
;
; vocabulary  ( "name" -- )
;
; Create a vocabulary with the parsed "name" as its name. The
; run-time efect of `name` is to replace `context`, the top
; vocabulary in the search order.
;
; ----
; : vocabulary  ( "name" -- )
;   create  (vocabulary)
;   does>   ( -- )  ( pfa ) context !  ;
; ----
; }doc

  dw create_,paren_vocabulary_
  dw paren_semicolon_code_
do_vocabulary:
  call do_does
  ; The next words are to be executed when the vocabulary is invoked.
  dw context_,store_
  dw exit_

; ----------------------------------------------
  _colon_header wordlist_,'WORDLIST'

; doc{
;
; wordlist  ( -- wid )
;
; : wordlist ( -- wid )
;   :noname  (vocabulary)  postpone ;  >body  ;
;
; }doc

  dw colon_no_name_,paren_vocabulary_,semicolon_,to_body_
  dw exit_

; ----------------------------------------------
  _colon_header get_current_,'GET-CURRENT'

; doc{
;
; get-current  ( -- wid )
;
; Return _wid_, the identifier of the compilation word list.
;
; Standard: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : get-current  ( -- wid )
;   current @  ;
; ----
;
; }doc

  dw current_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header set_current_,'SET-CURRENT'

; doc{
;
; set-current  ( wid -- )
;
; Set the compilation word list to the word list identified by
; _wid_.
;
; Standard: Forth-94 (SEARCH), Forth-2012 (SEARCH).
;
; ----
; : set-current  ( wid -- )
;   current !  ;
; ----
;
; }doc

  dw current_,store_
  dw exit_

; ----------------------------------------------
  _colon_header definitions_,'DEFINITIONS'

; doc{
;
; definitions  ( -- )
;
; Make the compilation word list the same as the first  word
; list in the search order. The  names of subsequent definitions
; will be placed in the compilation word list. Subsequent
; changes in the search  order will not affect the compilation
; word list.
;
; ----
; : definitions  ( -- )
;   context @ set-current  ;
; ----
;
; }doc

  dw context_,fetch_,set_current_
  dw exit_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

; doc{
;
; (  ( f "text<paren>" -- )
;
; Parse until a right paren is found.
; The number of parsed
; characters may be zero to the number of characters in the
; parse area.
;
; }doc

  _literal ')'
  dw parse_,two_drop_
  dw exit_

; ----------------------------------------------
  _colon_header dot_ok_,'.OK'

; doc{
;
; .ok  ( -- )
;
; Print "ok". This is the default behaviour of `ok`, the word
; called by `quit` after interpreting a command.
;
; }doc

  dw paren_dot_quote_
  _string 'ok'
  dw exit_

; ----------------------------------------------
  _defer_header ok_,'OK',,dot_ok_

; doc{
;
; ok  ( -- )
;
; A deferred word called by `quit` after interpreting a command.
; Its default behaviour is the word `.ok`.
;
; }doc

; ----------------------------------------------
  _colon_header quit_,'QUIT'

  dw terminal_to_source_
  dw left_bracket_
quit.begin:
  dw rp0_,fetch_,rp_store_
  dw cr_,query_ ; XXX TMP XXX TODO
  dw interpret_
  dw compiling_question_
  dw question_branch_,quit.begin
  dw ok_
  dw branch_,quit.begin

; ----------------------------------------------
  _colon_header paren_defer_,'(DEFER)'

; doc{
;
; (defer)  ( -- )
;
; Default behaviour of an uninitialized deferred word: error.
;
; }doc

  _literal error.deferred_word_uninitialized
  dw error_
  dw exit_

; ----------------------------------------------
  _colon_header defer_,'DEFER'

; doc{
;
; defer  ( "name" -- )
;
; Create a deferred word.
;
; Standard: Forth-2012 (CORE EXT).
;
; }doc

  dw header_,reveal_
  _literal 0x21 ; Z80 opcode for `ld hl,NN`
  dw c_comma_
  _literal paren_defer_ ; default cfa to execute
  dw comma_
  _literal 0xC3 ; Z80 opcode for `jp NN`
  dw c_comma_
  _literal next2 ; address to jump to
  dw comma_
  dw exit_

; ----------------------------------------------
  _colon_header defer_fetch_,'DEFER@'

; doc{
;
; defer@  ( cfa1 -- cfa2 )
;
; Return the word _cfa2_ currently associated to the deferred
; word _cfa1_.
;
; Standard: Forth-2012 (CORE EXT).
;
; }doc

  dw to_body_,one_plus_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header defer_store_,'DEFER!'

; doc{
;
; defer!  ( cfa1 cfa2 -- )
;
; Change the deferred word _cfa2_ to execute _cfa1_.
;
; Standard: Forth-2012 (CORE EXT).
;
; }doc

  dw to_body_,one_plus_,store_
  dw exit_

; ----------------------------------------------
  _two_constant_header version_,'VERSION'

; doc{
;
; version  ( -- d )
;
; Return the Solo Forth version number _d_.  The version number
; is the release date in the ISO format YYYYMMDD.
;
; }doc

  dw version_high_part,version_low_part

; ----------------------------------------------
  _colon_header greeting_,'GREETING'

; doc{
;
; greeting  ( -- )
;
; Print the boot message.
;
; }doc

  dw paren_dot_quote_
  _string "Solo Forth\rVersion "
  dw version_,d_dot_
  dw paren_dot_quote_
  _string "\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"

  ; XXX TMP show the free memory, during development only
  dw unused_,u_dot_
  dw paren_dot_quote_
  _string "B free"

  dw exit_

; ----------------------------------------------
  _defer_header boot_,'BOOT',,noop_

; doc{
;
; boot  ( -- )
;
; A deferrer word executed by `abort`. By default it does
; nothing. It is changed by `turnkey`.
;
; }doc

; ----------------------------------------------
  _variable_header previous_mode_,'PREVIOUS-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; previous-mode  ( -- a )
;
; Variable that holds the cfa of the word that activates the
; screen mode that was active before executing `bye`.  It's
; updated by `bye`, and used by `warm` to restore the current
; mode.
;
; }doc

  dw noop_

; ----------------------------------------------
  _variable_header current_mode_,'CURRENT-MODE'

  ; XXX TODO -- convert to a deferred word?

; doc{
;
; current-mode  ( -- a )
;
; Variable that holds the cfa of the word that activates the
; current screen mode. It's set to `noop` until the first mode
; change is done.
;
; }doc

  dw noop_

; ----------------------------------------------
  _colon_header warm_,'WARM'

; doc{
;
; warm  ( -- )
;
; }doc

  dw display_
  dw previous_mode_,perform_
  dw page_ ; note: this must be after changing the screen mode
  dw abort_
  ; No return from `abort`.

warm_start:
  call common_start
  dw warm_

; ----------------------------------------------
  _colon_header cold_,'COLD'

; doc{
;
; cold  ( -- )
;
; }doc

  ; Init the names pointer.
  dw lit_,names_pointer_init_value,fetch_
  dw lit_,names_pointer,store_

  ; Init the disk buffers.
  dw empty_buffers_

  ; Init the circular string buffer.
  dw empty_csb_

  ; Init the user variables.
  dw lit_,default_user_variables_start ; from
  dw up_,fetch_ ; to
  _literal default_user_variables_end-default_user_variables_start ; length
  dw cmove_

  ; Restore the vocabularies to the default state.
  dw lit_,latest_nfa_in_root_voc.init_value,fetch_
  dw lit_,root_pfa,store_
  dw lit_,latest_nfa_in_forth_voc.init_value,fetch_
  dw lit_,forth_pfa,store_
if 1 ; assembler_core_in_kernel
  dw lit_,latest_nfa_in_assembler_voc.init_value,fetch_
  dw lit_,assembler_pfa,store_
endif
  dw lit_,voc_link.init_value,fetch_
  dw lit_,voc_link_pfa,store_

  dw only_,forth_,definitions_  ; search order
  dw decimal_

  dw display_,default_colors_,page_,greeting_

;  _brk 'cold -- before abort' ; XXX INFORMER

  dw abort_

cold_start:
only_first_cold: ; XXX TMP -- temporary label
  call move_name_fields_to_memory_bank ; (only the first time)
  call common_start
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  ; (SP) = cfa of `cold` or `warm`

  im 1 ; interrupt mode 1
  pop bc ; get the return address, that holds the cfa of `cold` or `warm`
  ld (system_stack_pointer),sp ; save the system stack pointer
  ld sp,(sp0_init_value)
  xor a
  ld (iy+sys_df_sz_offset),a ; no lines at the bottom part of the screen
  ld ix,next ; restore IX
  _jp_next ; jump to the cfa pointed by the register pair BC

; ----------------------------------------------
  _code_alias_header d_to_s_,'D>S',,drop_

; doc{
;
; d>s  ( d -- n )
;
; Standard: Forth-94 (DOUBLE), Forth-2012 (DOUBLE).
;
; ----
; : d>s  ( d -- n )
;   drop  ;
; ----
; }doc

; ----------------------------------------------
  _code_header s_to_d_,'S>D'

; doc{
;
; s>d  ( n -- d )
;
; Sign extend a single number _n_ to form a double number _d_.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; ----
; : s>d  ( n -- d )
;   dup 0<  ;
; ----
;
; }doc

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_hlde ; jump if positive
  dec hl
  jp push_hlde

; ----------------------------------------------
  _code_header question_negate_,'?NEGATE'

; doc{
;
; ?negate  ( n1 n2 -- n1|n3 )
;
; If _n2_ is negative, negate _n1_, giving its arithmetic
; inverse _n3_.
;
; ----
; : ?negate  ( n1 n2 -- n1|n3 )
;   0< if  negate  then  ;
; ----
; }doc

  pop hl
question_negate.hl:
  bit 7,h
  jp nz,negate_pfa
  _jp_next

; ----------------------------------------------
  _code_header question_d_negate_,'?DNEGATE'

; doc{
;
; ?dnegate  ( d1 n -- d1|d2 )
;
; If _n_ is negative, negate _d1_, giving its arithmetic inverse
; _d2_.
;
; ----
; : ?dnegate  ( d1 n -- d1|d2 )
;   0< if  dnegate  then  ;
; ----
;
; }doc

  pop hl
question_d_negate.hl:
  bit 7,h
  jp nz,d_negate_pfa
  _jp_next

; ----------------------------------------------
  _code_header abs_,'ABS'

; doc{
;
; abs  ( n -- u )
;
; Leave the absolute value _u_ of a number _n_.
;
; ----
; : abs  ( n -- u )
;   dup ?negate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_negate.hl

if 0

  ; XXX TODO ? -- from DZX-Forth

  pop hl
  call abs_hl
  jp push_hl

endif

; ----------------------------------------------
  _code_header d_abs_,'DABS'

; doc{
;
; dabs  ( d -- ud )
;
; Leave the absolute value _ud_ of a double number _d_.
;
; ----
; : dabs  ( d -- ud )
;   dup ?dnegate  ;
; ----
;
; }doc

  pop hl
  push hl
  jp question_d_negate.hl

; ----------------------------------------------
  _code_header umax_,'UMAX'

; doc{
;
; umax  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  pop hl
  _compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMIN'

; doc{
;
; umin  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  pop hl
  _compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MIN'

  ; Credits:
  ; Code from DZX-Forth.

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MAX'

  ; Credits:
  ; Code adapted from DZX-Forth.

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  push de
  _jp_next

; ----------------------------------------------
  _colon_header m_star_,'M*'

; doc{
;
; m*  ( n1 n2 -- d )
;
; Multiply _n1_ by _n2_ producing the result _d_.
;
; Standard: fig-Forth, Forth-94, Forth-2012.
;
; ----
; : m*  ( n1 n2 -- d )
;   2dup xor >r
;   abs swap abs um*
;   r> ?dnegate  ;
; ----
;
; }doc

if 1 ; original_m_star

  ; Credits:
  ; Code from Abersoft Forth.

  ; XXX Note: this code is used also by Z88 CamelForth.

  dw two_dup_,xor_,to_r_
  dw abs_,swap_,abs_,u_m_star_
  dw from_r_,question_d_negate_
  dw exit_

else

  ; XXX TODO -- code from DZX-Forth

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_signed
  jp push_hlde

endif

; ----------------------------------------------
  _defer_header m_slash_,'M/',,s_m_slash_rem_

; doc{
;
; m/  ( d n1 -- n2 n3 )
;
; A mixed magnitude math operator which leaves the signed
; remainder _n2_ and signed quotient _n3_ from a double number
; dividend and divisor _n1_.
;
; This word is deferred and by default it's set to execute
; `sm/rem`, so it does a symmetric division (the  remainder
; takes its sign from the dividend), as in fig-Forth.  It can be
; set to execute `fm/mod` instead.
;
; This word is executed by all other division operators.
; Therefore setting it to execute either `sm/rem` or `fm/mod`
; will change the behaviour of all division operators.
;
; Standard: fig-Forth.
;
; }doc

; ----------------------------------------------
  _colon_header s_m_slash_rem_,'SM/REM'

; doc{
;
; sm/rem  ( d n1 -- n2 n3 )
;
; Symmetric division:
;
;   d = n3*n1+n2;

;   sign(n2) = sign(d1) or 0
;
; Divide _d_ by _n1_, giving the symmetric quotient _n3_ and the
; remainder _n2_. Input and output stack arguments are signed.
;
; Standard: Forth-94, Forth-2012.

; }doc

  ; XXX Note: This implementation, from Z88 CamelForth, is
  ; slower than Abersoft Forth's, but works better.

; : sm/rem  ( d1 n1 -- n2 n3 )
;   \ symmetric signed division
;   2dup xor >r  \  sign of quotient
;   over >r      \  sign of remainder
;   abs >r dabs r> um/mod
;   swap r> ?negate
;   swap r> ?negate  ;

  dw two_dup_,xor_,to_r_
  dw over_,to_r_
  dw abs_,to_r_,d_abs_,from_r_,u_m_slash_mod_
  dw swap_,from_r_,question_negate_
  dw swap_,from_r_,question_negate_
  dw exit_

if 0

  _colon_header s_m_slash_rem2_,'SM/REM2'  ; XXX TMP

  ; Credits:
  ; Code from Abersoft Forth's `m/`.

  ; XXX Note: This implementation, from Abersoft Forth, is
  ; faster than Z88 CamelForth's, but has bugs.
;
; ----
; : sm/rem  ( d n1 -- n2 n3 )
;   over >r >r dabs r@ abs um/mod
;   r> r@ xor ?negate swap
;   r> ?negate swap  ;
; ----
;
  ; XXX FIXME
  ; 16777216. 50 m/  ( -1 -1 )

  dw over_,to_r_,to_r_
  dw d_abs_,r_fetch_,abs_,u_m_slash_mod_
  dw from_r_,r_fetch_,xor_,question_negate_,swap_
  dw from_r_,question_negate_,swap_
  dw exit_

endif

; ----------------------------------------------
  _colon_header star_,'*'


; doc{
;
; *  ( n1|u1 n2|u2 -- n3|u3 )
;
; Multiply n1|u1 by n2|u2 giving the product n3|u3.
;
; Standard: fig-Forth, Forth-79, Forth-83, Forth-94, Forth-2012.
;
; }doc

if 1

  dw m_star_,drop_
  dw exit_

else

  ; XXX TODO -- from DZX-Forth

  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

endif

; ----------------------------------------------
  _colon_header slash_mod_,'/MOD'

; doc{
;
; /mod  ( n1 n2 -- n3 n4 )
;
; Divide _n1_ by _n2_ and leave the remainder _n3_ and quotient
; _n4_.
;
; Standard: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; }doc

  dw to_r_,s_to_d_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header slash_,'/'

; doc{
;
; /  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the quotient _n3_.

; Standard: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : /  ( n1 n2 -- n3 )
;   /mod nip  ;
; ----
;
; }doc

  ; Credits:
  ; Code from Abersoft Forth.

  dw slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header mod_,'MOD'

; doc{
;
; mod  ( n1 n2 -- n3 )
;
; Divide _n1_ by _n2_, giving the single-cell remainder _n3_.

; Standard: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : mod  ( n1 n2 -- n3 )
;   /mod drop  ;
; ----
;
; }doc

  ; Credits:
  ; Code from Abersoft Forth.

  dw slash_mod_,drop_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MOD'

; doc{
;
; */mod  ( n1 n2 n3 -- n4 n5 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; result _d_. Divide _d_ by _n3_ producing the remainder
; _n4_ and the quotient _n5_.

; Standard: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */mod  ( n1 n2 n3 -- n4 n5 )
;   >r m* r> m/  ;
; ----
;
; }doc

  ; Credits:
  ; Code from Abersoft Forth.

  dw to_r_,m_star_,from_r_,m_slash_
  dw exit_

; ----------------------------------------------
  _colon_header star_slash_,'*/'

; doc{
;
; */  ( n1 n2 n3 -- n4 )
;
; Multiply _n1_ by _n2_ producing the intermediate
; _d_. Divide _d_ by _n3_ giving the quotient _n4_.

; Standard: fig-Forth, Forth-79, Forth-94, Forth-2012.
;
; ----
; : */  ( n1 n2 n3 -- n4 )
;   */mod nip  ;
; ----
;
; }doc

  ; Credits:
  ; Code from Abersoft Forth.

  dw star_slash_mod_,nip_
  dw exit_

; ----------------------------------------------
  _colon_header line_to_string_,'LINE>STRING'

; doc{
;
; line>string  ( n1 n2 -- ca len )
;
; Convert the line number _n1_ and the screen number _n2_ to a
; string _ca len_ in the disk buffer containing the data.
;
; Note: in fig-Forth, this word is called `(line)`.
;
; ----
; : line>string  ( n1 n2 -- ca len )
;   >r  c/l b/buf */mod  r> +
;   block + c/l  ;
; ----
; }doc

  ; XXX TODO -- move to the library?
  ; the problem is `located` needs it,
  ; thus it can not be loaded with `need`.

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_
  dw plus_
  dw block_,plus_,c_slash_l_
  dw exit_

; XXX OLD
; ; ----------------------------------------------
;   _colon_header warning_,'WARNING'

; ; doc{
; ;
; ; warning  ( n -- )
; ;
; ; ----
; ; : warning  ( n -- )
; ;   warnings @ if  message  else  drop  then  ;
; ; ----
; ; }doc

;   dw warnings_,fetch_
;   dw question_branch_,message_pfa
;   dw drop_
;   dw exit_


; ----------------------------------------------
  _colon_header dec_dot_,'DEC.'

  dw base_,fetch_,swap_,decimal_,dot_,base_,store_
  dw exit_

; ----------------------------------------------
  _colon_header dot_throw_hash_,'.THROW#'

; doc{
;
; .throw#  ( n -- )
;
; Print the number of throw error _n_.
;
; }doc

  dw paren_dot_quote_
  _string 'Exception #'
  dw dec_dot_
  dw exit_

; ----------------------------------------------
  _defer_header dot_throw_,'.THROW',,dot_throw_hash_

  ; Credits:
  ; Name from MPE Forth for TiniARM.

; doc{
;
; .throw  ( n -- )
;
; Deferred word that prints error message _n_. By default it
; prints only the number.
;
; }doc

; ----------------------------------------------
; XXX OLD -- not used
  ; _colon_header dot_warning_hash_,'.WARNING#'

; ; doc{
; ;
; ; .warning#  ( n -- )
; ;
; ; Print the warning _n_.
; ;
; ; }doc

  ; dw warnings_,fetch_
  ; dw question_branch_,dot_warning_hash.do
  ; dw drop_,exit_

; dot_warning_hash.do:
  ; dw paren_dot_quote_
  ; _string 'Warning #'
  ; dw dec_dot_
  ; dw exit_

; ----------------------------------------------
  _colon_header updated_question_,'UPDATED?'

; doc{
;
; updated?  ( -- f )
;
; Is the current disk buffer marked as modified?
;
; ----
; : updated?  ( -- f )
;   buffer-id 0<  ;
; ----
; }doc

  dw buffer_id_,zero_less_than_
  dw exit_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFERS'

; doc{
;
; empty-buffers  ( -- )
;
; Unassign all block buffers. Do not transfer the contents of
; any updated block to mass storage.
;
; ----
; : empty-buffers  ( -- )
;   $7FFF block disk-buffer !  ;
; ----
; }doc

  _literal buffer_block_id_mask
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_id_,'BUFFER-ID'

; doc{
;
; buffer-id  ( -- x )
;
; Id of the disk buffer.
;
; }doc

  dw disk_buffer_,fetch_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_block_,'BUFFER-BLOCK'

; doc{
;
; buffer-block  ( -- n )
;
; Return the block _n_ associated with the disk buffer.
;
; ---
; : buffer-block  ( -- n )
;   buffer-id $7FFF literal and  ;
; ---
;
; }doc

  dw buffer_id_
  _literal buffer_block_id_mask
  dw and_
  dw exit_

; ----------------------------------------------
  _colon_header free_buffer_,'FREE-BUFFER'

; doc{
;
; free-buffer  ( n -- )
;
; If the current disk buffer has been updated, write its block
; to the disk. Assign block number _n_ to the disk buffer.
;
; ----
; : free-buffer  ( n -- )
;   updated?  if    buffer-block write-buffer
;             then  disk-buffer !  ;
; ----
;
; }doc

;  _chk "free-buffer -- start" ; XXX INFORMER
  dw updated_question_
  dw zero_branch_,free_buffer.end
  dw buffer_block_,write_block_
  dw branch_,free_buffer.end
free_buffer.end:
;  _chk "free-buffer.end" ; XXX INFORMER
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header buffer_,'BUFFER'

; doc{
;
; buffer  ( n -- a )
;
; Assign the block buffer to block _n_.   If the contents of the
; buffer were marked as updated, it is written to the disk.  The
; block _n_ is not read from the disk.  The address _a_ left on
; stack is the first cell in the buffer for data storage.
;
; ----
; : buffer  ( n -- a )
;   dup buffer-block =
;   if  drop  else  (buffer)  then  buffer-data  ;
; ----
;
; }doc

;  _chk "buffer -- start" ; XXX INFORMER
  dw dup_,buffer_block_,equals_
  dw zero_branch_,buffer.not_equals
  ; The requested block is the one already in the buffer.
  dw drop_
  dw branch_,buffer.end
buffer.not_equals:
;  _chk "buffer.not_equals" ; XXX INFORMER
  dw free_buffer_
buffer.end:
;  _chk "buffer.end" ; XXX INFORMER
  dw buffer_data_ ; first cell of data in the buffer
  dw exit_

; ----------------------------------------------
  _colon_header block_,'BLOCK'

; doc{
;
; block  ( n -- a )

; If the block _n_ is already in memory, leave the address _a_
; of the first cell in the disk buffer for data storage.
;
; If the block _n_ is not already in memory, transfer it from
; disk to the buffer.  If the block occupying that buffer has
; been marked as updated, rewrite it to disk before block _n_ is
; read into the buffer.  Finally leave the address _a_ of the
; first cell in the disk buffer for data storage.
;
; ----
; : block ( n -- a )
;   dup buffer-block =
;   if    drop
;   else  save-buffers  dup read-block  disk-buffer !
;   then  buffer-data  ;
; ----
;
; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,block.not_equals
  dw drop_
  dw branch_,block.end
block.not_equals:
;  _brk "block.not_equals" ; XXX INFORMER
  dw save_buffers_,dup_,read_block_
  dw disk_buffer_,store_
block.end:
;  _brk "block.end" ; XXX INFORMER
  dw buffer_data_
  dw exit_

; ----------------------------------------------
  _code_header flip_,'FLIP'

; doc{
;
; flip  ( n1 -- n2 )
;
; Exchange the low and high bytes within _n1_.
;
; Note: This word is called `><` or `cswap` in other Forth
; systems.
;
; }doc

; Credits:
; The name "flip" was taken from eForth.

  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp push_hl

; ----------------------------------------------
  _colon_header sector_id_,'SECTOR-ID'

; XXX UNDER DEVELOPMENT

; doc{

; sector-id  ( n1 -- n2 )

; Convert the sequential disk sector _n1_ to the disk sector id
; _n2_, in the format required by G+DOS: The high byte of _n2_
; is the track (0..79 for side 0; 128..207 for side 1); the low
; byte of _n2_ is the sector (1..10).
;
; ----
; : sector-id  ( n1 -- n2 )
;   \ n2 (high byte) = track 0..79 for side 0, 128..207 for side 1
;   \    (low byte)  = sector 1..10
;   \ track0 = 0..79
;   \ track = 0..207
;   \ side = 0..1
;   dup 10 mod 1+       ( n1 sector )
;   swap dup 20 /       ( sector n1 track0 )
;   swap 10 / 1 and     ( sector track0 side )
;   128                 ( sector track 128 )
;   negate 128 and or   ( sector track )
;   flip or  ;
; ----
;
; }doc

  dw dup_
  _literal 10
  dw mod_,one_plus_,swap_,dup_
  _literal 20
  dw slash_,swap_
  _literal 10
  dw slash_,one_,and_

  dw negate_
  _literal 128
  dw and_,or_

  dw flip_,or_
  dw exit_

; ----------------------------------------------
  _colon_header read_block_,'READ-BLOCK'

; doc{
;
; read-block  ( n -- )
;
; Read disk block _n_ to the buffer.
;
; ----
; : read-block  ( n -- )
;   disk> transfer-block  ;
; ----
;
; }doc

  dw read_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header write_block_,'WRITE-BLOCK'

; doc{
;
; write-block  ( n -- )
;
; Write the buffer to disk block _n_.
;
; ----
; : write-block  ( n -- )
;   >disk transfer-block  ;
; ----
;
; }doc

  dw write_mode_,transfer_block_
  dw exit_

; ----------------------------------------------
  _colon_header transfer_block_,'TRANSFER-BLOCK'

; doc{
;
; transfer-block  ( n -- )
;
; The block-level disk read-write linkage.
; Transfer block _n_ to or from disk.
; The read or write mode must be previously set
; by `>disk` or `disk>`.
;
; }doc

  ; XXX TODO restore the current drive

  dw rec_slash_blk_,star_ ; sequential number of the first sector of the block
  dw dup_
  dw sector_id_
  dw buffer_data_
  dw transfer_sector_

  dw one_plus_,sector_id_

  ; XXX TODO -- benchmark again
  dw buffer_data_,b_slash_rec_,plus_ ; XXX 23768 frames
  ;_literal disk_buffer+cell+bytes_per_sector ; XXX 24425 frames??

  dw transfer_sector_

  dw exit_

; ----------------------------------------------
  _code_header transfer_sector_,'TRANSFER-SECTOR'

; doc{
;
; transfer-sector  ( x a -- )
;
; The sector-level disk read-write linkage.
; Transfer sector _x_ to or from disk.
; The read or write mode must be previously set
; by `>disk` or `disk>`.
;
; x = sector to read or write
;     high byte = track 0..79, +128 if side 1
;     low byte  = sector 1..10
; a = source or destination address
;
; }doc

; XXX TODO -- format the parameters list of the documentation,
; and other similar cases as well

  pop ix ; address
  pop de ; d = track 0..79, +128 if side 1
         ; e = sector 1..10
  push bc ; save the Forth IP
  ld a,2 ; drive
  rst 8 ; G+DOS hook
transfer_sector.command:
  ; G+DOS command already patched:
  db 0x44 ; 0x44 = read ; 0x45 = write
  pop bc ; restore the Forth IP
  ld ix,next
  _jp_next

; ----------------------------------------------
  _colon_header transfer_mode_,'TRANSFER-MODE'

; doc{
;
; transfer-mode  ( b -- )
;
; Set read or write mode for `transfer-sector` and
; `transfer-block`.
;
; b = 0x44 (read) or 0x45 (write)
;
; }doc

  _literal transfer_sector.command
  dw c_store_
  dw exit_

; ----------------------------------------------
  _colon_header write_mode_,'WRITE-MODE'

; doc{
;
; write-mode  ( -- )
;
; Set the write mode for `transfer-sector` and `transfer-block`.
;
; }doc

  _literal 0x45 ; G+DOS write sector command
  dw transfer_mode_
  dw exit_

; ----------------------------------------------
  _colon_header read_mode_,'READ-MODE'

; doc{
;
; read-mode  ( -- )
;
; Set the read mode for `transfer-sector` and `transfer-block`.
;
; }doc

  _literal 0x44 ; G+DOS read sector command
  dw transfer_mode_
  dw exit_

; **************************************************************
; +3DOS

; XXX UNDER DEVELOPMENT

if defined plus3dos and false  ; XXX TMP

back_from_dos:
  ; cy = no error?
  ; a  = error code
  jp c,false_   ; no error

back_from_dos.error:
  ; a = error code
  call convert_dos_error_code
  ; hl = error code
  jp push_hl

convert_dos_error_code:
  ; Input:   a  = original DOS error code (0..36)
  ; Outptut: hl = DOS error code converted to Forth range (-1000..-1036)
  ; XXX TODO use standard codes?
  ; XXX TODO make a Forth word to access this code?
  ld h,0
  ld l,a
convert_dos_error_code.hl:
  ld de,1000
  add hl,de
  jp negate_hl

get_current_drive:
  ld a,0xFF

set_current_drive:
  ; a = drive (ASCII 'A'..'P' to set it; 0xFF to get it)
  ld ix,dos_set_drive
  jr do_dos

get_current_user:
  ld a,0xFF

set_current_user:
  ; a = user (0x00..0x0F to set it; 0xFF to get it)
  ld ix,dos_set_user

; ------------------------------
; DOS call

dos:

  ; Adapted from the ZX Spectrum +3 manual.

  ; IX holds the address of the DOS routine to be run. All other registers are
  ; passed intact to the DOS routine and are returned from it.

  ; Stack must be somewhere in central 32K (conforming to DOS requirements), so
  ; saved AF and BC will not be switched out.

  push af
  push bc                  ; temp save registers while switching
  ld   a,(sys_bankm)       ; RAM/ROM switching system variable
  or   7                   ; want RAM page 7
  res  4,a                 ; and DOS ROM
  ld   bc,bank1_port       ; port used for horiz ROM switch and RAM paging
  di
  ld   (sys_bankm),a       ; keep system variables up to date
  out  (c),a               ; RAM page 7 to top and DOS ROM
  ei
  pop  bc
  pop  af

  ;_border_halt blue_color ; XXX INFORMER
  call call_dos.ix         ; go sub routine address in IX

  push af
  push bc
  ld   a,(sys_bankm)
  and  0F8h                ; reset bits for page 0
  set  4,a                 ; switch to ROM 3 (48 BASIC)
  ld   bc,bank1_port
  di
  ld   (sys_bankm),a
  out  (c),a               ; switch back to RAM page 0 and 48 BASIC
  ei
  pop  bc
  pop  af
  ret

call_dos.ix:

  jp   (ix)                ; standard way to CALL (IX), by calling this jump

; ------------------------------
; DOS call preserving the Forth IP

; This is used when the BC register (the Forth IP) is not a parameter of the
; DOS routine

do_dos:
  ; IX = DOS routine to run
  push bc
  call dos
  pop bc
  ret

; **************************************************************

endif

; ----------------------------------------------
  _colon_header save_buffers_,'SAVE-BUFFERS'

; doc{
;
; save-buffers  ( -- )
;
; If the disk buffer has been modified, transfer its contents to
; disk and mark it as unmodified.
;
; ----
; : save-buffers ( -- )
;   updated? 0= ?exit \ exit if not updated
;   buffer-block dup write-block  disk-buffer !  ;
; ----
;
; Standard: Forth-94.
;
; }doc

  dw updated_question_,zero_equals_ ; not updated?
  dw question_exit_ ; exit if not updated
  ; Updated
  dw buffer_block_,dup_,write_block_
  dw disk_buffer_,store_
  dw exit_

; ----------------------------------------------
  _colon_header set_source_,'SET-SOURCE'

; doc{
;
; set-source  ( ca len -- )
;
; Set the memory zone _ca len_ as the current source by pointing
; the input buffer to it.

; ----
; : set-source  ( ca len -- )
;   input-buffer 2!  >in off  ;
; ----
;
; }doc

  dw input_buffer_,two_store_
  dw to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header string_to_source_,'STRING>SOURCE'

; doc{
;
; string>source  ( ca len -- )
;
; Set the string _ca len_ as the current source.
;
; ----
; : string>source  ( ca len -- )
;   blk off
;   [ ' source-id >body ] literal on
;   set-source  ;
; ----
; }doc

  dw blk_,off_
  _literal source_id_pfa
  dw on_
  dw set_source_
  dw exit_

; ----------------------------------------------
  _colon_header terminal_to_source_,'TERMINAL>SOURCE'

; doc{
;
; terminal>source  ( -- )
;
; Set the terminal as the current source.
;
; ----
; : terminal>source  ( -- )
;   blk off
;   [ ' source-id >body ] literal off
;   tib #tib @ set-source  ;
; ----
;
; }doc

  dw blk_,off_
  _literal source_id_pfa
  dw off_
  dw tib_,number_tib_,fetch_,set_source_
  dw exit_

; ----------------------------------------------
  _colon_header block_to_source_,'BLOCK>SOURCE'

; doc{
;
; block>source  ( +n -- )
; 
; Set block _+n_ as the current source.
;
; ----
; : block>source  ( +n -- )
;   blk !  >in off  ;
; ----
;
; }doc

  dw blk_,store_,to_in_,off_
  dw exit_

; ----------------------------------------------
  _colon_header paren_load_,'(LOAD)'

; doc{
;
; (load)  ( u -- )
;
; XXX TODO -- update
;
; Store the first disk block of screen _u_ into `blk` (thus
; making screen _u_ the input source and setting the input
; buffer to encompass its contents), set `>in` to zero, and
; interpret.  Other stack effects are due to the words loaded.

; This word is a common factor of `load` and `continued`.
;
; ----
; : (load)  ( u -- )
;   block>source interpret  ;
; ----
;
; }doc

  dw block_to_source_,interpret_
  dw exit_

; ----------------------------------------------
  _colon_header load_,'LOAD'

; doc{
;
; load  ( u -- )
;
; XXX TODO update the description
;
; Save the current input-source specification. Store the first
; disk block of screen _u_ in `blk` (thus making screen _u_ the
; input source and setting the input buffer to encompass its
; contents), set `>in` to zero, and interpret. When the parse
; area is exhausted, restore the prior input source
; specification.
;
; An error is issued if _u_ is zero.
;
; ----
; : load  ( u -- )
;   dup 0= 9 ?throw  dup scr !
;   nest-source (load) unnest-source  ;
; ----
;
; }doc

  dw dup_,zero_equals_
  _question_throw error.loading_from_screen_0
  dw dup_,scr_,store_
  dw nest_source_,paren_load_,unnest_source_
  dw exit_

; ----------------------------------------------
  _colon_header next_block_,'-->',immediate

; doc{
;
; -->  ( -- )  \ "next-screen"
;
; Continue interpretation with the next disk screen.
;
; Standard: fig-Forth, Forth-79 (Reference Word Set), Forth-83
; (Controlled Reference Words).
;
; ----
; : -->  ( -- )
;   ?loading  blk @ 1+ block>source  ; immediate
; ----
;
; }doc

  ; XXX TODO -- In Gforth the definition is `refill drop`

  dw question_loading_
  dw blk_,fetch_,one_plus_
  dw block_to_source_
  dw exit_

; ----------------------------------------------
  _colon_header defined_,'DEFINED'

; doc{
;
; defined  ( "name" -- nfa | 0 )
;
; Parse "name" and find its definition.  If the definition is
; not found after searching all the vocabularies in the search
; order, return _ca len_ and _false_.  If the definition is found,
; return its _cfa_, its length byte _b_ and _true_.
;
; ----
; : defined  ( "name" -- nfa | 0 )
;   parse-name find-name  ;
; ----
;
; }doc

  dw parse_name_,find_name_
  dw exit_

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINED'

; doc{
;
; ?defined  ( f -- )
;
; }doc

  ; Credits:
  ; Code from DZX-Forth.

  dw zero_equals_
  _question_throw error.not_found
  dw exit_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

; doc{
;
; [defined]  ( "name" -- wf )
;
; ----
; : [defined]  ( "name" -- wf )
;   defined 0<>  ; immediate
; ----
;
; }doc

  dw defined_,zero_not_equals_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED]',immediate

  ; XXX TODO make this the main word, not `[defined]`, and move
  ; `[defined]` to the library

; doc{
;
; [undefined]  ( "name" -- wf )
;
; ----
; : [undefined]  ( "name" -- wf )
;   [defined] 0=  ; immediate
; ----
;
; }doc

  dw bracket_defined_,zero_equals_
  dw exit_

; ----------------------------------------------
  _colon_header tick_,"'"

; doc{
;
; '  ( "name" -- cfa )
;
; Standard: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : '  ( "name" -- cfa )
;   defined dup ?defined name>  ;
; ----
;
; }doc

  dw defined_,dup_,question_defined_,from_name_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate+compile_only

; doc{
;
; [']  ( "name" -- cfa )
;
; Standard: Forth-83 (Required Word Set), Forth-94 (CORE),
; Forth-2012 (CORE).
;
; ----
; : [']  ( "name" -- cfa )
;   ' postpone literal  ; immediate
; ----
;
; }doc

  dw tick_,literal_
  dw exit_

; ----------------------------------------------
  _colon_header begin_,'BEGIN',immediate+compile_only

; doc{
;
; begin  ( compilation: -- a n )
;
; At compile time `begin` leaves the dictionary address on
; stack with an error checking number _n_.  It does not compile
; anything to the dictionary.
;
; }doc

  dw backward_mark_ ; address to compute the backward branch
  dw exit_

; ----------------------------------------------
  _colon_header then_,'THEN',immediate+compile_only

  ; XXX TODO use an alias

  dw forward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header until_,'UNTIL',immediate+compile_only

  dw compile_,zero_branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header again_,'AGAIN',immediate+compile_only

; doc{
;
; again  ( compilation: a n -- )
;
; End of an infinite loop.  Compile an unconditional jump
; instruction to branch backward to _a_.
;
; }doc

  dw compile_,branch_
  dw backward_resolve_
  dw exit_

; ----------------------------------------------
  _colon_header repeat_,'REPEAT',immediate+compile_only

; doc{
;
; repeat
;
;   Compilation: ( orig dest -- )
;
; Compile `branch` to jump back to `begin`.  Resolve also  the
; branching offset required by `while`.
;
; }doc

  dw again_ ; unconditional branch back to `begin`
  dw then_ ; resolve the forward branching needed by `while`
  dw exit_

; ----------------------------------------------
  _colon_header if_,'IF',immediate+compile_only

; doc{
;
; if  ( Compilation: -- orig ) ( Run-time: x -- )
;
; }doc

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header ahead_,'AHEAD',immediate+compile_only

; doc{
;
; ahead
;   Compilation: ( -- )
;
; Standard: Forth-94, Forth-2012.
;
; }doc

  dw compile_,branch_
  dw forward_mark_
  dw exit_

; ----------------------------------------------
  _colon_header else_,'ELSE',immediate+compile_only

  dw ahead_
  dw swap_
  dw then_
  dw exit_

; ----------------------------------------------
  _colon_header while_,'WHILE',immediate+compile_only

  dw if_
  dw swap_ ; XXX TODO `cs-swap`
  dw exit_

; ----------------------------------------------
  _colon_header spaces_,'SPACES'

; doc{
;
; spaces  ( n -- )
;
; If _n_ is greater than zero, display _n_ spaces.
;
; Standard: fig-Forth, Forth-79, Forth-83 (Required Word Set),
; Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw b_l_,swap_,emits_
  dw exit_

; ----------------------------------------------
  _colon_header emits_,'EMITS'

; doc{
;
; emits  ( c n -- )
;
; If _n_ is greater than zero, display _n_ characters _c_.
;
; }doc

  ; XXX TODO use `?do` or `for` when available
  dw zero_,max_,question_dup_
  dw zero_branch_,emits.end
  dw zero_

  dw paren_do_,emits.loop_exit ; do
  dw dup_,emit_
  dw paren_loop_ ; loop
emits.loop_exit:

emits.end:
  dw drop_
  dw exit_

; ----------------------------------------------
  _colon_header less_hash_,'<#'

  dw pad_,hld_,store_
  dw exit_

; ----------------------------------------------
  _colon_header hash_greater_,'#>'

  dw two_drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw exit_

; ----------------------------------------------
  _colon_header sign_,'SIGN'

; doc{

; sign  ( n  --  )

; If _n_ is negative, add a minus sign to the beginning of the
; pictured numeric output string.
;
; Standard: Forth 94 (CORE), Forth-2012 (CORE).
;
; See: `<#`, `#>`.
;
; ----
; : sign  ( n -- )
;   0< if  [char] - hold  then  ;
; ----
;
; }doc

  dw zero_less_than_
  dw zero_branch_,sign.end
  _literal '-'
  dw hold_
sign.end:
  dw exit_

; ----------------------------------------------
  _code_header to_digit_,'>DIGIT'

; doc{
;
; >digit  ( n -- c )
;
; Convert a number to its character digit: 0..9A..Z.
;
; ----
; : >digit  ( n -- c )
;   dup 9 > [ 'A' '0' - 1+ ] literal and + '0' +  ;
; ----
;
; }doc

  ; Credits:
  ;
  ; Adapted from Z88 CamelForth.

  pop hl
  ld a,l
  cp 10
  jr c,to_digit.end
  add a,7
to_digit.end
  add a,0x30
  ld l,a
  jp push_hl

; ----------------------------------------------
  _colon_header hash_,'#'

; doc{
;
; #  ( d1 -- d2 )
;
; Divide _d1_ by current base.  The remainder is converted to
; an ASCII character and appended to the output text string.
; The quotient _d2_ is left on stack.
;
; ----
; : #  ( d1 -- d2 )
;   base @ ud/mod rot >digit hold  ;
; ----
;
; }doc

  dw base_,fetch_
  dw u_d_slash_mod_,rot_,to_digit_,hold_
  dw exit_

; ----------------------------------------------
  _colon_header u_d_slash_mod_,'UD/MOD'

; : ud/mod ( ud1 u2 -- urem udquot )
;   >r 0 r@ um/mod r> swap >r um/mod r>  ;

  ; XXX TODO benchmark

  ; Credits:
  ;
  ; Code from Abersoft Forth (in fig-Forth this word is called
  ; `m/mod`) and Gforth.

  dw to_r_
  _literal 0
  dw r_fetch_
  dw u_m_slash_mod_
  dw from_r_
  dw swap_
  dw to_r_
  dw u_m_slash_mod_
  dw from_r_
  dw exit_

  _colon_header u_d_slash_mod88_,'UD/MOD88'  ; XXX TMP -- possible alternative

  ; XXX TODO benchmark

  ; Credits:
  ; Code from Z88 CamelForth.

; : ud/mod  ( ud1 u1 -- u2 ud2 )
;   >r 0 r@ um/mod  rot rot r> um/mod rot ;
; : ud/mod  ( ud1 u1 -- u2 ud2 )
;   >r 0 r@ um/mod -rot r> um/mod rot ;

  dw to_r_
  _literal 0
  dw r_fetch_
  dw u_m_slash_mod_
  dw rot_,rot_ ; XXX TODO try `-rot`
  dw from_r_
  dw u_m_slash_mod_
  dw rot_
  dw exit_

; ----------------------------------------------
  _colon_header hash_s_,'#S'

; doc{
;
; #S  ( d1 -- d2 )
;
; }doc

hash_s.begin:
  dw hash_,two_dup_,or_
  dw question_branch_,hash_s.begin
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.R'

; doc{
;
; d.r  ( d n -- )
;
; Print a signed double number _d_ right justified in a field of
; _n_ characters.
;
; }doc

  dw to_r_ ; save n
  ; Save the high order part of d under d,
  ; to be used by `sign` to add a "-" sign to a negative number:
  dw swap_,over_
  dw d_abs_ ; convert d to its absolute value
  ; Convert the absolute value to ASCII text with proper sign:
  dw less_hash_
  dw hash_s_
  dw rot_,sign_
  dw hash_greater_
  dw from_r_ ; retrieve n
  dw over_,minus_,spaces_ ; fill the output field with preceding blanks
  dw type_ ; type out the number
  dw exit_

; ----------------------------------------------
  _colon_header dot_r_,'.R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _colon_header d_dot_,'D.'

; doc{
;
; d.  ( d -- )
;
; Print signed double integer _d_ according to current base,
; followed by only one blank.
;
; }doc

  dw zero_,d_dot_r_,space_
  dw exit_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; .  ( n -- )
;
; Print signed integer _n_ according to current base, followed
; by only one blank.
;
; }doc

  dw s_to_d_,d_dot_
  dw exit_

; ----------------------------------------------
  _colon_header question_,'?'

  dw fetch_,dot_
  dw exit_

; ----------------------------------------------
  _colon_header u_dot_,'U.'

  dw zero_,d_dot_
  dw exit_

; ----------------------------------------------

if 1

  _colon_header dot_s_,'.S'

  ; XXX TMP -- only during the development, then remove
  ; It is already on the disk.

  dw depth_,dup_
  _literal '<'
  dw emit_
  _literal 0
  dw dot_r_
  _literal '>'
  dw emit_

  dw space_
  _literal 1
  dw less_than_
  dw question_branch_,dot_s.end

  dw sp_fetch_,two_minus_,sp0_,fetch_,two_minus_
  dw paren_do_,dot_s.loop_exit ; do
  dw i_,fetch_,dot_ ; XXX TMP `u.`
  dw lit_,-2
  dw paren_plus_loop_ ; loop
dot_s.loop_exit:

dot_s.end:
  dw exit_

endif

; ----------------------------------------------
  _code_header default_colors_,'DEFAULT-COLORS'

; doc{
;
; colors0  ( -- )
;
; Set the screen colors to the default values.
;
; }doc

  ; XXX TODO deactivate inverse mode.

  ; Set the colors and their masks.

  ld hl,(default_color_attribute)
  ; l = 128*flash + 64*bright + 8*paper + ink
  ; h = mask
  ld (sys_attr_p),hl ; permanent
  ld (sys_attr_t),hl ; temporary

  ; Set the system variable that holds the attributes of the
  ; lower part of the screen.  It is needed only because G+DOS
  ; by default changes the border color during disk operations,
  ; and at the end restores it with the value of this system
  ; variable.

  ld a,l
  ld (sys_bordcr),a ; lower screen colors

  ; Set the border color to the paper color.

  ; a = 128*flash + 64*bright + 8*paper + ink
  and a ; cy=0
  rra
  rra
  rra ; a = paper
  out(0xFE),a ; set the border color

  _jp_next

; ----------------------------------------------
  _code_header paren_mode32_home_,'(MODE32-HOME)'

; doc{
;
; (mode32-home)  ( -- )
;
; Behaviour of `home` in `mode32`.
;
; }doc

if 0

  ; XXX OLD -- This method works only with the default ROM
  ; printing routines.

  ld hl,0x1821 ; 0x18 = 24 - row
               ; 0x21 = 33 - column
  ld (sys_s_posn),hl
  _jp_next

endif


if 1

  ; XXX NEW -- This method works with any printing routine
  ; associated to a chanel.

  ld a,at_char
  rst 0x10
  xor a
  rst 0x10
  xor a
  rst 0x10
  _jp_next

endif

if 0

  ; XXX TODO -- adapt this from DZX-Forth?
  ; same size, but slower

  ld hl,0x0000
  push hl
  push hl

  jp at_xy_
  ; XXX OLD
;  ld hl,at_xy_
;  jp next2

endif

; ----------------------------------------------
  _defer_header home_,'HOME',,paren_mode32_home_

; doc{
;
; home  ( -- )
;
; Set the cursor position at the top left position (column 0,
; row 0).
;
; }doc

; ----------------------------------------------
  _code_header cls_,'CLS'

; doc{
;
; cls  ( -- )
;
; Clear the screen with the current colors and reset the cursor
; position to the upper left corner (column 0, row 0).
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

; Credits:
; The attributes part was improved after code by Dean Belfield
; <http://wordpress.animatez.co.uk/programming/assembly-language/z80/z80-library-routines/204-2/>.
; The idea for `ld (hl),l` was found in David Webb's _Advanced
; Spectrum Machine Language_.

  exx ; save the Forth IP
  ; Erase the bitmap.
  ld hl,sys_screen
  ld de,sys_screen+1
  ld bc,sys_screen_bitmap_size
  ld (hl),l ; l=0 because sys_screen=0x4000
  ldir
  ; Color with the permanent attributes.
  ld bc,sys_screen_attributes_size-1
  ld a,(sys_attr_p)
  ld (hl),a
  ldir
  ld (sys_coords),bc ; reset the graphic coordinates
  exx ; restore the Forth IP

; XXX OLD -- can not work anymory because `home`is deferred
; XXX NEW -- it works with the new version of `defer`.
; XXX TODO -- try
  jp home_pfa ; continue at `home`
; XXX NEW
; XXX OLD
;  ld hl,home_
;  jp next2

  ; The Z80 version above uses 29 bytes;
  ; the following Forth version uses 30 bytes:

  ; _colon_header cls_,'CLS'
  ; dw lit_,sys_screen,lit_,sys_screen_bitmap_size,erase
  ; dw lit_,sys_screen_attributes,lit_,sys_screen_attributes_size
  ; dw lit_,sys_attr_p,c_fetch_,fill_
  ; dw home_
  ; dw semicolon_s

; ----------------------------------------------
  _colon_header page_,'PAGE'

; doc{
;
; page  ( -- )
;
; Move to another page for output.  On a terminal, `page` clears
; the screen and resets the cursor position to the upper left
; corner. On a printer, `page` performs a form feed.
;
; Standard: Forth-94.
;
; }doc

  dw printing_,fetch_
  dw zero_branch_,page.display
  _literal form_feed_char
  dw emit_
  dw exit_

page.display
  dw cls_
  dw exit_

; ----------------------------------------------
  _code_header paren_bye_,'(BYE)'

  ld (iy+sys_df_sz_offset),0x02 ; restore lines of the lower screen

  im 1 ; interrupt mode 1, normal situation of the OS

system_stack_pointer: equ $+1
  ld sp,0 ; restore the system stack

; The Complete Spectrum ROM Disassembly
; (http://www.worldofspectrum.org/infoseekid.cgi?id=2000076),
; page 201, states:
;
; For a successful return to BASIC, H'L' must on exit from the
; machine code contain the address in SCANNING of the 'end-calc'
; instruction, 2758 hex (10072 decimal).

  ld hl,0x2758
  exx

  ; Exit to BASIC:
  rst 0x08
  db 0x08 ; "STOP" BASIC error

; ----------------------------------------------
  _defer_header default_mode_,'DEFAULT-MODE',,noop_

; doc{
;
; default-mode  ( -- )
;
; Activate the default screen mode. It's set to `noop` until the
; first mode change is done. Then it's vectored to `mode32`.
; It's used by `bye`.
;
; }doc

; ----------------------------------------------
  _colon_header bye_,'BYE'

  dw current_mode_,fetch_
  dw previous_mode_,store_
  dw default_mode_
  dw paren_bye_
  ; No return from `(bye)`.

; ----------------------------------------------
  _code_header two_drop_,'2DROP'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWAP'

; doc{
;
; 2swap  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
;
; }doc

  ; Credits:
  ; Code adapted from Z88 CamelForth

                      ; T   B
                      ; --- --
  exx                 ;  04 01
  pop hl  ; hl'=x4    ;  10 01
  pop de  ; de'=x3    ;  10 01
  exx                 ;  04 01
  pop hl  ; hl=x2     ;  10 01
  pop de  ; de=x1     ;  10 01
  exx                 ;  04 01
  push de ; x3        ;  11 01
  push hl ; x4        ;  11 01
  exx                 ;  04 01
  jp push_hlde        ;  10 03
                      ;  11 00 push de
                      ;  11 00 push hl
                      ; --- --
                      ; 110 13 TOTAL

; ----------------------------------------------
  _variable_header limit_,'LIMIT'

; doc{
;
; limit  ( -- a )
;
; Variable that holds the address above the highest address
; usable by the region addressed by `here`.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header unused_,'UNUSED'

; doc{
;
; unused ( -- u )
;
; Return the amount of space remaining in the region addressed
; by `here`, in address units.
;
; Standard: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
;
; }doc

  dw limit_,fetch_,here_,minus_
  dw exit_

; ----------------------------------------------
  _colon_header where_,'WHERE'

  ; XXX TMP -- needed only during the development
  ; XXX TODO -- remove; already copied to the disk

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw exit_

where.do_it:
  dw dup_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_,dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  _literal '^'
  dw emit_
  dw exit_

; ----------------------------------------------
  _colon_header paren_mode32_at_xy_,'(MODE32-AT-XY)'

; doc{

; (mode32-at-xy) ( col row -- )
;
; Default behaviour of `at-xy`, in mode 32.
;
; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

  ; Credits:
  ; Code adapted from Spectrum Forth-83.

  dw dup_
  _literal 23
  dw not_equals_ ; not the last row?
  dw zero_branch_,at_pfa.last_line
  ; not the last row
  dw lit_,22,paren_mode32_emit_,paren_mode32_emit_,paren_mode32_emit_
  dw exit_ ; XXX TODO exit_

at_pfa.last_line:
  dw one_minus_,dup_,paren_mode32_emit_,paren_mode32_emit_,zero_,paren_mode32_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  _literal 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw exit_

; ----------------------------------------------
  _defer_header at_xy_,'AT-XY',,paren_mode32_at_xy_

; doc{
;
; at-xy ( col row -- )
;
; Standard: Forth-94 (FACILITY), Forth-2012 (FACILITY).
;
; }doc

; ----------------------------------------------
  _colon_header paren_mode32_xy_,'(MODE32-XY)'

; doc{
;
; (mode32-xy)  ( -- col row )

; Return the current column and row, in mode 32.
;
; ----
; : (mode32-xy)  ( -- row col )
;   24 23689 c@ -
;   33 23688 c@ - dup 32 = if  drop 1+ 0  then  ;
; ----
;
; }doc

  ; Credits:
  ; Code from the Spectrum Forth-83 manual.

  _literal 24
  _literal sys_s_posy
  dw c_fetch_,minus_
  _literal 33
  _literal sys_s_posx
  dw c_fetch_,minus_
  dw dup_
  _literal 32 ; XXX TODO -- chars per line in the current mode
  dw equals_
  dw zero_branch_,paren_mode32_xy.end
  dw drop_,one_plus_
  _literal 0
paren_mode32_xy.end:
  dw exit_

; ----------------------------------------------
  _defer_header xy_,'XY',,paren_mode32_xy_

; doc{
;
; xy ( -- col row )
;
; Return the current column and row of the text cursor.
;
; }doc

; ----------------------------------------------
  _code_header border_,'BORDER'

  pop hl
  ld a,l
  out (border_port),a

  ; The system variable that holds the attributes of the lower
  ; part of the screen, unnecessary in Solo Forth, must be
  ; updated.  The reason is G+DOS, after disk operations that
  ; make the border change, restores the border color with the
  ; value of this system variable.  We use the border color as
  ; paper and set a a contrast ink (black or white), to make
  ; sure the lower part of the screen is usable after returning
  ; to BASIC.

  ; XXX TODO move the contrast ink calculation to `bye` or
  ; simply remove it:

  cp 4 ; cy = dark color (0..3)?
  ld a,7 ; white ink
  jr c,border.end
  xor a ; black ink

border.end:
  ; Note: slower than shifting the register, but saves three bytes.
  add hl,hl
  add hl,hl
  add hl,hl ; l = paper (bits 3..5)
  or l ; combine with ink
  ld (sys_bordcr),a
  _jp_next

; ----------------------------------------------
  _code_header overprint_,'OVERPRINT'

  ld a,over_char
  jr color

; ----------------------------------------------
  _code_header flash_,'FLASH'

  ld a,flash_char
  jr color

; ----------------------------------------------
  _code_header inverse_,'INVERSE'

  ld a,inverse_char
  jr color

; ----------------------------------------------
  _code_header bright_,'BRIGHT'

  ld a,bright_char
  jr color

; ----------------------------------------------
  _code_header paper_,'PAPER'

  ld a,paper_char
  jr color

; ----------------------------------------------
  _code_header ink_,'INK'

  ld a,ink_char

color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or
  ; overprint).
  ; Input:
  ;   a = attribute control char
  ;   (tos) = color attribute value
  rst 0x10
  pop hl
  ld a,l
  rst 0x10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTANT'

  dw create_,two_comma_
  dw paren_semicolon_code_
do_two_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header two_variable_,'2VARIABLE'

; doc{
;
; 2variable ( "name" -- )
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve two consecutive
; cells of data space.
;
;    _name_ is referred to as a two-variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the first (lowes address) cell of two
;    consecutive cells. A program is responsible for
;    initializing the contents.
;
; Standard: Forth-94.
;
; }doc

  dw create_
  dw branch_,two_comma.allot

; ----------------------------------------------
  _colon_header u_dot_r_,'U.R'

  dw to_r_,zero_,from_r_,d_dot_r_
  dw exit_

; ----------------------------------------------
  _code_header two_over_,'2OVER'

; doc{
;
; 2over  ( d1 d2 -- d1 d2 d1 )
;
; }doc

  ld hl,4
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _code_alias_header unnest_,'UNNEST',,r_drop_

  ; XXX NEW -- experimental

  ; Credits:
  ; http://dxforth.netbay.com.au/unnest.html

if 0 ; XXX OLD

; ----------------------------------------------
  _code_header semicolon_s_,';S'

; doc{
;
; ;s  ( -- )
;
; Return execution to the calling definition.  Unnest one level.
;
; It is used to stop interpretation of a screen. It is also the
; run-time word compiled at the end of a colon-definition which
; returns execution to the calling procedure.

; Standard: fig-Forth.
;
; }doc

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _colon_header exit_,'EXIT',compile_only

; doc{
;
; exit  ( -- ) ( R: nest-sys -- )

; Return control to the calling definition, specified by
; _nest-sys_.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  dw r_drop_
  dw exit_

; ----------------------------------------------
  _colon_header question_exit_,'?EXIT',compile_only

; doc{
;
; ?exit  ( f -- ) ( R: a | -- a | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by the address on the return stack.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; }doc

  dw question_branch_,exit_pfa
  dw exit_

else ; XXX NEW

; ----------------------------------------------
  _code_header exit_,'EXIT'

; doc{
;
; exit  ( -- ) ( R: nest-sys -- )

; Return control to the calling definition, specified by
; _nest-sys_.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; In Solo Forth `exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; Standard: Forth-94 (CORE), Forth-2012 (CORE).
;
; }doc

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header question_exit_,'?EXIT'

; doc{
;
; ?exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by _nest-sys_.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; In Solo Forth `?exit` can be used in interpretation mode to
; stop the interpretation of a block.
;
; }doc

  pop hl
  ld a,h
  or l
  jp nz,exit_pfa
  _jp_next

endif

; ----------------------------------------------
  _colon_header catch_,'CATCH'

; doc{

; catch  ( cfa -- 0 | err# )

; Push an exception frame on the exception stack and then
; execute _cfa_ (as with `execute`) in such a way that control
; can be transferred to a point just after `catch` if `throw` is
; executed during the execution of _cfa_.
;
; If the execution of _cfa_ completes normally (i.e., the
; exception frame pushed by this `catch` is not popped by an
; execution of `throw`) pop the exception frame and return zero
; on top of the data stack, above whatever stack items would
; have been returned by the execution of _cfa_. Otherwise, the
; remainder of the execution semantics are given by `throw`.
;
; Standard: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).

;----
; : catch  ( xt -- exception# | 0 )
;   sp@ >r          ( cfa ) \ save data stack pointer
;   catcher @ >r    ( cfa ) \ save previous catcher
;   rp@ catcher !   ( cfa ) \ set current catcher
;   execute         ( )     \ `execute` returns if no `throw`
;   r> catcher !    ( )     \ restore previous catcher
;   r> drop         ( )     \ discard saved stack pointer
;   0  ;            ( 0 )   \ normal completion, no error
;----
; }doc

  ; Credits:
  ; Code from DZX-Forth and MPE Forth for TiniARM.

  dw sp_fetch_,to_r_ ; save data stack pointer
  dw catcher_,fetch_,to_r_ ; save previous catcher
  dw rp_fetch_,catcher_,store_ ; set current catcher
  dw execute_ ; `execute` returns if no `throw`
  dw from_r_,catcher_,store_  ; restore error frame
  dw from_r_,drop_ ; discard saved stack pointer
  _literal 0  ; normal completion, no error
  dw exit_

; ----------------------------------------------
  _colon_header throw_,'THROW'

  ; Credits:
  ; Code from DZX-Forth.
  ; Comments from MPE Forth for TiniARM.

; doc{
;
; throw  ( n -- )
;
; Standard: Forth-94 (EXCEPTION), Forth-2012 (EXCEPTION).
;
; ----
; : throw  ( n -- )
;   ?dup if
;     catcher @ ?dup 0=   \ no catcher?
;     if  error  then     \ `error` does not return
;     rp!                 \ restore previous return stack
;     r> catcher !        ( n )  \ restore previous catcher
;     r> swap >r          ( saved-sp ) ( R: n )
;     sp! drop r>         ( n )  \ restore stack
;     \ Return to the caller of `catch` because return stack is
;     \ restored to the state that existed when `catch` began
;     \ execution.
;   then  ;
; ----
;
; }doc

  dw question_dup_
  dw zero_branch_,throw.end
  dw catcher_,fetch_,question_dup_  ; catcher?
  dw question_branch_,throw.catcher ; if so, branch
  dw error_ ; no return from `error`.

throw.catcher:
  dw rp_store_                ; restore previous return stack
  dw from_r_,catcher_,store_  ; ( n )  restore previous catcher
  dw from_r_,swap_,to_r_      ; ( saved-sp ) ( R: n )
  dw sp_store_,drop_,from_r_  ; ( n )  restore stack

  ; Return to the caller of `catch` because return stack is
  ; restored to the state that existed when `catch` began
  ; execution.

throw.end:
  dw exit_

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT)'

  dw sp0_,fetch_,sp_store_
  dw boot_  ; XXX TODO -- not here?
  dw quit_

; ----------------------------------------------
  _colon_header abort_,'ABORT'

  _literal -1
  dw throw_
  dw exit_

; ----------------------------------------------
  _colon_header char_,'CHAR'

  dw parse_name_,drop_,c_fetch_
  dw exit_

; ----------------------------------------------
  _colon_header bracket_char_,'[CHAR]',immediate+compile_only

  dw char_,literal_
  dw exit_

; ----------------------------------------------
  _colon_header s_quote_,'S"',immediate

  ; : s"  ( compilation: "text<">" -- ) ( run-time:  -- ca len )
  ;  [char] " parse-string  ; immediate

  _literal '"'
  dw parse_string_
  dw exit_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

; doc{
;
; ?\  ( f "text" -- )
;
; If _f_ is not false, parse and discard the rest of the parse
; area.  This word is used for conditional compilation.
;
; }doc

  ; XXX TODO move to the library?

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw exit_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

; doc{
;
; \  ( "text" -- )
;
; Parse and discard the rest of the parse area.
;
; Standard: Forth-94 (BLOCK EXT), Forth-2012 (BLOCK EXT).
;
; }doc

  dw loading_question_ ; input stream from disk?
  dw question_branch_,backslash.loading
  ; Interpreting
  dw span_,fetch_ ; XXX TODO -- use `#tib` instead?
;  _chk '\ tib -- before updating >in' ; XXX INFORMER
  dw to_in_,store_
  dw exit_

backslash.loading:
  ; Loading
  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
;  _chk '\ disk -- before updating >in' ; XXX INFORMER
  dw parsed_
  dw exit_

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .(  ( 'text<paren>' -- )  \ immediate
;
; }doc

  _literal ')'
  dw parse_,type_
  dw exit_

latest_nfa_in_forth_voc: equ dot_paren_nfa

dictionary_pointer_after_cold:

; ==============================================================
; Name and link fields

move_name_fields_to_memory_bank:

  ; Move the name fields, assembled in ordinary memory, to the
  ; names bank. This routine is needed only once, therefore its
  ; call is patched with `noop` at the end; the routine itself
  ; will be overwritten by the Forth dictionary.

  ; The whole screen is used as intermediate buffer for copying
  ; the data.

  ld hl,names_bank_address ; origin
  ld de,sys_screen ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the data to the screen
  call bank.names
  ld hl,sys_screen ; origin
  ld de,names_bank_address ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the name fields to the bank
  call bank.default

  ; Remove the call to this routine:
  ld hl,only_first_cold ; address of the call to this routine
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  ret

  org names_bank_address

  db 0 ; fake length byte, needed by the algorithm used in `>name`

; ==============================================================
; End

end cold_entry

; ==============================================================
; Debug tools

; dw lit_,2,border_,key_,drop_,lit_,7,border_ ; XXX INFORMER
; dw lit_,0,border_,key_,drop_ ; XXX INFORMER
; dw lit_,1,border_,key_,drop_ ; XXX INFORMER
; dw lit_,2,border_,key_,drop_ ; XXX INFORMER
; dw lit_,4,border_,key_,drop_ ; XXX INFORMER
; dw lit_,5,border_,key_,drop_ ; XXX INFORMER
; dw lit_,6,border_,key_,drop_ ; XXX INFORMER
; dw lit_,7,border_,key_,drop_ ; XXX INFORMER

; dw two_dup_,two_,ink_,type_,zero_,ink_ ; XXX INFORMER

; ==============================================================
; Development notes
;
; 2015-06-25:
;
; Number  Times compiled (not including error numbers)
; 0       20
; 1       11
; 2       11
; 3       6

; vim: ft=z80
