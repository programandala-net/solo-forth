  \ 000.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Block 0 of the library, which by convention can not be
  \ loaded, and which is used only for credits and information.

( Solo Forth library )

\ http://programandala.net/en.program.solo_forth.html

  \ vim: filetype=soloforth
  \ 001.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111423

  \ -----------------------------------------------------------
  \ Description

  \ Block 1 of the library, which is used to load the user
  \ application. By default it loads block 2, which contains
  \ the `need` utility.

(  )

2 load

  \ XXX TMP -- for debugging `associative-list`
  \ need associative-list
  \ exit

  \ XXX TMP -- for debugging the floating point ROM
  \ implementation
  \ need order
  \ need fmax
  need --fp-rom--
  100 s>f  200 s>f  300 s>f

  \ XXX TMP -- for debugging the G+DOS support
  \ need plusd-in  need plusd-in,

  \ XXX TMP -- for debugging the tape support
  \ need write-tape-file
  \ : savescr 16384 6912 s" screen" write-tape-file  ;
  \ : savetxt s" TEXT" s" txt" write-tape-file  ;
  \ hex  ' (write-tape-file) u.

  \ XXX TMP --
  \ need 8-bit-random-pix-benchmarks  exit

  \ XXX TMP --
  \ need wordlist-words  need order
  \ need bench{  need indexer
  \ : iw  ( -- )  index-wordlist wordlist-words  ;

  \ vim: filetype=soloforth
  \ 002.need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604031848

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the library dependencies.
  \ It must be at block 2 of the library.
  \
  \ The utility consists of words `need`, `needed`, `reneed`
  \ and `reneeded`. All of them are deferred words. Their
  \ default behaviour is set by `set-located-need`: locate the
  \ required word searching the blocks of the library.
  \
  \ An alternative faster behaviour is provided by the
  \ `indexer` tool, in other module.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( contains delimited located )

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does string _ca1 len1_ contain string _ca2 len2_?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited   ( ca1 len1 -- ca2 len2 )
  \
  \ Add one leading space and one trailing space to string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
      contains if  2drop i unloop exit  then
      break-key? ?leave
  loop  2drop 0  ;

  \ doc{
  \
  \ located  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (but surrounded by spaces), and return its number. If
  \ not found, return zero.  The search is case-sensitive.
  \
  \ }doc

-->

( ?located locate from reneeded reneed )

: ?located  ( block | 0 -- )  dup 0= #-268 ?throw  ;

  \ XXX FIXME -- the word shown by the exception may have been
  \ overwritten in the circular string buffer.

  \ doc{
  \
  \ ?located ( f -- )
  \
  \ If f is zero, throw an exception -268 ("required, but not
  \ located").
  \
  \ }doc

: locate  ( "name" -- block | 0 )
  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- block | 0 )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

: from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268
  \ ("required, but not located").
  \
  \ This word is intended to prevent undesired matches clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker.
  \
  \ Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures== need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

defer reneeded  ( ca len -- )

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Load the first block whose header contains the string _ca
  \ len_ (surrounded by spaces).  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneeded`.
  \
  \ }doc

: locate-reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ locate-reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (but surrounded by spaces), and load it. If not found,
  \ throw an exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

defer reneed  ( "name" -- )

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Load the first block whose header contains "name" (but
  \ surrounded by spaces).
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneed`.
  \
  \ }doc

: locate-reneed  ( "name" -- )
  parse-name save-string reneeded  ;

  \ doc{
  \
  \ locate-reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name" (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

-->

( needed-word [needed] [unneeded] )

2variable needed-word

  \ XXX TODO -- make `[needed]` and `[unneeded]` optional.

: [needed]  ( "name" -- wf )
  parse-name needed-word 2@ 2dup or
  if  compare 0=  exit  then  2drop 2drop true   ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- wf )
  \
  \ Is "name" the needed word specified by the last execution
  \ of `need` or `needed`?
  \
  \ }doc

: [unneeded]  ( "name" -- wf )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- wf )
  \
  \ Is "name" different than the needed word specified by the
  \ last execution of `need` or `needed`?
  \
  \ }doc

: new-needed-word  ( ca len -- ca len )
  -trailing -leading save-string 2dup needed-word 2!  ;

-->

( needed need )

defer needed  ( ca len -- )

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, load the first block of the
  \ library where "name" is included in the block header
  \ (but surrounded by spaces).
  \ If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-needed`.
  \
  \ }doc

: locate-needed  ( ca len -- )
  \ cr ." need " 2dup type  \ XXX INFORMER
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ locate-needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

defer need  ( "name" -- )

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (but surrounded by spaces), and load it.
  \ If not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-need`.
  \
  \ }doc

: locate-need  ( "name" -- )  parse-name needed  ;

  \ doc{
  \
  \ locate-need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (but surrounded by spaces), and load it.
  \ If not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is the default behaviour of the deferred word `need`.
  \
  \ }doc

: set-located-need  ( -- )
  ['] locate-reneeded ['] reneeded  defer!
  ['] locate-reneed   ['] reneed    defer!
  ['] locate-need     ['] need      defer!
  ['] locate-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-located-need  ( -- )
  \ 
  \ Set the default behaviour of `need`, `needed`, `reneed` and
  \ `reneeded`: Use `locate` for searching the library.
  \
  \ The alternative, provided by the optional `indexer` tool,
  \ is set by `set-indexed-need`.
  \
  \ }doc

set-located-need

blk @ 1+ dup default-first-locatable !  first-locatable !

  \ vim: filetype=soloforth
  \ assembler.macro.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111350

  \ -----------------------------------------------------------
  \ Description

  \ `macro` and `endm`, compatible with any assembler.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2016-04-11: Extracted from the assemblers `z80-asm` and
  \ `z80-asm,`. The code was identical in both of them and it
  \ can be useful without an assembler.

( macro )

need get-order

get-order get-current

only forth definitions  also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

set-current  set-order

  \ vim: filetype=soloforth

  \ assembler.tools.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604091523

  \ -----------------------------------------------------------
  \ Description

  \ Z80 assembler tools, independent from the actual assembler.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( << >> )

  \ For dumping assembled code to screen.

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

  \ vim: filetype=soloforth

  \ assembler.z80-asm-comma.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.

  \ Last modified: 201604130136

  \ -----------------------------------------------------------
  \ Description

  \ A alternative Z80 assembler, called `z80-asm,`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015-12-25: First changes:
  \
  \ 1. "," suffixes in Z80 instructions; 2. one single set of
  \ conditions; 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module.  Fixed `execute-hl`,
  \ then renamed it and `call-xt` with a trailing comma, to
  \ avoid loading them instead of the versions written for the
  \ first assembler.

  \ -------------------------------------------------------------
  \ XXX TODO

  \ - combine changes 2..4 with the previous version.
  \ - rename `|mark` and `|resolve`.
  \ - remove all "retCOND" and "callCOND" and "jpCOND"
  \   (or make them optional.
  \ - make absolute-jump control structures optional.
  \ - `get-order` at the start and `set-order` at the end.

( z80-asm, )

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm, )

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  create c, does>  ( -- )  ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- )
  create , does>  ( -- )  ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;
  \ Relative jumps.

-->

( z80-asm, )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 20 m9 jrnz,
22 m5 sthl, 27 m1 daa, 28 m9 jrz, 2A m5 fthl, 2F m1 cpl, 30 m9
jrnc, 32 m5 sta, 37 m1 scf, 38 m9 jrc, 3A m5 fta, 3F m1 ccf, 76
m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98 m2 sbc, B8 m2 cp,
C1 m3 pop, C2 m5 jpnz, C3 m5 jp, C5 m3 push, C6 m4 add#, C7 m2
rst, C9 m1 ret, CA m5 jpz, CD m5 call, CE m4 adc#, D2

-->

( z80-asm, )

  \ Opcodes

m5 jpnc, D3 m4 out, 41 m3 outbc, D6 m4 sub#, D9 m1 exx, DA m5
jpc, DB m4 in, 40 m3 inbc, 0DE m4 sbc#, E2 m5 jppo, E3 m1
exsp, E6 m4 and#, E9 m1 jphl, EA m5 jppe, EB m1 exde, EE m4
xor#, F2 m5 jpp, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FA m5 jpm,
FB m1 ei, FE m4 cp#, 00 m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6
rr, 20 m6 sla,  28 m6 sra, 38 m6 srl,  40 m7 bit, 80 m7 res, C0
m7 set, B0ED m8 ldir, B8ED m8 lddr, 44ED m8 neg, 57ED m8 ldai,
47ED m8 ldia, 56ED m8 im1 5EED m8 im2 B1ED m8 cpir, 6FED m8
rld,

-->

( z80-asm, )

  \ Opcodes

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ldp#,  ;
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;

  \ ZX Spectrum specific

CF m4 hook, \ rst 0x08
D7 m1 prt,  \ rst 0x16

-->

( z80-asm, )

  \ Index register opcodes

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, )

  \ Conditions

  \ Conditions are Z80 opcodes for the required jump
  \ instruction.
  \
  \ Example: `z aif` compiles a `jp nz`, so `z` is the code for
  \ `jp nz`.
  \
  \ Control structures that compile relative jumps modify the
  \ opcode accordingly. Example: `z rif` compiles a `jr nz`,
  \ while `z aif` compiles a `jp nz`.

C2 constant z  CA constant nz D2 constant cy DA constant nc
E2 constant pe EA constant po F2 constant ne  FA constant p

  \ XXX FIXME -- condition `m` has been renamed to `ne` because
  \ of the register `m`; but maybe all registers should be
  \ renamed.

  \ XXX TODO -- ne->ns and p->ps?

  \ XXX TODO -- add a "?" suffix and use the original names `c`
  \ and `m`: z?, nz?, c?, nc?, pe?, po?, m?, p?.

: jp>jr  ( op1 -- op2 )  dup nc > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

-->

( z80-asm, )

  \ Conditional ret and call

  \ Conditional ret

: ?ret,  ( op -- )  8 xor 2- c,  ;

: retc,   ( -- )  cy ?ret,  ;    : retnc,  ( -- )  nc ?ret,  ;
: retz,   ( -- )   z ?ret,  ;    : retnz,  ( -- )  nz ?ret,  ;
: retm,   ( -- )  ne ?ret,  ;    : retp,   ( -- )   p ?ret,  ;
: retpe,  ( -- )  pe ?ret,  ;    : retpo,  ( -- )  po ?ret,  ;

  \ Conditional call

: ?call,  ( a op -- )  8 xor 2+ c, ,  ;

: callc,   ( -- )  cy ?call,  ;
: callnc,  ( -- )  nc ?call,  ;
: callz,   ( -- )   z ?call,  ;
: callnz,  ( -- )  nz ?call,  ;
: callm,   ( -- )  ne ?call,  ;
: callp,   ( -- )   p ?call,  ;
: callpe,  ( -- )  pe ?call,  ;
: callpo,  ( -- )  po ?call,  ;

-->

( z80-asm, )

  \ Control structures with relative jumps

  \ XXX TODO -- document
  \ XXX TODO -- rename `rel...` to `r...`

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, )

  \ Control structures with relative jumps

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.
  \ XXX TODO -- rename to `rahead`.

: rif  ( op -- orig cs-id )  jp>jr , >relmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: relse  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`

( z80-asm, )

  \ Control structures with absolute jumps

  \ XXX TODO document

: aif  (  op -- orig cs-id )  c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ C3 = opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm, )

  \ Last opcodes and macros

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and,  B0 m2 or,  A8 m2 xor,

  \ Macro, 16-bit subtract:
: subp,  ( rp -- )  a and sbcp,  ;

  \ Macro to test 16-bit register for zero:
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;

-->

( z80-asm, )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

decimal only forth definitions

( execute-hl, call-xt, )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm,  need macro

macro execute-hl,  ( -- )
  0000 bc stp,  |mark  \ save the Forth IP
  0000 bc ldp#, |mark  \ point IP to phony_compiled_word
  jphl,          \ execute the xt in HL
  >resolve \ phony_compiled_word
  here cell+ ,      \ point to the phony xt following
  0000 bc ldp#  |resolve  \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt,  ( xt -- )
  hl ldp#,  execute-hl,
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ assembler.z80-asm.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604130136

  \ -----------------------------------------------------------
  \ Description

  \ A Z80 assembler called `z80-asm`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015: Adapted from Afera. Main development.
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module. Fixed `execute-hl`.

( z80-asm )

  \ XXX TODO -- `get-order` here and `set-order` at the end.

  \ .( in z80-asm latest is ) latest .name cr key drop
  \ XXX INFORMER

only forth definitions

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm )

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm )

  \ Opcodes

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm )

  \ Index register opcodes

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm )

  \ Conditional ret and call

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm )

  \ Control structures with relative jumps

  \ XXX TODO -- document
  \ XXX TODO -- rename `rel...` to `r...`

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm )

  \ Control structures with absolute jumps

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm )

  \ Last opcodes and macros

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

decimal only forth definitions

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm  need macro

macro execute-hl  ( -- )
  0000 bc stp  |mark  \ save the Forth IP
  0000 bc ldp# |mark  \ point IP to phony_compiled_word
  jphl          \ execute the xt in HL
  >resolve \ phony_compiled_word
  here cell+ ,      \ point to the phony xt following
  0000 bc ldp#  |resolve  \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt  ( xt -- )
  hl ldp#  execute-hl
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ benchmark.byte-magazine.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ BYTE Magazine benchmark.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( do-prime )

  \ Credit:
  \
  \ Eratosthenes Sieve Prime Number program in Forth
  \ by Jim Gilbreath, BYTE Magazine, 1981-09, page 190.

forth definitions decimal

8190 constant size  variable flags  size allot

: do-prime  ( -- )
  flags size 1 fill
  0 size 0
  do flags i + c@
     if i dup + 3 + dup i +
          begin   dup size <
          while   0 over flags + c! over +
          repeat  drop drop 1+
     then
  loop  .  ." primes "  ;

( byte-magazine-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).
  \
  \ 2015-12-24. Modified: no printing.

need bench{

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop
  \ u. ." PRIMES" cr  \ XXX OLD
  drop  \ XXX NEW
  ;  -->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( n -- )
  cr dup u. ." iterations..." cr
  bench{ 0 ?do  do-prime  loop }bench.  ;

  cr
  \  <------------------------------>
  .( To run the BYTE Magazine) cr
  .( benchmark type:) cr
  .(   n byte-magazine-benchmark) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 1000 iterations.) cr


  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       -----         -----
  \ 00010  6397          5216
  \ 00100 63970 (1.00)  52159 (0.81)

  \ 2016-03-16
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 00001                    517
  \ 00010                   5164
  \ 00100 52161 (1.00)     51635 (0.98)
  \
  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ benchmark.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Generic benchmarking tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in the file <development_benchmarks.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( bench{ }bench }bench. bench. benched )

  \ Credit:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

( all-benchmarks )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

  \ vim: filetype=soloforth
  \ benchmark.interface-age.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Interface-Age benchmark.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( interface-age-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ Interface Age Benchmark, 1985-11-16.  This is the Interface
  \ Age benchmark program described in Appendix D of the
  \ forthCMP Manual.

  \ 2015-12-24. Modified: no printing.

need bench{  need 2/

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 ?do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop
    \ if  .  else  drop  then  \ XXX OLD
    2drop  \ XXX NEW
  loop  drop  ;  -->

( interface-age-benchmark )

: interface-age-benchmark  ( n -- )
  bench{ (interface-age-benchmark) }bench.  ;

  cr
  \  <------------------------------>
  .( To run the interface age) cr
  .( benchmark type:) cr
  .(   n interface-age-benchmark  ) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 5000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       ------------  ------------
  \ 05000 80091 (1.00)  72445 (0.90)

  \ 2016-03-16 XXX TODO --
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 05000 72445 (1.00)     71914 (0.99)
  \
  \ [1] Changed only in the kernel.

( Interface Age Benchmark program )

  \ XXX TODO -- test

  \ Forth Dimensions (volume 2, number 4, page 112)

: bench  ( -- )
  dup 2 / 1+ swap ." Starting " cr
  1 do dup i 1 rot
    2 do drop dup i /mod
      dup 0= if  drop drop 1 leave
      else  1 = if drop 1
            else  dup 0 > if  drop 1
                  else  0= if  0 leave  then
                  then
            then
      then
    loop
    if  4 .r  else  drop  then
  loop  drop cr ." Finished " ;

  \ vim: filetype=soloforth
  \ benchmark.vector-loop.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Vector-Loop benchmark.

  \ -----------------------------------------------------------
  \ Authors

  \ M. Edward Borasky, 1995-07-30; code published on Forth
  \ Dimensions (volume 17, number 4, page 11, 1995-11).

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( vector-loop-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench{

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !
     1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop3 ( -- ) \ vector divide
  0 begin
    dup vec1 @ over vec2 @ / over vec3 !
    1+ dup vsize =
  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench{ 0 begin  loop0 1+ dup reps =  until  drop }bench.
  ." Vector No-Op" cr  ;

: bench1 ( -- ) \ benchmark loop1
  bench{ 0 begin  loop1 1+ dup reps =  until  drop }bench.
  ." Vector +    " cr  ;

: bench2 ( -- ) \ benchmark loop2
  bench{ 0 begin  loop2 1+ dup reps =  until  drop }bench.
  ." Vector *    " cr  ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench{ 0 begin  loop3 1+ dup reps =  until  drop }bench.
  ." Vector /    " cr  ;

: bench4 ( -- ) \ benchmark loop4
  bench{ 0 begin  loop4 1+ dup reps =  until  drop }bench.
  ." Vector */   " cr  ;

: vector-loop-benchmarks  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  cr
  \  <------------------------------>
  .( To run the vector loop) cr
  .( benchmarks type:) cr
  .(   vector-loop-benchmarks ) cr

  \ 2015-12-24
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               ITC           DTC
  \               ------        -------------
  \ Vector noop    10919 (1.0)    9033 (0.82)
  \ Vector +       58650 (1.0)   47462 (0.80)
  \ Vector *      107770 (1.0)   91611 (0.85)
  \ Vector /      149002 (1.0)  127495 (0.85)
  \ Vector */     178854 (1.0)  154480 (0.86)

  \ 2016-03-16
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               jp pushhl        push hl + jp (ix) [1]
  \               ------------     ---------------------
  \ Vector noop     9033 (1.0)       8943 (0.99)
  \ Vector +       47461 (1.0)      47177 (0.99)
  \ Vector *       91920 (1.0)      91153 (0.99)
  \ Vector /      127496 (1.0)     126783 (0.99)
  \ Vector */     155192 (1.0)     154364 (0.99)

  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111453

  \ -----------------------------------------------------------
  \ Description

  \ Words related to disk blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.

( ?--> )

: ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "ccc<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

( update flush thru )

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credit:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ Origin: Pygmy Forth.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loader or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credit:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ Origin: MMSFORTH.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;


[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line )

: .line  ( n1 n2 -- )  line>string -trailing type  ;

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ blocks.indexer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604031430

  \ -----------------------------------------------------------
  \ Description

  \ A blocks indexer that improves the default behaviour of
  \ `need`, `needed`, `reneed` and `reneeded`: It creates a
  \ word list from the names that are on the index (header)
  \ line of every searchable block, ignoring duplicates.  These
  \ words will load the block they belong to. This way, after
  \ indexing all of the disk blocks only once, `need` will
  \ search the word list and execute the word found, instead of
  \ searching all of the blocks every time.

  \ At the time of writing (2016-04-03) Indexing the whole
  \ library (677 blocks) takes less than one minute and uses
  \ 3600 bytes of dictionary space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-02: Start.
  \ 2016-04-03: First working version.

( indexer )

only forth definitions

need loader  need s=  need alias  need string/
need get-order  need set-order

wordlist constant index-wordlist
  \ Words of the blocks index.

: search-index  ( ca len -- 0 | xt 1 | xt -1 )
  index-wordlist search-wordlist  ;
  \ Search the index for word _ca len_.

: name-indexed?  ( ca len -- f )
  search-index 0<> dup if  nip  then  ;
  \ Is word _ca len_ in the index?

variable indexed-block

: (index-name)  ( ca len -- )
  2dup name-indexed? if  2drop exit  then
  nextname indexed-block @ loader  ;
  \ Add word _ca len_ to the blocks index, if not done before.
  \ The current word list is supposed to be `index-wordlist`.

-->

( indexer )

wordlist dup constant indexer-wordlist set-current
  \ Words to parse the block index lines.

: (  ( "ccc<space><paren><space|eof>" -- )
  begin  parse-name 2dup s" )" s= 0=
  while  (index-name)  repeat  2drop  ;
  \ Parse and index the names until the next right paren name.

' ( alias .(

: \  ( "ccc<space><backslash><space|eof>" -- )
  begin  parse-name 2dup s" \" s= 0=
  while  (index-name)  repeat  2drop  ;
  \ Parse and index the names until the next backslash name.

-->

( indexer )

forth-wordlist set-current

: index-reneeded  ( ca len -- )
  search-index 0= #-277 ?throw execute  ;

  \ doc{
  \
  \ index-reneeded  ( ca len-- )
  \
  \ Search the index word list for word _ca len_. If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

: index-reneed  ( "name" -- )  parse-name index-reneeded  ;

  \ doc{
  \
  \ index-reneed  ( "name" -- )
  \
  \ Search the index word list for word "name". If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: index-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  index-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ index-needed ( ca len -- )
  \
  \ If word _ca len_ is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `needed`.
  \
  \ }doc


: index-need  ( "name" -- )  parse-name index-needed  ;

  \ doc{
  \
  \ index-need  ( "name" -- )
  \
  \ If word "name" is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `need`.
  \
  \ }doc

: set-indexed-need  ( -- )
  ['] index-reneeded ['] reneeded  defer!
  ['] index-reneed   ['] reneed    defer!
  ['] index-need     ['] need      defer!
  ['] index-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-indexed-need  ( -- )
  \
  \ Set the alternative behaviour of `need`, `needed`, `reneed`
  \ and `reneeded`: Use the library index created by `indexer`.
  \ In fact `indexer` executes `set-indexed-need` after
  \ creating the index.
  \
  \ The default behaviour can be restored by
  \ `set-located-need`.
  \
  \ }doc

-->

( indexer )

: valid-block-header?  ( ca len -- f )
  -trailing dup 0= #-278 ?throw
  2 string/ 2dup s"  )" s= >r s"  \" s= r> or  ;
  \ Is block header _ca len_ valid?
  \ Valid block headers end with " )" or " /".
  \ If it's empty, throw error -278 in order to quit
  \ the indexing.

: index-block-header  ( ca len -- )
  2dup valid-block-header? if  evaluate exit  then  2drop  ;
  \ Index block header _ca len_, if it's valid.

: index-block  ( +n -- )
  dup indexed-block ! 0 swap line>string index-block-header  ;
  \ Index block _+n_.

: (indexer)  ( -- )
  last-locatable @ 1+ first-locatable @
  ?do  i index-block  loop  ;
  \ Create the blocks index.

: indexer  ( -- )
  get-current  get-order
  index-wordlist set-current  indexer-wordlist 1 set-order
  ['] (indexer) catch  dup #-278 <> swap ?throw
  set-order set-current  set-indexed-need  ;
  \ doc{
  \
  \ indexer  ( -- )

  \ Create the blocks index and activate it. The the current
  \ word list and the current search order are preserved.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ compilation.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604172130

  \ -----------------------------------------------------------
  \ Description

  \ Words related to compilation.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added `name>>`.

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( [if] [else] [then] )

need s=

: [else]  ( "..." -- )

  1 begin   parse-name dup
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( body>name name>body link>name name>link name<name )

[unneeded] body>name
?\ : body>name  ( pfa -- nt ) body> >name  ;

[unneeded] name>body
?\ : name>body  ( nt -- pfa ) name> >body  ;

[unneeded] link>name dup  ?\ need alias
?\ ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link dup  ?\ need alias
?\ ' cell- alias name>link  ( nt -- pfa )

[unneeded] name<name dup  ?\ need name>link
?\ : name<name  ( nt1 -- nt2 )  name>link @s  ;
  \ Get the previous _nt2_ from _nt1_.

( >>link name>> )

[unneeded] >>link dup  ?\ need alias
?\ ' cell+ alias >>link  ( xtp -- lfa )

[unneeded] name>>
?\ : name>>  ( nt -- xtp )  [ 2 cells ] literal -  ;

( name>interpret name>compile )

  \ XXX UNDER DEVELOPMENT

: name>interpret  ( nt -- xt | 0 )
  ;

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return a _xt_ that represents the interpretation semantics
  \ of the word _nt_. If _nt_ has no interpretation
  \ semantics, return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

: name>compile  ( nt -- x xt )
  ;

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Return _x xt_ that represents the compilation semantics
  \ of the word _nt_. The  returned _xt_ has the stack
  \ effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

( smudge smudged )

need c!toggle-bits

: smudged  ( nt -- )
  smudge-mask swap system-bank c!toggle-bits default-bank  ;

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hided` and `revealed` are used
  \ instead.
  \
  \ }doc

 : smudge  ( -- )  latest smudged  ;

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ?pairs )

: ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;
  \ If _x1_ not equals _x2_ throw an error -22 (control
  \ structure mismatch).

( save-here restore-here )

variable here-backup
: save-here  ( -- )  here here-backup !  ;
: restore-here  ( -- )  here-backup there  ;


  \ vim: filetype=soloforth
  \ data.array.noble.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ References

  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 2001 Julian V. Noble

  \ Modified for Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ License of the original version:

  \ ---------------------------------------------------
  \     (c) Copyright 2001  Julian V. Noble.          \
  \       Permission is granted by the author to      \
  \       use this software for any application pro-  \
  \       vided this copyright notice is preserved.   \
  \ ---------------------------------------------------

  \ License of this version:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \
  \ 2016-04-03: Header reorganized after the original
  \ documentation.

( 1array )

need <=

: long ; immediate

: 1array ( len #bytes/datum --) \ ( #b len data ...)
  create 2dup , , * allot ;

: _len ( base_addr -- len)  cell+ @ ;
  \ determine length of an array

: } ( base_adr indx -- adr[indx] )
  over _len over <= over 0< or #-272 ?throw
    \ #-272 = array index out of range
  over @ * + cell+ cell+ ;

( 2array ) \ noble-arrays

  \ words for 2-dimensional arrays

need 1array

: wide ; immediate

: 2array ( hgt wid data_size --) \ ( wid #b len data ...)
  create >r tuck , ( wid hgt)
  r@ , * dup , r> * allot ;

: }} ( base_adr m n -- adr[m,n] ) \ data stored row-wise
  2>r cell+ dup cell- @
  r> * r> + ( base_adr+cell m+n*w)
  } ;

  \ ...........................................................
  \ Usage examples:

  \ 20 long 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 long 20 wide 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 long 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

  \ vim: filetype=soloforth
  \ data.array.wong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The one-dimensional Wong arrays.

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of `array`, `array>` `ato` and `+ato`.

  \ -----------------------------------------------------------
  \ Authors

  \ Leo Wong.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \ 2016-04-02: Reorganized the description.

( array ato )

need within

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

  \ vim: filetype=soloforth
  \ data.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `associative:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83, by Henry Laxen and Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2016-04-09: Fixed the file header. Improved the
  \ documentation.

( associative: )

: associative:  ( n "name" -- )
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;

  \ doc{
 
  \ associative:  ( n "name" -- )

  \ Create a table lookup "name" with _n_ entries.
  \ 
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \ 1000 constant zx1
  \ 200 constant zx2
  \ 30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ data.associative-list.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160027

  \ -----------------------------------------------------------
  \ Description

  \ An associative list implemented with standard word lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on code written by Wil Baden, published in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-06: Start, adapted from Wil Baden's code.
  \
  \ 2016-03-24: Comments.
  \
  \ 2016-04-15: Improved with different types of items.
  \ Factored. An obscure bug was discovered in during the
  \ changes.  Finally its origin was found in `(;code)`, in the
  \ kernel, and fixed.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- document

( associative-list item? item create-entry )

: associative-list  ( "name" -- )  wordlist constant  ;
  \ Create a new associative list "name".

: item?  ( ca len wid -- false | xt true )
  search-wordlist 0<> ;
  \ Is _ca len_ an item of associative list _wid_?
  \ If so return its _xt_ and _true_, else return _false_.

: item  ( ca len wid -- i*x )
  item? 0= #-13 ?throw execute  ;
  \ If _ca len_ is an item of associative list _wid_, return
  \ its value _i*x_; else throw exception -13, "undefined
  \ word".

: create-entry  ( i*x wid xt "name" -- )
  get-current >r swap set-current
  create execute
  r> set-current  ;
  \ Create an entry "name" in associative list _wid_,
  \ using _xt_ to store its value _i*x_.

-->

( entry char-entry double-entry string-entry )

: entry  ( x wid "name" -- )
  ['] , create-entry does>  ( -- x )  ( pfa ) @  ;
  \ Create a cell entry "name" in associative list
  \ _wid_, with value _x_.

: char-entry  ( c wid "name" -- )
  ['] c, create-entry does>  ( -- c )  ( pfa ) c@  ;
  \ Create a character entry "name" in associative list
  \ _wid_, with value _c_.

: double-entry  ( dx wid "name" -- )
  ['] 2, create-entry does>  ( -- dx )  ( pfa ) 2@  ;
  \ Create a double-cell entry "name" in associative list
  \ _wid_, with value _dx_.

: string-entry  ( ca len wid "name" -- )
  ['] s, create-entry does>  ( -- ca len )  ( pfa ) count  ;
  \ Create a string entry "name" in associative list
  \ _wid_, with value _ca len_.

( items )

need alias  need wordlist-words

' wordlist-words alias items  ( wid -- )
  \ List items of associative list _wid_.

( associative-list-demo )

need associative-list need items

associative-list stuff

1887          stuff entry year
char E        stuff char-entry letter
s" Saluton"   stuff string-entry hello
314159.       stuff double-entry pi

cr .( Keys:) cr stuff items cr

cr .( Values: ) cr

s" year"    stuff item . cr
s" letter"  stuff item emit cr
s" hello"   stuff item type cr
s" pi"      stuff item d. cr

  \ vim: filetype=soloforth
  \ data.begin-stringtable.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-stringtable end-stringtable`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( begin-stringtable end-stringtable )

  \ Credit:
  \
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

  \ vim: filetype=soloforth
  \ data.begin-structure.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Forth-2012 structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

  \ vim: filetype=soloforth
  \ data.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to data structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( buffer: cvariable enum )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;

( set )

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

  \ doc{
  \
  \ set  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will  cause  the
  \ value _x_  to be stored at _a_.
  \
  \ Origin: Forth-79 (Reference Word Set); Forth-83 (Appendix
  \ B.  Uncontrolled Reference Words).
  \
  \ }doc

( link@ link, )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written after the description by Rick VanNorman,
  \ published on Forth Dimensions (volume 20, number 3, pages
  \ 19-22, 1998-09).

defer link@  ( node1 -- node2 )
  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

  \ vim: filetype=soloforth
  \ data.user.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `user`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( user )

  \ XXX UNDER DEVELOPMENT -- improved version, which uses the
  \ first free offset.

  \ doc{
  \
  \ user  ( +n "name" -- )
  \
  \ Create a user variable _name_.  _+n_ is the offset within
  \ the user area where the value for _name_ is stored.
  \ Execution of _name_ leaves its absolute user area storage
  \ address.
  \
  \ Origin: Forth-79, Forth-83.
  \
  \ }doc

: user  ( n "name -- )
  create c,  does>  c@ up @ +  ;

exit

: user  ( n "name -- )
  cconstant
  ;code asm
  de incp  \ de=pfa
  exde
  m e ld
  00 d ld#  \ de = index of the user variable
  up fthl \ ld hl,(user_variables_pointer) \ XXX FIXME
  de addp  \ hl= address of the user variable
  jppushhl  end-asm

  \ vim: filetype=soloforth
  \ data.value.char.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `cvalue` and `cto`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( cvalue cto )

: cvalue  ( b "name"  -- )  cconstant  ;

: cto  ( Interpretation: b "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone c!
                       else  c!  then  ; immediate

  \ vim: filetype=soloforth
  \ data.value.double.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `2to` for a non-standard version of
  \ `2value`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 2value 2to )

  \ Implementation of `2value` (from Forth-2012) but with
  \ the non-standard word `2to`

: 2value  ( d "name"  -- )  2constant  ;

: 2to  ( Interpretation: d "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone 2!
                     else  2!  then  ; immediate

  \ vim: filetype=soloforth
  \ data.value.forth-2012.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ A Forth-2012 implemention of `value`,
  \ `2value` and `to`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( value 2value to )

  \ Origin: Forth-2012.

  \ This Forth-2012 implementation of `to` is provided as an
  \ alternative, but it's bigger and slower than the Forth-94
  \ `to` and the non-standard `2to`.

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;
: 2value  ( n "name"  -- )  create  1 c, , ,  does> 1+ 2@  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

  \ vim: filetype=soloforth
  \ data.value.forth-94.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Forth-94 version of `value`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( value to )

  \ Origin: Forth-94.

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone !
                     else  !  then  ; immediate

  \ vim: filetype=soloforth
  \ data.value.non-parsing.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ A non-standard version of `value` with a
  \ non-parsing `to`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( value to )

  \ Non-standard implementation of `value` with non-parsing
  \ `to`. This could be useful in special cases.

  \ Credit:
  \
  \ Code inspired by lina.

variable (value)  ['] @ (value) !
: to    ( -- )  ['] ! (value) !  ;
: value  ( n "name" -- )
  create ,  does>   (value) perform  ['] @ (value) !  ;

  \ vim: filetype=soloforth
  \ data.xstack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `xstack`, an implementation of named
  \ extra stacks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( xstack )

  \ Credit:
  \
  \ Code adapted from Galope (xstack module).

  \ Creation and core manipulation of xstacks

need value  need allocate  need free

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- )
    \ Make an xstack the current one.
    ( pfa ) dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: xfree  ( -- )  xp0 free throw  ;

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

need xstack

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( 2x@ 2>x 2x> 2xdrop 2xdup )

  \ xstack double-number operations

need xstack  need x@  need >x  need xpick  need xover

: 2x@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: 2xdrop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: 2xdup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xdepth .x )

  \ xstack tools

need xstack

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the right-most item.
: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack,
  \ followed by a list of the items, if any; TOS is the right-most item.
  \ data_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the data stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 2nip )  \ ==datastack==

  \ Credit:
  \
  \ Code from Afera; original code from DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ doc{
  \
  \ 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  \
  \ }doc

( roll )

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp
    \ push bc
    \ ld b,d
    \ ld c,e
    \ ld d,h
    \ ld e,l

  bc tstp
    \ ld a,b
    \ or c

  0000 jpz |mark 0 unresolved !
    \ jp z,roll.end

  hl decp  hl decp  lddr
    \ dec hl
    \ dec hl
    \ lddr

    \ roll.end:
  0 unresolved @ >resolve
  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl

  jpnext

  end-code

( 3drop 4drop )

code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 3drop  ( x1 x2 x3 -- )
  \
  \ }doc

code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 4drop  ( x1 x2 x3 x4 -- )
  \
  \ }doc

( 3dup )

code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  D9 c,
    \ exx
  C1 c,  D1 c,  E1 c,
    \ pop bc
    \ pop de
    \ pop hl
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  D9 c,
    \ exx
  jpnext  end-code

  \ doc{
  \
  \ 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  \
  \ }doc

exit  \ slower and smaller version:

: 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

( 2rot )

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

  \ doc{
  \
  \ 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  \
  \ }doc

( swapped )

  \ Credit:
  \
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

( nup drup dip )

code nup  ( x1 x2 -- x1 x1 x2 )
  E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,
    \ pop hl
    \ pop de
    \ push de
    \ jp pushhlde
  end-code
  \ Also called `under`.

  \ doc{
  \
  \ nup  ( x1 x2 -- x1 x1 x2 )
  \
  \ }doc

code drup  ( x1 x2 -- x1 x1 )
  D1 c,  E1 c,  E5 c,  E5 c,  jpnext
    \ pop de
    \ pop hl
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ drup  ( x1 x2 -- x1 x1 )
  \
  \ }doc

code dip  ( x1 x2 -- x2 x2 )
  E1 c, D1 c, E5 c, E5 c,  jpnext
    \ pop hl
    \ pop de
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ dip  ( x1 x2 -- x2 x2 )
  \
  \ }doc

( 0dup -dup )

code 0dup  ( x -- x | 0 0 )
  E1 c,  78 04 + c,  B0 05 + c,
    \ pop hl
    \ ld a,h
    \ or l
  C2 c, pushhl ,  E5 c,  jppushhl
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ 0dup  ( x -- x | 0 0 )
  \
  \ Duplicate _x_ if it's zero.
  \
  \ }doc

code -dup  ( x -- x | 0 0 )
  E1 c,  CB c, 7C c,
    \ pop hl
    \ bit 7,h ; negative?
  C2 c, pushhl ,  E5 c,  jppushhl
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ -dup  ( x -- x x | x )
  \
  \ Duplicate _x_ if it's negative.
  \
  \ }doc

( ndrop )

need z80-asm

code ndrop  ( x1..xn n -- )

  hl pop  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( x1..xn n -- )
  \
  \ Drop _n_ cell items from the stack.
  \
  \ }doc

( 2ndrop )

need z80-asm

code 2ndrop  ( dx1..dxn n -- )

  hl pop  hl addp  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( dx1..dxn n -- )
  \
  \ Drop _n_ double cell items from the stack.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.alias.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604180026

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of `alias`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `alias`: it creates a deferred
  \ word and initializes it. Second version: it recognizes code
  \ words and patches their code field instead.
  \
  \ 2015-12-26: New alternative version, adapted to DTC: if
  \ _xt_ is a deferred word, the alias will point to the word
  \ it's associated to.
  \
  \ 2016-02-27: Fixed the DTC version: the alias of an
  \ unitialized deferred word executed the default error even
  \ after the initialization of the deferred word.
  \
  \ 2016-03-04: Removed the ITC version.
  \
  \ 2016-04-17: Improved `alias`: nowe the aliases have the xt
  \ of the original word.
  \
  \ 2016-04-18: Wrote `realias`.

( alias realias )

need name>>  need !s

: alias  ( xt "name" -- )  header reveal latest name>> !s  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.
  \
  \ Aliases have the execution token _xt_ of the original word,
  \ but don't inherit its precedence (set by `immediate`) and
  \ restricted (set by `compile-only`) attributes.
  \
  \ See `realias`.
  \
  \ Origin: Gforth.
  \
  \ }doc

: realias  ( xt "name" -- )
  defined dup 0= #-13 ?throw name>> !s  ;

  \ doc{
  \
  \ realias  ( xt "name" -- )
  \
  \ Set the alias _name_ to execute _xt_.
  \
  \ See `alias`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.deferred.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604172122

  \ -----------------------------------------------------------
  \ Description

  \ Words related to deferred words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added `deferred`, using the old definition of
  \ `alias`.

( deferred )

: deferred  ( xt "name" -- )  defer latest name> defer!  ;

  \ doc{
  \
  \ deferred  ( xt "name" -- )
  \
  \ Create a deferred word _name_ that will execute _xt_.  The
  \ effect is the same than `defer name  xt ' name defer!`.
  \
  \ }doc

( defers action-of )

  \ Credit:
  \
  \ Code adapted from the Afera library.

: defers  ( "name" -- )  ' defer@ compile,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  \
  \ Origin: Gforth.

: action-of  ( Interpretation: "name" -- xt )
             ( Compilation:    "name" -- )
             ( Runtime:        -- xt )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.
  \
  \ Origin: Forth-2012 (CORE EXT).

( <is> [is] is  )

  \ Credit:
  \
  \ Code adapted from the Afera library.

: <is>  ( xt "name" -- )  ' defer!  ;

: [is]  ( xt "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

: is  ( xt "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

( deferred? )

  \ XXX REMARK -- This word can not distinguish deferred words
  \ and aliases, which are created also by `defer`.

: deferred?  ( xt -- wf )  c@ $C3 =  ;
  \ Is _xt_ a deferred word?
  \ The code of a deferred word starts with a Z80 jump ($C3)
  \ to the word it's associated to.

  \ vim: filetype=soloforth
  \ define.synonym.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604180106

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of Forth-2012 `synonym`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `synonym`, using `create
  \ does>`.
  \
  \ 2015-12-23: New improved version, using `alias`. Keep the
  \ first version, just in case.
  \
  \ 2016-04-18: Removed the old first version.

( synonym )

need alias

: synonym  ( "newname" "oldname" -- )
  parse-name nextname ' dup >r alias
  r> >name dup immediate?     if  immediate     then
               compile-only?  if  compile-only  then  ;

  \ doc{
  \
  \ synonym  ( "newname" "oldname" -- )
  \
  \ Create a definition for _newname_ with the the semantics
  \ defined below. _newname_ may be the same as _oldname_; when
  \ looking up _oldname_, _newname_ shall not be found.
  \
  \ newname ( Interpretation: i*x -- j*x )
  \
  \ Perform the interpretation semantics of _oldname_.
  \
  \ newname ( Compilation: i*x -- j*x )
  \
  \ Perform the compilation semantics of _oldname_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ development_benchmarks.flow.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604011826

  \ -----------------------------------------------------------
  \ Description

  \ Flow control benchmarks written during the development of
  \ Solo Forth in order to choose from different implementation
  \ options.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( case-benchs )

  \ Comparison of case-like structures.
  \
  \ 2015-11-14: `case` (4 versions), `case:`, `options[` and
  \ `cases:`.
  \ 2015-12-14: Updated the comments: `case:` has been renamed
  \ to `positional-case:`.

need bench{

warnings off

: .used  ( u -- )  unused - cr u. ." B used " ;

32767 constant iterations

defer (case-bench)  ( -- )

: case-bench  ( n xt -- )
  cr ." ..."
  ['] (case-bench) defer!
  bench{
  iterations 0 do  i %11 and (case-bench)  loop
  }bench.  ;

-->

( case-benchs )

cr .( case)
unused need case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( eForth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

cr .( case from the Forth-94 docs)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( Abersoft Forth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

  \ Note: the `positional-case:` structure is more specific
  \ than the other structures: it lacks a default option and
  \ its argument is positional.

cr .( positional-case:)
unused need positional-case: .used  unused
positional-case:  positional-case:-example  ( n -- )
  noop  noop  noop  noop ;
.used .( by its example)  ' positional-case:-example case-bench

cr .( options[)
unused need options[ .used  unused
: options[-example  ( n -- )
  options[
    0 option noop  1 option noop  2 option noop
      default-option noop
  ]options  ;
.used .( by its example)  ' options[-example case-bench

-->

( case-benchs )

cr .( cases:)
unused need cases: .used  unused
cases: cases:-example  ( n -- )
  0 case> noop  1 case> noop  2 case> noop  other> noop
.used .( by its example)  ' cases:-example case-bench

cr .( baden-case)
unused need baden-case .used  unused
: baden-case-example  ( n -- )
  case 0 = of  noop  endof
  case 1 = of  noop  endof
  case 2 = of  noop  endof
           othercase noop  ;
.used .( by its example)  ' baden-case-example case-bench

-->

( case-benchs )

cr .( baden-case-like)
unused .used  unused
: baden-case-like-example  ( n -- )
  dup 0 = if drop  noop  exit then
  dup 1 = if drop  noop  exit then
      2 = if       noop  exit then
  noop  ;
.used .( by its example)  ' baden-case-like-example case-bench

cr .( vannorman-switch)
unused need [switch .used  unused
[switch vannorman-switch-example drop
  0 runs noop  1 runs noop  2 runs noop
switch]
.used .( by its example)  ' vannorman-switch-example case-bench


  \                        Bytes used            Speed (3)
  \                        --------------------- --------------
  \ Structure              Code (1)  Example (2) Frames Seconds
  \ ---------              --------- ----------- ------ -------
  \ case (7)                 48       62          1365   27
  \ eforth-case (8)          54       62          1366   27
  \ 94-doc-case (6)          54       62          1365   27
  \ abersoft-case (5)        64       62          1365   27
  \ positional-case: (4)     21       12           823   16
  \ options[ (9)            166       24          3627   72
  \ cases: (10)             109       18          3155   63
  \ baden-case (11)          18       56          1472   29
  \ baden-case (12)          36       56          1472   29
  \ baden-case (13)           0       50          1353   27
  \ vannorman-switch (14)   124       24          3573   71

  \ (1) Bytes used by the compilation of the structure's code.
  \
  \ (2) Bytes used by the tested example: a structure with
  \ three options plus default, that execute a `noop`.
  \
  \ (3) For 32767 iterations with parameter 0..3. One system
  \ frame is 20 ms.

  \ (4) A port of F83's `case:`. It is more specific than the
  \ other structures: it lacks a default option and its
  \ argument is positional.
  \
  \ (5) Eaker/Forth-94 `case` of Abersoft Forth, but with
  \ compiler security removed.
  \
  \ (6) Eaker/Forth-94 `case` copied from the Forth-94
  \ documentation.
  \
  \ (7) Eaker/Forth-94 `case` of eForth, with a little
  \ simplification. This is the default `case` used in Solo
  \ Forth.
  \
  \ (8) Eaker/Forth-94 `case` of eForth.
  \
  \ (9) A port of IsForth's `case:`.
  \
  \ (10) A port of a structure written by Dan Lerner, published
  \ on Forth Dimensions (volume 3, number 6, page 189,
  \ 1982-03).
  \
  \ (11) "Ultimate CASE Statement", written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).
  \
  \ (12) The same "Ultimate CASE Statement", by Wil Baden, with
  \ two syntactic sugar words added: `endof` and `othercase`.
  \
  \ (13) The same "Ultimate CASE Statement", by Wil Baden,
  \ emulated with standard words. This is a bit faster because,
  \ without the syntactic sugar definitions, one `dup` and two
  \ `drop` are saved.
  \
  \ (14) Code by Rick VanNorman, published on Forth Dimensions
  \ (volume 20, number 3, pages 19..22, 1998-09).

( do-bench )

  \ 2015-12-17

need bench{

32767 0 2constant range

: forth-83-do  ( -- )  bench{  range do83  loop83  }bench.  ;

: forth-79-do  ( -- )  bench{  range do  loop  }bench.  ;

: forth-83-i  ( -- )
  bench{  range do83  i83 drop  loop83  }bench.  ;

: forth-79-i  ( -- )
  bench{  range do  i drop  loop  }bench.  ;

: forth-83-+loop  ( -- )
  bench{  range do83  2 +loop83  }bench.  ;

: forth-79-+loop  ( -- )  bench{  range do  2 +loop  }bench.  ;

: do-bench  ( -- )
  forth-83-do forth-79-do
  forth-83-i forth-79-i
  forth-83-+loop forth-79-+loop  ;

  \           Frames by 32767 iterations
  \           --------------------------
  \ Bench     Forth-79  Forth-83
  \ --------  --------  --------
  \ loop           143       109
  \ i              264       258
  \ +loop          108        97

  \ Note: 1 frame = 50th of second

  \ vim: filetype=soloforth

  \ development_benchmarks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604011832

  \ -----------------------------------------------------------
  \ Description

  \ Misc benchmarks written during the development of Solo
  \ Forth in order to choose from different implementation
  \ options.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( number-base-bench )

  \ 2015-10-09

: number-base-1  ( ca len -- ca' len' n )
  \ This is the current version defined in the kernel.
  over c@ [char] $ = if  1 /string 16  exit  then
  over c@ [char] % = if  1 /string  2  exit  then
  over c@ [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-2  ( ca len -- ca' len' n )
  over c@ >r
  r@ [char] $ = if  1 /string 16  rdrop exit  then
  r@ [char] % = if  1 /string  2  rdrop exit  then
  r> [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-3  ( ca len -- ca' len' n )
  over c@
  dup >r [char] $ = if  1 /string 16  rdrop exit  then
      r@ [char] % = if  1 /string  2  rdrop exit  then
      r> [char] # = if  1 /string 10  exit  then  base @  ;

-->

( number-base-bench )

: number-base-4  ( ca len -- ca' len' n )
  over c@
  dup [char] $ = if  drop 1 /string 16  exit  then
  dup [char] % = if  drop 1 /string  2  exit  then
      [char] # = if  1 /string 10  exit  then  base @  ;

need frames@  need reset-frames  defer (number-base)

: (number-base-bench)  ( n xt -- )
  ['] (number-base) defer!
  reset-frames  0 do  s" 000" (number-base) drop 2drop  loop
  frames@ d. cr  ;

: number-base-bench  ( n -- )
  dup ['] number-base-1 (number-base-bench)
  dup ['] number-base-2 (number-base-bench)
  dup ['] number-base-3 (number-base-bench)
      ['] number-base-4 (number-base-bench) ;

  \ 2015-10-09
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          1    2    3    4
  \       ---- ---- ---- ----
  \ 01000   73   75   74   69
  \ 10000  732  744  736  686
  \ 32000 2343 2382 2367 2194

( fill-bench )

  \ 2015-09-25: Benchmark three implementations of `fill`:
  \
  \ `fill` is the original implementation from Abersoft Forth
  \ `fill2` is a modified version
  \ `fill88` is the code adapted from Z88 CamelForth

need frames@  need reset-frames  need rnd

defer (fill)

: (fill-bench)  ( n xt -- )
  ['] (fill) defer!
  reset-frames  0
  do  16384 6144 rnd (fill)  loop
  \ do  16384 1 rnd (fill)  loop
  \ do  16384 0 rnd (fill)  loop
  \ do  16384 2048 rnd (fill)  loop
  frames@ cr d.
  key drop  ;

: fill-bench  ( n -- )
  dup ['] fill (fill-bench)
  dup ['] fill2 (fill-bench)
      ['] fill88 (fill-bench)  ;

  \ Kernel code: `16384 6144 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010   10    10      5
  \ 00100  491   522    252
  \ 01000 4909  5218   2524

  \ Kernel code: `16384 1 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    9     8      8
  \ 01000   85    84     84
  \ 05000  425   423    422
  \ 10000  850   846    845

  \ Kernel code: `16384 0 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    8     8      8
  \ 01000   84    83     84
  \ 05000  421   418    421
  \ 10000  842   837    842

  \ Kernel code: `16384 2048 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill  fill2 fill88
  \       ----- ----- ------
  \ 00010    17    18      9
  \ 00100   169   180     89
  \ 01000  1693  1795    898
  \ 30000 50770 53863  26933

( value-bench )

need frames@  need reset-frames

0 value v1

: value-bench  ( n -- )
  reset-frames  0 do  v1 drop  loop  frames@ cr d.  ;

( 2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2value-bench  ( n -- )
  reset-frames  0 do  v2 2drop  loop  frames@ cr d.  ;

( to-value-bench )

need frames@  need reset-frames

0 value v1

: to-value-bench  ( n -- )
  reset-frames  0
  do  0 to v1   loop
  frames@ cr d.  ;

( to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: to-2value-bench  ( n -- )
  reset-frames  0
  do  0. to v2   loop
  frames@ cr d.  ;

( 2to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2to-2value-bench  ( n -- )
  reset-frames  0
  do  0. 2to v2   loop
  frames@ cr d.  ;

( rshift-bench lshift-bench )

need frames@  need reset-frames

: rshift-bench  ( n -- )
  reset-frames  0
  do  128 255 rshift drop   loop
  frames@ cr d.  ;

: lshift-bench  ( n -- )
  reset-frames  0
  do  128 255 lshift drop   loop
  frames@ cr d.  ;

  \ 2015-11-01

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       rshift         lshift
  \       -------------- --------------
  \        Z88  DZX    %  Z88  DZX    %
  \       ---- ---- ---- ---- ---- ----
  \ 10000 1203 1609 133% 1016 1723 169%
  \ 30000 3607 4826 133% 3048 5170 169%

  \ Z88 = code adapted from Z88 CamelForth
  \ DZX = code adapted from DZX-Forth

( /-bench )

  \ 2015-09-22: This bench compares the execution speed of
  \ Abersoft Forth's `m/` and Z88 CamelForth's `sm/rem`. Both
  \ words are equivalent.  Abersoft Forth's `m/` is much
  \ faster.

need frames@  need reset-frames  need rnd

: drnd  ( -- d )  rnd rnd  ;

[defined] (/)  ?\ defer (/)

: (/-bench)  ( n -- )
  reset-frames
  1+ 1 do  drnd i (/) 2drop  loop  frames@ cr d.  ;

: /-bench  ( n -- )
  dup ['] m/ ['] (/) defer! (/-bench)
      ['] sm/rem ['] (/) defer! (/-bench)  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       m/    sm/rem
  \       ----- ------
  \ 00010     3      4
  \ 00100    33     44
  \ 01000   326    442

  \ m/     = word from Abersoft Forth
  \ sm/rem = word from Z88 Camel Forth

( um*-bench )

need frames@  need reset-frames

: um*-bench  ( n -- )
  reset-frames  0 do  i i um* 2drop  loop  frames@ d.  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       DZX   hForth R hForth A Z88 R Z88 A
  \       ----- -------- -------- ----- -----
  \ 00100     3        3        3     3     3
  \ 01000    29       32       31    32    31
  \ 10000   297      328      319   323   316
  \ 20000   598      659      643   647   633
  \ 32000   961     1060     1037  1037  1016

  \            Bytes free Code from
  \            ---------- ---------
  \ DZX      = 33783      DZX-Forth
  \ hForth R = 33787      hForth, with relative jumps
  \ hForth A = 33784      hForth, with absolute jumps
  \ Z88 R    = 33786      Z88 CamelForth, with relative jumps
  \ Z88 A    = 33784      Z88 CamelForth, with absolute jumps

( um/mod-bench )

  \ 2015-11-24

need bench{

: um/mod-bench  ( n -- )
  bench{  0 do  i s>d i um/mod 2drop  loop  }bench.  ;

: um/mod-bench88  ( n -- )
  bench{  0 do  i s>d i um/mod88 2drop  loop  }bench.  ;

: um/mod-bench  ( n -- )
  dup cr ." Abersoft Forth  U/MOD ..." um/mod-bench
      cr ." Z88 CamelForth UM/MOD ..." um/mod-bench88  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          AF      Z88
  \       ----- --------------
  \ 00100     6        5
  \ 01000    59       42 (71%)
  \ 10000   587      428 (72%)
  \ 20000  1157      875 (75%)
  \ 32000  1881     1372 (72%)

  \            Bytes free Code from
  \            ---------- ---------
  \ AF         32689      Abersoft Forth
  \ Z88        32707      Z88 CamelForth

( ud/mod-bench )

  \ 2015-12-21

need bench{

: a-m/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod drop 2drop  loop  }bench.  ;

: z1-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod881 drop 2drop  loop  }bench.  ;

: z2-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod882 drop 2drop  loop  }bench.  ;

: run  ( n -- )
  dup cr ." Abersoft Forth  M/MOD ..." a-m/mod
  dup cr ." Z88 CamelForth UD/MOD 1..." z1-ud/mod
      cr ." Z88 CamelForth UD/MOD 2..." z2-ud/mod  ;

  \ 10000 run  20000  run 65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ 10000     964    967      944
  \ 20000    1928   1934     1888
  \ 65535    6300   6316     6161

  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ B used:    22     22      20 (3)

  \ (1) Z88 CamelForth code
  \ (2) Z88 CamelForth code, with `-rot` instead of `rot rot`
  \ (3) Not including the size of `-rot`

( ud/mod-bench )

  \ 2016-03-15: Second benchmark. Faster results because of
  \ DTC.

need bench{

: a-m/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod drop 2drop  loop  }bench.  ;

: z-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod88 drop 2drop  loop  }bench.  ;


: run  ( n -- )
      cr ." UD/MOD from:"
  dup cr ." Abersoft Forth and Gforth ..." a-m/mod
  dup cr ." Z88 CamelForth .............." z-ud/mod  ;

  \ 10000 run  20000  run 65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \            AF    Z88
  \         ----- ------
  \ 10000     900    882
  \ 20000    1799   1765
  \ 65535    5870   5759

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 12345" num?   s" 12345." num?
    s" -12345" num?  s" -12345." num?  empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

                                    \ Version of `number?`
  \    ' number? ' num? defer! benchs  \ pForth
  \  ' c.number? ' num? defer! benchs  \ CamelForth
  \ ' dzx-number? ' num? defer! benchs  \ DZX-Forth
   ' solo-number? ' num? defer! benchs  \ Solo Forth

  \ Note: The CamelForth code is for single numbers only.
  \       The DZX-Forth code is a bit obfuscated.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       pForth CamelForth DZX-Forth Solo Forth
  \       ------ ---------- --------- ----------
  \ 00100    256        257       259        266
  \ 01000   2559       2565      2594       2658
  \ 10000  25591      25652     25933      26581

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 123x45." num?   s" 12345.999x" num?
    s" -12345.x" num?  s" -12345.999x" num?
    s" -12345.000.000" num?
    empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

' solo-number? ' num? defer! benchs

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \ 00100   416
  \ 01000  4165
  \ 10000 41649

( dummy-needed )

( buffer-benchmark-1 )

  2 load need reset-frames
  reset-frames

  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed

  frames@ cr .( Frames ) d. cr

  \ 2015-11-04

  \ Benchmark: Locate and load 16 times empty block #457.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \        512-byte buffer 1024-byte buffer
  \       ---------------- ----------------
  \    16             6323       8621 (136%)

( buffer-benchmark-2 )

  2 load  need reset-frames  warnings off  reset-frames

  need list  need dump  need wdump  need decode
  need life  need hanoi  need tt need siderator  need pong
  need doer  need a!  need defer  need value  need editor
  need case  need times  need dtimes  need for

  frames@ cr .( Frames ) d. cr

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-04 512-byte buffer       33742        20960 (1.00)
  \            1024-byte buffer      33277 (-465) 24310 (1.15)
  \                                               24042 (1.14)

  \ This is not good for benchmarking the headers, because most
  \ of the time is wasted locating the blocks. That's why
  \ both methods are equally fast:

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

need bench{ warnings off bench{ : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        490 (9 s)
  \            `next-name` (4)       32791        494 (9 s)
  \            `nextname` (2)        32781        491 (9 s)
  \            `nextname` (3)        32765        494 (9 s)

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.
  \
  \ (3) Same as (2) but with zero-length name check.
  \
  \ (4) Same as (1) but with zero-length name check.

( header-benchmark )

need bench{ warnings off blk @ 1+ constant b bench{ b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

  }bench. sp0 @ sp!

  \ How `interpret`
  \ interprets numbers   Bytes free  Frames         Date
  \ ------------------   ----------  -------------  ----------
  \ branches (1)              32766     500 (1.00)  2015-11-12
  \ execution table (1)       32770     497 (0.99)  2015-11-12
  \ execution table (2)       32761     498 (0.99)  2015-11-12
  \ execution table (3)                 476 (0.95)  2016-03-19

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor
  \ (3): same as (2), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

: foo  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ;

  }bench.

  \ How `interpret`
  \ compiles numbers    Bytes free  Frames         Date
  \ ----------------    ----------  -------------  ----------
  \ branches (1)             32766     510 (1.00)  2015-11-12
  \ execution table (1)      32770     507 (0.99)  2015-11-12
  \ execution table (2)      32761     508 (0.99)  2015-11-12
  \ execution table (3)                483 (0.94)  2016-03-19

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor
  \ (3): same as (2), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop

  }bench.

  \ How `interpret`
  \ interprets words       Bytes free  Frames      Date
  \ ---------------------  ----------  ----------- ----------
  \ branches (0)           32770       192 (1.00)  2015-11-12
  \ independent table (1)  32746       190 (0.98)  2015-11-12
  \ combined table (2)     32747       190 (0.98)  2015-11-12
  \ combined table (3)     32753       192 (1.00)  2015-11-12
  \ combined table (4)     32761       190 (0.98)  2015-11-12
  \ combined table (5)                 191 (0.99)  2016-03-19

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor
  \ (5): same as (4), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

: foo noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop ;

  }bench.

  \ How `interpret`
  \ compiles words        Bytes free  Frames      Date
  \ ------------------    ----------  ----------  ----------
  \ branches (0)          32770       199 (1.00)  2015-11-12
  \ independent table (1) 32746       198 (0.98)  2015-11-12
  \ combined table (2)    32747       198 (0.99)  2015-11-12
  \ combined table (3)    32753       200 (1.00)  2015-11-12
  \ combined table (4)    32761       198 (0.98)  2015-11-12
  \ combined table (5)                191 (0.95)  2016-03-19

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor
  \ (5): same as (4), but when the Forth system is DTC

  \ 1 frame = 50th of second

( constant-bench )

  \ 2016-02-16: New version.

need bench{ need }bench.

3 constant const1

: bench1  ( n -- )
  bench{ 0 do  const1 drop  loop }bench.  ;

: bench2  ( n -- )
  bench{ 0 do  3 drop  loop }bench.  ;

: constant-bench  ( n -- )  dup cr bench1 cr bench2  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \  1000                      6      5
  \ 52000                    307    284
  \ 65535                    386    358

( constant-bench )

need reset-frames  need frames@

0 constant const1

: bench1  ( n -- )
  reset-frames 0 do  const1 drop  loop
  frames@ d. cr ;

: const2  ( -- x )  const1 cell+  ;

: bench2  ( n -- )
  reset-frames 0 do  const2 drop  loop
  frames@ d. cr ;

( literal-bench )

need reset-frames  need frames@

: bench1  ( n -- )
  reset-frames 0 do  cell negate drop  loop
  frames@ d. cr ;

: bench2  ( n -- )
  reset-frames 0 do  [ cell negate ] literal drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \ 32000                    320    249

( 0-bench false-bench )

need reset-frames  need frames@

  \ This bench compares `0` (implemented as a `cconstant`) and
  \ `false` (written in assembler).

: 0-bench  ( n -- )
  reset-frames 0 do  0 drop  loop
  frames@ d. cr ;

: false-bench  ( n -- )
  reset-frames 0 do  false drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                           0       false
  \                       ----- -----------
  \ 32000                   251   236 (94%)

( d*-bench )

  \ `d*` by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 33, 1998-04).

: baden-d*  ( d1 d2 -- d3 )
  >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  r> * swap r> * + +  ; ( d1*d2 ) ( R: )

  \ `d*` by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

need pick  need roll

: smith-d*  ( d1 d2 -- d3 )
  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ `d*` from DX-Forth 4.13

unused
: dx-d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;
unused - . cr key drop

-->

( d*-bench )

need bench{

: baden-d*-bench  ( n -- )  0 do  1. 2. baden-d* 2drop  loop  ;
: smith-d*-bench  ( n -- )  0 do  1. 2. smith-d* 2drop  loop  ;
: dx-d*-bench  ( n -- )  0 do  1. 2. dx-d* 2drop  loop  ;

: d*-benchs  ( -- )
  page
  32767 dup bench{ baden-d*-bench }bench.
        dup bench{ smith-d*-bench }bench.
            bench{ dx-d*-bench }bench.  ;

  \ 2015-11-09: baden-d*, smith-d*

  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4920 (98 seconds)  1.00
  \ smith-d*  5189 (103 seconds) 1.05

  \ 2015-12-22:
  \
  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4860 (97 seconds)   1.0008
  \ smith-d*  5139 (102 seconds)  1.0582
  \ dx-d*     4856 (97 seconds)   1.0000

( misc-benchs )

  \ Some misc speed benchs.

need bench{  need 0if

: bench1  ( n -- )
  begin  ?dup if  1 - else  exit  then  again  ;

: bench1a  ( n -- )
  begin  ?dup if  1- else  exit  then  again  ;

: bench2  ( n -- )
  begin  dup 0= if  drop  exit  then  1-  again  ;

: bench2a  ( n -- )
  begin  dup 0if  drop exit  then  1-  again  ;

: bench3  ( n -- )
   begin  ?dup 0if  exit  then  1-  again  ;


: misc-benchs  ( -- )
  32767 dup bench{ bench1 }bench.
        dup bench{ bench2 }bench.
            bench{ bench3 }bench.  ;

  \ Bench    Frames for 32767 iterations
  \ -----   ---------------------------
  \ bench1   655 (`1 -`)
  \ bench1a  576 (`1-`)
  \ bench2   320 (`0= if`: 100%)
  \ bench2a  245 (`0if`:    76%)
  \ bench3   528

( 2swap-bench )

  \ 2015-11-24

need bench{

: 2swap-bench  ( -- )
  32767 0 bench{ 2dup do  2swap  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From DZX-Forth                271 (5 s) (1.00)
  \ Adapted from Z88 CamelForth   243 (4 s) (0.89)

( dnegate-bench )

  \ 2015-11-24

need bench{

: dnegate-bench  ( -- )
  32767 0 bench{ 2dup do  dnegate  loop  }bench. 2drop  ;

: dnegate-bench2  ( -- )
  32767 0 bench{ 2dup do  dnegate2  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From Abersoft Forth           243 (4 s) (1.00)
  \ From Spectrum Forth-83        253 (5 s) (1.04)

( ?dup-bench )

  \ 2016-01-01

need bench{  variable times  40000 times !

: iterations  ( -- n1 n2 )  times @ 0  ;

: forth-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup drop  loop  }bench.  ;

: z80-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup80 drop  loop  }bench.  ;

: forth-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup 2drop  loop  }bench.  ;

: z80-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup80 2drop  loop  }bench.  ;

: ?dup-bench  ( -- )
  cr ." Forth version:" cr ." 0 ?dup :" forth-0-?dup-bench cr
                           ." 1 ?dup :" forth-1-?dup-bench cr
     ." Z80 version:"   cr ." 0 ?dup :" z80-0-?dup-bench cr
                           ." 1 ?dup :" z80-1-?dup-bench cr  ;

  \ Code        Frames for 40000 iterations
  \ -----       ---------------------------
  \             Forth  Z80
  \             -----  ----
  \ `0 ?dup`    532    288
  \ `1 ?dup`    585    312

( #spaces-bench )

need under+

: #spaces1  ( ca len -- +n )
  0 rot rot  0 do  count bl = 1 and under+  loop  drop ;
  \ From:
  \ http://forth.sourceforge.net/mirror/comus/index.html

: #spaces2  ( ca len -- +n )
  0 rot rot  bounds do  i c@ bl = +  loop  abs  ;
  \ First variant.

: #spaces3  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Second variant, the fastest one.

need bench{

defer #spaces

: #spaces-bench  ( n -- )
  cr bench{  0 do  0 32767 #spaces drop  loop  }bench.  ;

: run  ( n -- )
  dup ['] #spaces1 ['] #spaces defer! ." 1..." #spaces-bench
  dup ['] #spaces2 ['] #spaces defer! ." 2..." #spaces-bench
      ['] #spaces3 ['] #spaces defer! ." 3..." #spaces-bench  ;

  \         Frames
  \         ----------------------------
  \ Version 10 iterations 100 iterations
  \ ------- ------------- --------------
  \ 1                 123           1231
  \ 2                 103           1036
  \ 3                  95            951

  \ Note: 1 frame = 50th of second

( emit-udg-bench )

  \ 2015-12-18

need bench{

: e  ( n -- )
  bench{ 0 ?do  home 128 emit  loop  }bench.  ;
: eu  ( n -- )
  bench{ 0 ?do  home 128 emit-udg  loop  }bench.  ;

  \             Frames (20 ms)
  \             -----------------------
  \ Iterations  emit        emit-udg
  \ ----------  ----------- -----------
  \ 32000       1904 (1.00) 1856 (0.97)

( m+-bench )

  \ 2016-04-15

need bench{  need m+

: code-m+-bench  ( n -- )
  bench{  0 do  i s>d i m+ 2drop  loop  }bench.  ;

unused
: high-m+  ( n -- )  s>d d+  ;
unused - cr .( bytes of high M+ ) .

: high-m+-bench  ( d1|ud1 n -- d2|ud2 )
  bench{  0 do  i s>d i high-m+ 2drop  loop  }bench.  ;


: run  ( n -- )
  cr dup cr ." Code M+ ..." code-m+-bench
         cr ." High M+ ..." high-m+-bench  ;

  \ 10000 run  65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         code M+ (13 bytes)  high M+ (9 bytes)
  \         ------------------  -----------------
  \ 10000                  134         196 (1.44)
  \ 65535                  883        1308 (1.48)

( du<-bench )

  \ 2016-04-15

need bench{  need j

unused
  \ 2016-04-15: Current version in the library
: dzx-forth-du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;
unused - cr .( DZX-Forth ) . .( bytes)  \ 41

unused
: m3forth-du< ( ud1 ud2 -- f )
  rot 2dup = if 2drop u< else u> nip nip then  ;
unused - cr .( m3forth ) . .( bytes)  \ 29
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

-->

( du<-bench )

defer (u<)

: du<-bench  ( n xt -- )
  ['] (u<) defer!
  bench{
    dup 0 ?do  0 ?do  i s>d j s>d (u<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." DU< from:"
  dup cr ." DZX-Forth ..." ['] dzx-forth-du< du<-bench
      cr ." 3mforth ....." ['] m3forth-du< du<-bench  ;

  \ 10 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         DZX-Forth DU< m3forth DU<
  \         ------------- -----------
  \ 10               3623      crash!

( m*/-bench )

  \ XXX UNDER DEVELOPMENT

  \ 2016-04-15: Start.


unused
  \ 2016-04-15: This is the current implementation.
  \ Credit: from Gforth 0.7.3.
: gforth-m*/  ( d1 n1 +n2 -- d2 )
  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;
unused - cr .( gforth ) . .( bytes)  \ 89 bytes

-->

( m*/-bench )

  \ Alternative implementation of `m*/`
  \
  \ Credit:
  \
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

unused
need mt*  need tnegate  need ut/
unused
: coldforth-m*/  ( d1 n1 +n2 -- d2 )
    >r mt* dup 0< if    tnegate r> ut/ dnegate
                  else  r> ut/  then  ;
         cr .( coldforth:)
unused - cr .( m*/ only ) . .( bytes)  \ 33 bytes
unused - cr .( with requirements) . .( bytes)  \ 185 bytes

-->

( m*/-bench )

need bench{

defer (m*/)

: m*/-bench  ( n xt -- )
  ['] (m*/) defer!
  bench{
    1+ 1 ?do  i s>d i i (m*/) 2drop  loop
    \ XXX FIXME -- use better range of numbers
  }bench.  ;

: run  ( n -- )
      cr ." M*/ from:"
  dup cr ." Gforth ......" ['] gforth-m*/ m*/-bench
      cr ." ColdForth ..." ['] coldforth-m*/ m*/-bench  ;

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         Gforth M*/  ColdForth M*/
  \         ----------  -------------
  \ 10000         1690           1719 (1.01)
  \ 20000         3381           3442 (1.01)
  \ 65535        11621              0 \ XXX FIXME --
  \

( u<-bench )

  \ 2016-04-16

need bench{

defer (u<)  need j

: u<-bench  ( n xt -- )
  ['] (u<) defer!
  bench{
    dup 0 ?do  0 ?do  i j (u<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." u< from:"
  dup cr ." DZX-Forth .........." ['] dzxu< u<-bench
      cr ." Z88 CamelForth ....." ['] u< u<-bench  ;

  \ XXX FIXME -- Z88 CamelForth `u<` never ends

  \ 10 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         DZX-Forth u<  Z88 CamelForth u<
  \         ------------- -----------------
  \ 10               

  \ vim: filetype=soloforth
  \ development_benchmarks.rng.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604090210

  \ -----------------------------------------------------------
  \ Description

  \ RNG benchmarks written during the development of Solo Forth
  \ in order to choose the best implementations.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( rnd-benchmark )

  \ XXX UNDER DEVELOPMENT -- new benchmark
  \ 2016-04-07: Start

need bits  need u%

$FFFF constant #sampled
8 constant /byte  \ bits
#sampled /byte / constant /sample

create sample  /sample allot

: -sample  ( -- )  sample /sample erase  ;
  \ Erase the sample.

: sampled  ( -- u )  sample /sample bits  ;
  \ Count the bits of the sample.

: remember  ( u -- )  /byte /mod sample + c!set-bits  ;
  \ Remember random number _u_, by setting its associated bit
  \ in the sample.

: sampled%.  ( u -- )  #sampled u% 0.r ." %"  ;
  \ Print _u_ sampled numbers as a percentage.

: .sampled  ( u -- )  dup u. ." (" sampled%. ." )"  ;
  \ Print _u_ as the number of sampled numbers.

: report  ( ca len -- )  type sampled .sampled cr  ;

: rnd-benchmark  ( ca len xt -- )
  -sample
  #sampled 0 do  dup execute remember  loop  drop
  report  ;

( random-pix-benchmark )

  \ Random pixels benchmark

need set-pixel  need bench{  need pixels  need u%  need 3dup

256 192 * constant #pixels
  \ number of pixels of the screen

defer rng  ( n -- 0..n-1 )

: pixels%.  ( u -- )  #pixels u% 0.r ." %"  ;
  \ Print _u_ pixels as a percentage of the maximum number of
  \ pixels.

: .pixels  ( u -- )  dup u. ." pixels (" pixels%. ." )"  ;
  \ Print _u_ as the number of pixels.

: .title  ( ca len -- )  ." Code: " type  ;

variable cycles

defer .cycles  ( -- )

: (.cycles)  ( -- )
  cycles ?  s" cycles" cycles @ 1 = + type  ;
  \ Print the number of cycles.

: .time  ( d -- )  bench. ." per cycle" cr  ;

: .result  ( ca len d -- )
  2>r pixels >r  .title cr  r> .pixels cr
  2r> .time .cycles   ;
  \ Calculate and print the result of the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

-->

( random-pix-benchmark )

defer random-coords  ( -- gx gy )
  \ Random graphic coordinates. Configurable depending on the
  \ type of `random` to benchmark.

: (random-coords)  ( -- gx gy )  256 rng 192 rng  ;
  \ Default behaviour of `random-coords`.

: fill-screen  ( -- )
  #pixels 0 do  random-coords set-pixel  loop  ;
  \ Fill the screen with random pixels.

: signal  ( -- )  cycles @ %111 and border  ;
  \ Change the border color according to the current count
  \ of cycles, just to show that the benchmark is running.

: (random-pix-benchmark)  ( -- d )
  1 cycles +!  signal  bench{ fill-screen }bench  ;
  \ Do one cycle of the benchmark and return its result.

: wait  ( -- )  key drop  ;

: finish  ( ca len d -- )  0 border  .result  wait  ;
  \ Finish the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

: init  ( xt1 xt2 xt3 -- )
  ['] random-coords defer!  ['] .cycles defer!  ['] rng defer!
  page  -1 cycles !  ;

defer finish?  ( i*x -- j*x f )
  \ Finish the benchmark?

: new-pixels?  ( n1 -- n2 f )  pixels tuck =  ;
  \ Are there new pixels on the screen, comparing the previous
  \ count _n1_ with the new count _n2_?

' new-pixels? ' finish? defer!  -->

( random-pix-benchmark )

defer random-pix-benchmark  ( ca len xt -- )
  \ Do a RNG benchmark for the `random` word _xt_ with title
  \ _ca len_.

: (random-pix-benchmark2)  ( ca len -- )
  0 begin   (random-pix-benchmark) 2>r
            finish? dup 0= if  2rdrop  then
  until     drop 2r> finish  ;
  \ Do a double RNG benchmark with title _ca len_: The time
  \ required to complete one cycle (49152 random pixels), plus
  \ the number of cycles required until the number of pixels
  \ doesn't change.

: random-pix-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] (random-coords) init
  (random-pix-benchmark2)  ;
  \ Do a double RNG benchmark for the `random` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

  \ The best `random` words need several cycles. In such cases
  \ it's useful a simpler test to show only the pixels set at
  \ the end of the first cycle:

' random-pix-benchmark2 ' random-pix-benchmark defer!
  \ default benchmark

: (.cycle)  ( -- )  ." First cycle only"  ;

: (random-pix-benchmark1)  ( ca len -- )
  (random-pix-benchmark) .result wait  ;
  \ Do a one-cycle RNG benchmark with title _ca len_: Only the
  \ time required to complete one cycle (49152 random pixels).

: random-pix-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] (random-coords) init
  (random-pix-benchmark1)  ;  -->
  \ Do a one-cycle RNG benchmark for `random` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( random-pix-benchmark )

  \ Versions for 8-bit `rnd`.

: crnd-coords  ( -- gx gy )  rng rng 192 min  ;
  \ Random graphic coordinates for 8-bit `rnd`.

: crnd-pix-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] crnd-coords init
  (random-pix-benchmark2)  ;
  \ Do a double RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

: crnd-pix-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] crnd-coords init
  (random-pix-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( 16-bit-random-pix-benchmarks )

  \ Execute all of the 16-bit random pixels benchmarks

need random-pix-benchmark  need +thru  2 21 +thru

ace-random-pix-benchmark

cgm-5E9B-random-pix-benchmark
cgm-61BF-random-pix-benchmark
cgm-62DC-random-pix-benchmark
cgm-6363-random-pix-benchmark
cgm-6594-random-pix-benchmark
cgm-65E8-random-pix-benchmark

dx-random-pix-benchmark gf-random-pix-benchmark
jer-random-pix-benchmark jml-random-pix-benchmark
lb-random-pix-benchmark lina-random-pix-benchmark
mb-random-pix-benchmark

  \ mm-random-pix-benchmark  \ XXX TMP --

sf83-random-pix-benchmark tt-random-pix-benchmark
vf-random-pix-benchmark z88-random-pix-benchmark
zh-random-pix-benchmark  -->

( 16-bit-random-pix-benchmarks )

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' random-pix-benchmark1 ' random-pix-benchmark defer!

cgm-5E9B-random-pix-benchmark
cgm-61BF-random-pix-benchmark
cgm-62DC-random-pix-benchmark
cgm-6363-random-pix-benchmark
cgm-6594-random-pix-benchmark
cgm-65E8-random-pix-benchmark

dx-random-pix-benchmark  vf-random-pix-benchmark

( ace-random )

  \ Credit:
  \
  \ Adapted from ACE Forth, after the Jupiter ACE manual.
  \ Also used by Abersoft Forth in its bundled game
  \ "Bertie".

need os-seed

: ace-rnd  ( -- u )
  os-seed @ 75 um* 75. d+ 2dup u< - - 1- dup os-seed !  ;

: ace-random  ( n -- 0..n-1 )  ace-rnd um* nip  ;

need random-pix-benchmark

: ace-random-pix-benchmark  ( -- )
  os-seed off  s" Jupiter ACE manual"
  ['] ace-random random-pix-benchmark  ;

( cgm-5E9B-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-5E9B-rnd  ( -- u )
  rloc 2@ $5E9B um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-5E9B-random  ( n -- 0..n-1 )  cgm-5E9B-rnd um* nip  ;

need random-pix-benchmark

: cgm-5E9B-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $5E9B"
  ['] cgm-5E9B-random random-pix-benchmark  ;

( cgm-61BF-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-61BF-rnd  ( -- u )
  rloc 2@ $61BF um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-61BF-random  ( n -- 0..n-1 )  cgm-61BF-rnd um* nip  ;

need random-pix-benchmark

: cgm-61BF-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $61BF"
  ['] cgm-61BF-random random-pix-benchmark  ;

( cgm-62DC-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-62DC-rnd  ( -- u )
  rloc 2@ $62DC um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-62DC-random  ( n -- 0..n-1 )  cgm-62DC-rnd um* nip  ;

need random-pix-benchmark

: cgm-62DC-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $62DC"
  ['] cgm-62DC-random random-pix-benchmark  ;

( cgm-6363-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-6363-rnd  ( -- u )
  rloc 2@ $6363 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-6363-random  ( n -- 0..n-1 )  cgm-6363-rnd um* nip  ;

need random-pix-benchmark

: cgm-6363-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $6363"
  ['] cgm-6363-random random-pix-benchmark  ;

( cgm-6594-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-6594-rnd  ( -- u )
  rloc 2@ $6594 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-6594-random  ( n -- 0..n-1 )  cgm-6594-rnd um* nip  ;

need random-pix-benchmark

: cgm-6594-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $6594"
  ['] cgm-6594-random random-pix-benchmark  ;

( cgm-65E8-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-65E8-rnd  ( -- u )
  rloc 2@ $65E8 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-65E8-random  ( n -- 0..n-1 )  cgm-65E8-rnd um* nip  ;

need random-pix-benchmark

: cgm-65E8-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $65E8"
  ['] cgm-65E8-random random-pix-benchmark  ;

( dx-random )

  \ Credit:
  \
  \ Code from DX-Forth 4.13.

2variable dx-seed  1. dx-seed 2!

need d*

: dx-rnd ( -- u )
  dx-seed 2@ $15A4E35. d* 1. d+ tuck dx-seed 2!  ;
  \ Get random number

: dx-random ( u -- 0..u-1 )  dx-rnd um* nip  ;
  \ Get random number between 0 and u-1

need random-pix-benchmark

: dx-random-pix-benchmark  ( -- )
  s" DX-Forth" ['] dx-random random-pix-benchmark  ;

( gf-random )

  \ Credit:
  \
  \ Adapted from Gforth.

need os-seed  need ud*

: gf-rnd  ( -- n )
  272958469. os-seed @ ud* d>s 1+ dup os-seed !  ;

: gf-random  ( n -- 0..n-1 )  gf-rnd um* nip  ;

need random-pix-benchmark

: gf-random-pix-benchmark  ( -- )
  os-seed off  s" Gforth"
  ['] gf-random random-pix-benchmark  ;

( jer-random )

  \ Credit:
  \
  \ Random number generator by J. E. Rickenbacker, published on
  \ Forth Dimensions (volume 2, number 2, page 34, 1980-07).

need os-seed

: jer-rnd  ( -- n )
  os-seed @ 259 * 3 + 32767 and dup os-seed !  ;

: jer-random ( n1 -- n2 )
  jer-rnd 32767 */  ;
  \ Return a random number _n2_ (0 <= n2 < n1).

  \ XXX Note: patterns

need random-pix-benchmark

: jer-random-pix-benchmark  ( -- )
  os-seed off  s" J. E. Rickenbacker"
  ['] jer-random random-pix-benchmark  ;

( jml-random )

  \ Credit:
  \
  \ Adapted from code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need z80-asm  need os-seed

code jml-rnd  ( -- u )

  os-seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  os-seed sthl
  jppushhl
  end-code

: jml-random  ( n -- 0..n-1 )  jml-rnd um* nip  ;

need random-pix-benchmark

: jml-random-pix-benchmark  ( -- )
  os-seed off  s" J. M. Lazo"
  ['] jml-random random-pix-benchmark  ;

( lb-random )

  \ Credit:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: lb-rnd  ( -- u )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: lb-random  ( n -- 0..n-1 )  lb-rnd um* nip  ;

need random-pix-benchmark

: lb-random-pix-benchmark  ( -- )
  os-seed off  s" Leo Brodie"
  ['] lb-random random-pix-benchmark  ;

( lina-random )

need os-seed

: lina-rnd  ( -- n )
  os-seed @ 107465 * 234567 + dup os-seed !  ;

: lina-random  ( n -- 0..n-1 )  lina-rnd um* nip ;

need random-pix-benchmark

: lina-random-pix-benchmark  ( -- )
  os-seed off  s" lina"
  ['] lina-random random-pix-benchmark  ;

( mb-random )

  \ Credit:
  \
  \ Adapted from code published by Milos Bazelides:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

need z80-asm  need os-seed

code mb-rnd  ( -- u )
  os-seed de ftp
  d a ld  e h ld  #253 l ld#
  a or  de sbcp
  0 sbc#  de sbcp
  0 d ld#  d sbc  a e ld  de sbcp
  cy if  hl incp  then
  os-seed sthl
  jppushhl   end-code

: mb-random  ( n -- 0..n-1 )  mb-rnd um* nip  ;

  \ Original code:

  \ ----
  \ ; Input: none
  \ ; Output: HL = pseudo-random number, period 65536

  \ Rand16:
  \  ld  de,Seed    ; Seed is usually 0
  \  ld  a,d
  \  ld  h,e
  \  ld  l,253
  \  or  a
  \  sbc  hl,de
  \  sbc  a,0
  \  sbc  hl,de
  \  ld  d,0
  \  sbc  a,d
  \  ld  e,a
  \  sbc  hl,de
  \  jr  nc,Rand
  \  inc  hl
  \ Rand:
  \  ld  (Rand16+1),hl
  \  ret
  \ ----

need random-pix-benchmark

: mb-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides"
  ['] mb-random random-pix-benchmark  ;

( mm-random )

  \ Credit:
  \ IsForth Random Number Generator, by Mark I Manning IV.

  \ 2016-04-04: Adapted to Solo Forth. Strange negative
  \ results.
  \ XXX TODO -- check the original

need cell/  need frames@

variable seed1  variable seed2

: randomize  ( -- )  frames@ seed1 ! seed2 !  ;

: 0seed  ( -- )  seed1 off seed2 off  ;  0seed
  \ Reset random number generator seed to zero.

: mm-random  ( n1 --- n2 )
  seed1 @ 123 * 234 + seed2 @ 234 * 123 +
  2dup + seed2 ! 2dup xor seed1 !
  + swap cells mod cell/ ;

need random-pix-benchmark

: mm-random-pix-benchmark  ( -- )
  s" IsForth" ['] mm-random random-pix-benchmark  ;

  \ ' random-pix-benchmark2 ' random-pix-benchmark defer!

  \ mm-random-pix-benchmark

  \ ' random-pix-benchmark1 ' random-pix-benchmark defer!

  \ mm-random-pix-benchmark

( sf83-random )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

need os-seed  3 os-seed !

: sf83-random  ( n -- 0..n-1 )
  os-seed @ 743 * 43 + dup os-seed ! um* swap drop  ;

need random-pix-benchmark

: sf83-random-pix-benchmark  ( -- )
  s" Spectrum Forth-83"
  ['] sf83-random random-pix-benchmark  ;

( tt-random )

  \ Credit:
  \
  \ Code from tt.pfe, Tetris for terminals, redone in
  \ ANSI-Forth.  Written 1994-04-05 by Dirk Uwe Zoller.
  \
  \ Note: the seed can not be zero.

need os-seed

: tt-random   ( n -- 0..n-1 )
    os-seed @ 13 * $7FFF and
    dup os-seed !  swap mod ;

need random-pix-benchmark

: tt-random-pix-benchmark  ( -- )
  os-seed on  s" Tetris for terminals"
  ['] tt-random random-pix-benchmark  ;

( vf-random )

  \ Credit:
  \
  \ Code from vForth.

need os-frames

: vf-random  ( n -- 0..n-1 )
  1+ 8195 os-frames @ um* 1. d+
  16383 um/mod drop
  \ dup os-seed !
  swap mod  ;

need random-pix-benchmark

: vf-random-pix-benchmark  ( -- )
  s" vForth" ['] vf-random random-pix-benchmark  ;

( z88-random )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need ud*  need os-seed

: z88-random  ( n -- 0..n-1 )
  1103515245. \ 20077 16838
  os-seed @ ud* 12345. d+ over os-seed !
  rot ud/mod 2drop  ;

need random-pix-benchmark

: z88-random-pix-benchmark  ( -- )
  os-seed off  s" Z88 CamelForth"
  ['] z88-random random-pix-benchmark  ;

( zh-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code zh-rnd  ( -- u )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: zh-random  ( n -- 0..n-1 )  zh-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

need random-pix-benchmark

: zh-random-pix-benchmark  ( -- )
  os-seed off  s" Z80 Heaven"
  ['] zh-random random-pix-benchmark  ;

( random-byte )

code random-byte  ( -- b )
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

need bench{

: random-byte-test  ( -- )
  ['] random-byte ['] rng defer!  cls  bench{ pixels
  do  rng rng 192 min set-pixel  loop  }bench.
  ." Z80 R register" cr key drop ;

( lcm-random )

  \ XXX UNDER DEVELOPMENT

  \ Credit:
  \
  \ Adapted from code written by Everett F. Carter, published
  \ on Forth Dimensions (volume 16, number 2, page 17,
  \ 1994-08).
  \
  \ Linear Congruential Method, the "minimal standard
  \ generator", Park & Miller, 1988, Comm of the ACM, 31(10),
  \ pp. 1192-1201

need d*  need du/mod  need 2nip

2variable 2seed

2147483647. 2constant max32

: lcm-rnd  ( -- d )
  2seed 2@ 16807. d*
  max32 du/mod  2nip
  2dup 2seed 2!  ;
  \ XXX FIXME -- it always returns 0

  \ \ Original code:
  \ : lcm-rnd  ( -- d )
  \   2seed 2@ 16807. umd*
  \   max32 umd/mod
  \   2drop 2seed 2!  ;

: lcm-random  ( n -- 0..n-1 )  lcm-rnd d>s um* nip  ;

need random-pix-benchmark

: lcm-random-pix-benchmark  ( -- )
  s" LCM" ['] lcm-random random-pix-benchmark  ;

( 8-bit-random-pix-benchmarks )

  \ Execute all of the 8-bit random pixels benchmarks

need random-pix-benchmark  need +thru  1 5 +thru

' crnd-pix-benchmark2 ' random-pix-benchmark defer!

  \ libzx-random-pix-benchmark
  \ jw-random-pix-benchmark
  mb1-random-pix-benchmark
  mb2-random-pix-benchmark
  \ zh-random-pix-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' crnd-pix-benchmark1 ' random-pix-benchmark defer!

  \ jw-random-pix-benchmark
  \ libzx-random-pix-benchmark

( jw-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need z80-asm  need os-seed

code jw-crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

need random-pix-benchmark

: jw-random-pix-benchmark  ( -- )
  os-seed off  s" Joe Wingbermuehle"
  ['] jw-crnd random-pix-benchmark  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( mb1-crnd )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

  \ This is a very simple linear congruential generator. The
  \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
  \ advantage is small size and simplicity. Due to nature of
  \ such generators only a couple of higher bits should be
  \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb1-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  a inc  os-seed sta
    \  inc  a    ; another possibility is ADD A,7
    \  ld  (seed),a
  pusha jp
  end-code

: mb1-crandom  ( n1 -- n2 )  mb1-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need random-pix-benchmark

  \ : mb1-random-pix-benchmark  ( -- )
  \   s" Milos Bazelides 1" ['] mb1-crandom random-pix-benchmark  ;

: mb1-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides 1 (8 bit)"
  ['] mb1-crnd random-pix-benchmark  ;

( mb2-crnd )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb2-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  07 add#  os-seed sta
    \  add a,7
    \  ld  (seed),a
  pusha jp  end-code

: mb2-crandom  ( n1 -- n2 )  mb2-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need random-pix-benchmark

  \ : mb2-random-pix-benchmark  ( -- )
  \   s" Milos Bazelides 2" ['] mb2-crandom random-pix-benchmark  ;

: mb2-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides 2 (8 bit)"
  ['] mb2-crnd random-pix-benchmark  ;

( zh-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

code zh-crnd  ( -- b )

  os-seed fta  a e ld
  a add  e add  a add  a add  e add  #83 add#
  os-seed sta
  pusha jp

  end-code

need random-pix-benchmark

: zh-random-pix-benchmark  ( -- )
  s" Z80 Heaven (8 bit)" ['] zh-crnd random-pix-benchmark  ;

  \ This is one of many variations of PRNGs. This routine is
  \ not particularly useful for many games, but is fairly
  \ useful for shuffling a deck of cards. It uses SMC, but that
  \ can be fixed by defining randSeed elsewhere and using ld
  \ a,(randSeed) at the beginning.

  \ PseudoRandByte:
  \ ;f(n+1)=13f(n)+83
  \ ;97 cycles
  \      .db 3Eh     ;start of ld a,*
  \ randSeed:
  \      .db 0
  \      ld c,a
  \      add a,a
  \      add a,c
  \      add a,a
  \      add a,a
  \      add a,c
  \      add a,83
  \      ld (randSeed),a
  \      ret

( opt3-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized and modified
  \ the original code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  rom-pointer off  os-seed off

code opt3-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ftp  hl incp
  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld hl,(romPointer)
    \ inc hl
    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  rom-pointer off  os-seed off  s" libzx opt3 (8 bit)"
  ['] opt3-libzx-crnd random-pix-benchmark  ;

' crnd-pix-benchmark2 ' random-pix-benchmark defer!
libzx-random-pix-benchmark  \ XXX TMP --

( opt2-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized and modified
  \ the original code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  rom-pointer off  os-seed off

code opt2-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ftp  hl incp
  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld hl,(romPointer)
    \ inc hl
    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta
    \ ld (lastRandomNumber), a        ; save this number

  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  rom-pointer off  os-seed off  s" libzx opt2 (8 bit)"
  ['] opt2-libzx-crnd random-pix-benchmark  ;

libzx-random-pix-benchmark  \ XXX TMP --

( opt1-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized the original
  \ code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  3 rom-pointer !  33 os-seed c!

code opt1-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer bc ftp 3 hl ldp#  bc addp

    \ ld bc,(romPointer)
    \ ld hl,3
    \ add hl,bc ; HL := ROM pointer advanced by 3

  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta
    \ ld (lastRandomNumber), a        ; save this number

  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  3 rom-pointer !  33 os-seed c!
  s" libzx opt1 (8 bit)"
  ['] opt1-libzx-crnd random-pix-benchmark  ;

( libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  3 rom-pointer !  33 os-seed c!

code libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ldp#
  m c ld  hl incp  m b ld  3 hl ldp#  bc addp
    \ XXX TODO -- simpler
    \ XXX REMARK -- original code is not optimized

    \ ld hl, romPointer
    \ ld c, (hl)
    \ inc hl
    \ ld b, (hl)        ; BC := word (romPointer)
    \ ld hl, 3
    \ add hl, bc        ; HL := ROM pointer advanced by 3

  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld a, h
    \ and %00111111
    \ ld h, a          ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed ldp#  m a ld
    \ ld hl, lastRandomNumber
    \ ld (hl), a        ; save this number
    \ XXX REMARK -- original code is not optimized

  bc pop  0 h ld#  a l ld  jppushhl end-code

: libzx-random-pix-benchmark  ( -- )
  3 rom-pointer !  33 os-seed c!
  s" libzx (8 bit)" ['] libzx-crnd random-pix-benchmark  ;


  \ ===========================================================

  \ 2016-03-31
  \ Results of the 16-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Jupiter ACE manual     | 05937 (012%) | 07652 (153 s) | 1
  \ | C. G. Montgomery $5E9B | 49151 (099%) | 06917 (138 s) | 11
  \ | C. G. Montgomery $5E9B | 30985 (063%) | 06917 (138 s) | first only
  \ | C. G. Montgomery $61BF | 49152 (100%) | 06916 (138 s) | 11
  \ | C. G. Montgomery $61BF | 31024 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $62DC | 49152 (100%) | 06917 (138 s) | 12
  \ | C. G. Montgomery $62DC | 30964 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $6363 | 49152 (100%) | 06917 (138 s) | 11
  \ | C. G. Montgomery $6363 | 30917 (062%) | 06917 (138 s) | first only
  \ | C. G. Montgomery $6594 | 49151 (099%) | 06917 (138 s) | 10
  \ | C. G. Montgomery $6594 | 31009 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $65E8 | 49152 (100%) | 06917 (138 s) | 12
  \ | C. G. Montgomery $65E8 | 31006 (063%) | 06917 (138 s) | first only
  \ | DX-Forth               | 49152 (100%) | 17733 (354 s) | 12
  \ | DX-Forth               | 31076 (063%) | 17734 (354 s) | first only
  \ | Gforth                 | 31189 (063%) | 09746 (194 s) | 1
  \ | J. E. Rickenbacker     | 08149 (016%) | 18458 (369 s) | 1
  \ | J. M. Lazo             | 12637 (025%) | 03349 (066 s) | 1
  \ | Leo Brodie             | 20818 (042%) | 09150 (183 s) | 1
  \ | lina                   | 23945 (048%) | 09179 (183 s) | 1
  \ | Milos Bazelides        | 28465 (057%) | 03316 (066 s) | 1
  \ | Spectrum Forth-83      | 05194 (010%) | 08741 (174 s) | 1
  \ | Tetris for terminals   | 02038 (004%) | 14200 (284 s) | 1
  \ | vForth                 | 27448 (055%) | 14806 (296 s) | 10
  \ | vForth                 | 20804 (042%) | 14806 (296 s) | first only
  \ | Z88 CamelForth         | 05496 (011%) | 15683 (313 s) | 1
  \ | Z80 Heaven             | 32599 (066%) | 03371 (067 s) | 1

  \ 2016-03-31
  \ Results of the 8-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Joe Wingbermuehle      | 49145 (099%) | 01076 (021 s) | 29
  \ | Joe Wingbermuehle      | 25234 (051%) | 01075 (021 s) | first only
  \ | Milos Bazelides 1      | 00096 (000%) | 01047 (020 s) | 1
  \ | Milos Bazelides 2      | 00096 (000%) | 01048 (021 s) | 1
  \ | Z80 Heaven             | 00096 (000%) | 01055 (021 s) | 1

  \ 2016-04-07
  \ Results of the 16-bit version of `random-pix-benchmark`,
  \ with `os-seed` initialized to zero every time, except when
  \ the implementation needs a non-zero value:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Jupiter ACE manual     | 02272 (004%) | 07635 (152 s) | 1
  \ | C. G. Montgomery $5E9B | 49151 (099%) | 06899 (137 s) | 11
  \ | C. G. Montgomery $5E9B | 31064 (063%) | 06900 (138 s) | first only
  \ | C. G. Montgomery $61BF | 49152 (100%) | 06899 (137 s) | 12
  \ | C. G. Montgomery $61BF | 30983 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $62DC | 49152 (100%) | 06900 (138 s) | 10
  \ | C. G. Montgomery $62DC | 31054 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $6363 | 49152 (100%) | 06899 (137 s) | 10
  \ | C. G. Montgomery $6363 | 31063 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $6594 | 49152 (100%) | 06900 (138 s) | 11
  \ | C. G. Montgomery $6594 | 31084 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $65E8 | 49151 (099%) | 06900 (138 s) | 11
  \ | C. G. Montgomery $65E8 | 31123 (063%) | 06899 (137 s) | first only
  \ | DX-Forth               | 49152 (100%) | 17717 (354 s) | 11
  \ | DX-Forth               | 31031 (063%) | 17718 (354 s) | first only
  \ | Gforth                 | 31104 (063%) | 09725 (194 s) | 1
  \ | J. E. Rickenbacker     | 08192 (016%) | 18460 (369 s) | 1
  \ | J. M. Lazo             | 12608 (025%) | 03325 (066 s) | 1
  \ | Leo Brodie             | 20928 (042%) | 09131 (182 s) | 1
  \ | lina                   | 24064 (048%) | 09161 (183 s) | 1
  \ | Milos Bazelides        | 28715 (058%) | 03297 (065 s) | 1
  \ | Spectrum Forth-83      | 05120 (010%) | 08723 (174 s) | 1
  \ | Tetris for terminals   | 00096 (000%) | 14210 (284 s) | 1
  \ | vForth                 | 29248 (059%) | 14807 (296 s) | 9
  \ | vForth                 | 21694 (044%) | 14806 (296 s) | first only
  \ | Z88 CamelForth         | 00384 (000%) | 15683 (313 s) | 1
  \ | Z80 Heaven             | 32768 (066%) | 03352 (067 s) | 1

  \ 2016-04-08
  \ Results of the 8-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Joe Wingbermuehle      | 49140 (099%) | 01075 (021 s) | 27
  \ | Joe Wingbermuehle      | 25308 (051%) | 01075 (021 s) | first only
  \ | libzx                  | 25650 (052%) | 01389 (027 s) | 2
  \ | libzx                  | 25380 (051%) | 01390 (027 s) | first only
  \ | libzx (opt1)           | 25650 (052%) | 01389 (027 s) | 2
  \ | libzx (opt2)           | 25784 (052%) | 01382 (027 s) | 2
  \ | libzx (opt2)           | 25650 (052%) | 01382 (027 s) | first only
  \ | Milos Bazelides 1      | 00096 (000%) | 01052 (021 s) | 1
  \ | Milos Bazelides 2      | 00096 (000%) | 01055 (021 s) | 1
  \ | Z80 Heaven             | 00096 (000%) | 01061 (021 s) | 1


  \ vim: filetype=soloforth
  \ development_tests.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Development tests.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( alias-test synonym-test )

  \ 2015-11-24

need alias need synonym

' literal alias literal-a
' border alias border-a
' if alias if-a

synonym border-s border
synonym literal-s literal
synonym if-s if

  \ XXX TMP -- alternative `synonym` that uses `alias`
synonym2 border-s2 border
synonym2 literal-s2 literal
synonym2 if-s2 if

  \ : ifa if-a ." yes" then ;   \ "then" error #-4
  \ : ifs if-s ." yes" then ;   \ ok
  \ : ifs2 if-s2 ." yes" then ;   \ "then" error #-4
  \
  \ 1 literal     \ error -14 \ ok
  \ 1 literal-a   \ no error
  \ 1 literal-s   \ error -14 \ ok
  \ 1 literal-s2  \ no error
  \
  \ : zx [ 1 ] literal ;      \ ok
  \ : zx [ 1 ] literal-a ;    \ error #-264
  \ : zx [ 1 ] literal-s ;    \ no error \ ok
  \ : zx [ 1 ] literal-s2 ;   \ error #-264

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test >body 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test >body dup here swap - dump

( {if-test {do-test )

  \ 2015-11-11

: test2  ( n -- )
  {do   dup 5 <   do> ." <5" cr 1+
  |do|  dup 10 <  do> ." <10" cr 1+
  do} drop  ;

: test1  ( n1 n2 -- )
  {if   2dup > if> ." >" cr
  |if|  2dup < if> ." <" cr
  if}  ;

( options[-test )

: o1 ." option 1" ;  : o2 ." option 2" ;  : o3 ." option 3" ;

: test  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
  ]options  ." end of test" cr   ;

: retest  ( -- )  [char] a test ." end of retest" cr  ;

: o0 ." default" ;

: testd  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
    default-option o0
  ]options  ;

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( exception-test )

  \ Credit:
  \
  \ Code from MPE Forth for TiniARM User Manual.

: could-fail  ( -- c )
  key dup [char] q =
  if  -1 throw  then  ;

: do-it  ( a b -- c )
  2drop could-fail  ;

: try-it  ( -- )
  1 2 ['] do-it catch
  if    ( x1 x2 )  2drop ." There was an exception" cr
  else  ." The character was " emit cr then  ;

: retry-it  ( -- )
  begin   1 2 ['] do-it catch
  while   ( x1 x2 ) 2drop ." Exception, keep trying" cr
  repeat  ( c )
  ." The character was " emit cr  ;

( err>ord )

  \ XXX TMP -- `err>ord` tests `error>ordinal`

: err>ord  ( -- )
  91 1 do  i . i error>ordinal ."  -> " . cr  loop
  286 256 do  i . i error>ordinal ."  -> " . cr  loop
  1025 1000 do  i . i error>ordinal ."  -> " . cr  loop ;

.( block x line 0)
  .( block x line 1 ) cr
  .( block x line 2 ) cr
  .( block x line 3 ) cr
  .( block x line 4 ) cr
  .( block x line 5 ) cr
  .( block x line 6 ) cr
  .( block x line 7 ) cr
  .( block x line 8 ) cr
  .( block x line 9 ) cr
  .( block x line 10 ) cr
  .( block x line 11 ) cr
  .( block x line 12 ) cr
  .( block x line 13 ) cr
  .( block x line 14 ) cr
  .( block x line 15 ) cr
.( block x+1 line 0)
  .( block x+1 line 1 ) cr
  .( block x+1 line 2 ) cr
  .( block x+1 line 3 ) cr
  .( block x+1 line 4 ) cr
  .( block x+1 line 5 ) cr
  .( block x+1 line 6 ) cr
  .( block x+1 line 7 ) cr
  .( block x+1 line 8 ) cr
  .( block x+1 line 9 ) cr
  .( block x+1 line 10 ) cr
  .( block x+1 line 11 ) cr
  .( block x+1 line 12 ) cr
  .( block x+1 line 13 ) cr
  .( block x+1 line 14 ) cr
  .( block x+1 line 15 ) cr

( XXX TMP -- block for temporary tries)

need thru
blk @ 1+ blk @ 2+ thru

( XXX TMP -- block for temporary tries)

: hello  ( -- )

  ;

  \ vim: filetype=soloforth
  \ dos.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111420

  \ -----------------------------------------------------------
  \ Description

  \ G+DOS support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \
  \ 2016-04-11: Started `plusd-in`, plusd-out`, `plusd-in,`,
  \ plusd-out,`.

( plusd-in plusd-out )

  \ XXX UNDER DEVELOPMENT -- second version

need z80-asm  need --hook-codes--

code plusd-in  ( -- )
  patch hook
  jpnext
  end-code

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ }doc

code plusd-out  ( -- )
  D3 c, #231 c,     \ out (231),a
  jpnext
  end-code

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ }doc

( plusd-in plusd-out )

  \ XXX UNDER DEVELOPMENT -- first version

code plusd-in  ( -- )
  DB c, #231 c,     \ in a,(231)
  jpnext
  end-code

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ }doc

code plusd-out  ( -- )
  D3 c, #231 c,     \ out (231),a
  jpnext
  end-code

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ }doc

( plusd-in, plusd-out, )

  \ XXX UNDER DEVELOPMENT

need macro

macro plusd-in,  ( -- )
  DB c, #231 c,     \ in a,(231)
  endm

  \ doc{
  \
  \ plusd-in,  ( -- )
  \
  \ Compile machine code to page in the Plus D memory.
  \
  \ }doc

macro plusd-out,  ( -- )
  D3 c, #231 c,     \ out (231),a
  endm

  \ doc{
  \
  \ plusd-out,  ( -- )
  \
  \ Compile machine code to page out the Plus D memory.
  \
  \ }doc

( ufia )

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1   \ drive: 1 or 2
ufia 1+   constant fstr1   \ program number
ufia 2+   constant sstr1   \ stream number
ufia 3 +  constant device  \ device: "D" or "d"
ufia 4 +  constant nstr1   \ directory description
ufia 5 +  constant nstr2   \ file name
ufia 15 + constant hd00    \ file type
ufia 16 + constant hd0b    \ file length
ufia 18 + constant hd0d    \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

char d device c! \ "d" or "D"
2 sstr1 c!  \ stream 2
1 dstr1 c!  \ drive 1

variable file-length   \ copy of `hd0b` used by `(<file)`
variable file-address  \ copy of `hd0d` used by `(<file)`

( --file-types-- )

0 constant basic-filetype
1 constant data-array-filetype
2 constant string-array-filetype
3 constant code-filetype

: --file-types--  ;

( --directory-descriptions-- )

01 constant basic-file-dir      02 constant data-array-dir
03 constant string-array-dir    04 constant code-file-dir
05 constant snapshot-48k-dir    06 constant microdrive-file-dir
07 constant screens$-file-dir   08 constant special-file-dir
09 constant snapshot-128k-dir   10 constant opentype-file-dir
11 constant execute-file-dir

: --directory-descriptions--  ;

( --hook-codes-- )

$33 constant hxfer  $34 constant ofsm  $35 constant hofile
$36 constant sbyte  $37 constant hsvbk $38 constant cfsm
$39 constant pntp   $3A constant cops  $3B constant hgfile
$3C constant lbyte  $3D constant hldbk $3E constant wsad
$3F constant sad    $40 constant rest  $41 constant heraz
$42 constant cops2  $43 constant pcat  $44 constant hrsad
$45 constant hwsad  $46 constant otfoc $47 constant patch

: --hook-codes--  ;

( dosior>error ?dos-error dosior>ior )

: dosior>error  ( dosior -- f n )
  dup 1 and negate swap   \ calculate f
  flip %11111111 and      \ upper 8 bits of ior
  1000 + negate  ;
  \ Convert a DOS ior to a Forth error number.
  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ f = error?
  \ n = error number:
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26
  \ XXX OLD -- obsolete

: ?dos-error  ( dosior -- )
  \ dosior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: OS error; unset: DOS error
  dosior>error ?throw  ;
  \ XXX OLD -- obsolete

: dosior>ior  ( dosior -- ior )
  dup 1 and negate          \ error?
  swap flip %11111111 and   \ get upper 8 bits
  1000 + negate and  ;
  \ Convert a DOS ior to a Forth ior.
  \ dosior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ ior = error number:
  \     0: no error
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26
  \ XXX TODO -- check

( get-drive set-drive )

need z80-asm  need --hook-codes--

code get-drive  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  \ save the Forth IP
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp  end-code

code set-drive  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  \ save the Forth IP
  l a ld  21 hook   \ select drive in a
  bc pop   next ix ldp#  \ restore the Forth registers
  jpnext  end-code

( delete-file )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia  need dosior>ior

code (delete-file)  ( -- ior )
  bc push  \ save the Forth registers
  ufia ix ldp#
  heraz hook  \ erase the file
  bc pop  next ix ldp#  \ restore the Forth registers
  af push
  jpnext
  end-code
  \ Delete a disk file using the data hold in UFIA.
  \ Return a G+DOS _ior_.

: delete-file  ( ca len -- ior )
  filename>ufia (delete-file) dosior>ior  ;
  \ Delete a disk file _ca len_ and return I/O result code
  \ _ior_.

( -filename filename! >ufia filename>ufia )

need ufia  need get-drive

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;
  \ XXX TODO -- rename to `set-filename`?

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  get-drive dstr1 c!  ;

1 set-drive  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  bc pop  next ix ldp#  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- ior )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) dosior>ior  ;

( <file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- ior )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) dosior>ior  ;

( file>screen )

  \ XXX UNDER DEVELOPMENT
  \ Experimental code to read lines from a file

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (file>screen)  ( -- dosior )

  \ Print a file on the screen, line by line, using the data
  \ hold in UFIA.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    patch hook  4000 de ldp#  128 bc ldp#
      \ page +D in
      \ destination and count

    d h ld
    begin   lbyte hook  de stap
            a l ld  de push  bc push  1744 call  bc pop  de pop
              \ print HL
            de incp  bc decp  b a ld  c or
    z until  E7 out  \ page +D out
    \ begin
    \   lbyte hook  af push  10 hook  af pop  13 cp
    \ z until

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code -->

( file>screen )

: file>screen  ( ca2 len2 -- ior )
  \ Copy a file to the screen, line by line.
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (file>screen) dosior>ior  ;

( .100 )

  \ XXX TMP -- for debugging

code .100  ( u -- )
  hl pop
  bc push
  hl push
  patch hook
  hl pop
  1744 call
  E7 out  \ page +D out
  bc pop  next ix ldp#  jpnext
  end-code

( <file-as-is )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (<file-as-is)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    hd0d de ftp  hd0b bc ftp  hldbk hook
      \ Use the address and length from the header.
      \ Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ Restore the Forth registers and save the ior.

  jpnext  end-code

: <file-as-is  ( ca len -- ior )
  \ Load a file from disk.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2swap >ufia (<file-as-is) dosior>ior  ;

( file? )

need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )

  bc push  \ save the Forth IP
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  ' true jpz
  ' false jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ $3E01 constant ufia1
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  exx
    \ Get the parameter in hl' and save the Forth IP

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  \ exx  l a ld  24B5 call  168E call \ XXX OLD
    \ 24B5 = CAT_RUN (input: cat type in the A register)
    \ 168E = BORD_REST (restore the border)

  exx  l a ld  09A5 call \ XXX NEW
    \ 09A5 = SCAN_CAT  (input: cat or search type in the A register)

  E7 out  bc pop  next ix ldp#  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need z80-asm  need --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

need z80-asm  need --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

need z80-asm  need --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( !dos )

need z80-asm  need --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  \ save the Forth IP
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ bc pop  next ix ldp#  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

  \ vim: filetype=soloforth
  \ editor.specforth.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604032014

  \ -----------------------------------------------------------
  \ Description

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum.  Its original
  \ name is "Specforth Editor V1.1".
  \
  \ It has been adapted to Solo Forth.
  \
  \ Word descriptions and stack comments have been added after
  \ the Specforth manual, the Abersoft Forth manual and Dr.
  \ C.H. Ting's book _Systems Guide to fig-Forth_. The word
  \ `copy` has been adapted from Abersoft Forth. The word
  \ `text` has been rewritten.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-11: Adapted to Solo Forth.

( editor )

only forth definitions

need list  need update  need flush  need parse-line

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "ccc<char>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "ccc<eol>" -- )
  pad c/l 1+ blank  parse-line  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type [char] _ emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "ccc<eol>"  -- )  text r  ;
  \ Put "ccc" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear block _n_ with blanks and select for editing.

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= leave  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 leave  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "ccc<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "ccc" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "ccc<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "ccc".

: till  ( "ccc<eol>" -- )
  #lead + text 1line 0= #-270 ?throw
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "ccc".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "ccc<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "ccc" to the cursor line at the cursor position.

also forth

: copy  ( n1 n2 -- )
  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ vim: filetype=soloforth
  \ environmental_queries.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `environment?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( environment? )

need wid-of

vocabulary environment ( -- )
wid-of environment constant environment-wordlist ( -- wid )
  \ Wordlist that is searched by environmental queries.

: environment? ( ca len -- false | i*x true )
  environment-wordlist search-wordlist
  if  execute true  else  false  then  ;

also environment definitions

8 constant address-unit-bits ( -- n )
  \ Size of one address unit, in bits.

255 constant max-char ( -- u )
  \ Maximum value of any character in the character set.

255 constant /counted-string ( -- n )
  \ Maximum size of a counted string, in characters.

  \ XXX TODO
address-unit-bits cells 2* 2+ constant /hold ( -- n )
  \ Size of the pictured numeric string output buffer, in
  \ characters.

  \ XXX TODO calculate
84 constant /pad ( -- n )
  \ Size of the scratch area pointed to by `pad`, in
  \ characters.

1 -3 mod 0< constant floored ( -- f )
  \ True if `/` etc. perform floored division

-->

( environment? )

32767 constant max-n ( -- n )
  \ Largest usable signed integer.

-1 constant max-u ( -- u )
  \ Largest usable unsigned integer.

-1 max-n 2constant max-d ( -- d )
  \ Largest usable signed double.

-1. 2constant max-ud ( -- ud )
  \ Largest usable unsigned double.

  \ XXX TODO -- calculate
$50 constant return-stack-cells ( -- n )
  \ : return-stack-cells ( -- n )
    \ [ forthstart 6 cells + ] literal @ cell / ;
    \ Maximum size of the return stack, in cells.

  \ XXX TODO -- calculate
$50 constant stack-cells ( -- n )
  \ : stack-cells ( -- n )
    \ [ forthstart 4 cells + ] literal @ cell / ;
    \ Maximum size of the data stack, in cells.

  \ XXX TODO -- add "#locals" when needed

forth definitions  previous

  \ exception.codes.0001.standard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604031748

  \ -----------------------------------------------------------
  \ Description

  \ The standard Forth error codes (range -255..-1).

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( Standard error codes #-01..#-15)

\ #-01 ABORT
\ #-02 ABORT"
\ #-03 stack overflow
\ #-04 stack underflow
\ #-05 return stack overflow
\ #-06 return stack underflow
\ #-07 do-loops nested too deeply during execution
\ #-08 dictionary overflow
\ #-09 invalid memory address
\ #-10 division by zero
\ #-11 result out of range
\ #-12 argument type mismatch
\ #-13 undefined word
\ #-14 interpreting a compile-only word
\ #-15 invalid FORGET

( Standard error codes #-16..#-30)

\ #-16 attempt to use zero-length string as a name
\ #-17 pictured numeric output string overflow
\ #-18 parsed string overflow
\ #-19 definition name too long
\ #-20 write to a read-only location
\ #-21 unsupported operation
\ #-22 control structure mismatch
\ #-23 address alignment exception
\ #-24 invalid numeric argument
\ #-25 return stack imbalance
\ #-26 loop parameters unavailable
\ #-27 invalid recursion
\ #-28 user interrupt
\ #-29 compiler nesting
\ #-30 obsolescent feature

( Standard error codes #-31..#-45)

\ #-31 >BODY used on non-CREATEd definition
\ #-32 invalid name argument
\ #-33 block read exception
\ #-34 block write exception
\ #-35 invalid block number
\ #-36 invalid file position
\ #-37 file I/O exception
\ #-38 non-existent file
\ #-39 unexpected end of file
\ #-40 invalid BASE for floating point conversion
\ #-41 loss of precision
\ #-42 floating-point divide by zero
\ #-43 floating-point result out of range
\ #-44 floating-point stack overflow
\ #-45 floating-point stack underflow

( Standard error codes #-46..#-60)

\ #-46 floating-point invalid argument
\ #-47 compilation word list deleted
\ #-48 invalid POSTPONE
\ #-49 search-order overflow
\ #-50 search-order underflow
\ #-51 compilation word list changed
\ #-52 control-flow stack overflow
\ #-53 exception stack overflow
\ #-54 floating-point underflow
\ #-55 floating-point unidentified fault
\ #-56 QUIT
\ #-57 exception in sending or receiving a character
\ #-58 [IF], [ELSE], or [THEN] exception
\ #-59 ALLOCATE
\ #-60 FREE

( Standard error codes #-61..#-75 )

\ #-61 RESIZE
\ #-62 CLOSE-FILE
\ #-63 CREATE-FILE
\ #-64 DELETE-FILE
\ #-65 FILE-POSITION
\ #-66 FILE-SIZE
\ #-67 FILE-STATUS
\ #-68 FLUSH-FILE
\ #-69 OPEN-FILE
\ #-70 READ-FILE
\ #-71 READ-LINE
\ #-72 RENAME-FILE
\ #-73 REPOSITION-FILE
\ #-74 RESIZE-FILE
\ #-75 WRITE-FILE

( Standard error codes #-76..#-79 )

\ #-76 WRITE-LINE
\ #-77 malformed xchar
\ #-78 SUBSTITUTE
\ #-79 REPLACES
\ #-80
\ #-81
\ #-82
\ #-83
\ #-84
\ #-85
\ #-86
\ #-87
\ #-88
\ #-89
\ #-90

  \ vim: filetype=soloforth
  \ exception.codes.0256.system.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140237

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256), except
  \ those reserved for the OS and the DOS.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( System error codes #-256..#-270 )

\ #-256 not a word nor a number
\ #-257 warning: is not unique
\ #-258 stack imbalance
\ #-259 trying to load from block 0
\ #-260 wrong digit
\ #-261 deferred word is uninitialized
\ #-262 assertion failed
\ #-263 execution only
\ #-264 definition not finished
\ #-265 loading only
\ #-266 off current editing block
\ #-267 warning: not present, though required
\ #-268 required, but not located
\ #-269 relative jump too long
\ #-270 text not found

( System error codes #-271..#-285)

\ #-271 immediate word not allowed in this structure
\ #-272 array index out of range
\ #-273 invalid assembler condition
\ #-274 command line history overflow
\ #-275 wrong number
\ #-276 dictionary reached the zone of memory banks
\ #-277 required, but not indexed
\ #-278 empty block found: quit indexing
\ #-279
\ #-280
\ #-281
\ #-282
\ #-283
\ #-284
\ #-285

  \ vim: filetype=soloforth

  \ exception.codes.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ G+DOS (range -1031..-1000).

( G+DOS error codes #-1000..#-1014)

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1000 G+DOS: Nonsense in G+DOS
\ #-1001 G+DOS: Nonsense in GNOS
\ #-1002 G+DOS: Statement end error
\ #-1003 G+DOS: Break requested
\ #-1004 G+DOS: Sector error
\ #-1005 G+DOS: Format data lost
\ #-1006 G+DOS: Check disk in drive
\ #-1007 G+DOS: No +SYS file
\ #-1008 G+DOS: Invalid file name
\ #-1009 G+DOS: Invalid station
\ #-1010 G+DOS: Invalid device
\ #-1011 G+DOS: Variable not found
\ #-1012 G+DOS: Verify failed
\ #-1013 G+DOS: Wrong file type
\ #-1014 G+DOS: Merge error

( G+DOS error codes #-1015..#-1029)

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1015 G+DOS: Code error
\ #-1016 G+DOS: Pupil set
\ #-1017 G+DOS: Invalid code
\ #-1018 G+DOS: Reading a write file
\ #-1019 G+DOS: Writing a read file
\ #-1020 G+DOS: O.K. G+DOS
\ #-1021 G+DOS: Network off
\ #-1022 G+DOS: Wrong drive
\ #-1023 G+DOS: Disk write protected
\ #-1024 G+DOS: Not enough space on disk
\ #-1025 G+DOS: Directory full
\ #-1026 G+DOS: File not found
\ #-1027 G+DOS: End of file
\ #-1028 G+DOS: File name used
\ #-1029 G+DOS: No G+DOS loaded

( G+DOS error codes #-1030..#-1031)

\ #-1030 G+DOS: STREAM used
\ #-1031 G+DOS: CHANNEL used

  \ vim: filetype=soloforth
  \ exception.codes.os.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604031807

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ ZX Spectrum OS (range -1154..-1128).

( OS error codes #-1128..#-1142)

  \ XXX TODO -- it seems OS error codes (there are 28 of them)
  \ may be returned by G+DOS.  they are detected and converted
  \ by `ior>error`.

\ #-1128 OS:
\ #-1129 OS:
\ #-1130 OS:
\ #-1131 OS:
\ #-1132 OS:
\ #-1133 OS:
\ #-1134 OS:
\ #-1135 OS:
\ #-1136 OS:
\ #-1137 OS:
\ #-1138 OS:
\ #-1139 OS:
\ #-1140 OS:
\ #-1141 OS:
\ #-1142 OS:

( OS error codes #-1143..#-1154)

\ #-1143 OS:
\ #-1144 OS:
\ #-1145 OS:
\ #-1146 OS:
\ #-1147 OS:
\ #-1148 OS:
\ #-1149 OS:
\ #-1150 OS:
\ #-1151 OS:
\ #-1151 OS:
\ #-1152 OS:
\ #-1153 OS:
\ #-1154 OS:

  \ vim: filetype=soloforth
  \ exception.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604141453

  \ -----------------------------------------------------------
  \ Description

  \ The management of exceptions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09: Main development.
  \
  \ 2015-10: Fixes.
  \
  \ 2016-04-14: Restored the file from the repository. It was
  \ removed from version 0.3.0+2016-04-09 by mistake. Updated
  \ the headers and documentation.  Renamed `(.throw)` to
  \ `.throw-message`, and `msg-scr` to `error-messages-block`.
  \ Fixed `error>ordinal`.

( abort" )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only

( error>ordinal error>line )

: error>ordinal  ( -n1 -- +n2 )
  abs dup 256 < ?exit
      dup 1000 < if  [ 256 091 - ] literal - exit  then
      [ 1000 286 - 256 091 - + ] literal -   ;

  \ XXX TODO  add OS codes

  \ doc{
  \
  \ error>ordinal  ( -n1 -- +n2 )
  \
  \ Convert an error code _n1_ to its ordinal position _+n2_ in
  \ the library.

  \ ----
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146
  \ ----

  \ }doc

: error>line  ( -n1 -- n2 )
  error>ordinal dup >r
  begin
    dup dup 16 / - r@ <>  while  1+
  repeat  rdrop  ;

  \ doc{
  \
  \ error>line  ( -n1 -- n2 )
  \
  \ Convert error code _-n1_ to line _n2_ relative to the block
  \ that contains the error messages.
  \
  \ }doc

( error-messages-block .throw-message )

need error>line  need .line

variable error-messages-block
s" Standard error codes" located error-messages-block !
  \ XXX TODO rename!

  \ doc{
  \
  \ error-messages-block  ( -- a )
  \
  \ Variable that holds the block that holds the error
  \ messages.
  \
  \ }doc

: .throw-message  ( n -- )
  error-messages-block @
  if    error>line error-messages-block @ .line space
  else  .throw#  then  ;

' .throw-message ' .throw defer!

  \ doc{
  \
  \ .throw-message  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`: Print the
  \ text of throw error _n_.  The variable
  \ `error-messages-block` holds the number of the first
  \ block where messages are hold. If it contains zero, only
  \ the error number is printed.
  \
  \ }doc

( ?compiling ?executing )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.associative-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `associative-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-09: Fixed the file header.

( associative-case: )

need create:

: associative-case: ( "name" -- )
  create:
  does> ( n -- ) ( n pfa ) cell+  \ move past `lit`
  begin   2dup @ dup 0= >r  ( n a n n')
          =  r> or  0= ( n a f )
  while   ( n a )  [ 3 cells ] literal +  \ no match
  repeat  nip cell+ perform  ;

  \ doc{

  \ associative-case: ( "name" -- )
  \
  \ Create an associative case definition "name":
  \ `name  ( i*x n -- j*x )`.

  \ Usage example:

  \ ----
  \ : red       ." red"  ;
  \ : blue      ." blue"  ;
  \ : orange    ." orange"  ;
  \ : pink      ." pink"  ;
  \ : black     ." black"  ;
  \
  \ associative-case: color  ( n -- )
  \   7 red  12 blue  472 orange  15 pink  0 black  ;
  \
  \ 7 color cr  472 color cr  3000 color cr
  \ ----

  \ _n_ for default must be 0 and the default pair must be
  \ last.  Numbers can be in any order except 0 must be last.
  \ An actual zero or a no match causes the default to be
  \ executed.  Numbers can't be constants.

  \ }doc

  \ vim: filetype=soloforth
  \ flow.begin-execute.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-execute`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( base-execute )

  \ Credit:
  \
  \ Word from Gforth.

: base-execute  ( xt n -- )  base @ >r execute r> base !  ;
  \ Execute _xt_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

  \ vim: filetype=soloforth
  \ flow.begincase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begincase nextcase`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( begincase )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

need cs-push  need cs-pop

: begincase
  postpone case  postpone begin  cs-push  ; immediate

: (nextcase)
  cs-pop  postpone again  postpone endcase  ; immediate

: nextcase
  postpone drop  postpone (nextcase)  ; immediate

: test
  begincase
    cr ." press a key ('2' '4' '9' exits) : " key
    [char] 2 of  ." ... 2 "  endof
    [char] 4 of  ." ... 4 "  endof
    [char] 9 of  ." ... 9 "  endof
      dup emit ."  try again"
  nextcase  ;

  \ vim: filetype=soloforth
  \ flow.bracket-switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `[switch`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( [switch switch] )

  \ 2015-11-15

  \ Credit:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default xt
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched xt. If no match is found, leave _n_ on
  \ the stack and execute the default xt.

: :switch  ( xt "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _xt_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head xt n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _xt_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the xt of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

: run:  ( head n "ccc<semicolon>" -- )
  :noname [char] ; parse evaluate postpone ; ( xt )
  swap >switch  ;

( [switch-test ) \ without syntactic sugar

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test ) \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

  \ vim: filetype=soloforth
  \ flow.call.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `call`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( call )

code call  ( a -- )

  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next

  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

  \ vim: filetype=soloforth
  \ flow.case.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604021926

  \ -----------------------------------------------------------
  \ Description

  \ Several implementations of the standard Eaker's `case`
  \ structure and some variants of `of`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: x -- )
  postpone drop  begin  ?dup  while  [compile] then  repeat
  ; immediate compile-only

( eforth-case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  [compile] then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( 94-doc-case )

  \ Credit:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( abersoft-case )

  \ Credit:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credit:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credit:
  \
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credit:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID: <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credit:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

  \ vim: filetype=soloforth
  \ flow.cases-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `cases:`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( cases: )

  \ `cases:` structure, alternative to the standard `case`.
  \ It saves space, but is slower.

  \ 2015-11-14

  \ Credit:
  \
  \ Adapted, renamed and commented from code written by Dan
  \ Lerner, published on Forth Dimensions (volume 3, number 6,
  \ page 189, 1982-03).

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  leave
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>  say10
  \    100 case>  say100
  \   1000 case>  say1000
  \        other> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: other>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ XXX TODO -- rename? `anycase>`, `othercase>`...

  \ doc{
  \
  \ other>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required, `other>
  \ noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.create-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `create:`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ Create a word that will return the address of its pfa.

  \ Credit:
  \
  \ The idea for this word was borrowed from CP/M-volksForth
  \ 3.80a.

  \ vim: filetype=soloforth
  \ flow.dfor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160145

  \ -----------------------------------------------------------
  \ Description

  \ `dfor dstep`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-01: Written, a double-cell variant of `for step`.
  \
  \ 2015-03-23: Renamed `di` to `dfor-i`, after `for-i`,
  \ because `i` cannot be used since the implementation of the
  \ Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header.  Fixed stack
  \ notations.

( dfor dstep di )

: (dstep)  ( R: x d -- x d' )

  \ doc{
  \
  \ (dstep)  ( R: x d -- x d' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( d -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest ) Run-time: ( d -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `dfor-i`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' 2r@ alias dfor-i  ( -- d )

  \ doc{
  \
  \ dfor-i  ( -- d )
  \
  \ Return the current index _d_ of a `dfor` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.dijkstra.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Dijkstra control structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming". Originally published
  \ on Forth Dimensions (volume 18, number 4, pp 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh.

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 ?do  postpone then  loop  ; immediate compile-only
  \ end a conditional

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming" Originally published
  \ on Forth Dimensions (number 18, number 4, pages 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ vim: filetype=soloforth
  \ flow.doer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Leo Brodie's `doer make` construct.

  \ -----------------------------------------------------------
  \ Credit

  \ Original code by Leo Brodie, 1983, published on _Thinking
  \ Forth_, Appendix A. Public domain.

  \ This version was adapted from PFE by Marcos Cruz
  \ (programanadla.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( doer )

: doer-noop ;

: doer  ( "name" -- )
  \ Define a word whose behaviour is vectorable.
  create  ['] doer-noop >body ,
  does>  ( pfa ) @ >r ;

: (make)
  \ Stuff the address of further code into the parameter field
  \ of a doer word.
  r> dup cell+ dup cell+
    ( a1 a2 a2 )
    \ a1 = address of an optional continuation after `;and`,
    \      or zero
    \ a2 = address of the doer word
    \ a3 = address of the code to associate the doer word with
  swap @ >body !
    \ Get the pfa of the doer word and store the code address
    \ into it.
  @ ?dup if  >r  then ;
    \ Manage the optional continuation after `;and`.

variable >;and
  \ Hold the address of optional continuation pointer.

: make
  \ Used interpretively:
  \   make doer-name forth-code ;
  \ Or inside a definition:
  \   : definition  make doer-name forth-code  ;
  compiling? if     postpone (make)  here >;and ! 0 ,
             else   here ' >body ! ]  then  ; immediate

: ;and  ( -- )  postpone exit  here >;and @ !  ; immediate
  \ Allow continuation of the "making" definition.

: undo  ( "name" -- )  ['] doer-noop >body  ' >body ! ;
  \ Make the doer word "name" safe to execute.

( doer-test )

need doer

doer test
  .( Test 1: ) test
make test  cr ." test 2" ;
  .( Test 2: ) test
: change    make test ." test 3" ;and  test ;
change
  .( Test 3: ) test
undo test
  .( Test 4: ) test

  \ vim: filetype=soloforth
  \ flow.dont.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `don't`

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.dtimes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `dtimes`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

  \ vim: filetype=soloforth
  \ flow.executions.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `executions`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( executions )

  \ Credit:
  \
  \ Code from Galope (module times.fs).

: executions  ( xt n -- )
  \ Execute _xt_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

  \ vim: filetype=soloforth
  \ flow.for.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160140

  \ -----------------------------------------------------------
  \ Description

  \ `for step`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Adapted and modified from code written by Garry Lancaster
  \ for Z88 CamelForth, 2001.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-07-06: Adapted from Z88 CamelForth.
  \
  \ 2015-08-14: Checked. Removed the fig-Forth compiler
  \ security.  Moved from the kernel to the library.  Improved
  \ after Gforth: now the index is checked before decrementing
  \ it.  Documented.
  \
  \ 2015-03-23: Added `for-i`, because `i` cannot be used since
  \ the implementation of the Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header. Fixed stack
  \ notations.

( for step )

  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch ,
    \ jp nz,branch_code ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( n -- )
  \
  \ Start of a `for step` loop, that will iterate _n+1_ times,
  \ starting with _n_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `for-i`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' r@ alias for-i  ( -- n )

  \ doc{
  \
  \ for-i  ( -- n )
  \
  \ Return the current index _n_ of a `for` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.j.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604150138

  \ -----------------------------------------------------------
  \ Description

  \ `j` and `k`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-15: Written.

( j )

code j  ( -- n|u ) ( R: do-sys1 do-sys2 -- do-sys1 do-sys2 )
  2A c, rp ,  11 c, 3 cells ,  19 c,  C3 c, (i) ,
    \ ld hl,(return_stack_pointer)
    \ ld de,3*cell
    \ add hl,de
    \ jp i.hl
  end-code

  \ doc{
  \
  \ j  ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
  \
  \ Return a copy _n|u_ of the next-outer loop index.
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE),
  \ Forth-2012 (CORE).  Note: `k` was also in Forth-79
  \ (Reference word set), but returned a signed number.
  \
  \ }doc

( k )

code k  ( -- n|u )
  ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  2A c, rp ,  11 c, 6 cells ,  19 c,  C3 c, (i) ,
    \ ld hl,(return_stack_pointer)
    \ ld de,6*cell
    \ add hl,de
    \ jp i.hl
  end-code

  \ doc{
  \
  \ k  ( -- n|u ) ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  \
  \ Return a copy _n|u_ of the second outer loop index.
  \
  \ Origin: Forth-83 (Controlled reference words). Note: `k`
  \ was also in Forth-79 (Reference word set), but returned a
  \ signed number.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.negative_conditionals.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Negative conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch ,
    \ jp z,branch_code ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( -exit )

code -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                   \ pop hl
  CB c, 7C c,             \ bit 7,h ; negative?
  C2 c, ' exit ,          \ jp nz,exit_code
  jpnext                  \ jp next

  end-code

  \ doc{
  \
  \ -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _n_ is negative, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `-exit` is not intended to be used within a do-loop. Use
  \ `0< if unloop exit then` instead.
  \
  \ In Solo Forth `-exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.options-bracket.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `options[`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( options[ )

  \ Credit:
  \
  \ `options[` is a port of IsForth's `case:`.

  \ Note: in the original IsForth code the word `(options`)
  \ (called `docase` in IsForth) is written in x86 assembler. I
  \ rewrote it from scratch, without investigating the
  \ assembler code.

  \ XXX TODO -- alternative version `coptions[`

  \ 166 bytes used.

variable (default-option)
  \ default option xt

variable #options
  \ number of compiled options

: default-option ( "name" -- )  ' (default-option) !  ;
  \ Set the default option.
  \ It can go anywhere inside a the options statement.

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option xt
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  leave then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

( options[ )

: options[  ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ number of options is 0 so far
  compile (options)           \ compile run time handler
  >mark >mark >mark  ( a1 a2 a3 )
  postpone [  ; immediate compile-only

  \ doc{
  \
  \ options[  ( -- )
  \
  \ Start an `options[` structure.

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  \ Compile an option _x_ and the xt of its action "name".
  ,  ' ,  1 #options +!  ;

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option xt
  >resolve                    \ store exit point
  ]  ;

  \ vim: filetype=soloforth
  \ flow.positional-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `positional-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83's `case:`, by Henry Laxen and
  \ Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2015-11-22: Modified to use `create:`. 
  \ 2015-12-14: Renamed to `positional-case:`.
  \ 2016-04-09: Fixed the file header. Documented.

( positional-case: )

need create:

: positional-case:  ( "name" -- )
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;


  \ doc{
  \
  \ positional-case:  ( "name" -- )
  \
  \ Create a positional case word "name". At runtime, "name"
  \ will execute the n-th word compiled in its definition,
  \ depending upon the value on the stack. No range checking.
  \
  \ Usage example:

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ positional-case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.question-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `??`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ?? )

  \ Credit:
  \
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

  \ vim: filetype=soloforth
  \ flow.question-repeat.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ An alternative exit point for `begin until` loops.

  \ -----------------------------------------------------------
  \ Credit

  \ Code from the documentation of Forth-2012 and Forth-94.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ?repeat )

need cs-pick

: ?repeat  ( dest -- dest ) \ Compilation
           ( flag -- )      \ Execution
    0 cs-pick   postpone until
  ; immediate

  \ doc{
  \
  \ ?repeat  Compilation: ( dest -- dest )
  \          Execution:   ( flag -- )

  \ Example use:

  \ ----
  \ : xx  ( -- )
  \     begin
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag until    \ Go back to `begin` if flag is false
  \     ...
  \   ;
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.recurse.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604171545

  \ -----------------------------------------------------------
  \ Description

  \ `recurse`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-05: Written in the kernel.
  \ 2016-04-17: Moved to the library.

( recurse )

  \ XXX FIXME -- use `latestxt`, else words created with
  \ `:noname` will not work

: recurse  ( -- )
  latest name> compile,  ; immediate compile-only

  \ doc{
  \
  \ recurse  ( -- )
  \
  \ Append the execution semantics of the current definition to
  \ the current definition.
  \
  \ Origin: Forth-83 (Controlled Reference Words), Forth-94
  \ (CORE), Forth-2012 (CORE).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.retry.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `retry` and `retry?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( retry ?retry )

  \ Credit:
  \
  \ Code of `retry` from an article by Richard Astle in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

need name>body

: retry  ( -- )
  latest name>body postpone again
  ; immediate compile-only

: ?retry  ( run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

  \ vim: filetype=soloforth
  \ flow.select.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `select`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credit:
  \
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 wf )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 wf )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Point "              else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  char a  .(   ) dup emit  select-test
cr  char ,  .(   ) dup emit  select-test
cr  char 8  .(   ) dup emit  select-test
cr  char ?  .(   ) dup emit  select-test
cr  char K  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

  \ vim: filetype=soloforth
  \ flow.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to manipulate the control flow
  \ stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( cs-pick cs-roll cs-swap cs-drop )

need alias need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this in the kernel:

  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value
  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credit:
  \
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

  \ vim: filetype=soloforth
  \ flow.switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `switch`, a case selector with word
  \ lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

  \ flow.thiscase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `thiscase`, an alternative `case` based
  \ on code written by Wil Baden.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( thiscase )

  \ An alternative `case` structure that makes any
  \ calculation easier.

  \ 2015-11-14: First version.
  \ 2016-03-24: Renamed to avoid standard names `case`, `of`
  \ and `endof`.

  \ Credit:
  \
  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

need alias

' dup alias thiscase  ( n -- n n )
' drop alias othercase  ( n -- )

: ifcase  ( n f -- )
  postpone if  postpone drop  ; immediate compile-only

: exitcase  ( n f -- )
  postpone exit  postpone then  ; immediate compile-only

  \ Usage example

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;

  \ : test  ( n -- )
  \   thiscase 0 = ifcase  say0  exitcase
  \   thiscase 1 = ifcase  say1  exitcase
  \   thiscase 2 = ifcase  say2  exitcase
  \            othercase say-other  ;
  \ ----

  \ vim: filetype=soloforth
  \ flow.times.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604161626

  \ -----------------------------------------------------------
  \ Description

  \ `times`, a control flow structure which executes _n_ times
  \ the next word compiled.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ `times` was inspired by cmForth's `repeats`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Several drafts, with different behaviours
  \ during compilation.
  \
  \ 2016-04-16: Finished. Simplest version. Documented.

( times )

variable times-xt  \ the _xt_ executed by `times`

: times  ( i*x n -- j*x )
  rp@ @  dup cell+ rp@ !  @ times-xt !
  0 ?do  times-xt perform  loop  ; compile-only

  \ doc{
  \
  \ times  ( i*x n -- j*x )
  \
  \ Repeat the next compiled instruction _n_ times.  If _n_ is
  \ zero, continue executing the following instruction.
  \
  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.
  \
  \ Usage example:
  \
  \ ----
  \ : blink  ( -- )  7 0 do  i border  loop  0 border  ;
  \ : blinking  ( -- )  100 times blink  ." Done" cr  ;
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.zero_conditions.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Zero conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 0if 0while 0until )

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( 0exit )

code 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                 \ pop hl
  78 04 + c,            \ ld a,h
  B0 05 + c,            \ or l
  CA c, ' exit ,        \ jp z,exit_code
  jpnext                \ jp next

  end-code

  \ doc{
  \
  \ 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _f_ is zero, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `0exit` is not intended to be used within a do-loop. Use
  \ `0= if unloop exit then` instead.
  \
  \ In Solo Forth `0exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ game.life.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT
  
  \ Last modified: 201604032007

  \ -----------------------------------------------------------
  \ Description

  \ Conway's Game of Life, or Occam's Razor Dulled

  \ -----------------------------------------------------------
  \ Authors

  \ Original ANS Forth version: Copyright (C) 1995 Leo Wong.
  \
  \ Version for kForth: K. Myneny, 2001-12-26.
  \
  \ Version for Solo Forth: Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Code adapted from kForth. Original Credit:

  \ The original ANS Forth version by Leo Wong (see bottom) has
  \ been modified slightly to allow it to run under kForth.
  \ Also, delays have been changed from 1000 ms to 100 ms for
  \ faster update --- K. Myneni, 12-26-2001
  \
  \ 950724 + 970703 +
  \ Copyright 1995 Leo Wong
  \ hello at albany dot net
  \ http://www.albany.net/~hello/

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Start.
  \
  \ 2016-04-03: Header reorganized after the original credit.

( life )

  \ XXX FIXME -- works in Gforth, but freezes here.

need ms  need c+!  need 2/

1 CHARS CONSTANT /Char

  \ the universal pattern
32 CONSTANT How-Deep  24 CONSTANT How-Wide

How-Wide How-Deep *
  \  1-  \ 1- prevents scrolling on my screen \ XXX OLD
   CONSTANT Homes

  \ world wrap
: World  ( "name" -- )
  CREATE  Homes CHARS ALLOT
  DOES>  ( u -- c-addr )
    ( u pfa ) SWAP Homes +  Homes MOD  CHARS + ;

World old  World new

-->

( life )

  \ biostatistics

  \ begin hexadecimal numbering
  \ hex xy : x holds life , y holds neighbors count

$10 CONSTANT Alive  \ 0y = not alive

  \ Conway's rules:
  \ a life depends on the number of its next-door neighbors

  \ it dies if it has fewer than 2 neighbors
: Lonely  ( char -- flag )  $12 < ;

  \ it dies if it has more than 3 neighbors
: Crowded  ( char -- flag )  $13 > ;

: -Sustaining  ( char -- flag )  DUP Lonely  SWAP Crowded  OR ;

  \ it is born if it has exactly 3 neighbors
: Quickening  ( char -- flag )  $03 = ;

-->

( life )

  \ compass points
: N  ( i -- j )  How-Wide - ;
: S  ( i -- j )  How-Wide + ;
: E  ( i -- j )  1+ ;
: W  ( i -- j )  1- ;

  \ census
: Home+!  ( -1|1 i -- )  >R  Alive *  R> new C+! ;

: Neighbors+!  ( -1|0|1 i -- )
  2DUP N W new C+!  2DUP N new C+!  2DUP N E new C+!
  2DUP   W new C+!  (     i      )  2DUP   E new C+!
  2DUP S W new C+!  2DUP S new C+!       S E new C+! ;

: Bureau-of-Vital-Statistics ( -1|1 i -- )
  2DUP Home+!  Neighbors+! ;

  \ mortal coils
CHAR ? CONSTANT Soul  BL CONSTANT Body

-->

( life )

: Home  ( char i -- )  How-Wide /MOD AT-XY  EMIT ;

: Is-Born  ( i -- )
  Soul OVER Home  1 SWAP Bureau-of-Vital-Statistics ;

: Dies  ( i -- )
  Body OVER Home  -1 SWAP Bureau-of-Vital-Statistics ;

: One  ( c-addr -- i )  0 old -  /Char / ;

-->

( life )

: there  ( -- )  How-Wide 1- 0 AT-XY ;

: Everything  ( -- )
  0 old  Homes
  BEGIN  DUP
  WHILE  OVER C@  DUP Alive AND
     IF   -Sustaining IF  OVER One Dies     THEN
     ELSE  Quickening IF  OVER One Is-Born  THEN THEN
     1 /STRING
  REPEAT  2DROP
  there  ;

-->

( life )

  \ in the beginning
: Void  ( -- )  0 old  Homes BLANK ;

  \ spirit
: Voice  ( -- c-addr u )
  PAGE ." Say: "  0 new  DUP Homes ACCEPT ;

  \ subtlety
: Serpent  ( -- )
  0 2 AT-XY  ." Press a key for knowledge."  KEY DROP
  0 2 AT-XY  ." Press space to re-start, Esc to escape life." ;

  \ the primal state
: Innocence  ( -- )
  Homes 0 DO  I new C@  Alive /  I Neighbors+!  LOOP ;

  \ children become parents
: Passes  ( -- )  0 new  0 old  Homes  CMOVE ;

-->

( life )

  \ a garden
: Paradise  ( c-addr u -- )
  >R  How-Deep How-Wide *  How-Deep 2 MOD 0=  How-Wide AND -
  R@  -  2/  old
  R>  CMOVE
  0 old  Homes 0
  DO  COUNT BL <>
      DUP IF  Soul I Home  THEN
      Alive AND  I new C!
  LOOP  DROP
  Serpent
  Innocence Passes ;

-->

( life )

: Creation  ( -- )  Void Voice Paradise ;

  \ the human element

100 CONSTANT Ideas
: Dreams  ( -- )  Ideas MS ;

100 CONSTANT Images
: Meditation  ( -- )  Images MS ;

  \ free will
: Action  ( -- char )
  KEY? DUP
  IF  DROP KEY  DUP BL = IF  Creation  THEN
  THEN ;

  \ environmental dependence
7 CONSTANT Escape

  \ history
: Goes-On  ( -- )
  BEGIN  Everything Passes  Dreams Action Meditation
         Escape = UNTIL ;

  \ a vision
: Life  ( -- )  Creation Goes-On ;

  \ Life

  \ vim: filetype=soloforth
  \ game.pong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Pong.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( pong )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO slow the rackets

  \ Credit:
  \
  \ Code adapted from IsForth (version 1.23v).

  \ ____
  \
  \ pong.f
  \ Written june 2002 by Robert Oestling
  \ <robost at telia dot com>
  \ Tested with IsForth, http://isforth.clss.net/
  \ ____

need columns  need rows  need udg:  need rnd  need ??
3 constant /kk  need pressed?
need cvariable  need 2/  need pixel-addr
need hires-emit-udg  need c!toggle-bits

0 cconstant black  7 cconstant white

  \ XXX OLD
  \ 500 constant initial-speed
  \ variable speed
  \ Delay in milliseconds.

8 cconstant ball-delay0
  \ Counter: Times the ball is not moved in the main loop.
variable ball-delay
  \ XXX NEW

4 cconstant racket-size

: brighty  ( n1 -- n2 )  %1000000 or  ;
: paper-color  ( n1 -- n2 )  8 *  ;

white paper-color brighty cconstant racket-color

22528 constant top-line-attr
  \ address of the top left screen attribute
23264 constant bottom-line-attr
  \ address of the bottom left screen attribute

code sync  ( -- )  78 c,  jpnext  end-code
  \ Z80 halt

-->

( pong )

  \ Key constant are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant left1-key   char 1 cconstant left1-char
$02 $F7FE 2constant right1-key  char 2 cconstant right1-char
  \ Player 1 keys.

$10 $EFFE 2constant left2-key   char 6 cconstant left2-char
$08 $EFFE 2constant right2-key  char 7 cconstant right2-char
  \ Player 2 keys.

variable x  variable y
  \ Coordinates of the ball.

cvariable direction
  \ Direction of ball.
  \ Bit 0: 1 = down, 0 = up.
  \ Bit 1: 1 = right, 0 = left.

variable points1  variable points2
  \ Player points.

variable racket1-x  columns racket-size - 2/  racket1-x !
  \ Top racket x coordinate.

variable racket2-x  racket1-x @ racket2-x !
  \ Bottom racket x coordinate.

0 cconstant racket1-y
  \ Top racket y coordinate.

rows 1- cconstant racket2-y
  \ Bottom racket y coordinate.

-->

( pong )

%00111100
%01111110
%11111111
%11111111
%11111111
%11111111
%01111110
%00111100 128 udg: (ball)  0 cconstant ball \ XXX TMP

  \ XXX TODO -- frames

  \ %00111100
  \ %01111110
  \ %11111011
  \ %11111101
  \ %11111111
  \ %11111111
  \ %01111110
  \ %00111100 128 udg: ball0

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111101
  \ %11111101
  \ %11111111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111101
  \ %11111011
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11100111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11110011
  \ %01111110
  \ %00111100 130 udg: ball1

-->

( pong )

: restore-screen  ( -- )  default-colors page  ;

: init-screen  ( -- )  restore-screen white ink  ;

: ball-xy  ( -- x y )  x @ y @  ;

: show-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: erase-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: (border)  ( a -- )
  columns [ white paper-color ] literal sync fill  ;

: top-border  ( -- )  top-line-attr (border)  ;

: bottom-border  ( -- )  bottom-line-attr (border)  ;

-->

( pong )

: show-racket  ( a -- )  racket-size racket-color sync fill  ;

: show-racket1  ( -- )
  top-line-attr dup (border) racket1-x @ + show-racket  ;

: show-racket2  ( -- )
  bottom-line-attr dup (border) racket2-x @ + show-racket  ;

: show-rackets  ( -- )  show-racket1 show-racket2  ;

: racket-initial-x  ( -- n )
  columns 2/ [ racket-size 2/ ] literal -  ;

: reset-rackets  ( -- )
  racket-initial-x dup racket1-x ! racket2-x !  ;

-->

( pong )

: erase-racket  ( a1 a2 -- )  @ + racket-size erase  ;
  \ Erase a racket.
  \ a1 = address of the first screen attribute on the row
  \ a2 = variable that holds the racket x coordinate

: erase-racket1  ( -- )
  top-line-attr racket1-x erase-racket  ;
  \ Erase racket of player 1.

: erase-racket2  ( -- )
  bottom-line-attr racket2-x erase-racket  ;
  \ Erase racket of player 2.

-->

( pong )

: (print-points)  ( n y -- )
  0 swap at-xy s>d <# # # # #>
  black ink sync type white ink  ;
  \ Print the points of a player.

: print-points1  ( -- )
  points1 @ racket1-y (print-points) show-racket1  ;
  \ Print the points of player 1.

: print-points2  ( -- )
  points2 @ racket2-y (print-points) show-racket2  ;
  \ Print the points of player 2.

: print-points  ( -- )  print-points1 print-points2  ;
  \ Print the points of both players.

: change-x  ( -- )  %10 direction c!toggle-bits  ;
  \ Change the x direction of the ball.

: change-y  ( -- )  %01 direction c!toggle-bits  ;
  \ Change the y direction of the ball.

: faster  ( -- )
  exit  ;  \ XXX OLD
  \ speed @ 40 > if  speed @ dup 20 / - speed !   then  ;
  \ If the delay is more than 40 ms, reduce it with 5%.

-->

( pong )

: ball-moving-right?  ( -- f )  direction c@ %10 and  ;
: ball-moving-down?  ( -- f )  direction c@ %01 and  ;
  \ : ball-at-right?  ( -- wf )  x @ columns 1- =  ;
: ball-at-right?  ( -- wf )  x @ 247 >  ;
: ball-at-left?  ( -- wf )  x @ 1 <  ;
  \ : ball-at-bottom?  ( -- wf )  y @ rows 2- =  ;
: ball-at-bottom?  ( -- wf )  y @ 16 <  ;
  \ : ball-at-top?  ( -- wf )  y @ 1 =  ;
: ball-at-top?  ( -- wf )  y @ 182 >  ;

: move-ball-x  ( -- )
  ball-moving-right?
  if
    \ 0 2 at-xy ." right" \ XXX INFORMER
    ball-at-right?  if  change-x  then  1
  else
    \ 0 2 at-xy ." left " \ XXX INFORMER
    ball-at-left?   if  change-x  then  -1
  then  x +!  ;

-->

( pong )

: reset-ball  ( -- )
  128 x !  95 y !  rnd %11 and direction c!  ;
  \ Reset the ball position and direction.

: ready  ( -- )  reset-rackets reset-ball  ;

: score-player1  ( -- )  1 points1 +! print-points1  ;
  \ Increase player 1's points by one.

: score-player2  ( -- )  1 points2 +! print-points2  ;
  \ Increase player 2's points by one.

[defined] 8* ?\ : 8*  ( n1 -- n2 )  2* 2* 2*  ;

: hit-racket1?  ( -- wf )
  x @ racket1-x @ 8* 1- >
  x @ racket1-x @ 8* racket-size 8* + <  and  ;
  \ Is racket1 hit by the ball?
  \ Is racket1-x <= x < racket1-x + racket-size?

: hit-racket2?  ( -- wf )
  x @ racket2-x @ 8* 1- >
  x @ racket2-x @ 8* racket-size 8* + <  and  ;
  \ Is racket2 hit by the ball?
  \ Is racket2-x <= x < racket2-x + racket-size?

  \ : hit-racket?  ( a -- wf )
  \   \ XXX NEW -- alternative
  \   \ XXX TODO try
  \   \ a = address that holds the x coordinate of a racket
  \   @ 8* x @ swap  ( ball-x pad-x )
  \   2dup 1- > >r
  \   racket-size 8* + <  r> and  ;

-->

( pong )

: possible-top-hit  ( -- )
  hit-racket2? if change-y  else  score-player1 ready  then  ;

: move-ball-down  ( -- )
  ball-at-bottom? if  possible-top-hit  else  -1 y +!  then  ;

: possible-bottom-hit  ( -- )
  hit-racket1? if  change-y  else  score-player2 ready  then  ;

: move-ball-up  ( -- )
  ball-at-top? if  possible-bottom-hit  else  1 y +!  then  ;

: move-ball-y  ( -- )
  ball-moving-down?
  if  move-ball-down  else  move-ball-up  then  ;

8 cconstant racket-delay0
  \ Counter: Times the rackets are not moved in the main loop.
variable racket1-delay
variable racket2-delay

-->

( pong )

: ?move-ball  ( -- )
  -1 ball-delay +!  ball-delay @ if  unnest  exit  then
  ball-delay0 ball-delay !  ;

: move-ball  ( -- )
  ?move-ball
  erase-ball move-ball-x move-ball-y show-ball  ;

: frame  ( -- )  white border  top-border bottom-border  ;

: arena-line  ( -- )
  [ 0 96 pixel-addr nip ] literal columns %10101010 fill
  [ 0 95 pixel-addr nip ] literal columns %01010101 fill  ;

: arena  ( -- )
  cls  frame arena-line show-rackets print-points show-ball  ;

-->

( pong )

: ?move-racket1  ( -- )
  -1 racket1-delay +!  racket1-delay @ if  unnest exit  then
  racket-delay0 racket1-delay !  ;

: (move-racket1)  ( 1|-1 -- )  racket1-x +!  show-racket1  ;

: move-racket1-left  ( -- )
  ?move-racket1
  racket1-x @ 0= ?exit
  -1 (move-racket1)  ;

: move-racket1-right  ( -- )
  ?move-racket1
  racket1-x @ racket-size + columns = ?exit
  1 (move-racket1)  ;

-->

( pong )

: ?move-racket2  ( -- )
  -1 racket2-delay +!  racket2-delay @ if  unnest exit  then
  racket-delay0 racket2-delay !  ;

: (move-racket2)  ( 1|-1 -- )  racket2-x +!  show-racket2  ;

: move-racket2-left  ( -- )
  ?move-racket2
  racket2-x @ 0= ?exit
  -1 (move-racket2)  ;

: move-racket2-right  ( -- )
  ?move-racket2
  racket2-x @ racket-size + columns = ?exit
  1 (move-racket2)  ;

-->

( pong )

: reset-points  ( -- )  points1 off  points2 off  ;

: init-game  ( -- )
  init-screen reset-points
  racket-delay0  dup racket1-delay !  racket2-delay !
  ball-delay0 ball-delay ! ready  ;

: quit-game  ( -- )
  restore-screen  ." Player 1 score: " points1 ? cr
                  ." Player 2 score: " points2 ?  quit  ;

  : keypress  ( key -- )
    left1-key     pressed? ?? move-racket1-left
    right1-key    pressed? ?? move-racket1-right
    left2-key     pressed? ?? move-racket2-left
    right2-key    pressed? ?? move-racket2-right
                break-key? ?? quit-game  ;  -->

( pong )

: show-player-key  ( c ca len -- )
  space rot emit ."  = " type cr  ;

: show-player-keys  ( c1 c2 -- )
  s" left" show-player-key  s" right" show-player-key  ;

: show-game-keys  ( -- )
  ." Player 1:" cr right1-char left1-char show-player-keys
  ." Player 2:" cr right2-char left2-char show-player-keys
  ." Break (Shift+Space) = quit"  ;

-->

( pong )

: show-credits  ( -- )

  \  <------------------------------>
  ." Forth Pong" cr cr
  ." Original code by:" cr
  ."   Robert Oestling, 2002" cr
  ." Ported to IsForth by:" cr
  ."   Mark Manning, 2012" cr
  ." Rewritten for Solo Forth by:" cr
  ."   Marcos Cruz" cr
  ."   (programandala.net), 2015" cr  ;
  \  <------------------------------>

: press-any-key  ( -- )
  \  <------------------------------>
  ." Press any key to start the game." key drop  ;

: welcome  ( -- )
  page show-credits cr show-game-keys cr cr press-any-key  ;

-->

( pong )

: pong  ( -- )
  init-game welcome page arena
  begin  move-ball
  \ begin key? until key drop  \ XXX TMP -- for debugging
  keypress  again  ;

  \ vim: filetype=soloforth
  \ game.siderator_2.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Siderator 2.

  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2009, 2010, 2013, 2015,
  \ 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-02: Start, with the code of the Jupiter ACE
  \ version: http://programandala.net/en.program.siderator.html

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- less stars!
  \ XXX FIXME -- The craft's autodestruction creates a new star.

( siderator )

only forth definitions  decimal

need random  need randomize  need udg:  need inkey
need between  need ocr  need frames@
need j  need between  need rows  need last-column
need last-row

vocabulary siderator
also siderator definitions

-->

( siderator )

  \ Game variables and constants:

variable x          variable speed
variable parsecs    variable record  record off

999 constant max-speed
'5' constant left-key  '8' constant right-key

  \ System variables and addresses:

8192 constant 'screen \ XXX OLD

  \ Common words:

: pause  ( -- )  begin  inkey  until  ;  -->

( siderator )

  \ Graphics

15360 constant charset  \ ROM charset

: char>a  ( c -- a )  8 * charset +  ;

: udg>a  ( c -- a )  128 - 8 * os-udg @ +  ;

: char>udg  ( c0 c1 -- )  swap char>a swap udg>a 8 cmove  ;

128 constant star0-udg  '*' star0-udg char>udg

%00011000
%00001000
%00011000
%00010000
%00011000
%00001000
%00011000
%00010000 129 udg: star1-udg  -->

( siderator )

130 constant star2-udg
char | star2-udg char>udg

%00001000
%00000000
%00001000
%00000000
%00001000
%00000000
%00001000
%00000000 131 udg: star3-udg  -->

( siderator )

%10000001
%10000001
%11000011
%11100111
%11111111
%01100110
%00111100
%00011000 132 udg: craft-udg  -->

( siderator )

  \ Keyboard

0 constant first-column

: pressed?  ( c -- f )  inkey =  ;

: left  ( col -- col' )
  left-key pressed? + first-column max  ;

: right  ( col -- col' )
  right-key pressed? - last-column min  ;

: rudder  ( -- )  x @ right left x !  ;

-->

( siderator )

  \ Stars

4 constant #stars

: star-coords  ( -- gx gy )  last-column last-row  ;

: .star  ( c -- )
  [ last-column 1+ ] literal random last-row at-xy
  1 bright emit 0 bright  ;

: stars/speed  ( -- n )  speed @ #stars 1- max-speed */ 1+  ;

: scroll  ( -- )  star-coords at-xy cr cr  ;

: .stars  ( -- )
  stars/speed dup [ star0-udg 1- ] literal + swap 0
  do  dup .star  loop  drop  ;

: star=  ( c -- f )  star0-udg star3-udg between  ;

: star<>  ( c -- f )  star= 0=  ;

-->

( siderator )

  \ Craft

rows 2 / constant craft-y

: craft-coords  ( -- y x )  x @ craft-y  ;

: at-craft  ( -- )  craft-coords at-xy  ;

: -craft  ( -- )  at-craft space  ;

: .craft  ( -- )  at-craft craft-udg 5 ink emit 7 ink  ;

-->

( siderator )

  \ Speed, parsecs, record

: .datum  ( u -- )  s>d <# # # # #> type space  ;

: delay  ( -- )  max-speed speed @ - 2 / 0  do  loop  ;

: .speed  ( -- )  ." Speed:" speed @ .datum  ;

: +speed  ( u1 -- u2 )
  dup 10 / 1 max  parsecs @ 4 mod 0= abs *  + max-speed min  ;

: faster  ( -- )  speed @ +speed speed !  ;

: .parsecs  ( -- )  ." Parsecs:" parsecs @ .datum  ;

: farther  ( -- )  1 parsecs +!  ;

: .record  ( -- )  ." Record:" record @ .datum  ;

: .info  ( -- )  home .speed .parsecs .record  ;

-->

( siderator )

  \ End

: blast-delay  ( -- )  32 0  do  loop  ;

: (blast)  ( -- )
  .craft blast-delay at-craft star0-udg emit blast-delay  ;

: blast  ( -- )  256 0  do  (blast)  loop  ;

: halt  ( -- )
  32 0  do  24 0 do
    i j ocr star= if  i j at-xy  star0-udg emit  then
  loop  loop  ;
  \ XXX TODO

-->

( siderator )

: safe?  ( -- f )  craft-coords swap ocr star<>  ;

: continue?  ( -- f )  safe? break-key? 0= and  ;

: new-record  ( -- )
  parsecs @ record @ >  if  parsecs @ record !  then  ;

: game-over  ( -- )
  blast halt  11 dup at-xy ." GAME OVER"
  new-record .info first-column last-row at-xy
  default-colors  ;

-->

( siderator )

\ Instructions

: about  ( -- )
  cr ." Siderator 2: Jugdement Day"  cr
  cr ." By programandala.net"
  cr ." Version: 0.1.0+20160325"  ;

: objective  ( -- )
  cr ." Your objective is to travel as"
  cr ." much parsecs as possible"
  cr ." while dodging the stars."
  cr ." Anyway you're supposed to die"
  cr ." before the 1000th parsec"
  cr ." because four digits would ruin"
  cr ." the score panel."  ;

-->

( siderator )

\ Instructions

: keys  ( -- )
  cr ." Rudder keys: "
  left-key emit space right-key emit
  cr ." Autodestruction key: Break"  ;

: instructions  ( -- )  objective cr keys  ;

: wait  ( -- )  cr cr ." Press any key to start." pause  ;

-->

( siderator )

  \ Init

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;

: init-screen  ( -- )
  init-colors cls about cr instructions wait cls  ;

: 4+-  ( n1 -- n2 )  9 random 4 - +  ;

: init  ( -- )
  frames@ s>d randomize  udg-ocr
  init-screen  15 4+- x ! parsecs off  speed off  ;

-->

( siderator )

  \ Main

: run ( -- )
  init
  begin   -craft scroll  faster farther .info  continue?
  while   rudder .craft .stars  delay
  repeat  game-over  ;

  \ vim: filetype=soloforth
  \ game.tetris_for_terminals.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604022008

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Tetris for Terminals.
  \
  \ An improved port of a game written in Forth-94 by Dirk Uwe
  \ Zoller in 1994.

  \ -----------------------------------------------------------
  \ Authors

  \ Dirk Uwe Zoller, 1994-05-05.  Look&feel stolen from Mike
  \ Taylor's "Tetris for terminals".
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ tt.pfe  Tetris for terminals, redone in ANSI-Forth.
  \
  \ Written 05Apr94 by Dirk Uwe Zoller, e-mail duz AT roxi DOT
  \ rz DOT fht-mannheim DOT de.
  \
  \ Look&feel stolen from Mike Taylor's "TETRIS FOR TERMINALS".
  \
  \ Please copy and share this program, modify it for your
  \ system and improve it as you like. But don't remove this
  \ notice.
  \
  \ Thank you.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

.( tt )

only forth also definitions

  [undefined] forget-tt ?\ forget-tt
  \ XXX TODO
  \ marker forget-tt

need random  need j  need >=  need <=  need 2/  need value
need d<>  need d=  need case  need ms  need frames@  need yes?
need begin-stringtable  need positional-case:  need tab

vocabulary tt  also tt definitions  decimal

bl bl 2constant empty
  \ An empty position of the pit.

variable wiping
  \ If true, wipe brick, else draw brick.

2 constant col0  0 constant row0
  \ Position of the pit, not including the frame.

14 constant wide  22 constant deep
  \ Size of pit, not including the frame.
  \ Wide in stones; deep in rows.

-->

.( tt )

  \ c1 = left key
  \ c2 = right key
  \ c3 = rotate key
  \ c4 = drop key
  \ c5 = pause key
  \ c6 = quit key

7 constant edit-char

: actual-cursor-keys  ( -- c1 c2 c3 c4 c5 c6 )
  8 9 11 10 bl edit-char  ;
  \ Actual cursor keys, useful for PC keyboards with cursor
  \ keys

: spanish-dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] H [char] . [char] A bl edit-char  ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] R [char] ' [char] A bl edit-char  ;

: qwerty-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] O [char] P [char] Q [char] A bl edit-char ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: cursor-digits-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 5 [char] 8 [char] 7 [char] 6 bl edit-char  ;
  \ Cursor keys, actually the digits keys they are associated with.

: sinclair1-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 1 [char] 2 [char] 3 [char] 4  bl edit-char  ;
  \ Sinclair 1 joystick.

: sinclair2-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 6 [char] 7 [char] 8 [char] 9  bl edit-char  ;  -->
  \ Sinclair 2 joystick.

.( tt )

6 constant max-keyset
  \ Maximum number of the keyset (first is zero).

variable keyset
  \ Number of the current keyset.

positional-case: keyset>keys  ( n -- c1 c2 c3 c4 c5 c6 )
  actual-cursor-keys
  dvorak-keys
  spanish-dvorak-keys
  sinclair1-keys
  sinclair2-keys
  cursor-digits-keys
  qwerty-keys  ;

-->

.( tt )

begin-stringtable keyset>name  ( n -- ca len )
  s" Cursor        " s,
  s" Dvorak        " s,
  s" Spanish Dvorak" s,
  s" Sinclair 1    " s,
  s" Sinclair 2    " s,
  s" Cursor digits " s,
  s" QWERTY        " s,
end-stringtable

: keyset-name  ( -- ca len )  keyset @ keyset>name  ;

-->

.( tt )

0 value quit-key  0 value pause-key  0 value drop-key
0 value rot-key   0 value right-key  0 value left-key

: keys!  ( c1 c2 c3 c4 c5 c6 -- )
  to quit-key to pause-key to drop-key
  to rot-key to right-key to left-key   ;

: set-keyset   ( n -- )  dup keyset ! keyset>keys keys!  ;
  \ Set the keyset layout number _n_.

: next-keyset  ( -- n )  keyset @ 1+ dup max-keyset > 0= and  ;
  \ Calculate the next keyset.

: change-keyset  ( -- )  next-keyset set-keyset  ;
  \ Set the next keyset.

0 set-keyset  \ default

-->

.( tt )

variable score
variable pieces
variable levels
variable delay  \ in ms

variable brick-row  variable brick-col
  \ Position of the current brick.

: 2c@  ( a -- c1 c2 )  dup 1+ c@ swap c@  ;
  \ Fetch a pair of characters.

: 2c!  ( c1 c2 a -- )  dup >r c! r> 1+ c!  ;
  \ Store a pair of characters.

: 2emit  ( c1 c2 -- )   emit emit  ;

: position  ( row col -- )
  2* col0 + swap row0 + at-xy  ;
  \ Cursor to the position in the pit.

: stone  ( c1 c2 -- )
  wiping @ if  2drop 2 spaces  else  2emit  then  ;
  \ Draw or undraw these two characters.

-->

.( tt )

wide deep * 2 * constant /pit
  \ Size of the pit in memory.

create 'pit /pit allot
  \ The pit.

: pit  ( col row -- a )  'pit rot wide * rot + 2* +  ;
  \ Convert pit coords to the correspondent address.

: empty-pit  ( -- )  'pit /pit blank  ;
  \ Empty the pit.

: draw-bottom  ( -- )
  deep -1 position  [char] + dup stone
  wide 0 do  [char] = dup stone  loop
  [char] + dup stone  ;
  \ Draw the bottom of the pit.

: draw-frame  ( -- )
  deep 0 do   i -1   position [char] | dup stone
              i wide position [char] | dup stone
  loop  draw-bottom  ;  -->
  \ Draw the frame of the pit.

.( tt )

: bottom-msg  ( addr cnt -- )
  deep over 2/ wide swap - 2/ position 1 flash type 0 flash  ;
  \ Output a message at the bottom of the pit.

: draw-line  ( line -- )
  dup 0 position  wide 0 do  dup i pit 2c@ 2emit  loop  drop  ;
  \ Draw the contents of a pit line.

: draw-pit  ( -- )  deep 0 do  i draw-line  loop  ;
  \ Draw the contents of the pit.

begin-stringtable c>name  ( c -- ca len )
  s" Edit" s, s" Left" s, s" Right" s, s" Down" s, s" Up" s,
end-stringtable
  \ Names of the control chars 7..11.

: control-char-name  ( c -- ca len )  7 - c>name  ;
  \ Name of a control char (7..11).

: show-key  ( c -- )
  2 spaces  dup bl = if  drop ." Space"  else
            dup bl < if    control-char-name type
                     else  emit  then
            then  tab  ;
  \ Display the name of char _c_.
  \ Control chars are not supported except cursor keys and edit.

-->

.( tt )

: show-keys  ( -- )
  \ display the game keys
  \  <------------------------------>
  ." Keys: " keyset-name type cr cr
  left-key     show-key ."  Move left" cr
  right-key    show-key ."  Move right" cr
  rot-key      show-key ."  Rotate" cr
  drop-key     show-key ."  Drop" cr
  pause-key    show-key ."  Pause" cr
  quit-key     show-key ."  Quit"  ;
  \  <------------------------------>

-->

.( tt )

: (show-help)  ( -- )
  0 0 at-xy
  \  <------------------------------>
  ." TT (Tetris for Terminals)" cr cr
  ." Original ANS Forth code written" cr
  ." by Dirk Uwe Zoller, 1994." cr
  ." Ported to Solo Forth" cr
  ." by Marcos Cruz, 2015." cr cr
  show-keys  ;
  \ Display some explanations.

: show-help  ( -- )
  page
  begin  (show-help) cr cr
          \  <------------------------------>
         ." Press Space to change the keys" cr
         ." or any other key to start."
         key bl =
  while  change-keyset  repeat  ;  -->
  \ Display some explanations and change the keyset.

.( tt )

23 constant score-row

: at-score  ( col -- )  score-row at-xy  ;
  \ Set cursor at column _col_ of the score row.

: score-labels ( -- )
   0 at-score ." Score:"
  10 at-score ." Pieces:"
  21 at-score ." Levels:"  ;
  \ Display the labels of the score.

: .score  ( a col -- )  at-score @ 3 .r  ;
  \ Display the contents of the score variable _a_ at column
  \ _col_.

: update-score  ( -- )
  score 6 .score  pieces 17 .score  levels 28 .score  ;
  \ Display the current score.

: arena  ( --)
  draw-frame draw-pit score-labels update-score  ;
  \ Redraw everything on screen.

-->

.( tt ) blk @ . key drop

.s key drop

: brick:  ( ca1 len1 ca2 len2 ca3 len3 ca4 len4 "name" -- )
  create  4 0 do
            0 ?do  dup i chars + c@ c,  loop drop
          loop
  does>  ( x1 x2 -- a ) ( pfa )  rot 4 * rot + 2* +  ;
  \ Define the shape of a brick.
  \ Every brick has 4 rows, defined by 4 strings.
  \ XXX TODO stack notation of `does>`

s"         " 2constant empty-brick-row .s key drop

  \ XXX FIXME -- crash! -- never reaches the next `key drop`

empty-brick-row
s"   ##    "
s" ######  "  empty-brick-row  brick: brick1  .s key drop

empty-brick-row 2dup
s" <><><><>"  empty-brick-row  brick: brick2  .s key drop

empty-brick-row
s"   {}    "
s"   {}{}{}"  empty-brick-row  brick: brick3  .s key drop -->

.( tt ) blk @ . key drop

empty-brick-row
s"     ()  "
s" ()()()  "  empty-brick-row brick: brick4

empty-brick-row
s"   [][]  "
s"   [][]  "  empty-brick-row brick: brick5

empty-brick-row
s"   @@@@  "
s" @@@@    "  empty-brick-row brick: brick6

empty-brick-row
s" %%%%    "
s"   %%%%  "  empty-brick-row brick: brick7

empty-brick-row 2dup 2dup 2dup brick: brick
  \ brick actually in use

empty-brick-row 2dup 2dup 2dup brick: scratch  -->

.( tt ) blk @ . key drop

create bricks  ' brick1 ,  ' brick2 ,  ' brick3 ,  ' brick4 ,
               ' brick5 ,  ' brick6 ,  ' brick7 ,

create brick-value 1 c, 2 c, 3 c, 3 c, 4 c, 5 c, 5 c,

32 constant /brick
  \ Bytes per brick shape.

: is-brick  ( brick -- )
  >body [ ' brick >body ] literal /brick cmove  ;
  \ Activate a shape of brick.

: new-brick  ( -- )
  1 pieces +!  7 random
  bricks over cells + @ is-brick
  brick-value swap chars + c@ score +!  ;
  \ Select a new brick by random, count it.

: rotate-left  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  3 i - j scratch 2c!
  loop loop
  ['] scratch is-brick  ;  -->
  \ Rotate the current brick left.

.( tt ) blk @ . key drop


: rotate-right  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  i 3 j - scratch 2c!
  loop loop
  ['] scratch is-brick  ;
  \ Rotate the current brick right.

: draw-brick  ( row col -- )
  4 0 do 4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i +  position
        j i brick 2c@  stone
    then
  loop loop  2drop  ;
  \ Draw the current brick at the given coords.

: show-brick  ( row col -- )  wiping off draw-brick  ;

: hide-brick  ( row col -- )  wiping on  draw-brick  ;

-->

.( tt ) blk @ . key drop

: put-brick  ( row col -- )
  4 0 do 4 0 do
      j i brick 2c@  empty d<>
      if  over j +  over i +  pit
          j i brick 2c@  rot 2c!
      then
  loop loop  2drop  ;
  \ Put the brick into the pit.

: remove-brick  ( row col -- )
  4 0 do  4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i + pit empty rot 2c!  then
  loop  loop  2drop  ;
  \ Remove the brick from that position.

-->

.( tt ) blk @ . key drop

: test-brick  ( row col -- f )
  4 0 do 4 0 do
    j i brick 2c@ empty d<>
    if  over j +  over i +
        over dup 0< swap deep >= or
        over dup 0< swap wide >= or
        2swap pit 2c@  empty d<>
        or or if  unloop unloop 2drop false  exit  then
    then
  loop loop  2drop true  ;
  \ Could the brick be there?

-->

.( tt ) blk @ . key drop


: move-brick  ( rows cols -- f )
  brick-row @ brick-col @ remove-brick
  swap brick-row @ + swap brick-col @ + 2dup test-brick
  if    brick-row @ brick-col @ hide-brick
        2dup brick-col ! brick-row !
        2dup show-brick put-brick  true
  else  2drop brick-row @ brick-col @ put-brick  false
  then  ;
  \ Try to move the brick.

-->

.( tt ) blk @ . key drop

: rotate-brick  ( f1 -- f2 )
  \ f1 = rotate right?, else rotate left
  \ f2 = success
  brick-row @ brick-col @ remove-brick
  dup if  rotate-right  else  rotate-left  then
  brick-row @ brick-col @ test-brick
  over if  rotate-left  else  rotate-right  then
  if  brick-row @ brick-col @ hide-brick
      if  rotate-right  else  rotate-left  then
      brick-row @ brick-col @ put-brick
      brick-row @ brick-col @ show-brick  true
  else  drop false  then  ;
  \ Rotate the current brick.

-->

.( tt ) blk @ . key drop

: insert-brick  ( row col -- f )
  2dup test-brick
  if  2dup brick-col ! brick-row !
      2dup put-brick  draw-brick  true
  else  false  then  ;
  \ Introduce a new brick.

: drop-brick  ( -- )  begin  1 0 move-brick 0=  until  ;
  \ Move brick down fast.

: move-line  ( from to -- )
    over 0 pit  over 0 pit  wide 2*  cmove  draw-line
    dup 0 pit  wide 2*  blank  draw-line  ;

: line-full?  ( line-no -- f )
    true  wide 0
    do  over i pit 2c@ empty d=
        if  drop false  leave  then
    loop nip  ;

-->

.( tt ) blk @ . key drop

: adjust-delay  ( -- )
  levels @
  dup  50 < if  100 over -  else
  dup 100 < if   62 over 4 / -  else
  dup 500 < if   31 over 16 / -  else  0  then then then
  delay !  drop  ;
  \ Make it faster with increasing level.

-->

.( tt ) blk @ . key drop

: new-level  ( -- )  1 levels +!  10 score +!  adjust-delay  ;

: remove-lines  ( -- )
  deep deep
  begin
    swap
    begin
      1- dup 0< if  2drop exit  then  dup line-full?
    while
      new-level
    repeat
    swap 1- 2dup <> if  2dup move-line  then
  again  ;

-->

.( tt ) blk @ . key drop

: interaction  ( -- f )
  case  key upper
    left-key      of  0 -1 move-brick drop  endof
    right-key     of  0  1 move-brick drop  endof
    rot-key       of  0 rotate-brick drop  endof
    drop-key      of  drop-brick  endof
    pause-key     of  S"  Paused " bottom-msg  key drop
                      draw-bottom  endof
    quit-key      of  false exit  endof
  endcase  true  ;

: initialize  ( -- )
  frames@ d>s randomize
  score off  pieces off  levels off  adjust-delay
  empty-pit page arena  ;
  \ Prepare for playing.

-->

.( tt ) blk @ . key drop

: play-game  ( -- )
  begin
    new-brick  -1 3 insert-brick
  while
    begin
      4 0 do
        delay @ ms key?
        if  interaction 0= if  unloop exit  then  then
      loop
      1 0 move-brick 0=
    until
    remove-lines  update-score  adjust-delay
  repeat  ;
  \ Play one tt game.

-->

.( tt ) blk @ . key drop

also forth definitions

: again?  ( -- f )  s"  Again? (Y/N) " bottom-msg yes?  ;

: start-message  ( -- )  ." Type RUN to start tt" cr  ;

: end-message  ( -- )  0 23 at-xy cr start-message  ;

: run  ( -- )
  show-help
  begin  initialize play-game again? 0=  until
  draw-bottom end-message  ;
  \ Play the tt game.

cr start-message

only forth definitions

  \ vim: filetype=soloforth
  \ game.toe.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Toe.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( toe )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-24: Changes.

  \ Credit:
  \
  \ Based on code from Leo Brodie's _Starting Forth_, ANSized
  \ by Benjamin Hoyt in 1997.

9 constant squares

1 constant player-x  2 constant player-o

create board  squares allot

: clear  ( -- )  board squares erase  ;  clear

: >square  ( square -- ca )  board +  ;
: square@  ( square -- c )  >square c@  ;
: square!  ( c square -- )  >square c!  ;

: bar  ( -- )  ." | "  ;
: dashes  ( -- )  cr  9 0 do  '-' emit  loop cr  ;

: .player-mark  ( player -- )
  player-x = if ." x " else ." o " then  ;

: .box-contents  ( n -- )
  ?dup if  .player-mark  else  2 spaces  then  ;

: .box  ( square -- )  square@  .box-contents  ;

-->

( toe )

: display  ( -- )
  home
  squares 0 do
    i if    i 3 mod  0= if  dashes  else  bar  then
      then  i .box
  loop  cr  ;

: limited  ( square -- square' )  0 max squares min  ;

: play  ( square player -- )  swap 1- limited square! ;

: x  ( square -- )  player-x play  display ;
: o  ( square -- )  player-o play  display ;

  \ vim: filetype=soloforth
  \ game.towers_of_hanoi.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604171550

  \ -----------------------------------------------------------
  \ Description

  \ Towers of Hanoi puzzle.

  \ -----------------------------------------------------------
  \ Authors

  \ Raul Deluth Miller, original algorithm, published on
  \ comp.lang.forth, 1994.

  \ Marcel Hendrix and Brad Eckert, published on
  \ comp.lang.forth, 2002-05-30.

  \ K. Myneni, modified for kForth., 2002-05-30.

  \ Marcos Cruz (programandala.net), version for Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Start.

  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore. Updated the file headers.

( hanoi )

only forth definitions

need don't  need ms  need mode64  need alloted  need recurse

vocabulary hanoi  also hanoi definitions

variable slowness  1000 slowness !
  \ ms delay between screen updates

3 constant pegs

create PegSPS  pegs cells allot
  \ pointers for three disk stacks

: PegSP     ( peg -- addr ) cells PegSPS + ;
: PUSH      ( c peg -- )    PegSP tuck @ c!  1 chars swap +! ;
: POP       ( peg -- c )    PegSP -1 chars over +!  @ c@ ;

create PegStacks  30 chars allot
  \ stack area for up to 10 disks

: PegStack  ( peg -- addr )   10 * PegStacks + ;

: clear-peg    ( peg -- )  dup PegStack  swap PegSP ! ;
: clear-pegs  ( -- )  pegs 0 do  i clear-peg  loop  ;

  \ : PegDepth  ( peg -- depth )  dup PegSP @  swap PegStack - ;
  \ XXX OLD not needed

-->

( hanoi )

: show-disk  ( level diameter peg -- )
  22 * 10 + over -  rot 10 swap - at-xy
  2* [char] * emits ;

: show-peg   ( peg -- )
  dup >r PegStack
  BEGIN   r@ PegSP @ over <>
  WHILE   dup r@ PegStack - over c@  ( addr level diameter )
          r@ show-disk  char+
  REPEAT  drop r> drop ;

-->

( hanoi )

: maketab  ( n1..nn n -- XXX ) \ XXX TODO stack effect
  create
    dup alloted over 1- + swap 0
    2dup <> if    do  dup >r c! r> 1-  loop
            else  2drop
            then  drop
  does>  + c@ ;

#3 base !
00 02 01 12 00 10 21 20  #8 maketab TO!
00 21 12 20 00 02 10 01  #8 maketab FRO!
decimal

-->

( hanoi )

: finished  ( -- )  key drop 0 11 at-xy ." Stopped" cr abort  ;

: show-pegs  ( -- )
  page  pegs 0 do  i show-peg  loop  slowness @ ms
  key? if  finished  then ;

: move-ring  ( ring -- ring )
  dup to! 3 / pop  over fro! 3 mod push show-pegs ;

: tower ( depth direction -- depth direction )
  swap 1- swap over
  IF    to!  recurse  to! move-ring fro! recurse  fro!
  ELSE  move-ring
  THEN  swap 1+ swap ;

-->

( hanoi )

: run  ( depth -- )

  clear-pegs

  dup BEGIN ?dup WHILE 1- dup 0 push REPEAT
    \ stack up some disks

  show-pegs 1 tower 2drop
    \ move them

  0 11 at-xy ;

mode64 page
  \  <-------------------------->
  .( Towers of Hanoi) cr
  .( Type 'n run' to play where) cr
  .( 'n' is the number of disks.) cr
  \  <-------------------------->

  \ vim: filetype=soloforth
  \ graphics.attributes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to screen attributes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( attr )

need z80-asm need (attr-addr)

code attr ( col line -- b )

  \ Return the color attribute of the given cursor coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  jppushhl

  end-code

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col line -- a )

  \ Return the color attribute address of the given cursor
  \ coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  jppushhl

  end-code

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  \ Address of a Z80 routine that calculates the color
  \ attribute address of a cursor position.  This is a modified
  \ version of the ROM routine at 0x2583.

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

  \ vim: filetype=soloforth
  \ graphics.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words which manipulate screen blocks
  \ (windows)

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( clear-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code clear-block  ( column row width height -- )

  \ doc{
  \
  \ clear-block  ( column row width height -- )
  \
  \ Clear a screen block at the given character coordinates and
  \ of the given size in characters.  Only the bitmap is
  \ cleared. The color attributes remain unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+6 = column
    \ ; ix+4 = row
    \ ; ix+2 = width
    \ ; ix+0 = height

  #4 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #6 ix orx
    \ ld a,(ix+4) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+6) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a
  #2 ix c ftx  #0 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+2) ; width
    \ ld a,(ix+0) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  0 hl ldp#  sp addp  #4 cells de ldp#  de addp  ldsp
    \ djnz delete_bitmap
    \ ; Drop the parameters:
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( color-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code color-block  ( column row width height color -- )

  \ doc{
  \
  \ color-block  ( column row width height color -- )
  \
  \ Color a screen block at the given character coordinates and
  \ of the given size in characters.  Only the color attributes
  \ are changed; the bitmap remains unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
  #2 ix b ftx  #4 ix c ftx
    \ ld b,(ix+2) ; height
    \ ld c,(ix+4) ; width
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( wipe-block )

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code wipe-block  ( column row width height color -- )

  \ doc{
  \
  \ wipe-block  ( column row width height color -- )
  \
  \ Wipe a screen block at the given character coordinates and
  \ of the given size in characters.  The bitmap is erased and
  \ the color attributes are changed with the given color.
  \
  \ This word is written in assembler and it combines the
  \ functions of `clear-block` and `color-block`. It may be
  \ defined also this way (with slower but much smaller code):

  \ ----
  \ : wipe-block  ( column row width height color -- )
  \   >r 2over 2over clear-block r> color-block  ;
  \ ----

  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #8 ix orx
    \ ld a,(ix+6) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+8) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a ; DE = top left address of the block
  #4 ix c ftx  #2 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+4) ; width
    \ ld a,(ix+2) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  -->
    \ djnz delete_bitmap

( wipe-block )

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld  #2 ix b ftx
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
    \ ld b,(ix+2) ; height
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.circle.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw circles.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( circle )

  \ XXX UNDER DEVELOPMENT

  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( gx gy radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

  \ vim: filetype=soloforth
  \ graphics.cls.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that clear the screen with special
  \ effects.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( cls-chars0 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Anselmo Moreno
  \ Lorente, published on Microhobby, issue 121 (1987-03), page
  \ 7:
  \
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code cls-chars0  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( cls-chars1 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code cls-chars1  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin
      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
    z until

  step

  bc pop  jpnext  end-code

( horizontal-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color attribute _b_ from the
  \ top and bottom rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.display.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604101641

  \ -----------------------------------------------------------
  \ Description

  \ Words to save and restore the display status, in order to
  \ call ROM routines that prints to the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( nonfull-display full-display save-display restore-display )

: nonfull-display  ( -- )  2 23659 c!  ;

  \ doc{
  \
  \ nonfull-display  ( -- )
  \
  \ Set the nonfull screen mode: 2 lines in the lower screen
  \ and 22 lines in the upper main screen, which is the default
  \ configuration in BASIC.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: full-display  ( -- )  0 23659 c!  ;

  \ doc{
  \
  \ full-display  ( -- )
  \
  \ Set the full screen mode: no lines in the lower screen,
  \ thus 24 lines in the upper main screen, which is the
  \ default configuration in Solo Forth.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: save-display  ( -- ) ( R: -- col row )
  r> xy 2>r >r save-mode nonfull-display  ;

  \ doc{
  \
  \ save-display  ( -- ) ( R: -- col row )
  \
  \ Save the status of the display.  This word is intended to
  \ be used before calling a ROM routine that uses the display.
  \ The display can be restored to its previous status with
  \ `restore-display`.
  \
  \ }doc

: restore-display  ( -- ) ( R: col row -- )
  display full-display restore-mode  r> 2r> at-xy >r  ;

  \ doc{
  \
  \ restore-display  ( -- ) ( R: col row -- )
  \
  \ Restore the status of the display, saved by `save-display`.
  \ Intended to be used after calling a ROM routine that uses
  \ the display.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.hires-emit.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ Words to print characters at high resolution
  \ coordinates.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( hires-emit-udg )

need z80-asm  need (hires-emit)

code hires-emit-udg  ( gx gy b -- )

  \ Display the user graphic character _b_ (0..255) at graphic
  \ coordinates _x y_. The system variable "UDG" is supossed to
  \ hold the address of a graphic charset (the address of the
  \ char 0 bitmap).
  \
  \ The UDG character will be printed with overwritting
  \ (equivalent to `1 overwrite`).

  \ XXX FIXME  -- crash?

  hl pop  l a ld
  de pop  hl pop  bc push  e b ld  l c ld
  5C7B de ftp  \ system variable UDG
  (hires-emit) call
  bc pop  next ix ldp#  jpnext
  end-code

\ (hires-emit) \

need z80-asm  need (pixel-addr)

  \ Credit:
  \
  \ Code Adapted from "SMOOTH MOVE",
  \ written by Simon N.  Goodwin,
  \ published on Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create (hires-emit)  ( -- )

  \ Print a 8x8 bits char at high resolution coordinates.

  \ Input:
  \   DE = address of the first char (0) bitmap in a charset
  \   A = char code (0..255)
  \   B = y coordinate
  \   C = x coordinate
  \ Modifies:
  \   AF BC HL IX DE

  \ XXX FIXME  -- crash?

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

  \ vim: filetype=soloforth
  \ graphics.lines.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw lines.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( rdraw )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( gx gy -- )

  \ Draw a line relative to the current coordinates.
  \
  \ gx gy = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

\ (rdraw) \

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- finish adapting the DRAW-LINE ROM routine

need z80-asm

create (rdraw)
asm


  \  ld      a,c
  \  cp      b
  \  jr      nc,dl_x_ge_y
  \
  \  ld      l,c
  \  push    de
  \  xor     a
  \  ld      e,a
  \  jr      dl_larger
  \
  \ dl_x_ge_y:
  \  or      c
  \  ret     z
  \
  \  ld      l,b
  \  ld      b,c
  \  push    de
  \  ld      d,$00
  \
  \ dl_larger:
  \  ld      h,b
  \  ld      a,b
  \  rra
  \
  \ d_l_loop:
  \  add     a,l
  \  jr      c,d_l_diag
  \
  \  cp      h
  \  jr      c,d_l_hr_vt
  \
  \ d_l_diag:
  \  sub     h
  \  ld      c,a
  \  exx
  \  pop     bc
  \  push    bc
  \  jr      d_l_step
  \
  \ d_l_hr_vt:
  \  ld      c,a
  \  push    de
  \  exx
  \  pop     bc
  \
  \ d_l_step:
  \  ld      hl,($5c7d) ; coords
  \  ld      a,b
  \  add     a,h
  \  ld      b,a
  \  ld      a,c
  \  inc     a
  \  add     a,l
  \  jr      c,d_l_range
  \  jr      z,report_bc ; XXX TODO -- adapt, integer out of range
  \
  \ d_l_plot:
  \  dec     a
  \  ld      c,a
  \  call    l22e5      ; routine plot-sub \ XXX TODO
  \ XXX TODO -- replace `call PLOT-SUB` with `call PLOT-SUB+7`
  \  exx
  \  ld      a,c
  \  djnz    d_l_loop
  \
  \  pop     de
  \  ret
  \
  \ d_l_range:
  \  jr      z,d_l_plot

end-asm

( adraw ) \ from Abersoft Forth

  \ Credit:
  \
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot  need os-coordx  need os-coordy

2variable x1  2variable incx  2variable y1  2variable incy

: adraw  ( gx gy -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  [ os-coordy ] literal c@ ( y0 )
  dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )

  [ os-coordx ] literal c@ ( x0 )
  dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )

  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  -->

( adraw )

  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

  \ vim: filetype=soloforth
  \ graphics.ocr.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that recognize characters on the
  \ screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( ocr )

  \ Credit:
  \
  \ Adapted from anonymous code published on Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  jppushhl  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

need os-chars  need os-udg

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  os-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ set pointed by the system variable UDG.
  os-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

  \ vim: filetype=soloforth
  \ graphics.pixels.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604071548

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate pixels.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( gx gy -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

\ (pixel-addr) \

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( gx gy -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credit:
  \
  \ Author of the original code: Jos Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( gx gy -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( gx gy -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true jpnz
  ' false jp
  end-code

( pixels )

need z80-asm

code pixels  ( -- u )

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code

  \ doc{
  \
  \ pixels  ( -- u )
  \
  \ Number of pixels set on the screen.
  \
  \ }doc

  \ 26 bytes used.

  \ Credit:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret

( slow-pixels )

  \ Slower version of `pixels`.

need bits
: pixels  ( -- u )  16384 6144 bits  ;

  \ vim: filetype=soloforth
  \ graphics.screen_filters.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that make filter effects to the
  \ whole screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 46: <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credit:
  \
  \ Code adapted from a routine written by Javier Granadino,
  \ published on Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credit:
  \
  \ Code adapted from a routine written by Juan Jos Rivas,
  \ published on Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
           begin   m rrc  hl decp  h 6 bit  z until
  step

  bc pop  jpnext

  end-code

  \ vim: filetype=soloforth
  \ graphics.scroll.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to scroll the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( scroll-1px-right )

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
    m srl  hl incp  \ first char column
    1F b ld#  \ remaining columns
    begin   m rr  hl incp  step
    c dec
  z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credit:
  \
  \ Code adapted from a routine written by Ivn Sansa,
  \ published on Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.udg.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Word to define User Defined Graphics.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( udg! udg: )

need os-udg

: udg!  ( b0..b7 c -- )
  128 - 8 * os-udg @ + dup 7 + do  i c!  -1 +loop  ;
  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;
  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant called "name" for the UDG char _c_.
  \ Store the given 8 bytes into the UDG char _c_.
  \
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

  \ vim: filetype=soloforth
  \ keyboard.casp_lock.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to manipulate caps lock.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( capslock )

need os-flags2
need c!toggle-bits  need c@test-bits
need c!reset-bits   need c!reset-bits

%1000 os-flags2 2constant capslock
  \ Bit and system variable that control the capslock.

: toggle-capslock  ( -- )    capslock c!toggle-bits  ;
: set-capslock     ( -- )    capslock c!set-bits  ;
: unset-capslock   ( -- )    capslock c!reset-bits  ;
: capslock?        ( -- f )  capslock c@test-bits 0<>  ;

  \ vim: filetype=soloforth
  \ keyboard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the keyboard.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ }}} =======================================================
  \ Keyboard {{{

( at-accept clear-accept set-accept )

  \ XXX UNDER DEVELOPMENT
  \ Common code for several versions of `accept`
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

2variable accept-xy       \ coordinates of the edited string
  \ doc{
  \
  \ accept-xy  ( -- a )
  \
  \ A double variable that holds the cursor position at the
  \ start of the most recent `accept`.
  \
  \ }doc

variable accept-buffer    \ address of the edited string
  \ doc{
  \
  \ accept-buffer  ( -- a )
  \
  \ A variable that holds the buffer address used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable /accept          \ max length of the edited string
  \ doc{
  \
  \ /accept  ( -- a )
  \
  \ A variable that holds the buffer max length used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable >accept          \ offset to the cursor position
  \ doc{
  \
  \ >accept  ( -- a )
  \
  \ A variable that holds the offset of the cursor in the
  \ string being edited by `accept`.
  \
  \ }doc

: at-accept  ( -- )  accept-xy 2@ at-xy  ;
  \ doc{
  \
  \ at-accept  ( -- )
  \
  \ Set the cursor position at the start of the most recent
  \ `accept`.
  \
  \ }doc

: clear-accept  ( -- )
  at-accept span @ spaces at-accept  span off  ;
  \ doc{
  \
  \ clear-accept ( -- )
  \
  \ Clear the string currently edited by `accept`.
  \
  \ }doc

: set-accept  ( ca1 len1 -- ca1' )
  clear-accept /accept @ min  ( ca1 len1' )
  dup span ! 2dup system-bank type default-bank
  dup >r
  accept-buffer @  ( ca1 len1' ca2 )
  smove accept-buffer @  ( ca2 )
  r> +  ( ca1' )  ;
  \ doc{
  \
  \ set-accept  ( ca1 len1 -- ca1' )
  \
  \ Set string _ca len_ as the string being edited by `accept`.
  \ Return the address _ca1'_ after its last character.
  \
  \ }doc

( acceptx )

  \ XXX UNDER DEVELOPMENT
  \
  \ Alternative version of `accept` with more editing features
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

need at-accept  need set-accept

: .acceptx  ( -- )

  accept-buffer @ >accept @ at-accept type
    \ Print the start of the string, before the cursor.

  1 inverse  >accept @ span @ <
  if accept-buffer @ >accept @ + c@ emit  else  space  then
  0 inverse
    \ Print the cursor.

  accept-buffer @ span @ >accept @ 1+ min /string type
    \ Print the end of the string, after the cursor.
  ;

-->

( acceptx )

need toggle-capslock

: accept-edit  ( -- )  clear-accept init-accept  ;
: accept-left  ( -- )  ;
: accept-right  ( -- )  ;
: accept-up  ( -- )  ;
: accept-down  ( -- )  ;
: accept-delete  ( -- )  ;

create accept-commands ] noop noop noop noop noop noop
toogle-capslock accept-edit accept-left accept-right
accept-down accept-up accept-delete noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop [

: >accept-command  ( c -- a )  cells accept-commands +  ;
: accept-command  ( c -- )  >accept-command perform  ;

-->

( acceptx )

: init-acceptx  ( ca len -- )
  /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;

: (acceptx) ( ca len -- len' )  2dup init-accept

  over + over ( bot eot cur )
  begin  key dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;  -->

( acceptx )

: acceptx ( ca len -- len' )
  span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;

  \ XXX TMP -- for debugging

: ax  ( -- )  ['] acceptx ['] accept defer!  ;
: a0  ( -- )  ['] default-accept ['] accept defer!  ;

( nuf? )

  \ Credit:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29, 1988-05).

need aborted?

[defined] 'cr' ?\ 13 constant 'cr' \ code of carriage return

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's _c_, else return _false_.
  \
  \ This word is a useful factor of `nuf?`.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( Keyboard rows ports)

  \ Adapted from Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \
  \ "kk" stands for "keyboard key". This notation was chosen
  \ first in order to prevent future name clashes with standard
  \ words which uses the "k-" prefix, and second because these
  \ words manage only physical keys of the keyboard, not key
  \ combinations.
  \
  \ -----------------------------------------------------------

( kk-ports kk, kk@ )

  \ There are two versions of `kk,` and `kk@`. They depend on the
  \ value of `/kk`, a constant that holds the bytes ocuppied by
  \ every key in `kk-ports`, 3 or 4.
  \
  \ The application must define `/kk` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/kk 3 <> dup

?\ : kk,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `kk@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/kk 4 <> dup

?\ : kk,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( kk-ports )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2
$04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4
$10 $F7FE 2constant kk-5

$01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w
$04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r
$10 $FBFE 2constant kk-t

$01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s
$04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f
$10 $FDFE 2constant kk-g

$01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z
$04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c
$10 $FDFE 2constant kk-v

-->

( kk-ports )

$01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9
$04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7
$10 $EFFE 2constant kk-6

$01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o
$04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u
$10 $DFFE 2constant kk-y

$01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l
$04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j
$10 $BFFE 2constant kk-h

$01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss
$04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n
$10 $7FFE 2constant kk-b

-->

( kk-ports )

  \ This table contains the key double constants (port and
  \ bitmak) of all keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

need kk,

40 constant keys

create kk-ports

kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,
kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,
kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,
kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,
kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,
kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,
kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,
kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,

( kk-1# )

  \ Key number constants, to be used as indexes of the key
  \ tables.

need enum

0
enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#
enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#
enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#
enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#
enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#
enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#
enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#
enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#
drop

( kk-chars )

  \ This table contains the chars used as names of the keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

  \ By default, the first 4 UDG are used for keys whose names
  \ are not a printable char:
  \
  \ 128 = Caps Shift
  \ 129 = Enter
  \ 130 = Space
  \ 131 = Symbol Shift

create kk-chars

char 1 c,  char 2 c,  char 3 c,  char 4 c,  char 5 c,
char q c,  char w c,  char e c,  char r c,  char t c,
char a c,  char s c,  char d c,  char f c,  char g c,
128    c,  char z c,  char x c,  char c c,  char v c,
char 0 c,  char 9 c,  char 8 c,  char 7 c,  char 6 c,
char p c,  char o c,  char i c,  char u c,  char y c,
129    c,  char l c,  char k c,  char j c,  char h c,
130    c,  131    c,  char m c,  char n c,  char b c,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need kk-ports

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need kk-ports

0. 2variable kk-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. kk-pressed 2! \ none by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed?
  if  kk-pressed 2@ + if
  then
  /kk +loop
  kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ vim: filetype=soloforth
  \ keyboard.get-inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-inkey )

  \ Credit:
  \
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code get-inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

  \ vim: filetype=soloforth
  \ keyboard.get-key-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-key?` and `fast-get-key?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false jp

  end-code

( fast-get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code fast-get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false jp

  end-code

  \ keyboard.inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

  \ vim: filetype=soloforth
  \ keyboard.yes-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words for "yes/no" questions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( y/n? y/n no? yes? )

  \ Credit:
  \
  \ Code adapted from Afera.

need value

char Y value "y"  char N value "n"
  \ Default (uppercase) letters for "yes" and "no".

: y/n?  ( c -- f )  dup "y" = swap "n" = or  ;
  \ Is the given (uppercase) char _c_
  \ a valid answer for a "y/n" question?

: y/n  ( -- c )
  begin  key upper dup y/n? 0=  while  drop  repeat  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return its code.

: no?  ( -- f )  y/n "n" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "no",
  \ else return _false_.

: yes?  ( -- f )  y/n "y" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "yes",
  \ else return _false_.

  \ vim: filetype=soloforth
  \ locals.anon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604091917

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of locals using an array of anonymous
  \ variables.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code written by Leonard Morgenstern, published on
  \ Forth Dimensions (volume 6, number 1, page 33, 1984-05).
  \
  \ Adapted, modified, improved and commented by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Adapted from the original code.
  \ 2016-04-09: Fixed the file header.

( create-anon anon +anon n>anon )

variable (anon)  ( -- a )
  \ xt of the latest anonymous variable.

: create-anon  ( -- )
  here (anon) !
  [ (anon) body> @ ] literal compile, 0 ,  ;
  \ Create a new anonymous variable.  `(anon)` is used to get
  \ and compile the xt executed by all variables.

: anon  ( Compilation: -- ) ( Run-time: -- a )
  (anon) @
  compiling? if  compile,  else  execute  then  ; immediate
  \ Current anonymous variable (first cell),
  \ equivalent to `0 +anon`.

: +anon  ( Compilation:  n -- ) ( Run-time: -- )
  cells (anon) @ execute +
  compiling? if  postpone literal  then ; immediate
  \ Current anonymous variable (cell _n_, first is 0).

: n>anon  ( x1..xn n -- )
  cells postpone anon swap bounds do  i !  cell +loop  ;
  \ Store the given _n_ cells into the current anonymous
  \ variable.

  \ Usage example:

  \ create-anon 5 cells allot
  \
  \ : test
  \   400 300 200 100 000  5 n>anon
  \   anon ?          \ prints 0
  \   123 anon !
  \   anon ?          \ prints 123
  \   [ 2 ] +anon ?   \ prints 200
  \   555 [ 2 ] +anon !
  \   [ 2 ] +anon ?   \ prints 555
  \   ;

  \ vim: filetype=soloforth
  \ locals.arguments.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604091850

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of nestable locals, with a predefined set
  \ of ten variables which return their contents. 

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Marc Perkel, published on Forth Dimensions
  \ (volume 3, number 6, page 185, 1982-03).
  \
  \ Adapted to Solo Forth and improved by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Start.
  \ 2016-04-09: Fixed, improved, renamed, documented, finished.

( arguments results )

need cell/

variable >args
  \ address of the current arguments in the data stack

create arg-actions ] @ ! +! [
  \ execution table of the argument actions

variable arg-action  arg-action off
  \ id (offset) of the argument action:
  \ 0 = fetch; 2 (1 cell) = store; 4 (2 cells) = add

: arg:  ( +n "name" -- )
  create  c,
  does>  ( -- x ) ( x -- )
    \ ( pfa | x pfa )
    c@ >args @ swap -
    arg-action @ arg-actions + perform  arg-action off  ;
  \ create a new argument "name" with offset _+n_

$00 arg: l0 $02 arg: l1 $04 arg: l2 $06 arg: l3 $08 arg: l4
$0A arg: l5 $0C arg: l6 $0E arg: l7 $10 arg: l8 $12 arg: l9

-->

( arguments results )

: toarg  ( -- )  cell arg-action !  ;

  \ doc{
  \
  \ toarg  ( -- )
  \ 
  \ Set the store action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: +toarg  ( -- )  [ 2 cells ] literal arg-action !  ;

  \ doc{
  \
  \ +toarg  ( -- )
  \
  \ Set the add action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: arguments  ( i*x +n -- j*x )
  r> >args @ >r >r
  cells sp@ + dup >args ! [ 10 cells ] literal - sp@ swap -
  cell/ 0 do  0  loop  ; compile-only

  \ doc{
  \
  \ arguments  ( i*x +n -- j*x )
  \
  \ Define the number _+n_ of arguments to take from the stack
  \ and assign them to the first local variables from `l0` to
  \ `l9`.
  \
  \ The local variables are modified with `toarg`, `+toarg`,
  \ and returned  with `results`.
  \
  \ Example: The phrase `3 arguments` assigns the names of
  \ local variables `l0` through `l9` to ten stack positions,
  \ with `l0`, `l1` and `l2` returning the top 3 stack values
  \ that were there before `3 arguments` was executed. `l3`
  \ through `l9` are zero-filled and the stack pointer is set
  \ to just below `l9`.
  \
  \ `l0` through `l9` act as local variables returning their
  \ contents, not their addresses.  To write them you precede
  \ them with the word `toarg`. For example `5 toarg l4` writes
  \ a 5 into `l4`. Execution of `l4` returns 5 to the stack.
  \
  \ After all calculating is done, the phrase `3 results`
  \ leaves that many results on the stack relative to the stack
  \ position when `arguments` was executed. All intermediate
  \ stack values are lost, which is good because you can leave
  \ the stack "dirty" and it doesn't matter.
  \
  \ Usage example:

  \ ----
  \ : test  ( length width height -- length' volume surface )
  \   3 arguments
  \   l0 l1 * toarg l5       \ surface
  \   l5 l2 * toarg l4       \ volume
  \   $2000 +toarg l0        \ length+$2000
  \   l4 toarg l1            \ volume
  \   l5 toarg l2            \ surface
  \   3 results  ;
  \ ----

  \ }doc

: results  ( +n -- )
  cells >args @ swap - sp@ -
  cell/ 0 do  drop  loop
  r> r> >args ! >r  ; compile-only

  \ doc{
  \
  \ results  ( +n -- )
  \ 
  \ Define the number _+n_ of local variables to leave on the
  \ stack as results. Used with locals created by `arguments`.
  \ See `arguments` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ locals.local.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603242022

  \ -----------------------------------------------------------
  \ Description

  \ A simple solution to use an ordinary variable as local,
  \ saving its current value on the return stack and restoring
  \ it at the end.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Henning Hanseng, published on Forth
  \ Dimensions (volume 9, number 5, page 6, 1988-01).
  \
  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History
 
  \ 2015-11-14: Adapted from the original code.
  \ 2016-03-24: An alternative implementation with `:noname`.

( local )


:noname  \ Compilation: ( -- xt )
         \ Run-time:    ( -- ) ( R: a x -- )
  2r> swap !  ;
  \ Restore variable address _a_ and value _x_.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token to restore the variable
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap                     \ save top return address
  dup @ 2>r                   \ save variable address and value
  [ dup >body ] literal >r    \ force exit via `restore-local`
  >r  ;                       \ restore top return address
  compile-only

  drop  \ delete xt

  \ doc{
  \
  \ local  ( a -- )
  \
  \ Save the value of variable _a_, which will be restored at
  \ the end of the current definition.
  \
  \ Usage example:

  \ ----
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value
  \ ----
  \
  \ }doc

( local )

  \ XXX OLD
  \ 2015-11-14: First port of the original.

: (restore-local)  ( -- )  ( R: a x -- )  2r> swap !  ;
  \ Restore value _x_ of variable _a_.
  \ Can not be used directly.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token of `restore-local`
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap  dup @ 2>r
    \ save return address
    \ save variable address and value
  ['] (restore-local) >body >r  >r  ;  compile-only
    \ force exit via `(restore-local)`
    \ restore return address

  \ vim: filetype=soloforth
  \  math.calculator.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604182006

  \ -----------------------------------------------------------
  \ Description

  \ ROM calculator support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development, as part of the
  \ floating point implementation.
  \
  \ 2016-04-11: Revision. Code reorganized. Improvements.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Extracted the code from the floating point
  \ module, in order to reuse it. Much improved. Added `if then
  \ else`.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Move the stack and make it configurable. The
  \ default location is limited by the small free memory left
  \ to BASIC.
  \
  \ XXX FIXME -- When the calculator stack is out of bounds,
  \ the calculator could issue a BASIC error and crash the
  \ system. Test it.
  \
  \ XXX TODO -- Add more control structures.
  \
  \ XXX TODO -- Document.

( calculator )

need alias

wordlist constant calculator-wordlist

: calculator  ( -- )
  calculator-wordlist >order  $C5 c, $EF c,  ;
  \ Add `calculator-wordlist` to the search order and
  \ compile the assembler instructions to start the ROM
  \ calculator:
  \ ----
  \ push bc ; save the Forth IP
  \ rst $28 ; call the ROM calculator
  \ ----

calculator-wordlist >order
get-current  calculator-wordlist set-current

: end-calc  ( -- )  $38 c,  ;
  \ Compile the `end-calc` ROM calculator command.
  \ ----
  \ db $38 ; exit the ROM calculator
  \ ----

: end-calculator  ( -- )  previous end-calc $C1 c,  ;
  \ Restore the search order and
  \ compile the assembler instructions to exit the ROM calculator:
  \ ----
  \ db $38 ; `end-calc` ROM calculator command
  \ pop bc ; restore the Forth IP
  \ ----

-->

( calculator )

: +  ( -- )  $0F c,  ;
  \ Compile the `addition` ROM calculator command.
: -  ( -- )  $03 c,  ;
  \ Compile the `subtract` ROM calculator command.
: *  ( -- )  $04 c,  ;
  \ Compile the `multiply` ROM calculator command.
: /  ( -- )  $05 c,  ;
  \ Compile the `division` ROM calculator command.
: mod  ( -- )  $32 c,  ;
  \ Compile the `n-mod-m` ROM calculator command.

: **  ( -- )  $06 c,  ;
  \ Compile the `to-power` ROM calculator command.
: sqrt  ( -- )  $28 c,  ;
  \ Compile the `sqr` ROM calculator command.

-->

( calculator )

: sgn  ( -- )  $29 c,  ;
  \ Compile the `sgn` ROM calculator command.
: abs  ( -- )  $2A c,  ;
  \ Compile the `abs` ROM calculator command.
: truncate  ( -- )  $3A c,  ;
  \ Compile the `truncate` ROM calculator command.
: re-stack  ( r -- r' )  $3D c,  ;
  \ Compile the `re-stack` ROM calculator command.

: negate  ( -- )  $1B c,  ;
  \ Compile the `negate` ROM calculator command.

: zero  ( -- )  $A0 c,  ;
  \ Compile the `` ROM calculator command.
: one  ( -- )  $A1 c,  ;
  \ Compile the `` ROM calculator command.
: half  ( -- )  $A2 c,  ;
  \ Compile the `` ROM calculator command.
: pi2/  ( -- )  $A3 c,  ;
  \ Compile the `` ROM calculator command.
: ten  ( -- )  $A4 c,  ;
  \ Compile the `` ROM calculator command.

-->

( calculator )

: ln  ( -- )  $25 c,  ;
  \ Compile the `ln` ROM calculator command.
: exp  ( -- )  $26 c,  ;
  \ Compile the `exp` ROM calculator command.

: acos  ( -- )  $23 c,  ;
  \ Compile the `acos` ROM calculator command.
: asin  ( -- )  $22 c,  ;
  \ Compile the `asin` ROM calculator command.
: atan  ( -- )  $24 c,  ;
  \ Compile the `atan` ROM calculator command.
: cos  ( -- )  $20 c,  ;
  \ Compile the `cos` ROM calculator command.
: sin  ( -- )  $1F c,  ;
  \ Compile the `sin` ROM calculator command.
: tan  ( -- )  $21 c,  ;
  \ Compile the `tan` ROM calculator command.

-->

( calculator )

: drop  ( -- )  $02 c,  ;
  \ Compile the `delete` ROM calculator command.

: dup  ( -- )  $31 c,  ;
  \ Compile the `duplicate` ROM calculator command.

: swap  ( -- )  $01 c,  ;
  \ Compile the `exchange` ROM calculator command.

: >mem  ( n -- )  $C0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `st-mem` ROM calculator command for memory
  \ number _n_ (0..5). Note: The floating-point stack TOS is
  \ copied, not moved.

: mem>  ( n -- )  $E0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `get-mem` ROM calculator command for memory
  \ number _n_ (0..5).

: over  ( -- )
  2 >mem drop 1 >mem 2 mem> 1 mem>  ;
  \ Compile the ROM calculator commands to do `over`.
  \ XXX TODO -- do not use the calculator memory

: 2dup  ( -- )  over over  ;
  \ Compile the ROM calculator commands to do `2dup`.

-->

( calculator )

: 0=  ( -- )  $30 c,  ;
  \ Compile the `not` ROM calculator command.

: <>  ( -- )  $0B c,  ;
  \ Compile the `nos-neql` ROM calculator command.

: =  ( -- )  $0E c,  ;
  \ Compile the `nos-eql` ROM calculator command.

: >  ( -- )  $0C c,  ;
  \ Compile the `no-grtr` ROM calculator command.

: <  ( -- )  $0D c,  ;
  \ Compile the `no-less` ROM calculator command.

: <=  ( -- )  $09 c,  ;
  \ Compile the `no-l-eql` ROM calculator command.

: >=  ( -- )  $0A c,  ;
  \ Compile the `no-gr-eql` ROM calculator command.

: 0>  ( -- )  $36 c,  ;
  \ Compile the `less-0` ROM calculator command.

: 0<  ( -- )  $37 c,  ;
  \ Compile the `greater-0` ROM calculator command.

-->

( calculator )

: ?branch  ( -- )  $00 c,  ;
  \ Compile the `jump-true` ROM calculator command.

: branch  ( -- )  $33 c,  ;
  \ Compile the `jump` ROM calculator command.

: >mark  ( -- a )  here 0 c,  ;

  \ Compile space for the displacement of a ROM calculator
  \ forward branch which will later be resolved by
  \ `>resolve`.
  \
  \ Typically used after either `branch` or
  \ `?branch`.

: from-here  ( a -- n )
  here [ also forth ] swap - [ previous ] ;
  \ Calculate the displacement _n_ from the current data-space
  \ pointer to address _a_.

: >resolve  ( a -- )
  [ also forth ] dup [ previous ] from-here
  [ also forth ] swap [ previous ] c!  ;

  \ Resolve a ROM calculator forward branch by placing the
  \ displacement to the current position into the space
  \ compiled by `>mark`.

' here alias <mark  ( -- a )

  \ Leave the address of the current data-space pointer as the
  \ destination of a ROM calculator backward branch which will
  \ later be resolved by `<resolve`.
  \
  \ Typically used before either `branch` or
  \ `?branch`.

: <resolve  ( a -- )  from-here c,  ;

  \ Resolve a ROM calculator backward branch by compiling the
  \ displacement from the current position to the address left
  \ by `<mark`.

  \ XXX TODO -- test:

: if  ( -- a )  ?branch >mark  ;

: else  ( a1 -- a2 )
  branch >mark [ also forth ] swap [ previous ] >resolve  ;

' >resolve alias then  ( a -- )

set-current  previous
  \ restore the current word list and the search order
  \  math.floating_point.rom.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604182006

  \ -----------------------------------------------------------
  \ Description

  \ A floating point implementation that uses the ROM
  \ calculator.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development.
  \
  \ 2016-04-11: Revision. Code reorganized. First improvements.
  \
  \ 2016-04-12: Started `f.` and `f,`.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Made `f.` immune to the ROM bug. Fixed
  \ `ftrunc`. Moved the ROM calculator to its own file.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Write `fliteral`, `ffield:`, `fvalue`,
  \ environmental queries.
  \
  \ XXX TODO -- Write safer alternatives for the ambiguous
  \ conditions listed in Forth-2012.

( --fp-rom-- )

  \ XXX TMP -- for development

need +thru

1 22 +thru

: --fp-rom-- ;

( float float+ floats )

5 constant float

: float+  ( n1 -- n2 )  float +  ;
: floats  ( n1 -- n2 )  float *  ;

( fp0 fp (fp@ fp@ empty-fs fdepth )

need float

23651 constant fp0  \ STKBOT system variable
23653 constant fp   \ STKEND system variable

  \ Note: The calculator stack grows towards higher memory, and
  \ `fp` points to the first free position, therefore above top
  \ of stack.

: (fp@  ( -- a )  fp @  ;

: fp@  ( -- a )  (fp@ float -  ;

: empty-fs  ( -- )  fp0 @ fp !  ;
  \ XXX TODO -- try alternative: ROM routine $16BF

: fdepth  ( -- n )  (fp@ fp0 @ - float /  ;

( end-calculator-flag )

need macro  need f>s  need call-xt

: f>flag  ( -- f ) ( F: rf -- )  f>s negate  ;

  \ Convert a floating-poing flag _rf_ (1|0) to an actual flag
  \ _f_ in the data stack.

macro end-calculator-flag  ( -- f ) ( F: 1|0 -- )
  [ calculator-wordlist >order ] end-calculator [ previous ]
  ['] f>flag call-xt  jpnext endm

  \ Exit the ROM calculator and convert a flag calculated by
  \ it (_1|0_) to a well-formed flag on the data stack.
  \
  \ This macro is a common factor of all floating point logical
  \ operators.

( f= f<> )

  \ XXX UNDER DEVELOPMENT

need calculator  need end-calculator-flag

code f<>  ( -- f ) ( F: r1 r2 -- )
  calculator  <>  end-calculator-flag  end-code

code f=  ( -- f ) ( F: r1 r2 -- )
  calculator  =  end-calculator-flag  end-code

  \ code f~ \ XXX TODO

( f0< f0= f0<> f0> )

need calculator  need end-calculator-flag

code f0<  ( -- f ) ( F: r -- )
  calculator  0<  end-calculator-flag  end-code

code f0=  ( -- f ) ( F: r -- )
  calculator  0=  end-calculator-flag  end-code

code f0<>  ( -- f ) ( F: r -- )
  calculator  0= 0=  end-calculator-flag  end-code

code f0>  ( -- f ) ( F: r -- )
  calculator  0>  end-calculator-flag  end-code

( f< f<= f> f>= )

  \ XXX UNDER DEVELOPMENT

need calculator  need end-calculator-flag

code f<  ( -- f ) ( F: r1 r2 -- )
  calculator  <  end-calculator-flag  end-code

code f<=  ( -- f ) ( F: r1 r2 -- )
  calculator  <=  end-calculator-flag  end-code

code f>  ( -- f ) ( F: r1 r2 -- )
  calculator  >  end-calculator-flag  end-code

code f>=  ( -- f ) ( F: r1 r2 -- )
  calculator  >=  end-calculator-flag  end-code

( fdrop fdup fswap fover )

need calculator

code fdrop  ( F: r -- )
  calculator  drop  end-calculator  jpnext  end-code

code fdup  ( F: r -- r r )
  calculator  dup  end-calculator  jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calculator  swap  end-calculator  jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calculator  over  end-calculator  jpnext  end-code

( frot -frot )

need calculator

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calculator
    1 >mem drop swap 1 mem> swap
  end-calculator  jpnext  end-code

code -frot  ( F: r1 r2 r3 -- r3 r1 r2 )
  calculator
    swap 1 >mem drop swap 1 mem>
  end-calculator  jpnext  end-code

( f+ f- f* f/ fmod )

need calculator  need fdup  need f0=

code f+  ( F: r1 r2 -- r3 )
  calculator  +  end-calculator  jpnext  end-code

code f-  ( F: r1 r2 -- r3 )
  calculator  -  end-calculator  jpnext  end-code

code f*  ( F: r1 r2 -- r3 )
  calculator  *  end-calculator  jpnext  end-code

code f/  ( F: r1 r2 -- r3 )
  calculator  /  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r2_ is zero, the calculator issues
  \ "number too big" BASIC error, what crashes the system.  It
  \ could be trapped with G+DOS. A safe alternative `?f/` is
  \ provided.

: ?f/  ( F: r1 r2 -- r3 )  fdup f0= #-42 ?throw f/  ;
  \ Safe version of `f/`. If _r2_ is zero, an exception
  \ is thrown.

code fmod  ( F: r1 -- r2 )
  calculator  mod  end-calculator  jpnext  end-code

( fmax )

need calculator

code fmax  ( F: r1 r2 -- r1|r2 )
  calculator
    2dup >  ( F: r1 r2 rf -- )
    if    swap drop  ( F: r1 )
    else  drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

( fmin )

need calculator

code fmin  ( F: r1 r2 -- r1|r2 )
  calculator
    2dup <  ( F: r1 r2 rf -- )
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

( fsgn fabs fnegate )

need calculator

code fsgn  ( F: r1 -- -1|0|1 )
  calculator  sgn  end-calculator  jpnext  end-code

code fabs  ( F: r1 -- r2 )
  calculator  abs  end-calculator  jpnext  end-code

code fnegate  ( F: r1 -- r2 )
  calculator  negate  end-calculator  jpnext  end-code

( fln fexp f** fsqrt )

need calculator  need fdup  need f0<

code fln  ( F: r1 -- r2 )
  calculator  ln  end-calculator  jpnext  end-code

code fexp  ( F: r1 -- r2 )
  calculator  exp  end-calculator  jpnext  end-code

code f**  ( F: r1 -- r2 )
  calculator  **  end-calculator  jpnext  end-code

code fsqrt  ( F: r1 -- r2 )
  calculator  sqrt  end-calculator  jpnext  end-code

  \ XXX FIXME -- when _r1_ is negative, the calculator issues
  \ "invalid argument" BASIC error, what crashes the system.
  \ Maybe it could be trapped with G+DOS. A safe alternative
  \ `?fsqrt` is provided.

: ?fsqrt  ( F: r1 -- r2 )  fdup f0< #-46 ?throw f/  ;
  \ Safe version of `fsqrt`. If _r1_ is negative, an exception
  \ is thrown.

( f0 f1 fhalf fpi2/ f10 )

need calculator

code f0  ( F: -- r )
  calculator  zero  end-calculator  jpnext  end-code

code f1  ( F: -- r )
  calculator  one  end-calculator  jpnext  end-code

code fhalf  ( F: -- r )
  calculator  half  end-calculator  jpnext  end-code

code fpi2/  ( F: -- r )
  calculator  pi2/  end-calculator  jpnext  end-code

code f10  ( F: -- r )
  calculator  ten  end-calculator  jpnext  end-code

( frestack b>f u>f s>f f>s )

need calculator  need fnegate

code frestack  ( F: r -- r' )
  calculator  re-stack  end-calculator  jpnext end-code
  \ Restacks an integer in full floating point form.

code b>f  ( b -- ) ( F: -- r )
  D9 c, E1 c, 78 05 + c, CD c, 2D28 , D9 c,  jpnext  end-code
    \ exx
    \ pop hl
    \ ld a,l
    \ call $2D28 ; STACK_A ROM routine
    \ exx
  \ XXX TODO -- test

code u>f  ( u -- ) ( F: -- r )
  D9 c, C1 c, CD c, 2D2B , D9 c,  jpnext  end-code
    \ exx
    \ pop bc
    \ call $2D2B ; STACK_BC ROM routine
    \ exx

: s>f  ( n -- ) ( F: -- r )
  dup 0< if  abs u>f fnegate  else  u>f  then  ;
  \ XXX TODO -- test

code f>s  ( -- n ) ( F: r -- )
  D9 c, CD c, 2DA2 , C5 c, D9 c,  jpnext  end-code
    \ exx
    \ call $2DA2 ; FP_TO_BC ROM routine
    \ push bc
    \ exx
  \ XXX TODO -- test

  \ code f>d  ( -- d ) ( F: r -- )
  \ end-code
  \ XXX TODO

  \ code d>f  ( d -- ) ( F: -- r )
  \ end-code
  \ XXX TODO

  \ code f>string  ( -- ca len ) ( F: r -- )
  \ end-code
  \ XXX TODO -- command $2E

  \ : >float  ;
  \ XXX TODO --

( f! f@ )

need z80-asm

code f!  ( fa -- ) ( F: r -- )
  exx  2BF1 call  \ STK_FETCH ROM routine
       hl pop  a m ld  hl incp
               e m ld  hl incp  d m ld  hl incp
               c m ld  hl incp  b m ld
  exx  jpnext end-code

code f@  ( fa -- ) ( F: -- r )
  exx  hl pop m a ld  hl incp
              m e ld  hl incp  m d ld  hl incp
              m c ld  hl incp  m b ld
              2AB6 call  \ STK_STORE ROM routine
  exx  jpnext end-code

( f, fconstant fvariable )

need f!

: f,  ( -- ) ( F: r -- )  here float allot f!  ;

: fconstant  ( "name" -- )  ( F: f -- )  create  f,  does>  ;

: fvariable  ( "name" -- )  create  float allot  ;

( facos fasin fatan fcos fsin ftan )

need calculator

code facos  ( F: r1 -- r2 )
  calculator  acos  end-calculator  jpnext  end-code

code fasin  ( F: r1 -- r2 )
  calculator  asin  end-calculator  jpnext  end-code

code fatan  ( F: r1 -- r2 )
  calculator  atan  end-calculator  jpnext  end-code

code fcos  ( F: r1 -- r2 )
  calculator  cos  end-calculator  jpnext  end-code

code fsin  ( F: r1 -- r2 )
  calculator  sin  end-calculator  jpnext  end-code

code ftan  ( F: r1 -- r2 )
  calculator  tan  end-calculator  jpnext  end-code

( (f. f. )

need fdepth  need fdrop

code (f.  ( F: r -- )
  C5 c,  CD c, 2DE3 ,  C1 c,
    \ push bc
    \ call $2DE3  ; PRINT_FP ROM routine
    \ pop bc
  jpnext  end-code
  \ Note: `exx` can no be used to preserve `bc`, the Forth IP,
  \ because the routine uses the alternative registers.  `bc`
  \ is saved on the stack instead.

: f.  ( F: r -- )
  fdepth >r  (f. space
  fdepth r> = if  fdrop  then  ;

  \ Note: the depth of the stack must be checked because
  \ there's a bug in the PRINT-FP ROM routine called "unbalaced
  \ stack error". When the number is a non-integer less than 1,
  \ it's not removed from the stack at the end, and a zero is
  \ pushed on the stack.  This bug is documented in the ROM
  \ disassembly. Credit: Tony Stratton, 1982.

  \ XXX FIXME -- The Forth-2012 standard reads `f.` must use
  \ fixed-point notation, but in this implementation the
  \ decimal point is not shown at the end when the number is
  \ integer.

( .fs dump-fs )

need (fp@  need fp0  need f@  need f.
need fdepth  need float  need float+  need .depth

: (.fs  ( -- )  (fp@ fp0 @ ?do  i f@ f.  float +loop  ;

: .fs   ( -- )  fdepth dup .depth 0> if  (.fs  then  ;

: (dump-fs  ( -- )
  cr ." Bottom"
  (fp@ fp0 @ ?do
    i dup cr u. float bounds ?do  i c@ 4 .r  loop
  float +loop  cr ." Top" cr  ;
  \ XXX TODO -- improve: print the top at the top

: dump-fs  ( -- )  fdepth dup .depth 0> if  (dump-fs  then  ;

( fround floor ftrunc )

need calculator  need f0=  need f0<  need fdup  need fnegate

: fround  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ fround  ( r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round to
  \ nearest" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

: floor  ( F: r1 -- r2 )  ;

  \ XXX TODO --

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ negative infinity" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc


code ftrunc  ( F: r1 -- r2 )
  calculator  truncate  end-calculator  jpnext  end-code

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ zero" rule, giving _r2_.
  \
  \ Origin: Forth-2012 (FLOATING).
  \
  \ }doc

  \ Example from the documentation of Forth-2012:

  \ : ftrunc  ( F: r1 -- r2 )
  \   fdup f0= 0= if
  \     fdup f0< if  fnegate floor fnegate  else  floor  then
  \   then  ;

  \ From Gforth:
  \
  \ : ftrunc  ( F: r1 -- r2 )  f>d d>f ;

( falign faligned )

need alias

' noop alias falign     ( -- )        immediate
' noop alias faligned   ( a -- fa )   immediate
  \ ' noop alias sfalign    ( -- )        immediate
  \ ' noop alias sfaligned  ( a -- dfa )  immediate
  \ ' noop alias dfalign    ( -- )        immediate
  \ ' noop alias dfaligned  ( a -- dfa )  immediate

  \ vim: filetype=soloforth
  \  math.number.conversion.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number conversion.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( number )

: number  ( ca len -- n | d )  number? 0= #-275 ?throw  ;
  \ doc{
  \
  \ number  ( ca len -- n | d )
  \
  \ Attempt to convert a string _ca len_ into a number. If
  \ a valid point is found, return _d_; if there is no
  \ valid point, return _n_. If conversion fails due to an
  \ invalid character, an exception #-275 is thrown.
  \
  \ }doc

  \ vim: filetype=soloforth

  \  math.number.point.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to configure the charactes accepted as number point.

  \ -----------------------------------------------------------
  \ Authors

  \ Wil Baden, published on Forth Dimensions (volume 20, number
  \ 3 page 26, 1998-10).

  \ Adapted by Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( standard-number-point? extended-number-point? )

need [if]

[needed] classic-number-point? [if]

: classic-number-point?  ( c -- f )
  dup [char] : = swap [char] , - 4 u< or  ;
  \ doc{
  \
  \ standard-number-point?  ( c -- f )
  \
  \ Is character _c_ a classic number point?  Allowed
  \ points are: comma, hyphen, period, slash and
  \ colon.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

[needed] extended-number-point? [if]

: extended-number-point?  ( c -- f )
  dup [char] : = swap [char] + - 5 u< or  ;

  \ doc{
  \
  \ extended-number-point?  ( c -- f )
  \
  \ Is character _c_ an extended number point?  Allowed points
  \ are: plus sign, comma, hyphen, period, slash and colon,
  \ after _Forth Programmer's Handbook_.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth

  \  math.number.prefix.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Numeric prefix words. Solo Forth recognizes the standard
  \ notations, but these words may be useful in some cases.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( base# b# d# h# )

  \ Credit:
  \
  \ Based on code from eForth and code written by Wil Baden
  \ (published on Forth Dimensions 20-3, p. 27).

: base# ( -- ) ( "name" -- )
  create c, immediate
  does> c@
  base c@ >r  base !    \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

 2 base# b#
10 base# d#
16 base# h#

( x# b# o# d# h# t# )

  \ Credit:
  \
  \ Code from eForth.

: x# ( -- ) ( "name" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create o# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate
create t# ( "name" -- n | d ) 36 c, x# immediate

( c# )

  \ Credit:
  \
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate

  \ doc{
  \
  \ c#  ( "name" -- c )
  \
  \ Parse "name" and return the code _c_ of the its first
  \ character.
  \
  \ This is a short and state-smart alternative to the standard
  \ words `char` and `[char]`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \  math.number.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number printing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ud.r ud. )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

: ud.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;

  \ : u.r  ( n1 n2 -- )  >r 0 r> ud.r  ;

: ud.  ( d -- )  0 ud.r space  ;

( bin. dec. hex. )

  \ Credit:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credit:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credit:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

  \ vim: filetype=soloforth
  \  math.operators.1-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604071520

  \ -----------------------------------------------------------
  \ Description

  \ Single-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( under+ )  \ ==operators==

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c,           \ exx
  D1 c,           \ pop de
  C1 c,           \ pop bc
  E1 c,           \ pop hl
  19 c,           \ add hl,de
  E5 c,           \ push hl
  C5 c,           \ push bc
  D9 c,           \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ Origin: Comus.
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \   rot + swap  ;
  \ ----
  \
  \ }doc

( +under )

code +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  D9 c,           \ exx
  C1 c,           \ pop bc
  D1 c,           \ pop de
  E1 c,           \ pop hl
  19 c,           \ add hl,de
  E5 c,           \ push hl
  C5 c,           \ push bc
  D9 c,           \ exx
  jpnext  end-code

  \ doc{
  \
  \ +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ Origin: Comus.
  \
  \ ----
  \ : +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \   >r + r>  ;
  \ ----
  \
  \ }doc

  \ XXX TODO -- variant after PFE's `(under+)`:
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;

( cell/ )

  \ Credit:
  \
  \ Idea from IsForth.

need 2/ need alias
' 2/ alias cell/

( within between )

  \ Credit:
  \
  \ Code from DZX-Forth.

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit

: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )

  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.

  \ name  ( -- )
  \
  \ }doc

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/between.html

( polarity )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code

  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve

  78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

( u<= u>= <= >= 0>= 0<= )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;

( lshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ 16 bytes used

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ 19 bytes used

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (16 bytes used) but slower (133%
  \ the execution time of the version adapted from Z88 CamelForth).

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( bits )

need z80-asm

code bits  ( ca len -- u )

  0 hl ldp#  \ init bit count
  exx  \ save IP and count
  de pop  hl pop  \ memory zone
  begin
    d a ld  e or  nz if
      08 b ld#  \ bits per byte
      begin  m rrc  cy if  exx hl incp exx  then  step
      hl incp  de decp  \ next byte
  2swap again then
    \ Note: `2swap` is needed because `begin again` and `if
    \ then` are not nested.

  exx jppushhl end-code

  \ 29 bytes used.

  \ doc{
  \
  \ bits  ( ca len -- u )
  \
  \ Count the number of bits set in memory zone _ca len_.
  \
  \ }doc

  \ Credit:
  \
  \ Based on a pixels counter written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

( 2/ )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  jppushhl        \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

( sqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

  \ XXX TODO -- benchmark

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credit:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

  \ XXX TODO -- benchmark

need 2/

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ XXX TODO -- remove, it's in the kernel

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

need fm/mod

  \ Credit:
  \
  \ Forth-94 documentation.

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? )

  \ Credit:
  \
  \ Code from F83.

need roll

variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;
  \ Is any _x1..xn_ equal to _x0_?

( % u% )

: %  ( n1 n2 -- n3 )  100 swap */  ;
  \ _n1_ is percentage _n3_ of _n2_

: u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;
  \ _u1_ is percentage _u3_ of _u2_

  \ vim: filetype=soloforth
  \  math.operators.2-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604060043

  \ -----------------------------------------------------------
  \ Description

  \ Double-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ud* )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: ud*  ( ud1 u2 -- ud3 )  dup >r um* drop  swap r> um* rot +  ;

( d* )

  \
  \ Credit:
  \
  \ Code from DX-Forth 4.13.

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0000

: d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;

  \ --------------------------------------------
  \ Alternative implementation.
  \
  \ Credit:
  \
  \ Adapted from code written by Robert L. Smith,
  \ published on Forth Dimensions (volume 4, number 1, page 3,
  \ 1982-05).
  \
  \ This implementation uses 36 bytes.
  \ Relative speed: 1.0582
  \
  \ : d*  ( d1 d2 -- d3 )
  \  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ --------------------------------------------
  \ Alternative implementation.

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 33, 1998-04).

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0008

  \ : d*  ( d1 d2 -- d3 )
  \   >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  \   2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  \   r> * swap r> * + +  ; ( d1*d2 ) ( R: )

( du/mod )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

need tum*  need t+  need t-  need tum/  need d2*  need lshift

: normalize-divisor  ( d1 -- d1' shift )
  0 >r begin  dup 0< while  d2*  r> 1+ >r  repeat  r>  ;

  \ XXX TODO rename as `ud/mod`?
  \ XXX TODO stack comments

: du/mod  ( ud1 ud2 -- ud3 ud4 )

  ?dup 0= if
    \ there is a leading zero "digit" in divisor
    >r  0 r@ um/mod  r> swap >r  um/mod  0 swap r>  exit
  then

  normalize-divisor dup >r rot rot 2>r
  1 swap lshift tum*
    \ normalize divisor and dividend

  dup  r@ = if   -1  else  2dup  r@ um/mod nip  then
    \ guess leading "digit" of quotient

  2r@  rot dup >r  tum*  t-
    \ multiply divisor by trial quot and substract from
    \ dividend

  dup 0< if  r> 1-  2r@  rot >r  0 t+
    \ if negative, decrement quot and add to dividend

    dup 0< if  r> 1-  2r@  rot >r  0 t+  then
    \ if still negative, do it one more time

  then

  r> 2r> 2drop  1 r>  rot >r  lshift tum/  r> 0  ;
    \ undo nurmalization of dividend to get remainder

  \ Double unsigned divide with remainder.  Given a dividend
  \ _ud1_ and a divisor _ud2_, return remainder _ud3_ and
  \ quotient _ud4_.

( d0= d0< d< du< )

  \ Credit:
  \
  \ Code from DZX-Forth.

[unneeded] d0= ?\ : d0=  ( d -- f )  or 0=  ;  exit

[unneeded] d0< ?\ : d0<  ( d -- f )  nip 0<  ; exit

need [if]

[needed] d< [if]

need 2nip

: d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;  exit

[then]

[needed] du< [if]

  \ XXX TODO rewrite in Z80

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop [ true ] literal exit  then
  -   if  2drop [ false ] literal exit  then  u<  ;  exit

  \ Note: the flags are compiled with `literal` to make
  \ execution a bit faster.

[then]

( dmin dmax )

  \ Credit:
  \
  \ Code from DZX-Forth.

need [if]

[needed] dmin [if]
: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;  exit  [then]
  \ XXX TODO -- use `d>` when available

[needed] dmax [if]
: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;  [then]

( d= d<> )

  \ XXX TODO -- rewrite in Z80

: d<>  ( d1 d2 -- f )  rot <> if  2drop true exit  then  <>  ;

: d=  ( d1 d2 -- f )  d<> 0=  ;

  \ XXX OLD
  \ XXX TODO benchmark
  \ : d=  ( d1 d2 -- f ) rot = >r = r> and  ;
  \ : d<>  ( d1 d2 -- f )  d= 0=  ;

( d- )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  jppushhl
  end-code

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  D1 c, E1 c,
    \ pop de / pop hl
  29 c,  CB c, 13 c,  CB c, 12 c,
    \ add hl,hl
    \ rl e
    \ rl d
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  E1 c, D1 c,
    \ pop hl / pop de
  CB c, 2C c,  CB c, 1C c,  CB c, 1D c,
    \ sra h  /  rr h /  rr l
  CB c, 1A c,  CB c, 1B c,
    \ rr d /  rr e
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]  need z80-asm

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  de pop  hl pop
  hl addp  e rl  d rl
                              \ alternatives:
  exde  pushhlde jp           \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  hl pop  de pop
  h sra  l rr  d rr  e rr

                              \ alternatives:
  pushhlde jp                 \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

( dxor dor dand )

  \ Credit:
  \
  \ Code written by Everett F. Carter, published on Forth
  \ Dimensions (volume 16, number 2, page 17, 1994-08).

[unneeded] dxor
?\ : dxor  ( d1 d2 -- d3 )  rot xor -rot xor swap  ;

[unneeded] dor
?\ : dor  ( d1 d2 -- d3 )  rot or -rot or swap  ;

[unneeded] dand
?\ : dand  ( d1 d2 -- d3 )  rot and -rot and swap  ;

( m* )

  \ Credit:
  \
  \ Code by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

  \ XXX TODO benchmark with the version in the kernel

need d*

: m*  ( n1 n2 -- d )
  >r s>d r> s>d d* ;

( m+ )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need z80-asm

code m+  ( d1|ud1 n -- d2|ud2 )
  exx     \ save Forth IP
  bc pop  \ n
  de pop  \ d1 hi cell
  hl pop  \ d1 lo cell
  bc addp  hl push
  cy if  de inc  then  de push
  exx      \ restore Forth IP
  jpnext
  end-code

  \ doc{
  \
  \ m+  ( d1|ud1 n -- d2|ud2 )
  \
  \ Add _n_ to _d1|ud1_, giving the sum _d2|ud2_.
  \
  \ Origin: Forth-94 (DOUBLE) Forth-2012 (DOUBLE).
  \
  \ }doc

exit

  \ This alternative is slower (1.48), but saves 4 bytes.

: m+  ( d1|ud1 n -- d2|ud2 )  s>d d+  ;

( m*/ )

  \ Credit:
  \
  \ Code from Gforth 0.7.3.

: m*/  ( d1 n1 +n2 -- d2 )

  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;

  \ doc{
  \
  \ m*/  ( d1 n1 +n2 -- d2 )
  \
  \ Multiply _d1_ by _n1_ producing the triple-cell
  \ intermediate result _t_.  Divide _t_ by _+n2_ giving the
  \ double-cell quotient _d2_.
  \
  \ }doc

  \ XXX TODO -- see difference Gforth - Forth-94

( m*/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need mt*  need tnegate  need ut/

: m*/  ( d1 n1 +n2 -- d2 )
    >r mt* dup 0< if    tnegate r> ut/ dnegate
                  else  r> ut/  then  ;

( dsqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need q2*  need d2*  need d<  need m+  need d- need 2rot
need 2nip  [defined] cell-bits ?\ 16 constant cell-bits

  \ XXX FIXME wrong results
  \
  \ It worked fine, but something got wrong
  \ Perhaps because of some wrong dependency?
  \ maybe `d<`?
  \
  \ It works in Gforth

: (dsqrt)  ( radicand . -- remainder . root . )
  0. 0.             ( radicand . remainder . root . )
  cell-bits 0 do    ( radicand . remainder . root . )
    cr .s  key drop  \ XXX INFORMER
    2>r q2* q2* 2r>  d2*
    2over 2over d2* 2swap
      cr .s ." d< ?"  \ XXX INFORMER
      d< if
      cr .s ." d<"  \ XXX INFORMER
      2dup 2>r d2* d- -1 m+ 2r>  1 m+
    then
  loop  cr .s 2rot 2drop  ;

: dsqrt  ( radicand . -- root . )  (dsqrt) 2nip  ;

( d10* )

  \ Credit:
  \ Code from Pygmy Forth.

: d10*  ( ud -- ud*10 )  d2* 2dup d2* d2* d+  ;

  \ vim: filetype=soloforth
  \  math.operators.3-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604150254

  \ -----------------------------------------------------------
  \ Description

  \ Triple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( tum* tum/ t+ t- )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

  \ XXX TODO -- test

need d-

: +carry  ( n1 n2 -- n1+n2 carry )  0 tuck d+  ;

: -borrow  ( n1 n2 -- n1-n2 borrow )  0 tuck d-  ;

: tum*  ( d n -- t )  2>r  r@ um*  0 2r>  um* d+  ;
  \ Triple unsigned mixed multiply.

: tum/  ( t n -- d )  dup >r um/mod r> swap >r um/mod nip r>  ;
  \ Triple unsigned mixed division.

: t+  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r +carry  0 r> r> +carry d+ r> r> + +  ;
  \ Triple add.

: t-  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r -borrow
  s>d r> r> -borrow d+ r> r> - +  ;
  \ Triple substract.

( tnegate )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: tnegate  ( t1 -- t2 )
  invert >r
  invert >r
  invert 0 -1 -1 d+ s>d r> 0 d+
  r> +  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ tnegate  ( t1 -- t2 )
  \
  \ _t2_ is the negation of _t1_.
  \
  \ }doc

( ut* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut*   ( ud u -- t )
  swap >r dup >r
  um* 0 r> r> um* d+  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut*   ( ud u -- t )
  \
  \ _t_ is the signed product of _ud_ times _u_.
  \
  \ }doc

( mt* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need ut*  need tnegate

: mt*   ( d n -- t )
  dup 0<
  if   abs over 0< if   >r dabs r> ut*  else ut* tnegate then
  else over 0< if  >r dabs r> ut* tnegate  else  ut*  then
  then ;

  \ XXX TODO -- test

  \ doc{
  \
  \ mt*   ( d n -- t )
  \
  \ _t_ is the signed product of _d_ times _n_.
  \
  \ }doc

( ut/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut/   ( ut n -- d )
  dup >r um/mod -rot r> um/mod nip swap  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut/   ( ut n -- d )
  \
  \ Divide a triple unsigned number _ut_ by a single number _n_
  \ giving the double number result _d_.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.operators.4-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604060057

  \ -----------------------------------------------------------
  \ Description

  \ Quadruple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( q2* )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need d2*

: q2*  ( n . . . -- 2n . . . )
  d2* >r >r
  dup 0< if     d2* r> 1+ r>
         else   d2* r> r>
         then  ;

( q+ q- q0< q0= qu< qnegate qabs )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

code q+  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

code q-  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

: q0<  ( nq -- f )  0< push drop 2drop pop  ;
: q0=  ( nq -- f )  or or or 0=  ;
: qu<  ( uq uq -- f )  q- q0<  ;
: qnegate  ( nq -- nq' )  0 0 0 0 4swap q-  ;
: qabs  ( nq -- uq )  dup 0< if qnegate then  ;

( udm* dm* )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

need qnegate

code udm*  ( ud ud - quad )
  \ XXX TODO -- port to Z80
end-code

: dm* ( nd nd - nq )
  2>r dup 0< dup >r if  dnegate  then
  r> 2r> dup 0< dup >r if  dnegate  then
  rot >r udm* 2r> xor 0< if  qnegate  then  ;

  \ vim: filetype=soloforth
  \ memory.address_register.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Address register store and fetch words.
  \
  \ There aren't any spare registers to make this as efficient
  \ as it could be. However, it can still give a useful
  \ improvement in loops, and in many cases also results in
  \ cleaner-looking code.  (From the original source of Z88
  \ CamelForth, by Garry Lancaster.)

  \ -----------------------------------------------------------
  \ Authors

  \ Garry Lancaster wrote the original code for Z88 CamelForth,
  \ 2001.
  \
  \ Marcos Cruz (programandala.net) adapted the code for Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( a! a@ )  \ ==addressregister==

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,  22 c, a ,  jpnext
    \ pop hl
    \ ld (a),hl
    \ jp (ix)
  end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,  C3 c, pushhl ,
    \ ld hl,(a)
    \ jp pushhl
  end-code

( !a @a )

need a!

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,  2A c, a ,  70 03 + c,  23 c,  70 04 + c,  jpnext
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ jp (ix)
  end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,  5E c,  23 c,  66 c,  68 03 + c,  C3 c, pushhl ,
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld h,(hl)
    \ ld l,e
    \ jp pushhl
  end-code

( c!a c@a )

need a!

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  jpnext                \ jp (ix)
  end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a+ @a+ )

need a!

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code @a+  ( -- u )      \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

( c!a+ c@a+ )

need a!

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

  \ vim: filetype=soloforth
  \ memory.alocate.charlton.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604031945

  \ -----------------------------------------------------------
  \ Description

  \ A standard implementation of the memory-allocation word
  \ set.

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, `allocate`,
  \ `free`, and `resize` which give the minimum functionality
  \ required to use the heap. These are given in areas 3, 4 and
  \ 5 respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant `heapsize`. the constant
  \ `hysteresis` controls the amount of spare space that is
  \ added to an allocation, to reduce the need for block moves
  \ during resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright Gordon Charlton, 1994-09-12.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ Solo Forth version of the code:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ Original code:

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.  <gordon at charlton dot
  \ demon dot co dot uk>

( heap )


  \ XXX REMARK: 1614 bytes used

  \ XXX TODO use top of memory instead of dictionary space?
  \ problem: memory banks could not be used at the same time.
  \
  \ XXX TODO use a memory bank instead of dictionary space?
  \ problem: only words below 0xC000 could manipulate the heap.

also forth definitions
need wid-of
vocabulary heap-voc  wid-of heap-voc constant heap-wordlist
also heap-voc definitions

  \ XXX TODO -- alternative
  \ forth-wordlist set-current
  \ wordlist heap-wordlist

  \ **1** General Purpose Extensions

0 1 2 um/mod nip 1- constant maxpos
  \ XXX TODO use `environment?` instead when available

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  --  Constants

256 cells constant heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 cells 1- constant hysteresis

  \ Node lengths are rounded up according to the value of
  \ `hysteresis` to reduce the number of block moves during
  \ `resize` operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

3 cells constant headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis or  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize constant overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  --  Structure

create sentinel  here cell+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

create heap  heapsize allot

  \ The heap is as described in `headsize`.

variable nextnode  -->

  \ Searching is done using a "nextfit" algorithm. `nextnode`
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr1 -- addr2)  cell+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr1 -- addr2)  [ 2 cells ] literal +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )
  heap dup nextnode !
  dup dup !
  dup heapsize  over >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does
  \ `nextnode`.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  --  List Searching

: attach ( addr)
  >prev @  dup sentinel rot !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (_addr_) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >r begin 2@ swap R@ < invert until
  r> drop  >prev @  ;

  \ Search the nodelist, starting at the node specified
  \ (_addr_), for a free node larger than or equal to the
  \ specified _size_.  Return the address of the first node
  \ that matches, or zero for no match. The heap structure is
  \ set up to make this a near optimal search loop. The "size"
  \ field is next to the "next" field so that both can be
  \ collected in a single operation (2@). Nodes in use have
  \ negated sizes so they never match the search. The
  \ "previous" field is included to allow the search to
  \ overshoot the match by one node and then link back outside
  \ the loop, rather than remembering the address of the node
  \ just examined. The sentinel removes the need for a separate
  \ test for failure. `search` assumes the sentinel is in
  \ place.

: detach ( addr)  dup >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           dup      attach
           dup rot  search
           swap     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ `nextnode`, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  --  Head Creation

: fits ( size addr -- flag)  >size @ swap -  overhead  <  ;

  \ Returns _true_ if the size of the node specified is the
  \ same as the specified size, or larger than it by less than
  \ the size of the smallest possible node. Returns _false_
  \ otherwise.

: togglesize ( addr)  >size dup @  negate swap !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2dup + >r  >size 2dup @ swap -
  R@ >size !   swap negate swap !  r>  ;

  \ Given a free node (_addr_), reduce its size to that
  \ specified and mark it as in use. Start to construct a new
  \ node within the specified node beyond its new length, by
  \ storing the length of the remainder of the node in the size
  \ field of the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2dup swap @  2dup  swap !  >prev !
  2dup >prev !   swap !  ;


  \ _Addr1_ is an existing node. _Addr2_ is the address of a
  \ new node just above the existing node. Break the links from
  \ the existing node to the next node and from the next node
  \ to the existing node and join the new node to them.


  \ ANSI heap  --  Node Construction  ALLOCATE

: newnode ( size addr)  tuck sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)
  2dup fits if  togglesize drop  else  newnode  then  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

forth-wordlist set-current

: allocate ( u -- addr ior)
  dup 0< if  -59  \ `allocate` error code
       else  adjustsize
       dup findspace
       dup if  dup next!
         tuck makenode
         headsize +  0
         else  drop -59  \ `allocate` error code
         then
       then  ;

heap-wordlist set-current  -->

  \ Make an in-use node with a data field at least _u_ address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and the standard ior.  The
  \ standard specifies that the argument to `allocate` is
  \ unsigned. As the implementation uses the sign bit of the
  \ size field for its own purposes any request for an amount
  \ of space greater than `maxpos` must fail. As this would be
  \ a request for half the addressable memory or more this is
  \ not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  --  Head Destruction

: mergesizes ( addr1 addr2)
  >size @ swap >size +!  ;

  \ Make the size field of the node at _addr1_ equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at _addr2_ will be the one immediately above _addr1_.

: mergelinks ( addr1 addr2)
  @ 2dup swap !  >prev !  ;

  \ The node at _addr2_ is removed from the node list. As with
  \ `mergesizes` the node at _addr2_ will be immediately above
  \ that at _addr1_. Destroy the link from node1 to node2 and
  \ relink node1 to the node above node2. Destroy the backward
  \ link from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that `nextnode` may point to it. This is cured by
  \ making it point to the node prior to the one removed. We do
  \ not want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically `nextnode` is set to
  \ point to the node pointed to by the "previous" field of the
  \ node pointed to in the "next" field of the node pointed to
  \ by `nextnode`. Ordinarily this is a no-op (ie I am my
  \ father's son) but when the node has had its links merged it
  \ sets `nextnode` to point to the node prior to the node it
  \ pointed to (ie when I died my father adopted my son, so now
  \ my son is my father's son).

: merge ( addr)
  dup @ 2dup mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  --  Node Removal

: ?merge ( addr1 addr2)
  >size @ 0> if
    dup dup @
    u< if  dup merge  then
  then  drop  ;  -->

  \ Merge the node at _addr1_ with the one above it on two
  \ conditions, firstly that the node at _addr2_ is free, and
  \ secondly that the node pointed to by the next field in
  \ _addr1_ is actually above _addr1_ (ie that it does not wrap
  \ around because it is the topmost node). In usage _addr2_
  \ will be either _addr1_ or the node above it. In each
  \ instance the other affected node (either the node above
  \ _addr1_ or _addr1_) is known to be free, so no test is
  \ needed for this.

( heap )

: ?mergenext ( addr)  dup @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ dup ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

forth-wordlist set-current

: free ( addr -- ior)
  headsize -  dup togglesize  dup ?mergenext  ?mergeprev  0  ;

heap-wordlist set-current

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  --  Node Repairing

variable stash

  \ the `resize` algorithm is simplified and made faster by
  \ assuming that it will always succeed. `stash` holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ saves the contents of the `>next` field of the node being
  \ `resize`d in `stash` (above).

: restorelink ( addr)  stash @  swap !  ;

  \ Converse operation to `savelink` (above).

: fixprev ( addr)  dup >prev @ !  ;

  \ The `>next` field of the node prior to the node being
  \ `resize`d should point to the node being `resize`d. it may
  \ very well do already, but this makes sure.

: fixnext ( addr)  dup @ >prev !  ;

  \ The `>prev` field of the node after the node resized may
  \ need correcting.  This corrects it whether it needs it or
  \ not.  (Its quicker just to do it than to check first.)

: fixlinks ( addr)  dup fixprev  dup fixnext  @ fixnext  ;

  \ `resize` may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of `jiggle` (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)
  dup >size @ 0>
  if  dup @  2dup <
      if    over - swap >size !  else  2drop  then
  else  drop  then  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the `>next` field provided
  \ that the node is free and it is not the topmost node in the
  \ heap (ie there is no wraparound). Both these conditions
  \ need to be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  dup fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to `resize` (damaged by
  \ `?mergenext`) and its predecessor (damaged by `?mergeprev`).

: repair ( addr)
  dup restorelink
  dup fixlinks  dup fixsizes
  togglesize  ;

  \ Make good the damage done by `resize`. Restore the `>next`
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer `nextnode`
  \ may have moved back one or two nodes by virtue of having
  \ been `jiggle`d about if it happened to be pointing to the
  \ wrong node. This is not serious, so I have chosen to ignore
  \ it.


  \ ANSI Heap  --  Node Movement

: toobig? ( addr size -- flag)
  swap  >size @  >  ;

  \ _Flag_ is true if the node at _addr_ is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
  over >size @  headsize -
  rot  headsize + rot rot move  ;

  \ Move the contents of the data field of the node at _addr1_
  \ to the data field at _addr2_. Assumes _addr2_ is large
  \ enough. It will be.

: enlarge ( addr1 size -- addr2 ior)
  over  ?mergeprev
  allocate dup >r
  if  swap repair  else  tuck copynode  then  r>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of _addr1_ to the new node. Merge the node at addr1 with
  \ the one preceding it, if possible. This last behaviour is
  \ to finish off removing the node at _addr1_. The word
  \ `adjust` (below) starts removing the node. The node is
  \ removed before allocation to increase the probability of
  \ `allocate` succeeding. The address returned by `enlarge` is
  \ that returned by `allocate`, which is that of the data
  \ field, not the head. If the allocation fails repair the
  \ damage done by removing the node at _addr1_.


  \ ANSI Heap  --  Node Restructuring

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >r
  headsize -
  dup savelink
  dup togglesize
  dup ?mergenext r>  ;

  \ _Addr1_ points to the data field of a node, not the "next"
  \ field. This needs correcting. _Size1_ also needs adjusting
  \ as per `adjustsize`. In addition it is easier to work with
  \ free nodes than live ones as the size field is correct,
  \ and, as we intend to change the nodes size we will
  \ inevitably want to muck about with the next node, if its
  \ free, so lets merge with it straight away. Sufficient
  \ information is first saved to put the heap back as it was,
  \ if necessary.  Now we are ready to get down to business.

-->

( heap )

forth-wordlist set-current

: resize ( addr1 u -- addr2 ior)
  dup 0<  if  drop -61  \ `resize` error code
          else  adjust  2dup toobig?
                if enlarge
                else  over makenode headsize +  0  then
          then  ;

  \ Resize the node at _addr1_ to the specified size. Return
  \ the address of the resized node _addr2_ along with an _ior_
  \ of zero if successful and -61 if not. _Addr2_ may be the
  \ same as, or different to, _addr1_.  If _ior_ is non-zero
  \ then _addr2_ is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using `makenode`,
  \ which has just the right functionality.  In this case the
  \ ior is zero. As this is a standard word it takes an
  \ unsigned size argument, but excessive requests fail
  \ automatically, as with `allocate`.

  \ vim: filetype=soloforth
  \ memory.alocate.gil.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ An alternative implementation of the
  \ common heap based on code written by Javier Gil.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on "Gestor de memoria dinmica (version 1)" by Javier
  \ Gil, from his book _Introduccin a Forth_ (2007-01),
  \ <http://disc.ua.es/~gil/#forth>.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-18: Start.
  \ 2015-11-21: Changes.

( create-heap )

need value  need set-bit  need reset-bit  need bit?
need reserve  need alias

0 value heap  ( -- a )
  \ Address of the current heap.

8 constant address-unit-bits
16 value /chunk \ bytes per chunk

: groups ( n1 n2 -- n3 )  /mod swap 0<> abs +  ;
  \ Return the number _n3_ of groups of _n2_ elements, needed
  \ to hold _n1_ elements.

: bytes>chunks ( n1 -- n2 )  /chunk groups  ;
  \ Return the chunks _n2_ required to allocate _n1_ bytes.

: chunks>bytes ( n1 -- n2 )  address-unit-bits groups  ;
  \ Return the bytes _n2_ required for a bitmap of _n1_ chunks.

' heap alias heap-chunks  ( -- a )
  \ Address that holds the number of chunks of the current
  \ heap.

: heap-unused-chunks  ( -- a )  heap-chunks cell+  ;
  \ Address that holds the number of unused chunks of the
  \ current heap.

: heap-map  ( -- a )  heap-unused-chunks cell+  ;
  \ Address of the current heap's map.

: /heap-map  ( -- n )  heap-chunks @ chunks>bytes  ;
  \ Number of bytes of the current heap's map.

: heap-data  ( -- a ) heap-map /heap-map +  ;  -->
  \ Address of the current heap's data space.

( create-heap )

: (mapbit)  ( n1 -- n2 ca )
  address-unit-bits /mod heap-map +  ;
  \ n1 = number of bit in the bitmap
  \ n2 = number of bit in the byte at _a2_
  \ ca = address of the bitmap that holds bit _n2_

: mapbit ( n1 -- a2 b n2 )  (mapbit) dup @ rot  ;
  \ n1 = number of bit in the bitmap
  \ a2 = address of the correspondent byte
  \ b =  correspondent byte
  \ n2 = number of bit in _b_

: used-chunk? ( n -- f )  (mapbit) @ swap bit?  ;
  \ Is chunk _n_ used?

: use-chunk ( n -- )  mapbit set-bit swap !  ;
  \ Mark chunk _n_ as used.

: free-chunk ( n -- )  mapbit reset-bit swap !  ;
  \ Mark chunk _n_ as free.

: allocated>chunks  ( a -- n )  cell- @  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its number of chunks.

: allocated>index  ( a -- n )  heap-data - /chunk /  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n_ in the map of the heap
  \ chunks.

: allocated>map  ( a -- n1 n2 )
  dup allocated>index swap allocated>chunks  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n1_ in the map of heap chunks
  \ and the number _n2_ of ocuppied chunks.

-->

( create-heap )

: locate-chunks  ( n1 -- n1 n2 0 | ior )
  0 tuck  ( n2 n1 count )
  heap-chunks @ 0 do  ( n2 n1 count )
    i used-chunk? if  drop >r i 1+ r> 0  else  1+  then
    2dup = if  drop swap 0 unloop exit  then
  loop  2drop drop -59  ;
  \ Locate _n1_ consecutive free chunks in the current heap.
  \ If succesful, _n2_ is the first chunk of the group;
  \ else return _ior_ -59, the error code for `allocate`.

: chunk>address  ( n1 -- a )  /chunk * heap-data +  ;

: (allocate)  ( n1 n2 -- a )
  dup chunk>address >r
  swap bounds do  i use-chunk  loop
  r>  ;
  \ Allocate _n1_ chunks of the current heap, starting from
  \ chunk _n2_; return the address _a_ of the allocated space.

-->

( create-heap )

  \ User interface

: create-heap ( n "name" -- )
  create  bytes>chunks dup ,  0 ,
            \ max chunks and free chunks
          dup chunks>bytes reserve drop
            \ bitmap
          /chunk * allot  ;
            \ data space
  \ Create a new heap "name" to hold _n_ bytes.

: allocate  ( n -- a ior )
  bytes>chunks locate-chunks ?dup ?exit  (allocate) 0  ;

: free  ( a -- ior )
  allocated>map dup >r
  bounds do  i free-chunk  loop
  r> heap-unused-chunks +! 0  ;

  \ XXX TODO -- update with `resize`
  \ doc{
  \
  \ free  ( a -- ior )
  \
  \ Return the contiguous region of data space indicated by _a_
  \ to the system for later allocation. _a_ shall indicate a
  \ region of data space that was previously obtained by
  \ `allocate`.
  \
  \ If the operation succeeds, _ior_ is zero. If the operation
  \ fails, _ior_ is -60.
  \
  \ Origin: Forth-94 (MEMORY), Forth-2012 (MEMORY).
  \
  \ }doc

: empty-heap  ( -- )  heap-chunks @ 0 do  i free-chunk  loop  ;
  \ Empty the current heap, setting all chunks free.

: .heap ( -- )
  heap-chunks @ 0 do
    i used-chunk? if  [char] x  else  [char] -  then  emit
  loop  ;

  \ Print the map of the current heap. Occupied chunks are
  \ marked with a "x"; free chunks are marked with a "-".

  \ vim: filetype=soloforth

  \ memory.bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604171421

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory banks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-17: Moved `!s` and `!cs` from the kernel.

( !s c!s )

: !s  ( x a -- )  system-bank ! default-bank  ;

  \ doc{
  \
  \ !s  ( x a -- )
  \
  \ Store _x_ into address _a_ of the system bank.
  \
  \ }doc

: c!s  ( c ca -- )  system-bank c! default-bank  ;

  \ doc{
  \
  \ c!s  ( c ca -- )
  \
  \ Store _c_ into address _ca_ of the system bank.
  \
  \ }doc


  \ vim: filetype=soloforth
  \ memory.code-bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Tool to use a 16-KiB memory bank to store binary code,
  \ Forth words or data.  The intent is to use it mainly for
  \ binary modules, saving dictionary space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( code-bank )

need save-here  need call

variable cp  bank-start cp !  \ code pointer

: code-here   ( -- a )  cp @  ;
: code-there  ( a -- )  cp !  ;
: code-allot  ( n -- )  cp +!  ;

variable code-bank#  3 code-bank# !
  \ Memory bank used as code bank.

: code-bank  ( -- )  code-bank# @ bank  ;
  \ Page the code bank in.

: code-bank{  ( -- )  save-here code-here there code-bank  ;
  \ Start compiling code into the code bank.

: }code-bank  ( -- )  default-bank restore-here  ;
  \ End compiling code into the code bank.

: ?bank  ( -- )  bank-start here u< #-276 ?throw  ;
  \ Issue error -276 if the dictionary has reached
  \ the zone of memory banks. This check is required after
  \ compiling code that manipulates memory banks.

: code-bank-caller  ( i*x a "name" -- j*x )
  create ?bank ,
  does>  ( -- )  ( pfa ) @ code-bank call default-bank  ;
  \ Create a word "name" which will call the machine code
  \ routine at _a_, in the code bank.

?bank

  \ vim: filetype=soloforth
  \ memory.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604171225

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-17: Added `-!`. Documented some words.

( exchange )  \  ==memory==

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

( -! )

code -!  ( n|u a -- )
  E1 c,  D1 c,
  \ pop hl ; address
  \ pop de ; number
  7E c,  90 03 + c,  70 07 + c,  23 c,
  \ ld a,(hl)
  \ sub a,e
  \ ld (hl),a
  \ inc hl
  7E c,  98 02 + c,  70 07 + c,
  \ ld a,(hl)
  \ sbc a,d
  \ ld (hl),a
  jpnext  end-code

  \ doc{
  \
  \ -!  ( n|u a -- )
  \
  \ Subtract n|u from the single-cell number at _a_.
  \
  \ }doc

( c+! c@+ )

need z80-asm

[unneeded] c+! dup
?\  code c+!  ( c ca -- )
?\    hl pop  de pop  e a ld  m a add  a m ld  jpnext  end-code

  \ doc{
  \
  \ code c+!  ( c ca - )
  \
  \ Add _c_ to the char at _ca_
  \
  \ }doc

[unneeded] c@+ dup
?\ code c@+  ( ca - ca+1 c )

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ First version
  \ de pop  de ftap  de incp  0 h ld# a l ld  pushhlde jp

  \ Second version
?\  hl pop  m a ld  hl incp  hl push  pusha jp  end-code

  \ doc{
  \
  \ code c@+  ( ca - ca+1 c )
  \
  \ Fetch the character at _ca_ a and increments the address.
  \ This is handy for stepping through character arrays.
  \
  \ }doc

( 1+! 1-! )

need z80-asm  need [if]

[needed] 1+! [if]
code 1+!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de incp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the single-cell number at _a_.
  \
  \ }doc

[needed] 1-! [if]
code 1-!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de decp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the single-cell number at _a_.
  \
  \ }doc

( c1+! c1-! )

need z80-asm

[unneeded] c1+!
?\  code c1+!  ( ca -- )  hl pop  m inc  jpnext  end-code

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the char at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  hl pop  m dec  jpnext  end-code

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the char at _ca_.
  \
  \ }doc

( c@+ c!+ -c@ -c! )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credit:
  \
  \ Words from the TED editor.
  \ http://dxforth.netbay.com.au/ted.html

  \ Note: these words are too specific for the TED editor.

need 1+!  need 1-!

: c@+  ( ca -- c )  dup @ c@ swap 1+!  ;
: c!+  ( c ca -- )  tuck @ c! 1+!  ;
: -c@  ( ca -- c )  dup 1-! @ c@  ;
: -c!  ( c ca -- )  dup 1-! @ c!  ;

( @+ @- !+ !- c@+ c@- c!+ c!- )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credit:
  \
  \ Words written after cmForth.

  \ XXX Note: the original descriptions didn't include stack
  \ notations. Some of them are not clear.

  \ @+  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is incremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ XXX TODO alternative found -- which one is cmForth?
  : @+ ( a inc -- value a+inc )  + dup @ swap  ;

  \ @-  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is decremented by _n_.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ !+  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then incremented by _n_.

  \ XXX TODO alternative found -- which one is cmForth?
  : !+  ( value a inc -- a+inc )  + tuck !  ;

  \ !-  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then decremented by _n_.

  \ c@+  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and increment the address by _n_.

  \ c@-  ( ca n -- c ca' )
  \
  \ Fetch a character from memory and decrement the address by _n_.

  \ c!+  ( c ca n -- ca' )
  \
  \ Store a character to memory and increment the address by _n_.

  \ c!-  ( c ca n -- ca' )
  \
  \ Store a character to memory and decrement the address by _n_.

( bit? set-bit reset-bit )

need lshift

: bit>mask  ( n -- b )  1 swap lshift  ;

  \ doc{
  \
  \ bit>mask  ( n -- b )
  \
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.
  \
  \ }doc

: bit? ( b n -- f )  bit>mask and 0<> ;

  \ doc{
  \
  \ bit? ( b n -- f )
  \
  \ Is bit _n_ of _b_ set?
  \
  \ }doc

: set-bit ( b1 n -- b2 )  bit>mask or ;

  \ doc{
  \
  \ set-bit ( b1 n -- b2 )
  \
  \ Set bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

: reset-bit ( b1 n -- b2 )  bit>mask invert and ;

  \ doc{
  \
  \ reset-bit ( b1 n -- b2 )
  \
  \ Reset bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc


( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credit:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need z80-asm  need [if]

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- wf )
  \   hl pop  de pop  e a ld  m and
  \   ' true jpnz  ' false jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s char < emit type char > emit cr

[needed] c@test-bits [if]
code c@test-bits  ( b1 ca -- b2 )
  hl pop  de pop  e a ld  m and  pusha jp
  end-code  exit  [then]
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[needed] c!toggle-bits [if]
code c!toggle-bits  ( b ca -- )
  hl pop  de pop  m a ld  e xor  a m ld  jpnext
  end-code  exit  [then]
  \ Invert the bits at _ca_ specified by the bitmask _b_.

( reserve alloted )

: reserve  ( n -- a )  here tuck over erase allot  ;

  \ doc{
  \
  \ reserve  ( n -- a )
  \
  \ Reserve _n_ address units of data space, erase the zone and
  \ return its address _a_.
  \
  \ }doc

: allotted  ( n -- a )  here swap allot ;

  \ doc{
  \
  \ allotted  ( n -- a )
  \
  \ Reserve _n_ address units of data space and return its
  \ address _a_.
  \
  \ }doc

  \ and return its address _a_.

  \ vim: filetype=soloforth
  \ memory.ports.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words for ports input and output.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( @p )

code @p  ( a -- b )

  \ Input byte _b_ from port _a_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  jppushhl        \ jp pushhl
  end-code

( !p )

code !p  ( b a -- )

  \ Output byte _b_ to port _a_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  end-code

  \ vim: filetype=soloforth
  \ modules.begin-module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603252238

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of named and unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation supports any number of groups of
  \ private and public words, in any order. Beside, named
  \ modules make it possible to use the private words of the
  \ module, if needed.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Code adapted and modified from Galope.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( begin-module: begin-module public private end-module )

need get-order  need wordlist

  \ Inner words

get-order get-current

wordlist dup set-current  >order

variable current-wid  variable module-wid

: (begin-module)  ( -- wid )
  get-current current-wid !
  wordlist dup module-wid ! dup >order  ;

set-current

  \ Interface words

: public  ( -- )  current-wid @ set-current  ;
  \ doc{
  \
  \ public  ( -- )
  \
  \ Public definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: private  ( -- )  module-wid @ set-current  ;
  \ doc{
  \
  \ private  ( -- )
  \
  \ Private definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc


: begin-module:  ( "name" -- )
  (begin-module) constant private  ;
  \ doc{
  \
  \ begin-module:  ( "name" -- )
  \
  \ Start a named module "name".
  \ Private definitions follow.

  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ Usage example:

  \ ----
  \ begin-module: my_module
  \   \ Inner/helper words.
  \ public
  \   \ Interface words,
  \   \ compiled in the outer vocabulary,
  \   \ thus seen from the extern.
  \ private
  \   \ Inner/helper words again.
  \ public
  \   \ Interface words again. And so on.
  \ end-module
  \ ----

  \ The private words can be found using the module name,
  \ which returns the _wid_ of its word list.

  \ As an alternative, the word `begin-module` starts an
  \ unnamed module.
  \
  \ }doc

: begin-module  ( -- )  (begin-module) drop private  ;
  \ doc{
  \
  \ begin-module  ( -- )
  \
  \ Start an anonymous module.
  \ Private definitions follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: end-module  ( -- )  public previous  ;
  \ doc{
  \
  \ end-module  ( -- )
  \
  \ End a module.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

set-order

  \ vim: filetype=soloforth
  \ modules.minus-transient.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603252228

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of transient modules, whose code is
  \ discarded after being used. First intended for assemblers,
  \ but can be used for any other tool needed during the
  \ compilation of a program, but not during the execution.
  \ The size of the discarded code must be known in advance.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ The code was adapted from the Afera library. The Afera
  \ version was adapted from Spectrum Forth-83 (by Lennart
  \ Benschop, 1988), where it was used only for the assembler.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( transient[ )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- Finish and test.

need >>link

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - there  ;
  \ doc{
  \
  \ transient[  ( u -- )
  \
  \ Start transient code, reserving _u_ bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.
  \
  \ See: `]transient`, `-transient`.
  \
  \ }doc


: ]transient  ( -- )  old-dp @ there  old-np @ np !  ;

  \ doc{
  \
  \ ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.
  \
  \ See: `transient[`, `-transient`.
  \
  \ }doc

: -transient  ( -- )
  old-voc-link @ voc-link !
  \ XXX TODO -- finish adapt to Solo Forth:
  old-latest @ old-np @ >>link !s  ;

  \ doc{
  \
  \ -transient  ( -- )
  \
  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.
  \
  \ The inner operation is: Store the _nt_ of the latest word
  \ created before compiling the transient code, into the _lfa_
  \ of the first word created after the transient code was
  \ finished by `]transient`.
  \
  \ See: `transient[`, `]transient`.
  \
  \ }doc

  \ See: `transient[`, `-transient`.
  \ vim: filetype=soloforth
  \ modules.module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603252149

  \ -----------------------------------------------------------
  \ Description

  \ Simple and small implementation of unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation uses the data stack for temporary
  \ values and does no error checking.
  \

  \ -----------------------------------------------------------
  \ Authors

  \ Deway Val Schorre wrote the original code for fig-Forth,
  \ which was published on the article _Structured programming
  \ by adding modules to FORTH_, on Forth Dimensions (volume 2,
  \ number 5, page 132, 1981-01).

  \ Marcos Cruz (programandala.net), adapted it to Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( module )


need alias  need >>link

' latest alias internal  ( -- nt )

  \ doc{
  \
  \ internal  ( -- nt )
  \
  \ Start private definitions.
  \
  \ Return the _nt_ of the latest word created in the `current`
  \ vocabulary.
  \
  \ See `module` for a usage example.
  \
  \ }doc

' np@ alias external  ( -- xtp )

  \ doc{
  \
  \ external  ( -- xtp )

  \ End internal definitions.
  \
  \ Return the _xtp_ (execution token pointer) of the first
  \ word to be defined as external, that is, the current value
  \ of the names pointer.
  \
  \ See `module` for a usage example.
  \
  \ }doc

: module  ( nt xtp -- )  >>link !s  ;

  \ doc{
  \
  \ module  ( nt xtp -- )
  \
  \ Hide all words defined between the latest pair `internal`
  \ and `external`.  Those words are supposed to be needed only
  \ within a module and do not need to be exported.

  \ Link the first word after `external` to the word before
  \ `internal`, thus making the private words invisible.

  \ Usage example:
  \
  \ ----
  \ internal
  \
  \ : hello  ( -- )  ." hello"  ;
  \
  \ external
  \
  \ : salute  ( -- )  hello  ;
  \
  \ module
  \
  \ salute  \ ok!
  \ hello   \ error!
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ modules.privatize.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603252149

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of unnamed modules with error checking,
  \ adapted from pForth.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright 1996 Phil Burk.

  \ Adapted from pForth to Solo Forth by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( privatize )

need name<name  need abort"

variable private-start  variable private-stop

: private{  ( -- )
  latest private-start !  private-stop off  ;

  \ doc{
  \
  \ private{  ( -- )
  \
  \ Start private definitions.  See `privatize` for a usage
  \ example.
  \
  \ }doc

: }private  ( -- )
  private-stop @ abort" Extra }private"
  latest private-stop !  ;

  \ doc{
  \
  \ }private  ( -- )
  \
  \ End private definitions. See `privatize` for a usage
  \ example.
  \
  \ }doc

: privatize  ( -- )
  private-start @ 0= abort" Missing private{"
  private-stop @ dup 0= abort" Missing }private"
  begin   dup private-start @ u>
  while   dup hide name<name
  repeat  drop  private-start off  private-stop off  ;

  \ doc{
  \
  \ privatize  ( -- )
  \
  \ Hide all words defined between the latest valid pair of
  \ `private{` and `}private`.

  \ Usage example:
  \
  \ ----
  \ private{
  \ \ everything between `private{` and `}private`
  \ \ will become private.
  \ : foo ;
  \ : moo ;
  \ }private
  \
  \ : goo   foo moo ;  \ can use foo and moo
  \ privatize          \ hide foo and moo
  \ ' foo              \ will fail
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ multitask.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Jiffy tool for multitasking on
  \ G+DOS.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( jiffy! jiffy@ -jiffy )

  \ Note: This code is specific for G+DOS.

  \ Credit:
  \
  \ Idea inspired by an article by Paul King, published on
  \ Format (volume 2, number 3, 1988-10).
  \
  \ XXX TODO link to the WoS archive ftp, when available

need !dosvar  need @dosvar

: jiffy!  ( a -- )  16 !dosvar  ;
  \ Set the Z80 routine to be called by G+DOS after the OS
  \ interrupts routine, every 50th of a second.

: jiffy@  ( -- a )  16 @dosvar  ;
  \ Get the current Z80 routine that is called by G+DOS after
  \ the OS interrupts routine, every 50th of a second.

: -jiffy  ( -- )  8335 jiffy!  ;
  \ Deactivate the jiffy call, setting its default value
  \ (a noop routine in the RAM of the +D interface).

  \ vim: filetype=soloforth
  \ parsing.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to parsing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( parse-line )

  \ XXX OLD -- 2015-09-13: moved to kernel
  \ : source  ( -- a len )  \ Forth-94
  \   blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

: parse-line  ( "ccc<eol>" -- ca len )
  source span @ min c/l min  >in @ span @ min /string
  dup >in +! save-string  ;

  \ doc{
  \
  \ parse-line  ( "ccc<eol>" -- ca len )
  \
  \ Get the text string until the end of line.  Note: this is a
  \ factor of the editor's `text`.
  \
  \ }doc

( evaluate )

  \ XXX UNDER DEVELOPMENT

  \ XXX Gforth:
: execute-parsing  ( ca len xt -- )
  >in @ >r >in off
  source >r >r ;

: evaluate  ( ca len -- )  ['] interpret execute-parsing  ;

( parse-char )

: parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ;
  \ Parse the next char in the input stream and return its
  \ code.

( word )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: word  ( c "<chars>ccc<char>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -                      ( ca' len )
  here place  here            ( ca )
  bl over count + c!  ;       \ append trailing blank

  \  doc{
  \
  \  word  ( c "<chars>ccc<char>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( defined? )

: defined?  ( ca len -- wf )  undefined? 0=  ;

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: save-input ( -- xn ... x1 n )
  source-id 0>
  if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove
     r> to tib  >in @
     source-id file-position throw
     5
  else blk @ >in @ 2 then
  ;

-->
( save-input restore-input )

: restore-input ( xn ... x1 n -- f )
  source-id 0>
  if dup 5 <> if 0 ?do drop loop -1 exit then
     drop source-id reposition-file ?dup
     if >r 2drop drop r> exit then
     >in ! #tib ! to tib false
  else dup 2 <> if 0 ?do drop loop -1 exit then
     drop >in ! blk ! false
  then
  ;

  \ vim: filetype=soloforth
  \ printing.control.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related printing control characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( tabulate tab-stop )

need column

  \ 2015-12-14
  \ XXX FIXME

variable tab-stop  8 tab-stop !

: tabulate  ( -- )  column 1+ tab-stop @ tuck mod - spaces  ;

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

 6 constant 'tab'
 8 constant 'bs'
13 constant 'cr'

: tab          ( -- )  'tab' emit  ;
: backspace    ( -- )  'bs'  emit  ;

: crs           ( n -- )  'cr'  emits  ;
: tabs          ( n -- )  'tab' emits  ;
: backspaces    ( n -- )  'bs'  emits  ;

  \ vim: filetype=soloforth
  \ printing.cursor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the cursor position.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( column last-column row last-row at-x at-y )

: column  ( -- col )  xy drop  ;
  \ Current column (x coordinate).

: last-column  ( -- row  )  column 1-  ;
  \ Last column (x coordinate).

: row  ( -- row )  xy nip  ;
  \ Current row (y coordinate).

: last-row  ( -- row  )  row 1-  ;
  \ Last row (y coordinate).

: at-x  ( col -- )  row at-xy  ;
  \ Set the cursor
  \ at the given column (x coordinate)
  \ and the current row (y coordinate).

: at-y  ( row -- )  column swap at-xy  ;
  \ Set the cursor
  \ at the current column (x coordinate)
  \ and the given row (y coordinate).

  \ vim: filetype=soloforth
  \ printing.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Tool to print left justified texts.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( print )

  \ XXX UNDER DEVELOPMENT
  \ Adapted from Galope <print.fs>.

need last-row  need /name

  \ export

variable #printed   \ Printed chars in the current line.
variable #indented   \ Indented chars in the current line.
: printed+  ( u -- )  #printed +!  ;
: indented+  ( u -- )  #indented +!  ;
: (.word) ( ca len -- )  dup printed+ type  ;
: .char  ( c -- )  emit 1 printed+  ;
: not-at-home?  ( -- f )  xy +  ;

  \ export

: no-printed  ( -- )  #printed off #indented off  ;
: print-home  ( -- )  home no-printed  ;
: print-page  ( -- )  page print-home  ;

-->

( print )

: print-start-of-line  ( -- )
  #printed @ trm+move-cursor-left no-printed  ;

  \ : print-cr  ( -- )  not-at-home? if  cr  then  no-printed  ;
  \ XXX OLD first version

  \ hide

: at-last-start-of-line?  ( -- wf )
  xy last-row = swap 0= and  ;
: not-at-start-of-line?  ( -- wf )  column 0<>  ;
: print-cr?  ( -- wf )
  not-at-home? not-at-start-of-line? and
  \ xxx fixme 2012-09-30 what this was for?:
  \ at-last-start-of-line? 0= or
  ;

  \ export

defer (print-cr) ' (print-cr) ' cr defer!

: print-cr print-cr? ?? (print-cr) no-printed ;

variable print-width

-->

( print )

  \ hide

: previous-word?  ( -- wf )  #printed @ #indented @ >  ;
: ?space  ( -- ) previous-word? if  bl .char  then  ;
: current-print-width  ( -- u )
  print-width @ ?dup 0= ?? cols  ;
: too-long?  ( u -- wf )
  1+ #printed @ + current-print-width >  ;
: .word  ( ca len -- )
  dup too-long? if  print-cr  else  ?space  then  (.word)  ;

-->

( print )

: (print-indentation)  ( u -- )
  dup trm+move-cursor-right dup indented+ printed+  ;

  \ export

: print-indentation  ( u -- )  ?dup ?? (print-indentation)  ;

  \ hide

: >word  ( ca1 len1 ca2 len2 -- ca2 len2 ca1 len4 )
  \ ca1 len1 = Text, from the start of its first word.
  \ ca2 len2 = Same text, from the char after its first word.
  \ ca1 len4 = First word of the text.
  tuck 2>r -  2r> 2swap  ;

: first-word  ( ca1 len1 -- ca2 len2 ca3 len3 )  /name >word  ;

: (print)  ( ca1 len1 -- ca2 len2 )  first-word .word  ;

-->

( print )

  \ export

: print  ( ca len --)
  begin  dup   while  (print)  repeat  2drop  ;

  \ Suggested usage in the application:

  \ 4 value indentation
  \ : paragraph  ( ca len -- )
  \   print-cr indentation print-indentation print  ;

  \ vim: filetype=soloforth
  \ random.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604082315

  \ -----------------------------------------------------------
  \ Description

  \ Pseudo-random number generators.
  \
  \ See benchmark results in <development_benchmarks.rng.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( rnd random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: Found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: Adapted to Solo Forth.
  \
  \ 2016-04-08: Updated the constant after the latest
  \ benchmarks.

2variable rnd-seed  $0111 rnd-seed !

: rnd  ( -- u )
  rnd-seed 2@ $62DC um* rot 0 d+ over rnd-seed 2!  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).

( fast-rnd fast-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code fast-rnd  ( -- u )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: fast-random  ( n -- 0..n-1 )  fast-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

( crnd crandom )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need os-seed

code crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

: crandom  ( b -- 0..b-1 )  crnd um* nip  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( randomize randomize0 )

[defined] randomize
?\  need os-seed  : randomize  ( n -- )  os-seed !  ;
  \ Set the seed of the random number generator.

[needed] randomize ?exit

need os-frames

: randomize0  ( n -- )
  ?dup 0=  if  os-frames @  then  randomize  ;
  \ Set the seed of the random number generator;
  \ if _n_ is zero use the system frames counter instead.

  \ vim: filetype=soloforth
  \ return_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the return stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( n>r )  \ ==returnstack==

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

  \ doc{
  \
  \ n>r  ( x1..xn n -- ) ( R: -- x1..xn n )
  \
  \ }doc

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  jppushhl
  end-code

  \ doc{
  \
  \ nr>  ( -- x1..xn n ) ( R: x1..xn n -- )
  \
  \ }doc

need n>r

( rdepth r'@ )

  \ Credit:
  \
  \ `rdepth` from Afera.

[unneeded] rdepth
?\ : rdepth  ( -- n )  rp@ rp0 @ - -2 /  ;

  \ doc{
  \
  \ rdepth  ( -- n )
  \
  \ }doc

  \ Credit:
  \
  \ `r'@` from Wil Baden.

[unneeded] r'@ dup
?\ : r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
?\   r> 2r@ drop swap >r  ;

  \ doc{
  \
  \ r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  \
  \ }doc

  \ }}} =======================================================
  \ User variables {{{

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

: uallot ( n -- )  udp @ swap udp +!  ;
  \ XXX from Gforth

: user  ( "name" -- )  create cell uallot , does> @ up @ +  ;

: user  ( "name" -- )  create cell uallot c, does> c@ up @ +  ;

  \ vim: filetype=soloforth
  \ screen_mode.32.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The screen mode 32.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( mode32 )

need columns  need rows  need set-font  need set-mode-output

: mode32  ( -- )
  [ latest name> ] literal current-mode !
  15360 set-font  2548 set-mode-output
  32 to columns  24 to rows
  ['] mode32-xy ['] xy defer!
  ['] mode32-at-xy ['] at-xy defer!  ;
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).

' mode32 ' default-mode defer!

  \ vim: filetype=soloforth
  \ screen_mode.42.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The screen mode 42.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( mode42 )

  \ XXX UNDER DEVELOPMENT -- a 42 CPL mode

  \ Credit:
  \
  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ XXX TODO -- integrate the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

need set-mode-output  need <file-as-is  need (mode42

: mode42  ( -- )
  [ latest name> ] literal current-mode !
  (mode42 set-mode-output  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

get-drive 1 set-drive
s" prnt42.bin" <file-as-is throw
s" ea5aky.f42" <file-as-is throw
set-drive
  \ Load the driver and the font.

( banked-mode42 )

  \ XXX UNDER DEVELOPMENT -- A variant of `mode42` that stores
  \ the driver and the font in the code bank.

  \ Credit:
  \
  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ XXX TODO -- integrate the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

need set-banked-mode-output  need <file-as-is
need (mode42  need code-bank

: banked-mode42  ( -- )
  [ latest name> ] literal current-mode !
  (mode42 set-banked-mode-output  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.
  \ XXX FIXME -- crash!

code-bank{
  get-drive 1 set-drive
  s" prnt42.bin" <file-as-is throw
  s" ea5aky.f42" <file-as-is throw
  set-drive
}code-bank
  \ Load the driver and the font into the code bank.

( (mode42 )

need columns  need rows  need set-font

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode42-xy  ( -- col row )  0 0  ;  \ XXX TODO

: (mode42  ( -- a )
  42 to columns  24 to rows
  ['] mode42-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  [ 64600 256 - ] literal set-font 63900  ;
  \ Set the 42 cpl font and `at-xy`;
  \ Return the address of the output routine.

  \ vim: filetype=soloforth
  \ screen_mode.64.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The screen mode 64.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( mode64 )

  \ A 64 CPL mode

  \ Credit:
  \
  \ Author of the original code: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1
  \ Modified and adapted to Solo Forth by Marcos Cruz.

  \ XXX TMP -- The driver is loaded from disk into and the
  \ memory address 60000.
  \ XXX TODO -- Integrate the driver into the library.

need mode32  need <file-as-is  need 4x8font

get-drive 1 set-drive
s" 4x8fd.bin" <file-as-is throw
set-drive
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode64-xy  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latest name> ] literal current-mode !
  64 to columns  24 to rows
  ['] mode64-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  4x8font set-font  60000 set-mode-output  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

  \ XXX TODO mode64-home

code mode64-emit  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if  FF a ld#  then
  \ check_cr

  end-code

: mode64  ( -- )
  mode64-chars @ set-font  mode64-emit set-mode-outupt
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credit:
  \
  \ Author of the font: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

  \ vim: filetype=soloforth
  \ screen_mode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that are common to all screen
  \ modes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( columns rows )

need value

32 value columns  24 value rows

( set-banked-mode-output )

need set-mode-output

0 constant (output-routine)

code (banked-mode-output)  ( -- )
  C5 c,                 \ push bc ; save Forth IP
  CD c, 0 ,             \ call output_routine ; to be patched

  here cell- ' (output-routine) >body !
    \ Store the address where the address of the output routine
    \ must be stored, into the constant `(output-routine)`.

  C1 c,                 \ pop bc ; restore Forth IP
  DD c, 21 c, next ,    \ ld ix,next ; restore IX, just in case
  jpnext  end-code

: set-banked-mode-output  ( a -- )
  (output-routine) !  \ patch `(banked-mode-output)`
  ['] (banked-mode-output) set-mode-output  ;
  \ Associate the output routine at _a_ (which is in the code
  \ bank) to the system channels "K", "S" and "P", using and
  \ intermediate routine to page the code bank in and out.

( set-mode-output set-font )

need os-chars  need os-chans

: set-mode-output  ( a -- )
  os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

  \ doc{
  \
  \ set-mode-output  ( a -- )
  \
  \ Associate the output routine at _a_ to the system channels
  \ "K", "S" and "P".
  \
  \ }doc
  \ XXX TODO -- why also "P"?

: set-font  ( a -- )  os-chars !  ;

  \ doc{
  \
  \ set-font  ( a -- )
  \
  \ Set the system font to _a_.  This is used by all modes:
  \ `mode32`, `mode42` and `mode64`. The value of _a_ depends
  \ on the mode: In `mode32` and `mode42`, _a_ is the address
  \ of char 0, i.e. 256 bytes below the space char; In `mode64`
  \ _a_ is the address of space char.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ screen_mode.fzx.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ The FZX screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 set-drive  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( gx gy -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credit:
  \
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    r now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  r add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) call
  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ sound.128.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140107

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 128k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( sound-register-port sound-write-port )

65533 constant sound-register-port
49149 constant sound-write-port

( !sound vol shutup noise )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !p  need sound-register-port  need sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  vocabulary music  current @  also music definitions
need roll

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b  -->

( music )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l   ( n -- )  len !  ;
: o+  ( -- )    octave @ 2 * octave !  ;
: o-  ( -- )    octave @ 2 / octave !  ;
: r   ( -- )    tempo @ len @ * ms  ;
: >>  ( -- )    1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )    1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: sound, )

  \ Credit:
  \
  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !p  need sound-register-port  need sound-write-port

14 constant /sound

: play  ( a -- )
  \ a = address of a table with 14 bytes
  /sound 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

: sound,  ( b0 ... b13 -- )
  here /sound allot here 1- do  i c!  -1 +loop  ;

: sound:  ( b0 ... b13 "name" -- )  create  sound,  ;

( play sound: sound, )

  \ XXX TODO -- alternative:

need roll

: sound:  ( b0 ... b13 "name" -- )
  create  14 0 do  14 i - roll ,  loop  ;

: sound,  ( b0 ... b13 -- a )
  here >r 14 0 do  14 i - roll ,  loop  r>  ;

( play )

  \ Faster version of the previous `play`, using `c@+`,
  \ which requires the assembler.

need !p  need c@+
need sound-register-port  need sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  c@+ sound-write-port !p
  loop  drop  ;

( play )

  \ Z80 version of the previous `play`.

need z80-asm

need sound-register-port  need sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter1 train )

  \ Sounds to be played with `play`.

need sound:

  \ Credit:
  \
  \ `waves` and `shoot` are
  \ adapted from code written by Juan Jos Ruiz,
  \ published on Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

0  0  0  0  0  0  7 71  20  20  20  0  38  14
sound: waves

10  0  177  0  191  0  31 71  20  20  20  92  28  3
sound: shoot

  \ Credit:
  \
  \ `helicopter` and `train` are
  \ adapted from code written by Jos ngel Martn,
  \ published on Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

200  15  200  15  200  15  0 7 23  23  23  255  1  12
sound: helicopter1

100  120  48  97  12  200  55 15  9  11  55  180  4  8
sound: train

( bomber whip metalic rain2 lightning1 lighting2 )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Adapted from data written by Francisco Majn,
  \ published on Microhobby, issue 194 (1989-12), page 26:
  \ http://microhobby.org/numero194.htm
  \ http://microhobby.speccy.cz/mhf/194/MH194_26.jpg

need sound:

73 82 62 165 90 138 159 140 102 77 100 162 87 201 sound: bomber

5 18 8 6 19 11 5 11 0 19 3 24 21 1 sound: whip

149 64 104 236 210 180 0 32 0 194 146 73 81 177 sound: metalic

16 17 25 10 19 9 4 31 245 1 6 30 2 sound: rain2

1 4 0 16 36 67 8 4 31 245 1 6 30 2 sound: lighting1

0 0 0 0 0 255 7 4 255 25 0 60 60 3 sound: lighting2

( Sound effects )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Data extracted a program written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter2
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop2

decimal

( rain1 waterdrop1 )

  \ Sounds to be played with `play`.

need sound:

  \ Credit:
  \
  \ Data extracted from a program written by Carlos Ventura,
  \ published on Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX FIXME -- these effects don't sound fine, though the data
  \ are correct

44 24 6 6 7 3 3 5 44 6 3 5 3 3 sound: rain1

20 83 94 39 0 8 31 71 23 23 22 90 0 0 sound: waterdrop1

  \ vim: filetype=soloforth
  \ sound.48.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140114

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 48k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Main development.
  \ 2016-04-14: Documented `bleep` and `beep>bleep`.

( bleep )

  \ Credit:
  \
  \ Code modified from Abersoft Forth.

code bleep  ( duration pitch -- )
  E1 c,  D1 c,  C5 c,  CD c, 03B5 ,
    \ pop hl
    \ pop de
    \ push bc ; save Forth IP
    \ call rom_beeper
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore ix
  jpnext
  end-code

  \ doc{
  \
  \ bleep  ( duration pitch -- )
  \
  \ Produce a tone in the internal beeper.
  \
  \ }doc


( beep>bleep )

  \ Credit:
  \
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( frequency duration1 -- duration2 pitch )
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

  \ doc{
  \
  \ beep>bleep  ( frequency duration1 -- duration2 pitch )
  \
  \ Convert the parameters of Sinclair BASIC `beep` to Solo
  \ Forth `bleep`. See `bleep`.
  \
  \ }doc

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published on Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Lder Software.
  \ Published on Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ string.cquote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Two implementations of `c"` and
  \ `csliteral`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( cslit csliteral c" )

  \ This is the default definition of `csliteral`, based on a
  \ system-dependent `cslit`, which makes it possible to decode
  \ `c"`.

  \ XXX REMARK -- 43 bytes used

: cslit  ( -- ca )  r@ dup c@ 1+ r> + >r  ;
  \ doc{
  \
  \ cslit  ( -- ca )
  \
  \ Return a string that is compiled after the calling word, and
  \ adjust the instruction pointer to step over the inline string.
  \
  \ }doc

: csliteral  ( ca len -- )
  compile cslit s,  ; immediate compile-only
  \ doc{
  \
  \ csliteral  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Compile a string _ca len_ which at run-time will
  \ be returned as a counted string.
  \
  \ }doc

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  [char] " parse postpone csliteral  ; immediate compile-only
  \ doc{
  \
  \ c"  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Parse a string delimited by double quotes and
  \ compile it into the current definition.
  \ At run-time the string will be returned as a
  \ counted string _ca_.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( csliteral c" )

  \ This is an alternative system-independent definition of
  \ `csliteral`.

  \ XXX REMARK -- 43 bytes used

: csliteral  ( Compilation: ca len -- )
             ( Run-time: -- ca )
  2>r postpone ahead here 2r> s, >r postpone then
  r> postpone literal  ; immediate compile-only
  \ Credit:
  \ Code from Gforth's `CLiteral`.

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  [char] " parse postpone csliteral  ; immediate compile-only

  \ vim: filetype=soloforth
  \ strings.escaped.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to escaped strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( parse-escaped-string )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( parse-escaped-string )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "ccc<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

( s\" )

need parse-escaped-string

: s\"  ( Interpretation: "ccc<quote>" -- ca len )
       ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "ccc<quote>"  - ca len )
  \
  \ }doc

( .\" )

need parse-escaped-string

: .\"  ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only

  \ vim: filetype=soloforth
  \ strings.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ String words and tools.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( s= )

: s=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;

( sconstant )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credit:
  \
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( hunt )

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( #spaces )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

( #chars )

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credit:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need s=  need [if]

  \ Credit:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]
: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> s=  ;
[then]

  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]
: suffix? ( ca1 len1 ca2 len2 -- wf )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string s=  ;
[then]

( -prefix )

  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ )

code string/  ( ca1 len1 len2 -- ca2 len2 )
    \                           ;   T  B
    \                           ;  -- --
  D9 c,  C1 c,  D1 c,  E1 c,
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
  19 c,  A7 c,  ED c, 42 c,
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c,  C5 c,
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
  D9 c,  jpnext
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total
  end-code

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

exit

  \ Slower version, 1 byte shorter
  \
  \ Credit: code from Galope.

: string/  ( ca1 len1 len2 -- ca2 len2 )
  >r + r@ - r>  ;
  \ Return the _len2_ ending characters of string _ca1 len1_.

  \ vim: filetype=soloforth
  \ strings.replaces.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `replaces`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( replaces )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credit:
  \
  \ Code adapted from the Forth-2012 documentation.

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

vocabulary replaces-voc
wid-of replaces-voc constant wid-subst
  \ wordlist id of the wordlist used to hold substitution names and replacement text.

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

-->

( replaces )

: findsubst  ( ca len -- xt f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _xt_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if
    nip nip execute    \ get buffer address
  else
     makesubst
  then
  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )

  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc

  \ vim: filetype=soloforth
  \ strings.s-quote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `s'`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( s' )

  \ Credit:
  \
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  \
  \ Identical to the standard word `s"`, but using single
  \ quote as delimiter. A simple alternative to `s\"` when only
  \ double quotes are needed in a string.
  \
  \ }doc

: s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  [char] ' parse-string  ; immediate

  \ vim: filetype=soloforth
  \ system_variables.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603301710

  \ -----------------------------------------------------------
  \ Description

  \ Constants for the system variables.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( os-chars os-chans os-flags2 os-seed os-frames os-udg )

[unneeded] os-chars    ?\ 23606 constant os-chars
  \ 1 cell:
  \ address of character 0 of the font (actual characters 32..127)

[unneeded] os-chans    ?\ 23631 constant os-chans
  \ 1 cell:
  \ address of the channels

[unneeded] os-flags2   ?\ 23658 constant os-flags2
  \ 1 byte:
  \ several flags

[unneeded] os-seed     ?\ 23670 constant os-seed
  \ 1 cell:
  \ seed of the random number generator

[unneeded] os-frames   ?\ 23672 constant os-frames
  \ 3 bytes:
  \ 24-bit counter of frames (1 frame = 20 ms)

[unneeded] os-udg      ?\ 23675 constant os-udg
  \ 1 cell:
  \ address of the User Defined Graphics (characters 128..255)

[unneeded] os-coords      ?\ 23677 constant os-coords
  \ 2 cells:
  \ coordinates of last point plotted

[unneeded] os-coordx      ?\ 23677 constant os-coordx
  \ 1 cell:
  \ x-coordinate of last point plotted

[unneeded] os-coordy      ?\ 23678 constant os-coordy
  \ 1 cell:
  \ y-coordinate of last point plotted

  \ vim: filetype=soloforth
  \ tape.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604110003

  \ -----------------------------------------------------------
  \ Description

  \ Tape files support. The only supported filetype is "code".
  \ Contrary to BASIC, saving starts immediately (the message
  \ "Start tape, then press any key" is not printed).
  \
  \ Known issues:
  \
  \ 1) If the space key is pressed while reading or writing
  \ files, the ROM routine will issue a BASIC error and make
  \ the system crash.  This may be solved in the future, with
  \ the help of G+DOS, by trapping the error.
  \
  \ 2) Tape loading errors are not trapped. They make the
  \ system crash.
  \
  \ 3) No support to verify saved files. It may be added in the
  \ future, though it's not useful with emulators, without
  \ actual tapes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-12-04: Started adapting the tape words from the Afera
  \ library.
  \ 2015-12-23: Changes.
  \ 2016-04-10: Fixed. First working version.
  \ 2016-04-10: Improved: no "Start tape" message.

  \ -----------------------------------------------------------
  \ Development documentation

  \ The information was guessed from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119), the ZX Spectrum ROM
  \ disassembly (whose description of the tape headers is
  \ wrong), the _Abersoft Forth disassembled_ project
  \ (http://programandala.net/en.program.abersoft_forth.html)
  \ and the Afera library
  \ (http://programandala.net/en.program.afera.html).

  \ Structure of a tape header:

  \ +00 : byte, filetype (3 for code files)
  \ +01 : 10-char filename, padded with spaces
  \ +11 : cell, length
  \ +13 : cell, start address
  \ +15 : cell, not used for code files

  \ Arrangement of both tape headers:

  \ IX addresses the first header, which must contain the data.
  \ The second header is used by the system when loading and
  \ verifying. Only the "CODE" file type column is relevant to
  \ Solo Forth.

  \                 File types
  \                 -----------------------
  \ NEW     OLD     PROG   DATA  DATA  CODE
  \ HEADER  HEADER         num   chr          NOTES
  \ ------  ------  ----   ----  ----  ----   ----------------------------
  \ IX+$00  IX+$11  0      1     2     3      File type
  \ IX+$01  IX+$12  x      x     x     x      F  ($FF if filename is null)
  \ IX+$02  IX+$13  x      x     x     x      i
  \ IX+$03  IX+$14  x      x     x     x      l
  \ IX+$04  IX+$15  x      x     x     x      e
  \ IX+$05  IX+$16  x      x     x     x      n
  \ IX+$06  IX+$17  x      x     x     x      a
  \ IX+$07  IX+$18  x      x     x     x      m
  \ IX+$08  IX+$19  x      x     x     x      e
  \ IX+$09  IX+$1A  x      x     x     x      .
  \ IX+$0A  IX+$1B  x      x     x     x      Padding spaces
  \ IX+$0B  IX+$1C  lo     lo    lo    lo     Total...
  \ IX+$0C  IX+$1D  hi     hi    hi    hi     ...length of datablock
  \ IX+$0D  IX+$1E  Auto   -     -     Start  Various
  \ IX+$0E  IX+$1F  Start  a-z   a-z   addr   ($80 if no autostart).
  \ IX+$0F  IX+$20  lo     -     -     -      Length of program only...
  \ IX+$10  IX+$21  hi     -     -     -      ...i.e. without variables

( write-tape-file read-tape-file )

17 constant /tape-header
  \ doc{
  \
  \ /tape-header  ( -- n )
  \
  \ A constant. Length of the tape header stored at
  \ `tape-header`: 17 bytes.
  \
  \ }doc

create tape-header  /tape-header 2 * allot

  \ doc{
  \
  \ tape-header  ( -- a )

  \ Address of the tape header, which is used by the ROM
  \ routines. Its structure is the following:

  \ |===
  \ | Offset  | Size     | Description
  \
  \ | +00     | byte     | filetype
  \ | +01     | 10-chars | filename, padded with spaces
  \ | +11     | cell     | length
  \ | +13     | cell     | start address
  \ | +15     | cell     | not used for code files
  \ |===

  \ When the first char of the filename is code 255, it is
  \ regarded as a wildcard which will match any filename. The
  \ word `read-tape-file` sets the wildcard when the provided
  \ filename is empty. See `any-tape-filename` and
  \ `?set-tape-filename`.
  \
  \ A second tape header follows the main one. It is used by
  \ the ROM routines while loading.

  \ }doc

10 constant /tape-filename \ filename max length

: tape-filetype  ( -- ca )  tape-header  ;

  \ doc{
  \
  \ tape-filetype  ( -- ca )
  \
  \ Address of the file type (one byte) in the tape header.
  \ See `tape-header`.
  \
  \ }doc

: tape-filename  ( -- ca )  tape-header 1+  ;

  \ doc{
  \
  \ tape-filename  ( -- ca )
  \
  \ Address of the filename in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-length    ( -- a )   tape-header 11 +  ;

  \ doc{
  \
  \ tape-length  ( -- a )
  \
  \ Address of the file length in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-start     ( -- a )   tape-header 13 +  ;

  \ doc{
  \
  \ tape-start  ( -- a )
  \
  \ Address of the file start in the tape header pointed by
  \ `tape-header`.
  \
  \ }doc

3 tape-filetype c!  \ "code" filetype by default

-->

( write-tape-file read-tape-file )

: -tape-filename  ( -- )  tape-filename /tape-filename blank  ;

  \ doc{
  \
  \ -tape-filename  ( -- )
  \
  \ Blank the filename of the tape header.
  \
  \ }doc

: any-tape-filename  ( -- )  255 tape-filename c!  ;

  \ doc{
  \
  \ any-tape-filename  ( -- )
  \
  \ Configure the tape header to load any filename,
  \ by replacing the first char of the filename with 255,
  \ which will be recognized as a wild card.
  \
  \ }doc

: set-tape-filename  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-filename swap cmove  ;

  \ doc{
  \
  \ set-tape-filename  ( ca len -- )
  \
  \ Store filename _ca len_ into the tape header.
  \
  \ }doc

: ?set-tape-filename  ( ca len -- )
  dup if    set-tape-filename
      else  2drop any-tape-filename  then  ;

  \ doc{
  \
  \ ?set-tape-filename  ( ca len -- )
  \
  \ If filename _ca len_ is not empty, store it into the tape
  \ header; else use a wildcard instead.
  \
  \ }doc

: set-tape-memory  ( ca len -- )
  tape-length ! tape-start !  ;

  \ doc{
  \
  \ set-tape-memory  ( ca len -- )
  \
  \ Configure the tape header with the memomy zone _ca len_ (to
  \ be read or written).
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (read-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,  2A c, tape-start ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
    \ ld hl,(tape_start)
  3E c, 01 c,  32 c, 5C74 ,  CD c, 075A ,
    \ ld a,1      ; 1=load
    \ ld (5C74),A ; T_ADDR system variable
    \ call 075A   ; SA_ALL ROM routine
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore the address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (read-tape-file)  ( -- )
  \
  \ Low-level action of `read-tape-file`: read a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: read-tape-file  ( ca1 len1 ca2 len2 -- )
  ?set-tape-filename set-tape-memory (read-tape-file)  ;

  \ doc{
  \
  \ read-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Read a tape file _ca2 len2_ (_len2_ is zero if filename is
  \ unspecified) into a memory region _ca1 len1_.
  \
  \ _ca1_ is zero if the address must be taken from the file
  \ header instead, which is the address the file was saved
  \ from.  _len1_ is zero if is unspecified.
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (write-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
  A8 07 + c,  32 c, 5C74 ,
    \ xor a       ; 0=save
    \ ld (5C74),a ; T_ADDR system variable
  21 c, here 0A + ,  E5 c,
    \ ld hl,return_from_ROM
    \ push hl ; simulate a call
  2A c, tape-start ,  E5 c,
    \ ld hl,(tape_start) ; start of data
    \ push hl ; needed by entry point $0984,
    \         ; because it's done at the main entry point $0970
  C3 c, 0984 ,
    \ jp $0984  ; alternative entry point to SA_ALL, after the save message
    \           ; note: `jp` is used, but it works as a `call`,
    \           ; because the return address has been pushed
    \ return_from_ROM:
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (write-tape-file)  ( -- )
  \
  \ Low-level action of `write-tape-file`: write a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: write-tape-file  ( ca1 len1 ca2 len2 -- )
  set-tape-filename set-tape-memory (write-tape-file)  ;

  \ doc{
  \
  \ write-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Write a memory region _ca1 len1_ into a tape file _ca2
  \ len2_.
  \
  \ }doc

( .tape )

  \ XXX TMP -- for debugging

: .tape  ( -- )
  cr ." Tape header " tape-header u. cr
     ." Filetype    " tape-filetype c@ . cr
     ." Filename    " tape-filename /tape-filename type cr
     ." Length      " tape-length @ u. cr
     ." Start       " tape-start @ u. cr
     .s cr
     ." Press any key" key drop  ;


  \ vim: filetype=soloforth
  \ time.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ms )  \ ==time==

need os-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / os-frames @ +
  begin  dup os-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

need os-frames

: frames@  ( -- d )
  os-frames @ [ os-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ os-frames 2+ ] literal c! os-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-xt  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-xt  hl pop  execute-hl
      \ execute the xt hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-xt

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-xt
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but its current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the xt hold in `(wait)`:

    ' (wait) >body fthl execute-hl

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- adapt `pause` to DTC, needed?

( just-pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit  then
  dup 100 mod 0= if  drop false  exit  then
        4 mod 0= if       false  exit  then
  false  ;

exit

  \ Alternative.

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

( set-date get-date )

create (date)  1 c,  1 c,  2016 ,
  \ day, month, year

: get-date  ( -- day month year )
  (date) c@
  [ (date) 1+ ] literal c@
  [ (date) 2+ ] literal @  ;

  \ doc{
  \
  \ get-date  ( -- day month year )
  \
  \ Get the current date. The default date is 2016-01-01. It
  \ can be changed with `set-date`. The date is not updated by
  \ the system.
  \
  \ }doc

: set-date  ( day month year -- )
  [ (date) 2+ ] literal !
  [ (date) 1+ ] literal c!
  (date) !  ;

  \ doc{
  \
  \ set-date  ( day month year -- )
  \
  \ Set the current date. The default date is 2016-01-01. It
  \ can be fetch with `get-date`. The date is not updated by
  \ the system.
  \
  \ }doc

( set-time get-time reset-time )

need frames@  need frames!  need m+  need alias  need ud*

: get-time  ( -- second minute hour )
  frames@ 50 um/mod nip s>d   ( sec . )
          60 um/mod s>d       ( sec min . )
          60 um/mod           ( sec min hour )  ;

  \ doc{
  \
  \ get-time  ( -- second minute hour )
  \
  \ Return the current time.
  \
  \ The system doesn't have an actual clock. The system frames
  \ counter is used instead. It is increased by the interrupts
  \ routine every 20th ms. The counter is a 24-bit value, so
  \ its maximum is $FFF ticks of 20 ms (5592 minutes, 93
  \ hours), then it starts again from zero.
  \
  \ }doc

: set-time  ( second minute hour -- )
  3600 um*  rot 60 * m+  rot m+  ( seconds )
  50. ud* frames!  ;

  \ doc{
  \
  \ set-time  ( second minute hour -- )
  \
  \ Set the current time. See `get-time`.
  \
  \ }doc

' reset-frames alias reset-time  ( -- )

  \ doc{
  \
  \ reset-time  ( -- )
  \
  \ Reset the current time to 00:00:00. See `get-time`.
  \
  \ }doc

( .time .system-time .date .system-date .time&date time&date )

  \ XXX TODO document

need get-time  need get-date

: .00  ( n -- )  s>d <# # # #> type  ;
: .0000  ( n -- )  s>d <# # # # # #> type  ;

: .time  ( second minute hour -- )
  .00 ':' emit .00 ':' emit .00  ;

: .system-time  ( -- )  get-time .time  ;

: .date  ( day month year -- )
  .0000 '-' emit .00 '-' emit .00  ;

: .system-date  ( -- )  get-date  .date  ;

: .time&date  ( second minute hour day month year -- )
  .date 'T' emit .time  ;

: time&date  ( -- second minute hour day month year )
  get-time get-date  ;

  \ doc{
  \
  \ time&date  ( -- second minute hour day month year )
  \
  \ Return the current time and date: second (0..59), minute
  \ (0..59), hour (0..23), day (1..31), month (1..12) and year
  \ (e.g., 2016).
  \
  \ See: `get-time`, `get-date`, `set-time`, `set-date`.
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-201 (FACILITY
  \ EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tool.debug.assert.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Versions of the `assert` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( assert assert= )

  \ Credit:
  \
  \ Taken from Brad Nelson's code:
  \ http://bradn123.github.io/literateforth/out/events.fs

: assert   ( n -- )    0= if  abort  then  ;
: assert=  ( a b -- )  = assert  ;

( assert( )

  \ Credit:
  \
  \ Code and documentation from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

  \ vim: filetype=soloforth
  \ tool.debug.tilde-tilde.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The `~~` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ~~ )

  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->


( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

  \ tool.debug.where.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `where`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr # " decimal dup . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

  \ vim: filetype=soloforth
  \ tool.decode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604171613

  \ -----------------------------------------------------------
  \ Description

  \ The `decode` utility.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions (volume 4, number 2, page 28, 1982-07).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History
  
  \ 2015-06-05: Copied from Afera. First changes to adapt it.
  \
  \ 2015-06-19: Added `?branch`.
  \
  \ 2015-07-23: Fix: `clit` was not included in the recognized
  \ special cases.
  \
  \ 2015-08-14: Fixed a recent bug: `sp0 sp!` was used when
  \ quitting, instead of `sp0 @ sp!`!
  \
  \ 2015-10-09: Fix: `slit` was missing from the special cases.
  \
  \ 2015-12-21: Fixed `decode-special` after the Forth-83
  \ version of `do loop`: now the branch address is after `do`
  \ or `?do`; also added `-branch` to it, in case it is already
  \ defined during the compilation of `decode-special`.
  \
  \ 2015-12-24: Start converting from ITC to DTC.
  \
  \ 2016-04-15: Fixed `decode-compile`, which had not been
  \ adapted from ITC to DTC.
  \
  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore. Updated the history from the
  \ development history of the project.

( decode )

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]
need recurse

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2* spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )  cell+ dup @ >name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof

-->

( decode )

    [defined] cslit [if]
      ['] cslit     of  decode-sliteral  endof
    [then]
    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof
    [then]

  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD <> if  drop false exit  then
  1+ @  docolon =  ;
  \ Is _cfa_ a colon definition?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the colon interpreter.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is _pfa_ a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @  ( pfa+n xt ) dup decode-end? 0=
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      >body ( pfa+n pfa' ) dup indent+  body>name .name
      key case  [char] q  of  sp0 @ sp! quit  endof
                      bl  of  drop            endof
                swap recurse  \ default
          endcase  decode-special  cell+  -1 decode-level +!
    repeat  indent >name .name
            \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined  ( nt | 0 )  dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

  \ vim: filetype=soloforth
  \ tool.dump.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604152121

  \ -----------------------------------------------------------
  \ Description

  \ Two versions of the `dump` tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-15: Fixed `dump` (the loop printed one byte more
  \ than requested). Improved `ascii-type` (now also characters
  \ above 127 are printed as dots, not masked).

( ascii-type )

: ascii-char?    ( c -- f )  128 <  ;
  \ XXX TODO -- char 127?

: control-char?  ( c -- f )  bl <  ;

: ascii-type  ( ca len -- )
  bounds ?do
    i c@ dup dup ascii-char? 0= swap control-char? or
    if  drop '.'  then  emit
  loop  ;

  \ doc{
  \
  \ ascii-type  ( ca len -- )
  \
  \ Type string _ca len_, replacing non-ASCII and control chars
  \ with a dot.
  \
  \ }doc

( dump )

need 16hex.  need ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: dump  ( ca len -- )
  8 2dup mod - + 8 / 1- 0
  ?do
    cr dup 16hex.
    8 0 do  i over + @ flip 16hex.  cell +loop
    \ 16 0 do  i over + c@ hexb.  loop  \ XXX OLD
    dup bs 8 ascii-type
    break-key? ?leave
  8 + loop  drop  ;
  \ Show the contents of _n_ bytes starting from _ca_.

( wdump )

need 16hex.

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  ?do
    i 4 mod 0= if  cr dup 16hex. space  then  \ show address
    dup @ 16hex. cell+
    break-key? ?leave
  loop  drop  ;

  \ vim: filetype=soloforth
  \ tool.history.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The command line history tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( history )

  \ XXX NEW -- upwards version, with back linked strings

  \ Every entry in the command line history has the following
  \ structure:
  \
  \ +0    : length byte
  \ +1..n : string
  \ +n+1  : address of +0

variable /history
  \ Size of the history space, where all strings are hold.

variable hp0
  \ Address of the bottom of the history.

variable hp
  \ The history pointer: Address of the free space in the
  \ history.

: used-history  ( -- u )  hp0 @ hp @  -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

: allot-history  ( +n -- )  hp +!  ;
  \ Reserve _+n_ bytes in the history.

: len>history  ( len -- +n )  1+ cell+  ;
  \ Convert a string length to space required to store it into
  \ the history.

: history>link  ( ca -- a )  cell-  ;
  \ Convert a history string address to its link field.

: history<history  ( ca1 -- ca2 )  history>link @s  ;
  \ Convert a history string address to the previous one.

: history>history  ( ca1 -- ca2 )
  system-bank count default-bank  + cell+  ;
  \ Convert a history string address to the next one.

: history>string  ( ca1 -- ca2 len2 )
  system-bank count save-string default-bank  ;  -->
  \ Copy a history string to a string in the circular string
  \ buffer.

( history )

variable browsed-history
  \ Address of the history string being browsed.

: oldest-history?  ( -- f )  browsed-history @ hp0 @ =  ;
  \ Are we browsing the oldest string of history?

: browse-older-history  ( -- )
  oldest-history? ?exit
  browsed-history @ history<history browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newest-history?  ( -- )
  browsed-history @ history>history hp @ =
  browsed-history @ hp @ =  or  ;
  \ Are we browsing the newest string of history?

: browse-newer-history  ( -- )
  newest-history? ?exit
  browsed-history @ history>history browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( n -- )
  dup /history !  $FFFF swap -
  dup hp0 !  dup hp !  browsed-history !  0 hp0 @ c!s  ;

1024 init-history  -->

( history )

need s=

: history-empty?  ( -- f )  used-history 0=  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

-->

( history )

: latest-history$  ( -- ca len )
  hp @ history<history history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: duplicated-history?  ( ca len -- f )  latest-history$ s=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: longer-history?  ( len -- f )
  len>history unused-history >  ;
  \ Is _len_ too long?

: history,  ( ca len -- )
  hp @ dup >r  over >r  ( ca len ca1 ) ( R: len ca1 -- )
  system-bank place default-bank
  r> 1+ allot-history  r> hp @ !s  cell allot-history  ;
  \ Add a string to the command line history.

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
  2dup duplicated-history? if  2drop exit  then
  dup longer-history? if  dup allocate-history throw  then
  history,  hp @ browsed-history !  ;
  \ Save string _ca len_ into the command line history,
  \ provided the string is valid (not empty, not duplicated).
  \ Make room if necessary. Then update the pointer to the
  \ browsed history.

-->

( history )

: browsed-history$  ( -- ca len )
  browsed-history @ history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: get-history   ( -- ca )  browsed-history$ set-accept  ;

: (history-up)    ( -- ca )
  get-history browse-older-history  ;
: (history-down)  ( -- ca )
  get-history browse-newer-history  ;

-->

( history )

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  ['] 2drop ['] >history defer!
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  ['] (>history) ['] >history defer!
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

-->

( history )

: .history  ( -- )
  hp0 @ begin  dup hp @ u<  while
          dup history>string type cr  history>history
        repeat  drop  ;

need dump

: hdump  ( ca len -- )  system-bank dump default-bank  ;

: .h  ( -- )  hp0 dup hp @ - hdump  ;

\ history-on

( history )  \ XXX OLD

  \ XXX OLD -- downwards version

  \ 2016-03-07: Start.

  \ Command line history is implemented as a list of counted
  \ string at the top of a memory bank. It's the same bank
  \ where name fields are stored. Name fields are stored
  \ upwards from the bottom of the 16-KiB space; command line
  \ history grows downwards from the top.
  \
  \ The length of the every counted string is used as a link
  \ field to the previous string.  The bottom of the list is
  \ the highest address of the bank, and it holds one byte, the
  \ length of the first string stored in the history, or zero
  \ when the history is empty.
  \
  \ There's a maximum space usable for the history. When
  \ there's no free space left to store a new string, oldest
  \ strings are removed as necessary.

  \ 2016-03-08: XXX TODO -- Rewrite, simpler: grow upwards.

variable hp
  \ Pointer to the most recent string in the history.

$FFFF constant hp0
  \ Pointer to the bottom of the history, which contains a copy
  \ of the length of the first string.

variable /history  1024 /history !
  \ Size of the history space, where all strings are hold.

: init-hp0  ( -- )  0 hp0 c!s  ;

: history-bounds  ( -- ca1 ca2 )  hp0 hp @  ;
  \ Return bottom of history _a1_ and address of the latest
  \ string _ca2:

: used-history  ( -- u )  history-bounds -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

-->

( history )  \ XXX OLD

variable previously-browsed-history
  \ Address of the history string previously browsed.

variable currently-browsed-history
  \ Address of the history string being browsed.

: older-history  ( -- )
  currently-browsed-history @ dup previously-browsed-history !
  system-bank count default-bank +
  currently-browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newer-history  ( -- )
  currently-browsed-history @
  previously-browsed-history @ currently-browsed-history !
  currently-browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( -- )
  init-hp0  hp0 dup hp ! currently-browsed-history !  ;

init-history  -->

( history )  \ XXX OLD

need s=

: allot-history  ( +n -- )  negate hp +!  ;
  \ Reserve _+n_ bytes in the history.

: history-empty?  ( -- f )  history-bounds =  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

: latest-history  ( -- ca len )
  system-bank  hp @ count  save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.
  \ XXX OLD

: browsed-history  ( -- ca len )
  currently-browsed-history @
  system-bank  count save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: (history>)  ( -- ca len )
  browsed-history  dup 0= ?exit
                   dup 1+ negate allot-history
  history-empty? if  init-hp0  then  ;  -->
  \ Get a string from the command line history, and return it
  \ as _ca len_ in the circular string buffer.
  \ XXX TODO -- adapt the browser variables

( history )  \ XXX OLD

: duplicated-history?  ( ca len -- f )  latest-history s=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: too-long-for-history?  ( len -- f )  1+ unused-history > ;

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
    \ If string is empty, do nothing.
  history-empty? if  dup hp0 c!s  then
    \ If history is empty, init its bottom with the length
    \ of the string.
  2dup duplicated-history? if  2drop exit  then
  dup too-long-for-history?
  if  dup allocate-history throw  then
    \ If there's no space left, allocate it.
  dup 1+ allot-history
  hp @ dup system-bank place default-bank
           currently-browsed-history !  ;
  \ Save string _ca len_ into the command line history.

-->

( history )  \ XXX OLD

: get-history   ( -- ca )  browsed-history set-accept  ;
: (history-up)    ( -- ca )  get-history older-history  ;
: (history-down)  ( -- ca )  get-history newer-history  ;

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  \ XXX OLD
  \ ['] 2drop ['] >history defer!
  \ ['] s""   ['] history> defer!  history off  ;
  \ XXX NEW
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  \ XXX OLD
  \ ['] (>history) ['] >history defer!
  \ ['] (history>) ['] history> defer!  history on  ;
  \ XXX NEW
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

: .history  ( -- )
  hp @  begin  dup hp0 <  while
          system-bank count 2dup type cr default-bank  +
        repeat  drop  ;

\ history-on

  \ vim: filetype=soloforth
  \ tool.list.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604021142

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap ?do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap ?do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap ?do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

  \ vim: filetype=soloforth
  \ tool.list.order.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111513

  \ -----------------------------------------------------------
  \ Description

  \ `order`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-11: Documented.

( .current .context order )

need wid>name  need get-order

: .wid  ( wid -- )
  space dup wid>name ?dup if  .name drop exit  then  0 u.r  ;

  \ doc{
  \
  \ .wid  ( wid -- )
  \
  \ Display the id of the word list _wid_: it can be an
  \ associated name or the number _wid_.
  \
  \ }doc

: .current  ( -- )  get-current .wid  ;

  \ doc{
  \
  \ .current  ( -- )
  \
  \ Display the word list into which new definitions will be
  \ placed.
  \
  \ }doc

: .context  ( -- )
  get-order begin  ?dup  while  swap .wid 1-  repeat  ;

  \ doc{
  \
  \ .context  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched.
  \
  \ }doc

: order  ( -- )
  cr ." Search: " .context cr ." Define: " .current  ;

  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

  \ doc{
  \
  \ order  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched. Also
  \ display the word list into which new definitions will be
  \ placed.
  \
  \ Origin: Forth-2012 (SEARCH EXT).

  \ }doc

  \ vim: filetype=soloforth
  \ tool.list.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604122314

  \ -----------------------------------------------------------
  \ Description

  \ Words to examine the stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.
  \
  \ 2016-04-12: Divided into 3 blocks, in order to reuse
  \ `.depth` for the floating point `.fs`. Fixed the check:
  \ the stacks are not printed when their depth is negative.

( .depth )


: .depth  ( n -- )  [char] < emit 0 .r [char] > emit space  ;

( .s )

  \ Credit:
  \ Code from Afera. Original algorithm from v.Forth.

need .depth

: .s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ .  [ cell negate ] literal +loop
  then  ;

( u.s )

need .depth

: u.s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ u.  [ cell negate ] literal +loop
  then  ;

  \ vim: filetype=soloforth
  \ tool.list.wordlists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `wordlists`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( wordlists )

: wordlists  ( -- )
  voc-link
  begin  @ ?dup  while  dup .wid wid>link  repeat  ;
  \ List all wordlists.
  \ XXX FIXME -- prints only one

  \ tool.list.words.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to list words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( more-words? )

: more-words?  ( -- f )  dup 0<>  nuf? 0= and  ;
  \ A common factor of `words` and `words-like`.

( words )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need trail  need name>link  need tab  need nuf?
need more-words?

: words  ( -- )
  trail
  begin  more-words?  while
    dup .name tab  name>link @s
  repeat drop  ;

( wordlist-words )

need words

: wordlist-words  ( wid -- )  >order  words  previous  ;

( words-like )

  \ Credit:
  \
  \ Code adapted from pForth.

need trail  need name>link  need tab  need nuf?
need more-words?

[defined] contains
?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
   \ Does the string _ca1 len1_ contains the string _ca2
   \ len2?_

: words-like  ( "name" -- )
  \ Print all words (from the `context` vocabulary) containing a substring.
  parse-name 2dup uppers trail  ( ca len nt )
  begin  more-words?  while
    dup >r
    name>string 2over contains if  r@ .name tab  then
    r> name>link @s
  repeat drop 2drop  ;

  \ vim: filetype=soloforth
  \ tool.marker.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `marker` and `anew`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( possibly anew )

need marker

  \ Credit:
  \
  \ Code adapted from Wil Baden.

  \ XXX TODO test

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ;

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

( marker ) \ second approach

  \ XXX UNDER DEVELOPMENT

: marker,  ( -- a )
  here  voc-link @ dup ,
  begin
    dup cell- @  ( a nt ) swap @
  dup 0= until  drop
  np@ ,  ;
  \ Compile the data required by a a marker and return its
  \ address.

: unmarker  ( a -- )
  ;
  \ Restore the data preserved at _a_ by a marker word.

: marker  ( "name" -- )
  marker, create ,  does>  ( -- ) ( pfa )  @ unmarker  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT

  \ 2016-01-01: example taken from m3forth
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: MARKER ( "name" -- )
  here
  get-current ,
  get-order dup , 0 ?do dup , @ , loop
  create ,
  does> @ dup \ only
  dup @ set-current cell+
  dup @ >r r@ cells 2* + 1 cells - r@ 0
  ?do dup dup @ swap cell+ @ over ! swap 2 cells - loop
  drop r> set-order
  there
  ;

( marker )  \ first approach

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nt0..ntn | nt )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nt0..ntn | nt -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nt1..ntn2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ there  ;

-->

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT
  \ Code from eForth, for reference.

 \ : _MARKER ( -- ) ( R: dfa -- ) \ ???
 \   R> 2@ ( * ) DUP @ FOLLOWER !  DUP CONTEXT
 \   BEGIN >R CELL+ DUP @ DUP R@ ! WHILE R> CELL+ REPEAT ( search order )
 \   CELL+ DUP 2@ CURRENT 2!  CELL+ DUP @ ( cur wid & head )
 \   BEGIN >R  CELL+ DUP @ R@ !  R> CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   R> 2DROP ( * ) DP 2! ; COMPILE-ONLY

 \ : MARKER ( "name" -- ) \ ???
 \   ALIGN DP 2@ ( * ) FOLLOWER @ ,  CONTEXT
 \   BEGIN DUP @ DUP , WHILE CELL+ REPEAT  DROP ( search order )
 \   CURRENT 2@ , DUP , ( cur wid & head )
 \   BEGIN DUP @ , CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   ['] _MARKER : REVEAL COMPILE, ( * ) , , ;

  \ vim: filetype=soloforth
  \ tool.turnkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to save the system.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( extend size system turnkey )

  \ XXX WARNING -- Since name fields are saved in a memory
  \ bank, the best way to save a modified Forth system is to
  \ make a snapshot with the ZX Spectrum emulator; otherwise a
  \ multipart saving and loading would be needed.  Anyway,
  \ these words are meant to save a Forth program that does not
  \ need to search the dictionary.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )
  latest $08 +origin !  \ top most word in `forth` vocabulary
  here $1F +origin !   \ `dp` init value
  np@ $26 +origin !   \ `np` init value
  voc-link @ $0C +origin !  ;  \ `voc-link` init value

  \ doc{
  \
  \ extend  ( -- )
  \
  \ }doc
  \
  \ Change the `cold` start parameters to extend the system to
  \ its current state.

: size  ( -- u )  here 0 +origin -  ;

  \ doc{
  \
  \ size  ( -- u )
  \
  \ Size of the system.
  \
  \ }doc

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ doc{
  \
  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.
  \
  \ }doc

: turnkey  ( xt -- a len )  boot defer! system  ;

  \ doc{
  \
  \ turnkey  ( xt -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given xt after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604171613

  \ -----------------------------------------------------------
  \ Description

  \ Words related to word lists.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore.

( wid>link wid>name named-wid wid>vocabulary )

  \ XXX TODO -- test

need alias

' cell+ alias wid>link  ( wid -- a )

: (wid>name)  ( wid -- a )  [ 2 cells ] literal +  ;

  \ doc{
  \
  \ (wid>name)  ( wid -- a )
  \
  \ Return the address _a_ which holds the _nt_ of _wid_ (or
  \ zero if the word list has no associated name).
  \
  \ }doc

: wid>name  ( wid -- nt|0 )  (wid>name) @  ;

  \ doc{
  \
  \ wid>name  ( wid -- nt|0 )
  \
  \ Return the _nt_ of _wid_ (or zero if the word list has no
  \ associated name).
  \
  \ }doc

: named-wid  ( wid -- )  (wid>name) latest swap !  ;

  \ doc{
  \
  \ named-wid ( wid -- )
  \
  \ Associate the latest name to _wid_.
  \
  \ }doc

: wid>vocabulary  ( wid "name" -- )
  create dup , named-wid
  does>  ( -- )  ( pfa )  @ context !  ;

  \ doc{
  \
  \ wid>vocabulary  ( wid "name" -- )
  \
  \ Create a vocabulary "name" for the _wid_ word list.
  \
  \ }doc

( get-order order@ )

  \ Credit: Code from eForth.

need recurse

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@  ;

( wid-of )

  \ Credit:
  \
  \ Adapted from eForth's `widof`.

: wid-of  ( "name" -- wid )  ' >body  ;
  \ Return the _wid_ of vocabulary "name".

( swap-current trail )

[unneeded] trail
?\ : trail  ( -- nt )  context @ @  ;

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the
  \ `context` vocabulary.
  \
  \ }doc

[unneeded] swap-current ?\ exit
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ;

  \ Credit:
  \
  \ Idea from lpForth.

( find-name-in find )

: find-name-in  ( ca len wid -- nt | 0 )  @ find-name-from  ;

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in
  \ word list _wid_. If the definition is found, return its
  \ _nt_, else return zero.
  \
  \ The search is case-sensitive.  // XXX TODO -- confirm
  \
  \ }doc

: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ;

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

  \ vim: filetype=soloforth
