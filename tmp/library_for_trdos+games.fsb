  \ 000.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Block 0 of the library, which by convention can not be
  \ loaded, and which is used only for credits and information.

( Solo Forth library )

\ http://programandala.net/en.program.solo_forth.html

  \ vim: filetype=soloforth
  \ 001.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111423

  \ -----------------------------------------------------------
  \ Description

  \ Block 1 of the library, which is used to load the user
  \ application. By default it loads block 2, which contains
  \ the `need` utility.

(  )

2 load

  \ XXX TMP -- for debugging `marker`
  \ need wdump  need save-voc-links

  \ XXX TMP -- for debugging `associative-list`
  \ need associative-list
  \ exit

  \ XXX TMP -- for debugging the floating point ROM
  \ implementation
  \ need f0 need .fs
  \ need f>s
  \ need ftuck
  \ need fmax  need fmin
  \ need --fp-rom--
  \ f1 f0 fpi2/ f1 f1
  \ need f=  need f<
  \ f1 f0 f1 f0 f1 f0
  \ 100 s>f  200 s>f  300 s>f

  \ XXX TMP -- for debugging the G+DOS support
  \ need plusd-in  need plusd-in,

  \ XXX TMP -- for debugging the tape support
  \ need write-tape-file
  \ : savescr 16384 6912 s" screen" write-tape-file  ;
  \ : savetxt s" TEXT" s" txt" write-tape-file  ;
  \ hex  ' (write-tape-file) u.

  \ XXX TMP --
  \ need 8-bit-random-pix-benchmarks  exit

  \ XXX TMP --
  \ need wordlist-words  need order
  \ need bench{  need indexer
  \ : iw  ( -- )  index-wordlist wordlist-words  ;

  \ vim: filetype=soloforth
  \ 002.need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201606011726

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the library dependencies.
  \ It must be at block 2 of the library.
  \
  \ The utility consists of words `need`, `needed`, `reneed`
  \ and `reneeded`. All of them are deferred words. Their
  \ default behaviour is set by `set-located-need`: locate the
  \ required word searching the blocks of the library.
  \
  \ An alternative faster behaviour is provided by the
  \ `indexer` tool, in other module.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06: First version, partly based on code from Afera.
  \
  \ 2015-06-25: Fix: `require` and `locate` needed to save the
  \ parsed words to the circular string buffer.
  \
  \ 2015-09-13: Rename `require` to `need`, and all related
  \ words accordingly.  The reason is `require` and `required`
  \ are standard words (in Forth-94 and Forth-2012), and should
  \ not be used for different purposes.
  \
  \ 2015-10-05: Fix `needed`. The trailing and leading spaces
  \ of the string, sometimes used to prevent name clashes, had
  \ to be removed before `undefined?`. `-leading` has to be
  \ moved to the kernel.
  \
  \ 2015-10-16: Add `[needed]`.  It allows selective
  \ compilation depending on the word specified by `need` or
  \ `needed`.  Improve `located`: now the string searched for
  \ is delimited with spaces. This prevents name clashes and
  \ makes it unnecessary to add the spaces explicitly in risky
  \ cases.
  \
  \ 2015-10-25: Improve `need` and `needed` a bit.
  \
  \ 2016-04-02: Factor `new-needed-word` from `needed`.  This
  \ change was needed for `indexer`.
  \
  \ 2016-04-03: Make `need` and related words deferred. Factor
  \ `new-needed-word` from `needed`. These changes were needed
  \ for `indexer`.
  \
  \ 2016-04-26: Improve `located`: when the user press the
  \ break key, throw exception #-28 ("user interrupt");
  \ formerly the ordinary #-268 ("required, but not located")
  \ was thrown by the calling word.
  \
  \ 2016-05-06: Make `from` and `locate` optional. Compact the
  \ blocks.
  \
  \ 2016-05-07: Improve documentation. Fix the word shown when
  \ `?locate` throws an error.
  \
  \ 2016-05-10: Fix a harmless bug: `locate-reneed` called the
  \ deferred `reneeded` instead of `locate-reneeded`.
  \
  \ 2016-05-31: Fix block header.
  \
  \ 2016-06-01: Fix `need-here`, which left the string on the
  \ stack.

( contains delimited located )

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does string _ca1 len1_ contain string _ca2 len2_?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited  ( ca1 len1 -- ca2 len2 )
  \
  \ Add one leading space and one trailing space to string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over contains
      if  2drop i unloop exit  then  break-key? #-28 ?throw
  loop  2drop 0  ;
  \ Note: Error #-28 is "user interrupt".

  \ doc{
  \
  \ located  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

2variable needed-word  -->

( ?located reneeded reneed needed-word [needed] [unneeded] )

: ?located  ( n -- )
  dup ?exit  needed-word 2@ parsed-name 2! #-268 throw  ;

  \ doc{
  \
  \ ?located ( n -- )
  \
  \ If _n_ is zero, throw an exception -268 ("required, but not
  \ located").
  \
  \ }doc

defer reneeded  ( ca len -- )

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Load the first block whose header contains the string _ca
  \ len_ (surrounded by spaces).  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneeded`.
  \
  \ }doc

: locate-reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ locate-reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

defer reneed  ( "name" -- )

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Load the first block whose header contains "name" (but
  \ surrounded by spaces).
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneed`.
  \
  \ }doc

: locate-reneed  ( "name" -- )
  parse-name save-string locate-reneeded  ;

  \ doc{
  \
  \ locate-reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name" (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: [needed]  ( "name" -- f )
  parse-name needed-word 2@ 2dup or
  if  compare 0= exit  then  2drop 2drop true  ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return true.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _true_, else return _false_.
  \
  \ }doc

: [unneeded]  ( "name" -- f )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return false.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _false_, else return _true_.
  \
  \ }doc

: new-needed-word  ( ca len -- ca' len' )
  -trailing -leading save-string 2dup needed-word 2!  ;

  \ doc{
  \
  \ new-needed-word  ( ca1 len -- ca2 len' )
  \
  \ Remove trailing and leading spaces from the word _ca1 len_,
  \ which is the parameter of the latest `need` `needed`,
  \ `reneed` or `reneeded`, store it in the circular string
  \ buffer and return it as _ca2 len'_ for further processing.
  \
  \ }doc

-->

( needed need )

defer needed  ( ca len -- )

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, load the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces).  If not found, throw an exception
  \ -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-needed`.
  \
  \ }doc

: locate-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ locate-needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

defer need  ( "name" -- )

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-need`.
  \
  \ }doc

: locate-need  ( "name" -- )  parse-name locate-needed  ;

  \ doc{
  \
  \ locate-need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is the default behaviour of the deferred word `need`.
  \
  \ }doc

: set-located-need  ( -- )
  ['] locate-reneeded ['] reneeded  defer!
  ['] locate-reneed   ['] reneed    defer!
  ['] locate-need     ['] need      defer!
  ['] locate-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-located-need  ( -- )
  \
  \ Set the default behaviour of `need`, `needed`, `reneed` and
  \ `reneeded`: Use `locate` for searching the library.
  \
  \ The alternative, provided by the optional `indexer` tool,
  \ is set by `set-indexed-need`.
  \
  \ }doc

set-located-need

blk @ 1+ dup default-first-locatable !  first-locatable !

( locate from need-here )

[unneeded] locate [unneeded] from and
?\ : locate  ( "name" -- n )  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- n )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

[unneeded] from
?\ : from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268
  \ ("required, but not located").
  \
  \ This word is intended to prevent undesired name clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker.
  \
  \ Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures==  need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

[unneeded] need-here ?exit

: need-here  ( "name" -- )
  parse-name needed-word 2@ 2>r
  new-needed-word  2dup needed-word 2! undefined?
  if  blk @ load  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ need-here  ( "name" -- )
  \
  \ If "name" is not a word found in the current search order,
  \ load the current block.
  \
  \ This is a faster alternative to `need`, when the needed
  \ word is in the same block, and conditional compilation is
  \ used with `?\`, `?(` or `[if]`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ assembler.macro.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111350

  \ -----------------------------------------------------------
  \ Description

  \ `macro` and `endm`, compatible with any assembler.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2016-04-11: Extracted from the assemblers `z80-asm` and
  \ `z80-asm,`. The code was identical in both of them and it
  \ can be useful without an assembler.

( macro )

need get-order

get-order get-current

only forth definitions  also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

set-current  set-order

  \ vim: filetype=soloforth

  \ assembler.tools.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604091523

  \ -----------------------------------------------------------
  \ Description

  \ Z80 assembler tools, independent from the actual assembler.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( << >> )

  \ For dumping assembled code to screen.

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

  \ vim: filetype=soloforth

  \ assembler.z80-asm-comma.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.

  \ Last modified: 201605092127

  \ -----------------------------------------------------------
  \ Description

  \ A alternative Z80 assembler, called `z80-asm,`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015-12-25: First changes:
  \
  \ 1. "," suffixes in Z80 instructions; 2. one single set of
  \ conditions; 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module.  Fixed `execute-hl`,
  \ then renamed it and `call-xt` with a trailing comma, to
  \ avoid loading them instead of the versions written for the
  \ first assembler.
  \
  \ 2016-05-08:
  \ - Rename conditions to the original names plus "?".
  \ - Rename `|mark` to `>amark`.
  \ - Rename `|resolve` to `>aresolve`.
  \ - Rename "resmark"-like words to "rmark"-like.
  \ - Rename "resresolve"-like words to "rresolve"-like.
  \ - Remove "retCOND"-like and "callCOND"-like macros.
  \ - Compact the blocks.
  \ - Add `?jp` and `?jr` for conditional jumps.
  \ - Remove "jpCOND"-like and "jrCOND"-like opcodes.
  \ - Changed the opcode values of the conditions.
  \ - Rename `?page` to `?jr-range`.
  \ - Rename `clr,` to `clrp,`; add new `clr,`.
  \
  \ 2016-05-09: Save and restore the compile word list, the
  \ current radix and the search order.

  \ -------------------------------------------------------------
  \ XXX TODO

  \ - Combine changes 2..4 with the previous version.
  \ - Make absolute-jump control structures optional.
  \ - Use `get-order` at the start and `set-order` at the end.
  \ - Document.

( z80-asm, )

get-current forth-wordlist set-current

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions base @ hex

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?jr-range  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  create c, does>  ( -- ) ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- ) ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- ) ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- ) create , does>  ( -- ) ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: (jr,)  ( a op -- )  c, here 1+ - ?jr-range c,  ;
  \ Compile a relative jump _op_ to absolute address _a_.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- ) ( a pfa )  c@ (jr,)  ;
  \ Relative jumps.

-->

( z80-asm, )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 22 m5 sthl,
27 m1 daa, 2A m5 fthl, 2F m1 cpl, 32 m5 sta, 37 m1 scf, 3A m5
fta, 3F m1 ccf, 76 m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98
m2 sbc, B8 m2 cp, C1 m3 pop, C3 m5 jp, C5 m3 push, C6 m4 add#,
C7 m2 rst, C9 m1 ret, CD m5 call, CE m4 adc#, D3 m4 out, 41 m3
outbc, D6 m4 sub#, D9 m1 exx, DB m4 in, 40 m3 inbc, 0DE m4
sbc#, E3 m1 exsp, E6 m4 and#, E9 m1 jphl, EB m1 exde, EE m4
xor#, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FB m1 ei, FE m4 cp#, 00
m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6 rr, 20 m6 sla, 28 m6 sra, 38
m6 srl,  40 m7 bit, 80 m7 res, C0 m7 set, B0ED m8 ldir, B8ED m8
lddr, 44ED m8 neg, 57ED m8 ldai, 47ED m8 ldia, 56ED m8 im1 5EED
m8 im2 B1ED m8 cpir, 6FED m8 rld, A0 m2 and, B0 m2 or,  A8 m2
xor, -->

( z80-asm, )

  \ Opcodes

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ld#,  ;
  \ Macro to clear an 8-bit register with zero.
: clrp,  ( rp -- )  0 swap ldp#,  ;
  \ Macro to clear a 16-bit register with zero.
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;
  \ Macro, 16-bit register load.
: subp,  ( rp -- )  a and, sbcp,  ;
  \ Macro, 16-bit subtract.
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;  -->
  \ Macro to test 16-bit register for zero.

( z80-asm, )

  \ ZX Spectrum specific

CF m4 hook,  \ rst $08
D7 m1 prt,   \ rst $16

  \ Index register opcodes

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, )

  \ Conditions

  \ Conditions are Z80 opcodes for the required absolute jump
  \ instruction.

CA constant z?  C2 constant nz? DA constant c? D2 constant nc?
EA constant pe? E2 constant po? FA constant m? F2 constant p?

: jp>jr  ( op1 -- op2 )  dup nc? > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

: ?ret,  ( op -- )  2- c,  ;
  \ Conditional ret

: ?call,  ( a op -- )  2+ c, ,  ;
  \ Conditional call

: ?jp,  ( a op -- )  c, ,  ;
  \ Conditional absolute jump

: ?jr,  ( a op -- )  jp>jr (jr,)  ;
  \ Conditional relative jump

  \ Control structures with relative jumps

: >rmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.

: rresolve  ( orig dest -- )  1- over - ?jr-range swap c!  ;
  \ Resolve a relative branch.

: >rresolve  ( orig -- )  here rresolve  ;
  \ Resolve a forward relative branch.

: <rresolve  ( dest -- )  here 1- swap rresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, )

  \ Control structures with relative jumps

: inverse-cond  ( op1 -- op2 )  8 xor  ;
  \ Convert a condition flag (actually, an absolute jump
  \ opcode) to its opposite.
  \
  \ Examples: `c?` to `nc?` (jpc to jpnc); nz? to z? (jpnz to
  \ jpz); etc.

: rahead  ( -- orig  )  18 , >rmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.
  \ Note: $18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr inverse-cond , >rmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >rresolve  ;

: relse  ( orig cs-id -- cs-id )
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note: $18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <rresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`
  \ Note: $18 is the opcode of `jr`.

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`
  \ Note: $10 is the Z80 opcode for `djnz`.

( z80-asm, )

  \ Control structures with absolute jumps

: aif  (  op -- orig cs-id )  inverse-cond c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ Note: $C3 is the opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.
  \ Note: $C3 is the opcode of `jp`

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: >amark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: >aresolve  ( a -- )  >amark swap !  ;
  \ Resolve an absolute forward reference.

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

base ! set-current previous

( execute-hl, call-xt, )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm,  need macro

macro execute-hl,  ( -- )
  0000 bc stp,  >amark      \ save the Forth IP
  0000 bc ldp#, >amark      \ point IP to phony_compiled_word
  jphl,                     \ execute the xt in HL
  >resolve                  \ phony_compiled_word
  here cell+ ,              \ point to the phony xt following
  0000 bc ldp#  >aresolve   \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt,  ( xt -- )
  hl ldp#,  execute-hl,
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ assembler.z80-asm.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605092127

  \ -----------------------------------------------------------
  \ Description

  \ A Z80 assembler called `z80-asm`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015: Adapted from Afera. Main development.
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module. Fixed `execute-hl`.
  \
  \ 2016-05-09: Save and restore the compile word list, the
  \ current radix and the search order.

( z80-asm )

  \ XXX TODO -- `get-order` here and `set-order` at the end.

get-current forth-wordlist set-current

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions base @ hex

-->

( z80-asm )

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm )

  \ Opcodes

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm )

  \ Index register opcodes

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm )

  \ Conditional ret and call

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm )

  \ Control structures with relative jumps

  \ XXX TODO -- document
  \ XXX TODO -- rename `rel...` to `r...`

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm )

  \ Control structures with absolute jumps

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm )

  \ Last opcodes and macros

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

base ! set-current previous

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm  need macro

macro execute-hl  ( -- )
  0000 bc stp  |mark  \ save the Forth IP
  0000 bc ldp# |mark  \ point IP to phony_compiled_word
  jphl          \ execute the xt in HL
  >resolve \ phony_compiled_word
  here cell+ ,      \ point to the phony xt following
  0000 bc ldp#  |resolve  \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt  ( xt -- )
  hl ldp#  execute-hl
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ benchmark.byte-magazine.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ BYTE Magazine benchmark.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( do-prime )

  \ Credit:
  \
  \ Eratosthenes Sieve Prime Number program in Forth
  \ by Jim Gilbreath, BYTE Magazine, 1981-09, page 190.

forth definitions decimal

8190 constant size  variable flags  size allot

: do-prime  ( -- )
  flags size 1 fill
  0 size 0
  do flags i + c@
     if i dup + 3 + dup i +
          begin   dup size <
          while   0 over flags + c! over +
          repeat  drop drop 1+
     then
  loop  .  ." primes "  ;

( byte-magazine-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).
  \
  \ 2015-12-24. Modified: no printing.

need bench{

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop
  \ u. ." PRIMES" cr  \ XXX OLD
  drop  \ XXX NEW
  ;  -->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( n -- )
  cr dup u. ." iterations..." cr
  bench{ 0 ?do  do-prime  loop }bench.  ;

  cr
  \  <------------------------------>
  .( To run the BYTE Magazine) cr
  .( benchmark type:) cr
  .(   n byte-magazine-benchmark) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 1000 iterations.) cr


  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       -----         -----
  \ 00010  6397          5216
  \ 00100 63970 (1.00)  52159 (0.81)

  \ 2016-03-16
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 00001                    517
  \ 00010                   5164
  \ 00100 52161 (1.00)     51635 (0.98)
  \
  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ benchmark.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Generic benchmarking tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in the file <development_benchmarks.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( bench{ }bench }bench. bench. benched )

  \ Credit:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

( all-benchmarks )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

  \ vim: filetype=soloforth
  \ benchmark.interface-age.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Interface-Age benchmark.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( interface-age-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ Interface Age Benchmark, 1985-11-16.  This is the Interface
  \ Age benchmark program described in Appendix D of the
  \ forthCMP Manual.

  \ 2015-12-24. Modified: no printing.

need bench{  need 2/

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 ?do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop
    \ if  .  else  drop  then  \ XXX OLD
    2drop  \ XXX NEW
  loop  drop  ;  -->

( interface-age-benchmark )

: interface-age-benchmark  ( n -- )
  bench{ (interface-age-benchmark) }bench.  ;

  cr
  \  <------------------------------>
  .( To run the interface age) cr
  .( benchmark type:) cr
  .(   n interface-age-benchmark  ) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 5000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       ------------  ------------
  \ 05000 80091 (1.00)  72445 (0.90)

  \ 2016-03-16 XXX TODO --
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 05000 72445 (1.00)     71914 (0.99)
  \
  \ [1] Changed only in the kernel.

( Interface Age Benchmark program )

  \ XXX TODO -- test

  \ Forth Dimensions (volume 2, number 4, page 112)

: bench  ( -- )
  dup 2 / 1+ swap ." Starting " cr
  1 do dup i 1 rot
    2 do drop dup i /mod
      dup 0= if  drop drop 1 leave
      else  1 = if drop 1
            else  dup 0 > if  drop 1
                  else  0= if  0 leave  then
                  then
            then
      then
    loop
    if  4 .r  else  drop  then
  loop  drop cr ." Finished " ;

  \ vim: filetype=soloforth
  \ benchmark.vector-loop.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Vector-Loop benchmark.

  \ -----------------------------------------------------------
  \ Authors

  \ M. Edward Borasky, 1995-07-30; code published on Forth
  \ Dimensions (volume 17, number 4, page 11, 1995-11).

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( vector-loop-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench{

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !
     1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop3 ( -- ) \ vector divide
  0 begin
    dup vec1 @ over vec2 @ / over vec3 !
    1+ dup vsize =
  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench{ 0 begin  loop0 1+ dup reps =  until  drop }bench.
  ." Vector No-Op" cr  ;

: bench1 ( -- ) \ benchmark loop1
  bench{ 0 begin  loop1 1+ dup reps =  until  drop }bench.
  ." Vector +    " cr  ;

: bench2 ( -- ) \ benchmark loop2
  bench{ 0 begin  loop2 1+ dup reps =  until  drop }bench.
  ." Vector *    " cr  ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench{ 0 begin  loop3 1+ dup reps =  until  drop }bench.
  ." Vector /    " cr  ;

: bench4 ( -- ) \ benchmark loop4
  bench{ 0 begin  loop4 1+ dup reps =  until  drop }bench.
  ." Vector */   " cr  ;

: vector-loop-benchmarks  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  cr
  \  <------------------------------>
  .( To run the vector loop) cr
  .( benchmarks type:) cr
  .(   vector-loop-benchmarks ) cr

  \ 2015-12-24
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               ITC           DTC
  \               ------        -------------
  \ Vector noop    10919 (1.0)    9033 (0.82)
  \ Vector +       58650 (1.0)   47462 (0.80)
  \ Vector *      107770 (1.0)   91611 (0.85)
  \ Vector /      149002 (1.0)  127495 (0.85)
  \ Vector */     178854 (1.0)  154480 (0.86)

  \ 2016-03-16
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               jp pushhl        push hl + jp (ix) [1]
  \               ------------     ---------------------
  \ Vector noop     9033 (1.0)       8943 (0.99)
  \ Vector +       47461 (1.0)      47177 (0.99)
  \ Vector *       91920 (1.0)      91153 (0.99)
  \ Vector /      127496 (1.0)     126783 (0.99)
  \ Vector */     155192 (1.0)     154364 (0.99)

  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610111953

  \ -----------------------------------------------------------
  \ Description

  \ Words related to disk blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-29: Add `lineload` and `lineblock>source`.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-13: Add `load-app`.
  \ 2016-10-04: Start a new version of `load-app`,
  \ compatible with `[if]` and other words that use `refill`.
  \ 2016-10-11: Finish the new version of `load-app`,
  \ compatible with `[if]` and other words that use `refill`.

( ?--> update flush thru )

[unneeded] ?-->
?\ : ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "ccc<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credit:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ Origin: Pygmy Forth.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loaded or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credit:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ Origin: MMSFORTH.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;

[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line lineblock>source lineload load-app )

[unneeded] .line
?\ : .line  ( n1 n2 -- )  line>string -trailing type  ;  exit

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

[unneeded] lineblock>source [unneeded] lineload and
?\ : lineblock>source  ( n1 n2 -- )  blk !  c/l * >in !  ;

  \ doc{
  \
  \ lineblock>source  ( n1 n2 -- )
  \
  \ Set block _n2_ as the current source, starting from its
  \ line _n1_.
  \
  \ }doc

need ?( [unneeded] lineload ?(

: lineload  ( n1 n2 -- )
  dup 0= #-259 ?throw
  nest-source lineblock>source interpret unnest-source  ; ?)

  \ doc{
  \
  \ lineload  ( n1 n2 -- )
  \
  \ Begin interpretation at line _n1_ of block _n2_.
  \
  \ Origin: Forth-83 (Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] load-app ?( need locate  variable loading-app

  \ doc{
  \
  \ loading-app ( -- a )
  \
  \ A variable that holds a flag: Is an application being
  \ loaded?  This flag is modified by `load-app` and `end-app`.
  \
  \ See `load-app`, `end-app`.
  \
  \ }doc

: end-app  ( -- )  loading-app off  ;  end-app

  \ doc{
  \
  \ end-app  ( -- )
  \
  \ End a app of the library.
  \
  \ See `load-app`, `loading-app`.
  \
  \ }doc

  \ : load-app  ( "name" -- )
  \   loading-app on
  \   blocks locate ?do   loading-app @ 0= ?leave  i load
  \                 loop  end-app  ; ?)
  \   \ XXX OLD -- incompatible with words that use `refill`

: load-app  ( "name" -- )
  loading-app on  locate blk !
  begin   loading-app @  blk @ blocks <  and  while
          blk @ (load) 1 blk +!
  repeat  end-app  ; ?)

  \ doc{
  \
  \ load-app  ( "name" -- )
  \
  \ Load an application from the blocks disk.  An application
  \ is a set of blocks that are loaded as a whole. They don't
  \ have block headers except the first one, which contains
  \ "name", and therefore they don't have internal requisites.
  \ Applications dont't need `-->` or any other word to change
  \ the loading: The loading starts from the first block of the
  \ disk that has "name" in its header, and continues until the
  \ last block of the disk or until `end-app` is executed.
  \
  \ See `end-app`, `loading-app`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ blocks.indexer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- It works fine, but the indexed
  \ words (all words from the library) fill the memory bank.
  \ The solution is a configurable system bank.

  \ Last modified: 201608051257

  \ -----------------------------------------------------------
  \ Description

  \ A blocks indexer that improves the default behaviour of
  \ `need`, `needed`, `reneed` and `reneeded`: It creates a
  \ word list from the names that are on the index (header)
  \ line of every searchable block, ignoring duplicates.  These
  \ words will load the block they belong to. This way, after
  \ indexing all of the disk blocks only once, `need` will
  \ search the word list and execute the word found, instead of
  \ searching all of the blocks every time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-02: Start.
  \
  \ 2016-04-03: First working version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has
  \ been moved from the kernel to the library.
  \
  \ 2016-05-05: Update `s=` to `str=`. Improve documentation.
  \
  \ 2016-05-07: New method: the indexed word is an alias, which
  \ doesn't use data space, and its execution token is the
  \ block it's associated to. This way, no data space is used
  \ by the index.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \
  \ 2016-08-05: Compact the code to save one block.

( indexer )

only forth definitions

need str=  need alias  need string/
need get-order  need set-order  need nextname

wordlist constant index-wordlist
  \ Word list for the indexed words.

: search-index  ( ca len -- 0 | xt 1 | xt -1 )
  index-wordlist search-wordlist  ;
  \ Search the index for word _ca len_.

: name-indexed?  ( ca len -- f )
  search-index 0<> dup if  nip  then  ;
  \ Is word _ca len_ in the index?

variable indexed-block

  \ variable counter counter off  \ XXX INFORMER

: index-name  ( ca len -- )
  2dup name-indexed? if  2drop exit  then
  \ 1 counter +! counter ? 2dup type space np@ u.
  \ XXX INFORMER
  nextname indexed-block @ alias  ;
  \ Add word _ca len_ to the blocks index, if not done before.
  \ The current word list is supposed to be `index-wordlist`.

wordlist dup constant indexer-wordlist set-current  -->
  \ Word list for the words that parse the block index lines.

( indexer )

: (  ( "ccc<space><paren><space|eof>" -- )
  begin  parse-name 2dup s" )" str= 0=
  while  index-name  repeat  2drop  ;  ' ( alias .(
  \ Parse and index the names until the next right paren name.

: \  ( "ccc<space><backslash><space|eof>" -- )
  begin  parse-name 2dup s" \" str= 0=
  while  index-name  repeat  2drop  ;
  \ Parse and index the names until the next backslash name.

forth-wordlist set-current

: index-reneeded  ( ca len -- )
  search-index 0= #-277 ?throw load  ;

  \ doc{
  \
  \ index-reneeded  ( ca len-- )
  \
  \ Search the index word list for word _ca len_. If found,
  \ load the block it's associated to.  If not found, throw an
  \ exception -277 ("required, but not indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

: index-reneed  ( "name" -- )  parse-name index-reneeded  ;

  \ doc{
  \
  \ index-reneed  ( "name" -- )
  \
  \ Search the index word list for word "name". If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: index-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  index-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ index-needed ( ca len -- )
  \
  \ If word _ca len_ is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

: index-need  ( "name" -- )  parse-name index-needed  ;  -->

  \ doc{
  \
  \ index-need  ( "name" -- )
  \
  \ If word "name" is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `need`.
  \
  \ }doc

( indexer )

: set-indexed-need  ( -- )
  ['] index-reneeded ['] reneeded  defer!
  ['] index-reneed   ['] reneed    defer!
  ['] index-need     ['] need      defer!
  ['] index-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-indexed-need  ( -- )
  \
  \ Set the alternative behaviour of `need`, `needed`, `reneed`
  \ and `reneeded`: Use the library index created by `indexer`.
  \ In fact `indexer` executes `set-indexed-need` after
  \ creating the index.
  \
  \ The default behaviour can be restored by
  \ `set-located-need`.
  \
  \ }doc

  \ : valid-block-header?  ( ca len -- f )
  \   -trailing dup 0= #-278 ?throw
  \   2 string/ 2dup s"  )" str= >r s"  \" str= r> or  ;
  \ XXX TODO -- remove

  \ XXX OLD
  \ doc{
  \
  \ valid-block-header?  ( ca len -- f )
  \
  \ Is block header _ca len_ valid?
  \ Valid block headers end with " )" or " /".
  \ If it's empty, throw error -278 in order to quit
  \ the indexing.
  \
  \ }doc

  \ XXX OLD
  \ : index-block-header  ( ca len -- )
  \   2dup valid-block-header? if  evaluate exit  then  2drop  ;
  \ Index block header _ca len_, if it's valid.

need evaluate

: index-block  ( +n -- )
  dup indexed-block ! 0 swap line>string evaluate  ;
  \ Index block _+n_.

  \ XXX OLD
  \ dup indexed-block ! 0 swap line>string index-block-header  ;

: (indexer)  ( -- )  last-locatable @ 1+ first-locatable @
                     ?do  i index-block  loop  ;
  \ Create the blocks index.

: indexer  ( -- )
  get-current  get-order
  index-wordlist set-current  indexer-wordlist 1 set-order
  ['] (indexer) catch  dup #-278 <> swap ?throw
  set-order set-current  set-indexed-need  ;

  \ doc{
  \
  \ indexer  ( -- )
  \
  \ Create the blocks index and activate it. The current
  \ word list and the current search order are preserved.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ chars.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271451

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-27: Move `ascii-char?` and `control-char?` from
  \ module "tool.dump.fsb".

  \ XXX TODO -- move to <strings.misc.fsb>.

( ascii-char? control-char? )

: ascii-char?    ( c -- f )  128 <  ;

  \ doc{
  \
  \ ascii-char?    ( c -- f )
  \
  \ Is character _c_ an ASCII character?
  \
  \ }doc


: control-char?  ( c -- f )  bl <  ;

  \ doc{
  \
  \ control-char?    ( c -- f )
  \
  \ Is character _c_ a control character?
  \
  \ }doc

  \ vim: filetype=soloforth
  \ compilation.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051556

  \ -----------------------------------------------------------
  \ Description

  \ Words related to compilation.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-04: Add `[if] [else] [then]`, adapted from Afera.
  \ 2015-06-17: Add `[true]`, `[false]`.
  \ 2015-06-25: Finish `[if] [else] [then]`.
  \ 2015-10-22: Rename words that convert header addresses.
  \ 2015-10-24: Move `body>name`, `name>link`, `link>name` and
  \ `>>link` from the kernel.
  \ 2015-10-29: Move `smudge` and `smudged` from the kernel.
  \ 2015-11-13: Move `?pairs` from the kernel.
  \ 2016-03-19: Add `save-here` and `restore-here`.
  \ 2016-04-17: Add `name>>`.
  \ 2016-04-24: Add `]l`, `]2l`, `exec`, `eval`.
  \ 2016-04-24: Add `[const]`, `[2const]`, `[cconst]`.
  \ 2016-04-24: Move `cliteral` from the kernel.
  \ 2016-04-24: Move `n,` from module "tool.marker.fsb".
  \ 2016-04-25: Simplify `exec`, move `possibly` from the
  \ module "tool.marker.fsb".
  \ 2016-04-25: Move `n,`, `n@`, `n!` to the module
  \ "memory.misc.fsb".
  \ 2016-04-26: Fix `restore-here`. Add `name>interpret`,
  \ `name>compile`.  Move `current-latest` from the kernel,
  \ formerly called `latest`.
  \ 2016-04-27: Add `comp'`, `[comp']`. Move `warning` from the
  \ kernel. Add `warn.throw`, `warn.message`, `warn-throw`
  \ and common factors.
  \ 2016-04-29: Add `string-parameter`.
  \ 2016-05-02: Join several blocks to save space.
  \ 2016-05-02: Move `[compile]` from the kernel.
  \ 2016-05-04: Compact the blocks.
  \ 2016-05-05: Update `s=` to `str=`.
  \ 2016-05-06: Move `current-latest` back to the kernel.
  \ 2016-05-07: Add `?(`, a simpler alternative to `[if]`.
  \ 2016-05-12: Fix requirements of `[cconst]`.
  \ 2016-05-13: Improve `[else]` with `refill`.
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \ 2016-05-15: Update comment.
  \ 2016-05-17: Move `body>` and `>body` from the kernel.
  \ 2016-05-18: Fix `body>` and `>body`: their codes were
  \ exchanged.
  \ 2016-05-31: Update: `cliteral` has been moved to the
  \ kernel. Add `''` and `>>name`.
  \ 2016-06-01: Move `there` from the kernel. Update. Add
  \ `['']`.
  \ 2016-08-05: Fix requiring of `]l`, `]2l`, `exec` ,`eval`,
  \ `save-here` and `restore-here`. Compact the code of several
  \ blocks. Replace one usage of `[if]` with `?(`.

( [false] [true] [if] [else] [then] )

[unneeded] [true]  ?\   0 constant [false] immediate exit
[unneeded] [false] ?\  -1 constant [true]  immediate exit

need str=

  \ Note: `[if]` uses 132 bytes of data space (not including
  \ `str=`).

: [else] ( "ccc" -- )
  1 begin  begin  parse-name dup while  2dup s" [if]" str=
                  if    2drop 1+
                  else  2dup s" [else]" str=
                        if    2drop 1- dup if  1+  then
                        else  s" [then]" str= if  1-  then
                        then
                  then  ?dup 0= if exit then
           repeat  2drop
    refill 0= until  drop  ; immediate

: [if]  ( f "ccc" -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( ?( )

need str=

  \ Note: `?(` uses 35 bytes of data space (not including
  \ `str=`).

: ?(  ( f "ccc<space><question><paren><space>" -- )
  0= ?exit  begin  parse-name dup
            while  s" ?)" str= ?exit  repeat  ; immediate

: ?)  ( -- )  ; immediate

( body>name name>body link>name name>link name<name )

[unneeded] body>name
?\ need body>  : body>name  ( pfa -- nt )  body> >name  ;

[unneeded] name>body
?\ need >body  : name>body  ( nt -- pfa )  name> >body  ;

[unneeded] link>name
?\ need alias  ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link
?\ need alias  ' cell- alias name>link  ( nt -- pfa )

[unneeded] name<name
?\ need name>link  : name<name  ( nt1 -- nt2 )  name>link @s  ;
  \ Get the previous _nt2_ from _nt1_.

( >>link name>> >>name >body body> '' [''] )

[unneeded] >>link
?\ need alias  ' cell+ alias >>link  ( xtp -- lfa ) exit

[unneeded] name>>
?\ : name>>  ( nt -- xtp )  [ 2 cells ] literal -  ; exit

[unneeded] >>name
?\ : >>name  ( xtp -- nt )  [ 2 cells ] literal +  ; exit

[unneeded] >body
?\ code >body  E1 c, 23 c, 23 c, 23 c, jppushhl  end-code
  \ ( xt -- pfa )
  \ pop hl
  \ inc hl
  \ inc hl
  \ inc hl
  \ jp pushhl

[unneeded] body>
?\ code body> E1 c, 2B c, 2B c, 2B c, jppushhl  end-code exit
  \ ( pfa -- xt )
  \ pop hl
  \ dec hl
  \ dec hl
  \ dec hl
  \ jp pushhl

need ?(

[unneeded] '' ?(  need need-here  need-here name>>
: ''  ( "name" -- xtp )  defined dup ?defined name>>  ; exit ?)

[unneeded] [''] ?(  need need-here  need-here ''
: ['']  '' postpone literal  ; immediate compile-only exit ?)
  \ Compilation: ( "name" -- )
  \ Execution: ( -- xtp )

( name>interpret name>compile comp' [comp'] )

need ?(

[unneeded] name>interpret ?(
: name>interpret  ( nt -- xt | 0 )
  dup name> swap compile-only? 0= and  ;  ?)

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return _xt_ that represents the interpretation semantics of
  \ the word _nt_. If _nt_ has no interpretation semantics,
  \ return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[unneeded] name>compile ?(

: (comp')  ( nt -- xt )
  immediate?  if    ['] execute
              else  ['] compile,  then  ;

: name>compile  ( nt -- x xt )  dup name> swap (comp')  ;  ?)

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of the word _nt_. The  returned _xt_ has the
  \ stack effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[unneeded] comp' ?(  need need-here  need-here name>compile

: comp'  ( "name" -- x xt )
  defined dup ?defined name>compile  ;  ?)

  \ doc{
  \
  \ comp'  ( "name" -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] [comp'] ?(  need need-here  need-here comp'

: [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  comp' postpone 2literal  ; immediate compile-only  ?)

  \ doc{
  \
  \ [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

( there ?pairs [compile] smudge smudged )

[unneeded] there
?\ : there  ( a -- )  dp !  ;  exit

  \ doc{
  \
  \ there  ( a -- )
  \
  \ Set _a_ as the address of the data-space pointer.
  \ A non-standard counterpart of `here`.
  \
  \ }doc

[unneeded] ?pairs
?\ : ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;  exit

  \ doc{
  \
  \ ?pairs  ( x1 x2 -- )
  \
  \ If _x1_ not equals _x2_ throw error #-22 (control structure
  \ mismatch).
  \
  \ }doc

[unneeded] [compile]
?\ : [compile]  ( "name" -- )  ' compile,  ; immediate  exit


need ?(

[unneeded] smudged ?(  need c!toggle-bits
: smudged  ( nt -- )
  smudge-mask swap system-bank c!toggle-bits default-bank  ; ?)

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hidden` and `revealed` are used
  \ instead.
  \
  \ }doc

[unneeded] smudge ?(  need need-here  need-here smudged
: smudge  ( -- )  latest smudged  ;  ?)

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ]l ]2l save-here restore-here )

need ?(

[unneeded] ]l ?(

: ]l  ( x -- )  ] postpone literal  ; immediate compile-only ?)

  \ doc{
  \
  \ ]l  ( x -- )
  \
  \ A short form of the idiom `] literal`.
  \
  \ }doc

[unneeded] ]2l ?(

: ]2l  ( xd -- )  ] postpone 2literal  ; immediate compile-only

  \ doc{
  \
  \ ]2l  ( xd -- )
  \
  \ A short form of the idiom `] 2literal`.
  \
  \ }doc

?)

[unneeded] save-here [unneeded] restore-here and ?(  need there

variable here-backup
: save-here  ( -- )  here here-backup !  ;
: restore-here  ( -- )  here-backup @ there  ;  ?)

  \ XXX TODO -- behead `here-backup`

( possibly exec eval )

  \ Credit:
  \
  \ Code of `possibly` adapted from Wil Baden.

need ?(

[unneeded] possibly ?(

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ; ?)

  \ doc{
  \
  \ possibly  ( "name" -- )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else do nothing.
  \
  \ }doc

[unneeded] exec ?(

: exec  ( "name" -- i*x )
  defined ?dup 0= #-13 ?throw  name> execute  ; ?)

  \ doc{
  \
  \ exec  ( "name" -- i*x )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else throw exception
  \ #-13.
  \
  \ }doc

[unneeded] eval ?(  need evaluate

: eval  ( i*x "name" -- j*x )  parse-name evaluate  ; ?)

  \ doc{
  \
  \ exec  ( i*x "name" -- j*x )
  \
  \ Parse and evaluate "name".
  \
  \ This is a common factor of `[const]`, `[2const]` and
  \ `[cconst]`.
  \
  \ }doc

[unneeded] cliteral ?(

: cliteral  ( b -- )
  compile clit c,  ; immediate compile-only ?)

  \ doc{
  \
  \ cliteral  ( b -- )
  \
  \ Compile _b_ in the current definition.
  \
  \ This word does the same than `literal` but saves one byte
  \ of data space.
  \
  \ Origin: Comus.
  \
  \ }doc

( [const] [2const] [cconst] )

need ?(

[unneeded] [const] ?(  need eval

: [const]  ( "name" -- )
  eval postpone literal  ; immediate compile-only  ?)

  \ doc{
  \
  \ [const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the single-cell value left on
  \ the stack.
  \
  \ This word is intented to compile constants as literals, in
  \ order to gain execution speed. "name" can be any word, as
  \ long as its execution returns a single-cell value on the
  \ stack.
  \
  \ Usage example:
  \
  \ ----
  \ 48 constant zx
  \ : test  ( -- )  [const] zx .  ;
  \ ----
  \
  \ }doc

[unneeded] [2const] ?(  need eval

: [2const]  ( "name" -- )
  eval postpone 2literal  ; immediate compile-only  ?)

  \ doc{
  \
  \ [2const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the double-cell value left on
  \ the stack.
  \
  \ This word is intented to compile double-cell constants as
  \ literals, in order to gain execution speed.
  \
  \ Usage example:
  \
  \ ----
  \ 48. 2constant zx
  \ : test  ( -- )  [2const] zx d.  ;
  \ ----
  \
  \ }doc

[unneeded] [cconst] ?(  need eval

: [cconst]  ( "name" -- )
  eval postpone cliteral  ; immediate compile-only  ?)

  \ doc{
  \
  \ [cconst]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the char left
  \ on the stack.
  \
  \ This word is intented to compile char constants as literals, in
  \ order to gain execution speed.
  \
  \ Usage example:
  \
  \ ----
  \ 48 cconstant zx
  \ : test  ( -- )  [cconst] zx emit  ;
  \ ----
  \
  \ }doc

( warnings )

need user  need search-wordlist

user warnings  \ flag

  \ doc{
  \
  \ warnings  ( -- a )
  \
  \ User variable that holds a flag. If it's zero, no warning
  \ is shown when a compiled word is not unique in the
  \ `current` vocabulary.
  \
  \ }doc

: no-warnings?  ( -- f )  warnings @ 0=  ;

  \ doc{
  \
  \ no-warnings?  ( -- f )
  \
  \ Are the warnings deactivated?
  \
  \ }doc

: not-redefined?  ( ca len -- ca len xt false | ca len true )
  2dup get-current search-wordlist 0=  ;

  \ doc{
  \
  \ not-redefined?  ( ca len -- ca len xt false | ca len true )
  \
  \ Is the word name _ca len_ not yet defined in the
  \ current compilation word list?
  \
  \ }doc

: ?warn  ( ca len -- ca len | ca len xt )
    no-warnings? if  unnest exit  ( ca len )  then
  not-redefined? if  unnest                   then
  ( ca len | ca len xt )  ;

  \ doc{
  \
  \ ?warn  ( ca len -- ca len | ca len xt )
  \
  \ A common factor of `warn.throw`, `warn.message` and
  \ `warn-throw`.  Check if a warning about the redefinition of
  \ the word name _ca len_ is needed.  If no warning is needed,
  \ unnest the calling definition and return _ca len_. If a
  \ warning is needed, return _ca len_ and the _xt_ of the word
  \ found in the current compilation wordlist.
  \
  \ See `warn.throw`, `warn-throw`, `warn.message`.
  \
  \ }doc

( warn.throw warn.message warn-throw )

need warnings  need ?(

[unneeded] warn.throw ?(

: warn.throw  ( ca len -- ca len )
  ?warn ( ca len xt )  drop 2drop .error-word  #-257 .throw  ;
' warn.throw ' warn defer!  warnings on  ?)

  \ doc{
  \
  \ warn.throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print throw error #-257, without
  \ actually throwing an error.
  \
  \ See `warn-throw`, `warn.message`.
  \
  \ }doc

[unneeded] warn.message ?(

: warn.message  ( ca len -- ca len )
  ?warn ( ca len xt )  ." redefined " >name .name  ;
' warn.message ' warn defer!  warnings on  ?)

  \ doc{
  \
  \ warn.message  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print a warning message.
  \
  \ See `warn.throw`, `warn-throw`.
  \
  \ }doc

[unneeded] warn-throw ?(

: warn-throw  ( ca len -- ca len )
  ?warn ( ca len xt )  #-257 throw  ;
' warn-throw ' warn defer!  warnings on  ?)

  \ doc{
  \
  \ warn-throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, throw error #-257 instead of
  \ printing a warning message.
  \
  \ See `warn.throw`, `warn.message`.
  \
  \ }doc

( string-parameter )

  \ Credit:
  \
  \ Inspired by pForth's `param`.

: string-parameter  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  @ count             ( ca len ) ( R: a1 )
    \ get the string
  dup char+ r@ @ +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ XXX TODO -- benchmark this alternative:

: string-parameter2  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len ) ( R: a1 )
    \ get the string
  dup char+ rot +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

: string-parameter3  ( -- ca len )
  \ XXX UNDER DEVELOPMENT
  rp@ cell+ dup       ( a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len )
    \ get the string
  rot dup >r over char+ over +    ( ca len a2 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ doc{
  \
  \ string-param  ( -- ca len )
  \
  \ Return a string compiled after the calling word.
  \
  \ See `warning"` and `(warning")` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.array.noble.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051526201608051526

  \ -----------------------------------------------------------
  \ Description

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ References

  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 2001 Julian V. Noble

  \ Modified for Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ License of the original version:

  \ ---------------------------------------------------
  \     (c) Copyright 2001  Julian V. Noble.          \
  \       Permission is granted by the author to      \
  \       use this software for any application pro-  \
  \       vided this copyright notice is preserved.   \
  \ ---------------------------------------------------

  \ License of this version:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \
  \ 2016-04-03: Header reorganized after the original
  \ documentation.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.
  \
  \ 2016-08-05: Remove `long` and `wide` (syntactic sugar).
  \ Combine both blocks into one. Rewrite all stack comments
  \ and word descriptions.

( 1array 2array )

need ?(  [defined] 1array ?(  need <=  

: 1array ( n1 n2 "name" -- )
  create 2dup , , * allot  ;
  \ Define a 1-dimension array _name_ with _n1_ items of 
  \ _n2_ address units each.

: array>items ( a -- n )  cell+ @ ;
  \ Convert address of array _a_ to its number of items _n_.

: } ( a1 n -- a2 )
  over array>items over <= over 0< or #-272 ?throw
  over @ * + cell+ cell+  ;  ?)
  \ Return address _a2_ of the _n_ item of the 1-cell array
  \ _a1_.  Note: #-272 = array index out of range.

[needed] 1array ?exit

: 2array ( n1 n2 n3 "name" -- )
  create >r tuck , ( n2 n1 )  r@ , * dup , r> * allot  ;
  \ Define a 2-dimension array _name_ with _n1 x n2_ items of 
  \ _n3_ address units each.

: }} ( a1 n1 n2 -- a2 ) \ data stored row-wise
  2>r cell+ dup cell- @  r> * r> + }  ;
  \ Return address _a2_ of the _n1,n2_ item of the 2-dimension
  \ array _a1_.

  \ ...........................................................
  \ Usage examples:

  \ 20 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 20 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

  \ vim: filetype=soloforth
  \ data.array.wong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170045

  \ -----------------------------------------------------------
  \ Description

  \ The one-dimensional Wong arrays.

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of `array`, `array>` `ato` and `+ato`.

  \ -----------------------------------------------------------
  \ Authors

  \ Leo Wong.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \ 2016-04-02: Reorganized the description.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( array ato )

need within  need >body

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

  \ vim: filetype=soloforth
  \ data.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `associative:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83, by Henry Laxen and Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2016-04-09: Fixed the file header. Improved the
  \ documentation.

( associative: )

: associative:  ( n "name" -- )
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;

  \ doc{

  \ associative:  ( n "name" -- )

  \ Create a table lookup "name" with _n_ entries.
  \
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \ 1000 constant zx1
  \ 200 constant zx2
  \ 30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ data.associative-list.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160027

  \ -----------------------------------------------------------
  \ Description

  \ An associative list implemented with standard word lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on code written by Wil Baden, published in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-06: Start, adapted from Wil Baden's code.
  \
  \ 2016-03-24: Comments.
  \
  \ 2016-04-15: Improved with different types of items.
  \ Factored. An obscure bug was discovered in during the
  \ changes.  Finally its origin was found in `(;code)`, in the
  \ kernel, and fixed.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- document

( associative-list item? item create-entry )

: associative-list  ( "name" -- )  wordlist constant  ;
  \ Create a new associative list "name".

: item?  ( ca len wid -- false | xt true )
  search-wordlist 0<> ;
  \ Is _ca len_ an item of associative list _wid_?
  \ If so return its _xt_ and _true_, else return _false_.

: item  ( ca len wid -- i*x )
  item? 0= #-13 ?throw execute  ;
  \ If _ca len_ is an item of associative list _wid_, return
  \ its value _i*x_; else throw exception -13, "undefined
  \ word".

: create-entry  ( i*x wid xt "name" -- )
  get-current >r swap set-current
  create execute
  r> set-current  ;
  \ Create an entry "name" in associative list _wid_,
  \ using _xt_ to store its value _i*x_.

-->

( entry char-entry double-entry string-entry )

: entry  ( x wid "name" -- )
  ['] , create-entry does>  ( -- x )  ( pfa ) @  ;
  \ Create a cell entry "name" in associative list
  \ _wid_, with value _x_.

: char-entry  ( c wid "name" -- )
  ['] c, create-entry does>  ( -- c )  ( pfa ) c@  ;
  \ Create a character entry "name" in associative list
  \ _wid_, with value _c_.

: double-entry  ( dx wid "name" -- )
  ['] 2, create-entry does>  ( -- dx )  ( pfa ) 2@  ;
  \ Create a double-cell entry "name" in associative list
  \ _wid_, with value _dx_.

: string-entry  ( ca len wid "name" -- )
  ['] s, create-entry does>  ( -- ca len )  ( pfa ) count  ;
  \ Create a string entry "name" in associative list
  \ _wid_, with value _ca len_.

( items )

need alias  need wordlist-words

' wordlist-words alias items  ( wid -- )
  \ List items of associative list _wid_.

( associative-list-demo )

need associative-list need items

associative-list stuff

1887          stuff entry year
char E        stuff char-entry letter
s" Saluton"   stuff string-entry hello
314159.       stuff double-entry pi

cr .( Keys:) cr stuff items cr

cr .( Values: ) cr

s" year"    stuff item . cr
s" letter"  stuff item emit cr
s" hello"   stuff item type cr
s" pi"      stuff item d. cr

  \ vim: filetype=soloforth
  \ data.begin-stringtable.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-stringtable end-stringtable`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( begin-stringtable end-stringtable )

  \ Credit:
  \
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

  \ vim: filetype=soloforth
  \ data.begin-structure.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Forth-2012 structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

  \ vim: filetype=soloforth
  \ data.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605102225

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to data structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-15: Add `link@` and `link,`.
  \ 2016-04-28: Rename `set` to `storer` and improve it. Add
  \ `cstorer`.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-10: Add `2storer`.

( buffer: cvariable enum link@ link, )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;  exit

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;  exit

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;  exit

[unneeded] link@  [unneeded] link, and ?exit

  \ Credit:
  \
  \ Code of `link@` and `link,` written after the description
  \ by Rick VanNorman, published on Forth Dimensions (volume
  \ 20, number 3, pages 19-22, 1998-09).

defer link@  ( node1 -- node2 )  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

( storer cstorer 2storer )

need ?(

[unneeded] storer ?(

: storer  ( x a "name" -- )
  create  2,  does>   ( -- ) ( pfa )  2@ !  ; ?)

  \ doc{
  \
  \ storer  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _x_ be stored at _a_.
  \
  \ Origin: word `set` found in Forth-79 (Reference Word Set)
  \ and Forth-83 (Appendix B.  Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] cstorer ?(

: cstorer  ( c ca "name" -- )
  create  2,  does>   ( -- ) ( pfa )  2@ c!  ; ?)

  \ doc{
  \
  \ cstorer  ( c ca "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _c_ be stored at _ca_.
  \
  \ Origin: variant of the word `set` found in Forth-79
  \ (Reference Word Set) and Forth-83 (Appendix B.
  \ Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] 2storer ?(

: 2storer  ( xd a "name" -- )
  create  , 2,
  does>   ( -- ) ( pfa )  dup cell+ 2@ rot @ 2!  ; ?)

  \ doc{
  \
  \ 2storer  ( xd a "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _xd_ be stored at _a_.
  \
  \ Origin: variant of the word `set` found in Forth-79
  \ (Reference Word Set) and Forth-83 (Appendix B.
  \ Uncontrolled Reference Words).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.store-to.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170047

  \ -----------------------------------------------------------
  \ Description

  \ Words that change the value of constants.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-10: First version.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( !> 2!> c!> )

need ?(  need >body

[unneeded] !> ?(
: !>  ( Int: x "name" -- ) ( Comp: "name" -- ) ( Exe: x -- )
  ' >body compiling? if    postpone literal postpone ! exit
                     then  !  ; immediate ?)

  \ Credit:
  \
  \ Name borrowed from IsForth.

  \ doc{
  \
  \ !>
  \
  \ Interpretation: ( x "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `constant`, and make _x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `constant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( x -- )
  \
  \ Make _x_ the current value of constant "name".
  \
  \ Origin: IsForth.
  \
  \ }doc

[unneeded] 2!> ?(
: 2!>  ( Int: xd "name" -- ) ( Comp: "name" -- ) ( Exe: xd -- )
  ' >body compiling? if    postpone literal postpone 2! exit
                     then  2!  ; immediate ?)

  \ doc{
  \
  \ 2!>
  \
  \ Interpretation: ( xd "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `2constant`, and make _xd_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `2constant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( xd -- )
  \
  \ Make _xd_ the current value of double-cell constant "name".
  \
  \ Origin: IsForth `!>`.
  \
  \ }doc

[unneeded] c!> ?(
: c!>  ( Int: c "name" -- ) ( Comp: "name" --) ( Exe: c -- )
  ' >body compiling? if    postpone literal postpone c! exit
                     then  c!  ; immediate ?)

  \ doc{
  \
  \ c!>
  \
  \ Interpretation: ( c "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `cconstant`, and make _c_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `cconstant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( c -- )
  \
  \ Make _c_ the current value of the character constant
  \ "name".
  \
  \ Origin: IsForth `!>`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.user.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604211656

  \ -----------------------------------------------------------
  \ Description

  \ Words to use the user data space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09: First draft.
  \ 2016-04-21: New version, moved from the kernel.

( ?user uallot ucreate user 2user )

: ?user  ( -- )
  udp @ dup /user > #-279 ?throw  \ user area overflow?
            0< #-280 ?throw  ;    \ user area underflow?

  \ doc{
  \
  \ ?user  ( -- )
  \
  \ Throw an exception if the user area pointer is out of bounds.
  \
  \ }doc

: uallot  ( n -- )  udp +! ?user  ;

  \ doc{
  \
  \ uallot  ( n -- )
  \
  \ If _n_ is greater than zero, reserve _n_ address units of
  \ user data space. If _n_ is less than zero, release _n_
  \ address units of user data space. If _n_ is zero, leave the
  \ user data-space pointer unchanged. An exception is thrown
  \ if the user-data pointer is out of bounds after the
  \ operation.
  \
  \ }doc

: ucreate  ( "name" -- )  udp @ (user)  ;

  \ doc{
  \
  \ ucreate  ( "name" -- )
  \
  \ Create a header _name_ which points to the first available
  \ offset within the user area.  Execution of _name_ leaves
  \ its absolute user area storage address. No user space is
  \ allocated. See: `uallot`, `user`.
  \
  \ }doc

: user  ( "name" -- )  ucreate cell uallot  ;

  \ doc{
  \
  \ user  ( n "name" -- )
  \
  \ Create a user variable _name_ in the first available offset
  \ within the user area.  Execution of _name_ leaves its
  \ absolute user area storage address.
  \
  \ }doc

: 2user  ( "name" -- )  ucreate [ 2 cells ] literal uallot  ;

  \ doc{
  \
  \ 2user  ( "name" -- )
  \
  \ Create a user double variable _name_ in the first available
  \ offset within the user area.  Execution of _name_ leaves
  \ its absolute user area storage address.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.value.val.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605110157

  \ -----------------------------------------------------------
  \ Description

  \ This module defines `val` and `toval`, which behave like
  \ standard `value` and `to` except `valto` doesn't parse: it
  \ changes the run-time behaviour of the value.
  \
  \ Also double-cell variant `2val` and `2toval` are included.
  \
  \ These words are 3-4 times slower than `value` and `2value`
  \ (from module "data.value.default.fsb"), but since they are
  \ non-parsing they may be useful in special cases.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-08: First versions of `value` with non-standard
  \ non-parsing `to`, inspired by lina.
  \
  \ 2015-09-25: Benchmarked. `perform` and flag versions are
  \ faster than the `defer` version.
  \
  \ 2016-05-10: Fix typo. Improve documentation.
  \
  \ 2016-05-11: Rename `value` to `val` and `to` to `toval`.
  \ Factor the initialization. Add a double-cell version.

( val 2val )

need ?(

[unneeded] val ?(

variable (val)
: init-val  ( -- )   ['] @ (val) !  ;  init-val
: val  ( x "name" -- )
  create ,  does>  ( -- ) ( pfa ) (val) perform  init-val  ;
: toval    ( -- )  ['] ! (val) !  ;  ?)

[unneeded] 2val ?(

variable (2val)
: init-2val  ( -- )   ['] 2@ (2val) !  ;  init-2val
: 2val  ( xd "name" -- )
  create 2,  does>  ( -- ) ( pfa ) (2val) perform  init-2val  ;
: 2toval    ( -- )  ['] 2! (2val) !  ;  ?)

  \ vim: filetype=soloforth
  \ data.value.default.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608021654

  \ -----------------------------------------------------------
  \ Description

  \ This module provides:
  \
  \ - Standard `value` and `to` for single-cell values.
  \ - Non-standard `2value` and `2to` for double-cell values.
  \ - Non-standard `cvalue` and `cto` for character values.
  \
  \ Note: There's a standard implementation of `value`,
  \ `2value` and `to` in module "data.value.standard.fsb",
  \ but it's bigger and slower.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: First versions.
  \
  \ 2015-09-25: Benchmark all versions.
  \
  \ 2015-10-07: Add `cvalue` and `cto`.
  \
  \ 2016-03-24: Split the code into several library modules.
  \
  \ 2016-05-11: Combine three library modules into one. Rewrote
  \ all words as aliases. Document them.
  \
  \ 2016-05-13: Fix `to`, `2to` and `cto`: `immediate` was
  \ missing.
  \
  \ 2016-08-02: Fix comment.

( value to 2value 2to cvalue cto )

need alias  need ?(

[unneeded] value [unneeded] to and ?(

' constant alias value  ( x "name"  -- )

  \ doc{
  \
  \ value  ( x "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _x_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

need !>  ' !> alias to immediate ?)

  \ doc{
  \
  \ to
  \
  \ Interpretation: ( x "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `value`, and make _x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `value`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( x -- )
  \
  \ Make _x_ the current value of value "name".
  \
  \ }doc

[unneeded] 2value [unneeded] 2to and ?(

' 2constant alias 2value  ( xd "name"  -- )

  \ doc{
  \
  \ 2value  ( xd "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _xd_ on the stack.
  \
  \ Note: This word is not the standard `2value` of Forth-94
  \ and Forth-2012. In Solo Forth, words created with this
  \ version of `2value` must be modified using the non-standard
  \ word `2to` instead of `to`.
  \
  \ See `2to`.
  \
  \ }doc

need 2!>  ' 2!> alias 2to immediate ?)

  \ doc{
  \
  \ 2to
  \
  \ Interpretation: ( xd "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `2value`, and make _xd_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `2value`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( xd -- )
  \
  \ Make _xd_ the current value of double-cell value "name".
  \
  \ }doc

[unneeded] cvalue [unneeded] cto and ?(

need cconstant ' cconstant alias cvalue  ( c "name"  -- )

  \ doc{
  \
  \ cvalue  ( c "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _c_ on the stack.
  \
  \ See `cto`.
  \
  \ }doc

need c!>  ' c!> alias cto immediate ?)

  \ doc{
  \
  \ cto
  \
  \ Interpretation: ( c "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `cvalue`, and make _c_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `cvalue`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( c -- )
  \
  \ Make _c_ the current value of the character value
  \ "name".
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.value.standard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170047

  \ -----------------------------------------------------------
  \ Description

  \ A standard implemention of `value`, `2value` and `to`.
  \
  \ This is provided as an alternative, when compatibility is
  \ required, but the code is bigger and slower than the
  \ default version provided by module
  \ "data.value.default.fsb", which uses the non-standard word
  \ `2to`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-09-25: Benchmark.
  \ 2016-05-10: Improve `2value`.
  \ 2016-05-11: Document.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( value 2value to )

need >body

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;

  \ doc{
  \
  \ value  ( x "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _x_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: 2value  ( n "name"  -- )  create  1 c, 2,  does> 1+ 2@  ;

  \ doc{
  \
  \ 2value  ( xd "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _xd_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: to  ( Int: i*x "name" -- ( Comp: "name" -- ( Exe: i*x -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

  \ doc{
  \
  \ to
  \
  \ Interpretation: ( i*x "name" -- )
  \
  \ Parse "name", which is a word created by `value` or
  \ `2value`, and make _i*x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `value` or
  \ `2value`, and append the execution execution semantics
  \ given below to the current definition.
  \
  \ Execution: ( i*x -- )
  \
  \ Make _i*x_ the value of "name".
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.xstack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610140034

  \ -----------------------------------------------------------
  \ Description

  \ `xstack`, an implementation of named
  \ extra stacks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.
  \
  \ Code adapted from Galope (xstack module).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-10-14: Rename `xstack` to `allocate-xstack` and write
  \ `allot-xstack`. Move the common code to its own block.

( xsize xp xp0 xp@ xp! xp+! xclear set-xstack )

  \ Core manipulation of xstacks.

need value

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: set-xstack  ( a -- )
  dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;
  \ Set the xstack at _a_ the current one.

( allocate-xstack xfree )

  \ Creation of xstacks in the heap.

need allocate  need free
need set-xstack  need xp0

: allocate-xstack  ( n "name" -- )
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- ) ( pfa ) set-xstack  ;
  \ Create, in the heap, a xstack _name_ of _n_ cells which,
  \ when executed, will be the current one.

: xfree  ( -- )  xp0 free throw  ;

( allot-xstack )

  \ Creation of xstacks in data space.

need set-xstack

: allot-xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup here [ 2 cells ] literal + dup
    , , , allot
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
    \ +6 = stack space
  does> ( -- )  ( pfa ) set-xstack  ;
  \ Create, in data space, a xstack _name_ of _n_ cells which,
  \ when executed, will be the current one.

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( 2x@ 2>x 2x> 2xdrop 2xdup )

  \ xstack double-number operations

need x@  need >x  need xpick  need xover

: 2x@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: 2xdrop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: 2xdup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xlen xdepth xdepth. .x )

  \ xstack tools

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( n -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the
  \ right-most item.

: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack, followed
  \ by a list of the items, if any; TOS is the right-most item.

  \ vim: filetype=soloforth
  \ data_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605020046

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the data stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-22: Add `2nip`.
  \ 2015-10-16: Move `roll` from the kernel.
  \ 2015-11-09: Add `swapped`.
  \ 2015-11-22: Add `3drop`, `4drop`.
  \ 2015-12-16: Add `nup`, `drup`, `dip`.
  \ 2015-12-22: Move `3dup` from the assembler and rewrite in Z80.
  \ 2016-02-26: Add `ndrop`, `2ndrop`.
  \ 2016-04-24: Move `pick` from the kernel.
  \ 2016-05-02: Join several blocks to save space.

( 2nip pick roll )

need [if]

  \ Credit:
  \
  \ Code from Afera; original code from DZX-Forth.

[needed] 2nip [if]  code 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  E1 c, D1 c, F1 c, F1 c, C3 c, pushhlde ,  end-code  [then]
    \ pop hl
    \ pop de
    \ pop af
    \ pop af
    \ jp pushhlde

  \ doc{
  \
  \ 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  \
  \ }doc

[needed] pick [if]
code pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
  E1 c,  29 c,  39 c,  C3 c, fetchhl ,  end-code  [then]
    \ pop hl
    \ add hl,hl
    \ add hl,sp
    \ jp fetch.hl

  \ doc{
  \
  \ pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

[needed] pick [if]  need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp  bc tstp
    \ push bc
    \ ld b,d
    \ ld c,e
    \ ld d,h
    \ ld e,l
    \ ld a,b
    \ or c

  0000 jpz |mark 0 unresolved !   hl decp  hl decp  lddr
    \ jp z,roll.end
    \ dec hl
    \ dec hl
    \ lddr
    \ roll.end:
  0 unresolved @ >resolve  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl
  jpnext  end-code

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

[then]

( 3drop 4drop 3dup )

need [if]

[needed] 3drop [if]
code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop hl
    \ pop hl
    \ jp next

  \ doc{
  \
  \ 3drop  ( x1 x2 x3 -- )
  \
  \ }doc

[needed] 4drop [if]
code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
    \ jp next

  \ doc{
  \
  \ 4drop  ( x1 x2 x3 x4 -- )
  \
  \ }doc

[needed] 3dup [if]
code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  D9 c,
    \ exx
  C1 c,  D1 c,  E1 c,  E5 c,  D5 c,  C5 c,  E5 c,  D5 c,  C5 c,
    \ pop bc
    \ pop de
    \ pop hl
    \ push hl
    \ push de
    \ push bc
    \ push hl
    \ push de
    \ push bc
  D9 c,  jpnext  end-code  [then]
    \ exx
    \ jp next

  \ doc{
  \
  \ 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  \
  \ }doc

  \ slower and smaller version of `3dup`:

  \ : 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

( 2rot swapped )

need [if]

[needed] 2rot [if]

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

  \ doc{
  \
  \ 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  \
  \ }doc

  \ Credit:
  \
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

[then]

[needed] swapped [if]

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

[then]

( nup drup dip 0dup -dup )

need [if]

[needed] nup [if]  code nup  ( x1 x2 -- x1 x1 x2 )
  E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,  end-code  [then]
    \ pop hl
    \ pop de
    \ push de
    \ jp pushhlde
  \ Also called `under`.

  \ doc{
  \
  \ nup  ( x1 x2 -- x1 x1 x2 )
  \
  \ }doc

[needed] drup [if]  code drup  ( x1 x2 -- x1 x1 )
  D1 c,  E1 c,  E5 c,  E5 c,  jpnext  end-code  [then]
    \ pop de
    \ pop hl
    \ push hl
    \ push hl
    \ jp next

  \ doc{
  \
  \ drup  ( x1 x2 -- x1 x1 )
  \
  \ }doc

[needed] dip [if]  code dip  ( x1 x2 -- x2 x2 )
  E1 c, D1 c, E5 c, E5 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop de
    \ push hl
    \ push hl
    \ jp next

  \ doc{
  \
  \ dip  ( x1 x2 -- x2 x2 )
  \
  \ }doc

[needed] 0dup [if]  code 0dup  ( x -- x | 0 0 )
  E1 c,  78 04 + c,  B0 05 + c,
    \ pop hl
    \ ld a,h
    \ or l
  C2 c, pushhl ,  E5 c,  jppushhl  end-code  [then]
    \ jp z,push_hl
    \ push hl
    \ jp push_hl

  \ doc{
  \
  \ 0dup  ( x -- x | 0 0 )
  \
  \ Duplicate _x_ if it's zero.
  \
  \ }doc

[needed] -dup [if]  code -dup  ( x -- x | 0 0 )
  E1 c,  CB c, 7C c,  C2 c, pushhl ,  E5 c,  jppushhl  end-code
    \ pop hl
    \ bit 7,h ; negative?
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  [then]

  \ doc{
  \
  \ -dup  ( x -- x x | x )
  \
  \ Duplicate _x_ if it's negative.
  \
  \ }doc

( ndrop 2ndrop )

need [if]  need z80-asm

[needed] ndrop [if]

code ndrop  ( x1..xn n -- )

  hl pop  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext  end-code

  \ doc{
  \
  \ ndrop  ( x1..xn n -- )
  \
  \ Drop _n_ cell items from the stack.
  \
  \ }doc

[then]

[needed] 2ndrop [if]

code 2ndrop  ( dx1..dxn n -- )

  hl pop  hl addp  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext  end-code

  \ doc{
  \
  \ ndrop  ( dx1..dxn n -- )
  \
  \ Drop _n_ double cell items from the stack.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth
  \ define.alias.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605052257

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of `alias`.  Features of an alias defined with
  \ `alias`:
  \
  \ - It has the execution token of the original word.
  \ - It does not inherit the attributes of the original word,
  \   which can be set with `immediate` and `compile-only`.
  \ - It does not use data space memory.
  \ - It can be reconfigured with `realias` and `alias!`, but
  \   the compiled aliases don't change.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `alias`: it creates a deferred
  \ word and initializes it. Second version: it recognizes code
  \ words and patches their code field instead.
  \
  \ 2015-12-26: New alternative version, adapted to DTC: if
  \ _xt_ is a deferred word, the alias will point to the word
  \ it's associated to.
  \
  \ 2016-02-27: Fixed the DTC version: the alias of an
  \ unitialized deferred word executed the default error even
  \ after the initialization of the deferred word.
  \
  \ 2016-03-04: Removed the ITC version.
  \
  \ 2016-04-17: Improved `alias`: nowe the aliases have the xt
  \ of the original word.
  \
  \ 2016-04-18: Wrote `realias`.
  \
  \ 2016-04-29: Add `alias!`, a useful common factor of
  \ `alias` and `realias`.
  \
  \ 2016-05-05: Add conditional compilation. Improve
  \ documentation.

( alias! alias realias )

need name>>  need !s

[defined] alias!
?\ : alias!  ( xt nt -- )  name>> !s  ;

  \ doc{
  \
  \ alias!  ( xt nt -- )
  \
  \ Set the alias _nt_ to execute _xt_.
  \
  \ See `alias`, `realias`.
  \
  \ }doc

[unneeded] alias
?\ : alias  ( xt "name" -- )  header reveal latest alias!  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.
  \
  \ Aliases have the execution token _xt_ of the original word,
  \ but don't inherit its precedence (set by `immediate`) and
  \ restricted (set by `compile-only`) attributes.
  \
  \ See `realias`, `alias!`.
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] realias ?exit

: realias  ( xt "name" -- )
  defined dup 0= #-13 ?throw alias!  ;

  \ doc{
  \
  \ realias  ( xt "name" -- )
  \
  \ Set the alias _name_ to execute _xt_.
  \
  \ See `alias`, `alias!`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.colon-no-name.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241823

  \ -----------------------------------------------------------
  \ Description

  \ `:name`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Moved `:noname` from the library.

( :noname )

: :noname  ( -- xt )
  here  dup lastxt !  last off  !csp
  docolon code-field,
  noname? on  ]  ;

  \ XXX TODO -- documentation

  \ doc{
  \
  \ :noname  ( -- xt )
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.deferred.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051328

  \ -----------------------------------------------------------
  \ Description

  \ Words related to deferred words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added `deferred`, using the old definition of
  \ `alias`.
  \
  \ 2016-05-04: Move `defer@` from the kernel, document most
  \ words, compact the blocks.
  \
  \ 2016-08-05: Improve conditional compilation of `<is>`,
  \ `[is]` and `is`.

( deferred defers defer@ action-of )

[unneeded] deferred
?\ : deferred  ( xt "name" -- )  defer latest name> defer!  ;

  \ doc{
  \
  \ deferred  ( xt "name" -- )
  \
  \ Create a deferred word _name_ that will execute _xt_.  The
  \ effect is the same than `defer name  xt ' name defer!`.
  \
  \ }doc

[unneeded] defers
?\ : defers  ( "name" -- )  ' defer@ compile,  ; immediate

  \ doc{
  \
  \ defers  ( Compilation: "name" -- )
  \
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  \
  \ Origin: Gforth.
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from Afera.

[unneeded] defer@ ?\ : defer@  ( xt1 -- xt2 )  >defer @  ;

  \ doc{
  \
  \ defer@  ( xt1 -- xt2 )
  \
  \ Return the word _xt2_ currently associated to the deferred
  \ word _xt1_.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] deferred? ?\ : deferred?  ( xt -- f )  c@ $C3 =  ;

  \ doc{
  \
  \ deferred?  ( xt -- f )
  \
  \ Is _xt_ a deferred word?
  \
  \ The code of a deferred word starts with a Z80 jump ($C3) to
  \ the word it's associated to.
  \
  \ }doc

[unneeded] action-of ?exit

: action-of  ( Interpretation: "name" -- xt )
             ( Compilation:    "name" -- )
             ( Runtime:        -- xt )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ doc{
  \
  \ action-of  ( -- )
  \   ( Interpretation: "name" -- xt )
  \   ( Compilation:    "name" -- )
  \   ( Runtime:        -- xt )
  \
  \ Return the code field address of a deferred word.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from Afera.

( <is> [is] is  )

  \ Credit:
  \
  \ Code adapted from Afera.

[needed] [is]
?\ : <is>  ( xt "name" -- )  ' defer!  ;  [needed] <is> ?exit

: [is]  ( xt "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

[needed] [is] ?exit

: is  ( xt "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

  \ vim: filetype=soloforth
  \ define.nextname.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604152121

  \ -----------------------------------------------------------
  \ Description

  \ Words to define words with specific names.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

( nextname )

2variable nextname-string

  \ doc{
  \
  \ nextname-string  ( -- a )
  \
  \ A double variable that may hold the address and length of a
  \ name to be used by the next defining word.  This variable
  \ is set by `nextname`.
  \
  \ }doc

: nextname-header  ( -- )
  nextname-string 2@ header, default-header  ;

  \ doc{
  \
  \ nextname-header  ( -- )
  \
  \ Create a dictionary header using the name string set by
  \ `nextname`.  Then restore the default behaviour of
  \ `header`.
  \
  \
  \ }doc

: nextname  ( ca len -- )
  nextname-string 2!
  ['] nextname-header ['] header defer!  ;

  \ doc{
  \
  \ nextname  ( ca len -- )
  \
  \ The next defined word will have the name _ca len_; the
  \ defining word will leave the input stream alone. `nextname`
  \ works with any defining word.
  \
  \
  \ Origin: Gforth.
  \
  \ }doc

  \ Credit:
  \ This word is borrowed from Gforth.

  \ vim: filetype=soloforth
  \ define.semicolon-code.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242027

  \ -----------------------------------------------------------
  \ Description

  \ `;code`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-24: Move `;code` from the library.

( ;code )

: ;code  ( -- )
  postpone (;code)  finish-code  ; immediate compile-only

  \ XXX TODO -- Improve documentation.

  \ doc{
  \
  \ ;code  ( -- )
  \
  \ Stop compilation and terminate a new defining word by
  \ compiling the run-time routine `(;code)`.
  \
  \ Origin: fig-Forth, Forth-79 (Assembler Word Set), Forth-83
  \ (Assembler Extension Word Set), Forth-94 (TOOLS EXT),
  \ Forth-2012 (TOOLS EXT).
  \
  \ }doc
  \ define.synonym.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241841

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of Forth-2012 `synonym`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `synonym`, using `create
  \ does>`.
  \
  \ 2015-12-23: New improved version, using `alias`. Keep the
  \ first version, just in case.
  \
  \ 2016-04-18: Removed the old first version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has been
  \ moved from the kernel to the library.


( synonym )

need alias  need nextname

: synonym  ( "newname" "oldname" -- )
  parse-name nextname ' dup >r alias
  r> >name dup immediate?     if  immediate     then
               compile-only?  if  compile-only  then  ;

  \ doc{
  \
  \ synonym  ( "newname" "oldname" -- )
  \
  \ Create a definition for _newname_ with the the semantics
  \ defined below. _newname_ may be the same as _oldname_; when
  \ looking up _oldname_, _newname_ shall not be found.
  \
  \ newname ( Interpretation: i*x -- j*x )
  \
  \ Perform the interpretation semantics of _oldname_.
  \
  \ newname ( Compilation: i*x -- j*x )
  \
  \ Perform the compilation semantics of _oldname_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ dos.trdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608041546

  \ -----------------------------------------------------------
  \ Description

  \ TR-DOS support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-08-04: Start.

( get-drive set-drive )

23833 constant dos-drive

: get-drive  ( -- b )  dos-drive c@  ;
  \ Get the current drive _b_ (0..3).

: set-drive  ( b -- )  dos-drive c!  ;
  \ Set the current drive _b_ (0..3).

  \ vim: filetype=soloforth

  \ editor.specforth.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051542

  \ -----------------------------------------------------------
  \ Description

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum.  Its original
  \ name is "Specforth Editor V1.1".
  \
  \ It has been adapted to Solo Forth.
  \
  \ Word descriptions and stack comments have been added after
  \ the Specforth manual, the Abersoft Forth manual and Dr.
  \ C.H. Ting's book _Systems Guide to fig-Forth_. The word
  \ `copy` has been adapted from Abersoft Forth. The word
  \ `text` has been rewritten.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-11: Adapted to Solo Forth.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-14: Update with `parse-all`, a fixed version of old
  \ `parse-line`.
  \
  \ 2016-05-18: Need `vocabulary`, which has been moved to the
  \ library.
  \
  \ 2016-08-05: Compact the code to save two blocks.

( editor )

only forth definitions  need list  need update  need flush
                        need parse-all need vocabulary

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "ccc<char>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "ccc<eol>" -- )
  pad c/l 1+ blank  parse-all  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;  -->
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

( editor )

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )  r# +! cr space #lead type '_' emit
               #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "ccc<eol>"  -- )  text r  ;
  \ Put "ccc" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;  -->
  \ Clear block _n_ with blanks and select for editing.

( editor )

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if  over + swap do
                  dup c@ [ also forth ] i [ previous ] c@ -
                  if  0= leave  else 1+  then
                loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap [ also forth ]
  do 2dup i -text
     if  >r 2drop r> - i swap - 0 swap 0 0 leave  then
  loop  [ previous ]  2drop swap 0= swap ;  
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin  03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;  -->
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

( editor )

: delete  ( n -- )  >r #lag + r@ - #lag r@ negate r# +! #lead +
                    swap cmove  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "ccc<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "ccc" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "ccc<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "ccc".

: till  ( "ccc<eol>" -- )  #lead + text 1line 0= #-270 ?throw
                           #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "ccc".

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r dup here r@ cmove
  here #lead + r> cmove r> cmove 0 m  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "ccc<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "ccc" to the cursor line at the cursor position.

: copy  ( n1 n2 -- )  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ vim: filetype=soloforth
  \ environmental_queries.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181523

  \ -----------------------------------------------------------
  \ Description

  \ `environment?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-13: Start: only the Forth-2012 queries, not the
  \ obsolescent word set queries of Forth-94.
  \
  \ 2016-05-18: Update: use `wordlist` instead of `vocabulary`,
  \ which has been moved to the library.

( environment? )

wordlist constant environment-wordlist ( -- wid )
  \ Wordlist that is searched by environmental queries.

: environment? ( ca len -- false | i*x true )
  environment-wordlist search-wordlist
  if  execute true  else  false  then  ;

get-current  environment-wordlist dup >order set-current

8 constant address-unit-bits ( -- n )
  \ Size of one address unit, in bits.

255 constant max-char ( -- u )
  \ Maximum value of any character in the character set.

255 constant /counted-string ( -- n )
  \ Maximum size of a counted string, in characters.

  \ XXX TODO
address-unit-bits cells 2* 2+ constant /hold ( -- n )
  \ Size of the pictured numeric string output buffer, in
  \ characters.

  \ XXX TODO calculate
84 constant /pad ( -- n )
  \ Size of the scratch area pointed to by `pad`, in
  \ characters.

1 -3 mod 0< constant floored ( -- f )
  \ True if `/` etc. perform floored division

-->

( environment? )

32767 constant max-n ( -- n )
  \ Largest usable signed integer.

-1 constant max-u ( -- u )
  \ Largest usable unsigned integer.

-1 max-n 2constant max-d ( -- d )
  \ Largest usable signed double.

-1. 2constant max-ud ( -- ud )
  \ Largest usable unsigned double.

  \ XXX TODO -- calculate
$50 constant return-stack-cells ( -- n )
  \ : return-stack-cells ( -- n )
    \ [ forthstart 6 cells + ] literal @ cell / ;
    \ Maximum size of the return stack, in cells.

  \ XXX TODO -- calculate
$50 constant stack-cells ( -- n )
  \ : stack-cells ( -- n )
    \ [ forthstart 4 cells + ] literal @ cell / ;
    \ Maximum size of the data stack, in cells.

  \ XXX TODO -- add "#locals" when needed

set-order previous

  \ vim: filetype=soloforth
  \ exception.codes.0001.standard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181601

  \ -----------------------------------------------------------
  \ Description

  \ The standard Forth error codes (range -255..-1).

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-18: Modify format of messages.

( Standard error codes #-01..#-15 )

#-01 \ ABORT
#-02 \ ABORT"
#-03 \ stack overflow
#-04 \ stack underflow
#-05 \ return stack overflow
#-06 \ return stack underflow
#-07 \ do-loops nested too deeply during execution
#-08 \ dictionary overflow
#-09 \ invalid memory address
#-10 \ division by zero
#-11 \ result out of range
#-12 \ argument type mismatch
#-13 \ undefined word
#-14 \ interpreting a compile-only word
#-15 \ invalid FORGET

( Standard error codes #-16..#-30 )

#-16 \ attempt to use zero-length string as a name
#-17 \ pictured numeric output string overflow
#-18 \ parsed string overflow
#-19 \ definition name too long
#-20 \ write to a read-only location
#-21 \ unsupported operation
#-22 \ control structure mismatch
#-23 \ address alignment exception
#-24 \ invalid numeric argument
#-25 \ return stack imbalance
#-26 \ loop parameters unavailable
#-27 \ invalid recursion
#-28 \ user interrupt
#-29 \ compiler nesting
#-30 \ obsolescent feature

( Standard error codes #-31..#-45 )

#-31 \ >BODY used on non-CREATEd definition
#-32 \ invalid name argument
#-33 \ block read exception
#-34 \ block write exception
#-35 \ invalid block number
#-36 \ invalid file position
#-37 \ file I/O exception
#-38 \ non-existent file
#-39 \ unexpected end of file
#-40 \ invalid BASE for floating point conversion
#-41 \ loss of precision
#-42 \ floating-point divide by zero
#-43 \ floating-point result out of range
#-44 \ floating-point stack overflow
#-45 \ floating-point stack underflow

( Standard error codes #-46..#-60 )

#-46 \ floating-point invalid argument
#-47 \ compilation word list deleted
#-48 \ invalid POSTPONE
#-49 \ search-order overflow
#-50 \ search-order underflow
#-51 \ compilation word list changed
#-52 \ control-flow stack overflow
#-53 \ exception stack overflow
#-54 \ floating-point underflow
#-55 \ floating-point unidentified fault
#-56 \ QUIT
#-57 \ exception in sending or receiving a character
#-58 \ [IF], [ELSE], or [THEN] exception
#-59 \ ALLOCATE
#-60 \ FREE

( Standard error codes #-61..#-75 )

#-61 \ RESIZE
#-62 \ CLOSE-FILE
#-63 \ CREATE-FILE
#-64 \ DELETE-FILE
#-65 \ FILE-POSITION
#-66 \ FILE-SIZE
#-67 \ FILE-STATUS
#-68 \ FLUSH-FILE
#-69 \ OPEN-FILE
#-70 \ READ-FILE
#-71 \ READ-LINE
#-72 \ RENAME-FILE
#-73 \ REPOSITION-FILE
#-74 \ RESIZE-FILE
#-75 \ WRITE-FILE

( Standard error codes #-76..#-79 )

#-76 \ WRITE-LINE
#-77 \ malformed xchar
#-78 \ SUBSTITUTE
#-79 \ REPLACES
#-80 \
#-81 \
#-82 \
#-83 \
#-84 \
#-85 \
#-86 \
#-87 \
#-88 \
#-89 \
#-90 \

  \ vim: filetype=soloforth
  \ exception.codes.0256.system.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181602

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256), except
  \ those reserved for the OS and the DOS.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-18: Modify format of messages.

( System error codes #-256..#-270 )

#-256 \ not a word nor a number
#-257 \ warning: is not unique
#-258 \ stack imbalance
#-259 \ trying to load from block 0
#-260 \ wrong digit
#-261 \ deferred word is uninitialized
#-262 \ assertion failed
#-263 \ execution only
#-264 \ definition not finished
#-265 \ loading only
#-266 \ off current editing block
#-267 \ warning: not present, though required
#-268 \ required, but not located
#-269 \ relative jump too long
#-270 \ text not found

( System error codes #-271..#-285 )

#-271 \ immediate word not allowed in this structure
#-272 \ array index out of range
#-273 \ invalid assembler condition
#-274 \ command line history overflow
#-275 \ wrong number
#-276 \ dictionary reached the zone of memory banks
#-277 \ required, but not indexed
#-278 \ empty block found: quit indexing
#-279 \ user area overflow
#-280 \ user area underflow
#-281 \
#-282 \
#-283 \
#-284 \
#-285 \

  \ vim: filetype=soloforth
  \ exception.codes.trdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181602

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ TR-DOS (range -1012..-1000).

  \ -----------------------------------------------------------
  \ History

  \ 2016-08-04: Start.

( TR-DOS error codes #-1000..#-1014 )

  \ TR-DOS Error codes and messages.
  \
  \ Note: Error #-1000 is not an error, but it's kept in order
  \ to preserve the range of the original actual errors of
  \ TR-DOS (1..12). That's also why the undocumented error
  \ #-1009 (not mentioned in the Beta 128 Disk manual) has been
  \ added.

#-1000 \ TR-DOS: OK
#-1001 \ TR-DOS: No files
#-1002 \ TR-DOS: File exists
#-1003 \ TR-DOS: No space
#-1004 \ TR-DOS: Directory full
#-1005 \ TR-DOS: Record number overflow
#-1006 \ TR-DOS: No disk
#-1007 \ TR-DOS: Disk errors
#-1008 \ TR-DOS: Syntax errors
#-1009 \ TR-DOS: (Undefined error)
#-1010 \ TR-DOS: Stream already opened
#-1011 \ TR-DOS: Not disk fle
#-1012 \ TR-DOS: Stream not open

  \ vim: filetype=soloforth
  \ exception.codes.os.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201608042151

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ ZX Spectrum OS (range -1154..-1128).

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-18: Modify format of messages.

( OS error codes #-1128..#-1142 )

  \ XXX TODO -- it seems OS error codes (there are 28 of them)
  \ may be returned by G+DOS.  they are detected and converted
  \ by `ior>error`.
  \
  \ XXX TODO -- Move this to the G+DOS file and integrate the
  \ calculation. Study in the G+DOS documentation, which OS
  \ errors can be actually issued by DOS operations, not by DOS
  \ commands entered in the BASIC CLI.

#-1128 \ OS: OK
#-1129 \ OS: NEXT without FOR
#-1130 \ OS: Variable not found
#-1131 \ OS: Subscript wrong
#-1132 \ OS: Out of memory
#-1133 \ OS: Out of screen
#-1134 \ OS: Number too big
#-1135 \ OS: RETURN without GO SUB
#-1136 \ OS: End of file
#-1137 \ OS: STOP statement
#-1138 \ OS: Invalid argument
#-1139 \ OS: Integer out of range
#-1140 \ OS: Nonsense in BASIC
#-1141 \ OS: BREAK - CONT repeats
#-1142 \ OS: Out of DATA

( OS error codes #-1143..#-1154 )

#-1143 \ OS: Invalid file name
#-1144 \ OS: No room for line
#-1145 \ OS: STOP in INPUT
#-1146 \ OS: FOR without NEXT
#-1147 \ OS: Invalid I/O device
#-1148 \ OS: Invalid colour
#-1149 \ OS: BREAK into program
#-1150 \ OS: RAMTOP no good
#-1151 \ OS: Statement lost
#-1151 \ OS: Invalid stream
#-1152 \ OS: FN without DEF
#-1153 \ OS: Parameter error
#-1154 \ OS: Tape loading error

  \ vim: filetype=soloforth
  \
  
  \ exception.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051339

  \ -----------------------------------------------------------
  \ Description

  \ The management of exceptions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09: Main development.
  \
  \ 2015-10: Fixes.
  \
  \ 2016-04-14: Restored the file from the repository. It was
  \ removed from version 0.3.0+2016-04-09 by mistake. Updated
  \ the headers and documentation.  Renamed `(.throw)` to
  \ `.throw-message`, and `msg-scr` to `error-messages-block`.
  \ Fixed `error>ordinal`.
  \
  \ 2016-04-25: Add carriage return before the exception
  \ message in `.throw-message`.
  \
  \ 2016-04-29: Add `warning"`.
  \
  \ 2016-05-03: Document `warning"`.
  \
  \ 2016-08-05: Rename `error-messages-block` to
  \ `errors-block`. Combine blocks to save two of them.

( ?compiling ?executing abort" warning" )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;  exit

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;  exit

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc
  \ Credit:
  \
  \ The code of `warning"` was adapted from pForth and modified.

need ?(  [unneeded] abort" ?(

  \ Credit:
  \
  \ The code of `abort"` was adapted from DZX-Forth.

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only  exit  ?)

need string-parameter

: (warning")  ( f -- )
  string-parameter rot if  type  else  2drop  then  ;

  \ doc{
  \
  \ (warning") ( f -- )
  \
  \ Inner procedure compiled by `warning"`.  If _f_ is not
  \ zero, print the compiled message; else do nothing.
  \
  \ }doc

: warning"  \ Compilation: ( "ccc<quote>" -- )
            \ Execution:   ( f -- )
  postpone (warning") ,"  ; immediate compile-only

  \ doc{
  \
  \ warning"
  \
  \ Compilation: ( "ccc<quote>" -- )
  \
  \ Parse and compile a message.
  \
  \ Execution:   ( f -- )
  \
  \ If _f_ is not zero, print the compiled message; else do
  \ nothing.
  \
  \ }doc

( error>ordinal error>line errors-block .throw-message )

: error>ordinal  ( -n1 -- +n2 )
  abs dup 256 < ?exit  \ standard
      dup 1000 < if  [ 256 91 - ] literal - exit  then  \
      [ 1000 286 - 256 91 - + ] literal -   ;
  \ Legend:
  \   -90 = lowest error defined
  \         in the standard range (-255..-1)
  \  -285 = lowest error reserved for the Forth system
  \         (not including the DOS)
  \         in the standard range (-4095..-256)
  \ -1000 = first (highest) error reserved for the DOS
  \         in the standard range (-4095..-256)

  \ doc{
  \
  \ error>ordinal  ( -n1 -- +n2 )
  \
  \ Convert an error code _n1_ to its ordinal position _+n2_ in
  \ the library.

  \ ----
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146
  \ ----

  \ }doc

: error>line  ( -n1 -- n2 )
  error>ordinal dup >r
  begin  dup dup l/scr / - r@ <>  while  1+  repeat  rdrop  ;

  \ doc{
  \
  \ error>line  ( -n1 -- n2 )
  \
  \ Convert error code _-n1_ to line _n2_ relative to the block
  \ that contains the error messages.
  \
  \ }doc

need .line

variable errors-block
s" Standard error codes" located errors-block !

  \ doc{
  \
  \ errors-block  ( -- a )
  \
  \ Variable that contains the block that holds the error
  \ messages.
  \
  \ }doc

: .throw-message  ( n -- )
  errors-block @
  if    cr error>line errors-block @ .line space
  else  .throw#  then  ;

' .throw-message ' .throw defer!

  \ doc{
  \
  \ .throw-message  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`: Print the
  \ text of throw error _n_.  The variable
  \ `errors-block` holds the number of the first
  \ block where messages are hold. If it contains zero, only
  \ the error number is printed.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.associative-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `associative-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-09: Fixed the file header.

( associative-case: )

need create:

: associative-case: ( "name" -- )
  create:
  does> ( n -- ) ( n pfa ) cell+  \ move past `lit`
  begin   2dup @ dup 0= >r  ( n a n n')
          =  r> or  0= ( n a f )
  while   ( n a )  [ 3 cells ] literal +  \ no match
  repeat  nip cell+ perform  ;

  \ doc{

  \ associative-case: ( "name" -- )
  \
  \ Create an associative case definition "name":
  \ `name  ( i*x n -- j*x )`.

  \ Usage example:

  \ ----
  \ : red       ." red"  ;
  \ : blue      ." blue"  ;
  \ : orange    ." orange"  ;
  \ : pink      ." pink"  ;
  \ : black     ." black"  ;
  \
  \ associative-case: color  ( n -- )
  \   7 red  12 blue  472 orange  15 pink  0 black  ;
  \
  \ 7 color cr  472 color cr  3000 color cr
  \ ----

  \ _n_ for default must be 0 and the default pair must be
  \ last.  Numbers can be in any order except 0 must be last.
  \ An actual zero or a no match causes the default to be
  \ executed.  Numbers can't be constants.

  \ }doc

  \ vim: filetype=soloforth
  \ flow.begin-execute.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-execute`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( base-execute )

  \ Credit:
  \
  \ Word from Gforth.

: base-execute  ( xt n -- )  base @ >r execute r> base !  ;
  \ Execute _xt_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

  \ vim: filetype=soloforth
  \ flow.begincase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051442

  \ -----------------------------------------------------------
  \ Description

  \ `begincase repeatcase`, an improved version of standard
  \ `case` that repeats like `begin again`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Original code by Ed:
  \ http://dxforth.netbay.com.au/cfsext.html

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10-26: Start.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \ 2016-04-27: Rename `nextcase` to `repeatcase`. Add
  \ `compile-only`.
  \ 2016-08-05: Move the test to <meta.test.misc.fsb>, but keep
  \ a copy as usage example.

( begincase )

need cs-push  need cs-pop

: begincase  ( -- )
  postpone case  postpone begin  cs-push
  ; immediate compile-only
  \ XXX TODO -- document the stack

: (repeatcase)  ( -- )
  cs-pop  postpone again  postpone endcase  ;
  \ XXX TODO -- document the stack

: repeatcase  ( -- )
  postpone drop  postpone (repeatcase)
  ; immediate compile-only

  \ Usage example:
  \ 
  \ ----
  \ : test
  \   begincase
  \     cr ." press a key ('2' '4' '9' exits) : " key
  \     '2' of  ." ... 2 "  endof
  \     '4' of  ." ... 4 "  endof
  \     '9' of  ." ... 9 "  endof
  \       dup emit ."  try again"
  \   repeatcase  ;
  \ ----

  \ vim: filetype=soloforth
  \ flow.bracket-switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170048

  \ -----------------------------------------------------------
  \ Description

  \ `[switch`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need :noname` and `need pick`, because
  \ those words have been moved from the kernel to the library.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( [switch switch] )

  \ 2015-11-15

  \ Credit:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,  need pick  need >body

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default xt
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched xt. If no match is found, leave _n_ on
  \ the stack and execute the default xt.

: :switch  ( xt "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _xt_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head xt n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _xt_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the xt of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

need :noname  need evaluate

: run:  ( head n "ccc<semicolon>" -- )
  :noname ';' parse evaluate postpone ; ( xt )
  swap >switch  ;

( [switch-test )

  \ without syntactic sugar

need :noname

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test )

  \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

  \ vim: filetype=soloforth
  \ flow.call.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `call`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( call )

code call  ( a -- )

  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next

  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

  \ vim: filetype=soloforth
  \ flow.case.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051503

  \ -----------------------------------------------------------
  \ Description

  \ Several implementations of the standard Eaker's `case`
  \ structure and some variants of `of`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \
  \ 2016-05-06: Replace two remaining `[compile]` with
  \ `postpone`.
  \
  \ 2016-08-05: Compact the code to save some blocks.

( case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( 0 orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop  begin  ?dup  while  postpone then  repeat
  ; immediate compile-only

( eforth-case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  postpone then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( 94-doc-case )

  \ Credit:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( abersoft-case )

  \ Credit:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credit:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of greater-of )

  \ Credit:
  \
  \ Code from Galope.

need ?(  [unneeded] less-of ?(

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

exit ?)

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( any-of default-of )

need ?(  [unneeded] any-of ?(  need any?  need pick

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

exit ?)

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

  \ Credit:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <comp.lang.forth>:
  \ Message-ID: <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( within-of or-of )

  \ Credit:
  \
  \ Code from Galope.

need ?(  [unneeded] within-of ?(  need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

exit ?)

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

  \ Credit:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

  \ vim: filetype=soloforth
  \ flow.cases-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `cases:` structure, an alternative to the standard `case`.
  \
  \ The `cases:` structure is named.  It's built as an array of
  \ pairs (value and associated vector).  It saves space, but
  \ is slower than standard `case`. The default case of the
  \ structure is mandatory.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code written by Dan Lerner, published on Forth
  \ Dimensions (volume 3, number 6, page 189, 1982-03).

  \ Marcos Cruz (programandala.net), adapted, renamed and
  \ commented the original code, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: First version.
  \ 2016-04-27: Rename `other>` to `othercase>`. Improve
  \ documentation and file header.

( cases: )

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  leave
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10      ." dek"  ;
  \ : say100     ." cent" ;
  \ : say1000    ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>      say10
  \    100 case>      say100
  \   1000 case>      say1000
  \        othercase> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: othercase>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ doc{
  \
  \ othercase>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required,
  \ `othercase> noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.ccase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281721

  \ -----------------------------------------------------------
  \ Description

  \ `ccase` is a positional control structure that uses the
  \ position of a character in a string as key, and has a
  \ mandatory default option at the end.  Data space used
  \ (without requirements): 69 bytes.
  \
  \ `ccase0` is a simpler variant of `ccase` that uses the
  \ first compiled option as a mandatory default option.  Data
  \ space used (without requirements): 44 bytes.
  \
  \ `?ccase` is a simpler variant of `ccase` with no default
  \ option.  Data space used (without requirements): 34 bytes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ `?ccase` was inspired by MMSFORTH's `acase`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-28: Write `?ccase`, `ccase0`.

( ?ccase )

need alias  need char-position?

' >resolve alias end?ccase  immediate compile-only
  \ Compilation: ( C: orig -- )
  \ Run-time: ( -- )

  \ doc{
  \
  \ end?ccase
  \
  \   Compilation: ( C: orig -- )
  \   Run-time: ( -- )
  \
  \ End of a `?ccase` control structure.
  \ See `?ccase` for a usage example.
  \
  \ }doc

: (?ccase)  ( c ca len -- )
  rot char-position? if  2+ cells r@ + perform  then  ;

  \ doc{
  \
  \ (?ccase) ( c ca len -- )
  \
  \ Run-time procedure compiled by `?ccase`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `?ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1).  If _c_ is not in _ca len_, do nothing.
  \
  \ See: `?ccase`.
  \
  \ }doc

: ?ccase
  \ Compilation: ( C: -- orig )
  \ Run-time: ( c ca len -- )
  postpone (?ccase) postpone ahead  ; immediate compile-only

  \ doc{
  \
  \ ?ccase
  \
  \ Compilation: ( C: -- orig ) Run-time: ( c ca len -- )
  \
  \ Start a `?ccase end?ccase` structure. If _c_ is in the string
  \ _ca len_, execute the n-th word compiled after `?ccase`,
  \ where _n_ is the position of the first _c_ in the string
  \ (0..len-1), then continue after `endcase`.  If _c_ is not
  \ in _ca len_, just continue after `end?ccase`.
  \
  \ Usage example:

  \ ----
  \ : .a   ( -- )  ." Letter A"  ;
  \ : .b   ( -- )  ." Letter B"  ;
  \ : .c   ( -- )  ." Letter C"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ?ccase  .a .b .c  end?ccase  ."  The End" cr  ;
  \ ----
  \
  \ }doc

( ccase0 )

need alias  need char-position?

' >resolve alias endccase0  immediate compile-only
  \ Compilation: ( C: orig -- )
  \ Run-time: ( -- )

  \ doc{
  \
  \ endccase0
  \
  \   Compilation: ( C: orig -- )
  \   Run-time: ( -- )
  \
  \ End of a `ccase0` control structure.
  \ See `ccase0` for a usage example.
  \
  \ }doc

: (ccase0)  ( c ca len -- )
  rot char-position? if    ( +n ) 3 +
                           \ character found:
                           \ calculate the cells offset to the option
                     else  2
                           \ character not found:
                           \ leave cells offset to the default option
                     then  cells r@ + perform  ;

  \ doc{
  \
  \ (ccase0) ( c ca len -- )
  \
  \ Run-time procedure compiled by `ccase0`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase0`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1.  If _c_ is not in _ca len_,
  \ execute the word compiled right after `ccase0`.
  \
  \ See: `ccase0`.
  \
  \ }doc

: ccase0
  \ Compilation: ( C: -- orig )
  \ Run-time: ( c ca len -- )
  postpone (ccase0) postpone ahead  ; immediate compile-only

  \ doc{
  \
  \ ccase0
  \
  \ Compilation: ( C: -- orig ) Run-time: ( c ca len -- )
  \
  \ Start a `ccase0 endccase` structure. If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1, then continue after `endcase`.
  \ If _c_ is not in _ca len_, execute the word compiled right
  \ after `ccase0`, then continue after `endccase`.
  \
  \ Usage example:

  \ ----
  \ : .a     ( -- )  ." Letter A"  ;
  \ : .b     ( -- )  ." Letter B"  ;
  \ : .c     ( -- )  ." Letter C"  ;
  \ : .nope  ( -- )  ." Nope!"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ccase0  .nope .a .b .c  endccase0
  \   ."  The End" cr  ;
  \ ----
  \
  \ }doc

( ccase )

need char-position?

: endccase
  \ Compilation: ( C: orig1 orig2 -- )
  \ Run-time: ( -- )
  here cell- swap !
    \ resolve _orig2_, the address of the default option
  >resolve
    \ resolve _orig1_, the branch to `endccase`
  ; immediate compile-only

  \ doc{
  \
  \ endccase
  \
  \   Compilation: ( C: orig1 orig2 -- )
  \   Run-time: ( -- )
  \
  \ End of a `ccase` control structure.
  \ See `ccase` for a usage example.
  \
  \ }doc

: (ccase)  ( c ca len -- )
  rot char-position? if    ( +n ) 3 + cells r@ +
                           \ character found:
                           \ calculate address of the option
                     else  [ 2 cells ] literal r@ + @
                           \ character not found:
                           \ calculate address of the default option
                     then  perform  ;

  \ doc{
  \
  \ (ccase) ( c ca len -- )
  \
  \ Run-time procedure compiled by `ccase`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1).  If _c_ is not in _ca len_,
  \ execute the word compiled right before `endccase`.
  \
  \ See: `ccase`.
  \
  \ }doc

: ccase
  \ Compilation: ( C: -- orig1 orig2 )
  \ Run-time: ( c ca len -- )
  postpone (ccase)  postpone ahead  >mark
  ; immediate compile-only

  \ doc{
  \
  \ ccase
  \
  \ Compilation: ( C: -- orig1 orig2 )
  \ Run-time: ( c ca len -- )
  \
  \ Start a `ccase endccase` structure. If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1, then continue after `endcase`.
  \ If _c_ is not in _ca len_, execute the word compiled right
  \ after `ccase`, then continue after `endccase`.
  \
  \ Usage example:

  \ ----
  \ : .a     ( -- )  ." Letter A"  ;
  \ : .b     ( -- )  ." Letter B"  ;
  \ : .c     ( -- )  ." Letter C"  ;
  \ : .nope  ( -- )  ." Nope!"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ccase  .a .b .c .nope  endccase
  \   ."  The End" cr  ;
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.conditionals.negative.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Negative conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch ,
    \ jp z,branch_code ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( -exit )

code -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                   \ pop hl
  CB c, 7C c,             \ bit 7,h ; negative?
  C2 c, ' exit ,          \ jp nz,exit_code
  jpnext                  \ jp next

  end-code

  \ doc{
  \
  \ -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _n_ is negative, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `-exit` is not intended to be used within a do-loop. Use
  \ `0< if unloop exit then` instead.
  \
  \ In Solo Forth `-exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.conditions.zero.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Zero conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 0if 0while 0until )

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( 0exit )

code 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                 \ pop hl
  78 04 + c,            \ ld a,h
  B0 05 + c,            \ or l
  CA c, ' exit ,        \ jp z,exit_code
  jpnext                \ jp next

  end-code

  \ doc{
  \
  \ 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _f_ is zero, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `0exit` is not intended to be used within a do-loop. Use
  \ `0= if unloop exit then` instead.
  \
  \ In Solo Forth `0exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.create-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160427

  \ -----------------------------------------------------------
  \ Description

  \ Provide `create:`, a defining word that creates a word
  \ which is compiled as a colon word but, when executed, will
  \ return the address of its pfa.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ The idea for `create:` was borrowed from CP/M-volksForth
  \ 3.80a.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ doc{
  \
  \ create:  ( "name" -- )
  \
  \ Create a word "name" which is compiled as a colon word but,
  \ when executed, will return the address of its pfa.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.dfor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160145

  \ -----------------------------------------------------------
  \ Description

  \ `dfor dstep`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-01: Written, a double-cell variant of `for step`.
  \
  \ 2015-03-23: Renamed `di` to `dfor-i`, after `for-i`,
  \ because `i` cannot be used since the implementation of the
  \ Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header.  Fixed stack
  \ notations.

( dfor dstep di )

: (dstep)  ( R: x d -- x d' )

  \ doc{
  \
  \ (dstep)  ( R: x d -- x d' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( d -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest ) Run-time: ( d -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `dfor-i`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' 2r@ alias dfor-i  ( -- d )

  \ doc{
  \
  \ dfor-i  ( -- d )
  \
  \ Return the current index _d_ of a `dfor` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.dijkstra.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Dijkstra control structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming". Originally published
  \ on Forth Dimensions (volume 18, number 4, pp 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh.

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 ?do  postpone then  loop  ; immediate compile-only
  \ end a conditional

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming" Originally published
  \ on Forth Dimensions (number 18, number 4, pages 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ vim: filetype=soloforth
  \ flow.doer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170049

  \ -----------------------------------------------------------
  \ Description

  \ Leo Brodie's `doer make` construct.

  \ -----------------------------------------------------------
  \ Credit

  \ Original code by Leo Brodie, 1983, published on _Thinking
  \ Forth_, Appendix A. Public domain.

  \ This version was adapted from PFE by Marcos Cruz
  \ (programanadla.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( doer )

need >body

: doer-noop ;

: doer  ( "name" -- )
  create  ['] doer-noop >body ,  does>  ( pfa ) @ >r ;
  \ Define a word whose behaviour is vectorable.

: (make)
  \ Stuff the address of further code into the parameter field
  \ of a doer word.
  r> dup cell+ dup cell+
    ( a1 a2 a2 )
    \ a1 = address of an optional continuation after `;and`,
    \      or zero
    \ a2 = address of the doer word
    \ a3 = address of the code to associate the doer word with
  swap @ >body !
    \ Get the pfa of the doer word and store the code address
    \ into it.
  @ ?dup if  >r  then ;
    \ Manage the optional continuation after `;and`.

variable >;and
  \ Hold the address of optional continuation pointer.

: make
  \ Used interpretively:
  \   make doer-name forth-code ;
  \ Or inside a definition:
  \   : definition  make doer-name forth-code  ;
  compiling? if     postpone (make)  here >;and ! 0 ,
             else   here ' >body ! ]  then  ; immediate

: ;and  ( -- )  postpone exit  here >;and @ !  ; immediate
  \ Allow continuation of the "making" definition.

: undo  ( "name" -- )  ['] doer-noop >body  ' >body ! ;
  \ Make the doer word "name" safe to execute.

( doer-test )

need doer

doer test
  .( Test 1: ) test
make test  cr ." test 2" ;
  .( Test 2: ) test
: change    make test ." test 3" ;and  test ;
change
  .( Test 3: ) test
undo test
  .( Test 4: ) test

  \ vim: filetype=soloforth
  \ flow.dont.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `don't`

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.dtimes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `dtimes`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

  \ vim: filetype=soloforth
  \ flow.executions.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242017

  \ -----------------------------------------------------------
  \ Description

  \ `executions`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need 2rdrop`, because `2rdrop` has been
  \ moved from the kernel to the library.

( executions )

  \ Credit:
  \
  \ Code from Galope (module times.fs).

need 2rdrop

: executions  ( xt n -- )
  \ Execute _xt_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

  \ vim: filetype=soloforth
  \ flow.for.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160140

  \ -----------------------------------------------------------
  \ Description

  \ `for step`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Adapted and modified from code written by Garry Lancaster
  \ for Z88 CamelForth, 2001.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-07-06: Adapted from Z88 CamelForth.
  \
  \ 2015-08-14: Checked. Removed the fig-Forth compiler
  \ security.  Moved from the kernel to the library.  Improved
  \ after Gforth: now the index is checked before decrementing
  \ it.  Documented.
  \
  \ 2015-03-23: Added `for-i`, because `i` cannot be used since
  \ the implementation of the Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header. Fixed stack
  \ notations.

( for step )

  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch ,
    \ jp nz,branch_code ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( n -- )
  \
  \ Start of a `for step` loop, that will iterate _n+1_ times,
  \ starting with _n_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `for-i`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' r@ alias for-i  ( -- n )

  \ doc{
  \
  \ for-i  ( -- n )
  \
  \ Return the current index _n_ of a `for` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.j.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605041254

  \ -----------------------------------------------------------
  \ Description

  \ `j` and `k`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-15: Written.
  \ 2016-04-28: Calculate the secondary entry point of `i`,
  \ instead of using the constant `(i)`, which has been
  \ removed from the kernel.
  \ 2016-05-04: Compact two blocks into one.

( j k )

need [if]

[needed] j [if]

code j  ( -- n|u ) ( R: do-sys1 do-sys2 -- do-sys1 do-sys2 )
  2A c, rp ,  11 c, 3 cells ,  19 c,  C3 c, ' i 3 + ,  end-code
    \ ld hl,(return_stack_pointer)
    \ ld de,3*cell
    \ add hl,de
    \ jp i.hl ; secondary entry point in `i`

[then]

  \ doc{
  \
  \ j  ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
  \
  \ Return a copy _n|u_ of the next-outer loop index.
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE),
  \ Forth-2012 (CORE).  Note: `k` was also in Forth-79
  \ (Reference word set), but returned a signed number.
  \
  \ }doc

[needed] k [if]

code k  ( -- n|u )
  ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  2A c, rp ,  11 c, 6 cells ,  19 c,  C3 c, ' i 3 + ,  end-code
    \ ld hl,(return_stack_pointer)
    \ ld de,6*cell
    \ add hl,de
    \ jp i.hl ; secondary entry point in `i`

[then]

  \ doc{
  \
  \ k  ( -- n|u ) ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  \
  \ Return a copy _n|u_ of the second outer loop index.
  \
  \ Origin: Forth-83 (Controlled reference words). Note: `k`
  \ was also in Forth-79 (Reference word set), but returned a
  \ signed number.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.options-bracket.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604290244

  \ -----------------------------------------------------------
  \ Description

  \ `options[ ]options` control structure, an alternative to
  \ `case` with single-word options and a specific default
  \ case. The compilation of options is done in interpretation
  \ mode.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit:

  \ `options[` is a port of IsForth's `case:`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-15: Finish porting IsForth's `case:`, with
  \ different names.  In the original code the word `docase`
  \ (called `(options)` in this port) is written in x86
  \ assembler.  It has been rewritten from scratch, without
  \ investigating the assembler code.
  \
  \ 2016-04-29: Improve documentation.

( options[ )

  \ XXX TODO -- alternative version `coptions[`

  \ Data space used: 166 bytes.

variable (default-option)
  \ Execution token of the default option.

variable #options
  \ Number of compiled options.

: default-option ( "name" -- )  ' (default-option) !  ;

  \ doc{
  \
  \ default-option ( "name" -- )
  \
  \ Set the default option "name" of an `options[ ]options`
  \ structure.  It can be anywhere inside the structure.
  \
  \ See `options[` for a usage example.
  \
  \ }doc

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option xt
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  leave then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

  \ doc{
  \
  \ (options)  ( i*x x -- j*x )
  \
  \ Run-time procedure compiled by `options[`.
  \
  \ x = option to search for
  \
  \ }doc

( options[ )

: options[

  \ Compilation: ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of the xt of the default option
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ init number of options
  postpone (options)          \ compile run-time handler
  >mark >mark >mark           ( a1 a2 a3 )
  postpone [                  \ start interpreting options
  ; immediate compile-only

  \ doc{
  \
  \ options[
  \
  \ Compilation: ( -- a1 a2 a3 )
  \
  \ Start an `options[ ]options` structure.
  \
  \ The addresses left on the stack will be resolved by
  \ `]options`:
  \
  \ - a1 = address of exit point
  \ - a2 = address of the xt of the default option
  \ - a3 = address of number of options
  \
  \ Usage example:
  \
  \ ----
  \ : say10      ." dek"   ;
  \ : say100     ." cent"  ;
  \ : say1000    ." mil"   ;
  \ : say-other  ." alia"  ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  ,  ' compile,  1 #options +!  ;

  \ doc{
  \
  \ option  ( x "name" -- )
  \
  \ Compile the action "name" of an option _x_ in an `options[
  \ ]options` control structure.
  \
  \ See `options[` for a usage example.
  \
  \ }doc

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option xt
  >resolve                    \ store exit point
  ]  ;

  \ doc{
  \
  \ ]options  ( a1 a2 a3 -- )
  \
  \ End a `options[ ]options` structure. Resolve the addresses
  \ left by `options[`:
  \
  \ - a1 = address of exit point
  \ - a2 = address of default option xt
  \ - a3 = address of number of options
  \
  \ See `options[` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.positional-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `positional-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83's `case:`, by Henry Laxen and
  \ Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2015-11-22: Modified to use `create:`.
  \ 2015-12-14: Renamed to `positional-case:`.
  \ 2016-04-09: Fixed the file header. Documented.

( positional-case: )

need create:

: positional-case:  ( "name" -- )
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;


  \ doc{
  \
  \ positional-case:  ( "name" -- )
  \
  \ Create a positional case word "name". At runtime, "name"
  \ will execute the n-th word compiled in its definition,
  \ depending upon the value on the stack. No range checking.
  \
  \ Usage example:

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ positional-case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.question-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `??`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ?? )

  \ Credit:
  \
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

  \ vim: filetype=soloforth
  \ flow.question-repeat.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281437

  \ -----------------------------------------------------------
  \ Description

  \ An alternative exit point for `begin until` loops.

  \ -----------------------------------------------------------
  \ Credit

  \ Code from the documentation of Forth-2012 and Forth-94.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-03-04: Copy from the Forth-2012 documentation.
  \ 2016-04-28: Fix the stack notation.

( ?repeat )

need cs-pick

: ?repeat  ( C: dest -- dest ) \ Compilation
           ( f -- )            \ Execution
    0 cs-pick   postpone until
  ; immediate

  \ doc{
  \
  \ ?repeat  Compilation: ( C: dest -- dest )
  \          Execution:   ( f -- )
  \
  \ Usage example:

  \ ----
  \ : xx  ( -- )
  \     begin
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag until    \ Go back to `begin` if flag is false
  \     ...
  \   ;
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.recurse.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241816

  \ -----------------------------------------------------------
  \ Description

  \ `recurse`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-05: Written in the kernel.
  \
  \ 2016-04-17: Moved to the library.
  \
  \ 2016-04-24: Fixed with `latestxt`: now it can be used
  \ in words created with `:noname`.

( recurse )

: recurse  ( -- )  latestxt compile,  ; immediate compile-only

  \ doc{
  \
  \ recurse  ( -- )
  \
  \ Append the execution semantics of the current definition to
  \ the current definition.
  \
  \ Origin: Forth-83 (Controlled Reference Words), Forth-94
  \ (CORE), Forth-2012 (CORE).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.retry.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604262145

  \ -----------------------------------------------------------
  \ Description

  \ `retry` and `?retry`: unconditional and conditional
  \ branches to the start of the current definition.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on the article "RETRY, EXIT, and Word-Level
  \ Factoring", by Richard Astle, published on Forth Dimensions
  \ (volume 17, number 4, page 19, 1995-11).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-07: First version.
  \ 2016-04-26: Documented.

( retry ?retry )

need name>body

: retry  ( Compilation: -- ) ( Run-time: -- )
  latest name>body postpone again
  ; immediate compile-only

  \ doc{
  \
  \ retry  ( -- )
  \
  \ Do an unconditional branch to the start of the word.
  \
  \ }doc

: ?retry  ( Compilation: -- ) ( Run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

  \ doc{
  \
  \ : ?retry  ( Compilation: -- ) ( Run-time: f -- )
  \
  \ Do a conditional branch to the start of the word.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.select.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242202

  \ -----------------------------------------------------------
  \ Description

  \ `select`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credit:
  \
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 f )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 f )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Point "              else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  'a'  .(   ) dup emit  select-test
cr  ','  .(   ) dup emit  select-test
cr  '8'  .(   ) dup emit  select-test
cr  '?'  .(   ) dup emit  select-test
cr  'K'  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

  \ vim: filetype=soloforth
  \ flow.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241713

  \ -----------------------------------------------------------
  \ Description

  \ Words to manipulate the control flow
  \ stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( cs-pick cs-roll cs-swap cs-drop )

need alias  need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this:

  \  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  \  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value:
  \  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credit:
  \
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

  \ vim: filetype=soloforth
  \ flow.switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `switch`, a case selector with word
  \ lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

  \ flow.thiscase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271840

  \ -----------------------------------------------------------
  \ Description

  \ `thiscase`, an alternative `case` structure that makes any
  \ calculation easier.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: First version.
  \
  \ 2016-03-24: Rename the words to avoid standard names
  \ `case`, `of` and `endof`.
  \
  \ 2016-04-27: Improve documentation and file header.

( thiscase )

need alias

: ifcase  ( x f -- )
  postpone if  postpone drop  ; immediate compile-only

  \ doc{
  \
  \ ifcase  ( x f -- )
  \
  \ Part of a `thiscase ifcase
  \ exitcase` structure that checks _x_.
  \
  \ See `thiscase` for a usage example.
  \ See also: `exitcase`, `othercase`.
  \
  \ }doc

: exitcase  ( -- )
  postpone exit  postpone then  ; immediate compile-only

  \ doc{
  \
  \ exitcase  ( -- )
  \
  \ Part of a `thiscase ifcase exitcase` structure.
  \
  \ See `thiscase` for a usage example.
  \ See also: `ifcase`, `othercase`.
  \
  \ }doc

' dup alias thiscase  ( x -- x x )

  \ doc{
  \
  \ thiscase  ( x -- x x )
  \
  \ Mark the start of a `thiscase ifcase exitcase` structure
  \ that checks _x_.
  \
  \ See: `ifcase`, `exitcase`, `othercase`.
  \
  \ Usage example:

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;
  \
  \ : test  ( x -- )
  \   thiscase 0 = ifcase  say0  exitcase
  \   thiscase 1 = ifcase  say1  exitcase
  \   thiscase 2 = ifcase  say2  exitcase
  \            othercase say-other  ;
  \ ----
  \
  \ }doc

' drop alias othercase  ( n -- )

  \ doc{
  \
  \ othercase  ( x -- )
  \
  \ Mark the start of the default option of a `thiscase ifcase
  \ exitcase` structure that checks _x_.
  \
  \ See `thiscase` for a usage example.
  \ See also: `ifcase`, `exitcase`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.times.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604161626

  \ -----------------------------------------------------------
  \ Description

  \ `times`, a control flow structure which executes _n_ times
  \ the next word compiled.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ `times` was inspired by cmForth's `repeats`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Several drafts, with different behaviours
  \ during compilation.
  \
  \ 2016-04-16: Finished. Simplest version. Documented.

( times )

variable times-xt  \ the _xt_ executed by `times`

: times  ( i*x n -- j*x )
  rp@ @  dup cell+ rp@ !  @ times-xt !
  0 ?do  times-xt perform  loop  ; compile-only

  \ doc{
  \
  \ times  ( i*x n -- j*x )
  \
  \ Repeat the next compiled instruction _n_ times.  If _n_ is
  \ zero, continue executing the following instruction.
  \
  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.
  \
  \ Usage example:
  \
  \ ----
  \ : blink  ( -- )  7 0 do  i border  loop  0 border  ;
  \ : blinking  ( -- )  100 times blink  ." Done" cr  ;
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.attributes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610151554

  \ -----------------------------------------------------------
  \ Description

  \ Words related to screen attributes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-10-15: Improve the format of the documentation.

( attr )

need z80-asm need (attr-addr)

code attr ( col row -- b )

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  jppushhl

  end-code

  \ doc{
  \
  \ attr  ( col row -- b )
  \
  \ Return the color attribute _b_ of the given cursor
  \ coordinates _col row_.
  \
  \ }doc

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col row -- a )

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  jppushhl

  end-code

  \ doc{
  \
  \ attr-addr  ( col row -- a )
  \
  \ Return the color attribute address _a_ of the given cursor
  \ coordinates _col row_.
  \
  \ }doc

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

  \ doc{
  \
  \ (attr-addr)  ( -- a )
  \
  \ Return the address _a_ of a Z80 routine that calculates the
  \ color attribute address of a cursor position.  This is a
  \ modified version of the ROM routine at 0x2583.
  \
  \ Input:
  \
  \ - D = column (0..31)
  \ - E = row (0..23)
  \
  \ Output:
  \
  \ - HL = address of the attribute in the screen
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words which manipulate screen blocks
  \ (windows)

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( clear-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code clear-block  ( column row width height -- )

  \ doc{
  \
  \ clear-block  ( column row width height -- )
  \
  \ Clear a screen block at the given character coordinates and
  \ of the given size in characters.  Only the bitmap is
  \ cleared. The color attributes remain unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+6 = column
    \ ; ix+4 = row
    \ ; ix+2 = width
    \ ; ix+0 = height

  #4 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #6 ix orx
    \ ld a,(ix+4) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+6) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a
  #2 ix c ftx  #0 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+2) ; width
    \ ld a,(ix+0) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  0 hl ldp#  sp addp  #4 cells de ldp#  de addp  ldsp
    \ djnz delete_bitmap
    \ ; Drop the parameters:
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( color-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code color-block  ( column row width height color -- )

  \ doc{
  \
  \ color-block  ( column row width height color -- )
  \
  \ Color a screen block at the given character coordinates and
  \ of the given size in characters.  Only the color attributes
  \ are changed; the bitmap remains unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
  #2 ix b ftx  #4 ix c ftx
    \ ld b,(ix+2) ; height
    \ ld c,(ix+4) ; width
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( wipe-block )

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code wipe-block  ( column row width height color -- )

  \ doc{
  \
  \ wipe-block  ( column row width height color -- )
  \
  \ Wipe a screen block at the given character coordinates and
  \ of the given size in characters.  The bitmap is erased and
  \ the color attributes are changed with the given color.
  \
  \ This word is written in assembler and it combines the
  \ functions of `clear-block` and `color-block`. It may be
  \ defined also this way (with slower but much smaller code):

  \ ----
  \ : wipe-block  ( column row width height color -- )
  \   >r 2over 2over clear-block r> color-block  ;
  \ ----

  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #8 ix orx
    \ ld a,(ix+6) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+8) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a ; DE = top left address of the block
  #4 ix c ftx  #2 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+4) ; width
    \ ld a,(ix+2) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  -->
    \ djnz delete_bitmap

( wipe-block )

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld  #2 ix b ftx
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
    \ ld b,(ix+2) ; height
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.circle.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw circles.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( circle )

  \ XXX UNDER DEVELOPMENT

  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( gx gy radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

  \ vim: filetype=soloforth
  \ graphics.cls.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that clear the screen with special
  \ effects.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( cls-chars0 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Anselmo Moreno
  \ Lorente, published on Microhobby, issue 121 (1987-03), page
  \ 7:
  \
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code cls-chars0  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( cls-chars1 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code cls-chars1  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin
      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
    z until

  step

  bc pop  jpnext  end-code

( horizontal-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color attribute _b_ from the
  \ top and bottom rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.display.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604101641

  \ -----------------------------------------------------------
  \ Description

  \ Words to save and restore the display status, in order to
  \ call ROM routines that prints to the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( nonfull-display full-display save-display restore-display )

: nonfull-display  ( -- )  2 23659 c!  ;

  \ doc{
  \
  \ nonfull-display  ( -- )
  \
  \ Set the nonfull screen mode: 2 lines in the lower screen
  \ and 22 lines in the upper main screen, which is the default
  \ configuration in BASIC.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: full-display  ( -- )  0 23659 c!  ;

  \ doc{
  \
  \ full-display  ( -- )
  \
  \ Set the full screen mode: no lines in the lower screen,
  \ thus 24 lines in the upper main screen, which is the
  \ default configuration in Solo Forth.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: save-display  ( -- ) ( R: -- col row )
  r> xy 2>r >r save-mode nonfull-display  ;

  \ doc{
  \
  \ save-display  ( -- ) ( R: -- col row )
  \
  \ Save the status of the display.  This word is intended to
  \ be used before calling a ROM routine that uses the display.
  \ The display can be restored to its previous status with
  \ `restore-display`.
  \
  \ }doc

: restore-display  ( -- ) ( R: col row -- )
  display full-display restore-mode  r> 2r> at-xy >r  ;

  \ doc{
  \
  \ restore-display  ( -- ) ( R: col row -- )
  \
  \ Restore the status of the display, saved by `save-display`.
  \ Intended to be used after calling a ROM routine that uses
  \ the display.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.g-emit.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610111954

  \ -----------------------------------------------------------
  \ Description

  \ Words to print characters at high resolution coordinates.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-03: First version.
  \
  \ 2016-04-23: Rename "hires-" prefix to "g-". Rename
  \ `g-emit-udg` to `g-emit-0udg`, because zero-index is used,
  \ instead of the default UDG char codes 128..255. Add
  \ `g-emit-udg` for codes 128..255. Improve documentation.
  \ First versions of `g-emitted` and `g-cr`.
  \
  \ 2016-10-11: Add `first-udg`.

( g-emit g-type )


  \ XXX TODO -- `g-emit` use the current coordinates

need z80-asm  need g-emit-routine  need g-emit-udg
need os-chars  need os-coords  need g-emitted

code (g-emit)  ( c -- )

  hl pop  l a ld
  bc push
  os-coords bc ftp
  os-chars de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit  ( c -- )
  \
  \ Display character _c_ (32..127) at the current graphic
  \ coordinates.
  \
  \ The character is printed with overprinting (equivalent to `1
  \ overprint`).
  \
  \ }doc

: g-emit  ( c -- )
  dup 127 > if  g-emit-udg  else  (g-emit)  then
  g-emitted  ;

  \ XXX TODO -- update the coordinates

  \ doc{
  \
  \ g-emit  ( gx gy c -- )
  \
  \ Display character _c_ (32..255) at the current graphic
  \ coordinates.  If _c_ is 32..127, it is printed from the
  \ main font.  If _c_ is 128..255, it is printed from the UDG
  \ font.
  \
  \ The character is printed with overprinting (equivalent to `1
  \ overprint`).
  \
  \ }doc

: g-type  ( ca len -- )
  bounds ?do  i c@ g-emit  loop  drop  ;

  \ doc{
  \
  \ g-type  ( ca len -- )
  \
  \ If _len_ is greater than zero, display the character string
  \ _ca len_ at the current graphic coordinates.
  \
  \ }doc

( g-cr g-emitted )

  \ XXX UNDER DEVELOPMENT

need g-x  need g-y
need g-at-x  need g-at-y
need c+!  need c-!

: g-cr  ( -- )
  0 g-at-x  8 (g-y) c-!  g-y 6 > ?exit  191 g-at-y  ;

  \ Move the graphic coordinates to the next printing
  \ position.

: g-emitted  ( -- )
  8 (g-x) c+!  g-x [ 255 6 - ] literal < ?exit  g-cr  ;

  \ Update the current graphic coordinates after printing a
  \ character at them. See `g-emit`, `g-cr`.

( g-emit-0udg )

need z80-asm  need g-emit-routine  need os-udg  need os-coords

code g-emit-0udg  ( gx gy b -- )

  hl pop  l a ld
  bc push
  os-coords bc ftp
  os-udg de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit-0udg  ( gx gy b -- )
  \
  \ Display UDG _b_ (0..255) at the current graphic
  \ coordinates, from the font pointed by system variable
  \ `os-udg`, which contains the address of the first UDG
  \ bitmap (0).
  \
  \ The UDG character is printed with overprinting (equivalent
  \ to `1 overprint`).
  \
  \ }doc

( g-emit-udg )

need z80-asm  need g-emit-routine  need os-udg  need os-coords

[defined] first-udg ?\ #128 constant first-udg

code g-emit-udg  ( c -- )

  hl pop  l a ld  first-udg sub#
  bc push
  os-coords bc ftp
  os-udg de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit-udg  ( gx gy c -- )
  \
  \ Display UDG _c_ (128..255) at the current graphic
  \ coordinates, from the font pointed by system variable
  \ `os-udg`, which contains the address of the first UDG
  \ bitmap (128).
  \
  \ The UDG character is printed with overprinting (equivalent
  \ to `1 overprint`).
  \
  \ }doc

( g-emit-routine )

need z80-asm  need (pixel-addr)

  \ Credit:
  \
  \ Code Adapted from "Smooth Move",
  \ written by Simon N. Goodwin,
  \ published on Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create g-emit-routine  ( -- a )

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

  \ doc{
  \
  \ g-emit-routine  ( -- a )
  \
  \ Address of a machine code routine that prints an 8x8 bits
  \ charater at graphic coordinates. Used by `g-emit-udg`
  \ and `g-emit-0udg`.
  \
  \ Input registers:
  \
  \ - DE = address of the first char (0) bitmap in a charset
  \ - A = char code (0..255)
  \ - B = y coordinate
  \ - C = x coordinate
  \
  \ Modifies: AF BC HL IX DE
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.g-xy.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604231943

  \ -----------------------------------------------------------
  \ Description

  \ Words to manage the graphic coordinates.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-23: First version.

( g-x g-y g-xy g-at-x g-at-y g-at-xy g-home )

need os-coords  need os-coordx  need os-coordy  need alias

' os-coords alias (g-xy)
' os-coordx alias (g-x)
' os-coordy alias (g-y)

: g-x  ( -- gx )  (g-x) c@  ;
: g-y  ( -- gy )  (g-y) c@  ;

: g-xy  ( -- gx gy )  g-x g-y  ;

: g-at-x  ( gx -- )  (g-x) c!  ;
: g-at-y  ( gy -- )  (g-y) c!  ;

: g-at-xy  ( gx gy -- )  g-at-y g-at-x  ;

: g-home  ( -- )  (g-xy) off  ;

  \ vim: filetype=soloforth
  \ graphics.lines.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070026

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw lines.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Make block titles compatible with `indexer`.

( rdraw )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( gx gy -- )

  \ Draw a line relative to the current coordinates.
  \
  \ gx gy = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

( (rdraw )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- finish adapting the DRAW-LINE ROM routine

need z80-asm

create (rdraw
asm


  \  ld      a,c
  \  cp      b
  \  jr      nc,dl_x_ge_y
  \
  \  ld      l,c
  \  push    de
  \  xor     a
  \  ld      e,a
  \  jr      dl_larger
  \
  \ dl_x_ge_y:
  \  or      c
  \  ret     z
  \
  \  ld      l,b
  \  ld      b,c
  \  push    de
  \  ld      d,$00
  \
  \ dl_larger:
  \  ld      h,b
  \  ld      a,b
  \  rra
  \
  \ d_l_loop:
  \  add     a,l
  \  jr      c,d_l_diag
  \
  \  cp      h
  \  jr      c,d_l_hr_vt
  \
  \ d_l_diag:
  \  sub     h
  \  ld      c,a
  \  exx
  \  pop     bc
  \  push    bc
  \  jr      d_l_step
  \
  \ d_l_hr_vt:
  \  ld      c,a
  \  push    de
  \  exx
  \  pop     bc
  \
  \ d_l_step:
  \  ld      hl,($5c7d) ; coords
  \  ld      a,b
  \  add     a,h
  \  ld      b,a
  \  ld      a,c
  \  inc     a
  \  add     a,l
  \  jr      c,d_l_range
  \  jr      z,report_bc ; XXX TODO -- adapt, integer out of range
  \
  \ d_l_plot:
  \  dec     a
  \  ld      c,a
  \  call    l22e5      ; routine plot-sub \ XXX TODO
  \ XXX TODO -- replace `call PLOT-SUB` with `call PLOT-SUB+7`
  \  exx
  \  ld      a,c
  \  djnz    d_l_loop
  \
  \  pop     de
  \  ret
  \
  \ d_l_range:
  \  jr      z,d_l_plot

end-asm

( adraw )

  \ Credit:
  \
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot  need os-coordx  need os-coordy

2variable x1  2variable incx  2variable y1  2variable incy

: adraw  ( gx gy -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  [ os-coordy ] literal c@ ( y0 )
  dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )

  [ os-coordx ] literal c@ ( x0 )
  dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )

  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  -->

( adraw )

  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

  \ vim: filetype=soloforth
  \ graphics.ocr.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that recognize characters on the
  \ screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( ocr )

  \ Credit:
  \
  \ Adapted from anonymous code published on Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  jppushhl  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

need os-chars  need os-udg

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  os-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ set pointed by the system variable UDG.
  os-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

  \ vim: filetype=soloforth
  \ graphics.pixels.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610151658

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate pixels.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-10-15: Make `(pixel-addr)` deferred. Rename previous
  \ versions to `slow-(pixel-addr)` and `fast-(pixel-addr)`.
  \ This way the application can choose the version associated
  \ to `(pixel-addr)`, which will be used by other words.
  \
  \ 2016-10-15: Make `pixels` deferred. Rename previous
  \ versions to `slow-pixels` and `fast-pixels`.  This way the
  \ application can choose the version associated to `pixels`.
  \
  \ 2016-10-15: Add `bitmap>attr-addr`, `pixel-attr-addr`.

\ (pixel-addr) slow-(pixel-addr) \

[defined] (pixel-addr) ?\ defer (pixel-addr)

create slow-(pixel-addr)  ( -- a )
  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

' slow-(pixel-addr) ' (pixel-addr) defer!

  \ doc{
  \
  \ slow-(pixel-addr)  ( -- a )
  \
  \ Return address _a_ of an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.
  \
  \ This is the default behaviour of `(pixel-addr)`. When
  \ `fast-(pixel-addr)` (which is faster but bigger, and
  \ requires the assembler) is needed, the application must use
  \ `need fast-(pixel-addr)` before `need set-pixel` or any
  \ other word that needs `(pixel-addr)`.
  \
  \ Input registers:
  \
  \ - C = x cordinate (0..255)
  \ - B = y coordinate (0..191)
  \
  \ Output registers:
  \
  \ - HL = address of the pixel byte in the screen bitmap
  \ - A = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.
  \
  \ }doc

  \ doc{
  \
  \ (pixel-addr)  ( -- a )
  \
  \ A deferred word that executes `fast-(pixel-addr)` or
  \ `slow-(pixel-addr)`.  Return address _a_ of an alternative
  \ to the "pixel-add" ROM routine (0x22AA), to let the range
  \ of the y coordinate to be 0..191 instead of 0..175.
  \
  \ See: `fast-(pixel-addr)`, `slow-(pixel-addr)`.
  \
  \ }doc

\ (pixel-addr) fast-(pixel-addr) \

need z80-asm

[defined] (pixel-addr) ?\ defer (pixel-addr)

create fast-(pixel-addr)  ( -- a )

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

' fast-(pixel-addr) ' (pixel-addr) defer!

  \ doc{
  \
  \ fast-(pixel-addr)  ( -- a )
  \
  \ Return address _a_ of a a modified copy of the "pixel-add"
  \ ROM routine (0x22AA), to let the range of the y coordinate
  \ to be 0..191 instead of 0..175. This code is a bit faster
  \ than `slow-(pixel-addr)` because the necessary jump to the
  \ ROM is saved and a useless `and a` has been removed. But in
  \ most cases the speed gain is so small (only 0.01: see
  \ `set-pixel-bench`) that it's not worth the extra space,
  \ including the assembler.
  \
  \ Input registers:
  \
  \ - C = x cordinate (0..255)
  \ - B = y coordinate (0..191)
  \
  \ Output registers:
  \
  \ - HL = address of the pixel byte in the screen bitmap
  \ - A = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.
  \
  \ }doc

( pixel-addr )

need (pixel-addr)

code pixel-addr  ( gx gy -- n a )
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,    \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

  \ doc{
  \
  \ pixel-addr  ( gx gy -- n a )
  \
  \ Return screen address _a_ and pixel position _n_ (0..7) of
  \ pixel coordinates _gx_ (0..255) and _gy_ (0..191).
  \
  \ }doc

( plot )

need (pixel-addr)

code plot  ( gx gy -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

need (pixel-addr)  need z80-asm

code set-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

  \ doc{
  \
  \ set-pixel  ( gx gy -- )
  \
  \ Set a pixel without changing the color attributes.
  \
  \ }doc

  \ Credit:
  \
  \ Author of the original code: Jos Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

( reset-pixel )

need (pixel-addr)  need z80-asm

code reset-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

  \ doc{
  \
  \ reset-pixel  ( gx gy -- )
  \
  \ Reset a pixel without changing the color attributes.
  \
  \ }doc

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

( toggle-pixel )

need (pixel-addr)  need z80-asm

code toggle-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

  \ doc{
  \
  \ toggle-pixel  ( gx gy -- )
  \
  \ Toggle a pixel without changing the color attributes.
  \
  \ }doc

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( gx gy -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true jpnz
  ' false jp
  end-code

( pixels fast-pixels )

need z80-asm  [defined] pixels ?\ defer pixels

code fast-pixels  ( -- n )

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code  ' fast-pixels ' pixels defer!

  \ doc{
  \
  \ pixels  ( -- n )
  \
  \ Return the number _n_ of pixels set on the screen.
  \ This is a deferred word associated `fast-pixels`
  \ or `slow-pixels`.
  \
  \ See: `fast-pixels`, `slow-pixels`.
  \
  \ }doc

  \ doc{
  \
  \ fast-pixels  ( -- n )
  \
  \ Return the number _n_ of pixels set on the screen.
  \ This is the default behaviour of `pixels`.
  \
  \ See: `pixels`, `slow-pixels`.
  \
  \ }doc

  \ 26 bytes used.

  \ Credit:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret

( pixels slow-pixels )

  \ Slower version of `pixels`.

need bits

[defined] pixels ?\ defer pixels

: slow-pixels  ( -- n )  16384 6144 bits  ;

' slow-pixels ' pixels defer!

  \ doc{
  \
  \ slow-pixels  ( -- n )
  \
  \ Return the number _n_ of pixels set on the screen.  This is
  \ the alternative behaviour of the deferred word `pixels`.
  \
  \ See: `pixels`, `fast-pixels`.
  \
  \ }doc

( bitmap>attr-addr pixel-attr-addr )

need ?(

[defined] bitmap>attr-addr ?(

code bitmap>attr-addr  ( a1 -- a2 )
  E1 c,  78 04 + c,
    \ pop hl
    \ ld a,h ; fetch high byte $40..$57
  0F c, 0F c, 0F c,
    \ rrca
    \ rrca
    \ rrca ; shift bits 3 and 4 to right
  E6 c, 03 c,  F6 c, 58 c,  60 07 + c,
    \ and $03 ; range is now 0..2
    \ or $58 ; form correct high byte for third of screen
    \ ld h,a
  jppushhl  end-code  ?)

  \ doc{
  \
  \ bitmap>attr-addr  ( a1 -- a2 )
  \
  \ Convert screen bitmap address _a1_ to its correspondent
  \ attributes address _a2_.
  \
  \ }doc
  \
  \ Credit:
  \
  \ The code is extracted from the PO-ATTR ROM routine
  \ (at $0BDB).

[unneeded] pixel-attr-addr ?exit

need pixel-addr

: pixel-attr-addr  ( gx gy -- a )
  pixel-addr nip bitmap>attr-addr  ;

  \ doc{
  \
  \ pixel-attr-addr  ( gx gy -- a )
  \
  \ Convert pixel coordinates _gx gy_ to their correspondent
  \ attributes address _a_.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.screen_filters.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that make filter effects to the
  \ whole screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 46: <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credit:
  \
  \ Code adapted from a routine written by Javier Granadino,
  \ published on Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credit:
  \
  \ Code adapted from a routine written by Juan Jos Rivas,
  \ published on Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
           begin   m rrc  hl decp  h 6 bit  z until
  step

  bc pop  jpnext

  end-code

  \ vim: filetype=soloforth
  \ graphics.scroll.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to scroll the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( scroll-1px-right )

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
    m srl  hl incp  \ first char column
    1F b ld#  \ remaining columns
    begin   m rr  hl incp  step
    c dec
  z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credit:
  \
  \ Code adapted from a routine written by Ivn Sansa,
  \ published on Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.udg.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610111959

  \ -----------------------------------------------------------
  \ Description

  \ Words to define User Defined Graphics.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-23: Add `0udg:`. Factor `0udg!` from `udg!`.
  \ Improve the documentation.
  \
  \ 2016-04-24: Add `udg[` and `0udg[`.
  \
  \ 2016-10-11: Add `udg-row[`.

( 0udg! udg! 0udg: udg: )

need os-udg

[defined] first-udg ?\ #128 constant first-udg

: 0udg!  ( b0..b7 n -- )
  8 * os-udg @ + dup 7 + do  i c!  -1 +loop  ;

  \ doc{
  \
  \ udg!  ( b0..b7 n -- )
  \
  \ Store the given 8 bytes into UDG number _n_ (0..127).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg!  ( b0..b7 c -- )  first-udg - 0udg!  ;

  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into UDG char _c_ (128..255).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;

  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant "name" for UDG char _c_ (128..255) and
  \ store the given 8 bytes into that UDG char.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: 0udg:  ( b0..b7 n "name" -- )  dup constant 0udg!  ;

  \ doc{
  \
  \ 0udg:  ( b0..b7 n "name" -- )
  \
  \ Create a constant "name" for UDG number _n_ (0..127) and
  \ store the given 8 bytes into UDG char _128+n_.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

( 0udg[ udg[ )

need os-udg

[defined] first-udg ?\ #128 constant first-udg
variable udg0
variable current-udg
variable current-scan

[defined] binary ?\  : binary  ( -- )  2 base !  ;

: 0udg[  ( b -- )
  dup udg0 !  current-udg !  current-scan off  binary  ;

  \ doc{
  \
  \ 0udg[  ( b -- )
  \
  \ Start a set of UDG definitions, from UDG number _b_
  \ (0..255).
  \
  \ See: `udg[`, `|`, `||`, `||]`.
  \
  \ }doc

: udg[  ( c -- )  first-udg - 0udg[  ;

  \ doc{
  \
  \ udg[  ( c -- )
  \
  \ Start a set of UDG definitions, from UDG character _c_
  \ (128..255).
  \
  \ See: `0udg[`, `|`, `||`, `||]`.
  \
  \ Usage example:
  \
  \ ----
  \ 140 udg[  \ define UDG 140..144
  \
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01011110 ||
  \ 11111111 | 11111111 | 11111111 | 10111111 | 10111111 ||
  \ 11111111 | 11111111 | 10111111 | 10111111 | 11111111 ||
  \ 11111111 | 10111111 | 10111111 | 11111111 | 11111111 ||
  \ 11001111 | 11011111 | 11111111 | 11111111 | 11111111 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||]
  \ ----
  \
  \ }doc

: |  ( b -- )
  os-udg @ current-udg @ 8 * current-scan @ + + c!
  1 current-udg +!  ;

  \ doc{
  \
  \ |  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined.
  \
  \ See: `0udg[`, `udg[`, `||`, `||]`.
  \
  \ }doc

: || ( b -- )
  |  1 current-scan +!  udg0 @ current-udg !  ;

  \ doc{
  \
  \ || ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and start
  \ a new row of scans.
  \
  \ See: `0udg[`, `udg[`, `|`, `||]`.
  \
  \ }doc


: ||]  ( b -- )  ||  decimal  ;

  \ doc{
  \
  \ ||]  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and stop
  \ defining UDGs.
  \
  \ See: `0udg[`, `udg[`, `|`, `||`.
  \
  \ }doc

( udg-block[ )

  \ XXX UNDER DEVELOPMENT
  \ 2016-10-04

need s=

: udg-block[  ( c "ccc" -- )
  begin   parse-name 2dup s" ]udg-block" compare
  while   dup 8 mod dup abort" Wrong scan length"

  repeat  ;

: ]udg-block ;

  \ doc{
  \
  \ udg-block[  ( c "ccc" -- )
  \
  \ Start a set of UDG definitions that form a sprite, from UDG
  \ character _c_ (128..255).

  \ Usage example:
  \
  \ ----
  \ 140 udg-block[
  \
  \ 0011110000111100001111000011110000111100
  \ 0111111001111110011111100111111001011110
  \ 1111111111111111111111111011111110111111
  \ 1111111111111111101111111011111111111111
  \ 1111111110111111101111111111111111111111
  \ 1100111111011111111111111111111111111111
  \ 0111111001111110011111100111111001111110
  \ 0011110000111100001111000011110000111100
  \
  \ ]udg-block
  \ ----
  \
  \ }doc

( udg-row[ )

need os-udg  need evaluate
[defined] binary  ?\ : binary  ( -- )  2 base !  ;

8 constant udg-height  8 constant udg-width
  \ height in bytes (scans)
  \ width in pixels

variable udg-row-height  variable udg-row-width
  \ height in scans
  \ width in characters

variable udg-row-first-udg

: ?block-scan-length  ( n -- )
  dup udg-width mod abort" Wrong block scan length"
  udg-width / udg-row-width @ ?dup
  if    <> abort" Wrong block width"
          \ not the first scan, so check the width
  else  udg-row-width !  then  ;
          \ first scan, so save the width

: udg-row-current-row  ( -- n )
  udg-row-height @ udg-height /  ;

: udg-current-scan  ( -- n )
  udg-row-height @ udg-height mod  ;  -->

( udg-row[ )

[defined] first-udg ?\ #128 constant first-udg

: >udg-scan  ( n -- a )
  udg-height * udg-current-scan +
  udg-row-first-udg @ first-udg - udg-height * +  os-udg @ +  ;
  \ Convert column _n_ of the current UDG row to address _a_
  \ of the scan of the current UDG.

: udg-scan!  ( b n -- )  >udg-scan c!  ;
  \ Store UDG scan _b_, which is at column _n_ of the current UDG
  \ block.

: udg-row-scan  ( ca len -- )
  base @ >r binary  dup ?block-scan-length
  dup udg-width / 0 do  over udg-width
    evaluate i udg-scan!  udg-width /string
  loop  2drop  r> base !  1 udg-row-height +!  ;
  \ Manage a UDG row scan _ca len_, extracting the individual
  \ UDG scans from it.

: ]udg-row  ( ca len -- )
  2drop  udg-row-height @ udg-height <>
  abort" The height of the UDG row is wrong"  ;
  \ End a UDG row. Check its height.

: udg-row-scan?  ( ca len -- f )  s" ]udg-row" compare 0<>  ;
  \ Is the string _ca len_ a UDG row scan
  \ instead of the end of the UDG row?

-->

( udg-row[ )

: parse-udg-row-scan  ( "ccc" -- ca len )
  begin   parse-name dup 0=
  while   2drop refill 0= abort" UDG row scan is missing"
  repeat  ;

: udg-row[  ( c "ccc" -- )
  udg-row-first-udg !  udg-row-height off  udg-row-width off
  begin   parse-udg-row-scan 2dup udg-row-scan?
  while   udg-row-scan
  repeat  ]udg-row  ;

  \ doc{
  \
  \ udg-row[  ( c "ccc" -- )
  \
  \ Start a UDG row (a graphic formed by a row of UDG). Parse
  \ its scans, extract the individual UDG scans and store them
  \ starting from UDG code _c_ (128..255).

  \ Usage example:
  \
  \ ----
  \ 140 udg-row[
  \
  \ 0011110000111100001111000011110000111100
  \ 0111111001111110011111100111111001011110
  \ 1111111111111111111111111011111110111111
  \ 1111111111111111101111111011111111111111
  \ 1111111110111111101111111111111111111111
  \ 1100111111011111111111111111111111111111
  \ 0111111001111110011111100111111001111110
  \ 0011110000111100001111000011110000111100
  \
  \ ]udg-row
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ keyboard.casp_lock.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to manipulate caps lock.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( capslock )

need os-flags2
need c!toggle-bits  need c@test-bits
need c!reset-bits   need c!reset-bits

%1000 os-flags2 2constant capslock
  \ Bit and system variable that control the capslock.

: toggle-capslock  ( -- )    capslock c!toggle-bits  ;
: set-capslock     ( -- )    capslock c!set-bits  ;
: unset-capslock   ( -- )    capslock c!reset-bits  ;
: capslock?        ( -- f )  capslock c@test-bits 0<>  ;

  \ vim: filetype=soloforth
  \ keyboard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605132207

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the keyboard.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.

( at-accept clear-accept set-accept )

  \ XXX UNDER DEVELOPMENT
  \ Common code for several versions of `accept`
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

2variable accept-xy       \ coordinates of the edited string
  \ doc{
  \
  \ accept-xy  ( -- a )
  \
  \ A double variable that holds the cursor position at the
  \ start of the most recent `accept`.
  \
  \ }doc

variable accept-buffer    \ address of the edited string
  \ doc{
  \
  \ accept-buffer  ( -- a )
  \
  \ A variable that holds the buffer address used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable /accept          \ max length of the edited string
  \ doc{
  \
  \ /accept  ( -- a )
  \
  \ A variable that holds the buffer max length used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable >accept          \ offset to the cursor position
  \ doc{
  \
  \ >accept  ( -- a )
  \
  \ A variable that holds the offset of the cursor in the
  \ string being edited by `accept`.
  \
  \ }doc

: at-accept  ( -- )  accept-xy 2@ at-xy  ;
  \ doc{
  \
  \ at-accept  ( -- )
  \
  \ Set the cursor position at the start of the most recent
  \ `accept`.
  \
  \ }doc

: clear-accept  ( -- )
  at-accept span @ spaces at-accept  span off  ;
  \ doc{
  \
  \ clear-accept ( -- )
  \
  \ Clear the string currently edited by `accept`.
  \
  \ }doc

: set-accept  ( ca1 len1 -- ca1' )
  clear-accept /accept @ min  ( ca1 len1' )
  dup span ! 2dup system-bank type default-bank
  dup >r
  accept-buffer @  ( ca1 len1' ca2 )
  smove accept-buffer @  ( ca2 )
  r> +  ( ca1' )  ;
  \ doc{
  \
  \ set-accept  ( ca1 len1 -- ca1' )
  \
  \ Set string _ca len_ as the string being edited by `accept`.
  \ Return the address _ca1'_ after its last character.
  \
  \ }doc

( acceptx )

  \ XXX UNDER DEVELOPMENT
  \
  \ Alternative version of `accept` with more editing features
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

need at-accept  need set-accept

: .acceptx  ( -- )

  accept-buffer @ >accept @ at-accept type
    \ Print the start of the string, before the cursor.

  1 inverse  >accept @ span @ <
  if accept-buffer @ >accept @ + c@ emit  else  space  then
  0 inverse
    \ Print the cursor.

  accept-buffer @ span @ >accept @ 1+ min /string type
    \ Print the end of the string, after the cursor.
  ;

-->

( acceptx )

need toggle-capslock

: accept-edit  ( -- )  clear-accept init-accept  ;
: accept-left  ( -- )  ;
: accept-right  ( -- )  ;
: accept-up  ( -- )  ;
: accept-down  ( -- )  ;
: accept-delete  ( -- )  ;

create accept-commands ] noop noop noop noop noop noop
toogle-capslock accept-edit accept-left accept-right
accept-down accept-up accept-delete noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop [

: >accept-command  ( c -- a )  cells accept-commands +  ;
: accept-command  ( c -- )  >accept-command perform  ;

-->

( acceptx )

: init-acceptx  ( ca len -- )
  /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;

: (acceptx) ( ca len -- len' )  2dup init-accept

  over + over ( bot eot cur )
  begin  key dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;  -->

( acceptx )

: acceptx ( ca len -- len' )
  span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;

  \ XXX TMP -- for debugging

: ax  ( -- )  ['] acceptx ['] accept defer!  ;
: a0  ( -- )  ['] default-accept ['] accept defer!  ;

( nuf? )

  \ Credit:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29, 1988-05).

need aborted?  need 'cr'

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's _c_, else return _false_.
  \
  \ This word is a useful factor of `nuf?`.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( kk-ports kk, kk@ )

  \ Adapted from Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \
  \ "kk" stands for "keyboard key". This notation was chosen
  \ first in order to prevent future name clashes with standard
  \ words which uses the "k-" prefix, and second because these
  \ words manage only physical keys of the keyboard, not key
  \ combinations.
  \
  \ -----------------------------------------------------------

  \ There are two versions of `kk,` and `kk@`. They depend on
  \ the value of `/kk`, a constant that holds the bytes
  \ ocuppied by every key in `kk-ports`, 3 or 4.
  \
  \ The application must define `/kk` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/kk 3 <> dup

?\ : kk,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `kk@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/kk 4 <> dup

?\ : kk,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( kk-ports )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2
$04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4
$10 $F7FE 2constant kk-5

$01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w
$04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r
$10 $FBFE 2constant kk-t

$01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s
$04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f
$10 $FDFE 2constant kk-g

$01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z
$04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c
$10 $FDFE 2constant kk-v

-->

( kk-ports )

$01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9
$04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7
$10 $EFFE 2constant kk-6

$01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o
$04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u
$10 $DFFE 2constant kk-y

$01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l
$04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j
$10 $BFFE 2constant kk-h

$01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss
$04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n
$10 $7FFE 2constant kk-b

-->

( kk-ports )

  \ This table contains the key double constants (port and
  \ bitmak) of all keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

need kk,

40 constant keys

create kk-ports

kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,
kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,
kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,
kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,
kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,
kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,
kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,
kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,

( kk-1# )

  \ Key number constants, to be used as indexes of the key
  \ tables.

need enum

0
enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#
enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#
enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#
enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#
enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#
enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#
enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#
enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#
drop

( kk-chars )

  \ This table contains the chars used as names of the keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

  \ By default, the first 4 UDG are used for keys whose names
  \ are not a printable char:
  \
  \ 128 = Caps Shift
  \ 129 = Enter
  \ 130 = Space
  \ 131 = Symbol Shift

create kk-chars

'1' c,  '2' c,  '3' c,  '4' c,  '5' c,
'q' c,  'w' c,  'e' c,  'r' c,  't' c,
'a' c,  's' c,  'd' c,  'f' c,  'g' c,
128 c,  'z' c,  'x' c,  'c' c,  'v' c,
'0' c,  '9' c,  '8' c,  '7' c,  '6' c,
'p' c,  'o' c,  'i' c,  'u' c,  'y' c,
129 c,  'l' c,  'k' c,  'j' c,  'h' c,
130 c,  131 c,  'm' c,  'n' c,  'b' c,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need kk-ports

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need kk-ports

0. 2variable kk-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. kk-pressed 2! \ none by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed?
  if  kk-pressed 2@ + if
  then
  /kk +loop
  kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ vim: filetype=soloforth
  \ keyboard.get-inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-inkey )

  \ Credit:
  \
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code get-inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

  \ vim: filetype=soloforth
  \ keyboard.get-key-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-key?` and `fast-get-key?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false jp

  end-code

( fast-get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code fast-get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false jp

  end-code

  \ keyboard.inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

  \ vim: filetype=soloforth
  \ keyboard.yes-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words for "yes/no" questions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( y/n? y/n no? yes? )

  \ Credit:
  \
  \ Code adapted from Afera.

need value

'Y' value "y"  'N' value "n"
  \ Default (uppercase) letters for "yes" and "no".

: y/n?  ( c -- f )  dup "y" = swap "n" = or  ;
  \ Is the given (uppercase) char _c_
  \ a valid answer for a "y/n" question?

: y/n  ( -- c )
  begin  key upper dup y/n? 0=  while  drop  repeat  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return its code.

: no?  ( -- f )  y/n "n" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "no",
  \ else return _false_.

: yes?  ( -- f )  y/n "y" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "yes",
  \ else return _false_.

  \ vim: filetype=soloforth
  \ locals.anon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170056

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of locals using an array of anonymous
  \ variables.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code written by Leonard Morgenstern, published on
  \ Forth Dimensions (volume 6, number 1, page 33, 1984-05).
  \
  \ Adapted, modified, improved and commented by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Adapted from the original code.
  \ 2016-04-09: Fixed the file header.
  \ 2016-05-17: Need `body>`, which has been moved to the
  \ library.

( create-anon anon +anon n>anon )

need body>

variable (anon)  ( -- a )
  \ xt of the latest anonymous variable.

: create-anon  ( -- )
  here (anon) !
  [ (anon) body> @ ] literal compile, 0 ,  ;
  \ Create a new anonymous variable.  `(anon)` is used to get
  \ and compile the xt executed by all variables.

: anon  ( Compilation: -- ) ( Run-time: -- a )
  (anon) @
  compiling? if  compile,  else  execute  then  ; immediate
  \ Current anonymous variable (first cell),
  \ equivalent to `0 +anon`.

: +anon  ( Compilation:  n -- ) ( Run-time: -- )
  cells (anon) @ execute +
  compiling? if  postpone literal  then ; immediate
  \ Current anonymous variable (cell _n_, first is 0).

: n>anon  ( x1..xn n -- )
  cells postpone anon swap bounds do  i !  cell +loop  ;
  \ Store the given _n_ cells into the current anonymous
  \ variable.

  \ Usage example:

  \ create-anon 5 cells allot
  \
  \ : test
  \   400 300 200 100 000  5 n>anon
  \   anon ?          \ prints 0
  \   123 anon !
  \   anon ?          \ prints 123
  \   [ 2 ] +anon ?   \ prints 200
  \   555 [ 2 ] +anon !
  \   [ 2 ] +anon ?   \ prints 555
  \   ;

  \ vim: filetype=soloforth
  \ locals.arguments.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604091850

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of nestable locals, with a predefined set
  \ of ten variables which return their contents.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Marc Perkel, published on Forth Dimensions
  \ (volume 3, number 6, page 185, 1982-03).
  \
  \ Adapted to Solo Forth and improved by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Start.
  \ 2016-04-09: Fixed, improved, renamed, documented, finished.

( arguments results )

need cell/

variable >args
  \ address of the current arguments in the data stack

create arg-actions ] @ ! +! [
  \ execution table of the argument actions

variable arg-action  arg-action off
  \ id (offset) of the argument action:
  \ 0 = fetch; 2 (1 cell) = store; 4 (2 cells) = add

: arg:  ( +n "name" -- )
  create  c,
  does>  ( -- x ) ( x -- )
    \ ( pfa | x pfa )
    c@ >args @ swap -
    arg-action @ arg-actions + perform  arg-action off  ;
  \ create a new argument "name" with offset _+n_

$00 arg: l0 $02 arg: l1 $04 arg: l2 $06 arg: l3 $08 arg: l4
$0A arg: l5 $0C arg: l6 $0E arg: l7 $10 arg: l8 $12 arg: l9

-->

( arguments results )

: toarg  ( -- )  cell arg-action !  ;

  \ doc{
  \
  \ toarg  ( -- )
  \
  \ Set the store action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: +toarg  ( -- )  [ 2 cells ] literal arg-action !  ;

  \ doc{
  \
  \ +toarg  ( -- )
  \
  \ Set the add action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: arguments  ( i*x +n -- j*x )
  r> >args @ >r >r
  cells sp@ + dup >args ! [ 10 cells ] literal - sp@ swap -
  cell/ 0 do  0  loop  ; compile-only

  \ doc{
  \
  \ arguments  ( i*x +n -- j*x )
  \
  \ Define the number _+n_ of arguments to take from the stack
  \ and assign them to the first local variables from `l0` to
  \ `l9`.
  \
  \ The local variables are modified with `toarg`, `+toarg`,
  \ and returned  with `results`.
  \
  \ Example: The phrase `3 arguments` assigns the names of
  \ local variables `l0` through `l9` to ten stack positions,
  \ with `l0`, `l1` and `l2` returning the top 3 stack values
  \ that were there before `3 arguments` was executed. `l3`
  \ through `l9` are zero-filled and the stack pointer is set
  \ to just below `l9`.
  \
  \ `l0` through `l9` act as local variables returning their
  \ contents, not their addresses.  To write them you precede
  \ them with the word `toarg`. For example `5 toarg l4` writes
  \ a 5 into `l4`. Execution of `l4` returns 5 to the stack.
  \
  \ After all calculating is done, the phrase `3 results`
  \ leaves that many results on the stack relative to the stack
  \ position when `arguments` was executed. All intermediate
  \ stack values are lost, which is good because you can leave
  \ the stack "dirty" and it doesn't matter.
  \
  \ Usage example:

  \ ----
  \ : test  ( length width height -- length' volume surface )
  \   3 arguments
  \   l0 l1 * toarg l5       \ surface
  \   l5 l2 * toarg l4       \ volume
  \   $2000 +toarg l0        \ length+$2000
  \   l4 toarg l1            \ volume
  \   l5 toarg l2            \ surface
  \   3 results  ;
  \ ----

  \ }doc

: results  ( +n -- )
  cells >args @ swap - sp@ -
  cell/ 0 do  drop  loop
  r> r> >args ! >r  ; compile-only

  \ doc{
  \
  \ results  ( +n -- )
  \
  \ Define the number _+n_ of local variables to leave on the
  \ stack as results. Used with locals created by `arguments`.
  \ See `arguments` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ locals.local.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170051

  \ -----------------------------------------------------------
  \ Description

  \ A simple solution to use an ordinary variable as local,
  \ saving its current value on the return stack and restoring
  \ it at the end.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Henning Hanseng, published on Forth
  \ Dimensions (volume 9, number 5, page 6, 1988-01).
  \
  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Adapted from the original code.
  \
  \ 2016-03-24: An alternative implementation with `:noname`.
  \
  \ 2016-04-24: Add `need :noname`, because `:noname` has been
  \ moved from the kernel to the library.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( local )

need :noname  need >body

:noname  \ Compilation: ( -- xt )
         \ Run-time:    ( -- ) ( R: a x -- )
  2r> swap !  ;
  \ Restore variable address _a_ and value _x_.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token to restore the variable
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap                     \ save top return address
  dup @ 2>r                   \ save variable address and value
  [ dup >body ] literal >r    \ force exit via `restore-local`
  >r  ;                       \ restore top return address
  compile-only

  drop  \ delete xt

  \ doc{
  \
  \ local  ( a -- )
  \
  \ Save the value of variable _a_, which will be restored at
  \ the end of the current definition.
  \
  \ Usage example:

  \ ----
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value
  \ ----
  \
  \ }doc

( local )

  \ XXX OLD
  \ 2015-11-14: First port of the original.

: (restore-local)  ( -- )  ( R: a x -- )  2r> swap !  ;
  \ Restore value _x_ of variable _a_.
  \ Can not be used directly.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token of `restore-local`
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap  dup @ 2>r
    \ save return address
    \ save variable address and value
  ['] (restore-local) >body >r  >r  ;  compile-only
    \ force exit via `(restore-local)`
    \ restore return address

  \ vim: filetype=soloforth
  \ math.calculator.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604201956

  \ -----------------------------------------------------------
  \ Description

  \ ROM calculator support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development, as part of the
  \ floating-point module.
  \
  \ 2016-04-11: Revision. Code reorganized. Improvements.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Extracted the code from the floating-point
  \ module, in order to reuse it. Much improved. Added `if then
  \ else`. Added `int`.
  \
  \ 2016-04-20: Improved `2dup`. Commented out `=`, `<>`, `<`,
  \ `<=`, `>` and `>=`, which can not be used yet.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Move the stack and make it configurable. The
  \ default location is limited by the small free memory left
  \ to BASIC.
  \
  \ XXX FIXME -- When the calculator stack is out of bounds,
  \ the calculator could issue a BASIC error and crash the
  \ system. Test it.
  \
  \ XXX TODO -- Add more control structures.
  \
  \ XXX TODO -- Test everything.
  \
  \ XXX TODO -- Document.
  \

( calculator )

need alias

wordlist constant calculator-wordlist

: calculator  ( -- )
  calculator-wordlist >order  $C5 c, $EF c,  ;
  \ Add `calculator-wordlist` to the search order and
  \ compile the assembler instructions to start the ROM
  \ calculator:
  \ ----
  \ push bc ; save the Forth IP
  \ rst $28 ; call the ROM calculator
  \ ----

calculator-wordlist >order
get-current  calculator-wordlist set-current

: end-calc  ( -- )  $38 c,  ;
  \ Compile the `end-calc` ROM calculator command.
  \ ----
  \ db $38 ; exit the ROM calculator
  \ ----

: end-calculator  ( -- )  previous end-calc $C1 c,  ;
  \ Restore the search order and
  \ compile the assembler instructions to exit the ROM calculator:
  \ ----
  \ db $38 ; `end-calc` ROM calculator command
  \ pop bc ; restore the Forth IP
  \ ----

-->

( calculator )

: +  ( -- )  $0F c,  ;
  \ Compile the `addition` ROM calculator command.
: -  ( -- )  $03 c,  ;
  \ Compile the `subtract` ROM calculator command.

: *  ( -- )  $04 c,  ;
  \ Compile the `multiply` ROM calculator command.
: /  ( -- )  $05 c,  ;
  \ Compile the `division` ROM calculator command.
: mod  ( -- )  $32 c,  ;
  \ Compile the `n-mod-m` ROM calculator command.

: **  ( -- )  $06 c,  ;
  \ Compile the `to-power` ROM calculator command.
: sqrt  ( -- )  $28 c,  ;
  \ Compile the `sqr` ROM calculator command.

-->

( calculator )

: negate  ( -- )  $1B c,  ;
  \ Compile the `negate` ROM calculator command.
: sgn  ( -- )  $29 c,  ;
  \ Compile the `sgn` ROM calculator command.
: abs  ( -- )  $2A c,  ;
  \ Compile the `abs` ROM calculator command.

: int  ( -- )  $27 c,  ;
  \ Compile the `int` ROM calculator command.
: truncate  ( -- )  $3A c,  ;
  \ Compile the `truncate` ROM calculator command.

: re-stack  ( r -- r' )  $3D c,  ;
  \ Compile the `re-stack` ROM calculator command.

: zero  ( -- )  $A0 c,  ;
  \ Compile the ROM calculator command that stacks 0.
: one  ( -- )  $A1 c,  ;
  \ Compile the ROM calculator command that stacks 1.
: half  ( -- )  $A2 c,  ;
  \ Compile the ROM calculator command that stacks 1/2.
: pi2/  ( -- )  $A3 c,  ;
  \ Compile the ROM calculator command that stacks pi/2.
: ten  ( -- )  $A4 c,  ;
  \ Compile the ROM calculator command that stacks 10.

-->

( calculator )

: ln  ( -- )  $25 c,  ;
  \ Compile the `ln` ROM calculator command.
: exp  ( -- )  $26 c,  ;
  \ Compile the `exp` ROM calculator command.

: acos  ( -- )  $23 c,  ;
  \ Compile the `acos` ROM calculator command.
: asin  ( -- )  $22 c,  ;
  \ Compile the `asin` ROM calculator command.
: atan  ( -- )  $24 c,  ;
  \ Compile the `atan` ROM calculator command.
: cos  ( -- )  $20 c,  ;
  \ Compile the `cos` ROM calculator command.
: sin  ( -- )  $1F c,  ;
  \ Compile the `sin` ROM calculator command.
: tan  ( -- )  $21 c,  ;
  \ Compile the `tan` ROM calculator command.

-->

( calculator )

: drop  ( -- )  $02 c,  ;
  \ Compile the `delete` ROM calculator command.

: dup  ( -- )  $31 c,  ;
  \ Compile the `duplicate` ROM calculator command.

: swap  ( -- )  $01 c,  ;
  \ Compile the `exchange` ROM calculator command.

: >mem  ( n -- )  $C0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `st-mem` ROM calculator command for memory
  \ number _n_ (0..5). Note: The floating-point stack TOS is
  \ copied, not moved.

: mem>  ( n -- )  $E0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `get-mem` ROM calculator command for memory
  \ number _n_ (0..5).

: over  ( -- )
  2 >mem drop 1 >mem 2 mem> 1 mem>  ;
  \ Compile the ROM calculator commands to do `over`.

: 2dup  ( -- )
  2 >mem drop 1 >mem drop 1 mem> 2 mem>  1 mem> 2 mem>  ;
  \ Compile the ROM calculator commands to do `2dup`.

-->

( calculator )

: 0=  ( -- )  $30 c,  ;
  \ Compile the `not` ROM calculator command.

: 0<  ( -- )  $36 c,  ;
  \ Compile the `less-0` ROM calculator command.

: 0>  ( -- )  $37 c,  ;
  \ Compile the `greater-0` ROM calculator command.

-->

( = <> < > <= >= )

-->  \ XXX TMP -- ignore this block

  \ XXX FIXME -- These commands always return true.
  \
  \ 2016-04-20:
  \
  \ After some research, it seems the reason is the numbers are
  \ compared as strings.  Some commands of the ROM calculator
  \ are used to compare numbers and strings, and the routine
  \ checks the parameters before doing the comparison.
  \
  \ Somehow the ROM routine at $353B gets confused because the
  \ command is not restored from $5C67 (the BREG system
  \ variable).
  \
  \ I examined the source of the ROM calculator and followed
  \ its execution using the debugger of the Fuse emulator, in
  \ BASIC and Forth. So far I got the following clues:
  \
  \ $335E: the command in B is saved to $5C67. This is at the
  \ start of the calculator, so it doesn't makes sense the
  \ first time, because the command is not in B. In Forth, B
  \ contains the high part of the IP ($78 at the time of
  \ writing). But this address is a re-entry point, forced by
  \ the calculator by manipulating the Z80 stack.
  \
  \ $336C: the command is in A, ok.
  \
  \ $338C: the command is modified for indexing, ok.
  \
  \ $339D: the command should be restored by `ld bc,($5C66)`,
  \ which is the low part of STKEND and the high part of BREG.
  \ The register B should contain the command, but not right
  \ after the first entry into the calculator.
  \
  \ $33A1: BREG is in B, which in Forth is $78, bad.
  \
  \ $33A1: Restore the ROM calculator literal: `ld a,($5C67)`.
  \ This is not executed by Forth's `f=`, but it is when the
  \ BASIC command `print 1=1` is interpreted.
  \
  \ $353B: B contains $78, not the command. The routine does a
  \ string comparison. But in BASIC, at this point register B
  \ contains the command.

: =  ( -- )  $0E c,  ;
  \ Compile the `nos-eql` ROM calculator command.

: <>  ( -- )  $0B c,  ;
  \ Compile the `nos-neql` ROM calculator command.

: >  ( -- )  $0C c,  ;
  \ Compile the `no-grtr` ROM calculator command.

: <  ( -- )  $0D c,  ;
  \ Compile the `no-less` ROM calculator command.

: <=  ( -- )  $09 c,  ;
  \ Compile the `no-l-eql` ROM calculator command.

: >=  ( -- )  $0A c,  ;
  \ Compile the `no-gr-eql` ROM calculator command.

-->

( calculator )

: ?branch  ( -- )  $00 c,  ;
  \ Compile the `jump-true` ROM calculator command.

: 0branch  ( -- )  0= ?branch  ;
  \ Compile the ROM calculator commands to do a branch if
  \ the TOS of the calculator stack is zero.

: branch  ( -- )  $33 c,  ;
  \ Compile the `jump` ROM calculator command.

-->

( calculator )

: >mark  ( -- a )  here 0 c,  ;

  \ Compile space for the displacement of a ROM calculator
  \ forward branch which will later be resolved by
  \ `>resolve`.
  \
  \ Typically used after either `branch` or
  \ `?branch`.

: from-here  ( a -- n )
  here [ also forth ] swap - [ previous ] ;
  \ Calculate the displacement _n_ from the current data-space
  \ pointer to address _a_.

: >resolve  ( a -- )
  [ also forth ] dup [ previous ] from-here
  [ also forth ] swap [ previous ] c!  ;

  \ Resolve a ROM calculator forward branch by placing the
  \ displacement to the current position into the space
  \ compiled by `>mark`.

' here alias <mark  ( -- a )

  \ Leave the address of the current data-space pointer as the
  \ destination of a ROM calculator backward branch which will
  \ later be resolved by `<resolve`.
  \
  \ Typically used before either `branch` or `?branch`.

: <resolve  ( a -- )  from-here c,  ;

  \ Resolve a ROM calculator backward branch by compiling the
  \ displacement from the current position to address _a_,
  \ which was left by `<mark`.

: if  ( -- a )  0branch >mark  ;

: else  ( a1 -- a2 )
  branch >mark [ also forth ] swap [ previous ] >resolve  ;

' >resolve alias then  ( a -- )

set-current  previous
  \ restore the current word list and the search order
  \ math.floating_point.rom.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605050022

  \ -----------------------------------------------------------
  \ Description

  \ A floating point implementation that uses the ROM
  \ calculator.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development.
  \
  \ 2016-04-11: Revision. Code reorganized. First improvements.
  \
  \ 2016-04-12: Started `f.` and `f,`.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Made `f.` immune to the ROM bug. Fixed
  \ `ftrunc`. Moved the ROM calculator to its own file.
  \ Improved. Added `floor`.
  \
  \ 2016-04-20: Added `fnip`, `ftuck`, `f2dup`, `f2drop`.
  \ Wrote `calculator-command>flag` and rewrote `f=`, `f<>`,
  \ `f<`, `f<=`, `f>` and `f>=` after it, because calling the
  \ equivalents command of the ROM calculator directly always
  \ returned a true flag; the details of the debugging are
  \ noted in the ROM calculator module. Fixed `fmax` and
  \ `fmin`.
  \
  \ 2016-04-21: Added `fround`, `f~`, `f~abs`, `f~rel`,
  \ `f~relabs`, `f==`, `flnp1`, `?fln`, `'?flnp1`.
  \
  \ 2016-05-05: Update `s=` to `str=`.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Write `fliteral`, `ffield:`, `fvalue`,
  \ environmental queries.
  \
  \ XXX TODO -- Write safer alternatives for the ambiguous
  \ conditions listed in Forth-2012, or better yet, use the
  \ standard name for the safe version, and factor the faster
  \ unsafe code.
  \
  \ XXX TODO -- `init-fs`, call to ROM routine STK_STK ($16C5).
  \
  \ XXX TODO -- Test everything.
  \
  \ XXX TODO -- Document.

( float float+ float- floats )

5 constant float

: float+  ( fa1 -- fa2 )  float +  ;
: float-  ( fa1 -- fa2 )  float -  ;
: floats  ( n1 -- n2 )  float *  ;

( fp0 fp (fp@ fp@ empty-fs fdepth )

need float

23651 constant fp0  \ STKBOT system variable
23653 constant fp   \ STKEND system variable

  \ Note: The calculator stack grows towards higher memory, and
  \ `fp` points to the first free position, therefore above top
  \ of stack.

: (fp@  ( -- a )  fp @  ;

: fp@  ( -- a )  (fp@ float -  ;

: empty-fs  ( -- )  fp0 @ fp !  ;

: fdepth  ( -- n )  (fp@ fp0 @ - float /  ;

( f>flag )

need (f>s

: f>flag  ( -- f ) ( F: rf -- )  (f>s negate  ;
  \ Convert a floating-poing flag _rf_ (1|0) to an actual flag
  \ _f_ in the data stack.

( end-calculator-flag )

need macro  need f>flag  need call-xt

macro end-calculator-flag  ( -- f ) ( F: 1|0 -- )
  [ calculator-wordlist >order ] end-calculator [ previous ]
  ['] f>flag call-xt  jpnext endm

  \ Exit the ROM calculator and convert a flag calculated by
  \ it (_1|0_) to a well-formed flag on the data stack.
  \
  \ This macro is a common factor of all floating point logical
  \ operators.

( calculator-command )

need calculator

: calculator-command  ( b -- )
  $C5 c,  $06 c, c,
    \ push bc ; save the Forth IP
    \ ld b,command
  calculator  $3B c,
    \ `fp-calc-2` calculator command, which executes the
    \ calculator command stored in the b register.
  [ calculator-wordlist >order ] end-calculator [ previous ]
  $C1 c,  ;
    \ pop bc ; restore the Forth IP

  \ doc{
  \
  \ calculator-command  ( b -- )
  \
  \ Compile the assembler instructions needed to execute the
  \ _b_ command of the ROM calculator.
  \
  \ }doc

( calculator-command>flag )

need calculator-command  need f>flag  need call-xt

: calculator-command>flag  ( b -- )
  calculator-command ['] f>flag call-xt
  [ also assembler ] jpnext [ previous ]  ;

  \ doc{
  \
  \ calculator-command>flag  ( b -- )
  \
  \ Compile the assembler instructions needed to execute the
  \ _b_ command of the ROM calculator and to return the
  \ floating-point result as a flag on the data stack.
  \
  \ }doc

( f= f<> )

need calculator-command>flag

code f=  ( -- f ) ( F: r1 r2 -- )
  0E calculator-command>flag  end-code
  \ `nos-eql` calculator command

code f<>  ( -- f ) ( F: r1 r2 -- )
  0B calculator-command>flag  end-code
  \ `nos-neql` calculator command

( f~abs f~rel f~relabs f== )

  \ Credit:
  \
  \ Most of this code is based on the words `f~`, `f~abs` and
  \ `f~rel` implemented in Gforth 0.7.3. Parts have been
  \ factored and adapted.

need frot  need f-  need fabs  need fswap  need f<  need fover
need f+  need f*  need fp@  need float-  need float  need str=
need fdrop  need fsgn

: f~abs  ( -- f ) ( F: r1 r2 r3 -- )
  frot frot f- fabs fswap f<  ;

  \ doc{
  \
  \ f~abs  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with absolute error: `|r1-r2|<r3`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than _r3_.
  \
  \ Origin: Gforth.
  \
  \ }doc

: f~rel  ( -- f ) ( F: r1 r2 r3 -- )
  frot frot fover fabs fover fabs f+
  frot frot f- fabs frot frot f* f<  ;

  \ doc{
  \
  \ f~rel  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with relative error:
  \ `|r1-r2|<r3*|r1+r2|`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than the value of _r3_ times the sum of the absolute values
  \ of _r1_ and _r2_.
  \
  \ }doc

: f~relabs  ( -- f ) ( F: r1 r2 r3 -- )  fabs f~rel  ;

  \ XXX TODO -- better name

  \ doc{
  \
  \ f~relabs  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with relative error:
  \ `|r1-r2|<|r3|*|r1+r2|`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than the absolute value of _r3_ times the sum of the
  \ absolute values of _r1_ and _r2_.
  \
  \ }doc

: f==  ( -- f ) ( F: r1 r2 -- )
  fp@ dup float- float tuck str= fdrop fdrop  ;

  \ doc{
  \
  \ f==  ( -- f ) ( F: r1 r2 -- )
  \
  \ Exact bitwise equality.
  \
  \ Are _r1_ and _r2_ exactly identical? Flag _f_ is true if
  \ the bitwise comparison of _r1_ and _r2_ is succesful.
  \
  \ }doc

( f~ )

need f~abs  need f==  need f~relabs

     ' f~abs ,
here ' f== ,
     ' f~relabs ,

      constant (f~) \ execution table of `f~`

: f~  ( -- f ) ( F: r1 r2 r3 -- )
  fdup fsgn f>s cells (f~) + perform  ;

  \ doc{
  \
  \ f~  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Medley for comparing _r1_ and _r2_ for equality:
  \
  \ - _r3_>0: `f~abs`;
  \ - _r3_=0: `f==`;
  \ - _r3_<0: `f~relabs`.
  \
  \ See: `f~abs`, `f==`, `f~rel`,`f~relabs`.
  \
  \ Origin: Forth-94 (FLOATING EXT), Forth-2012 (FLOATING EXT).
  \
  \ }doc

( f< f<= f> f>= )

need calculator-command>flag

code f<  ( -- f ) ( F: r1 r2 -- )
  0D calculator-command>flag  end-code
  \ `no-less` calculator command

code f<=  ( -- f ) ( F: r1 r2 -- )
  09 calculator-command>flag  end-code
  \ `no-l-eql` calculator command

code f>  ( -- f ) ( F: r1 r2 -- )
  0C calculator-command>flag  end-code
  \ `no-grtr` calculator command

code f>=  ( -- f ) ( F: r1 r2 -- )
  0A calculator-command>flag  end-code
  \ `no-gr-eql` calculator command

( f0< f0= f0<> f0> )

need calculator  need end-calculator-flag

code f0<  ( -- f ) ( F: r -- )
  calculator  0<  end-calculator-flag  end-code

code f0=  ( -- f ) ( F: r -- )
  calculator  0=  end-calculator-flag  end-code

code f0<>  ( -- f ) ( F: r -- )
  calculator  0= 0=  end-calculator-flag  end-code

code f0>  ( -- f ) ( F: r -- )
  calculator  0>  end-calculator-flag  end-code

( fdrop fdup fswap fover )

need calculator

code fdrop  ( F: r -- )
  calculator  drop  end-calculator  jpnext  end-code

code fdup  ( F: r -- r r )
  calculator  dup  end-calculator  jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calculator  swap  end-calculator  jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calculator  over  end-calculator  jpnext  end-code

( f2dup f2drop )

code f2dup  ( F: r -- r r )
  calculator  2dup  end-calculator  jpnext  end-code

code f2drop  ( F: r -- )
  calculator  drop drop  end-calculator  jpnext  end-code

( fnip ftuck )

need calculator

code fnip  ( F: r1 r2 -- r2 )
  calculator  swap drop  end-calculator  jpnext
  end-code

code ftuck  ( F: r1 r2 -- r2 r1 r2 )
  calculator  2 >mem swap 2 mem>  end-calculator  jpnext
  end-code

( frot -frot )

need calculator

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calculator
    1 >mem drop swap 1 mem> swap
  end-calculator  jpnext  end-code

code -frot  ( F: r1 r2 r3 -- r3 r1 r2 )
  calculator
    swap 1 >mem drop swap 1 mem>
  end-calculator  jpnext  end-code

( f+ f- f* f/ ?f/ fmod )

need calculator  need fdup  need f0=

code f+  ( F: r1 r2 -- r3 )
  calculator  +  end-calculator  jpnext  end-code

code f-  ( F: r1 r2 -- r3 )
  calculator  -  end-calculator  jpnext  end-code

code f*  ( F: r1 r2 -- r3 )
  calculator  *  end-calculator  jpnext  end-code

code f/  ( F: r1 r2 -- r3 )
  calculator  /  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r2_ is zero, the calculator issues
  \ "number too big" BASIC error, what crashes the system.  A
  \ safe alternative `?f/` is provided.

: ?f/  ( F: r1 r2 -- r3 )  fdup f0= #-42 ?throw f/  ;
  \ Safe version of `f/`. If _r2_ is zero, an exception
  \ is thrown.

code fmod  ( F: r1 -- r2 )
  calculator  mod  end-calculator  jpnext  end-code

( fmax )

need calculator  need calculator-command

code fmax  ( F: r1 r2 -- r1|r2 )
  calculator  2dup  end-calculator
  0C calculator-command  ( F: r1 r2 rf -- )
    \ `no-grtr` ROM calculator command
  calculator
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

  \ XXX OLD -- Original, simpler version. The problem is the
  \ calculator's `>`. See the calculator module for details of
  \ the problem.

  \ code fmax  ( F: r1 r2 -- r1|r2 )
  \   calculator
  \     2dup >  ( F: r1 r2 rf -- )
  \     if    drop  ( F: r1 )
  \     else  swap drop  ( F: r2 )
  \     then
  \   end-calculator  jpnext  end-code

( fmin )

need calculator  need calculator-command

code fmin  ( F: r1 r2 -- r1|r2 )
  calculator  2dup  end-calculator
  0D calculator-command  ( F: r1 r2 rf -- )
    \ `no-less` ROM calculator command
  calculator
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

  \ XXX OLD -- Original, simpler version. The problem is the
  \ calculator's `<`. See the calculator module for details of
  \ the problem.

  \ code fmin  ( F: r1 r2 -- r1|r2 )
  \   calculator
  \     2dup <  ( F: r1 r2 rf -- )
  \     if    drop  ( F: r1 )
  \     else  swap drop  ( F: r2 )
  \     then
  \   end-calculator  jpnext  end-code

( fsgn fabs fnegate )

need calculator

code fsgn  ( F: r1 -- -1|0|1 )
  calculator  sgn  end-calculator  jpnext  end-code

code fabs  ( F: r1 -- r2 )
  calculator  abs  end-calculator  jpnext  end-code

code fnegate  ( F: r1 -- r2 )
  calculator  negate  end-calculator  jpnext  end-code

( fln ?fln flnp1 ?flnp1 fexp f** fsqrt ?fsqrt )

need calculator  need fdup  need f0<  need f<=

code fln  ( F: r1 -- r2 )
  calculator  ln  end-calculator  jpnext  end-code
  \ XXX FIXME -- The ROM calculator checks that the argument is
  \ a positive non-zero number (address $3713). If not, it
  \ throws a BASIC error "invalid argument", what crashes the
  \ system.  A safe alternative `?fln` is provided.

: ?fln  ( F: r1 -- r2 )  fdup f0 f<= #-46 ?throw fln  ;
  \ Safe version of `fln`. If _r1_ is less than or equal to
  \ zero, an exception is thrown.

code flnp1  ( F: r1 -- r2 )
  calculator  one + fln  end-calculator  jpnext  end-code

: ?flnp1  ( F: r1 -- r2 )
  fdup f1 fnegate f<= #-46 ?throw fln  ;
  \ Safe version of `flnp1`. If _r1_ is less than or equal to
  \ negative one, an exception is thrown.

code fexp  ( F: r1 -- r2 )
  calculator  exp  end-calculator  jpnext  end-code

code f**  ( F: r1 -- r2 )
  calculator  **  end-calculator  jpnext  end-code

code fsqrt  ( F: r1 -- r2 )
  calculator  sqrt  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r1_ is negative, the calculator issues
  \ "invalid argument" BASIC error, what crashes the system.  A
  \ safe alternative `?fsqrt` is provided.

: ?fsqrt  ( F: r1 -- r2 )  fdup f0< #-46 ?throw fsqrt  ;
  \ Safe version of `fsqrt`. If _r1_ is negative, an exception
  \ is thrown.

( f0 f1 fhalf fpi2/ f10 )

need calculator

code f0  ( F: -- r )
  calculator  zero  end-calculator  jpnext  end-code

code f1  ( F: -- r )
  calculator  one  end-calculator  jpnext  end-code

code fhalf  ( F: -- r )
  calculator  half  end-calculator  jpnext  end-code

code fpi2/  ( F: -- r )
  calculator  pi2/  end-calculator  jpnext  end-code

code f10  ( F: -- r )
  calculator  ten  end-calculator  jpnext  end-code

( (f>s )

  \ XXX REMARK -- This word must be in other block than `f>s`,
  \ to avoid a circular `need`.

code (f>s  ( -- n ) ( F: r -- )
  C5 c,  CD c, 2DA2 ,
    \ push bc
    \ call $2DA2 ; FP_TO_BC ROM routine
  60 00 + c,  68 01 + c,  C1 c,  jppushhl
    \ ld h,b
    \ ld l,c
    \ pop bc
    \ jp push_hl
  end-code

( frestack b>f u>f s>f f>s )

need calculator  need fnegate  need fdup  need (f>s  need f0<

code frestack  ( F: r -- r' )
  calculator  re-stack  end-calculator  jpnext end-code
  \ Restack an integer in full floating-point form.

code b>f  ( b -- ) ( F: -- r )
  D9 c, E1 c, 78 05 + c, CD c, 2D28 , D9 c,  jpnext  end-code
    \ exx
    \ pop hl
    \ ld a,l
    \ call $2D28 ; STACK_A ROM routine
    \ exx
  \ XXX TODO -- test

code u>f  ( u -- ) ( F: -- r )
  D9 c, C1 c, CD c, 2D2B , D9 c,  jpnext  end-code
    \ exx
    \ pop bc
    \ call $2D2B ; STACK_BC ROM routine
    \ exx

: s>f  ( n -- ) ( F: -- r )
  dup 0< if  abs u>f fnegate  else  u>f  then  ;
  \ XXX TODO -- test

: f>s  ( -- n ) ( F: r -- )  fdup (f>s f0< ?negate  ;
  \ XXX TODO -- test

  \ code f>d  ( -- d ) ( F: r -- )
  \ end-code
  \ XXX TODO

  \ code d>f  ( d -- ) ( F: -- r )
  \ end-code
  \ XXX TODO

  \ code f>string  ( -- ca len ) ( F: r -- )
  \ end-code
  \ XXX TODO -- ROM calculator command $2E

  \ : >float  ;
  \ XXX TODO -- ROM calculator command `val`

( f! f@ )

need z80-asm

code f!  ( fa -- ) ( F: r -- )
  exx  2BF1 call  \ STK_FETCH ROM routine
       hl pop  a m ld  hl incp
               e m ld  hl incp  d m ld  hl incp
               c m ld  hl incp  b m ld
  exx  jpnext end-code

  \ doc{
  \
  \ f!  ( fa -- ) ( F: r -- )
  \
  \ Store _r_ at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

code f@  ( fa -- ) ( F: -- r )
  exx  hl pop m a ld  hl incp
              m e ld  hl incp  m d ld  hl incp
              m c ld  hl incp  m b ld
              2AB6 call  \ STK_STORE ROM routine
  exx  jpnext end-code

  \ doc{
  \
  \ f@  ( fa -- ) ( F: -- r )
  \
  \ _r_ is the value stored at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

( f, fconstant fvariable )

need float  need f!  need f@

: f,  ( -- ) ( F: r -- )  here float allot f!  ;

  \ doc{
  \
  \ f,  ( -- ) ( F: r -- )
  \
  \ Reserve data space for one floating-point number and store
  \ _r_ in that space.
  \
  \ Origin: Gforth.
  \
  \ }doc

: fconstant  ( "name" -- )  ( F: r -- )
  create  f,  does>  f@  ;

  \ doc{
  \
  \ fconstant  ( "name" -- )  ( F: r -- )
  \
  \ Create a floating-point constant called "name" with value
  \ _r_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

: fvariable  ( "name" -- )  create  float allot  ;

( facos fasin fatan fcos fsin ftan )

need calculator

code facos  ( F: r1 -- r2 )
  calculator  acos  end-calculator  jpnext  end-code

code fasin  ( F: r1 -- r2 )
  calculator  asin  end-calculator  jpnext  end-code

code fatan  ( F: r1 -- r2 )
  calculator  atan  end-calculator  jpnext  end-code

code fcos  ( F: r1 -- r2 )
  calculator  cos  end-calculator  jpnext  end-code

code fsin  ( F: r1 -- r2 )
  calculator  sin  end-calculator  jpnext  end-code

code ftan  ( F: r1 -- r2 )
  calculator  tan  end-calculator  jpnext  end-code

( (f. f. )

need fdepth  need fdrop

code (f.  ( F: r -- )
  C5 c,  CD c, 2DE3 ,  C1 c,
    \ push bc
    \ call $2DE3  ; PRINT_FP ROM routine
    \ pop bc
  jpnext  end-code
  \ Note: `exx` can no be used to preserve `bc`, the Forth IP,
  \ because the routine uses the alternative registers.  `bc`
  \ is saved on the stack instead.

: f.  ( F: r -- )
  fdepth >r  (f. space
  fdepth r> = if  fdrop  then  ;

  \ Note: the depth of the stack must be checked because
  \ there's a bug in the PRINT-FP ROM routine called "unbalaced
  \ stack error". When the number is a non-integer less than 1,
  \ a zero is left on the stack.  This bug is documented in the
  \ ZX Spectrum ROM disassembly. Credit: Tony Stratton, 1982.

  \ XXX FIXME -- The Forth-2012 standard reads `f.` must use
  \ fixed-point notation, but in this implementation the
  \ decimal point is not shown at the end when the number is
  \ integer.

( .fs dump-fs )

need (fp@  need fp0  need f@  need f.
need fdepth  need float  need float+  need .depth

: (.fs  ( -- )  (fp@ fp0 @ ?do  i f@ f.  float +loop  ;

: .fs   ( -- )  fdepth dup .depth 0> if  (.fs  then  ;

: (dump-fs  ( -- )
  cr ." Bottom"
  (fp@ fp0 @ ?do
    i dup cr u. float bounds ?do  i c@ 4 .r  loop
  float +loop  cr ." Top" cr  ;
  \ XXX TODO -- improve: print the top at the top

: dump-fs  ( -- )  fdepth dup .depth 0> if  (dump-fs  then  ;

( floor ftrunc fround )

need calculator  need fdup  need fsgn  need f*  need f+

code floor  ( F: r1 -- r2 )
  calculator  int  end-calculator  jpnext  end-code

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ negative infinity" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc


code ftrunc  ( F: r1 -- r2 )
  calculator  truncate  end-calculator  jpnext  end-code

  \ doc{
  \
  \ ftrunc  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ zero" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

  \ Example from the documentation of Forth-2012:

  \ : ftrunc  ( F: r1 -- r2 )
  \   fdup f0= 0= if
  \     fdup f0< if  fnegate floor fnegate  else  floor  then
  \   then  ;

  \ From Gforth:

  \ : ftrunc  ( F: r1 -- r2 )  f>d d>f  ;

: fround  ( F: r1 -- r2 )  fdup fsgn fhalf f* f+ ftrunc  ;

  \ doc{
  \
  \ fround  ( r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round to
  \ nearest" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

( falign faligned sfalign sfaligned dfalign dfaligned )

need alias

' noop alias falign     ( -- )        immediate
' noop alias faligned   ( a -- fa )   immediate

' noop alias sfalign    ( -- )        immediate
' noop alias sfaligned  ( a -- dfa )  immediate

' noop alias dfalign    ( -- )        immediate
' noop alias dfaligned  ( a -- dfa )  immediate

  \ vim: filetype=soloforth
  \ math.number.conversion.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number conversion.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( number )

: number  ( ca len -- n | d )  number? 0= #-275 ?throw  ;
  \ doc{
  \
  \ number  ( ca len -- n | d )
  \
  \ Attempt to convert a string _ca len_ into a number. If
  \ a valid point is found, return _d_; if there is no
  \ valid point, return _n_. If conversion fails due to an
  \ invalid character, an exception #-275 is thrown.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ math.number.point.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242143

  \ -----------------------------------------------------------
  \ Description

  \ Words to configure the charactes accepted as number point.

  \ -----------------------------------------------------------
  \ Authors

  \ Wil Baden, published on Forth Dimensions (volume 20, number
  \ 3 page 26, 1998-10).

  \ Adapted by Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( standard-number-point? extended-number-point? )

need [if]

[needed] classic-number-point? [if]

: classic-number-point?  ( c -- f )
  dup ':' = swap ',' - 4 u< or  ;
  \ doc{
  \
  \ standard-number-point?  ( c -- f )
  \
  \ Is character _c_ a classic number point?  Allowed
  \ points are: comma, hyphen, period, slash and
  \ colon.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

[needed] extended-number-point? [if]

: extended-number-point?  ( c -- f )
  dup ':' = swap '+' - 5 u< or  ;

  \ doc{
  \
  \ extended-number-point?  ( c -- f )
  \
  \ Is character _c_ an extended number point?  Allowed points
  \ are: plus sign, comma, hyphen, period, slash and colon,
  \ after _Forth Programmer's Handbook_.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth

  \ math.number.prefix.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605140240

  \ -----------------------------------------------------------
  \ Description

  \ Numeric prefix words. Solo Forth recognizes the standard
  \ notations, but these words may be useful in some cases.

  \ -----------------------------------------------------------
  \ Author

  \ XXX TODO -- update

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.

( base# b# d# h# )

  \ Credit:
  \
  \ Based on code from eForth and code written by Wil Baden
  \ (published on Forth Dimensions 20-3, p. 27).

need evaluate

: base# ( -- ) ( "name" -- )
  create c, immediate
  does> c@
  base c@ >r  base !    \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

 2 base# b#
10 base# d#
16 base# h#

( x# b# o# d# h# t# )

  \ Credit:
  \
  \ Code from eForth.

need evaluate

: x# ( -- ) ( "name" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create o# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate
create t# ( "name" -- n | d ) 36 c, x# immediate

( c# )

  \ Credit:
  \
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate

  \ doc{
  \
  \ c#  ( "name" -- c )
  \
  \ Parse "name" and return the code _c_ of the its first
  \ character.
  \
  \ This is a short and state-smart alternative to the standard
  \ words `char` and `[char]`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.number.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605010407

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number printing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-01: Add `holds`.

( ud.r ud. )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

: ud.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;

  \ : u.r  ( n1 n2 -- )  >r 0 r> ud.r  ;

: ud.  ( d -- )  0 ud.r space  ;

( bin. dec. hex. )

  \ Credit:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credit:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credit:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

( holds )

  \ Credit:
  \ Code from the documentation of Forth-2012.

: holds  ( ca len -- )
  begin  dup  while  1- 2dup + c@ hold  repeat
  2drop  ;

  \ doc{
  \
  \ holds  ( ca len -- )
  \
  \ Add string _ca len_ to the pictured numeric output string.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.operators.1-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610161127

  \ -----------------------------------------------------------
  \ Description

  \ Single-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015: Add `within`, `between`, and common operators.
  \ 2015-08-12: Add `lshift`. Improve `2/`.
  \ 2015-08-14: Add `under+`, in Forth.
  \ 2015-11-01: Add `rshift` and faster `lshift`.
  \ 2015-11-13: Add `sqrt` (version by Wil Baden).
  \ 2015-12-15: Rewrote `under+` in Z80.
  \ 2015-12-21: Add `polarity`.
  \ 2015-12-22: Add `%` and `u%`.
  \ 2015-12-29: Add second version of `sqrt` (from Computer One
  \ Forth).
  \ 2016-03-20: Add `+under`, a variant of `under+`.
  \ 2016-04-05: Add `cell/`.
  \ 2016-04-07: Add `bits`, generic version of `pixels`.
  \ 2016-04-27: Add `sgn`, `<=>`, `either`, `neither`.
  \ 2016-04-28: Fix `<=>`. Add `0max`.
  \ 2016-05-01: Add `clshift`.
  \ 2016-05-02: Compact the blocks to save space. Remove `sgn`
  \ because `polarity` does the same already.
  \ 2016-07-14: Fix and complete credits of `any?`.
  \ 2016-07-29: Add `gcd`.
  \ 2016-10-16: Document `%`, `u%` and `gcd`.

( under+ +under )

need [if]

[needed] under+ [if]

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c, D1 c, C1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop de
  \ pop bc
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `+under`.
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \   rot + swap  ;
  \ ----
  \
  \ }doc

[then]

[needed] +under [if]

code +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  D9 c, C1 c, D1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop bc
  \ pop de
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `under+`
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \   >r + r>  ;
  \ ----
  \
  \ }doc

[then]

  \ XXX TODO -- variant after PFE's `(under+)`:
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;

( within between % u% )

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ Credit:
  \
  \ Code from DZX-Forth.

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit

: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/between.html

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ }doc

[unneeded] %
?\ : %  ( n1 n2 -- n3 )  100 swap */  ;

  \ doc{
  \
  \ % ( n1 n2 -- n3 )
  \
  \ _n1_ is percentage _n3_ of _n2_
  \
  \ }doc

[unneeded] u%
?\ : u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;

  \ doc{
  \
  \ u% ( u1 u2 -- u3 )
  \
  \ _u1_ is percentage _u3_ of _u2_
  \
  \ }doc

[unneeded] gcd  ?exit

: gcd  ( n1 n2 -- n3 )  begin  ?dup  while  tuck mod  repeat  ;

  \ Credit:
  \
  \ Code by Will Baden (1986-04-10), from:
  \ <http://atariwiki.strotmann.de/wiki/Wiki.jsp?page=Local%20Variables>

  \ doc{
  \
  \ gcd  ( n1 n2 -- n3 )
  \
  \ _n3_ is the greatest common divisor of _n1_ and _n2_.
  \
  \ }doc

( polarity <=> )

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code
  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve
  78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

  \ doc{
  \
  \ polarity  ( n -- -1|0|1 )
  \
  \ If _n_ is zero, return zero.
  \ If _n_ is negative, return negative one.
  \ If _n_ is positive, return positive one.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : polarity  ( n -- -1|0|1 )
  \   dup 0= ?exit  0< ?dup ?exit  1  ;
  \ ----
  \
  \ }doc

  \ Credit:
  \
  \ Assembler version of `polarity` adapted from Z88
  \ CamelForth.

[unneeded] <=>
?\ : <=>  ( n1 n2 -- -1|0|1 )  - polarity  ;

  \ doc{
  \
  \ <=>  ( n1 n2 -- -1|0|1 )
  \
  \ If _n1_ equals _n2_, return zero.
  \ If _n1_ is less than _n2_, return negative one.
  \ If _n1_ is greater than _n2_, return positive one.
  \
  \ }doc

( u<= u>= <= >= 0>= 0<= 0max )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;  exit

[unneeded] 0max ?exit

code 0max  ( n -- n | 0 )
  E1 c,  CB c, 10 05 + c,  DA c, ' false ,  CB c, 18 05 + c,
    \ pop hl
    \ rl h ; negative?
    \ jp c,false_
    \ rr h
  jppushhl  end-code
    \ jp push_hl

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ 0max  ( n -- n | 0 )
  \
  \ If _n_ is negative, return 0; else return _n_.
  \ This is a faster alternative to the idiom `0 max`.
  \
  \ }doc

( lshift )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 16 bytes.

need z80-asm

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 19 bytes.

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is 3 bytes smaller but slower (133% the
  \ execution time of the version adapted from Z88 CamelForth).

  \ Data space used: 16 bytes.

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( clshift )

code clshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,  80 07 + c,  C3 c, ,
    \ dec e
    \ jp z,push_a
    \ add a,a
    \ jp begin
  end-code

( crshift )

  \ XXX UNDER DEVELOPMENT -- 2016-05-01

code crshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,
    \ dec e
    \ jp z,push_a
  \ 80 07 + c,
    \ rra
  C3 c, ,
    \ jp begin

  end-code

( bits )

  \ Credit:
  \
  \ Based on a pixels counter written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Data space used: 29 bytes.

need z80-asm

code bits  ( ca len -- u )

  0 hl ldp#  \ init bit count
  exx  \ save IP and count
  de pop  hl pop  \ memory zone
  begin
    d a ld  e or  nz if
      08 b ld#  \ bits per byte
      begin  m rrc  cy if  exx hl incp exx  then  step
      hl incp  de decp  \ next byte
  2swap again then
    \ Note: `2swap` is needed because `begin again` and `if
    \ then` are not nested.

  exx jppushhl end-code

  \ doc{
  \
  \ bits  ( ca len -- u )
  \
  \ Count the number of bits set in memory zone _ca len_.
  \
  \ }doc

( 2/ cell/ )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

need [if]

[needed] 2/ [needed] cell/ or [if]

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  jppushhl        \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

[then]

[unneeded] cell/  ?\ need alias  ' 2/ alias cell/
  \ Credit:
  \
  \ Idea from IsForth.

( sqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

  \ XXX TODO -- benchmark

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credit:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

  \ XXX TODO -- benchmark

need 2/

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ XXX TODO -- remove, it's in the kernel

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need sm/rem

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need fm/mod

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? either neither )

need [if]

[needed] any? [if]  need roll  variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;

  \ doc{
  \
  \ any?  ( x0 x1..xn n -- f )
  \
  \ Is any _x1..xn_ equal to _x0_?
  \
  \ Origin: John A. Peters' tools for CP/M F83 2.1.1, 1984.
  \
  \ }doc

  \ Credit:
  \
  \ Originally written by John A. Peters in 1984 as part of a
  \ tool set for the CP/M implementation of Laxen&Perry's F83
  \ 2.1.1.

[then]

  \ Credit:
  \
  \ Code from IsForth (version 1.23b).

[needed] either [if]

: either  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over = -rot = or  ;

  \ doc{
  \
  \ either  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ equals either _n2|u2_ or _n3|u3_;
  \ else return _false_.
  \
  \ }doc

[then]

[needed] neither [if]

: neither  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over <> -rot <> and  ;

  \ doc{
  \
  \ neither  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ is not equal to either _n2|u2_ or
  \ _n3|u3_; else return _false_.
  \
  \ }doc

[then]

( split join )

need [if]

[needed] split [if]

code split  ( x -- b1 b2 )
  E1 c,
    \ pop hl
  16 c, 00 c,  58 05 + c,  68 04 + c,  26 c, 00 c,
    \ ld d,0
    \ ld e,l
    \ ld l,h
    \ ld h,0
  C3 c, pushhlde ,  end-code
    \ jp push_hlde

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ split  ( x -- b1 b2 )
  \
  \ Get _b1_ and _b2_ from the 2 bytes which compose _x_: _b1_
  \ is the high-order byte and _b2_ is the low-order byte.
  \
  \ See `join`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

[needed] join [if]

code join  ( b1 b2 -- x )
  D1 c,  60 03 + c,  D1 c,  68 03 + c,
    \ pop de
    \ ld h,e
    \ pop de
    \ ld l,e
  jppushhl  end-code
    \ jp push_hl

  \ doc{
  \
  \ join  ( b1 b2 -- x )
  \
  \ _b1_ is the low-order byte of _x_, and _b2_ is the
  \ high-order byte of _x_.
  \
  \ See `split`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth
  \ math.operators.2-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271707

  \ -----------------------------------------------------------
  \ Description

  \ Double-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-13: Add `dsqrt`.

( ud* )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: ud*  ( ud1 u2 -- ud3 )  dup >r um* drop  swap r> um* rot +  ;

( d* )

  \
  \ Credit:
  \
  \ Code from DX-Forth 4.13.

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0000

: d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;

  \ --------------------------------------------
  \ Alternative implementation.
  \
  \ Credit:
  \
  \ Adapted from code written by Robert L. Smith,
  \ published on Forth Dimensions (volume 4, number 1, page 3,
  \ 1982-05).
  \
  \ This implementation uses 36 bytes.
  \ Relative speed: 1.0582
  \
  \ : d*  ( d1 d2 -- d3 )
  \  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ --------------------------------------------
  \ Alternative implementation.

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 33, 1998-04).

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0008

  \ : d*  ( d1 d2 -- d3 )
  \   >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  \   2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  \   r> * swap r> * + +  ; ( d1*d2 ) ( R: )

( du/mod )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

need tum*  need t+  need t-  need tum/  need d2*  need lshift

: normalize-divisor  ( d1 -- d1' shift )
  0 >r begin  dup 0< while  d2*  r> 1+ >r  repeat  r>  ;

  \ XXX TODO rename as `ud/mod`?
  \ XXX TODO stack comments

: du/mod  ( ud1 ud2 -- ud3 ud4 )

  ?dup 0= if
    \ there is a leading zero "digit" in divisor
    >r  0 r@ um/mod  r> swap >r  um/mod  0 swap r>  exit
  then

  normalize-divisor dup >r rot rot 2>r
  1 swap lshift tum*
    \ normalize divisor and dividend

  dup  r@ = if   -1  else  2dup  r@ um/mod nip  then
    \ guess leading "digit" of quotient

  2r@  rot dup >r  tum*  t-
    \ multiply divisor by trial quot and substract from
    \ dividend

  dup 0< if  r> 1-  2r@  rot >r  0 t+
    \ if negative, decrement quot and add to dividend

    dup 0< if  r> 1-  2r@  rot >r  0 t+  then
    \ if still negative, do it one more time

  then

  r> 2r> 2drop  1 r>  rot >r  lshift tum/  r> 0  ;
    \ undo nurmalization of dividend to get remainder

  \ Double unsigned divide with remainder.  Given a dividend
  \ _ud1_ and a divisor _ud2_, return remainder _ud3_ and
  \ quotient _ud4_.

( d0= d0< d< du< )

  \ Credit:
  \
  \ Code from DZX-Forth.

[unneeded] d0= ?\ : d0=  ( d -- f )  or 0=  ;  exit

[unneeded] d0< ?\ : d0<  ( d -- f )  nip 0<  ; exit

need [if]

[needed] d< [if]

need 2nip

: d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;  exit

[then]

[needed] du< [if]

  \ XXX TODO rewrite in Z80

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop [ true ] literal exit  then
  -   if  2drop [ false ] literal exit  then  u<  ;  exit

  \ Note: the flags are compiled with `literal` to make
  \ execution a bit faster.

[then]

( dmin dmax )

  \ Credit:
  \
  \ Code from DZX-Forth.

need [if]

[needed] dmin [if]
: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;  exit  [then]
  \ XXX TODO -- use `d>` when available

[needed] dmax [if]
: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;  [then]

( d= d<> )

  \ XXX TODO -- rewrite in Z80

: d<>  ( d1 d2 -- f )  rot <> if  2drop true exit  then  <>  ;

: d=  ( d1 d2 -- f )  d<> 0=  ;

  \ XXX OLD
  \ XXX TODO benchmark
  \ : d=  ( d1 d2 -- f ) rot = >r = r> and  ;
  \ : d<>  ( d1 d2 -- f )  d= 0=  ;

( d- )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  jppushhl
  end-code

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  D1 c, E1 c,
    \ pop de / pop hl
  29 c,  CB c, 13 c,  CB c, 12 c,
    \ add hl,hl
    \ rl e
    \ rl d
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  E1 c, D1 c,
    \ pop hl / pop de
  CB c, 2C c,  CB c, 1C c,  CB c, 1D c,
    \ sra h  /  rr h /  rr l
  CB c, 1A c,  CB c, 1B c,
    \ rr d /  rr e
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]  need z80-asm

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  de pop  hl pop
  hl addp  e rl  d rl
                              \ alternatives:
  exde  pushhlde jp           \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  hl pop  de pop
  h sra  l rr  d rr  e rr

                              \ alternatives:
  pushhlde jp                 \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

( dxor dor dand )

  \ Credit:
  \
  \ Code written by Everett F. Carter, published on Forth
  \ Dimensions (volume 16, number 2, page 17, 1994-08).

[unneeded] dxor
?\ : dxor  ( d1 d2 -- d3 )  rot xor -rot xor swap  ;

[unneeded] dor
?\ : dor  ( d1 d2 -- d3 )  rot or -rot or swap  ;

[unneeded] dand
?\ : dand  ( d1 d2 -- d3 )  rot and -rot and swap  ;

( m* )

  \ Credit:
  \
  \ Code by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

  \ XXX TODO benchmark with the version in the kernel

need d*

: m*  ( n1 n2 -- d )
  >r s>d r> s>d d* ;

( m+ )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need z80-asm

code m+  ( d1|ud1 n -- d2|ud2 )
  exx     \ save Forth IP
  bc pop  \ n
  de pop  \ d1 hi cell
  hl pop  \ d1 lo cell
  bc addp  hl push
  cy if  de inc  then  de push
  exx      \ restore Forth IP
  jpnext
  end-code

  \ doc{
  \
  \ m+  ( d1|ud1 n -- d2|ud2 )
  \
  \ Add _n_ to _d1|ud1_, giving the sum _d2|ud2_.
  \
  \ Origin: Forth-94 (DOUBLE) Forth-2012 (DOUBLE).
  \
  \ }doc

exit

  \ This alternative is slower (1.48), but saves 4 bytes.

: m+  ( d1|ud1 n -- d2|ud2 )  s>d d+  ;

( m*/ )

  \ Credit:
  \
  \ Code from Gforth 0.7.3.

: m*/  ( d1 n1 +n2 -- d2 )

  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;

  \ doc{
  \
  \ m*/  ( d1 n1 +n2 -- d2 )
  \
  \ Multiply _d1_ by _n1_ producing the triple-cell
  \ intermediate result _t_.  Divide _t_ by _+n2_ giving the
  \ double-cell quotient _d2_.
  \
  \ }doc

  \ XXX TODO -- see difference Gforth - Forth-94

( m*/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need mt*  need tnegate  need ut/

: m*/  ( d1 n1 +n2 -- d2 )
    >r mt* dup 0< if    tnegate r> ut/ dnegate
                  else  r> ut/  then  ;

( dsqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need q2*  need d2*  need d<  need m+  need d- need 2rot
need 2nip  [defined] cell-bits ?\ 16 constant cell-bits

  \ XXX FIXME wrong results
  \
  \ It worked fine, but something got wrong
  \ Perhaps because of some wrong dependency?
  \ maybe `d<`?
  \
  \ It works in Gforth

: (dsqrt)  ( radicand . -- remainder . root . )
  0. 0.             ( radicand . remainder . root . )
  cell-bits 0 do    ( radicand . remainder . root . )
    cr .s  key drop  \ XXX INFORMER
    2>r q2* q2* 2r>  d2*
    2over 2over d2* 2swap
      cr .s ." d< ?"  \ XXX INFORMER
      d< if
      cr .s ." d<"  \ XXX INFORMER
      2dup 2>r d2* d- -1 m+ 2r>  1 m+
    then
  loop  cr .s 2rot 2drop  ;

: dsqrt  ( radicand . -- root . )  (dsqrt) 2nip  ;

( d10* )

  \ Credit:
  \ Code from Pygmy Forth.

: d10*  ( ud -- ud*10 )  d2* 2dup d2* d2* d+  ;

  \ vim: filetype=soloforth
  \ math.operators.3-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604150254

  \ -----------------------------------------------------------
  \ Description

  \ Triple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( tum* tum/ t+ t- )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

  \ XXX TODO -- test

need d-

: +carry  ( n1 n2 -- n1+n2 carry )  0 tuck d+  ;

: -borrow  ( n1 n2 -- n1-n2 borrow )  0 tuck d-  ;

: tum*  ( d n -- t )  2>r  r@ um*  0 2r>  um* d+  ;
  \ Triple unsigned mixed multiply.

: tum/  ( t n -- d )  dup >r um/mod r> swap >r um/mod nip r>  ;
  \ Triple unsigned mixed division.

: t+  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r +carry  0 r> r> +carry d+ r> r> + +  ;
  \ Triple add.

: t-  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r -borrow
  s>d r> r> -borrow d+ r> r> - +  ;
  \ Triple substract.

( tnegate )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: tnegate  ( t1 -- t2 )
  invert >r
  invert >r
  invert 0 -1 -1 d+ s>d r> 0 d+
  r> +  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ tnegate  ( t1 -- t2 )
  \
  \ _t2_ is the negation of _t1_.
  \
  \ }doc

( ut* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut*   ( ud u -- t )
  swap >r dup >r
  um* 0 r> r> um* d+  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut*   ( ud u -- t )
  \
  \ _t_ is the signed product of _ud_ times _u_.
  \
  \ }doc

( mt* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need ut*  need tnegate

: mt*   ( d n -- t )
  dup 0<
  if   abs over 0< if   >r dabs r> ut*  else ut* tnegate then
  else over 0< if  >r dabs r> ut* tnegate  else  ut*  then
  then ;

  \ XXX TODO -- test

  \ doc{
  \
  \ mt*   ( d n -- t )
  \
  \ _t_ is the signed product of _d_ times _n_.
  \
  \ }doc

( ut/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut/   ( ut n -- d )
  dup >r um/mod -rot r> um/mod nip swap  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut/   ( ut n -- d )
  \
  \ Divide a triple unsigned number _ut_ by a single number _n_
  \ giving the double number result _d_.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.operators.4-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604271709

  \ -----------------------------------------------------------
  \ Description

  \ Quadruple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-13: Add `q2*`.

( q2* )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need d2*

: q2*  ( n . . . -- 2n . . . )
  d2* >r >r
  dup 0< if     d2* r> 1+ r>
         else   d2* r> r>
         then  ;

( q+ q- q0< q0= qu< qnegate qabs )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

code q+  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

code q-  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

: q0<  ( nq -- f )  0< push drop 2drop pop  ;
: q0=  ( nq -- f )  or or or 0=  ;
: qu<  ( uq uq -- f )  q- q0<  ;
: qnegate  ( nq -- nq' )  0 0 0 0 4swap q-  ;
: qabs  ( nq -- uq )  dup 0< if qnegate then  ;

( udm* dm* )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

need qnegate

code udm*  ( ud ud - quad )
  \ XXX TODO -- port to Z80
end-code

: dm* ( nd nd - nq )
  2>r dup 0< dup >r if  dnegate  then
  r> 2r> dup 0< dup >r if  dnegate  then
  rot >r udm* 2r> xor 0< if  qnegate  then  ;

  \ vim: filetype=soloforth
  \ memory.address_register.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605101814

  \ -----------------------------------------------------------
  \ Description

  \ Address register store and fetch words.
  \
  \ There aren't any spare registers to make this as efficient
  \ as it could be. However, it can still give a useful
  \ improvement in loops, and in many cases also results in
  \ cleaner-looking code.  (From the original source of Z88
  \ CamelForth, by Garry Lancaster.)

  \ -----------------------------------------------------------
  \ Authors

  \ Garry Lancaster wrote the original code for Z88 CamelForth,
  \ 2001.
  \
  \ Marcos Cruz (programandala.net) adapted the code for Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-07-20: Copy the code from Z88 CamelForth. Start
  \ adapting it.
  \ 2015-07-21: Finish the adaption. Not tested yet.
  \ 2015-07-22: Let independent loading of the words.
  \ 2016-05-07: Make block titles compatible with `indexer`.
  \ 2016-05-10: Compact the blocks. Fix `!a`, `!a+`, `c@a+`.
  \ Document.

( a a! a@ )

variable a

  \ doc{
  \
  \ a  ( -- a )
  \
  \ A variable that holds the address register.
  \
  \ See `a!`, `a@`,
  \ `!a`, `@a`, `c!a`, `c@a`, `!a+`, `@a+`, `c!a+`, `c@a+`.
  \
  \ }doc

code a!  ( a0 -- )  E1 c, 22 c, a , jpnext  end-code
    \ pop hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ a!  ( a -- )
  \
  \ Set the address register.
  \
  \ See `a`, `a@`.
  \
  \ }doc

code a@  ( -- a0 )  2A c, a , C3 c, pushhl ,  end-code
    \ ld hl,(a)
    \ jp pushhl

  \ doc{
  \
  \ a@  ( -- a )
  \
  \ Get the address register.
  \
  \ See `a`, `a!`.
  \
  \ }doc

( !a @a c!a c@a )

need a  need ?(

[unneeded] !a ?(
code !a  ( x -- )  D1 c, 2A c, a , 70 03 + c, 23 c, 70 02 + c,
                   jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ jp next

  \ doc{
  \
  \ !a  ( x -- )
  \
  \ Store _x_ at the address register.
  \
  \ See `a`, `@a`.
  \
  \ }doc

[unneeded] @a ?(
code @a  ( -- x )  2A c, a , 5E c, 23 c, 66 c, 68 03 + c,
                   C3 c, pushhl ,  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld h,(hl)
    \ ld l,e
    \ jp pushhl

  \ doc{
  \
  \ @a ( -- x )
  \
  \ Fetch _x_ at the address register.
  \
  \ See `a`, `!a`.
  \
  \ }doc

[unneeded] c!a ?(
code c!a  ( c -- )  D1 c, 2A c, a , 70 03 + c, jpnext
                    end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ c!a  ( c -- )
  \
  \ Store _c_ at the address register.
  \
  \ See `a`, `c@a`.
  \
  \ }doc

[unneeded] c@a ?(
code c@a  ( -- c )  2A c, a , 6E c, 26 c, 00 c, C3 c, pushhl ,
                    end-code ?)
    \ ld hl,(a)
    \ ld l,(hl)
    \ ld h,0
    \ jp pushhl

  \ doc{
  \
  \ c@a ( -- c )
  \
  \ Fetch _c_ at the address register.
  \
  \ See `a`, `c!a`.
  \
  \ }doc

( !a+ @a+ c!a+ c@a+ )

need a  need ?(

[unneeded] !a+ ?(
code !a+  ( x -- )
  D1 c, 2A c, a , 70 03 + c, 23 c, 70 02 + c, 23 c, 22 c, a ,
  jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ inc hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ !a+  ( x -- )
  \
  \ Store _x_ at the address register and increment the address
  \ register by one cell.
  \
  \ See `a`, `@a+`.
  \
  \ }doc

[unneeded] @a+ ?(
code @a+  ( -- x )
  2A c, a , 5E c, 23 c, 56 c, 23 c, 22 c, a , D5 c, jpnext
  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc hl
    \ ld (a),hl
    \ push de
    \ jp next

  \ doc{
  \
  \ @a+ ( -- x )
  \
  \ Fetch cell at the address register and increment the
  \ address register by one cell.
  \
  \ See `a`, `!a+`.
  \
  \ }doc


[unneeded] c!a+ ?(
code c!a+  ( c -- )  D1 c, 2A c, a , 70 03 + c, 23 c,
                     22 c, a , jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ c!a+  ( c -- )
  \
  \ Store _c_ at the address register and increment the address
  \ register by one address unit.
  \
  \ See `a`, `c@a+`.
  \
  \ }doc

[unneeded] c@a+ ?(
code c@a+  ( -- c )  2A c, a , 5E c, 23 c, 16 c, 00 c,
                     22 c, a , D5 c, jpnext  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld d,0
    \ ld (a),hl
    \ push de
    \ jp next

  \ doc{
  \
  \ c@a+  ( -- c )
  \
  \ Fetch _c_ at the address register and increment the address
  \ register by one address unit.
  \
  \ See `a`, `c!a+`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.alocate.charlton.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181528

  \ -----------------------------------------------------------
  \ Description

  \ A standard implementation of the memory-allocation word
  \ set.

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, `allocate`,
  \ `free`, and `resize` which give the minimum functionality
  \ required to use the heap. These are given in areas 3, 4 and
  \ 5 respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant `heapsize`. the constant
  \ `hysteresis` controls the amount of spare space that is
  \ added to an allocation, to reduce the need for block moves
  \ during resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright Gordon Charlton, 1994-09-12.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ Solo Forth version of the code:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ Original code:

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.  <gordon at charlton dot
  \ demon dot co dot uk>

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-18: Need `vocabulary`, which has been moved to the
  \ library.

( heap )


  \ XXX REMARK: 1614 bytes used

  \ XXX TODO use top of memory instead of dictionary space?
  \ problem: memory banks could not be used at the same time.
  \
  \ XXX TODO use a memory bank instead of dictionary space?
  \ problem: only words below 0xC000 could manipulate the heap.

also forth definitions
need vocabulary  need wid-of
vocabulary heap-voc  wid-of heap-voc constant heap-wordlist
also heap-voc definitions

  \ XXX TODO -- alternative
  \ forth-wordlist set-current
  \ wordlist heap-wordlist

  \ **1** General Purpose Extensions

0 1 2 um/mod nip 1- constant maxpos
  \ XXX TODO use `environment?` instead when available

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  --  Constants

256 cells constant heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 cells 1- constant hysteresis

  \ Node lengths are rounded up according to the value of
  \ `hysteresis` to reduce the number of block moves during
  \ `resize` operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

3 cells constant headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis or  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize constant overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  --  Structure

create sentinel  here cell+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

create heap  heapsize allot

  \ The heap is as described in `headsize`.

variable nextnode  -->

  \ Searching is done using a "nextfit" algorithm. `nextnode`
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr1 -- addr2)  cell+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr1 -- addr2)  [ 2 cells ] literal +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )
  heap dup nextnode !
  dup dup !
  dup heapsize  over >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does
  \ `nextnode`.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  --  List Searching

: attach ( addr)
  >prev @  dup sentinel rot !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (_addr_) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >r begin 2@ swap R@ < invert until
  r> drop  >prev @  ;

  \ Search the nodelist, starting at the node specified
  \ (_addr_), for a free node larger than or equal to the
  \ specified _size_.  Return the address of the first node
  \ that matches, or zero for no match. The heap structure is
  \ set up to make this a near optimal search loop. The "size"
  \ field is next to the "next" field so that both can be
  \ collected in a single operation (2@). Nodes in use have
  \ negated sizes so they never match the search. The
  \ "previous" field is included to allow the search to
  \ overshoot the match by one node and then link back outside
  \ the loop, rather than remembering the address of the node
  \ just examined. The sentinel removes the need for a separate
  \ test for failure. `search` assumes the sentinel is in
  \ place.

: detach ( addr)  dup >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           dup      attach
           dup rot  search
           swap     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ `nextnode`, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  --  Head Creation

: fits ( size addr -- flag)  >size @ swap -  overhead  <  ;

  \ Returns _true_ if the size of the node specified is the
  \ same as the specified size, or larger than it by less than
  \ the size of the smallest possible node. Returns _false_
  \ otherwise.

: togglesize ( addr)  >size dup @  negate swap !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2dup + >r  >size 2dup @ swap -
  R@ >size !   swap negate swap !  r>  ;

  \ Given a free node (_addr_), reduce its size to that
  \ specified and mark it as in use. Start to construct a new
  \ node within the specified node beyond its new length, by
  \ storing the length of the remainder of the node in the size
  \ field of the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2dup swap @  2dup  swap !  >prev !
  2dup >prev !   swap !  ;


  \ _Addr1_ is an existing node. _Addr2_ is the address of a
  \ new node just above the existing node. Break the links from
  \ the existing node to the next node and from the next node
  \ to the existing node and join the new node to them.


  \ ANSI heap  --  Node Construction  ALLOCATE

: newnode ( size addr)  tuck sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)
  2dup fits if  togglesize drop  else  newnode  then  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

forth-wordlist set-current

: allocate ( u -- addr ior)
  dup 0< if  -59  \ `allocate` error code
       else  adjustsize
       dup findspace
       dup if  dup next!
         tuck makenode
         headsize +  0
         else  drop -59  \ `allocate` error code
         then
       then  ;

heap-wordlist set-current  -->

  \ Make an in-use node with a data field at least _u_ address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and the standard ior.  The
  \ standard specifies that the argument to `allocate` is
  \ unsigned. As the implementation uses the sign bit of the
  \ size field for its own purposes any request for an amount
  \ of space greater than `maxpos` must fail. As this would be
  \ a request for half the addressable memory or more this is
  \ not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  --  Head Destruction

: mergesizes ( addr1 addr2)
  >size @ swap >size +!  ;

  \ Make the size field of the node at _addr1_ equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at _addr2_ will be the one immediately above _addr1_.

: mergelinks ( addr1 addr2)
  @ 2dup swap !  >prev !  ;

  \ The node at _addr2_ is removed from the node list. As with
  \ `mergesizes` the node at _addr2_ will be immediately above
  \ that at _addr1_. Destroy the link from node1 to node2 and
  \ relink node1 to the node above node2. Destroy the backward
  \ link from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that `nextnode` may point to it. This is cured by
  \ making it point to the node prior to the one removed. We do
  \ not want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically `nextnode` is set to
  \ point to the node pointed to by the "previous" field of the
  \ node pointed to in the "next" field of the node pointed to
  \ by `nextnode`. Ordinarily this is a no-op (ie I am my
  \ father's son) but when the node has had its links merged it
  \ sets `nextnode` to point to the node prior to the node it
  \ pointed to (ie when I died my father adopted my son, so now
  \ my son is my father's son).

: merge ( addr)
  dup @ 2dup mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  --  Node Removal

: ?merge ( addr1 addr2)
  >size @ 0> if
    dup dup @
    u< if  dup merge  then
  then  drop  ;  -->

  \ Merge the node at _addr1_ with the one above it on two
  \ conditions, firstly that the node at _addr2_ is free, and
  \ secondly that the node pointed to by the next field in
  \ _addr1_ is actually above _addr1_ (ie that it does not wrap
  \ around because it is the topmost node). In usage _addr2_
  \ will be either _addr1_ or the node above it. In each
  \ instance the other affected node (either the node above
  \ _addr1_ or _addr1_) is known to be free, so no test is
  \ needed for this.

( heap )

: ?mergenext ( addr)  dup @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ dup ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

forth-wordlist set-current

: free ( addr -- ior)
  headsize -  dup togglesize  dup ?mergenext  ?mergeprev  0  ;

heap-wordlist set-current

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  --  Node Repairing

variable stash

  \ the `resize` algorithm is simplified and made faster by
  \ assuming that it will always succeed. `stash` holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ saves the contents of the `>next` field of the node being
  \ `resize`d in `stash` (above).

: restorelink ( addr)  stash @  swap !  ;

  \ Converse operation to `savelink` (above).

: fixprev ( addr)  dup >prev @ !  ;

  \ The `>next` field of the node prior to the node being
  \ `resize`d should point to the node being `resize`d. it may
  \ very well do already, but this makes sure.

: fixnext ( addr)  dup @ >prev !  ;

  \ The `>prev` field of the node after the node resized may
  \ need correcting.  This corrects it whether it needs it or
  \ not.  (Its quicker just to do it than to check first.)

: fixlinks ( addr)  dup fixprev  dup fixnext  @ fixnext  ;

  \ `resize` may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of `jiggle` (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)
  dup >size @ 0>
  if  dup @  2dup <
      if    over - swap >size !  else  2drop  then
  else  drop  then  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the `>next` field provided
  \ that the node is free and it is not the topmost node in the
  \ heap (ie there is no wraparound). Both these conditions
  \ need to be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  dup fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to `resize` (damaged by
  \ `?mergenext`) and its predecessor (damaged by `?mergeprev`).

: repair ( addr)
  dup restorelink
  dup fixlinks  dup fixsizes
  togglesize  ;

  \ Make good the damage done by `resize`. Restore the `>next`
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer `nextnode`
  \ may have moved back one or two nodes by virtue of having
  \ been `jiggle`d about if it happened to be pointing to the
  \ wrong node. This is not serious, so I have chosen to ignore
  \ it.


  \ ANSI Heap  --  Node Movement

: toobig? ( addr size -- flag)
  swap  >size @  >  ;

  \ _Flag_ is true if the node at _addr_ is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
  over >size @  headsize -
  rot  headsize + rot rot move  ;

  \ Move the contents of the data field of the node at _addr1_
  \ to the data field at _addr2_. Assumes _addr2_ is large
  \ enough. It will be.

: enlarge ( addr1 size -- addr2 ior)
  over  ?mergeprev
  allocate dup >r
  if  swap repair  else  tuck copynode  then  r>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of _addr1_ to the new node. Merge the node at addr1 with
  \ the one preceding it, if possible. This last behaviour is
  \ to finish off removing the node at _addr1_. The word
  \ `adjust` (below) starts removing the node. The node is
  \ removed before allocation to increase the probability of
  \ `allocate` succeeding. The address returned by `enlarge` is
  \ that returned by `allocate`, which is that of the data
  \ field, not the head. If the allocation fails repair the
  \ damage done by removing the node at _addr1_.


  \ ANSI Heap  --  Node Restructuring

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >r
  headsize -
  dup savelink
  dup togglesize
  dup ?mergenext r>  ;

  \ _Addr1_ points to the data field of a node, not the "next"
  \ field. This needs correcting. _Size1_ also needs adjusting
  \ as per `adjustsize`. In addition it is easier to work with
  \ free nodes than live ones as the size field is correct,
  \ and, as we intend to change the nodes size we will
  \ inevitably want to muck about with the next node, if its
  \ free, so lets merge with it straight away. Sufficient
  \ information is first saved to put the heap back as it was,
  \ if necessary.  Now we are ready to get down to business.

-->

( heap )

forth-wordlist set-current

: resize ( addr1 u -- addr2 ior)
  dup 0<  if  drop -61  \ `resize` error code
          else  adjust  2dup toobig?
                if enlarge
                else  over makenode headsize +  0  then
          then  ;

  \ Resize the node at _addr1_ to the specified size. Return
  \ the address of the resized node _addr2_ along with an _ior_
  \ of zero if successful and -61 if not. _Addr2_ may be the
  \ same as, or different to, _addr1_.  If _ior_ is non-zero
  \ then _addr2_ is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using `makenode`,
  \ which has just the right functionality.  In this case the
  \ ior is zero. As this is a standard word it takes an
  \ unsigned size argument, but excessive requests fail
  \ automatically, as with `allocate`.

  \ vim: filetype=soloforth
  \ memory.alocate.gil.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604242144

  \ -----------------------------------------------------------
  \ Description

  \ An alternative implementation of the
  \ common heap based on code written by Javier Gil.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on "Gestor de memoria dinmica (version 1)" by Javier
  \ Gil, from his book _Introduccin a Forth_ (2007-01),
  \ <http://disc.ua.es/~gil/#forth>.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-18: Start.
  \ 2015-11-21: Changes.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( create-heap )

need value  need set-bit  need reset-bit  need bit?
need reserve  need alias

0 value heap  ( -- a )
  \ Address of the current heap.

8 constant address-unit-bits
16 value /chunk \ bytes per chunk

: groups ( n1 n2 -- n3 )  /mod swap 0<> abs +  ;
  \ Return the number _n3_ of groups of _n2_ elements, needed
  \ to hold _n1_ elements.

: bytes>chunks ( n1 -- n2 )  /chunk groups  ;
  \ Return the chunks _n2_ required to allocate _n1_ bytes.

: chunks>bytes ( n1 -- n2 )  address-unit-bits groups  ;
  \ Return the bytes _n2_ required for a bitmap of _n1_ chunks.

' heap alias heap-chunks  ( -- a )
  \ Address that holds the number of chunks of the current
  \ heap.

: heap-unused-chunks  ( -- a )  heap-chunks cell+  ;
  \ Address that holds the number of unused chunks of the
  \ current heap.

: heap-map  ( -- a )  heap-unused-chunks cell+  ;
  \ Address of the current heap's map.

: /heap-map  ( -- n )  heap-chunks @ chunks>bytes  ;
  \ Number of bytes of the current heap's map.

: heap-data  ( -- a ) heap-map /heap-map +  ;  -->
  \ Address of the current heap's data space.

( create-heap )

: (mapbit)  ( n1 -- n2 ca )
  address-unit-bits /mod heap-map +  ;
  \ n1 = number of bit in the bitmap
  \ n2 = number of bit in the byte at _a2_
  \ ca = address of the bitmap that holds bit _n2_

: mapbit ( n1 -- a2 b n2 )  (mapbit) dup @ rot  ;
  \ n1 = number of bit in the bitmap
  \ a2 = address of the correspondent byte
  \ b =  correspondent byte
  \ n2 = number of bit in _b_

: used-chunk? ( n -- f )  (mapbit) @ swap bit?  ;
  \ Is chunk _n_ used?

: use-chunk ( n -- )  mapbit set-bit swap !  ;
  \ Mark chunk _n_ as used.

: free-chunk ( n -- )  mapbit reset-bit swap !  ;
  \ Mark chunk _n_ as free.

: allocated>chunks  ( a -- n )  cell- @  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its number of chunks.

: allocated>index  ( a -- n )  heap-data - /chunk /  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n_ in the map of the heap
  \ chunks.

: allocated>map  ( a -- n1 n2 )
  dup allocated>index swap allocated>chunks  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n1_ in the map of heap chunks
  \ and the number _n2_ of ocuppied chunks.

-->

( create-heap )

: locate-chunks  ( n1 -- n1 n2 0 | ior )
  0 tuck  ( n2 n1 count )
  heap-chunks @ 0 do  ( n2 n1 count )
    i used-chunk? if  drop >r i 1+ r> 0  else  1+  then
    2dup = if  drop swap 0 unloop exit  then
  loop  2drop drop -59  ;
  \ Locate _n1_ consecutive free chunks in the current heap.
  \ If succesful, _n2_ is the first chunk of the group;
  \ else return _ior_ -59, the error code for `allocate`.

: chunk>address  ( n1 -- a )  /chunk * heap-data +  ;

: (allocate)  ( n1 n2 -- a )
  dup chunk>address >r
  swap bounds do  i use-chunk  loop
  r>  ;
  \ Allocate _n1_ chunks of the current heap, starting from
  \ chunk _n2_; return the address _a_ of the allocated space.

-->

( create-heap )

  \ User interface

: create-heap ( n "name" -- )
  create  bytes>chunks dup ,  0 ,
            \ max chunks and free chunks
          dup chunks>bytes reserve drop
            \ bitmap
          /chunk * allot  ;
            \ data space
  \ Create a new heap "name" to hold _n_ bytes.

: allocate  ( n -- a ior )
  bytes>chunks locate-chunks ?dup ?exit  (allocate) 0  ;

: free  ( a -- ior )
  allocated>map dup >r
  bounds do  i free-chunk  loop
  r> heap-unused-chunks +! 0  ;

  \ XXX TODO -- update with `resize`
  \ doc{
  \
  \ free  ( a -- ior )
  \
  \ Return the contiguous region of data space indicated by _a_
  \ to the system for later allocation. _a_ shall indicate a
  \ region of data space that was previously obtained by
  \ `allocate`.
  \
  \ If the operation succeeds, _ior_ is zero. If the operation
  \ fails, _ior_ is -60.
  \
  \ Origin: Forth-94 (MEMORY), Forth-2012 (MEMORY).
  \
  \ }doc

: empty-heap  ( -- )  heap-chunks @ 0 do  i free-chunk  loop  ;
  \ Empty the current heap, setting all chunks free.

: .heap ( -- )
  heap-chunks @ 0 do
    i used-chunk? if  'x'  else  '-'  then  emit
  loop  ;

  \ Print the map of the current heap. Occupied chunks are
  \ marked with a "x"; free chunks are marked with a "-".

  \ vim: filetype=soloforth

  \ memory.bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241652

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory banks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-17: Moved `!s` and `!cs` from the kernel.
  \
  \ 2016-04-24: Moved `get-default-bank` and `set-default-bank`
  \ from the kernel.

( !s c!s )

: !s  ( x a -- )  system-bank ! default-bank  ;

  \ doc{
  \
  \ !s  ( x a -- )
  \
  \ Store _x_ into address _a_ of the system bank.
  \
  \ }doc

: c!s  ( c ca -- )  system-bank c! default-bank  ;

  \ doc{
  \
  \ c!s  ( c ca -- )
  \
  \ Store _c_ into address _ca_ of the system bank.
  \
  \ }doc

( get-default-bank set-default-bank )


: get-default-bank  ( -- +n )  default-bank# c@  ;

  \ doc{
  \
  \ get-default-bank  ( -- +n )
  \
  \ Get the current default bank _+n_ (0..7) paged in at
  \ $C000..$FFFF.
  \
  \ }doc

: set-default-bank  ( +n -- )  default-bank# c!  ;

  \ doc{
  \
  \ set-default-bank  ( +n -- )
  \
  \ Set _+n_ (0..7) as the default memory bank paged in at
  \ $C000..$FFFF.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.code-bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201606010100

  \ -----------------------------------------------------------
  \ Description

  \ Tool to use a 16-KiB memory bank to store binary code,
  \ Forth words or data.  The intent is to use it mainly for
  \ binary modules, saving dictionary space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-03-19: First version.
  \ 2016-06-01: Update: `there` was moved from the kernel to
  \ the library.

( code-bank )

need save-here  need call  need there

variable cp  bank-start cp !  \ code pointer

: code-here   ( -- a )  cp @  ;
: code-there  ( a -- )  cp !  ;
: code-allot  ( n -- )  cp +!  ;

variable code-bank#  3 code-bank# !
  \ Memory bank used as code bank.

: code-bank  ( -- )  code-bank# @ bank  ;
  \ Page the code bank in.

: code-bank{  ( -- )  save-here code-here there code-bank  ;
  \ Start compiling code into the code bank.

: }code-bank  ( -- )  default-bank restore-here  ;
  \ End compiling code into the code bank.

: ?bank  ( -- )  bank-start here u< #-276 ?throw  ;
  \ If the dictionary has reached the zone of memory banks,
  \ throw error #-276; else do nothing.  This check is required
  \ after compiling code that manipulates memory banks.

: code-bank-caller  ( i*x a "name" -- j*x )
  create ?bank ,
  does>  ( -- )  ( pfa ) @ code-bank call default-bank  ;
  \ Create a word "name" which will call the machine code
  \ routine at _a_, in the code bank.

?bank

  \ vim: filetype=soloforth
  \ memory.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608011918

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-17: Added `-!`. Documented some words.
  \ 2016-04-23: Added `c-!`.
  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.
  \ 2016-04-25: Add `@cell+`. Move `n,`, `n@`, `n!` from the
  \ module "compilation.fsb".  Add `nn@`, `nn,`, `nn!`.
  \ 2016-04-26: Remove unused words, specific of the TED
  \ editor.
  \ 2016-04-27: Add `/!`, `*!`, `2/!`, `2*!`.
  \ 2016-05-09: Add `align`, `aligned`.
  \ 2016-05-10: Remove the dependency on the assembler.
  \ Compact the blocks. Remove unfinished words from cmForth.
  \ Rename `@cell+` to `@+`. Add `2@+`.
  \ 2016-08-01: Fix header line.
  \ 2016-08-02: Fix requiring `c1+!`, `c1-!`, `1+!` and `1-!`.

( -! c+! c-! )

need ?(

[unneeded] -! ?(

code -!  ( n|u a -- )
  E1 c, D1 c, 7E c, 90 03 + c, 70 07 + c, 23 c,
    \ pop hl ; address
    \ pop de ; number
    \ ld a,(hl)
    \ sub a,e
    \ ld (hl),a
    \ inc hl
  7E c, 98 02 + c, 70 07 + c, jpnext  end-code ?)
    \ ld a,(hl)
    \ sbc a,d
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ -!  ( n|u a -- )
  \
  \ Subtract n|u from the single-cell number at _a_.
  \
  \ }doc

[unneeded] c+! ?(

code c+!  ( c ca -- )
  E1 c, D1 c, 78 03 + c, 86 c, 70 07 + c, jpnext  end-code ?)
    \ pop hl
    \ pop de
    \ ld a,e
    \ add a,(hl)
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ code c+!  ( c ca - )
  \
  \ Add _c_ to the char at _ca_
  \
  \ }doc

[unneeded] c-! ?(

code c-!  ( c ca -- )
  E1 c, D1 c, 7E c, 90 03 + c, 70 07 + c, jpnext  end-code ?)
    \ pop hl
    \ pop de
    \ ld a,(hl)
    \ sub e
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ c-!  ( c ca - )
  \
  \ Subtract _c_ from the char at _ca_
  \
  \ }doc

( c1+! c1-! 1+! 1-! )

[unneeded] c1+!
?\  code c1+!  ( ca -- )  E1 c, 34 c, jpnext  end-code  exit
    \ pop hl
    \ inc (hl)
    \ jp next

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the char at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  E1 c, 35 c, jpnext  end-code  exit
    \ pop hl
    \ dec (hl)
    \ jp next

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the char at _ca_.
  \
  \ }doc

need ?(

[unneeded] 1+! ?(

code 1+!  ( a -- )
  E1 c, 5E c, 23 c, 56 c, 13 c, 70 02 + c, 2B c, 70 03 + c,
  jpnext end-code  ?)
    \ pop hl
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the single-cell number at _a_.
  \
  \ }doc

[unneeded] 1-! ?(

code 1-!  ( a -- )
  E1 c, 5E c, 23 c, 56 c, 1B c, 70 02 + c, 2B c, 70 03 + c,
  jpnext end-code  ?)
    \ pop hl
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the single-cell number at _a_.
  \
  \ }doc

( @+ 2@+ c@+ )

[unneeded] @+
?\ : @+  ( a -- a' x )  dup cell+ swap @  ;

  \ doc{
  \
  \ @+  ( a -- a' x )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by one cell.
  \ This is handy for stepping through cell arrays.
  \
  \ }doc

[unneeded] 2@+
?\ : 2@+  ( a -- a' xd )  dup [ 2 cells ] literal + swap 2@  ;

  \ doc{
  \
  \ @+  ( a -- a' x )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by two cells.
  \ This is handy for stepping through double-cell arrays.
  \
  \ }doc

[unneeded] c@+ ?exit

code c@+  ( ca -- ca' c )
  E1 c, 7E c, 23 c, E5 c, C3 c, pusha ,  end-code
    \ pop hl
    \ ld a,(hl)
    \ inc hl
    \ push hl
    \ jp push_a

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ doc{
  \
  \ code c@+  ( ca -- ca' c )
  \
  \ Fetch the character _c_ at _ca_. Return _ca'_, which is
  \ _ca_ incremented by one address unit.
  \ This is handy for stepping through character arrays.
  \
  \ }doc

( n, nn, n@ nn@ n! nn! )

[unneeded] n, ?\ : n,  ( xu..x1 u -- )  0 ?do  ,  loop  ; exit
  \ If _u_ is not zero, store _u_ cells _xu..x1_ into data
  \ space, being _x1_ the first one stored and _xu_ the last
  \ one.

need ?(  [unneeded] nn, ?(  need need-here  need-here n,
: nn,  ( xu..x1 u -- )  dup , n,  ; ?)
  \ Store the count _u_ into data space.  If _u_ is not zero,
  \ store also _u_ cells _xu..x1_ into data space, being _x1_
  \ the first one stored and _xu_ the last one.

[unneeded] n@ ?(
: n@  ( a u -- xu..x1 )
  tuck 1- cells +  \ point _a_ to _xu_
  swap 0 ?do  dup i cells - @ swap  loop  drop  ; exit ?)
  \ If _u_ is not zero, read _u_ cells _xu..x1_ from
  \ _a_, being _x1_ the first one stored and _xu_ the last
  \ one.

[unneeded] nn@ ?( need need-here  need-here n@
: nn@  ( a -- x1..xu u | 0 )  dup @ >r cell+ r@ n@ r>  ; ?)
  \ Read the count _u_ from _a_.  If it's zero, return it.  If
  \ _u_ is not zero, read _u_ cells _xu..x1_ from the next cell
  \ address, being _x1_ the first cell stored there and _xu_
  \ the last one.

[unneeded] n! ?(
: n!  ( xu..x1 u a -- )
  swap 0 ?do  dup >r ! r> cell+  loop  drop  ; exit ?)
  \ If _u_ is not zero, store _u_ cells at address _a_, being
  \ _x1_ the first cell stored there and _xu_ the last one.

[unneeded] nn! ?( need need-here  need-here n!
: nn!  ( xu..x1 u a -- )  2dup ! cell+ n!  ; ?)
  \ Store the count _u_ at _a_.  If _u_ is not zero, store also
  \ _u_ cells _xu..x1_ at the next cell address, being _x1_ the
  \ first one stored and _xu_ the last one.

( bit>mask bit? set-bit reset-bit )

[unneeded] bit? [unneeded] set-bit? [unneeded] reset-bit?
[unneeded] bit>bask and and and
?\ need lshift  : bit>mask  ( n -- b )  1 swap lshift  ;

  \ doc{
  \
  \ bit>mask  ( n -- b )
  \
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.
  \
  \ }doc

[unneeded] bit?
?\ : bit? ( b n -- f )  bit>mask and 0<> ;

  \ doc{
  \
  \ bit? ( b n -- f )
  \
  \ Is bit _n_ of _b_ set?
  \
  \ }doc

[unneeded] set-bit?
?\ : set-bit ( b1 n -- b2 )  bit>mask or ;

  \ doc{
  \
  \ set-bit ( b1 n -- b2 )
  \
  \ Set bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

[unneeded] reset-bit?
?\ : reset-bit ( b1 n -- b2 )  bit>mask invert and ;

  \ doc{
  \
  \ reset-bit ( b1 n -- b2 )
  \
  \ Reset bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credit:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need ?(

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- f )
  \   hl pop  de pop  e a ld  m and
  \   ' true jpnz  ' false jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s '<' emit type '>' emit cr

[unneeded] c@test-bits ?(
code c@test-bits  ( b1 ca -- b2 )
  E1 c, D1 c, 78 03 + c, A6 c, C3 c, pusha , jpnext end-code ?)
    \ pop hl
    \ pop de
    \ ld a,e
    \ and (hl)
    \ jp push_a

  \ doc{
  \
  \ c@test-bits  ( b1 ca -- b2 )
  \
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.
  \
  \ }doc

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[unneeded] c!toggle-bits ?(
code c!toggle-bits  ( b ca -- )
  E1 c, D1 c, 7E c, A8 03 + c, 70 07 + c, jpnext end-code ?)
    \ pop hl
    \ pop de
    \ ld a,(hl)
    \ xor e
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ c!toggle-bits  ( b ca -- )
  \
  \ Invert the bits at _ca_ specified by the bitmask _b_.
  \
  \ }doc

( exchange reserve alloted align aligned )

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

[unneeded] reserve
?\ : reserve  ( n -- a )  here tuck over erase allot  ;

  \ doc{
  \
  \ reserve  ( n -- a )
  \
  \ Reserve _n_ address units of data space, erase the zone and
  \ return its address _a_.
  \
  \ }doc

[unneeded] alloted
?\ : allotted  ( n -- a )  here swap allot ;

  \ doc{
  \
  \ allotted  ( n -- a )
  \
  \ Reserve _n_ address units of data space and return its
  \ address _a_.
  \
  \ }doc

[unneeded] align
?\ need alias  ' noop alias align immediate

[unneeded] aligned
?\ need alias  ' noop alias aligned immediate

( /! *! 2/! 2*! )

[unneeded] /!
?\ : /!  ( n a -- )  tuck @ swap / swap !  ;

  \ doc{
  \
  \ /!  ( n a -- )
  \
  \ Divide _n_ by the single-cell number at _a_ and store
  \ the quotient in _a_
  \
  \ }doc

[unneeded] *!
?\ : *!  ( n a -- )  tuck @ swap * swap !  ;

  \ doc{
  \
  \ *!  ( n|u a -- )
  \
  \ Multiply _n|u_ by the single-cell number at _a_ and store
  \ the product in _a_
  \
  \ }doc

[unneeded] 2*!
?\ : 2*!  ( a -- )  dup @ 2* swap !  ;

  \ doc{
  \
  \ 2*!  ( a -- )
  \
  \ Do a `2*` shift to the single-cell number at _a_.
  \
  \ See `2*`.
  \
  \ }doc

[unneeded] 2/!
?\ need 2/  : 2/!  ( a -- )  dup @ 2/ swap !  ;

  \ doc{
  \
  \ 2/!  ( a -- )
  \
  \ Do a `2/` shift to the single-cell number at _a_.
  \
  \ See `2/`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.ports.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605071939

  \ -----------------------------------------------------------
  \ Description

  \ Words for ports input and output.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Improve documentation. Compact the blocks.

( @p !p )

need ?(

[unneeded] @p ?(
code @p  ( a -- b )
  E1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 68 c,
    \ pop hl
    \ push bc
    \ ld c,l
    \ ld b,h
    \ in l,(c)
  C1 c,  26 c, 00 c,  jppushhl  end-code
    \ pop bc
    \ ld h,0x00
    \ jp pushhl

  \ doc{
  \
  \ @p  ( a -- b )
  \
  \ Input byte _b_ from port _a_.
  \
  \ }doc

?)

[unneeded] !p ?(
code !p  ( b a -- )
  E1 c,  D1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 59 c,
    \ pop hl
    \ pop de ; char in e
    \ push bc
    \ ld c,l
    \ ld b,h
    \ out (c),e
  C1 c,  jpnext  end-code
    \ pop bc
    \ jp next

  \ doc{
  \
  \ !p  ( b a -- )
  \
  \ Output byte _b_ to port _a_.
  \
  \ }doc

?)

  \ vim: filetype=soloforth
  \ modules.begin-module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604262155

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of named and unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation supports any number of groups of
  \ private and public words, in any order. Beside, named
  \ modules make it possible to use the private words of the
  \ module, if needed.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Code adapted and modified from Galope.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-09: First version, adapted from Galope.

( begin-module: begin-module public private end-module )

need get-order  need wordlist

  \ Inner words

get-order get-current

wordlist dup set-current  >order

variable current-wid  variable module-wid

: (begin-module)  ( -- wid )
  get-current current-wid !
  wordlist dup module-wid ! dup >order  ;

set-current

  \ Interface words

: public  ( -- )  current-wid @ set-current  ;
  \ doc{
  \
  \ public  ( -- )
  \
  \ Public definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: private  ( -- )  module-wid @ set-current  ;
  \ doc{
  \
  \ private  ( -- )
  \
  \ Private definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc


: begin-module:  ( "name" -- )
  (begin-module) constant private  ;
  \ doc{
  \
  \ begin-module:  ( "name" -- )
  \
  \ Start a named module "name".
  \ Private definitions follow.

  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ Usage example:

  \ ----
  \ begin-module: my_module
  \   \ Inner/helper words.
  \ public
  \   \ Interface words,
  \   \ compiled in the outer vocabulary,
  \   \ thus seen from the extern.
  \ private
  \   \ Inner/helper words again.
  \ public
  \   \ Interface words again. And so on.
  \ end-module
  \ ----

  \ The private words can be found using the module name,
  \ which returns the _wid_ of its word list.

  \ As an alternative, the word `begin-module` starts an
  \ unnamed module.
  \
  \ }doc

: begin-module  ( -- )  (begin-module) drop private  ;
  \ doc{
  \
  \ begin-module  ( -- )
  \
  \ Start an anonymous module.
  \ Private definitions follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: end-module  ( -- )  public previous  ;
  \ doc{
  \
  \ end-module  ( -- )
  \
  \ End a module.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

set-order

  \ vim: filetype=soloforth
  \ modules.minus-transient.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201606010101

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of transient modules, whose code is
  \ discarded after being used. First intended for assemblers,
  \ but can be used for any other tool needed during the
  \ compilation of a program, but not during the execution.
  \ The size of the discarded code must be known in advance.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ The code was adapted from the Afera library. The Afera
  \ version was adapted from Spectrum Forth-83 (by Lennart
  \ Benschop, 1988), where it was used only for the assembler.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-06-01: Update: `there` was moved from the kernel to
  \ the library.

( transient[ )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- Finish and test.
  \
  \ XXX TODO -- Check if `current-latest` (old fig-Forth
  \ `latest`) must be used instead of `latest`, which now
  \ (2016-04-26) is standard.

need >>link  need there

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - there  ;
  \ doc{
  \
  \ transient[  ( u -- )
  \
  \ Start transient code, reserving _u_ bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.
  \
  \ See: `]transient`, `-transient`.
  \
  \ }doc


: ]transient  ( -- )  old-dp @ there  old-np @ np !  ;

  \ doc{
  \
  \ ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.
  \
  \ See: `transient[`, `-transient`.
  \
  \ }doc

: -transient  ( -- )
  old-voc-link @ voc-link !
  \ XXX TODO -- finish adapt to Solo Forth:
  old-latest @ old-np @ >>link !s  ;

  \ doc{
  \
  \ -transient  ( -- )
  \
  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.
  \
  \ The inner operation is: Store the _nt_ of the latest word
  \ created before compiling the transient code, into the _lfa_
  \ of the first word created after the transient code was
  \ finished by `]transient`.
  \
  \ See: `transient[`, `]transient`.
  \
  \ }doc

  \ See: `transient[`, `-transient`.

  \ vim: filetype=soloforth
  \ modules.module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060224

  \ -----------------------------------------------------------
  \ Description

  \ Simple and small implementation of unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation uses the data stack for temporary
  \ values and does no error checking.

  \ -----------------------------------------------------------
  \ Authors

  \ Deway Val Schorre wrote the original code for fig-Forth,
  \ which was published on the article _Structured programming
  \ by adding modules to FORTH_, on Forth Dimensions (volume 2,
  \ number 5, page 132, 1981-01).

  \ Marcos Cruz (programandala.net), adapted it to Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10-27: First version, as a simpler alternative to
  \ `privatize`, even with the same names at first.
  \
  \ 2016-04-26: Use `current-latest` (old fig-Forth `latest`)
  \ instead of current standard `latest`. Update the
  \ documentation.
  \
  \ 2016-05-06: Update the requirements: `current-lastest`
  \ moved to the kernel.

( module )

need alias  need >>link

' current-latest alias internal  ( -- nt )

  \ doc{
  \
  \ internal  ( -- nt )
  \
  \ Start private definitions.
  \
  \ Return the _nt_ of the latest word created in the `current`
  \ vocabulary.
  \
  \ See `module` for a usage example.
  \
  \ }doc

' np@ alias external  ( -- a )

  \ doc{
  \
  \ external  ( -- a )

  \ End internal definitions.
  \
  \ Returne the current value of the names pointer, which is
  \ the _xtp_ (execution token pointer) of the next word
  \ defined.
  \
  \ See `module` for a usage example.
  \
  \ }doc

: module  ( nt xtp -- )  >>link !s  ;

  \ doc{
  \
  \ module  ( nt xtp -- )
  \
  \ Hide all words defined between the latest pair `internal`
  \ and `external`, by linking the first word after `external`
  \ to the word before `internal`, thus making the private
  \ words invisible.
  \
  \ Those words are supposed to be needed only within a module
  \ and do not need to be exported.
  \
  \ Usage example:
  \
  \ ----
  \ internal
  \
  \ : hello  ( -- )  ." hello"  ;
  \
  \ external
  \
  \ : salute  ( -- )  hello  ;
  \
  \ module
  \
  \ salute  \ ok!
  \ hello   \ error!
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ modules.privatize.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060225

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of unnamed modules with error checking.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright 1996 Phil Burk.

  \ Adapted from pForth to Solo Forth by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10: First version.
  \
  \ 2016-04-26: Use `current-latest` (old fig-Forth `latest`)
  \ instead of current standard `latest`.
  \
  \ 2016-05-06: Update the requirements: `current-lastest`
  \ moved to the kernel.

( privatize )

need name<name  need abort"

variable private-start  variable private-stop

: private{  ( -- )
  current-latest private-start !  private-stop off  ;

  \ doc{
  \
  \ private{  ( -- )
  \
  \ Start private definitions.  See `privatize` for a usage
  \ example.
  \
  \ }doc

: }private  ( -- )
  private-stop @ abort" Extra }private"
  current-latest private-stop !  ;

  \ doc{
  \
  \ }private  ( -- )
  \
  \ End private definitions. See `privatize` for a usage
  \ example.
  \
  \ }doc

: privatize  ( -- )
  private-start @ 0= abort" Missing private{"
  private-stop @ dup 0= abort" Missing }private"
  begin   dup private-start @ u>
  while   dup hide name<name
  repeat  drop  private-start off  private-stop off  ;

  \ doc{
  \
  \ privatize  ( -- )
  \
  \ Hide all words defined between the latest valid pair of
  \ `private{` and `}private`.

  \ Usage example:
  \
  \ ----
  \ private{
  \ \ everything between `private{` and `}private`
  \ \ will become private.
  \ : foo ;
  \ : moo ;
  \ }private
  \
  \ : goo   foo moo ;  \ can use foo and moo
  \ privatize          \ hide foo and moo
  \ ' foo              \ will fail
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ multitask.benschop.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- not finished

  \ Last modified: 201605171738

  \ -----------------------------------------------------------
  \ Description

  \ Multitask support, adapted from Spectrum Forth-83.

  \ -----------------------------------------------------------
  \ Authors

  \ L.C. Benschop wrote the original code Spectrum Forth-83,
  \ 1988.
  \
  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-17: Start.

( benschop-multitasker )

code switch
  rptr ldhl h push d push h clr sp addp exde uptr
  ldhl h dec d m ld h dec e m ld h dec begin h dec m d ld h
  dec m e ld exde m a ld a or z until
  h inc m e ld h inc  m d ld h inc uptr sthl  exde ldsp
  d pop h pop rptr  sthl jpix end-code

27028 constant uptr  variable task-link  variable first-task

: task:  ( "name" -- )
  create here $243 + , ( eerste adres ip)
  task-link @ ,  here task-link !  ( link naar vorige taak)
  here first-task @ !  ( maak cirkel rond)
  1 c, 0 , ( nog niet starten&ruimte sp)
  uptr @ here $3C cmove  here 23c + here $0E + ! here
  $013C + here $10 + ! $023C allot ( user-variabelen+stack)
  smudge ] current @ context ! !csp -->

( benschop-multitasker )

  does> dup $15 + @ 4 - ( stackpointer)
  2dup swap 5 + !  2dup swap @ swap !  ( ip op stack)
  over $17 + @ swap 2+ !  ( rp op stack)
  0 swap 4 + c! ( runnable) ;

: terminate 2 uptr @ 3 - c!  switch  ;
: sleep     3 uptr @ 3 - c!  switch  ;
: stop  ( tid -- )  4 swap 7 + c!  ;
: start ( tid -- )  0 swap 7 + c!  ;

: ;task compile terminate ?csp smudge [compile] [ ; immediate

task: main-task
 cr ." multi-tasking operating system"
 begin cr &> emit query
 interpret state @ 0= if ." ok" then 0 until ;task

' main-task 5 + first-task !  ' main-task 7 + task-link !
task-link @ first-task @ !  -->

( benschop-multitasker )

code (start)
  ' switch h ldp# (wait) sthl first-task @ 5 +
  h ldp# uptr sthl h dec m d ld h dec m e ld exde ldsp d pop
  h pop rptr sthl jpix end-code

: startup  ( -- )  main-task (start)  ;

: tasks  ( -- )
  uptr @ dup 27039 = cr if  ." multitasking not active"  else
  dup 10 - >name id. 6 emit ." active"
  begin  5 - @ 3 + dup uptr @ -  while
    cr dup 10 - >name id. 6 emit dup 3 -
    c@ dup 0 = if ." runnable" then
       dup 1 = if ." new"      then
       dup 2 = if ." terminated" then
       dup 3 = if ." sleeping" then
           4 = if ." stopped" then  repeat then drop  ;

  \ vim: filetype=soloforth
  \ multitask.muench-koh.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- not finished

  \ Last modified: 201605171604

  \ -----------------------------------------------------------
  \ Description

  \ Multitask support, adapted from eForth and hForth.
  \
  \ Reference: Forth Dimensions (volume 18, number 2, page 32).

  \ -----------------------------------------------------------
  \ Authors

  \ Bill Muench wrote the original code for eForth, 1993-1997.
  \
  \ Wonyong Koh adapted it to hForth, 1995,1997.
  \
  \ Marcos Cruz (programandala.net) wrote a version for Solo
  \ Forth, based on eForth and hForth, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-17: Start.

( muench-koh-multitasker )

get-current forth-wordlist set-current  need user

  \ Structure of a task created by TASK:
  \
  \ userP (points `follower`)
  \ return_stack
  \ data_stack
  \ user_area
  \ user1
  \ taskName
  \ throwFrame
  \ tos
  \ status
  \ follower
  \ sp0
  \ rp0

  \ user u1        \ free
  \ user tf        \ throw frame
  \ user tid       \ back link tid
user tos       \ top of stack
user status    \ `branch` or `wake`
user follower  \ address of next task's `status`

: pause  ( -- )
  rp@ sp@ tos !  follower @ >r  ; compile-only

  \ doc{
  \
  \ pause  ( -- )
  \
  \ Allow another task to execute:
  \ Stop current task and transfer control to the task of which
  \ `status` user variable is stored in `follower` user variable
  \ of current task.
  \
  \ }doc


: wake  ( -- )
  r> userp !  \ `userp` points `follower` of current task
  tos @ sp! rp!  ; compile-only

  \ doc{
  \
  \ wake  ( -- )
  \
  \ Wake current task.
  \
  \ }doc

: stop  ( -- )  ['] branch status ! pause  ;

  \ doc{
  \
  \ stop  ( -- )
  \
  \ Sleep current task.
  \
  \ }doc

: 's  ( tid a -- a' )
  \ follower  cell+ - swap @ + ;  \ XXX TMP -- eForth
  userP @ - swap  ( offset tid )  @ +  ;

  \ doc{
  \
  \ 's  ( tid a -- a' )
  \
  \ Index another task's user variable.
  \
  \ }doc

: sleep  ( tid -- )  status 's  ['] branch  swap !  ;

  \ doc{
  \
  \ Sleep another task.
  \
  \ }doc


: awake  ( tid -- )  status 's  ['] wake  swap !  ;

  \ doc{
  \
  \
  \ awake  ( tid -- )
  \
  \ Wake another task.
  \
  \ }doc

-->

( muench-koh-multitasker )

  \ XXX TMP -- eForth version of `task` (called `hat`):
 \ : HAT ( u s r "name" -- ) ( -- tid )
 \   CREATE + SWAP
 \   [ D# 7 CELLS ] LITERAL + ( TF\TID\TOS\STATUS\FOLLOWER\r>--<s )
 \   DUP HERE + ( rp0 ) , +
 \   DUP HERE + ( sp0 ) , ALLOT ;


: task  ( user_size ds_size rs_size "name" -- )
  create here >r  \ user_size ds_size rs_size  r: tid
  0 ,  \ reserve space for `userp` pointer
  allot here cell- >r  ( user_size ds_size ) ( r: tid rp0 )
  allot here cell- >r  ( user_size ) ( r: tid rp0 sp0 )
  [ 6 cells ] literal + allot  \ minimum user variables
  here cell-  ( user_pointer   ) ( r: tid rp0 sp0 )
  r> , r> , ( store sp0 and rp0  )
  r@ !  \ store `userp` pointer
  lastname r> taskname 's !  ;
  \ store task name in new task's 'taskname'

  \ doc{
  \
  \ task  ( user_size ds_size rs_size "name" -- )
  \
  \ Create a new task.
  \
  \ }doc

-->

( muench-koh-multitasker )


: build  ( tid -- )
  dup sleep                       \ sleep new task
  follower @ over follower 's !   \ link new task
  status 's follower !  ;         \ link old task

  \ doc{
  \
  \ Initialize and link new task into `pause` chain.
  \
  \ }doc

: activate  ( tid -- )

  \ XXX TMP -- eForth:
  dup 2@        ( tid sp rp )

  \ XXX TMP -- hForth:
  \ dup @ cell+ 2@ cell-  \ top of stack is in bx register
  \ swap      ( tid sp0 rp0 )

  r> over !      \ save entry at rp
  over !         \ save rp at sp
  over tos 's !  \ save sp in tos
  awake ; compile-only

  \ doc{
  \
  \ activate  ( tid -- )
  \
  \ Activate the task identified by _tid_. `activate` must be
  \ used only in definition. The code following `activate` must
  \ not `exit`. In other words it must be an infinite loop like
  \ `quit`.
  \
  \ }doc

-->

( muench-koh-multitasker )


: tasks  ( -- )
  follower      \ current task's follower
  begin
    cr dup [ taskname follower - ] literal + @ .name
    dup cell- @ ['] wake =
    if  ." awaked "  else  ." sleeping "  then
    @ cell+     \ next task's follower
      dup follower =
  until drop cr ;

  \ doc{
  \
  \ tasks  ( -- )
  \
  \ Display tasks list in status-follower chain.
  \
  \ }doc

set-current

  \ vim: filetype=soloforth
  \ parsing.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605311342

  \ -----------------------------------------------------------
  \ Description

  \ Words related to parsing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-13: Add `parse-char`.
  \ 2015-10-06: Move `word` from the kernel.
  \ 2015-10-18: Move `command` from the editor and rename it to
  \ `parse-line`.
  \ 2015-10-22: Fix `parse-char`.
  \ 2016-04-24: Move `char` and `[char]` from the kernel.
  \ 2016-05-10: Fix `[char]`.
  \ 2016-05-14: Compact the blocks. Fix `parse-line` and rename
  \ it to `parse-all`. Finish and document `execute-parsing`.
  \ Move `string>source` and `evaluate` from the kernel.
  \ Rewrite `evaluate` after `execute-parsing`.
  \ 2016-05-31: Update: `cliteral` has been moved to the
  \ kernel.

( defined? parse-char parse-all )

[unneeded] defined?
?\ : defined?  ( ca len -- f )  undefined? 0=  ; exit

[unneeded] parse-char
?\ : parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ; exit
  \ Parse the next char in the input stream and return its
  \ code.

need ?(  [unneeded] parse-all ?(
: parse-all  ( "ccc<eol>" -- ca len )
  stream dup parsed save-string  ; ?)

  \ doc{
  \
  \ parse-all  ( "ccc" -- ca len )
  \
  \ Parse the rest of the source.
  \
  \ This word is a useful factor of Specforth editor's `text`.
  \
  \ }doc

( execute-parsing string>source evaluate )

need ?(

[unneeded] string>source ?(
: string>source  ( ca len -- )
  blk off  (source-id) on  set-source  ; ?)

  \ doc{
  \
  \ string>source  ( ca len -- )
  \
  \ Set the string _ca len_ as the current source.
  \
  \ }doc

[unneeded] execute-parsing ?( need need-here
need-here string>source
: execute-parsing  ( ca len xt -- )
  nest-source >r string>source r> execute unnest-source  ; ?)

  \ doc{
  \
  \ execute-parsing  ( ca len xt -- )
  \
  \ Make _ca len_ the current input source, execute _xt_, then
  \ restore the previous input source.
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] evaluate ?(  need need-here
need-here execute-parsing
: evaluate  ( i*x ca len -- j*x )
  ['] interpret execute-parsing  ; ?)

  \ doc{
  \
  \ evaluate  ( i*x ca len -- j*x )
  \
  \ Save the current input source specification. Store
  \ minus-one (-1) in `source-id`. Make the  string described
  \ by _ca len_ both the input source and input buffer,  set
  \ `>in` to zero,  and interpret.  When the  parse area  is
  \ empty, restore the prior input source specification.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

( char [char] word )

[unneeded] char [unneded] char and
?\ : char  ( "name" -- c )  parse-name drop c@  ;
[needed] char ?exit

  \ doc{
  \
  \ char  ( "name" -- c )
  \
  \ Parse "name" and put the value of its first character on
  \ the stack.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

need ?(  [uneeded] [char]  ?(

: [char]  ( "name" -- c )
  char postpone cliteral  ; immediate compile-only  ?)

  \ doc{
  \
  \ [char]
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name" and append the run-time semantics given below
  \ to the current definition.
  \
  \ Run-time: ( -- c )
  \
  \ Place _c_, the value of the first character of _name_, on
  \ the stack.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

  \ Credit:
  \
  \ Code from Z88 CamelForth.

[unneeded] word
: word  ( c "<chars>ccc<char>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -  ( ca' len ) here place  here ( ca )
  bl over count + c!  ; ?)    \ append trailing blank

  \  doc{
  \
  \  word  ( c "<chars>ccc<char>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: save-input ( -- xn ... x1 n )
  source-id 0>
  if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove
     r> to tib  >in @
     source-id file-position throw
     5
  else blk @ >in @ 2 then
  ;

-->

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: restore-input ( xn ... x1 n -- f )
  source-id 0>
  if dup 5 <> if 0 ?do drop loop -1 exit then
     drop source-id reposition-file ?dup
     if >r 2drop drop r> exit then
     >in ! #tib ! to tib false
  else dup 2 <> if 0 ?do drop loop -1 exit then
     drop >in ! blk ! false
  then
  ;

  \ vim: filetype=soloforth
  \ printing.color.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608011328

  \ -----------------------------------------------------------
  \ Description

  \ Words related to color.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-01: Start. New words:
  \
  \   color@ color! color-mask@ color-mask! color 2color
  \   permcolor@ permcolor! permcolor-mask@ permcolor-mask!
  \   permcolor 2permcolor paper@ paper! ink@ ink!  bright@
  \   bright! flash! flash@
  \
  \ 2016-05-04: Move `inverse` and `overprint` from the kernel.
  \
  \ 2016-08-01: Move color constants, `papery`, `brighty` and
  \ `flashy` from _Nuclear Invaders_
  \ (http://programandala.net/en.program.nuclear_invaders.html).

  \ -----------------------------------------------------------
  \ Documentation

  \ (From the ZX Spectrum +3 manual transcribed by Russell
  \ Marks et al.; and from the ZX Spectrum ROM disassembly.)

  \ System variables:

  \ 23693 = ATTR_P -- permanent colors

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ ATTR_P  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23693   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23694 = MASK_P -- permanent mask
  \ MASK_P is used for transparent colours. Any bit that is 1
  \ shows that the corresponding attribute is taken not from
  \ ATTR_P but from what is already on the screen.

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ MASK_P  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23694   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23695 = ATTR_T -- temporary colors

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ ATTR_T  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23695   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23696 = MASK_T -- temporary mask
  \ MASK_T is used for transparent colours. Any bit that is 1
  \ shows that the corresponding attribute is taken not from
  \ ATTR_T but from what is already on the screen.

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ MASK_T  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23696   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ P_FLAG holds the print flags.  Even bits are the temporary
  \ flags; odd bits are the permanent flags.

  \         {paper9 }{ ink9 }{ inv1 }{ over1}
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ P_FLAG  |   |   |   |   |   |   |   |   |
  \         | p | t | p | t | p | t | p | t |
  \ 23697   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

( black blue red magenta green cyan yellow white )

0 cconstant black    1 cconstant blue   2 cconstant red
3 cconstant magenta  4 cconstant green  5 cconstant cyan
6 cconstant yellow   7 cconstant white

( papery brighty flashy )

[unneeded] papery
?\ : papery   ( color -- paper-attribute )           8 *  ;

[unneeded] brighty
?\ : brighty  ( attribute -- brighty-attribute )   64 or  ;

[unneeded] flashy
?\ : flashy   ( attribute -- flashy-attribute )   128 or  ;

( color@ color! color-mask@ color-mask! color 2color )

need os-attr-t  need os-mask-t

: color@  ( -- b )  os-attr-t c@  ;

  \ doc{
  \
  \ color!  ( b -- )
  \
  \ Get temporary color attribute _b_.
  \
  \ }doc

: color!  ( b -- )  os-attr-t c!  ;

  \ doc{
  \
  \ color!  ( b -- )
  \
  \ Set temporary color attribute _b_.
  \
  \ }doc

: color-mask@  ( -- b )  os-mask-t c@  ;

  \ doc{
  \
  \ color-mask!  ( b -- )
  \
  \ Get temporary color attribute mask _b_.
  \
  \ }doc

: color-mask!  ( b -- )  os-mask-t c!  ;

  \ doc{
  \
  \ color-mask!  ( b -- )
  \
  \ Set temporary color attribute mask _b_.
  \
  \ }doc

: color  ( b "name" -- )
  create c,  does>  ( -- ) ( pfa ) c@ color!  ;

  \ doc{
  \
  \ color  ( b "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set temporary color attribute _b_.
  \
  \ }doc

: 2color  ( b1 b2 "name" -- )
  create 2,  does>  ( -- ) ( pfa ) 2@ color! color-mask!  ;

  \ doc{
  \
  \ 2color  ( b1 b2 "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set temporary color attribute _b2_ and mask _b1_.
  \
  \ }doc

( permcolor@ permcolor! permcolor-mask@ permcolor-mask! )

need os-attr-p  need os-mask-p

: permcolor@  ( -- b )  os-attr-p c@  ;

  \ doc{
  \
  \ permcolor!  ( -- b )
  \
  \ Get permanent color attribute _b_.
  \
  \ }doc

: permcolor!  ( b -- )  os-attr-p c!  ;

  \ doc{
  \
  \ permcolor!  ( b -- )
  \
  \ Set permanent color attribute _b_.
  \
  \ }doc

: permcolor-mask@  ( -- b )  os-mask-p c@  ;

  \ doc{
  \
  \ permcolor-mask@  ( -- b )
  \
  \ Get permanent color attribute mask _b_.
  \
  \ }doc

: permcolor-mask!  ( b -- )  os-mask-p c!  ;

  \ doc{
  \
  \ permcolor-mask!  ( b -- )
  \
  \ Set permanent color attribute mask _b_.
  \
  \ }doc

( permcolor 2permcolor )

need permcolor!  need permcolor-mask!

: permcolor  ( b "name" -- )
  create ,
  does>  ( -- ) ( pfa ) @ permcolor!  ;

  \ doc{
  \
  \ permcolor  ( b "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set permanent color attribute _b_.
  \
  \ }doc

: 2permcolor  ( b1 b2 "name" -- )
  create 2,
  does>  ( -- ) ( pfa ) 2@ permcolor! permcolor-mask!  ;

  \ doc{
  \
  \ 2permcolor  ( b1 b2 "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set permanent color attribute _b2_ and mask _b1_.
  \
  \ }doc

( paper@ paper! ink@ ink! )

need lshift  need rshift  need color@  need color!

: paper>  ( n1 -- n2 )  %00111000 and 3 rshift  ;
: >paper  ( n1 -- n2 )  %00000111 and 3 lshift  ;

: paper@  ( -- b )  color@ paper>  ;

: paper!  ( b -- )  >paper color@ %11000111 and or color!  ;

: ink@  ( -- b )
  color@ %00000111 and  ;

: ink!  ( b -- )
  %00000111 and color@ %11111000 and or color!  ;

( bright@ bright! flash! flash@ )

need color@  need color!

: bright@  ( -- f )
  color@ %01000000 and 0=  ;

: bright!  ( f -- )
  %10000000 and color@ %10111111 and or color!  ;

: flash@  ( -- f )
  color@ %10000000 and 0=  ;

: flash!  ( f -- )
  %10000000 and color@ %01111111 and or color!  ;

( inverse overprint )

code inverse  ( f -- )
  E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,
    \ pop hl
    \ ld a,h
    \ or l
    \ jr z,inverse.off
  FD c, CB c, 57 c, C6 08 02 * + c,  jpnext
    \ set 2,(iy+sys_p_flag_offset) ; temporary inverse flag
    \ _jp_next
    \ inverse.off:
  FD c, CB c, 57 c, 86 08 02 * + c,  jpnext  end-code
    \ res 2,(iy+sys_p_flag_offset) ; temporary inverse flag
    \ _jp_next

  \ doc{
  \
  \ inverse  ( f -- )
  \
  \ If _f_ is zero, turn the inverse mode off; else turn it on.
  \
  \ }doc

code overprint  ( f -- )
  E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,
    \ pop hl
    \ ld a,h
    \ or l
    \ jr z,overprint.off
  FD c, CB c, 57 c, C6 08 00 * + c,  jpnext
    \ set 0,(iy+sys_p_flag_offset) ; temporary overprint flag
    \ _jp_next
    \ overprint.off:
  FD c, CB c, 57 c, 86 08 00 * + c,  jpnext  end-code
    \ res 0,(iy+sys_p_flag_offset) ; temporary overprint flag
    \ _jp_next

  \ doc{
  \
  \ overprint  ( f -- )
  \
  \ If _f_ is zero, turn the overprint mode off; else turn it
  \ on.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ printing.control.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060140

  \ -----------------------------------------------------------
  \ Description

  \ Words related to printing control characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Add words to print cr, bs, backspaces.
  \
  \ 2016: Add `tabulate`.
  \
  \ 2016-05-01: Test and document `tabulate`.
  \
  \ 2016-05-04: Move `printer` from the kernel.
  \
  \ 2016-05-06: Fix and add conditional compilation.

( printer tabulate )

[unneeded] printer
?\ : printer  ( -- )  3 channel printing on  ;  exit

need column

variable /tabulate  8 /tabulate !
  \ doc{
  \
  \ /tabulate  ( -- a )
  \
  \ A variable that holds the number of spaces that `tabulate`
  \ counts for. Its default value is 8.
  \
  \ See `tabulate`.
  \
  \ }doc

: tabulate  ( -- )  column 1+ /tabulate @ tuck mod - spaces  ;
  \ doc{
  \
  \ tabulate  ( -- )
  \
  \ Display the appropriate number of spaces to tabulate to the
  \ next position, using the value of `/tabulate`.
  \
  \ Note `tabulate` does not uses the "tab" control code, whose
  \ behaviour depends on the screen mode (in the default screen
  \ mode, it moves the cursor 16 positions to right).
  \ `tabulate` is independent on the screen mode, since it uses
  \ spaces.
  \
  \ See `/tabulate`.
  \
  \ }doc

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

[unneeded] 'tab' [unneeded] tab [unneeded] tabs and and
?\ 6 constant 'tab'

[unneeded] 'bs' [unneeded] backspace [unneeded] backspaces
and and ?\ 8 constant 'bs'

[unneeded] 'cr' [unneeded] crs and ?\ 13 constant 'cr'

[unneeded] tab [unneeded] tabs and
?\ : tab  ( -- )  'tab' emit  ;

[unneeded] backspace [unneeded] backspaces and
?\ : backspace    ( -- )  'bs'  emit  ;

[unneeded] crs  ?\ : crs   ( n -- )  'cr'  emits  ;
[unneeded] tabs ?\ : tabs  ( n -- )  'tab' emits  ;

[unneeded] backspaces
?\ : backspaces    ( n -- )  'bs'  emits  ;

  \ vim: filetype=soloforth
  \ printing.cursor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605072052

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the cursor position.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-14: Add `column`, `row`, `at-x`, `at-y`, adapted
  \ from Galope.
  \ 2016-05-01: Add conditional compilation and documentation.
  \ 2016-05-07: Fix typos and conditional compilation.

( column last-column row last-row at-x at-y )

[unneeded] column [unneeded] last-column and
[unneeded] at-y and
?\ : column  ( -- col )  xy drop  ;
  \ doc{
  \
  \ column  ( -- col )
  \
  \ Current column (x coordinate).
  \
  \ }doc

[unneeded] last-column
?\ : last-column  ( -- row  )  column 1-  ;
  \ doc{
  \
  \ last-column  ( -- col )
  \
  \ Last column (x coordinate) in the current screen mode.
  \
  \ }doc

[unneeded] row [unneeded] last-row [unneeded] at-x and and
?\ : row  ( -- row )  xy nip  ;
  \ doc{
  \
  \ row  ( -- row )
  \
  \ Current row (y coordinate).
  \
  \ }doc

[unneeded] last-row
?\ : last-row  ( -- row  )  row 1-  ;
  \ doc{
  \
  \ last-row  ( -- row )
  \
  \ Last row (y coordinate) in the current screen mode.
  \
  \ }doc

[unneeded] at-x
?\ : at-x  ( col -- )  row at-xy  ;
  \ doc{
  \
  \ at-x ( col -- )
  \
  \ Set the cursor at the given column (x coordinate) and the
  \ current row (y coordinate).
  \
  \ }doc

[unneeded] at-y
?\ : at-y  ( row -- )  column swap at-xy  ;
  \ doc{
  \
  \ at-y ( row -- )
  \
  \ Set the cursor at the current column (x coordinate) and the
  \ given row (y coordinate).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ printing.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604220029

  \ -----------------------------------------------------------
  \ Description

  \ Tool to print left justified texts.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( print )

  \ XXX UNDER DEVELOPMENT
  \ Adapted from Galope <print.fs>.

need last-row  need /name

  \ export

variable #printed   \ Printed chars in the current line.
variable #indented   \ Indented chars in the current line.
: printed+  ( u -- )  #printed +!  ;
: indented+  ( u -- )  #indented +!  ;
: (.word) ( ca len -- )  dup printed+ type  ;
: .char  ( c -- )  emit 1 printed+  ;
: not-at-home?  ( -- 0f )  xy +  ;

  \ export

: no-printed  ( -- )  #printed off #indented off  ;
: print-home  ( -- )  home no-printed  ;
: print-page  ( -- )  page print-home  ;

-->

( print )

: print-start-of-line  ( -- )
  #printed @ trm+move-cursor-left no-printed  ;

  \ : print-cr  ( -- )  not-at-home? if  cr  then  no-printed  ;
  \ XXX OLD first version

  \ hide

: at-last-start-of-line?  ( -- f )
  xy last-row = swap 0= and  ;
: not-at-start-of-line?  ( -- f )  column 0<>  ;
: print-cr?  ( -- f )
  not-at-home? not-at-start-of-line? and
  \ xxx fixme 2012-09-30 what this was for?:
  \ at-last-start-of-line? 0= or
  ;

  \ export

defer (print-cr) ' (print-cr) ' cr defer!

: print-cr print-cr? ?? (print-cr) no-printed ;

variable print-width

-->

( print )

  \ hide

: previous-word?  ( -- f )  #printed @ #indented @ >  ;
: ?space  ( -- ) previous-word? if  bl .char  then  ;
: current-print-width  ( -- u )
  print-width @ ?dup 0= ?? cols  ;
: too-long?  ( u -- f )
  1+ #printed @ + current-print-width >  ;
: .word  ( ca len -- )
  dup too-long? if  print-cr  else  ?space  then  (.word)  ;

-->

( print )

: (print-indentation)  ( u -- )
  dup trm+move-cursor-right dup indented+ printed+  ;

  \ export

: print-indentation  ( u -- )  ?dup ?? (print-indentation)  ;

  \ hide

: >word  ( ca1 len1 ca2 len2 -- ca2 len2 ca1 len4 )
  \ ca1 len1 = Text, from the start of its first word.
  \ ca2 len2 = Same text, from the char after its first word.
  \ ca1 len4 = First word of the text.
  tuck 2>r -  2r> 2swap  ;

: first-word  ( ca1 len1 -- ca2 len2 ca3 len3 )  /name >word  ;

: (print)  ( ca1 len1 -- ca2 len2 )  first-word .word  ;

-->

( print )

  \ export

: print  ( ca len --)
  begin  dup   while  (print)  repeat  2drop  ;

  \ Suggested usage in the application:

  \ 4 value indentation
  \ : paragraph  ( ca len -- )
  \   print-cr indentation print-indentation print  ;

  \ vim: filetype=soloforth
  \ printing.type.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281733

  \ -----------------------------------------------------------
  \ Description

  \ Versions of `type`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-27: Move `ascii-type` from module "tool.dump.fsb"
  \ and rename it to `type-ascii`.
  \
  \ 2016-04-27: Start `type-center`, `type-left` and
  \ `type-right`.
  \
  \ 2016-04-28: First working versions of `type-center`,
  \ `type-left` and `type-right`.

( type-ascii )

need ascii-char?  need control-char?

: type-ascii  ( ca len -- )
  bounds ?do
    i c@ dup dup ascii-char? 0= swap control-char? or
    if  drop '.'  then  emit
  loop  ;

  \ doc{
  \
  \ type-ascii  ( ca len -- )
  \
  \ Type string _ca len_, replacing non-ASCII and control chars
  \ with a dot.
  \
  \ }doc

( drop-type padding-spaces type-left )

[unneeded] drop-type
?\ : drop-type  ( ca len x -- )  drop type  ;  exit

: padding-spaces  ( len1 len2 -- )
  swap - 0 max spaces  ;

  \ doc{
  \
  \ : padding-spaces  ( len1 len2 -- )
  \
  \ If _len2_ minus _len1_ is a positive number, print that
  \ number of spaces; else do nothing.
  \
  \ }doc

[needed] padding-spaces ?exit

: type-left  ( ca len1 len2 -- )
  2dup 2>r min type 2r> padding-spaces  ;

  \ doc{
  \
  \ type-left  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the left of a field of _len2_
  \ characters.
  \
  \ }doc

( type-right )

need drop-type  need <=>

: type-right-crop  ( ca len1 len2 -- )
  over swap - /string type  ;

  \ doc{
  \
  \ type-right-crop  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters, which is shorter than the string.
  \
  \ }doc

: type-right-fit  ( ca len1 len2 -- )  over - spaces type  ;

  \ doc{
  \
  \ type-right-fit  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters, which is longer than the string.
  \
  \ }doc

      ' type-right-fit ,
here  ' drop-type ,
      ' type-right-crop ,
constant type-right-cases
  \ Execution table of `type-right`.

: type-right  ( ca len1 len2 -- )
  2dup <=> cells type-right-cases + perform  ;

  \ doc{
  \
  \ type-right  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters.
  \
  \ }doc

( type-center )

need drop-type  need <=>

: type-center-fit  ( ca len1 len2 -- )
  over - 2 /mod dup >r + spaces type r> spaces  ;

  \ doc{
  \
  \ type-center-fit  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters, which is longer than the string.
  \
  \ }doc

: type-center-crop  ( ca len1 len2 -- )
  over swap - 2 /mod dup >r + /string r> - type  ;

  \ doc{
  \
  \ type-center-crop  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters, which is shorter than the string.
  \
  \ }doc

      ' type-center-fit ,
here  ' drop-type ,
      ' type-center-crop ,
constant type-center-cases
  \ Execution table of `type-center`.

: type-center  ( ca len1 len2 -- )
  2dup <=> cells type-center-cases + perform  ;

  \ doc{
  \
  \ type-center  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ random.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610181359

  \ -----------------------------------------------------------
  \ Description

  \ Pseudo-random number generators.
  \
  \ See benchmark results in <meta.benchmark.rng.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-10-18: Update the name of the benchmarks library
  \ module.

( rnd random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: Found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: Adapted to Solo Forth.
  \
  \ 2016-04-08: Updated the constant after the latest
  \ benchmarks.

2variable rnd-seed  $0111 rnd-seed !

: rnd  ( -- u )
  rnd-seed 2@ $62DC um* rot 0 d+ over rnd-seed 2!  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).

( fast-rnd fast-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code fast-rnd  ( -- u )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: fast-random  ( n -- 0..n-1 )  fast-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

( crnd crandom )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need os-seed

code crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

: crandom  ( b -- 0..b-1 )  crnd um* nip  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( randomize randomize0 )

[defined] randomize
?\  need os-seed  : randomize  ( n -- )  os-seed !  ;
  \ Set the seed of the random number generator.

[needed] randomize ?exit

need os-frames

: randomize0  ( n -- )
  ?dup 0=  if  os-frames @  then  randomize  ;
  \ Set the seed of the random number generator;
  \ if _n_ is zero use the system frames counter instead.

  \ vim: filetype=soloforth
  \ return_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281333

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the return stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-10: Add `n>r`, `nr>`.
  \ 2015-10-27: Add `r'@`.
  \ 2016-04-24: Move `2rdrop` from the kernel.
  \ 2016-04-28: Add `dup>r`.

( n>r )

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

  \ doc{
  \
  \ n>r  ( x1..xn n -- ) ( R: -- x1..xn n )
  \
  \ }doc

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  jppushhl
  end-code

  \ doc{
  \
  \ nr>  ( -- x1..xn n ) ( R: x1..xn n -- )
  \
  \ }doc

need n>r

( rdepth r'@ )

  \ Credit:
  \
  \ `rdepth` from Afera.

[unneeded] rdepth
?\ : rdepth  ( -- n )  rp@ rp0 @ - -2 /  ;

  \ doc{
  \
  \ rdepth  ( -- n )
  \
  \ }doc

  \ Credit:
  \
  \ `r'@` by Wil Baden.

[unneeded] r'@ ?exit

: r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  r> 2r@ drop swap >r  ;

  \ doc{
  \
  \ r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  \
  \ }doc

( 2rdrop )


code 2rdrop  ( R: x1 x2 -- )
  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  11 c, 02 cells ,
    \ ld de,cell*2
  19 c,
    \ add hl,de
  22 c, rp ,
    \ ld (return_stack_pointer),hl
  jpnext
  end-code

  \ doc{
  \
  \ 2rdrop  ( R: x1 x2 -- )
  \
  \ }doc

( dup>r )

  \ Credit:
  \ Idea from IsForth.

code dup>r  ( x -- x ) ( R: -- x )
  D1 c, D5 c,
    \ pop de
    \ push de
  C3 c, ' >r 1+ ,
    \ jp to_r_.de ; secondary entry of `>r`, in the kernel
  end-code

  \ doc{
  \
  \ dup>r  ( x -- x ) ( R: -- x )
  \
  \ A faster alternative to the idiom `dup >r`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ screen_mode.32.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605071629

  \ -----------------------------------------------------------
  \ Description

  \ The screen mode 32.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Change `latest >name` to `latestxt`.
  \
  \ 2016-05-07: Improve documentation.

( mode32 )

need columns  need rows  need set-font  need set-mode-output

: mode32  ( -- )
  [ latestxt ] literal current-mode !
  15360 set-font  2548 set-mode-output
  32 to columns  24 to rows
  ['] mode32-xy ['] xy defer!
  ['] mode32-at-xy ['] at-xy defer!  ;

  \ doc{
  \
  \ mode32 ( -- )
  \
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).
  \
  \ This word is loaded when `mode42` or `mode64` are loaded,
  \ in order to make it the default mode.
  \
  \ }doc

' mode32 ' default-mode defer!

  \ vim: filetype=soloforth
  \ screen_mode.42.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201610161048

  \ -----------------------------------------------------------
  \ Description

  \ A 42 CPL screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ Marcos Cruz (programandala.net) integrated it into Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Update `latest >name` to `latestxt`.
  \ 2016-05-07: Compact the blocks. Improve the file header.
  \ Fix: `need mode32` was missing.
  \ 2016-08-11: Rename the filenames of the driver and the
  \ font.
  \ 2016-10-16: Typo.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- integrate the source of the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

( mode42 banked-mode42 )

  \ ............................
  \ Common requirements

need mode32  need <file-as-is need (mode42 need [if]

[needed] mode42 [if]  need set-mode-output

  \ ............................
  \ mode42

: mode42  ( -- )  [ latestxt ] literal current-mode !
                  (mode42 set-mode-output  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

get-drive 1 set-drive  s" pr42.bin" <file-as-is throw
                       s" ea5a.f42" <file-as-is throw
            set-drive
  \ Load the driver and the font.

exit [then]

  \ ............................
  \ banked-mode42

  \ XXX UNDER DEVELOPMENT -- A variant of `mode42` that stores
  \ the driver and the font in the code bank.

  \ XXX FIXME -- crash!

need set-banked-mode-output  need code-bank

: banked-mode42  ( -- )  [ latestxt ] literal current-mode !
                         (mode42 set-banked-mode-output  ;

code-bank{  get-drive 1 set-drive
            s" pr42.bin" <file-as-is throw
            s" ea5a.f42" <file-as-is throw
            set-drive  }code-bank
  \ Load the driver and the font into the code bank.

( (mode42 )

need columns  need rows  need set-font

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode42-xy  ( -- col row )  0 0  ;  \ XXX TODO

: (mode42  ( -- a )
  42 to columns  24 to rows
  ['] mode42-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  [ 64600 256 - ] literal set-font 63900  ;
  \ Set the 42 cpl font and `at-xy`;
  \ return the address of the output routine.

  \ vim: filetype=soloforth
  \ screen_mode.64.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610161042

  \ -----------------------------------------------------------
  \ Description

  \ A 64 CPL screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ Author of the original code: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Update `latest name>` to `latestxt`.
  \ 2016-05-07: Improve the file header.
  \ 2016-08-11: Rename the filenames of the driver.
  \ 2016-10-16: Fix credits.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- integrate the source of the driver

( mode64 )

  \ XXX TMP -- The driver is loaded from disk to memory address
  \ 60000.

need mode32  need <file-as-is  need 4x8font

get-drive 1 set-drive
s" pr64.bin" <file-as-is throw
set-drive
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode64-xy  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latestxt ] literal current-mode !
  64 to columns  24 to rows
  ['] mode64-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  4x8font set-font  60000 set-mode-output  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

  \ XXX TODO mode64-home

code mode64-emit  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if  FF a ld#  then
  \ check_cr

  end-code

: mode64  ( -- )
  mode64-chars @ set-font  mode64-emit set-mode-outupt
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credit:
  \
  \ Author of the font: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

  \ vim: filetype=soloforth
  \ screen_mode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170052

  \ -----------------------------------------------------------
  \ Description

  \ Words that are common to all screen
  \ modes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Compact the blocks.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( columns rows set-mode-output set-font )

[unneeded] columns [unneeded] rows and
?\ need value  32 value columns  24 value rows  exit

[unneeded] set-font
?\ need os-chars  : set-font  ( a -- )  os-chars !  ;  exit

  \ doc{
  \
  \ set-font  ( a -- )
  \
  \ Set the system font to _a_.  This is used by all modes:
  \ `mode32`, `mode42` and `mode64`. The value of _a_ depends
  \ on the mode: In `mode32` and `mode42`, _a_ is the address
  \ of char 0, i.e. 256 bytes below the space char; In `mode64`
  \ _a_ is the address of space char.
  \
  \ }doc

need os-chans

: set-mode-output  ( a -- )
  os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

  \ doc{
  \
  \ set-mode-output  ( a -- )
  \
  \ Associate the output routine at _a_ to the system channels
  \ "K", "S" and "P".
  \
  \ }doc
  \ XXX TODO -- why also "P"?

( set-banked-mode-output )

need set-mode-output  need >body

0 constant (output-routine)

code (banked-mode-output)  ( -- )
  C5 c,  CD c, 0 ,
    \ push bc ; save Forth IP
    \ call output_routine ; to be patched
  here cell- ' (output-routine) >body !
    \ Store the address where the address of the output routine
    \ must be stored, into the constant `(output-routine)`.
  C1 c,  DD c, 21 c, next ,  jpnext  end-code
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore IX, just in case
    \ jp next

: set-banked-mode-output  ( a -- )
  (output-routine) !  \ patch `(banked-mode-output)`
  ['] (banked-mode-output) set-mode-output  ;
  \ Associate the output routine at _a_ (which is in the code
  \ bank) to the system channels "K", "S" and "P", using and
  \ intermediate routine to page the code bank in and out.

  \ vim: filetype=soloforth
  \ screen_mode.fzx.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242159

  \ -----------------------------------------------------------
  \ Description

  \ The FZX screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 set-drive  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( gx gy -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credit:
  \
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  '?' 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    r now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  r add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) call
  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ sound.128.editor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608021653

  \ -----------------------------------------------------------
  \ Description

  \ A simple 128k sound editor.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-08-02: Start.

( edit-sound )

get-current  forth-wordlist set-current

need :noname  need c1+!  need c1-!  need inverse  need case
need value  need play  [defined] /sound ?\ 14 constant /sound

wordlist constant edit-sound-wordlist
edit-sound-wordlist dup >order set-current

variable sound  variable register
  \ `sound`: address of the sound being edited
  \ `register`: register (0..13) being edited

'Q' value quit-key  'P' value play-key
  8 value left-key    9 value right-key
 10 value down-key   11 value up-key

  \ : key>name  ( c -- ca len )
  \ XXX TODO --

: .help  ( -- )
  quit-key emit ."           - quit" cr
  play-key emit ."           - play" cr
  ." left/right - decrease/increase value" cr
  ." up/down    - previous/next register" cr ;
  \ XXX TODO -- print name of control keys

-->

( edit-sound )

:noname  ( -- )  ." Env."          ;  \ XXX TODO --
:noname  ( -- )  ." Env. T."       ;  \ XXX TODO --
:noname  ( -- )  ." Env. P."       ;  \ XXX TODO --
:noname  ( -- )  ." C volume"      ;
:noname  ( -- )  ." B volume"      ;
:noname  ( -- )  ." A volume"      ;
:noname  ( -- )  ." Mixer"         ;
:noname  ( -- )  ." Noise volume"  ;
:noname  ( -- )  ." C tone"        ;
:noname  ( -- )  ." C fine tone"   ;
:noname  ( -- )  ." B tone"        ;
:noname  ( -- )  ." B fine tone"   ;
:noname  ( -- )  ." A tone"        ;
:noname  ( -- )  ." A fine tone"   ;

create label  , , , , , , , , , , , , , ,  -->
  \ Execution tokens of the register labels.

( edit-sound )

: .label  ( n -- )  cells label + perform  ;
  \ Print the label of register _n_.

: .register  ( n -- )
  >r 0 r@ at-xy  sound @ r@ + c@ 4 .r  space r> .label cr  ;

: .menu-register  ( n -- )
  dup register @ = inverse  .register  0 inverse  ;
  \ Print register _n_ of the currently edited sound.

: .sound  ( -- )  /sound 0 do  i .menu-register  loop  ;
  \ Print the data of the currently edited sound.

: register@  ( -- n )  register @ dup .register  ;
  \ Print the currently edited register on its position,
  \ without inverse video, and return its value.

: register!  ( n -- )  dup register ! .menu-register  ;
  \ Make _n_ the currently edited register and update its label
  \ on the screen.

: next-register  ( -- )
  register@ 1+ dup /sound <> and register!  ;
  \ Increase the number of the currently edited register.
  \ Set it to zero if it was the maximum number.

: previous-register  ( -- )
  register@ 1- dup 0< if  drop /sound 1-  then  register!  ;
  \ Decrease the number of the currently edited register.
  \ Set it to the maximum number if it was zero.

: >register  ( -- ca )  sound @ register @ +  ;
  \ Address of the currently edited register.

: increase-value  ( -- )  >register c1+!  ;
  \ Increase the value of the currently edited register.

: decrease-value  ( -- )  >register c1-!  ;  -->
  \ Decrease the value of the currently edited register.

( edit-sound )

forth-wordlist set-current

: edit-sound ( a -- )
  sound ! register off  page .sound cr .help
  begin  .sound
    key upper case
      quit-key   of  exit               endof
      play-key   of  sound @ play       endof
      left-key   of  decrease-value     endof
      right-key  of  increase-value     endof
      down-key   of  next-register      endof
      up-key     of  previous-register  endof
    endcase
  again  ;

set-current  previous

( edit-sound-test )

  \ XXX TMP

need edit-sound  need >body  need shoot

create explosion

' shoot >body explosion /sound move

  \ vim: filetype=soloforth
  \ sound.128.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201610101851

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 128k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Need `pick`, which has been moved to the
  \ library.
  \
  \ 2016-05-18: Need `vocabulary`, which has been moved to the
  \ library.
  \
  \ 2016-10-10: Fix name of `applause`. Define `/sound` only
  \ once.

( /sound sound-register-port sound-write-port !sound )

[unneeded] /sound ?\ 14 constant /sound exit

#65533 constant sound-register-port
#49149 constant sound-write-port

[unneeded] !sound ?exit

need !p

: !sound  ( b1 b2 -- )
  sound-register-port !p sound-write-port !p  ;
  \ Set sound register _b2_ (0...13) to value _b1_.

( vol shutup noise )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !sound

: vol  ( b1 b2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  need roll  need pick  need vocabulary
need !sound  need vol

vocabulary music  get-current  also music definitions

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume

2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,  does>   @ octave @ * 16 /  1 freq tones
                     tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b  -->

( music )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l   ( n -- )  len !  ;
: o+  ( -- )    octave @ 2 * octave !  ;
: o-  ( -- )    octave @ 2 / octave !  ;
: r   ( -- )    tempo @ len @ * ms  ;
: >>  ( -- )    1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )    1 volume @ 1- vol -1 volume +!  ;

set-current previous

( play sound, sound )

  \ Credit:
  \
  \ Code inspired by the article "Las posibilidades sonoras del
  \ 128 K", written by Juan Jos Rosado Recio, published on
  \ Microhobby, issue 147 (1987-10), page 24:
  \
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !sound  need /sound

: play  ( a -- )
  /sound 0 do  dup c@ i !sound 1+  loop  drop  ;
  \ Play a 14-byte sound definition stored at _a_.

: sound,  ( b0 ... b13 -- )
  here /sound allot here 1- do  i c!  -1 +loop  ;
  \ Compile the 14-byte sound definition _b0 ... b13_.

: sound  ( b0 ... b13 "name" -- )
  create  sound,  does>  ( -- )  ( pfa )  play  ;
  \ Create a word _name_ that will play the 14-byte sound
  \ defined by _b0 ... b13_.

( fplay )

  \ XXX TMP --

  \ Faster version of `play`.

need !p  need c@+
need sound-register-port  need sound-write-port  need /sound

: fplay  ( a -- )
  /sound 0 do
    i sound-register-port !p  c@+ sound-write-port !p
  loop  drop  ;
  \ Play a sound whose 14 bytes are stored at _a_.

( zplay )

  \ XXX TMP --

  \ Z80 version of `play`.

need z80-asm

need sound-register-port  need sound-write-port  need /sound

code zplay  ( a -- )
  hl pop  bc push
  /sound b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step
  bc pop  jpnext  end-code
  \ Play a sound whose 14 bytes are stored at _a_.
  \ XXX FIXME -- no sound! maybe `outbc` has a bug in the
  \ assembler

( waves shoot helicopter1 train airplane helicopter2 )

  \ Sounds to be played with `play`.

need sound  hex

  \ Credit:
  \
  \ `waves` and `shoot` are adapted from code written by Juan
  \ Jos Ruiz, published on Microhobby, issue 139 (1987-07),
  \ page 7:
  \
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

[unneeded] waves
?\ 00 00 00 00 00 00 07 47 14 14 14 00 26 0E sound waves

[unneeded] shoot
?\ 0A 00 B1 00 BF 00 1F 47 14 14 14 5C 1C 03 sound shoot

  \ Credit:
  \
  \ `helicopter1` and `train` are adapted from code written by
  \ Jos ngel Martn, published on Microhobby, issue 172
  \ (1988-09), page 22:
  \
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

[unneeded] helicopter1
?\ C8 0F C8 0F C8 0F 00 07 17 17 17 FF 01 0C sound helicopter1

[unneeded] train
?\ 64 78 30 61 0C C8 37 0F 09 0B 37 B4 04 08 sound train

  \ Credit:
  \
  \ `airplane` and 'helicopter2' were extracted from a program
  \ written by Juan Jos Rosado Recio, published on Microhobby,
  \ issue 147 (1987-10), page 24:
  \
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

[unneeded] airplane
?\ 0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound airplane

[unneeded] helicopter2
?\ 09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound helicopter2

decimal

( bomber whip metalic rain2 lightning1 lighting2 )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Adapted from data written by Francisco Majn, published on
  \ Microhobby, issue 194 (1989-12), page 26:
  \
  \ http://microhobby.org/numero194.htm
  \ http://microhobby.speccy.cz/mhf/194/MH194_26.jpg

need sound  hex

[unneeded] bomber
?\ 49 52 3E A5 5A 8A 9F 8C 66 4D 64 A2 57 C9 sound bomber

[unneeded] whip
?\ 05 12 08 06 13 0B 05 0B 00 13 03 18 15 01 sound whip

[unneeded] metalic
?\ 95 40 68 EC D2 B4 00 20 00 C2 92 49 51 B1 sound metalic

[unneeded] ligthing1
?\ 01 04 00 10 24 43 08 04 1F F5 01 06 1E 02 sound lighting1

[unneeded] lighting2
?\ 00 00 00 00 00 FF 07 04 FF 19 00 3C 3C 03 sound lighting2

  \ #16 #17 #25 #10 #19 #9 #4 #31 #245 #1 #6 #30 #2 sound rain2
  \ 10 11 19 0A 13 09 04 1F F5 01 06 1E 02 sound rain2
  \ XXX FIXME -- one number is missing

decimal

( bell1 bell2 bell3 rap drum cymbal )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Data extracted from a program written by Juan Jos Rosado
  \ Recio, published on Microhobby, issue 147 (1987-10), page
  \ 24:
  \
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound  hex

[unneeded] bell1
?\ AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound bell1

[unneeded] bell2
?\ 66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound bell2

[unneeded] bell3
?\ FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound bell3

[unneeded] rap
?\ 00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound rap

[unneeded] drum
?\ 00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound drum

[unneeded] cymbal
?\ 09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound cymbal

decimal

( applause hammer background beach waterdrop2 )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Data extracted from a program written by Juan Jos Rosado
  \ Recio, published on Microhobby, issue 147 (1987-10), page
  \ 24:
  \
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound  hex

[unneeded] applause
?\ 00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound aplausse

[unneeded] hammer
?\ 1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound hammer

[unneeded] background
?\ 03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound background

[unneeded] beach
?\ 00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound beach

[unneeded] waterdrop2
?\ 24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound waterdrop2

decimal

( rain1 waterdrop1 explosion1 explosion2 )

  \ Sounds to be played with `play`.

need sound  hex

  \ Credit:
  \
  \ `rain1` and `waterdrop1` were extracted from a program
  \ written by Carlos Ventura, published on Microhobby, issue
  \ 198 (1990-05), page 16:
  \
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

[unneeded] rain1
?\ 2C 18 06 06 07 03 03 05 2C 06 03 05 03 03 sound rain1

[unneeded] waterdrop1
?\ 14 53 5E 27 00 08 1F 47 17 17 16 5A 00 00 sound waterdrop1

  \ Credit:
  \
  \ `explosion1` and `explosion2` are adapted from the SE BASIC
  \ manual, page 10, where they were taken from the Timex
  \ Sinclair TS2068 User Manual.
  \
  \ XXX FIXME -- 2016-10-10: Finish the conversion: Registers
  \ not specified in the examples are set to zero, but they
  \ should keep the default values. Consult the TS2068 User
  \ Manual.

[unneeded] explosion1
?\ 00 00 00 00 00 06 07 10 10 10 38 08 00 00 sound explosion1

[unneeded] explosion2
?\ 00 00 00 00 00 06 07 10 10 10 38 08 00 00 sound explosion2

decimal

  \ vim: filetype=soloforth
  \ sound.48.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140114

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 48k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Main development.
  \ 2016-04-14: Documented `bleep` and `beep>bleep`.

( bleep )

  \ Credit:
  \
  \ Code modified from Abersoft Forth.

code bleep  ( duration pitch -- )
  E1 c,  D1 c,  C5 c,  CD c, 03B5 ,
    \ pop hl
    \ pop de
    \ push bc ; save Forth IP
    \ call rom_beeper
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore ix
  jpnext
  end-code

  \ doc{
  \
  \ bleep  ( duration pitch -- )
  \
  \ Produce a tone in the internal beeper.
  \
  \ }doc


( beep>bleep )

  \ Credit:
  \
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( frequency duration1 -- duration2 pitch )
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

  \ doc{
  \
  \ beep>bleep  ( frequency duration1 -- duration2 pitch )
  \
  \ Convert the parameters of Sinclair BASIC `beep` to Solo
  \ Forth `bleep`. See `bleep`.
  \
  \ }doc

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published on Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Lder Software.
  \ Published on Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ string.cquote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051508

  \ -----------------------------------------------------------
  \ Description

  \ Two implementations of `c"` and
  \ `csliteral`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-03-14: Write `c"` with a new, system-independent
  \ implementation of `csliteral`.
  \
  \ 2016-03-15: Set the previous, system-dependent
  \ implementation of `csliteral` as default.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-08-05: Combine both blocks. Keep the alternative
  \ definition of `csliteral` only as a reference.

( cslit csliteral c" )

  \ This is the default definition of `csliteral`, based on a
  \ system-dependent `cslit`, which makes it possible to decode
  \ `c"`.

  \ Data space used: 43 bytes.

: cslit  ( -- ca )  r@ dup c@ 1+ r> + >r  ;
  \ doc{
  \
  \ cslit  ( -- ca )
  \
  \ Return a string that is compiled after the calling word, and
  \ adjust the instruction pointer to step over the inline string.
  \
  \ }doc

: csliteral  ( ca len -- )
  compile cslit s,  ; immediate compile-only
  \ doc{
  \
  \ csliteral  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Compile a string _ca len_ which at run-time will
  \ be returned as a counted string.
  \
  \ }doc

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  '"' parse postpone csliteral  ; immediate compile-only
  \ doc{
  \
  \ c"  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Parse a string delimited by double quotes and
  \ compile it into the current definition.
  \ At run-time the string will be returned as a
  \ counted string _ca_.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

exit

  \ This is an alternative system-independent definition of
  \ `csliteral`.

: csliteral  ( Compilation: ca len -- )
             ( Run-time: -- ca )
  2>r postpone ahead here 2r> s, >r postpone then
  r> postpone literal  ; immediate compile-only
  \ Credit:
  \ Code from Gforth's `CLiteral`.

  \ vim: filetype=soloforth
  \ strings.escaped.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181544

  \ -----------------------------------------------------------
  \ Description

  \ Words related to escaped strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]` and `char`, which have been
  \ moved to the library.
  \
  \ 2016-05-18: Use `wordlist` instead of `vocabulary`, which
  \ has been moved to the library.

( parse-escaped-string )

only forth definitions
need parse-char
wordlist dup constant escaped-wordlist dup >order set-current

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
'"' 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
'"' 1 2constant "  '\' 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( parse-escaped-string )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  '\' 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "ccc<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup '"' <>  while  \ not finished?
    dup '\' =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

( s\" .\" )

need parse-escaped-string  need ?(

[unneeded] s\" ?(
: s\"  ( Interpretation: "ccc<quote>" -- ca len )
       ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate  ?)

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "ccc<quote>"  - ca len )
  \
  \ }doc

[unneeded] .\" ?(
: .\"  ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only ?)

  \ vim: filetype=soloforth
  \ strings.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051628

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-22: Add `s""`, moved from the kernel.
  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \ 2016-04-27: Add `char-in-string?` and `char-position?`.
  \ 2016-05-05: Rename `s=` to `str=`. Add `str<` and `str>`.
  \ 2016-05-11: Fix `-prefix`. Start compacting the blocks.
  \ 2016-08-02: Improve comment of `hunt`. Comment the string
  \ comparison operators.
  \ 2016-08-05: Reorganize and compact the code to save one
  \ block.

( str= str< str> trim +place hunt )

[unneeded] str=
?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit
  \ Is string _ca1 len1_ lexicographically equal to string _ca2
  \ len2_?

[unneeded] str<
?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit
  \ Is string _ca1 len1_ lexicographically smaller than string
  \ _ca2 len2_?

[unneeded] str>
?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit
  \ Is string _ca1 len1_ lexicographically larger than string
  \ _ca2 len2_?

[unneded] trim
?\ : trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

need ?(

[unneeded] +place ?(
: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ; ?)
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

  \ Credit:
  \
  \ Code from Afera.

[unneeded] hunt ?(
: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ; ?)

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_. Therefore _ca3 len3_ = _ca1+n
  \ len1-n_.
  \
  \ }doc

( ud>str d>str char>string chars>string )

[unneeded] ud>str
?\ : ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

[unneeded] d>str
?\ : d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

need ?(

[unneeded] char>string ?(
: char>string  ( c -- ca len )
  1 allocate-string tuck c! 1  ; ?)
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

[unneeded] chars>string ?(
: chars>string  ( c1..cn n -- ca len )
  dup if    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
            bounds do  i c!  loop  2r>
      else  pad swap  then  ; ?)
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

need pick

[defined] lengths
?\ : lengths   2over nip over  ;
   \ ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( #spaces #chars )

need under+

  \ XXX TODO -- finish and benchmark. rewrite `#spaces` after
  \ `#chars`? add `#nulls`

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string _ca len_.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count chars _c_ in a string _ca len_.

( /name first-name last-name )

  \ Credit:
  \
  \ Code from Galope.

need ?(  [unneeded] last-name ?(  need trim

: last-name  ( ca1 len1 -- ca2 len2 )
  trim  begin  2dup bl scan bl skip dup
        while  2nip  repeat  2drop  ;  exit ?)
  \ Get the last name _ca2 len2_ from string _ca1 len1_.  A
  \ name is a substring separated by spaces.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  bl skip 2dup bl scan  ;
  \ Split string _ca1 len1_ into _ca2 len2_ (from the start of
  \ the first name in _ca1 len1_) and _ca3 len3_ (from the char
  \ after the first name in _ca1 len1).  A name is a substring
  \ separated by spaces.

[unneeded] first-name ?exit

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Return the first name _ca2 len2_ from string _ca1 len1_.  A
  \ name is a substring separated by spaces.

( prefix? suffix? -prefix -suffix )

need ?(

[unneeded] prefix? ?(  need str=  

: prefix?  ( ca1 len1 ca2 len2 -- f )
  tuck 2>r min 2r> str=  ; ?)
  \ Is string _ca2 len2_ the prefix of string _ca1 len1_?
  
  \ Credit:
  \
  \ Code adapted from Galope (module string-prefix-question.fs).

[unneeded] suffix? (?  need pick  need str=  

: suffix? ( ca1 len1 ca2 len2 -- f )
  2swap dup 3 pick - /string str=  ; ?)
  \ Is string _ca2 len2_ the suffix of string _ca1 len1_?
  
  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).


[unneeded] -prefix ?(  need prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  dup >r 2over 2swap prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ; ?)
  \ Remove prefix _ca2 len2_ from string _ca1 len1_.
  
  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

[unneeded] -suffix ?(  need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ; ?)
  \ Remove suffix _ca2 len2_ from string _ca1 len1_.

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

( chop s"" sconstant save-counted-string )

[unneeded] chop
?\ : chop  ( ca len -- ca' len' )  1- swap char+ swap  ;  exit
  \ Remove the last character from string _ca len_.
  \
  \ Credit:
  \
  \ Code from Galope (module chop.fs).


[unneeded] s""
?\ : s""  ( -- ca len )  0 allocate-string 0  ;  exit

  \ doc{
  \
  \ s""  ( -- ca len )
  \
  \ Return an empty string in the circular string buffer.
  \
  \ }doc

need ?(  [unneeded] sconstant ?(
: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ; ?)

[unneeded] save-counted-string ?(
: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ; ?)

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ char-in-string? char-position? ruler )

need ?(

code string/  ( ca1 len1 len2 -- ca2 len2 )
  D9 c, C1 c, D1 c, E1 c, 19 c, A7 c, ED c, 42 c,
    \                           ;   T  B
    \                           ;  -- --
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c, C5 c, D9 c, jpnext  end-code
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

[unneeded] char-in-string? ?(  need -rot

: char-in-string? ( ca len c -- f )
  -rot bounds ?do   dup i c@ = if  drop true unloop exit  then
              loop  drop false  ; ?)

  \ doc{
  \
  \ char-in-string? ( ca len c -- f )
  \
  \ Is char _c_ in string _ca len_?
  \
  \ }doc

[unneeded] char-position? ?(  need -rot

: char-position?  ( ca len c -- +n true | false )
  -rot 0 ?do   2dup i + c@ = if  2drop i true unloop exit  then
         loop  2drop false  ; ?)

  \ doc{
  \
  \ char-position?  ( ca len c -- +n true | false )
  \
  \ If char _c_ is in string _ca len_, return its first
  \ position _+n_ and _true_; else return _false_.
  \
  \ }doc


[unneeded] ruler ?(

: ruler  ( c len -- ca len )
  dup allocate-string swap 2dup 2>r rot fill 2r>  ; ?)

  \ doc{
  \
  \ ruler  ( c len -- ca len )
  \
  \ Return a string _ca len_ of characters _c_.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ strings.replaces.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605181554

  \ -----------------------------------------------------------
  \ Description

  \ `replaces`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-18: Use `wordlist` instead of `vocabulary`, which
  \ has been moved to the library.

( replaces )

  \ Credit:
  \
  \ Code adapted from the Forth-2012 documentation.

need vocabulary

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

wordlist constant replaces-wordlist
  \ wordlist for substitution names and replacement texts

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

: findsubst  ( ca len -- xt f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _xt_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if    nip nip execute  \ get buffer address
                 else  makesubst
                 then  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )
  \
  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc

  \ vim: filetype=soloforth
  \ strings.s-quote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242149

  \ -----------------------------------------------------------
  \ Description

  \ `s'`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( s' )

  \ Credit:
  \
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  \
  \ Identical to the standard word `s"`, but using single
  \ quote as delimiter. A simple alternative to `s\"` when only
  \ double quotes are needed in a string.
  \
  \ }doc

: s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  ''' parse-string  ; immediate

  \ vim: filetype=soloforth
  \ system_variables.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605011901

  \ -----------------------------------------------------------
  \ Description

  \ Constants for the system variables.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-23: Fix: graphic coordinates variables were not
  \ included in the block title.
  \
  \ 2016-05-01: Add `os-attr-p`, `os-mask-p`, `os-attr-t`,
  \ `os-mask-t`

( os-chars os-chans os-flags2 os-seed os-frames os-udg )

[unneeded] os-chars    ?\ 23606 constant os-chars
  \ 1 cell:
  \ address of character 0 of the font (actual characters 32..127)

[unneeded] os-chans    ?\ 23631 constant os-chans
  \ 1 cell:
  \ address of the channels

[unneeded] os-flags2   ?\ 23658 constant os-flags2
  \ 1 byte:
  \ several flags

[unneeded] os-seed     ?\ 23670 constant os-seed
  \ 1 cell:
  \ seed of the random number generator

[unneeded] os-frames   ?\ 23672 constant os-frames
  \ 3 bytes:
  \ 24-bit counter of frames (1 frame = 20 ms)

[unneeded] os-udg      ?\ 23675 constant os-udg
  \ 1 cell:
  \ address of the User Defined Graphics (characters 128..255)

( os-coords os-coordx os-coordy )

[unneeded] os-coords      ?\ 23677 constant os-coords
  \ 2 cells:
  \ coordinates of last point plotted

[unneeded] os-coordx      ?\ 23677 constant os-coordx
  \ 1 cell:
  \ x-coordinate of last point plotted

[unneeded] os-coordy      ?\ 23678 constant os-coordy
  \ 1 cell:
  \ y-coordinate of last point plotted

( os-attr-p os-mask-p os-attr-t os-mask-t os-p-flag )

[unneeded] os-attr-p      ?\ 23693 constant os-attr-p
  \ 1 cell:
  \ permanent color attribute

[unneeded] os-mask-p      ?\ 23694 constant os-mask-p
  \ 1 cell:
  \ permanent transparent color attribute mask

[unneeded] os-attr-t      ?\ 23695 constant os-attr-t
  \ 1 cell:
  \ temporary color attribute

[unneeded] os-mask-t      ?\ 23696 constant os-mask-t
  \ 1 cell:
  \ temporary transparent color attribute mask

[unneeded] os-p-flag      ?\ 23697 constant os-mask-t
  \ 1 cell:
  \ print flags

  \ vim: filetype=soloforth
  \ tape.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604110003

  \ -----------------------------------------------------------
  \ Description

  \ Tape files support. The only supported filetype is "code".
  \ Contrary to BASIC, saving starts immediately (the message
  \ "Start tape, then press any key" is not printed).
  \
  \ Known issues:
  \
  \ 1) If the space key is pressed while reading or writing
  \ files, the ROM routine will issue a BASIC error and make
  \ the system crash.  This may be solved in the future, with
  \ the help of G+DOS, by trapping the error.
  \
  \ 2) Tape loading errors are not trapped. They make the
  \ system crash.
  \
  \ 3) No support to verify saved files. It may be added in the
  \ future, though it's not useful with emulators, without
  \ actual tapes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-12-04: Started adapting the tape words from the Afera
  \ library.
  \ 2015-12-23: Changes.
  \ 2016-04-10: Fixed. First working version.
  \ 2016-04-10: Improved: no "Start tape" message.

  \ -----------------------------------------------------------
  \ Development documentation

  \ The information was guessed from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119), the ZX Spectrum ROM
  \ disassembly (whose description of the tape headers is
  \ wrong), the _Abersoft Forth disassembled_ project
  \ (http://programandala.net/en.program.abersoft_forth.html)
  \ and the Afera library
  \ (http://programandala.net/en.program.afera.html).

  \ Structure of a tape header:

  \ +00 : byte, filetype (3 for code files)
  \ +01 : 10-char filename, padded with spaces
  \ +11 : cell, length
  \ +13 : cell, start address
  \ +15 : cell, not used for code files

  \ Arrangement of both tape headers:

  \ IX addresses the first header, which must contain the data.
  \ The second header is used by the system when loading and
  \ verifying. Only the "CODE" file type column is relevant to
  \ Solo Forth.

  \                 File types
  \                 -----------------------
  \ NEW     OLD     PROG   DATA  DATA  CODE
  \ HEADER  HEADER         num   chr          NOTES
  \ ------  ------  ----   ----  ----  ----   ----------------------------
  \ IX+$00  IX+$11  0      1     2     3      File type
  \ IX+$01  IX+$12  x      x     x     x      F  ($FF if filename is null)
  \ IX+$02  IX+$13  x      x     x     x      i
  \ IX+$03  IX+$14  x      x     x     x      l
  \ IX+$04  IX+$15  x      x     x     x      e
  \ IX+$05  IX+$16  x      x     x     x      n
  \ IX+$06  IX+$17  x      x     x     x      a
  \ IX+$07  IX+$18  x      x     x     x      m
  \ IX+$08  IX+$19  x      x     x     x      e
  \ IX+$09  IX+$1A  x      x     x     x      .
  \ IX+$0A  IX+$1B  x      x     x     x      Padding spaces
  \ IX+$0B  IX+$1C  lo     lo    lo    lo     Total...
  \ IX+$0C  IX+$1D  hi     hi    hi    hi     ...length of datablock
  \ IX+$0D  IX+$1E  Auto   -     -     Start  Various
  \ IX+$0E  IX+$1F  Start  a-z   a-z   addr   ($80 if no autostart).
  \ IX+$0F  IX+$20  lo     -     -     -      Length of program only...
  \ IX+$10  IX+$21  hi     -     -     -      ...i.e. without variables

( write-tape-file read-tape-file )

17 constant /tape-header
  \ doc{
  \
  \ /tape-header  ( -- n )
  \
  \ A constant. Length of the tape header stored at
  \ `tape-header`: 17 bytes.
  \
  \ }doc

create tape-header  /tape-header 2 * allot

  \ doc{
  \
  \ tape-header  ( -- a )

  \ Address of the tape header, which is used by the ROM
  \ routines. Its structure is the following:

  \ |===
  \ | Offset  | Size     | Description
  \
  \ | +00     | byte     | filetype
  \ | +01     | 10-chars | filename, padded with spaces
  \ | +11     | cell     | length
  \ | +13     | cell     | start address
  \ | +15     | cell     | not used for code files
  \ |===

  \ When the first char of the filename is code 255, it is
  \ regarded as a wildcard which will match any filename. The
  \ word `read-tape-file` sets the wildcard when the provided
  \ filename is empty. See `any-tape-filename` and
  \ `?set-tape-filename`.
  \
  \ A second tape header follows the main one. It is used by
  \ the ROM routines while loading.

  \ }doc

10 constant /tape-filename \ filename max length

: tape-filetype  ( -- ca )  tape-header  ;

  \ doc{
  \
  \ tape-filetype  ( -- ca )
  \
  \ Address of the file type (one byte) in the tape header.
  \ See `tape-header`.
  \
  \ }doc

: tape-filename  ( -- ca )  tape-header 1+  ;

  \ doc{
  \
  \ tape-filename  ( -- ca )
  \
  \ Address of the filename in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-length    ( -- a )   tape-header 11 +  ;

  \ doc{
  \
  \ tape-length  ( -- a )
  \
  \ Address of the file length in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-start     ( -- a )   tape-header 13 +  ;

  \ doc{
  \
  \ tape-start  ( -- a )
  \
  \ Address of the file start in the tape header pointed by
  \ `tape-header`.
  \
  \ }doc

3 tape-filetype c!  \ "code" filetype by default

-->

( write-tape-file read-tape-file )

: -tape-filename  ( -- )  tape-filename /tape-filename blank  ;

  \ doc{
  \
  \ -tape-filename  ( -- )
  \
  \ Blank the filename of the tape header.
  \
  \ }doc

: any-tape-filename  ( -- )  255 tape-filename c!  ;

  \ doc{
  \
  \ any-tape-filename  ( -- )
  \
  \ Configure the tape header to load any filename,
  \ by replacing the first char of the filename with 255,
  \ which will be recognized as a wild card.
  \
  \ }doc

: set-tape-filename  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-filename swap cmove  ;

  \ doc{
  \
  \ set-tape-filename  ( ca len -- )
  \
  \ Store filename _ca len_ into the tape header.
  \
  \ }doc

: ?set-tape-filename  ( ca len -- )
  dup if    set-tape-filename
      else  2drop any-tape-filename  then  ;

  \ doc{
  \
  \ ?set-tape-filename  ( ca len -- )
  \
  \ If filename _ca len_ is not empty, store it into the tape
  \ header; else use a wildcard instead.
  \
  \ }doc

: set-tape-memory  ( ca len -- )
  tape-length ! tape-start !  ;

  \ doc{
  \
  \ set-tape-memory  ( ca len -- )
  \
  \ Configure the tape header with the memomy zone _ca len_ (to
  \ be read or written).
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (read-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,  2A c, tape-start ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
    \ ld hl,(tape_start)
  3E c, 01 c,  32 c, 5C74 ,  CD c, 075A ,
    \ ld a,1      ; 1=load
    \ ld (5C74),A ; T_ADDR system variable
    \ call 075A   ; SA_ALL ROM routine
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore the address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (read-tape-file)  ( -- )
  \
  \ Low-level action of `read-tape-file`: read a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: read-tape-file  ( ca1 len1 ca2 len2 -- )
  ?set-tape-filename set-tape-memory (read-tape-file)  ;

  \ doc{
  \
  \ read-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Read a tape file _ca2 len2_ (_len2_ is zero if filename is
  \ unspecified) into a memory region _ca1 len1_.
  \
  \ _ca1_ is zero if the address must be taken from the file
  \ header instead, which is the address the file was saved
  \ from.  _len1_ is zero if is unspecified.
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (write-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
  A8 07 + c,  32 c, 5C74 ,
    \ xor a       ; 0=save
    \ ld (5C74),a ; T_ADDR system variable
  21 c, here 0A + ,  E5 c,
    \ ld hl,return_from_ROM
    \ push hl ; simulate a call
  2A c, tape-start ,  E5 c,
    \ ld hl,(tape_start) ; start of data
    \ push hl ; needed by entry point $0984,
    \         ; because it's done at the main entry point $0970
  C3 c, 0984 ,
    \ jp $0984  ; alternative entry point to SA_ALL, after the save message
    \           ; note: `jp` is used, but it works as a `call`,
    \           ; because the return address has been pushed
    \ return_from_ROM:
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (write-tape-file)  ( -- )
  \
  \ Low-level action of `write-tape-file`: write a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: write-tape-file  ( ca1 len1 ca2 len2 -- )
  set-tape-filename set-tape-memory (write-tape-file)  ;

  \ doc{
  \
  \ write-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Write a memory region _ca1 len1_ into a tape file _ca2
  \ len2_.
  \
  \ }doc

( .tape )

  \ XXX TMP -- for debugging

: .tape  ( -- )
  cr ." Tape header " tape-header u. cr
     ." Filetype    " tape-filetype c@ . cr
     ." Filename    " tape-filename /tape-filename type cr
     ." Length      " tape-length @ u. cr
     ." Start       " tape-start @ u. cr
     .s cr
     ." Press any key" key drop  ;


  \ vim: filetype=soloforth
  \ time.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170054

  \ -----------------------------------------------------------
  \ Description

  \ Words related to time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Make block titles compatible with `indexer`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( ms )

need os-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / os-frames @ +
  begin  dup os-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

need os-frames

: frames@  ( -- d )
  os-frames @ [ os-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ os-frames 2+ ] literal c! os-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-xt  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-xt  hl pop  execute-hl
      \ execute the xt hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-xt

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-xt
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but its current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl  need >body

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm  need execute-hl  need >body

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the xt hold in `(wait)`:

    ' (wait) >body fthl execute-hl

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- adapt `pause` to DTC, needed?

( just-pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit  then
  dup 100 mod 0= if  drop false  exit  then
        4 mod 0= if       false  exit  then
  false  ;

exit

  \ Alternative.

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

( set-date get-date )

create (date)  1 c,  1 c,  2016 ,
  \ day, month, year

: get-date  ( -- day month year )
  (date) c@
  [ (date) 1+ ] literal c@
  [ (date) 2+ ] literal @  ;

  \ doc{
  \
  \ get-date  ( -- day month year )
  \
  \ Get the current date. The default date is 2016-01-01. It
  \ can be changed with `set-date`. The date is not updated by
  \ the system.
  \
  \ }doc

: set-date  ( day month year -- )
  [ (date) 2+ ] literal !
  [ (date) 1+ ] literal c!
  (date) !  ;

  \ doc{
  \
  \ set-date  ( day month year -- )
  \
  \ Set the current date. The default date is 2016-01-01. It
  \ can be fetch with `get-date`. The date is not updated by
  \ the system.
  \
  \ }doc

( set-time get-time reset-time )

need frames@  need frames!  need m+  need alias  need ud*

: get-time  ( -- second minute hour )
  frames@ 50 um/mod nip s>d   ( sec . )
          60 um/mod s>d       ( sec min . )
          60 um/mod           ( sec min hour )  ;

  \ doc{
  \
  \ get-time  ( -- second minute hour )
  \
  \ Return the current time.
  \
  \ The system doesn't have an actual clock. The system frames
  \ counter is used instead. It is increased by the interrupts
  \ routine every 20th ms. The counter is a 24-bit value, so
  \ its maximum is $FFF ticks of 20 ms (5592 minutes, 93
  \ hours), then it starts again from zero.
  \
  \ }doc

: set-time  ( second minute hour -- )
  3600 um*  rot 60 * m+  rot m+  ( seconds )
  50. ud* frames!  ;

  \ doc{
  \
  \ set-time  ( second minute hour -- )
  \
  \ Set the current time. See `get-time`.
  \
  \ }doc

' reset-frames alias reset-time  ( -- )

  \ doc{
  \
  \ reset-time  ( -- )
  \
  \ Reset the current time to 00:00:00. See `get-time`.
  \
  \ }doc

( .time .system-time .date .system-date .time&date time&date )

  \ XXX TODO document

need get-time  need get-date

: .00  ( n -- )  s>d <# # # #> type  ;
: .0000  ( n -- )  s>d <# # # # # #> type  ;

: .time  ( second minute hour -- )
  .00 ':' emit .00 ':' emit .00  ;

: .system-time  ( -- )  get-time .time  ;

: .date  ( day month year -- )
  .0000 '-' emit .00 '-' emit .00  ;

: .system-date  ( -- )  get-date  .date  ;

: .time&date  ( second minute hour day month year -- )
  .date 'T' emit .time  ;

: time&date  ( -- second minute hour day month year )
  get-time get-date  ;

  \ doc{
  \
  \ time&date  ( -- second minute hour day month year )
  \
  \ Return the current time and date: second (0..59), minute
  \ (0..59), hour (0..23), day (1..31), month (1..12) and year
  \ (e.g., 2016).
  \
  \ See: `get-time`, `get-date`, `set-time`, `set-date`.
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-201 (FACILITY
  \ EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tool.debug.assert.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Versions of the `assert` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( assert assert= )

  \ Credit:
  \
  \ Taken from Brad Nelson's code:
  \ http://bradn123.github.io/literateforth/out/events.fs

: assert   ( n -- )    0= if  abort  then  ;
: assert=  ( a b -- )  = assert  ;

( assert( )

  \ Credit:
  \
  \ Code and documentation from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

  \ vim: filetype=soloforth
  \ tool.debug.tilde-tilde.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The `~~` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ~~ )

  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->


( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

  \ vim: filetype=soloforth
  \ tool.debug.where.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242149

  \ -----------------------------------------------------------
  \ Description

  \ `where`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-21: 3 bytes shorter.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr #" dec. cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces '^' emit
  else  2drop  then  ;

  \ vim: filetype=soloforth
  \ tool.decode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605210052

  \ -----------------------------------------------------------
  \ Description

  \ The `decode` utility.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions (volume 4, number 2, page 28, 1982-07).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-05: Copied from Afera. First changes to adapt it.
  \
  \ 2015-06-19: Added `?branch`.
  \
  \ 2015-07-23: Fix: `clit` was not included in the recognized
  \ special cases.
  \
  \ 2015-08-14: Fixed a recent bug: `sp0 sp!` was used when
  \ quitting, instead of `sp0 @ sp!`!
  \
  \ 2015-10-09: Fix: `slit` was missing from the special cases.
  \
  \ 2015-12-21: Fixed `decode-special` after the Forth-83
  \ version of `do loop`: now the branch address is after `do`
  \ or `?do`; also added `-branch` to it, in case it is already
  \ defined during the compilation of `decode-special`.
  \
  \ 2015-12-24: Start converting from ITC to DTC.
  \
  \ 2016-04-15: Fixed `decode-compile`, which had not been
  \ adapted from ITC to DTC.
  \
  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore. Updated the history from the
  \ development history of the project.
  \
  \ 2016-04-24: Add support for `2lit`.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-17: Need `>body` and `body>`, which has been moved
  \ to the library.
  \
  \ 2016-05-18: Improve `colon-cfa?`. Compact `decode-special`.
  \ Fix `decode`, which showed the usage instructions before
  \ checking the word.

( decode )

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]
need recurse  need >body  need body>

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2* spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-2literal   ( a1 -- a2 )  cell+ dup 2@ d. cell+  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )  cell+ dup @ >name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )  dup @ case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] 2lit      of  decode-2literal   endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof
    [undefined] cslit   ?\ ['] cslit   of decode-sliteral endof
    [undefined] -branch ?\ ['] -branch of decode-branch   endof
  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD = swap 1+ @ docolon = and  ;
  \ Is _cfa_ a colon definition?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the colon interpreter.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is _pfa_ a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @  ( pfa+n xt ) dup decode-end? 0=
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      >body ( pfa+n pfa' ) dup indent+  body>name .name
      key case  'q' of  sp0 @ sp! quit  endof
                bl  of  drop            endof
                swap recurse  \ default
          endcase  decode-special  cell+  -1 decode-level +!
    repeat  indent >name .name
            \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  defined  ( nt | 0 )  dup 0= -13 ?throw
  decode-usage
  name>body  decode-level off  (decode)  ;

  \ vim: filetype=soloforth
  \ tool.dump.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271523

  \ -----------------------------------------------------------
  \ Description

  \ Two versions of the `dump` tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-15: Fixed `dump` (the loop printed one byte more
  \ than requested). Improved `ascii-type` (now also characters
  \ above 127 are printed as dots, not masked).
  \
  \ 2016-04-24: Fix `dump`: nothing was printed when length was
  \ less than 8.
  \
  \ 2016-04-27: Move `ascii-char?` and `control-char?` to
  \ module "chars.fsb".  Move `ascii-type` to module
  \ "printing.type.fsb" and rename it to `type-ascii`. Replace
  \ `bs` with `backspace`, which is part of the library.

( dump )

need 16hex.  need type-ascii  need backspace

: dump  ( ca len -- )
  8 max 8 2dup mod - + 8 / 1- 0
  ?do
    cr dup 16hex.
    8 0 do  i over + @ flip 16hex.  cell +loop
    dup backspace 8 type-ascii
    break-key? ?leave
  8 + loop  drop  ;
  \ Show the contents of _n_ bytes starting from _ca_.

( wdump )

need 16hex.

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  ?do
    i 4 mod 0= if  cr dup 16hex. space  then  \ show address
    dup @ 16hex. cell+
    break-key? ?leave
  loop  drop  ;

  \ vim: filetype=soloforth
  \ tool.history.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605070041

  \ -----------------------------------------------------------
  \ Description

  \ The command line history tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-05: Update `s=` to `str=`.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.

( history )

  \ XXX NEW -- upwards version, with back linked strings

  \ Every entry in the command line history has the following
  \ structure:
  \
  \ +0    : length byte
  \ +1..n : string
  \ +n+1  : address of +0

variable /history
  \ Size of the history space, where all strings are hold.

variable hp0
  \ Address of the bottom of the history.

variable hp
  \ The history pointer: Address of the free space in the
  \ history.

: used-history  ( -- u )  hp0 @ hp @  -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

: allot-history  ( +n -- )  hp +!  ;
  \ Reserve _+n_ bytes in the history.

: len>history  ( len -- +n )  1+ cell+  ;
  \ Convert a string length to space required to store it into
  \ the history.

: history>link  ( ca -- a )  cell-  ;
  \ Convert a history string address to its link field.

: history<history  ( ca1 -- ca2 )  history>link @s  ;
  \ Convert a history string address to the previous one.

: history>history  ( ca1 -- ca2 )
  system-bank count default-bank  + cell+  ;
  \ Convert a history string address to the next one.

: history>string  ( ca1 -- ca2 len2 )
  system-bank count save-string default-bank  ;  -->
  \ Copy a history string to a string in the circular string
  \ buffer.

( history )

variable browsed-history
  \ Address of the history string being browsed.

: oldest-history?  ( -- f )  browsed-history @ hp0 @ =  ;
  \ Are we browsing the oldest string of history?

: browse-older-history  ( -- )
  oldest-history? ?exit
  browsed-history @ history<history browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newest-history?  ( -- )
  browsed-history @ history>history hp @ =
  browsed-history @ hp @ =  or  ;
  \ Are we browsing the newest string of history?

: browse-newer-history  ( -- )
  newest-history? ?exit
  browsed-history @ history>history browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( n -- )
  dup /history !  $FFFF swap -
  dup hp0 !  dup hp !  browsed-history !  0 hp0 @ c!s  ;

1024 init-history  -->

( history )

need str=

: history-empty?  ( -- f )  used-history 0=  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

-->

( history )

: latest-history$  ( -- ca len )
  hp @ history<history history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: duplicated-history?  ( ca len -- f )  latest-history$ str=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: longer-history?  ( len -- f )
  len>history unused-history >  ;
  \ Is _len_ too long?

: history,  ( ca len -- )
  hp @ dup >r  over >r  ( ca len ca1 ) ( R: len ca1 -- )
  system-bank place default-bank
  r> 1+ allot-history  r> hp @ !s  cell allot-history  ;
  \ Add a string to the command line history.

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
  2dup duplicated-history? if  2drop exit  then
  dup longer-history? if  dup allocate-history throw  then
  history,  hp @ browsed-history !  ;
  \ Save string _ca len_ into the command line history,
  \ provided the string is valid (not empty, not duplicated).
  \ Make room if necessary. Then update the pointer to the
  \ browsed history.

-->

( history )

: browsed-history$  ( -- ca len )
  browsed-history @ history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: get-history   ( -- ca )  browsed-history$ set-accept  ;

: (history-up)    ( -- ca )
  get-history browse-older-history  ;
: (history-down)  ( -- ca )
  get-history browse-newer-history  ;

-->

( history )

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  ['] 2drop ['] >history defer!
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  ['] (>history) ['] >history defer!
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

-->

( history )

: .history  ( -- )
  hp0 @ begin  dup hp @ u<  while
          dup history>string type cr  history>history
        repeat  drop  ;

need dump

: hdump  ( ca len -- )  system-bank dump default-bank  ;

: .h  ( -- )  hp0 dup hp @ - hdump  ;

\ history-on

( history-xxx-old )

  \ XXX OLD -- downwards version

  \ 2016-03-07: Start.

  \ Command line history is implemented as a list of counted
  \ string at the top of a memory bank. It's the same bank
  \ where name fields are stored. Name fields are stored
  \ upwards from the bottom of the 16-KiB space; command line
  \ history grows downwards from the top.
  \
  \ The length of the every counted string is used as a link
  \ field to the previous string.  The bottom of the list is
  \ the highest address of the bank, and it holds one byte, the
  \ length of the first string stored in the history, or zero
  \ when the history is empty.
  \
  \ There's a maximum space usable for the history. When
  \ there's no free space left to store a new string, oldest
  \ strings are removed as necessary.

  \ 2016-03-08: XXX TODO -- Rewrite, simpler: grow upwards.

variable hp
  \ Pointer to the most recent string in the history.

$FFFF constant hp0
  \ Pointer to the bottom of the history, which contains a copy
  \ of the length of the first string.

variable /history  1024 /history !
  \ Size of the history space, where all strings are hold.

: init-hp0  ( -- )  0 hp0 c!s  ;

: history-bounds  ( -- ca1 ca2 )  hp0 hp @  ;
  \ Return bottom of history _a1_ and address of the latest
  \ string _ca2:

: used-history  ( -- u )  history-bounds -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

-->

( history-xxx-old )

variable previously-browsed-history
  \ Address of the history string previously browsed.

variable currently-browsed-history
  \ Address of the history string being browsed.

: older-history  ( -- )
  currently-browsed-history @ dup previously-browsed-history !
  system-bank count default-bank +
  currently-browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newer-history  ( -- )
  currently-browsed-history @
  previously-browsed-history @ currently-browsed-history !
  currently-browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( -- )
  init-hp0  hp0 dup hp ! currently-browsed-history !  ;

init-history  -->

( history-xxx-old )

need str=

: allot-history  ( +n -- )  negate hp +!  ;
  \ Reserve _+n_ bytes in the history.

: history-empty?  ( -- f )  history-bounds =  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

: latest-history  ( -- ca len )
  system-bank  hp @ count  save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.
  \ XXX OLD

: browsed-history  ( -- ca len )
  currently-browsed-history @
  system-bank  count save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: (history>)  ( -- ca len )
  browsed-history  dup 0= ?exit
                   dup 1+ negate allot-history
  history-empty? if  init-hp0  then  ;  -->
  \ Get a string from the command line history, and return it
  \ as _ca len_ in the circular string buffer.
  \ XXX TODO -- adapt the browser variables

( history-xxx-old )

: duplicated-history?  ( ca len -- f )  latest-history str=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: too-long-for-history?  ( len -- f )  1+ unused-history > ;

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
    \ If string is empty, do nothing.
  history-empty? if  dup hp0 c!s  then
    \ If history is empty, init its bottom with the length
    \ of the string.
  2dup duplicated-history? if  2drop exit  then
  dup too-long-for-history?
  if  dup allocate-history throw  then
    \ If there's no space left, allocate it.
  dup 1+ allot-history
  hp @ dup system-bank place default-bank
           currently-browsed-history !  ;
  \ Save string _ca len_ into the command line history.

-->

( history-xxx-old )

: get-history   ( -- ca )  browsed-history set-accept  ;
: (history-up)    ( -- ca )  get-history older-history  ;
: (history-down)  ( -- ca )  get-history newer-history  ;

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  \ XXX OLD
  \ ['] 2drop ['] >history defer!
  \ ['] s""   ['] history> defer!  history off  ;
  \ XXX NEW
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  \ XXX OLD
  \ ['] (>history) ['] >history defer!
  \ ['] (history>) ['] history> defer!  history on  ;
  \ XXX NEW
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

: .history  ( -- )
  hp @  begin  dup hp0 <  while
          system-bank count 2dup type cr default-bank  +
        repeat  drop  ;

\ history-on

  \ vim: filetype=soloforth
  \ tool.list.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604021142

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap ?do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap ?do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap ?do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

  \ vim: filetype=soloforth
  \ tool.list.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242150

  \ -----------------------------------------------------------
  \ Description

  \ Words to examine the stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.
  \
  \ 2016-04-12: Divided into 3 blocks, in order to reuse
  \ `.depth` for the floating point `.fs`. Fixed the check: the
  \ stacks are not printed when their depth is negative.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( .depth )


: .depth  ( n -- )  '<' emit 0 .r '>' emit space  ;

( .s )

  \ Credit:
  \ Code from Afera. Original algorithm from v.Forth.

need .depth

: .s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ .  [ cell negate ] literal +loop
  then  ;

( u.s )

need .depth

: u.s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ u.  [ cell negate ] literal +loop
  then  ;

  \ vim: filetype=soloforth
  \ tool.list.word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060218

  \ -----------------------------------------------------------
  \ Description

  \ Tool words to list word lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-11: Documented.
  \ 2016-05-01: Update.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-05: Remove unnecessary `space` from `.wid`.
  \ 2016-05-06: Improve printing of nameless word lists.

( wordlists .wid .current .context order )

need [if]

[needed] wordlists [if]

: wordlists  ( -- )
  voc-link begin  @ ?dup  while  dup .wid wid>link  repeat  ;
  \ List all wordlists.
  \ XXX FIXME -- prints only one

exit [then]

need wid>name  need get-order

: .wid  ( wid -- )
  dup wid>name ?dup if  .name drop exit  then  u.  ;

  \ doc{
  \
  \ .wid  ( wid -- )
  \
  \ Display the id of the word list _wid_: it can be an
  \ associated name or the number _wid_.
  \
  \ }doc

: .current  ( -- )  get-current .wid  ;

  \ doc{
  \
  \ .current  ( -- )
  \
  \ Display the word list into which new definitions will be
  \ placed.
  \
  \ }doc

: .context  ( -- )
  get-order begin  ?dup  while  swap .wid 1-  repeat  ;

  \ doc{
  \
  \ .context  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched.
  \
  \ }doc

: order  ( -- )
  cr ." Search: " .context cr ." Compile: " .current  ;

  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

  \ doc{
  \
  \ order  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched. Also
  \ display the word list into which new definitions will be
  \ placed.
  \
  \ Origin: Forth-2012 (SEARCH EXT).

  \ }doc

  \ vim: filetype=soloforth
  \ tool.list.words.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605042236

  \ -----------------------------------------------------------
  \ Description

  \ Words to list words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-09-12: Fix `words-like`.
  \ 2016-05-04: Compact the blocks. Add `words#`. Document.

( more-words? words wordlist-words )

need nuf?

: more-words?  ( nt|0 -- nt|0 f )  dup 0<>  nuf? 0= and  ;

  \ doc{
  \
  \ more-words?  ( nt|0 -- nt|0 f )
  \
  \ A common factor of `words` and `words-like`.
  \
  \ }doc


[needed] more-word? ?exit

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need trail  need name<name  need tab

: words  ( -- )
  trail begin  more-words?  while
          dup .name tab  name<name
        repeat drop  ;

  \ doc{
  \
  \ words  ( -- )
  \
  \ List the definition names in the first word list of
  \ the search order.
  \
  \ Origin: Forth-83 (Uncontrolled Reference Words), Forth-94
  \ (TOOLS), Forth-2012 (TOOLS).
  \
  \ }doc

[needed] words  ?exit

: wordlist-words  ( wid -- )  >order  words  previous  ;

  \ doc{
  \
  \ wordlist-words  ( wid -- )
  \
  \ List the definition names in word list _wid_.
  \
  \ }doc

( words-like words# )

need trail  need name<name  need tab  need more-words?
need [if]

[needed] words-like [if]  [defined] contains
?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
   \ Does the string _ca1 len1_ contains the string _ca2
   \ len2?_

: words-like  ( "name" -- )
  parse-name 2dup uppers trail  ( ca len nt )
  begin  more-words?  while
    dup >r name>string 2over contains if  r@ .name tab  then
        r> name<name
  repeat drop 2drop  ;  [then]

  \ doc{
  \
  \ words-like  ( "name" -- )
  \
  \ List the definition names, from the first word list of
  \ the search order, that contain substring "name".
  \
  \ }doc

  \ Credit:
  \
  \ Code of `words-like` adapted from pForth.

[needed] words# [if]
: words#  ( -- n ) 0 trail begin  ( n nt ) dup 0<>  while
                             swap 1+ swap  name<name
                           repeat drop  ;  [then]

  \ doc{
  \
  \ words#  ( -- n )
  \
  \ Return number _n_ of words defined in the first word list
  \ of the search order.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tool.marker.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201606010102

  \ -----------------------------------------------------------
  \ Description

  \ `marker`, `anew`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-27: Add `possibly`, `anew`.
  \
  \ 2015..2016: Drafts of `marker`.
  \
  \ 2016-01-01: Add example of `marker` from m3forth.
  \
  \ 2016-04-24: Move `n,` to module "compilation.fsb".
  \
  \ 2016-04-25: First working version of `marker`. Move
  \ `possibly` to the module "compilation.fsb".
  \
  \ 2016-06-01: Update: `there` was moved from the kernel to
  \ the library.

( marker )

  \ XXX TODO -- save and restore also the nt associated (+4):
  \ |===
  \ | +0 | _nt_ of last definition
  \ | +2 | _wid|0_, next wordlist in chain, or zero
  \ | +4 | _nt|0_, word list name pointer, or zero
  \ |===

: wordlists,  ( -- )
  voc-link @ begin
    dup cell- @  ( a nt ) , @
  ?dup 0= until  ;

  \ doc{
  \
  \ wordlists,  ( -- )
  \
  \ Store the latest definition of every word list in the data
  \ space.
  \
  \ }doc

: @wordlists  ( a -- )
  voc-link @ begin
    2dup  swap @ swap cell- !
    swap cell+ swap  @
  ?dup 0= until  drop  ;

  \ doc{
  \
  \ @wordlists  ( a -- )
  \
  \ Fetch the latest definition of every word list from _a_.
  \
  \ }doc

-->

( marker )

  \ Credit:
  \
  \ Code partly inspired by m3forth's `marker`:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

need get-order  need @cell+  need nn,  need nn@  need there

: @order  ( a -- )  nn@ set-order  ;

: unmarker  ( a -- )
  dup there
  @cell+ np!  @cell+ last !  @cell+ lastxt !  @cell+ voc-link !
  @cell+ set-current
  dup dup @ 1+ cells + >r  @order  r> @wordlists  ;

  \ doc{
  \
  \ unmarker  ( a -- )
  \
  \ Set the data-space pointer to _a_ and restore the names
  \ pointer, the latest definition pointers, the word lists
  \ pointer, the compilation word list, the search order and
  \ the configuration of word lists that were saved at _a_ by
  \ `marker,`.
  \
  \ This word is a factor of `marker`.
  \
  \ }doc

: order,  ( -- )  get-order nn,  ;

: marker,  ( -- a )
  here  np@ ,  last @ ,  lastxt @ ,  voc-link @ ,
        get-current ,  order,  wordlists,  ;

  \ doc{
  \
  \ marker,  ( -- a )
  \
  \ Store the names pointer, the latest definition pointers,
  \ the word lists pointer, the current compilation word list,
  \ the search order and the configuration of word lists at the
  \ current data-space pointer, and return its address _a_, for
  \ later restoration by `unmarker`.
  \
  \ This word is a factor of `marker`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: marker  ( "name" -- )
  marker, create ,  does>  ( -- )  ( pfa ) @ unmarker  ;

  \ doc{
  \
  \ marker  ( "name" -- )
  \
  \ Create a definition "name". When "name" is executed, it
  \ will restore the data-space pointer, the word lists
  \ pointer, the compilation word list, the search order and
  \ the configuration of word lists to the state they had just
  \ prior to the definition of "name".
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( anew )

need possibly  need marker

  \ Credit:
  \
  \ Code adapted from Wil Baden.

  \ XXX TODO -- test
  \ XXX TODO -- use `save-input` and `restore-source` when
  \ possible

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

  \ vim: filetype=soloforth
  \ tool.turnkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604262107

  \ -----------------------------------------------------------
  \ Description

  \ Words to save the system.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( extend size system turnkey )

  \ XXX WARNING -- Since name fields are saved in a memory
  \ bank, the best way to save a modified Forth system is to
  \ make a snapshot with the ZX Spectrum emulator; otherwise a
  \ multipart saving and loading would be needed.  Anyway,
  \ these words are meant to save a Forth program that does not
  \ need to search the dictionary.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )

  \ XXX TODO -- update:

  latest $08 +origin !  \ top most word in `forth` vocabulary
  here $1F +origin !   \ `dp` init value
  np@ $26 +origin !   \ `np` init value
  voc-link @ $0C +origin !  ;  \ `voc-link` init value

  \ doc{
  \
  \ extend  ( -- )
  \
  \ }doc
  \
  \ Change the `cold` start parameters to extend the system to
  \ its current state.

: size  ( -- u )  here 0 +origin -  ;

  \ doc{
  \
  \ size  ( -- u )
  \
  \ Size of the system.
  \
  \ }doc

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ doc{
  \
  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.
  \
  \ }doc

: turnkey  ( xt -- a len )  boot defer! system  ;

  \ doc{
  \
  \ turnkey  ( xt -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given xt after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181258

  \ -----------------------------------------------------------
  \ Description

  \ Words related to word lists.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore.
  \
  \ 2016-05-02: Join several blocks, to save space.
  \
  \ 2016-05-04: Improve the documentation of `trail`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library. Improve conditional compilation.
  \
  \ 2016-05-18: Simplify conditional compilation. Move
  \ `vocabulary` from the kernel and rewrite it after
  \ `wid>vocabulary` and the new word `dovocabulary`.

( wid>link (wid>name wid>name )

[unneeded] wid>link
?\ need alias  ' cell+ alias wid>link  ( wid -- a ) exit

[unneeded] (wid>name
?\ : (wid>name  ( wid -- a )  [ 2 cells ] literal +  ; exit

  \ doc{
  \
  \ (wid>name  ( wid -- a )
  \
  \ Return the address _a_ which holds the _nt_ of word list
  \ _wid_ (or zero if the word list has no associated name).
  \
  \ }doc

[unneeded] wid>name
?\ need (wid>name : wid>name  ( wid -- nt|0 )  (wid>name @  ;

  \ doc{
  \
  \ wid>name  ( wid -- nt|0 )
  \
  \ Return the _nt_ associated to word list _wid_ (or zero if
  \ the word list has no associated name).
  \
  \ }doc

( named-wid wid>vocabulary vocabulary )

need ?(  [unneeded] named-wid ?(  need (wid>name
: named-wid  ( wid -- )  (wid>name latest swap !  ; ?)

  \ doc{
  \
  \ named-wid ( wid -- )
  \
  \ Associate the latest name to word list _wid_.
  \
  \ }doc

[unneeded] wid>vocabulary ?(  need named-wid
: wid>vocabulary  ( wid "name" -- )
  create dup , named-wid dovocabulary  ; ?)

  \ doc{
  \
  \ wid>vocabulary  ( wid "name" -- )
  \
  \ Create a vocabulary "name" for the word list _wid_.
  \
  \ }doc

[unneeded] vocabulary ?(  need wid>vocabulary
: vocabulary  ( "name" -- )  wordlist wid>vocabulary  ; ?)

  \ doc{
  \
  \ vocabulary  ( "name" -- )
  \
  \ Create a vocabulary _name_. A vocabulary is a named word
  \ list. Subsequent execution of `name` replaces the first
  \ entry in the search order with the word list associated to
  \ `name`. When `name` becomes the compilation word list new
  \ definitions will be appended to `name`'s word list.
  \
  \ See: `wordlist`, `definitions`.
  \
  \ Origin: Forth-83 (Required Word Set).
  \
  \ }doc

( get-order order@ )

  \ Credit: Code from eForth.

need recurse

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@  ;

( trail find-name-in find swap-current wid-of )

[unneeded] trail ?\ : trail  ( -- nt )  context @ @  ;  exit

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the first word list
  \ of the search order.
  \
  \ }doc

[unneeded] find-name-in
?\ : find-name-in  ( ca len wid -- nt | 0 ) @ find-name-from  ;

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in
  \ word list _wid_. If the definition is found, return its
  \ _nt_, else return zero.
  \
  \ The search is case-sensitive.  // XXX TODO -- confirm
  \
  \ }doc

need ?(  [unneeded] find ?(
: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ; ?)

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

[unneeded] swap-current ?(
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ; ?)

  \ Credit:
  \
  \ Idea for `swap-current` from lpForth.

[unneeded] wid-of ?( need >body
  : wid-of  ( "name" -- wid )  ' >body @  ; ?)

  \ doc{
  \
  \ wid-of  ( "name" -- wid )
  \
  \ Return the _wid_ associated to vocabulary "name".
  \
  \ Origin: eForth's `widof`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ game.life.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605020146

  \ -----------------------------------------------------------
  \ Description

  \ Conway's Game of Life, or Occam's Razor Dulled

  \ -----------------------------------------------------------
  \ Authors

  \ Original ANS Forth version: Copyright (C) 1995 Leo Wong.
  \
  \ Version for kForth: K. Myneny, 2001-12-26.
  \
  \ Version for Solo Forth: Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Code adapted from kForth. Original Credit:

  \ The original ANS Forth version by Leo Wong (see bottom) has
  \ been modified slightly to allow it to run under kForth.
  \ Also, delays have been changed from 1000 ms to 100 ms for
  \ faster update --- K. Myneni, 12-26-2001
  \
  \ 950724 + 970703 +
  \ Copyright 1995 Leo Wong
  \ hello at albany dot net
  \ http://www.albany.net/~hello/

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Start.
  \
  \ 2016-04-03: Header reorganized after the original credit.
  \
  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library. Change the stack notation.
  \
  \ 2016-05-02: Compact two blocks to save space in the
  \ library.

( life )

  \ XXX FIXME -- works in Gforth, but freezes here.

need ms  need c+!  need 2/

1 CHARS CONSTANT /Char

  \ the universal pattern
32 CONSTANT How-Deep  24 CONSTANT How-Wide

How-Wide How-Deep * CONSTANT Homes

  \ world wrap
: World  ( "name" -- )
  CREATE  Homes CHARS ALLOT
  DOES>  ( u -- c-addr )
    ( u pfa ) SWAP Homes +  Homes MOD  CHARS + ;

World old  World new

  \ biostatistics

  \ begin hexadecimal numbering
  \ hex xy : x holds life , y holds neighbors count

$10 CONSTANT Alive  \ 0y = not alive

  \ Conway's rules:
  \ a life depends on the number of its next-door neighbors

  \ it dies if it has fewer than 2 neighbors
: Lonely  ( c -- f )  $12 < ;

  \ it dies if it has more than 3 neighbors
: Crowded  ( c -- f )  $13 > ;

: -Sustaining  ( c -- f )  DUP Lonely  SWAP Crowded  OR ;

  \ it is born if it has exactly 3 neighbors
: Quickening  ( c -- f )  $03 = ;

-->

( life )

  \ compass points
: N  ( i -- j )  How-Wide - ;
: S  ( i -- j )  How-Wide + ;
: E  ( i -- j )  1+ ;
: W  ( i -- j )  1- ;

  \ census
: Home+!  ( -1|1 i -- )  >R  Alive *  R> new C+! ;

: Neighbors+!  ( -1|0|1 i -- )
  2DUP N W new C+!  2DUP N new C+!  2DUP N E new C+!
  2DUP   W new C+!  (     i      )  2DUP   E new C+!
  2DUP S W new C+!  2DUP S new C+!       S E new C+! ;

: Bureau-of-Vital-Statistics ( -1|1 i -- )
  2DUP Home+!  Neighbors+! ;

  \ mortal coils
'?' CONSTANT Soul  BL CONSTANT Body

-->

( life )

: Home  ( c i -- )  How-Wide /MOD AT-XY  EMIT ;

: Is-Born  ( i -- )
  Soul OVER Home  1 SWAP Bureau-of-Vital-Statistics ;

: Dies  ( i -- )
  Body OVER Home  -1 SWAP Bureau-of-Vital-Statistics ;

: One  ( c-addr -- i )  0 old -  /Char / ;

: there  ( -- )  How-Wide 1- 0 AT-XY ;

: Everything  ( -- )
  0 old  Homes
  BEGIN  DUP
  WHILE  OVER C@  DUP Alive AND
     IF   -Sustaining IF  OVER One Dies     THEN
     ELSE  Quickening IF  OVER One Is-Born  THEN THEN
     1 /STRING
  REPEAT  2DROP  there  ;  -->

( life )

  \ in the beginning
: Void  ( -- )  0 old  Homes BLANK ;

  \ spirit
: Voice  ( -- c-addr u )
  PAGE ." Say: "  0 new  DUP Homes ACCEPT ;

  \ subtlety
: Serpent  ( -- )
  0 2 AT-XY  ." Press a key for knowledge."  KEY DROP
  0 2 AT-XY  ." Press space to re-start, Esc to escape life." ;

  \ the primal state
: Innocence  ( -- )
  Homes 0 DO  I new C@  Alive /  I Neighbors+!  LOOP ;

  \ children become parents
: Passes  ( -- )  0 new  0 old  Homes  CMOVE ;

-->

( life )

  \ a garden
: Paradise  ( c-addr u -- )
  >R  How-Deep How-Wide *  How-Deep 2 MOD 0=  How-Wide AND -
  R@  -  2/  old
  R>  CMOVE
  0 old  Homes 0
  DO  COUNT BL <>
      DUP IF  Soul I Home  THEN  Alive AND  I new C!
  LOOP  DROP  Serpent Innocence Passes ;

-->

( life )

: Creation  ( -- )  Void Voice Paradise ;

  \ the human element

100 CONSTANT Ideas
: Dreams  ( -- )  Ideas MS ;

100 CONSTANT Images
: Meditation  ( -- )  Images MS ;

  \ free will
: Action  ( -- c )
  KEY? DUP
  IF  DROP KEY  DUP BL = IF  Creation  THEN  THEN ;

  \ environmental dependence
7 CONSTANT Escape

  \ history
: Goes-On  ( -- )
  BEGIN  Everything Passes  Dreams Action Meditation
         Escape = UNTIL ;

  \ a vision
: Life  ( -- )  Creation Goes-On ;

  \ Life

  \ vim: filetype=soloforth
  \ game.pong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604242200

  \ -----------------------------------------------------------
  \ Description

  \ The Pong game.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on code included in IsForth (version 1.23v):
  \
  \ pong.f
  \ Written june 2002 by Robert Oestling
  \ <robost at telia dot com>
  \ Tested with IsForth, http://isforth.clss.net/
  \
  \ Ported to IsForth by Mark Manning, 2012.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-09: First working version.
  \
  \ 2015-11-11: Improve with delay counters and Z80 halts.
  \
  \ 2016-04-23: Improve file header. Add frames to the ball
  \ graphic. Adapt to new version of `g-emit-0udg`.
  \
  \ 2016-04-24: Compact the UDG definitions with `0udg[`.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- bounce effect
  \ XXX TODO -- sound
  \ XXX TODO -- turnkey to tape
  \ XXX TODO -- change the rotation of the ball after bounce
  \ XXX TODO -- random bounce angle

( pong )

  \ XXX TODO slow the rackets

need columns  need rows  need 0udg[  need rnd  need ??
3 constant /kk  need pressed?

need cvariable  need 2/  need pixel-addr
need g-emit-0udg  need c!toggle-bits  need g-at-xy

0 cconstant black  7 cconstant white

8 cconstant ball-delay0
  \ Counter: Times the ball is not moved in the main loop.

variable ball-delay

4 cconstant racket-size

: brighty  ( n1 -- n2 )  %1000000 or  ;
: paper-color  ( n1 -- n2 )  8 *  ;

white paper-color brighty cconstant racket-color

22528 constant top-line-attr
  \ address of the top left screen attribute
23264 constant bottom-line-attr
  \ address of the bottom left screen attribute

code sync  ( -- )  78 c,  jpnext  end-code
  \ Z80 halt

-->

( pong )

  \ Key constant are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant left1-key   '1' cconstant left1-char
$02 $F7FE 2constant right1-key  '2' cconstant right1-char
  \ Player 1 keys.

$10 $EFFE 2constant left2-key   '6' cconstant left2-char
$08 $EFFE 2constant right2-key  '7' cconstant right2-char
  \ Player 2 keys.

variable x  variable y
  \ Coordinates of the ball.

cvariable direction
  \ Direction of ball.
  \ Bit 0: 1 = down, 0 = up.
  \ Bit 1: 1 = right, 0 = left.

variable points1  variable points2
  \ Player points.

variable racket1-x  columns racket-size - 2/  racket1-x !
  \ Top racket x coordinate.

variable racket2-x  racket1-x @ racket2-x !
  \ Bottom racket x coordinate.

0 cconstant racket1-y
  \ Top racket y coordinate.

rows 1- cconstant racket2-y
  \ Bottom racket y coordinate.

-->

( pong )

0 0udg[

00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||
01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
11111011 | 11111111 | 11111111 | 11111111 | 11111111 ||
11111101 | 11111101 | 11111111 | 11111111 | 11111111 ||
11111111 | 11111101 | 11111101 | 11111111 | 11111111 ||
11111111 | 11111111 | 11111011 | 11110011 | 11100111 ||
01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||]

-->

( pong )

5 0udg[

00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||
01111110 | 01111110 | 01111110 | 01111110 | 01011110 ||
11111111 | 11111111 | 11111111 | 10111111 | 10111111 ||
11111111 | 11111111 | 10111111 | 10111111 | 11111111 ||
11111111 | 10111111 | 10111111 | 11111111 | 11111111 ||
11001111 | 11011111 | 11111111 | 11111111 | 11111111 ||
01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||]

-->

( pong )

10 0udg[

00111100 | 00111100 | 00111100 ||
01001110 | 01100110 | 01110110 ||
11111111 | 11111111 | 11111011 ||
11111111 | 11111111 | 11111111 ||
11111111 | 11111111 | 11111111 ||
11111111 | 11111111 | 11111111 ||
01111110 | 01111110 | 01111110 ||
00111100 | 00111100 | 00111100 ||]

-->

( pong )

 0 constant first-ball-frame
12 constant last-ball-frame

variable ball-frame  first-ball-frame ball-frame !
  \ UDG number (0..127) of the current frame of the ball
  \ graphic.

: ball  ( -- n )  ball-frame @  ;
  \ Return the UDG number _n_ (0..127) of the current frame
  \ of the ball graphic.

: last-ball-frame?  ( -- f )  ball last-ball-frame =  ;
  \ Is the current frame of the ball graphic the last one?

: next-ball-frame  ( -- )
  last-ball-frame? if     first-ball-frame ball-frame !
                   else   1 ball-frame +!  then  ;
  \ Update the current frame of the ball graphic.

: ball-xy  ( -- x y )  x @ y @  ;

: at-ball  ( -- )  ball-xy g-at-xy  ;

: show-ball  ( -- )  at-ball ball sync g-emit-0udg  ;

: erase-ball  ( -- )  at-ball ball sync g-emit-0udg  ;

-->

( pong )

: restore-screen  ( -- )  default-colors page  ;

: init-screen  ( -- )  restore-screen white ink  ;

: (border)  ( a -- )
  columns [ white paper-color ] literal sync fill  ;

: top-border  ( -- )  top-line-attr (border)  ;

: bottom-border  ( -- )  bottom-line-attr (border)  ;

-->

( pong )

: show-racket  ( a -- )  racket-size racket-color sync fill  ;

: show-racket1  ( -- )
  top-line-attr dup (border) racket1-x @ + show-racket  ;

: show-racket2  ( -- )
  bottom-line-attr dup (border) racket2-x @ + show-racket  ;

: show-rackets  ( -- )  show-racket1 show-racket2  ;

: racket-initial-x  ( -- n )
  columns 2/ [ racket-size 2/ ] literal -  ;

: reset-rackets  ( -- )
  racket-initial-x dup racket1-x ! racket2-x !  ;

-->

( pong )

: erase-racket  ( a1 a2 -- )  @ + racket-size erase  ;
  \ Erase a racket.
  \ a1 = address of the first screen attribute on the row
  \ a2 = variable that holds the racket x coordinate

: erase-racket1  ( -- )
  top-line-attr racket1-x erase-racket  ;
  \ Erase racket of player 1.

: erase-racket2  ( -- )
  bottom-line-attr racket2-x erase-racket  ;
  \ Erase racket of player 2.

-->

( pong )

: (print-points)  ( n y -- )
  0 swap at-xy s>d <# # # # #>
  black ink sync type white ink  ;
  \ Print the points of a player.

: print-points1  ( -- )
  points1 @ racket1-y (print-points) show-racket1  ;
  \ Print the points of player 1.

: print-points2  ( -- )
  points2 @ racket2-y (print-points) show-racket2  ;
  \ Print the points of player 2.

: print-points  ( -- )  print-points1 print-points2  ;
  \ Print the points of both players.

: change-x  ( -- )  %10 direction c!toggle-bits  ;
  \ Change the x direction of the ball.

: change-y  ( -- )  %01 direction c!toggle-bits  ;
  \ Change the y direction of the ball.

: faster  ( -- )
  exit  ;  \ XXX OLD
  \ speed @ 40 > if  speed @ dup 20 / - speed !   then  ;
  \ If the delay is more than 40 ms, reduce it with 5%.

-->

( pong )

: ball-moving-right?  ( -- 0f )  direction c@ %10 and  ;
: ball-moving-down?  ( -- 0f )  direction c@ %01 and  ;
  \ : ball-at-right?  ( -- f )  x @ columns 1- =  ;
: ball-at-right?  ( -- f )  x @ 247 >  ;
: ball-at-left?  ( -- f )  x @ 1 <  ;
  \ : ball-at-bottom?  ( -- f )  y @ rows 2- =  ;
: ball-at-bottom?  ( -- f )  y @ 16 <  ;
  \ : ball-at-top?  ( -- f )  y @ 1 =  ;
: ball-at-top?  ( -- f )  y @ 182 >  ;

: move-ball-x  ( -- )
  ball-moving-right?
  if
    \ 0 2 at-xy ." right" \ XXX INFORMER
    ball-at-right?  if  change-x  then  1
  else
    \ 0 2 at-xy ." left " \ XXX INFORMER
    ball-at-left?   if  change-x  then  -1
  then  x +!  ;

-->

( pong )

: reset-ball  ( -- )
  128 x !  95 y !  rnd %11 and direction c!  ;
  \ Reset the ball position and direction.

: ready  ( -- )  reset-rackets reset-ball  ;

: score-player1  ( -- )  1 points1 +! print-points1  ;
  \ Increase player 1's points by one.

: score-player2  ( -- )  1 points2 +! print-points2  ;
  \ Increase player 2's points by one.

[defined] 8* ?\ : 8*  ( n1 -- n2 )  2* 2* 2*  ;

: hit-racket1?  ( -- f )
  x @ racket1-x @ 8* 1- >
  x @ racket1-x @ 8* racket-size 8* + <  and  ;
  \ Is racket1 hit by the ball?
  \ Is racket1-x <= x < racket1-x + racket-size?

: hit-racket2?  ( -- f )
  x @ racket2-x @ 8* 1- >
  x @ racket2-x @ 8* racket-size 8* + <  and  ;
  \ Is racket2 hit by the ball?
  \ Is racket2-x <= x < racket2-x + racket-size?

  \ : hit-racket?  ( a -- f )
  \   \ XXX NEW -- alternative
  \   \ XXX TODO try
  \   \ a = address that holds the x coordinate of a racket
  \   @ 8* x @ swap  ( ball-x pad-x )
  \   2dup 1- > >r
  \   racket-size 8* + <  r> and  ;

-->

( pong )

: possible-top-hit  ( -- )
  hit-racket2? if change-y  else  score-player1 ready  then  ;

: move-ball-down  ( -- )
  ball-at-bottom? if  possible-top-hit  else  -1 y +!  then  ;

: possible-bottom-hit  ( -- )
  hit-racket1? if  change-y  else  score-player2 ready  then  ;

: move-ball-up  ( -- )
  ball-at-top? if  possible-bottom-hit  else  1 y +!  then  ;

: move-ball-y  ( -- )
  ball-moving-down?
  if  move-ball-down  else  move-ball-up  then  ;

8 cconstant racket-delay0
  \ Counter: Times the rackets are not moved in the main loop.
variable racket1-delay
variable racket2-delay

-->

( pong )

: ?move-ball  ( -- )
  -1 ball-delay +!  ball-delay @ if  unnest  exit  then
  ball-delay0 ball-delay !  ;
  \ Update the delay of the ball.
  \ If the ball must not be moved, exit from the calling word.

: move-ball  ( -- )
  ?move-ball erase-ball move-ball-x move-ball-y
             next-ball-frame show-ball  ;
  \ Move the ball.

: frame  ( -- )  white border  top-border bottom-border  ;
  \ Draw the frame of the arena.

: arena-line  ( -- )
  [ 0 96 pixel-addr nip ] literal columns %10101010 fill
  [ 0 95 pixel-addr nip ] literal columns %01010101 fill  ;
  \ Draw the line of the arena.

: arena  ( -- )
  cls  frame arena-line show-rackets print-points show-ball  ;
  \ Draw the arena.

-->

( pong )

: ?move-racket1  ( -- )
  -1 racket1-delay +!  racket1-delay @ if  unnest exit  then
  racket-delay0 racket1-delay !  ;

: (move-racket1)  ( 1|-1 -- )  racket1-x +!  show-racket1  ;

: move-racket1-left  ( -- )
  ?move-racket1
  racket1-x @ 0= ?exit
  -1 (move-racket1)  ;

: move-racket1-right  ( -- )
  ?move-racket1
  racket1-x @ racket-size + columns = ?exit
  1 (move-racket1)  ;

-->

( pong )

: ?move-racket2  ( -- )
  -1 racket2-delay +!  racket2-delay @ if  unnest exit  then
  racket-delay0 racket2-delay !  ;

: (move-racket2)  ( 1|-1 -- )  racket2-x +!  show-racket2  ;

: move-racket2-left  ( -- )
  ?move-racket2
  racket2-x @ 0= ?exit
  -1 (move-racket2)  ;

: move-racket2-right  ( -- )
  ?move-racket2
  racket2-x @ racket-size + columns = ?exit
  1 (move-racket2)  ;

-->

( pong )

: reset-points  ( -- )  points1 off  points2 off  ;

: init-game  ( -- )
  init-screen reset-points
  racket-delay0  dup racket1-delay !  racket2-delay !
  ball-delay0 ball-delay ! ready  ;

: quit-game  ( -- )
  restore-screen  ." Player 1 score: " points1 ? cr
                  ." Player 2 score: " points2 ?  quit  ;

: keypress  ( key -- )
  left1-key     pressed? ?? move-racket1-left
  right1-key    pressed? ?? move-racket1-right
  left2-key     pressed? ?? move-racket2-left
  right2-key    pressed? ?? move-racket2-right
              break-key? ?? quit-game  ;  -->

( pong )

: show-player-key  ( c ca len -- )
  space rot emit ."  = " type cr  ;

: show-player-keys  ( c1 c2 -- )
  s" left" show-player-key  s" right" show-player-key  ;

: show-game-keys  ( -- )
  ." Player 1:" cr right1-char left1-char show-player-keys
  ." Player 2:" cr right2-char left2-char show-player-keys
  ." Break (Shift+Space) = quit"  ;

-->

( pong )

: show-credits  ( -- )

  \  <------------------------------>
  ." Pong" cr cr
  ." Original code by:" cr
  ."   Robert Oestling, 2002" cr
  ." Ported to IsForth by:" cr
  ."   Mark Manning, 2012" cr
  ." Rewritten for Solo Forth by:" cr
  ."   Marcos Cruz" cr
  ."   (programandala.net), 2015," cr
  ."   2016." cr  ;
  \  <------------------------------>

: press-any-key  ( -- )
  \  <------------------------------>
  ." Press any key to start the game." key drop  ;

: welcome  ( -- )
  page show-credits cr show-game-keys cr cr press-any-key  ;

-->

( pong )

: pong  ( -- )
  init-game welcome page arena
  begin  move-ball
    \ begin key? until key drop  \ XXX TMP -- for debugging
  keypress  again  ;

( pong-test )

  \ XXX TMP -- for debugging

: pong-test  ( -- )
  begin
  last-ball-frame 1+ 128 + first-ball-frame 128 + ?do
    home i emit  key drop
  loop
  break-key? until  ;

  \ vim: filetype=soloforth
  \ game.siderator_2.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201608051851

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Siderator 2.

  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2009, 2010, 2013, 2015,
  \ 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-02: Start, with the code of the Jupiter ACE
  \ version: http://programandala.net/en.program.siderator.html
  \
  \ 2016-05-02: Compact two blocks to save space in the
  \ library.
  \
  \ 2016-05-18: Need `vocabulary`, which has been moved to the
  \ library.
  \
  \ 2016-06-01: Replace `char` with char notation.
  \
  \ 2016-08-05: Compact the code, but no block is saved. Add
  \ missing `need inverse`.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- less stars!
  \ XXX FIXME -- The craft's autodestruction creates a new star.
  \ XXX FIXME -- 2016-08-05: now stars appear at the middle of
  \ the screen

( siderator )

only forth definitions  decimal

need random  need randomize  need udg:  need inkey
need between  need ocr  need frames@  need inverse
need j  need between  need rows  need last-column
need last-row  need vocabulary

vocabulary siderator
also siderator definitions

  \ Game variables and constants:

variable x          variable speed
variable parsecs    variable record  record off

999 constant max-speed
'5' constant left-key  '8' constant right-key

  \ System variables and addresses:

8192 constant 'screen \ XXX OLD

  \ Common words:

: pause  ( -- )  begin  inkey  until  ;  -->

( siderator )

  \ Graphics

15360 constant charset  \ ROM charset

: char>a  ( c -- a )  8 * charset +  ;

: udg>a  ( c -- a )  128 - 8 * os-udg @ +  ;

: char>udg  ( c0 c1 -- )  swap char>a swap udg>a 8 cmove  ;

128 constant star0-udg  '*' star0-udg char>udg

%00011000
%00001000
%00011000
%00010000
%00011000
%00001000
%00011000
%00010000 129 udg: star1-udg  -->

( siderator )

130 constant star2-udg
'|' star2-udg char>udg

%00001000
%00000000
%00001000
%00000000
%00001000
%00000000
%00001000
%00000000 131 udg: star3-udg  -->

( siderator )

%10000001
%10000001
%11000011
%11100111
%11111111
%01100110
%00111100
%00011000 132 udg: craft-udg  -->

( siderator )

  \ Keyboard

0 constant first-column

: pressed?  ( c -- f )  inkey =  ;

: left  ( col -- col' )
  left-key pressed? + first-column max  ;

: right  ( col -- col' )
  right-key pressed? - last-column min  ;

: rudder  ( -- )  x @ right left x !  ;  -->

( siderator )

  \ Stars

4 constant #stars

: star-coords  ( -- gx gy )  last-column last-row  ;

: .star  ( c -- )
  [ last-column 1+ ] literal random last-row at-xy
  1 bright emit 0 bright  ;

: stars/speed  ( -- n )  speed @ #stars 1- max-speed */ 1+  ;

: scroll  ( -- )  star-coords at-xy cr cr  ;

: .stars  ( -- )
  stars/speed dup [ star0-udg 1- ] literal + swap 0
  do  dup .star  loop  drop  ;

: star=  ( c -- f )  star0-udg star3-udg between  ;

: star<>  ( c -- f )  star= 0=  ;  -->

( siderator )

  \ Craft

rows 2 / constant craft-y

: craft-coords  ( -- y x )  x @ craft-y  ;

: at-craft  ( -- )  craft-coords at-xy  ;

: -craft  ( -- )  at-craft space  ;

: .craft  ( -- )  at-craft craft-udg 5 ink emit 7 ink  ;  -->

( siderator )

  \ Speed, parsecs, record

: .datum  ( u -- )  s>d <# # # # #> type space  ;

: delay  ( -- )  max-speed speed @ - 2 / 0  do  loop  ;

: .speed  ( -- )  ." Speed:" speed @ .datum  ;

: +speed  ( u1 -- u2 )
  dup 10 / 1 max  parsecs @ 4 mod 0= abs *  + max-speed min  ;

: faster  ( -- )  speed @ +speed speed !  ;

: .parsecs  ( -- )  ." Parsecs:" parsecs @ .datum  ;

: farther  ( -- )  1 parsecs +!  ;

: .record  ( -- )  ." Record:" record @ .datum  ;

: .info  ( -- )  home .speed .parsecs .record  ;

-->

( siderator )

  \ End

: blast-delay  ( -- )  32 0  do  loop  ;

: (blast)  ( -- )
  .craft blast-delay at-craft star0-udg emit blast-delay  ;

: blast  ( -- )  256 0  do  (blast)  loop  ;

: halt  ( -- )
  32 0  do  24 0 do
    i j ocr star= if  i j at-xy  star0-udg emit  then
  loop  loop  ;  -->
  \ XXX TODO

( siderator )

: safe?  ( -- f )  craft-coords swap ocr star<>  ;

: continue?  ( -- f )  safe? break-key? 0= and  ;

: new-record  ( -- )
  parsecs @ record @ >  if  parsecs @ record !  then  ;

: game-over  ( -- )
  blast halt  11 dup at-xy ." GAME OVER"
  new-record .info first-column last-row at-xy
  default-colors  ;

-->

( siderator )

  \ Instructions

: about  ( -- )
  cr ." Siderator 2: Jugdement Day"  cr
  cr ." By programandala.net"
  cr ." Version: 0.1.0+20160325"  ;

: objective  ( -- )
  cr ." Your objective is to travel as"
  cr ." much parsecs as possible"
  cr ." while dodging the stars."
  cr ." Anyway you're supposed to die"
  cr ." before the 1000th parsec"
  cr ." because four digits would ruin"
  cr ." the score panel."  ;  -->

( siderator )

  \ Instructions

: keys  ( -- )  cr ." Rudder keys: "
                left-key emit space right-key emit
                cr ." Autodestruction key: Break"  ;

: instructions  ( -- )  objective cr keys  ;

: wait  ( -- )  cr cr ." Press any key to start." pause  ;  -->

( siderator )

  \ Init

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;

: init-screen  ( -- )
  init-colors cls about cr instructions wait cls  ;

: 4+-  ( n1 -- n2 )  9 random 4 - +  ;

: init  ( -- )
  frames@ s>d randomize  udg-ocr
  init-screen  15 4+- x ! parsecs off  speed off  ;

: run ( -- )
  init  begin  -craft scroll  faster farther .info  continue?
        while  rudder .craft .stars delay  repeat  game-over  ;

  \ vim: filetype=soloforth
  \ game.tetris_for_terminals.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605181525

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Tetris for Terminals.
  \
  \ An improved port of a game written in Forth-94 by Dirk Uwe
  \ Zoller in 1994.

  \ -----------------------------------------------------------
  \ Authors

  \ Dirk Uwe Zoller, 1994-05-05.  Look&feel stolen from Mike
  \ Taylor's "Tetris for terminals".
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ tt.pfe  Tetris for terminals, redone in ANSI-Forth.
  \
  \ Written 05Apr94 by Dirk Uwe Zoller, e-mail duz AT roxi DOT
  \ rz DOT fht-mannheim DOT de.
  \
  \ Look&feel stolen from Mike Taylor's "TETRIS FOR TERMINALS".
  \
  \ Please copy and share this program, modify it for your
  \ system and improve it as you like. But don't remove this
  \ notice.
  \
  \ Thank you.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.
  \
  \ 2016-05-18: Need `vocabulary`, which has been moved to the
  \ library.

.( tt )

only forth also definitions

  [undefined] forget-tt ?\ forget-tt
  \ XXX TODO
  \ marker forget-tt

need random  need j  need >=  need <=  need 2/  need value
need d<>  need d=  need case  need ms  need frames@  need yes?
need begin-stringtable  need positional-case:  need tab
need >body  need vocabulary

vocabulary tt  also tt definitions  decimal

bl bl 2constant empty
  \ An empty position of the pit.

variable wiping
  \ If true, wipe brick, else draw brick.

2 constant col0  0 constant row0
  \ Position of the pit, not including the frame.

14 constant wide  22 constant deep
  \ Size of pit, not including the frame.
  \ Wide in stones; deep in rows.

-->

.( tt )

  \ c1 = left key
  \ c2 = right key
  \ c3 = rotate key
  \ c4 = drop key
  \ c5 = pause key
  \ c6 = quit key

7 constant edit-char

: actual-cursor-keys  ( -- c1 c2 c3 c4 c5 c6 )
  8 9 11 10 bl edit-char  ;
  \ Actual cursor keys, useful for PC keyboards with cursor
  \ keys

: spanish-dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  'C' 'H' '.' 'A' bl edit-char  ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  'C' 'R' ''' 'A' bl edit-char  ;

: qwerty-keys  ( -- c1 c2 c3 c4 c5 c6 )
  'O' 'P' 'Q' 'A' bl edit-char ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: cursor-digits-keys  ( -- c1 c2 c3 c4 c5 c6 )
  '5' '8' '7' '6' bl edit-char  ;
  \ Cursor keys, actually the digits keys they are associated with.

: sinclair1-keys  ( -- c1 c2 c3 c4 c5 c6 )
  '1' '2' '3' '4'  bl edit-char  ;
  \ Sinclair 1 joystick.

: sinclair2-keys  ( -- c1 c2 c3 c4 c5 c6 )
  '6' '7' '8' '9'  bl edit-char  ;  -->
  \ Sinclair 2 joystick.

.( tt )

6 constant max-keyset
  \ Maximum number of the keyset (first is zero).

variable keyset
  \ Number of the current keyset.

positional-case: keyset>keys  ( n -- c1 c2 c3 c4 c5 c6 )
  actual-cursor-keys
  dvorak-keys
  spanish-dvorak-keys
  sinclair1-keys
  sinclair2-keys
  cursor-digits-keys
  qwerty-keys  ;

-->

.( tt )

begin-stringtable keyset>name  ( n -- ca len )
  s" Cursor        " s,
  s" Dvorak        " s,
  s" Spanish Dvorak" s,
  s" Sinclair 1    " s,
  s" Sinclair 2    " s,
  s" Cursor digits " s,
  s" QWERTY        " s,
end-stringtable

: keyset-name  ( -- ca len )  keyset @ keyset>name  ;

-->

.( tt )

0 value quit-key  0 value pause-key  0 value drop-key
0 value rot-key   0 value right-key  0 value left-key

: keys!  ( c1 c2 c3 c4 c5 c6 -- )
  to quit-key to pause-key to drop-key
  to rot-key to right-key to left-key   ;

: set-keyset   ( n -- )  dup keyset ! keyset>keys keys!  ;
  \ Set the keyset layout number _n_.

: next-keyset  ( -- n )  keyset @ 1+ dup max-keyset > 0= and  ;
  \ Calculate the next keyset.

: change-keyset  ( -- )  next-keyset set-keyset  ;
  \ Set the next keyset.

0 set-keyset  \ default

-->

.( tt )

variable score
variable pieces
variable levels
variable delay  \ in ms

variable brick-row  variable brick-col
  \ Position of the current brick.

: 2c@  ( a -- c1 c2 )  dup 1+ c@ swap c@  ;
  \ Fetch a pair of characters.

: 2c!  ( c1 c2 a -- )  dup >r c! r> 1+ c!  ;
  \ Store a pair of characters.

: 2emit  ( c1 c2 -- )   emit emit  ;

: position  ( row col -- )
  2* col0 + swap row0 + at-xy  ;
  \ Cursor to the position in the pit.

: stone  ( c1 c2 -- )
  wiping @ if  2drop 2 spaces  else  2emit  then  ;
  \ Draw or undraw these two characters.

-->

.( tt )

wide deep * 2 * constant /pit
  \ Size of the pit in memory.

create 'pit /pit allot
  \ The pit.

: pit  ( col row -- a )  'pit rot wide * rot + 2* +  ;
  \ Convert pit coords to the correspondent address.

: empty-pit  ( -- )  'pit /pit blank  ;
  \ Empty the pit.

: draw-bottom  ( -- )
  deep -1 position  '+' dup stone
  wide 0 do  '=' dup stone  loop
  '+' dup stone  ;
  \ Draw the bottom of the pit.

: draw-frame  ( -- )
  deep 0 do   i -1   position '|' dup stone
              i wide position '|' dup stone
  loop  draw-bottom  ;  -->
  \ Draw the frame of the pit.

.( tt )

: bottom-msg  ( addr cnt -- )
  deep over 2/ wide swap - 2/ position 1 flash type 0 flash  ;
  \ Output a message at the bottom of the pit.

: draw-line  ( line -- )
  dup 0 position  wide 0 do  dup i pit 2c@ 2emit  loop  drop  ;
  \ Draw the contents of a pit line.

: draw-pit  ( -- )  deep 0 do  i draw-line  loop  ;
  \ Draw the contents of the pit.

begin-stringtable c>name  ( c -- ca len )
  s" Edit" s, s" Left" s, s" Right" s, s" Down" s, s" Up" s,
end-stringtable
  \ Names of the control chars 7..11.

: control-char-name  ( c -- ca len )  7 - c>name  ;
  \ Name of a control char (7..11).

: show-key  ( c -- )
  2 spaces  dup bl = if  drop ." Space"  else
            dup bl < if    control-char-name type
                     else  emit  then
            then  tab  ;
  \ Display the name of char _c_.
  \ Control chars are not supported except cursor keys and edit.

-->

.( tt )

: show-keys  ( -- )
  \ display the game keys
  \  <------------------------------>
  ." Keys: " keyset-name type cr cr
  left-key     show-key ."  Move left" cr
  right-key    show-key ."  Move right" cr
  rot-key      show-key ."  Rotate" cr
  drop-key     show-key ."  Drop" cr
  pause-key    show-key ."  Pause" cr
  quit-key     show-key ."  Quit"  ;
  \  <------------------------------>

-->

.( tt )

: (show-help)  ( -- )
  0 0 at-xy
  \  <------------------------------>
  ." TT (Tetris for Terminals)" cr cr
  ." Original ANS Forth code written" cr
  ." by Dirk Uwe Zoller, 1994." cr
  ." Ported to Solo Forth" cr
  ." by Marcos Cruz, 2015." cr cr
  show-keys  ;
  \ Display some explanations.

: show-help  ( -- )
  page
  begin  (show-help) cr cr
          \  <------------------------------>
         ." Press Space to change the keys" cr
         ." or any other key to start."
         key bl =
  while  change-keyset  repeat  ;  -->
  \ Display some explanations and change the keyset.

.( tt )

23 constant score-row

: at-score  ( col -- )  score-row at-xy  ;
  \ Set cursor at column _col_ of the score row.

: score-labels ( -- )
   0 at-score ." Score:"
  10 at-score ." Pieces:"
  21 at-score ." Levels:"  ;
  \ Display the labels of the score.

: .score  ( a col -- )  at-score @ 3 .r  ;
  \ Display the contents of the score variable _a_ at column
  \ _col_.

: update-score  ( -- )
  score 6 .score  pieces 17 .score  levels 28 .score  ;
  \ Display the current score.

: arena  ( --)
  draw-frame draw-pit score-labels update-score  ;
  \ Redraw everything on screen.

-->

.( tt ) blk @ . key drop

.s key drop

: brick:  ( ca1 len1 ca2 len2 ca3 len3 ca4 len4 "name" -- )
  create  4 0 do
            0 ?do  dup i chars + c@ c,  loop drop
          loop
  does>  ( x1 x2 -- a ) ( pfa )  rot 4 * rot + 2* +  ;
  \ Define the shape of a brick.
  \ Every brick has 4 rows, defined by 4 strings.
  \ XXX TODO stack notation of `does>`

s"         " 2constant empty-brick-row .s key drop

  \ XXX FIXME -- crash! -- never reaches the next `key drop`

empty-brick-row
s"   ##    "
s" ######  "  empty-brick-row  brick: brick1  .s key drop

empty-brick-row 2dup
s" <><><><>"  empty-brick-row  brick: brick2  .s key drop

empty-brick-row
s"   {}    "
s"   {}{}{}"  empty-brick-row  brick: brick3  .s key drop -->

.( tt ) blk @ . key drop

empty-brick-row
s"     ()  "
s" ()()()  "  empty-brick-row brick: brick4

empty-brick-row
s"   [][]  "
s"   [][]  "  empty-brick-row brick: brick5

empty-brick-row
s"   @@@@  "
s" @@@@    "  empty-brick-row brick: brick6

empty-brick-row
s" %%%%    "
s"   %%%%  "  empty-brick-row brick: brick7

empty-brick-row 2dup 2dup 2dup brick: brick
  \ brick actually in use

empty-brick-row 2dup 2dup 2dup brick: scratch  -->

.( tt ) blk @ . key drop

create bricks  ' brick1 ,  ' brick2 ,  ' brick3 ,  ' brick4 ,
               ' brick5 ,  ' brick6 ,  ' brick7 ,

create brick-value 1 c, 2 c, 3 c, 3 c, 4 c, 5 c, 5 c,

32 constant /brick
  \ Bytes per brick shape.

: is-brick  ( brick -- )
  >body [ ' brick >body ] literal /brick cmove  ;
  \ Activate a shape of brick.

: new-brick  ( -- )
  1 pieces +!  7 random
  bricks over cells + @ is-brick
  brick-value swap chars + c@ score +!  ;
  \ Select a new brick by random, count it.

: rotate-left  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  3 i - j scratch 2c!
  loop loop
  ['] scratch is-brick  ;  -->
  \ Rotate the current brick left.

.( tt ) blk @ . key drop


: rotate-right  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  i 3 j - scratch 2c!
  loop loop
  ['] scratch is-brick  ;
  \ Rotate the current brick right.

: draw-brick  ( row col -- )
  4 0 do 4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i +  position
        j i brick 2c@  stone
    then
  loop loop  2drop  ;
  \ Draw the current brick at the given coords.

: show-brick  ( row col -- )  wiping off draw-brick  ;

: hide-brick  ( row col -- )  wiping on  draw-brick  ;

-->

.( tt ) blk @ . key drop

: put-brick  ( row col -- )
  4 0 do 4 0 do
      j i brick 2c@  empty d<>
      if  over j +  over i +  pit
          j i brick 2c@  rot 2c!
      then
  loop loop  2drop  ;
  \ Put the brick into the pit.

: remove-brick  ( row col -- )
  4 0 do  4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i + pit empty rot 2c!  then
  loop  loop  2drop  ;
  \ Remove the brick from that position.

-->

.( tt ) blk @ . key drop

: test-brick  ( row col -- f )
  4 0 do 4 0 do
    j i brick 2c@ empty d<>
    if  over j +  over i +
        over dup 0< swap deep >= or
        over dup 0< swap wide >= or
        2swap pit 2c@  empty d<>
        or or if  unloop unloop 2drop false  exit  then
    then
  loop loop  2drop true  ;
  \ Could the brick be there?

-->

.( tt ) blk @ . key drop


: move-brick  ( rows cols -- f )
  brick-row @ brick-col @ remove-brick
  swap brick-row @ + swap brick-col @ + 2dup test-brick
  if    brick-row @ brick-col @ hide-brick
        2dup brick-col ! brick-row !
        2dup show-brick put-brick  true
  else  2drop brick-row @ brick-col @ put-brick  false
  then  ;
  \ Try to move the brick.

-->

.( tt ) blk @ . key drop

: rotate-brick  ( f1 -- f2 )
  \ f1 = rotate right?, else rotate left
  \ f2 = success
  brick-row @ brick-col @ remove-brick
  dup if  rotate-right  else  rotate-left  then
  brick-row @ brick-col @ test-brick
  over if  rotate-left  else  rotate-right  then
  if  brick-row @ brick-col @ hide-brick
      if  rotate-right  else  rotate-left  then
      brick-row @ brick-col @ put-brick
      brick-row @ brick-col @ show-brick  true
  else  drop false  then  ;
  \ Rotate the current brick.

-->

.( tt ) blk @ . key drop

: insert-brick  ( row col -- f )
  2dup test-brick
  if  2dup brick-col ! brick-row !
      2dup put-brick  draw-brick  true
  else  false  then  ;
  \ Introduce a new brick.

: drop-brick  ( -- )  begin  1 0 move-brick 0=  until  ;
  \ Move brick down fast.

: move-line  ( from to -- )
    over 0 pit  over 0 pit  wide 2*  cmove  draw-line
    dup 0 pit  wide 2*  blank  draw-line  ;

: line-full?  ( line-no -- f )
    true  wide 0
    do  over i pit 2c@ empty d=
        if  drop false  leave  then
    loop nip  ;

-->

.( tt ) blk @ . key drop

: adjust-delay  ( -- )
  levels @
  dup  50 < if  100 over -  else
  dup 100 < if   62 over 4 / -  else
  dup 500 < if   31 over 16 / -  else  0  then then then
  delay !  drop  ;
  \ Make it faster with increasing level.

-->

.( tt ) blk @ . key drop

: new-level  ( -- )  1 levels +!  10 score +!  adjust-delay  ;

: remove-lines  ( -- )
  deep deep
  begin
    swap
    begin
      1- dup 0< if  2drop exit  then  dup line-full?
    while
      new-level
    repeat
    swap 1- 2dup <> if  2dup move-line  then
  again  ;

-->

.( tt ) blk @ . key drop

: interaction  ( -- f )
  case  key upper
    left-key      of  0 -1 move-brick drop  endof
    right-key     of  0  1 move-brick drop  endof
    rot-key       of  0 rotate-brick drop  endof
    drop-key      of  drop-brick  endof
    pause-key     of  S"  Paused " bottom-msg  key drop
                      draw-bottom  endof
    quit-key      of  false exit  endof
  endcase  true  ;

: initialize  ( -- )
  frames@ d>s randomize
  score off  pieces off  levels off  adjust-delay
  empty-pit page arena  ;
  \ Prepare for playing.

-->

.( tt ) blk @ . key drop

: play-game  ( -- )
  begin
    new-brick  -1 3 insert-brick
  while
    begin
      4 0 do
        delay @ ms key?
        if  interaction 0= if  unloop exit  then  then
      loop
      1 0 move-brick 0=
    until
    remove-lines  update-score  adjust-delay
  repeat  ;
  \ Play one tt game.

-->

.( tt ) blk @ . key drop

also forth definitions

: again?  ( -- f )  s"  Again? (Y/N) " bottom-msg yes?  ;

: start-message  ( -- )  ." Type RUN to start tt" cr  ;

: end-message  ( -- )  0 23 at-xy cr start-message  ;

: run  ( -- )
  show-help
  begin  initialize play-game again? 0=  until
  draw-bottom end-message  ;
  \ Play the tt game.

cr start-message

only forth definitions

  \ vim: filetype=soloforth
  \ game.toe.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The sample game Toe.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( toe )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-24: Changes.

  \ Credit:
  \
  \ Based on code from Leo Brodie's _Starting Forth_, ANSized
  \ by Benjamin Hoyt in 1997.

9 constant squares

1 constant player-x  2 constant player-o

create board  squares allot

: clear  ( -- )  board squares erase  ;  clear

: >square  ( square -- ca )  board +  ;
: square@  ( square -- c )  >square c@  ;
: square!  ( c square -- )  >square c!  ;

: bar  ( -- )  ." | "  ;
: dashes  ( -- )  cr  9 0 do  '-' emit  loop cr  ;

: .player-mark  ( player -- )
  player-x = if ." x " else ." o " then  ;

: .box-contents  ( n -- )
  ?dup if  .player-mark  else  2 spaces  then  ;

: .box  ( square -- )  square@  .box-contents  ;

-->

( toe )

: display  ( -- )
  home
  squares 0 do
    i if    i 3 mod  0= if  dashes  else  bar  then
      then  i .box
  loop  cr  ;

: limited  ( square -- square' )  0 max squares min  ;

: play  ( square player -- )  swap 1- limited square! ;

: x  ( square -- )  player-x play  display ;
: o  ( square -- )  player-o play  display ;

  \ vim: filetype=soloforth
  \ game.towers_of_hanoi.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605181526

  \ -----------------------------------------------------------
  \ Description

  \ Towers of Hanoi puzzle.

  \ -----------------------------------------------------------
  \ Authors

  \ Raul Deluth Miller, original algorithm, published on
  \ comp.lang.forth, 1994.

  \ Marcel Hendrix and Brad Eckert, published on
  \ comp.lang.forth, 2002-05-30.

  \ K. Myneni, modified for kForth., 2002-05-30.

  \ Marcos Cruz (programandala.net), version for Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Start.
  \
  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore. Updated the file headers.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( hanoi )

only forth definitions

need don't  need ms  need mode64  need alloted  need recurse
need vocabulary

vocabulary hanoi  also hanoi definitions

variable slowness  1000 slowness !
  \ ms delay between screen updates

3 constant pegs

create PegSPS  pegs cells allot
  \ pointers for three disk stacks

: PegSP     ( peg -- addr ) cells PegSPS + ;
: PUSH      ( c peg -- )    PegSP tuck @ c!  1 chars swap +! ;
: POP       ( peg -- c )    PegSP -1 chars over +!  @ c@ ;

create PegStacks  30 chars allot
  \ stack area for up to 10 disks

: PegStack  ( peg -- addr )   10 * PegStacks + ;

: clear-peg    ( peg -- )  dup PegStack  swap PegSP ! ;
: clear-pegs  ( -- )  pegs 0 do  i clear-peg  loop  ;

  \ : PegDepth  ( peg -- depth )  dup PegSP @  swap PegStack - ;
  \ XXX OLD not needed

-->

( hanoi )

: show-disk  ( level diameter peg -- )
  22 * 10 + over -  rot 10 swap - at-xy
  2* '*' emits ;

: show-peg   ( peg -- )
  dup >r PegStack
  BEGIN   r@ PegSP @ over <>
  WHILE   dup r@ PegStack - over c@  ( addr level diameter )
          r@ show-disk  char+
  REPEAT  drop r> drop ;

-->

( hanoi )

: maketab  ( n1..nn n -- XXX ) \ XXX TODO stack effect
  create
    dup alloted over 1- + swap 0
    2dup <> if    do  dup >r c! r> 1-  loop
            else  2drop
            then  drop
  does>  + c@ ;

#3 base !
00 02 01 12 00 10 21 20  #8 maketab TO!
00 21 12 20 00 02 10 01  #8 maketab FRO!
decimal

-->

( hanoi )

: finished  ( -- )  key drop 0 11 at-xy ." Stopped" cr abort  ;

: show-pegs  ( -- )
  page  pegs 0 do  i show-peg  loop  slowness @ ms
  key? if  finished  then ;

: move-ring  ( ring -- ring )
  dup to! 3 / pop  over fro! 3 mod push show-pegs ;

: tower ( depth direction -- depth direction )
  swap 1- swap over
  IF    to!  recurse  to! move-ring fro! recurse  fro!
  ELSE  move-ring
  THEN  swap 1+ swap ;

-->

( hanoi )

: run  ( depth -- )

  clear-pegs

  dup BEGIN ?dup WHILE 1- dup 0 push REPEAT
    \ stack up some disks

  show-pegs 1 tower 2drop
    \ move them

  0 11 at-xy ;

mode64 page
  \  <-------------------------->
  .( Towers of Hanoi) cr
  .( Type 'n run' to play where) cr
  .( 'n' is the number of disks.) cr
  \  <-------------------------->

  \ vim: filetype=soloforth
