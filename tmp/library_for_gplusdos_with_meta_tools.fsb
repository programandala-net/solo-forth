  \ 000.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Block 0 of the library, which by convention can not be
  \ loaded, and which is used only for credits and information.

( Solo Forth library )

\ http://programandala.net/en.program.solo_forth.html

  \ vim: filetype=soloforth
  \ 001.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111423

  \ -----------------------------------------------------------
  \ Description

  \ Block 1 of the library, which is used to load the user
  \ application. By default it loads block 2, which contains
  \ the `need` utility.

(  )

2 load

  \ XXX TMP -- for debugging `marker`
  \ need wdump  need save-voc-links

  \ XXX TMP -- for debugging `associative-list`
  \ need associative-list
  \ exit

  \ XXX TMP -- for debugging the floating point ROM
  \ implementation
  \ need f0 need .fs
  \ need f>s
  \ need ftuck
  \ need fmax  need fmin
  \ need --fp-rom--
  \ f1 f0 fpi2/ f1 f1
  \ need f=  need f<
  \ f1 f0 f1 f0 f1 f0
  \ 100 s>f  200 s>f  300 s>f

  \ XXX TMP -- for debugging the G+DOS support
  \ need plusd-in  need plusd-in,

  \ XXX TMP -- for debugging the tape support
  \ need write-tape-file
  \ : savescr 16384 6912 s" screen" write-tape-file  ;
  \ : savetxt s" TEXT" s" txt" write-tape-file  ;
  \ hex  ' (write-tape-file) u.

  \ XXX TMP --
  \ need 8-bit-random-pix-benchmarks  exit

  \ XXX TMP --
  \ need wordlist-words  need order
  \ need bench{  need indexer
  \ : iw  ( -- )  index-wordlist wordlist-words  ;

  \ vim: filetype=soloforth
  \ 002.need.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605080207

  \ -----------------------------------------------------------
  \ Description

  \ The `need` utility which manages the library dependencies.
  \ It must be at block 2 of the library.
  \
  \ The utility consists of words `need`, `needed`, `reneed`
  \ and `reneeded`. All of them are deferred words. Their
  \ default behaviour is set by `set-located-need`: locate the
  \ required word searching the blocks of the library.
  \
  \ An alternative faster behaviour is provided by the
  \ `indexer` tool, in other module.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06: First version, partly based on code from Afera.
  \
  \ 2015-06-25: Fix: `require` and `locate` needed to save the
  \ parsed words to the circular string buffer.
  \
  \ 2015-09-13: Rename `require` to `need`, and all related
  \ words accordingly.  The reason is `require` and `required`
  \ are standard words (in Forth-94 and Forth-2012), and should
  \ not be used for different purposes.
  \
  \ 2015-10-05: Fix `needed`. The trailing and leading spaces
  \ of the string, sometimes used to prevent name clashes, had
  \ to be removed before `undefined?`. `-leading` has to be
  \ moved to the kernel.
  \
  \ 2015-10-16: Add `[needed]`.  It allows selective
  \ compilation depending on the word specified by `need` or
  \ `needed`.  Improve `located`: now the string searched for
  \ is delimited with spaces. This prevents name clashes and
  \ makes it unnecessary to add the spaces explicitly in risky
  \ cases.
  \
  \ 2015-10-25: Improve `need` and `needed` a bit.
  \
  \ 2016-04-02: Factor `new-needed-word` from `needed`.  This
  \ change was needed for `indexer`.
  \
  \ 2016-04-03: Make `need` and related words deferred. Factor
  \ `new-needed-word` from `needed`. These changes were needed
  \ for `indexer`.
  \
  \ 2016-04-26: Improve `located`: when the user press the
  \ break key, throw exception #-28 ("user interrupt");
  \ formerly the ordinary #-268 ("required, but not located")
  \ was thrown by the calling word.
  \
  \ 2016-05-06: Make `from` and `locate` optional. Compact the
  \ blocks.
  \
  \ 2016-05-07: Improve documentation. Fix the word shown when
  \ `?locate` throws an error.
  \
  \ 2016-05-10: Fix a harmless bug: `locate-reneed` called the
  \ deferred `reneeded` instead of `locate-reneeded`.

( contains delimited located ?located )

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does string _ca1 len1_ contain string _ca2 len2_?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited  ( ca1 len1 -- ca2 len2 )
  \
  \ Add one leading space and one trailing space to string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
      contains if  2drop i unloop exit  then
      break-key? #-28 ?throw \ "user interrupt"
  loop  2drop 0  ;

  \ doc{
  \
  \ located  ( ca len -- block | 0 )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

2variable needed-word

-->

( ?located reneeded reneed needed-word [needed] [unneeded] )

: ?located  ( n -- )
  dup ?exit  needed-word 2@ parsed-name 2! #-268 throw  ;

  \ doc{
  \
  \ ?located ( n -- )
  \
  \ If _n_ is zero, throw an exception -268 ("required, but not
  \ located").
  \
  \ }doc

defer reneeded  ( ca len -- )

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Load the first block whose header contains the string _ca
  \ len_ (surrounded by spaces).  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneeded`.
  \
  \ }doc

: locate-reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ locate-reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

defer reneed  ( "name" -- )

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Load the first block whose header contains "name" (but
  \ surrounded by spaces).
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-reneed`.
  \
  \ }doc

: locate-reneed  ( "name" -- )
  parse-name save-string locate-reneeded  ;

  \ doc{
  \
  \ locate-reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name" (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: [needed]  ( "name" -- f )
  parse-name needed-word 2@ 2dup or
  if  compare 0= exit  then  2drop 2drop true  ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return true.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _true_, else return _false_.
  \
  \ }doc

: [unneeded]  ( "name" -- f )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- f )
  \
  \ Parse "name".  If there's no unresolved `need`, `needed`,
  \ `reneed` or `reneeded`, return false.  Otherwise, if "name"
  \ is the needed word specified by the last execution of
  \ `need` or `needed`, return _false_, else return _true_.
  \
  \ }doc

: new-needed-word  ( ca len -- ca' len' )
  -trailing -leading save-string 2dup needed-word 2!  ;

  \ doc{
  \
  \ new-needed-word  ( ca1 len -- ca2 len' )
  \
  \ Remove trailing and leading spaces from the word _ca1 len_,
  \ which is the parameter of the latest `need` `needed`,
  \ `reneed` or `reneeded`, store it in the circular string
  \ buffer and return it as _ca2 len'_ for further processing.
  \
  \ }doc

-->

( needed need )

defer needed  ( ca len -- )

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, load the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces).  If not found, throw an exception
  \ -268 ("required, but not located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-needed`.
  \
  \ }doc

: locate-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  locate-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ locate-needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header (but
  \ surrounded by spaces), and load it.  If not found, throw an
  \ exception -268 ("required, but not located").
  \
  \ This is the default behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

defer need  ( "name" -- )

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is a deferred word whose default behaviour is
  \ `locate-need`.
  \
  \ }doc

: locate-need  ( "name" -- )  parse-name locate-needed  ;

  \ doc{
  \
  \ locate-need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.  If
  \ not found, throw an exception -268 ("required, but not
  \ located").
  \
  \ This is the default behaviour of the deferred word `need`.
  \
  \ }doc

: set-located-need  ( -- )
  ['] locate-reneeded ['] reneeded  defer!
  ['] locate-reneed   ['] reneed    defer!
  ['] locate-need     ['] need      defer!
  ['] locate-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-located-need  ( -- )
  \
  \ Set the default behaviour of `need`, `needed`, `reneed` and
  \ `reneeded`: Use `locate` for searching the library.
  \
  \ The alternative, provided by the optional `indexer` tool,
  \ is set by `set-indexed-need`.
  \
  \ }doc

set-located-need

blk @ 1+ dup default-first-locatable !  first-locatable !

( locate from need-here )

[unneeded] locate [unneeded] from and
?\ : locate  ( "name" -- n )  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- n )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return zero.  The search is case-sensitive.
  \
  \ }doc

[unneeded] from
?\ : from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268
  \ ("required, but not located").
  \
  \ This word is intended to prevent undesired name clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker.
  \
  \ Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures==  need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

[unneeded] need-here ?exit

: need-here  ( "name" -- )
  parse-name
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  blk @ load  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ need-here  ( "name" -- )
  \
  \ If "name" is not a word found in the current search order,
  \ load the current block.
  \
  \ This is a faster alternative to `need`, when the needed
  \ word is in the same block, and conditional compilation is
  \ used with `?\`, `?(` or `[if]`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ assembler.macro.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604111350

  \ -----------------------------------------------------------
  \ Description

  \ `macro` and `endm`, compatible with any assembler.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2016-04-11: Extracted from the assemblers `z80-asm` and
  \ `z80-asm,`. The code was identical in both of them and it
  \ can be useful without an assembler.

( macro )

need get-order

get-order get-current

only forth definitions  also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

set-current  set-order

  \ vim: filetype=soloforth

  \ assembler.tools.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604091523

  \ -----------------------------------------------------------
  \ Description

  \ Z80 assembler tools, independent from the actual assembler.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( << >> )

  \ For dumping assembled code to screen.

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

  \ vim: filetype=soloforth

  \ assembler.z80-asm-comma.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.

  \ Last modified: 201605092127

  \ -----------------------------------------------------------
  \ Description

  \ A alternative Z80 assembler, called `z80-asm,`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015-12-25: First changes:
  \
  \ 1. "," suffixes in Z80 instructions; 2. one single set of
  \ conditions; 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module.  Fixed `execute-hl`,
  \ then renamed it and `call-xt` with a trailing comma, to
  \ avoid loading them instead of the versions written for the
  \ first assembler.
  \
  \ 2016-05-08:
  \ - Rename conditions to the original names plus "?".
  \ - Rename `|mark` to `>amark`.
  \ - Rename `|resolve` to `>aresolve`.
  \ - Rename "resmark"-like words to "rmark"-like.
  \ - Rename "resresolve"-like words to "rresolve"-like.
  \ - Remove "retCOND"-like and "callCOND"-like macros.
  \ - Compact the blocks.
  \ - Add `?jp` and `?jr` for conditional jumps.
  \ - Remove "jpCOND"-like and "jrCOND"-like opcodes.
  \ - Changed the opcode values of the conditions.
  \ - Rename `?page` to `?jr-range`.
  \ - Rename `clr,` to `clrp,`; add new `clr,`.
  \
  \ 2016-05-09: Save and restore the compile word list, the
  \ current radix and the search order.

  \ -------------------------------------------------------------
  \ XXX TODO

  \ - Combine changes 2..4 with the previous version.
  \ - Make absolute-jump control structures optional.
  \ - Use `get-order` at the start and `set-order` at the end.
  \ - Document.

( z80-asm, )

get-current forth-wordlist set-current

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions base @ hex

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?jr-range  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  create c, does>  ( -- ) ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- ) ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- ) ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- ) ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- ) create , does>  ( -- ) ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: (jr,)  ( a op -- )  c, here 1+ - ?jr-range c,  ;
  \ Compile a relative jump _op_ to absolute address _a_.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- ) ( a pfa )  c@ (jr,)  ;
  \ Relative jumps.

-->

( z80-asm, )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 22 m5 sthl,
27 m1 daa, 2A m5 fthl, 2F m1 cpl, 32 m5 sta, 37 m1 scf, 3A m5
fta, 3F m1 ccf, 76 m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98
m2 sbc, B8 m2 cp, C1 m3 pop, C3 m5 jp, C5 m3 push, C6 m4 add#,
C7 m2 rst, C9 m1 ret, CD m5 call, CE m4 adc#, D3 m4 out, 41 m3
outbc, D6 m4 sub#, D9 m1 exx, DB m4 in, 40 m3 inbc, 0DE m4
sbc#, E3 m1 exsp, E6 m4 and#, E9 m1 jphl, EB m1 exde, EE m4
xor#, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FB m1 ei, FE m4 cp#, 00
m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6 rr, 20 m6 sla, 28 m6 sra, 38
m6 srl,  40 m7 bit, 80 m7 res, C0 m7 set, B0ED m8 ldir, B8ED m8
lddr, 44ED m8 neg, 57ED m8 ldai, 47ED m8 ldia, 56ED m8 im1 5EED
m8 im2 B1ED m8 cpir, 6FED m8 rld, A0 m2 and, B0 m2 or,  A8 m2
xor, -->

( z80-asm, )

  \ Opcodes

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ld#,  ;
  \ Macro to clear an 8-bit register with zero.
: clrp,  ( rp -- )  0 swap ldp#,  ;
  \ Macro to clear a 16-bit register with zero.
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;
  \ Macro, 16-bit register load.
: subp,  ( rp -- )  a and, sbcp,  ;
  \ Macro, 16-bit subtract.
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;  -->
  \ Macro to test 16-bit register for zero.

( z80-asm, )

  \ ZX Spectrum specific

CF m4 hook,  \ rst $08
D7 m1 prt,   \ rst $16

  \ Index register opcodes

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, )

  \ Conditions

  \ Conditions are Z80 opcodes for the required absolute jump
  \ instruction.

CA constant z?  C2 constant nz? DA constant c? D2 constant nc?
EA constant pe? E2 constant po? FA constant m? F2 constant p?

: jp>jr  ( op1 -- op2 )  dup nc? > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

: ?ret,  ( op -- )  2- c,  ;
  \ Conditional ret

: ?call,  ( a op -- )  2+ c, ,  ;
  \ Conditional call

: ?jp,  ( a op -- )  c, ,  ;
  \ Conditional absolute jump

: ?jr,  ( a op -- )  jp>jr (jr,)  ;
  \ Conditional relative jump

  \ Control structures with relative jumps

: >rmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.

: rresolve  ( orig dest -- )  1- over - ?jr-range swap c!  ;
  \ Resolve a relative branch.

: >rresolve  ( orig -- )  here rresolve  ;
  \ Resolve a forward relative branch.

: <rresolve  ( dest -- )  here 1- swap rresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, )

  \ Control structures with relative jumps

: inverse-cond  ( op1 -- op2 )  8 xor  ;
  \ Convert a condition flag (actually, an absolute jump
  \ opcode) to its opposite.
  \
  \ Examples: `c?` to `nc?` (jpc to jpnc); nz? to z? (jpnz to
  \ jpz); etc.

: rahead  ( -- orig  )  18 , >rmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>rresolve`.
  \ Note: $18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr inverse-cond , >rmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >rresolve  ;

: relse  ( orig cs-id -- cs-id )
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note: $18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <rresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`
  \ Note: $18 is the opcode of `jr`.

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`
  \ Note: $10 is the Z80 opcode for `djnz`.

( z80-asm, )

  \ Control structures with absolute jumps

: aif  (  op -- orig cs-id )  inverse-cond c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ Note: $C3 is the opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.
  \ Note: $C3 is the opcode of `jp`

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: >amark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: >aresolve  ( a -- )  >amark swap !  ;
  \ Resolve an absolute forward reference.

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

base ! set-current previous

( execute-hl, call-xt, )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm,  need macro

macro execute-hl,  ( -- )
  0000 bc stp,  >amark      \ save the Forth IP
  0000 bc ldp#, >amark      \ point IP to phony_compiled_word
  jphl,                     \ execute the xt in HL
  >resolve                  \ phony_compiled_word
  here cell+ ,              \ point to the phony xt following
  0000 bc ldp#  >aresolve   \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt,  ( xt -- )
  hl ldp#,  execute-hl,
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ assembler.z80-asm.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605092127

  \ -----------------------------------------------------------
  \ Description

  \ A Z80 assembler called `z80-asm`.

  \ -----------------------------------------------------------
  \ Authors

  \ The original assembler, for the 8080, was written by John
  \ Cassady, in 1980-1981, and published on Forth Dimensions
  \ (volume 3, number 6, page 180, 1982-03).
  \
  \ Coos Haak wrote an improved version for Z80 for his own ZX
  \ Spectrum Forth, in the middle 1980's.
  \
  \ Lennart Benschop included Coos Haak's assembler in his
  \ Spectrum Forth-83 (1988).
  \
  \ Marcos Cruz (programandala.net) adapted, modified and
  \ improved the Spectrum Forth-83 version for Solo Forth,
  \ 2015, 2016.

  \ -------------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -------------------------------------------------------------
  \ History

  \ 2015: Adapted from Afera. Main development.
  \
  \ 2016-04-11: Moved `macro` to its own module.
  \
  \ 2016-04-13: Made `calc` independent from the assembler and
  \ moved it to the floating point module. Fixed `execute-hl`.
  \
  \ 2016-05-09: Save and restore the compile word list, the
  \ current radix and the search order.

( z80-asm )

  \ XXX TODO -- `get-order` here and `set-order` at the end.

get-current forth-wordlist set-current

need ?pairs  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions base @ hex

-->

( z80-asm )

  \ Registers

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm )

  \ Defining words for z80 instructions

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm )

  \ Defining words for z80 instructions

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm )

  \ Defining words for z80 instructions

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm )

  \ Opcodes

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm )

  \ Opcodes

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm )

  \ Index register opcodes

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm )

  \ Conditional ret and call

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm )

  \ Control structures with relative jumps

  \ XXX TODO -- document
  \ XXX TODO -- rename `rel...` to `r...`

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm )

  \ Control structures with absolute jumps

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm )

  \ Last opcodes and macros

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

base ! set-current previous

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credit:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call an xt hold in a
  \ variable.  The code was factored to two assembler macros in
  \ order to make it reusable.

need z80-asm  need macro

macro execute-hl  ( -- )
  0000 bc stp  |mark  \ save the Forth IP
  0000 bc ldp# |mark  \ point IP to phony_compiled_word
  jphl          \ execute the xt in HL
  >resolve \ phony_compiled_word
  here cell+ ,      \ point to the phony xt following
  0000 bc ldp#  |resolve  \ restore the Forth IP
  endm
  \ Compile an `execute` with the xt hold in HL.

macro call-xt  ( xt -- )
  hl ldp#  execute-hl
  endm
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.

  \ vim: filetype=soloforth
  \ benchmark.byte-magazine.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ BYTE Magazine benchmark.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( do-prime )

  \ Credit:
  \
  \ Eratosthenes Sieve Prime Number program in Forth
  \ by Jim Gilbreath, BYTE Magazine, 1981-09, page 190.

forth definitions decimal

8190 constant size  variable flags  size allot

: do-prime  ( -- )
  flags size 1 fill
  0 size 0
  do flags i + c@
     if i dup + 3 + dup i +
          begin   dup size <
          while   0 over flags + c! over +
          repeat  drop drop 1+
     then
  loop  .  ." primes "  ;

( byte-magazine-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).
  \
  \ 2015-12-24. Modified: no printing.

need bench{

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop
  \ u. ." PRIMES" cr  \ XXX OLD
  drop  \ XXX NEW
  ;  -->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( n -- )
  cr dup u. ." iterations..." cr
  bench{ 0 ?do  do-prime  loop }bench.  ;

  cr
  \  <------------------------------>
  .( To run the BYTE Magazine) cr
  .( benchmark type:) cr
  .(   n byte-magazine-benchmark) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 1000 iterations.) cr


  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       -----         -----
  \ 00010  6397          5216
  \ 00100 63970 (1.00)  52159 (0.81)

  \ 2016-03-16
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 00001                    517
  \ 00010                   5164
  \ 00100 52161 (1.00)     51635 (0.98)
  \
  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ benchmark.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Generic benchmarking tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in the file <development_benchmarks.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( bench{ }bench }bench. bench. benched )

  \ Credit:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

( all-benchmarks )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

  \ vim: filetype=soloforth
  \ benchmark.interface-age.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Interface-Age benchmark.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( interface-age-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ Interface Age Benchmark, 1985-11-16.  This is the Interface
  \ Age benchmark program described in Appendix D of the
  \ forthCMP Manual.

  \ 2015-12-24. Modified: no printing.

need bench{  need 2/

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 ?do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop
    \ if  .  else  drop  then  \ XXX OLD
    2drop  \ XXX NEW
  loop  drop  ;  -->

( interface-age-benchmark )

: interface-age-benchmark  ( n -- )
  bench{ (interface-age-benchmark) }bench.  ;

  cr
  \  <------------------------------>
  .( To run the interface age) cr
  .( benchmark type:) cr
  .(   n interface-age-benchmark  ) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 5000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       ------------  ------------
  \ 05000 80091 (1.00)  72445 (0.90)

  \ 2016-03-16 XXX TODO --
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- --------------------------------------
  \       jp pushhl        push hl + jp (ix) [1]
  \       ------------     ---------------------
  \ 05000 72445 (1.00)     71914 (0.99)
  \
  \ [1] Changed only in the kernel.

( Interface Age Benchmark program )

  \ XXX TODO -- test

  \ Forth Dimensions (volume 2, number 4, page 112)

: bench  ( -- )
  dup 2 / 1+ swap ." Starting " cr
  1 do dup i 1 rot
    2 do drop dup i /mod
      dup 0= if  drop drop 1 leave
      else  1 = if drop 1
            else  dup 0 > if  drop 1
                  else  0= if  0 leave  then
                  then
            then
      then
    loop
    if  4 .r  else  drop  then
  loop  drop cr ." Finished " ;

  \ vim: filetype=soloforth
  \ benchmark.vector-loop.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Vector-Loop benchmark.

  \ -----------------------------------------------------------
  \ Authors

  \ M. Edward Borasky, 1995-07-30; code published on Forth
  \ Dimensions (volume 17, number 4, page 11, 1995-11).

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( vector-loop-benchmark )

  \ Credit:
  \
  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench{

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !
     1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop3 ( -- ) \ vector divide
  0 begin
    dup vec1 @ over vec2 @ / over vec3 !
    1+ dup vsize =
  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench{ 0 begin  loop0 1+ dup reps =  until  drop }bench.
  ." Vector No-Op" cr  ;

: bench1 ( -- ) \ benchmark loop1
  bench{ 0 begin  loop1 1+ dup reps =  until  drop }bench.
  ." Vector +    " cr  ;

: bench2 ( -- ) \ benchmark loop2
  bench{ 0 begin  loop2 1+ dup reps =  until  drop }bench.
  ." Vector *    " cr  ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench{ 0 begin  loop3 1+ dup reps =  until  drop }bench.
  ." Vector /    " cr  ;

: bench4 ( -- ) \ benchmark loop4
  bench{ 0 begin  loop4 1+ dup reps =  until  drop }bench.
  ." Vector */   " cr  ;

: vector-loop-benchmarks  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  cr
  \  <------------------------------>
  .( To run the vector loop) cr
  .( benchmarks type:) cr
  .(   vector-loop-benchmarks ) cr

  \ 2015-12-24
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               ITC           DTC
  \               ------        -------------
  \ Vector noop    10919 (1.0)    9033 (0.82)
  \ Vector +       58650 (1.0)   47462 (0.80)
  \ Vector *      107770 (1.0)   91611 (0.85)
  \ Vector /      149002 (1.0)  127495 (0.85)
  \ Vector */     178854 (1.0)  154480 (0.86)

  \ 2016-03-16
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               jp pushhl        push hl + jp (ix) [1]
  \               ------------     ---------------------
  \ Vector noop     9033 (1.0)       8943 (0.99)
  \ Vector +       47461 (1.0)      47177 (0.99)
  \ Vector *       91920 (1.0)      91153 (0.99)
  \ Vector /      127496 (1.0)     126783 (0.99)
  \ Vector */     155192 (1.0)     154364 (0.99)

  \ [1] Changed only in the kernel.

  \ vim: filetype=soloforth
  \ blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605132325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to disk blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-29: Add `lineload` and `lineblock>source`.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-13: Add `load-app`.

( ?--> update flush thru )

[unneeded] ?-->
?\ : ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "ccc<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credit:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ Origin: Pygmy Forth.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loaded or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credit:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ Origin: MMSFORTH.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;

[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line lineblock>source lineload load-app )

[unneeded] .line
?\ : .line  ( n1 n2 -- )  line>string -trailing type  ;  exit

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

[unneeded] lineblock>source [unneeded] lineload and
?\ : lineblock>source  ( n1 n2 -- )  blk !  c/l * >in !  ;

  \ doc{
  \
  \ lineblock>source  ( n1 n2 -- )
  \
  \ Set block _n2_ as the current source, starting from its
  \ line _n1_.
  \
  \ }doc

need ?( [unneeded] lineload ?(

: lineload  ( n1 n2 -- )
  dup 0= #-259 ?throw
  nest-source lineblock>source interpret unnest-source  ; ?)

  \ doc{
  \
  \ lineload  ( n1 n2 -- )
  \
  \ Begin interpretation at line _n1_ of block _n2_.
  \
  \ Origin: Forth-83 (Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] load-app ?( need locate
variable loading-app

  \ doc{
  \
  \ loading-app ( -- a )
  \
  \ A variable that holds a flag: Is an application being
  \ loaded?  This flag is modified by `load-app` and `end-app`.
  \
  \ See `load-app`, `end-app`.
  \
  \ }doc

: end-app  ( -- )  loading-app off  ;  end-app

  \ doc{
  \
  \ end-app  ( -- )
  \
  \ End a app of the library.
  \
  \ See `load-app`, `loading-app`.
  \
  \ }doc

: load-app  ( "name" -- )
  loading-app on
  blocks locate ?do   loading-app @ 0= ?leave  i load
                loop  end-app  ; ?)

  \ doc{
  \
  \ load-app  ( "name" -- )
  \
  \ Load an application from the blocks disk.  An application
  \ is a set of blocks that are loaded as a whole. They don't
  \ have block headers except the first one, which contains
  \ "name", and therefore they don't have internal requisites.
  \ Applications dont't need `-->` or any other word to change
  \ the loading: The loading starts from the first block of the
  \ disk that has "name" in its header, and continues until the
  \ last block of the disk or until `end-app` is executed.
  \
  \ See `end-app`, `loading-app`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ blocks.indexer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- It works fine, but the indexed
  \ words (all words from the library) fill the memory bank.
  \ The solution is a configurable system bank.

  \ Last modified: 201605140237

  \ -----------------------------------------------------------
  \ Description

  \ A blocks indexer that improves the default behaviour of
  \ `need`, `needed`, `reneed` and `reneeded`: It creates a
  \ word list from the names that are on the index (header)
  \ line of every searchable block, ignoring duplicates.  These
  \ words will load the block they belong to. This way, after
  \ indexing all of the disk blocks only once, `need` will
  \ search the word list and execute the word found, instead of
  \ searching all of the blocks every time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-02: Start.
  \
  \ 2016-04-03: First working version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has
  \ been moved from the kernel to the library.
  \
  \ 2016-05-05: Update `s=` to `str=`. Improve documentation.
  \
  \ 2016-05-07: New method: the indexed word is an alias, which
  \ doesn't use data space, and its execution token is the
  \ block it's associated to. This way, no data space is used
  \ by the index.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.

( indexer )

only forth definitions

need str=  need alias  need string/
need get-order  need set-order  need nextname

wordlist constant index-wordlist
  \ Word list for the indexed words.

: search-index  ( ca len -- 0 | xt 1 | xt -1 )
  index-wordlist search-wordlist  ;
  \ Search the index for word _ca len_.

: name-indexed?  ( ca len -- f )
  search-index 0<> dup if  nip  then  ;
  \ Is word _ca len_ in the index?

variable indexed-block

  \ variable counter counter off  \ XXX INFORMER

: index-name  ( ca len -- )
  2dup name-indexed? if  2drop exit  then
  \ 1 counter +! counter ? 2dup type space np@ u.
  \ XXX INFORMER
  nextname indexed-block @ alias  ;
  \ Add word _ca len_ to the blocks index, if not done before.
  \ The current word list is supposed to be `index-wordlist`.

-->

( indexer )

wordlist dup constant indexer-wordlist set-current
  \ Word list for the words that parse the block index lines.

: (  ( "ccc<space><paren><space|eof>" -- )
  begin  parse-name 2dup s" )" str= 0=
  while  index-name  repeat  2drop  ;
  \ Parse and index the names until the next right paren name.

' ( alias .(

: \  ( "ccc<space><backslash><space|eof>" -- )
  begin  parse-name 2dup s" \" str= 0=
  while  index-name  repeat  2drop  ;
  \ Parse and index the names until the next backslash name.

forth-wordlist set-current  -->

( indexer )

: index-reneeded  ( ca len -- )
  search-index 0= #-277 ?throw load  ;

  \ doc{
  \
  \ index-reneeded  ( ca len-- )
  \
  \ Search the index word list for word _ca len_. If found,
  \ load the block it's associated to.  If not found, throw an
  \ exception -277 ("required, but not indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneeded`.
  \
  \ }doc

: index-reneed  ( "name" -- )  parse-name index-reneeded  ;

  \ doc{
  \
  \ index-reneed  ( "name" -- )
  \
  \ Search the index word list for word "name". If found,
  \ execute it, causing its associated block be loaded.  If not
  \ found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `reneed`.
  \
  \ }doc

: index-needed  ( ca len -- )
  needed-word 2@ 2>r  new-needed-word  2dup undefined?
  if  index-reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ index-needed ( ca len -- )
  \
  \ If word _ca len_ is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `needed`.
  \
  \ }doc

: index-need  ( "name" -- )  parse-name index-needed  ;

  \ doc{
  \
  \ index-need  ( "name" -- )
  \
  \ If word "name" is found in the current search order, do
  \ nothing. Otherwise search the index word list for it. If
  \ found, execute it, causing its associated block be loaded.
  \ If not found, throw an exception -277 ("required, but not
  \ indexed").
  \
  \ This is an alternative behaviour of the deferred word
  \ `need`.
  \
  \ }doc

: set-indexed-need  ( -- )
  ['] index-reneeded ['] reneeded  defer!
  ['] index-reneed   ['] reneed    defer!
  ['] index-need     ['] need      defer!
  ['] index-needed   ['] needed    defer!  ;

  \ doc{
  \
  \ set-indexed-need  ( -- )
  \
  \ Set the alternative behaviour of `need`, `needed`, `reneed`
  \ and `reneeded`: Use the library index created by `indexer`.
  \ In fact `indexer` executes `set-indexed-need` after
  \ creating the index.
  \
  \ The default behaviour can be restored by
  \ `set-located-need`.
  \
  \ }doc

-->

( indexer )

  \ : valid-block-header?  ( ca len -- f )
  \   -trailing dup 0= #-278 ?throw
  \   2 string/ 2dup s"  )" str= >r s"  \" str= r> or  ;
  \ XXX TODO -- remove

  \ XXX OLD
  \ doc{
  \
  \ valid-block-header?  ( ca len -- f )
  \
  \ Is block header _ca len_ valid?
  \ Valid block headers end with " )" or " /".
  \ If it's empty, throw error -278 in order to quit
  \ the indexing.
  \
  \ }doc

  \ XXX OLD
  \ : index-block-header  ( ca len -- )
  \   2dup valid-block-header? if  evaluate exit  then  2drop  ;
  \ Index block header _ca len_, if it's valid.

need evaluate

: index-block  ( +n -- )
  dup indexed-block ! 0 swap line>string evaluate  ;
  \ Index block _+n_.

  \ XXX OLD
  \ dup indexed-block ! 0 swap line>string index-block-header  ;

: (indexer)  ( -- )  last-locatable @ 1+ first-locatable @
                     ?do  i index-block  loop  ;
  \ Create the blocks index.

: indexer  ( -- )
  get-current  get-order
  index-wordlist set-current  indexer-wordlist 1 set-order
  ['] (indexer) catch  dup #-278 <> swap ?throw
  set-order set-current  set-indexed-need  ;

  \ doc{
  \
  \ indexer  ( -- )
  \
  \ Create the blocks index and activate it. The current
  \ word list and the current search order are preserved.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ chars.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271451

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-27: Move `ascii-char?` and `control-char?` from
  \ module "tool.dump.fsb".

( ascii-char? control-char? )

: ascii-char?    ( c -- f )  128 <  ;

  \ doc{
  \
  \ ascii-char?    ( c -- f )
  \
  \ Is character _c_ an ASCII character?
  \
  \ }doc


: control-char?  ( c -- f )  bl <  ;

  \ doc{
  \
  \ control-char?    ( c -- f )
  \
  \ Is character _c_ a control character?
  \
  \ }doc

  \ vim: filetype=soloforth
  \ compilation.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170044

  \ -----------------------------------------------------------
  \ Description

  \ Words related to compilation.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-04: Add `[if] [else] [then]`, adapted from Afera.
  \ 2015-06-17: Add `[true]`, `[false]`.
  \ 2015-06-25: Finish `[if] [else] [then]`.
  \ 2015-10-22: Rename words that convert header addresses.
  \ 2015-10-24: Move `body>name`, `name>link`, `link>name` and
  \ `>>link` from the kernel.
  \ 2015-10-29: Move `smudge` and `smudged` from the kernel.
  \ 2015-11-13: Move `?pairs` from the kernel.
  \ 2016-03-19: Add `save-here` and `restore-here`.
  \ 2016-04-17: Add `name>>`.
  \ 2016-04-24: Add `]l`, `]2l`, `exec`, `eval`.
  \ 2016-04-24: Add `[const]`, `[2const]`, `[cconst]`.
  \ 2016-04-24: Move `cliteral` from the kernel.
  \ 2016-04-24: Move `n,` from module "tool.marker.fsb".
  \ 2016-04-25: Simplify `exec`, move `possibly` from the
  \ module "tool.marker.fsb".
  \ 2016-04-25: Move `n,`, `n@`, `n!` to the module
  \ "memory.misc.fsb".
  \ 2016-04-26: Fix `restore-here`. Add `name>interpret`,
  \ `name>compile`.  Move `current-latest` from the kernel,
  \ formerly called `latest`.
  \ 2016-04-27: Add `comp'`, `[comp']`. Move `warning` from the
  \ kernel. Add `warn.throw`, `warn.message`, `warn-throw`
  \ and common factors.
  \ 2016-04-29: Add `string-parameter`.
  \ 2016-05-02: Join several blocks to save space.
  \ 2016-05-02: Move `[compile]` from the kernel.
  \ 2016-05-04: Compact the blocks.
  \ 2016-05-05: Update `s=` to `str=`.
  \ 2016-05-06: Move `current-latest` back to the kernel.
  \ 2016-05-07: Add `?(`, a simpler alternative to `[if]`.
  \ 2016-05-12: Fix requirements of `[cconst]`.
  \ 2016-05-13: Improve `[else]` with `refill`.
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \ 2016-05-15: Update comment.
  \ 2016-05-17: Move `body>` and `>body` from the kernel.

( [false] [true] [if] [else] [then] )

[unneeded] [true]  ?\   0 constant [false] immediate exit
[unneeded] [false] ?\  -1 constant [true]  immediate exit

need str=

  \ Note: `[if]` uses 132 bytes of data space (not including
  \ `str=`).

: [else] ( "ccc" -- )
  1 begin  begin  parse-name dup while  2dup s" [if]" str=
                  if    2drop 1+
                  else  2dup s" [else]" str=
                        if    2drop 1- dup if  1+  then
                        else  s" [then]" str= if  1-  then
                        then
                  then  ?dup 0= if exit then
           repeat  2drop
    refill 0= until  drop  ; immediate

: [if]  ( f "ccc" -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( ?( )

need str=

  \ Note: `?((` uses 35 bytes of data space (not including
  \ `str=`).

: ?(  ( f "ccc<space><question><paren><space>" -- )
  0= ?exit  begin   parse-name dup
            while   s" ?)" str= ?exit
            repeat  ; immediate

: ?)  ( -- )  ; immediate

( body>name name>body link>name name>link name<name )

[unneeded] body>name
?\ need body>  : body>name  ( pfa -- nt )  body> >name  ;

[unneeded] name>body
?\ need >body  : name>body  ( nt -- pfa )  name> >body  ;

[unneeded] link>name
?\ need alias  ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link
?\ need alias  ' cell- alias name>link  ( nt -- pfa )

[unneeded] name<name
?\ need name>link  : name<name  ( nt1 -- nt2 )  name>link @s  ;
  \ Get the previous _nt2_ from _nt1_.

( >>link name>> >body body> )

[unneeded] >>link
?\ need alias  ' cell+ alias >>link  ( xtp -- lfa ) exit

[unneeded] name>>
?\ : name>>  ( nt -- xtp )  [ 2 cells ] literal -  ; exit

need ?(

[unneeded] >body ?(
code >body  ( xt -- pfa )
  E1 c, 2B c, 2B c, 2B c, jppushhl  end-code  exit ?)
  \ pop hl
  \ dec hl
  \ dec hl
  \ dec hl
  \ jp pushhl

[unneeded] body> ?(
code body>  ( pfa -- xt )
  E1 c, 23 c, 23 c, 23 c, jppushhl  end-code ?)
  \ pop hl
  \ inc hl
  \ inc hl
  \ inc hl
  \ jp pushhl

( name>interpret name>compile comp' [comp'] )

need ?(

[unneeded] name>interpret ?(
: name>interpret  ( nt -- xt | 0 )
  dup name> swap compile-only? 0= and  ;  ?)

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return _xt_ that represents the interpretation semantics of
  \ the word _nt_. If _nt_ has no interpretation semantics,
  \ return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[unneeded] name>compile ?(

: (comp')  ( nt -- xt )
  immediate?  if    ['] execute
              else  ['] compile,  then  ;

: name>compile  ( nt -- x xt )  dup name> swap (comp')  ;  ?)

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of the word _nt_. The  returned _xt_ has the
  \ stack effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

[unneeded] comp' ?(  need need-here  need-here name>compile

: comp'  ( "name" -- x xt )
  defined dup ?defined name>compile  ;  ?)

  \ doc{
  \
  \ comp'  ( "name" -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] [comp'] ?(  need need-here  need-here comp'

: [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  comp' postpone 2literal  ; immediate compile-only  ?)

  \ doc{
  \
  \ [comp']  ( Compilation: "name" -- ) ( Run-time: -- x xt )
  \
  \ Compilation token _x xt_ represents the compilation
  \ semantics of "name".
  \
  \ Origin: Gforth.
  \
  \ }doc

( ?pairs [compile] smudge smudged )

[unneeded] ?pairs
?\ : ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;  exit

  \ doc{
  \
  \ ?pairs  ( x1 x2 -- )
  \
  \ If _x1_ not equals _x2_ throw error #-22 (control structure
  \ mismatch).
  \
  \ }doc

[unneeded] [compile]
?\ : [compile]  ( "name" -- )  ' compile,  ; immediate  exit


need ?(

[unneeded] smudged ?(  need c!toggle-bits
: smudged  ( nt -- )
  smudge-mask swap system-bank c!toggle-bits default-bank  ; ?)

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hidden` and `revealed` are used
  \ instead.
  \
  \ }doc

[unneeded] smudge ?(  need need-here  need-here smudged
: smudge  ( -- )  latest smudged  ;  ?)

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ]l ]2l exec eval save-here restore-here )

need [if]

[needed] ]l [if]

: ]l  ( x -- )  ] postpone literal  ; immediate compile-only

  \ doc{
  \
  \ ]l  ( x -- )
  \
  \ A short form of the idiom `] literal`.
  \
  \ }doc

[then]

[needed] ]2l [if]

: ]2l  ( xd -- )  ] postpone 2literal  ; immediate compile-only

  \ doc{
  \
  \ ]2l  ( xd -- )
  \
  \ A short form of the idiom `] 2literal`.
  \
  \ }doc

[then]

[needed] save-here [needed] restore-here or [if]

variable here-backup
: save-here  ( -- )  here here-backup !  ;
: restore-here  ( -- )  here-backup @ there  ;

  \ XXX TODO -- behead `here-backup`

[then]

( possibly exec eval cliteral )

  \ Credit:
  \
  \ Code of `possibly` adapted from Wil Baden.

need ?(

[unneeded] possibly ?(

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ; ?)

  \ doc{
  \
  \ possibly  ( "name" -- )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else do nothing.
  \
  \ }doc

[unneeded] exec ?(

: exec  ( "name" -- i*x )
  defined ?dup 0= #-13 ?throw  name> execute  ; ?)

  \ doc{
  \
  \ exec  ( "name" -- i*x )
  \
  \ Parse "name".  If "name" is the name of a word in the
  \ current search order, execute it; else throw exception
  \ #-13.
  \
  \ }doc

[unneeded] eval ?(  need evaluate

: eval  ( i*x "name" -- j*x )  parse-name evaluate  ; ?)

  \ doc{
  \
  \ exec  ( i*x "name" -- j*x )
  \
  \ Parse and evaluate "name".
  \
  \ This is a common factor of `[const]`, `[2const]` and
  \ `[cconst]`.
  \
  \ }doc

[unneeded] cliteral ?(

: cliteral  ( b -- )
  compile clit c,  ; immediate compile-only ?)

  \ doc{
  \
  \ cliteral  ( b -- )
  \
  \ Compile _b_ in the current definition.
  \
  \ This word does the same than `literal` but saves one byte
  \ of data space.
  \
  \ Origin: Comus.
  \
  \ }doc

( [const] [2const] [cconst] )

need ?(

[unneeded] [const] ?(  need eval

: [const]  ( "name" -- )
  eval postpone literal  ; immediate compile-only  ?)


  \ doc{
  \
  \ [const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the single-cell value left on
  \ the stack.
  \
  \ This word is intented to compile constants as literals, in
  \ order to gain execution speed. "name" can be any word, as
  \ long as its execution returns a single-cell value on the
  \ stack.
  \
  \ Usage example:
  \
  \ ----
  \ 48 constant zx
  \ : test  ( -- )  [const] zx .  ;
  \ ----
  \
  \ }doc

[unneeded] [2const] ?(  need eval

: [2const]  ( "name" -- )
  eval postpone 2literal  ; immediate compile-only  ?)

  \ doc{
  \
  \ [2const]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the double-cell value left on
  \ the stack.
  \
  \ This word is intented to compile double-cell constants as
  \ literals, in order to gain execution speed.
  \
  \ Usage example:
  \
  \ ----
  \ 48. 2constant zx
  \ : test  ( -- )  [2const] zx d.  ;
  \ ----
  \
  \ }doc

[unneeded] [cconst] ?(  need eval  need cliteral

: [cconst]  ( "name" -- )
  eval postpone cliteral  ; immediate compile-only  ?)

  \ doc{
  \
  \ [cconst]  ( "name" -- )
  \
  \ Evaluate "name". Then compile the char left
  \ on the stack.
  \
  \ This word is intented to compile char constants as literals, in
  \ order to gain execution speed.
  \
  \ Usage example:
  \
  \ ----
  \ 48 cconstant zx
  \ : test  ( -- )  [cconst] zx emit  ;
  \ ----
  \
  \ }doc

( warnings )

need user  need search-wordlist

user warnings  \ flag

  \ doc{
  \
  \ warnings  ( -- a )
  \
  \ User variable that holds a flag. If it's zero, no warning
  \ is shown when a compiled word is not unique in the
  \ `current` vocabulary.
  \
  \ }doc

: no-warnings?  ( -- f )  warnings @ 0=  ;

  \ doc{
  \
  \ no-warnings?  ( -- f )
  \
  \ Are the warnings deactivated?
  \
  \ }doc

: not-redefined?  ( ca len -- ca len xt false | ca len true )
  2dup get-current search-wordlist 0=  ;

  \ doc{
  \
  \ not-redefined?  ( ca len -- ca len xt false | ca len true )
  \
  \ Is the word name _ca len_ not yet defined in the
  \ current compilation word list?
  \
  \ }doc

: ?warn  ( ca len -- ca len | ca len xt )
    no-warnings? if  unnest exit  ( ca len )  then
  not-redefined? if  unnest                   then
  ( ca len | ca len xt )  ;

  \ doc{
  \
  \ ?warn  ( ca len -- ca len | ca len xt )
  \
  \ A common factor of `warn.throw`, `warn.message` and
  \ `warn-throw`.  Check if a warning about the redefinition of
  \ the word name _ca len_ is needed.  If no warning is needed,
  \ unnest the calling definition and return _ca len_. If a
  \ warning is needed, return _ca len_ and the _xt_ of the word
  \ found in the current compilation wordlist.
  \
  \ See `warn.throw`, `warn-throw`, `warn.message`.
  \
  \ }doc

( warn.throw warn.message warn-throw )

need warnings  need [if]

[needed] warn.throw [if]

: warn.throw  ( ca len -- ca len )
  ?warn ( ca len xt )  drop 2drop .error-word  #-257 .throw  ;

  \ doc{
  \
  \ warn.throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print throw error #-257, without
  \ actually throwing an error.
  \
  \ See `warn-throw`, `warn.message`.
  \
  \ }doc

' warn.throw ' warn defer!  warnings on   [then]

[needed] warn.message [if]

: warn.message  ( ca len -- ca len )
  ?warn ( ca len xt )  ." redefined " >name .name  ;

  \ doc{
  \
  \ warn.message  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, print a warning message.
  \
  \ See `warn.throw`, `warn-throw`.
  \
  \ }doc

' warn.message ' warn defer!  warnings on  [then]

[needed] warn-throw [if]

: warn-throw  ( ca len -- ca len )
  ?warn ( ca len xt )  #-257 throw  ;

  \ doc{
  \
  \ warn-throw  ( ca len -- ca len )
  \
  \ Alternative behaviour for the deferred word `warn`.  If the
  \ contents of the user variable `warnings` is not zero and
  \ the word name _ca len_ is already defined in the current
  \ compilation word list, throw error #-257 instead of
  \ printing a warning message.
  \
  \ See `warn.throw`, `warn.message`.
  \
  \ }doc

' warn-throw ' warn defer!  warnings on  [then]

( string-parameter )

  \ Credit:
  \
  \ Inspired by pForth's `param`.

: string-parameter  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  @ count             ( ca len ) ( R: a1 )
    \ get the string
  dup char+ r@ @ +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ XXX TODO -- benchmark this alternative:

: string-parameter2  ( -- ca len )
  rp@ cell+ dup >r    ( a1 ) ( R: a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len ) ( R: a1 )
    \ get the string
  dup char+ rot +    ( ca len a2 ) ( R: a1 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

: string-parameter3  ( -- ca len )
  \ XXX UNDER DEVELOPMENT
  rp@ cell+ dup       ( a1 )
    \ get the address, in the return stack,
    \ that contains the return address of the calling word,
    \ which contains the address of the compiled string
  dup @ count         ( a1 ca len )
    \ get the string
  rot dup >r over char+ over +    ( ca len a2 )
    \ calculate the new return address of the calling word,
    \ in order to skip the string
  r> !  ;
    \ update the return address of the calling word,

  \ doc{
  \
  \ string-param  ( -- ca len )
  \
  \ Return a string compiled after the calling word.
  \
  \ See `warning"` and `(warning")` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.array.noble.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070042

  \ -----------------------------------------------------------
  \ Description

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ References

  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 2001 Julian V. Noble

  \ Modified for Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ License of the original version:

  \ ---------------------------------------------------
  \     (c) Copyright 2001  Julian V. Noble.          \
  \       Permission is granted by the author to      \
  \       use this software for any application pro-  \
  \       vided this copyright notice is preserved.   \
  \ ---------------------------------------------------

  \ License of this version:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \
  \ 2016-04-03: Header reorganized after the original
  \ documentation.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.

( 1array )

need <=

: long ; immediate

: 1array ( len #bytes/datum --) \ ( #b len data ...)
  create 2dup , , * allot ;

: _len ( base_addr -- len)  cell+ @ ;
  \ determine length of an array

: } ( base_adr indx -- adr[indx] )
  over _len over <= over 0< or #-272 ?throw
    \ #-272 = array index out of range
  over @ * + cell+ cell+ ;

( 2array )

  \ words for 2-dimensional arrays

need 1array

: wide ; immediate

: 2array ( hgt wid data_size --) \ ( wid #b len data ...)
  create >r tuck , ( wid hgt)
  r@ , * dup , r> * allot ;

: }} ( base_adr m n -- adr[m,n] ) \ data stored row-wise
  2>r cell+ dup cell- @
  r> * r> + ( base_adr+cell m+n*w)
  } ;

  \ ...........................................................
  \ Usage examples:

  \ 20 long 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 long 20 wide 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 long 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

  \ vim: filetype=soloforth
  \ data.array.wong.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170045

  \ -----------------------------------------------------------
  \ Description

  \ The one-dimensional Wong arrays.

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of `array`, `array>` `ato` and `+ato`.

  \ -----------------------------------------------------------
  \ Authors

  \ Leo Wong.
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-15: Adapted to Solo Forth.
  \ 2016-04-02: Reorganized the description.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( array ato )

need within  need >body

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

  \ vim: filetype=soloforth
  \ data.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `associative:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83, by Henry Laxen and Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2016-04-09: Fixed the file header. Improved the
  \ documentation.

( associative: )

: associative:  ( n "name" -- )
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;

  \ doc{

  \ associative:  ( n "name" -- )

  \ Create a table lookup "name" with _n_ entries.
  \
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \ 1000 constant zx1
  \ 200 constant zx2
  \ 30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ data.associative-list.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160027

  \ -----------------------------------------------------------
  \ Description

  \ An associative list implemented with standard word lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on code written by Wil Baden, published in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-06: Start, adapted from Wil Baden's code.
  \
  \ 2016-03-24: Comments.
  \
  \ 2016-04-15: Improved with different types of items.
  \ Factored. An obscure bug was discovered in during the
  \ changes.  Finally its origin was found in `(;code)`, in the
  \ kernel, and fixed.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- document

( associative-list item? item create-entry )

: associative-list  ( "name" -- )  wordlist constant  ;
  \ Create a new associative list "name".

: item?  ( ca len wid -- false | xt true )
  search-wordlist 0<> ;
  \ Is _ca len_ an item of associative list _wid_?
  \ If so return its _xt_ and _true_, else return _false_.

: item  ( ca len wid -- i*x )
  item? 0= #-13 ?throw execute  ;
  \ If _ca len_ is an item of associative list _wid_, return
  \ its value _i*x_; else throw exception -13, "undefined
  \ word".

: create-entry  ( i*x wid xt "name" -- )
  get-current >r swap set-current
  create execute
  r> set-current  ;
  \ Create an entry "name" in associative list _wid_,
  \ using _xt_ to store its value _i*x_.

-->

( entry char-entry double-entry string-entry )

: entry  ( x wid "name" -- )
  ['] , create-entry does>  ( -- x )  ( pfa ) @  ;
  \ Create a cell entry "name" in associative list
  \ _wid_, with value _x_.

: char-entry  ( c wid "name" -- )
  ['] c, create-entry does>  ( -- c )  ( pfa ) c@  ;
  \ Create a character entry "name" in associative list
  \ _wid_, with value _c_.

: double-entry  ( dx wid "name" -- )
  ['] 2, create-entry does>  ( -- dx )  ( pfa ) 2@  ;
  \ Create a double-cell entry "name" in associative list
  \ _wid_, with value _dx_.

: string-entry  ( ca len wid "name" -- )
  ['] s, create-entry does>  ( -- ca len )  ( pfa ) count  ;
  \ Create a string entry "name" in associative list
  \ _wid_, with value _ca len_.

( items )

need alias  need wordlist-words

' wordlist-words alias items  ( wid -- )
  \ List items of associative list _wid_.

( associative-list-demo )

need associative-list need items

associative-list stuff

1887          stuff entry year
char E        stuff char-entry letter
s" Saluton"   stuff string-entry hello
314159.       stuff double-entry pi

cr .( Keys:) cr stuff items cr

cr .( Values: ) cr

s" year"    stuff item . cr
s" letter"  stuff item emit cr
s" hello"   stuff item type cr
s" pi"      stuff item d. cr

  \ vim: filetype=soloforth
  \ data.begin-stringtable.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-stringtable end-stringtable`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( begin-stringtable end-stringtable )

  \ Credit:
  \
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

  \ vim: filetype=soloforth
  \ data.begin-structure.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Forth-2012 structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

  \ vim: filetype=soloforth
  \ data.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605102225

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to data structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-15: Add `link@` and `link,`.
  \ 2016-04-28: Rename `set` to `storer` and improve it. Add
  \ `cstorer`.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-10: Add `2storer`.

( buffer: cvariable enum link@ link, )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;  exit

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;  exit

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;  exit

[unneeded] link@  [unneeded] link, and ?exit

  \ Credit:
  \
  \ Code of `link@` and `link,` written after the description
  \ by Rick VanNorman, published on Forth Dimensions (volume
  \ 20, number 3, pages 19-22, 1998-09).

defer link@  ( node1 -- node2 )  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

( storer cstorer 2storer )

need ?(

[unneeded] storer ?(

: storer  ( x a "name" -- )
  create  2,  does>   ( -- ) ( pfa )  2@ !  ; ?)

  \ doc{
  \
  \ storer  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _x_ be stored at _a_.
  \
  \ Origin: word `set` found in Forth-79 (Reference Word Set)
  \ and Forth-83 (Appendix B.  Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] cstorer ?(

: cstorer  ( c ca "name" -- )
  create  2,  does>   ( -- ) ( pfa )  2@ c!  ; ?)

  \ doc{
  \
  \ cstorer  ( c ca "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _c_ be stored at _ca_.
  \
  \ Origin: variant of the word `set` found in Forth-79
  \ (Reference Word Set) and Forth-83 (Appendix B.
  \ Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] 2storer ?(

: 2storer  ( xd a "name" -- )
  create  , 2,
  does>   ( -- ) ( pfa )  dup cell+ 2@ rot @ 2!  ; ?)

  \ doc{
  \
  \ 2storer  ( xd a "name" -- )
  \
  \ Define a word "name" which, when executed, will cause that
  \ _xd_ be stored at _a_.
  \
  \ Origin: variant of the word `set` found in Forth-79
  \ (Reference Word Set) and Forth-83 (Appendix B.
  \ Uncontrolled Reference Words).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.store-to.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170047

  \ -----------------------------------------------------------
  \ Description

  \ Words that change the value of constants.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-10: First version.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( !> 2!> c!> )

need ?(  need >body

[unneeded] !> ?(
: !>  ( Int: x "name" -- ) ( Comp: "name" -- ) ( Exe: x -- )
  ' >body compiling? if    postpone literal postpone ! exit
                     then  !  ; immediate ?)

  \ Credit:
  \
  \ Name borrowed from IsForth.

  \ doc{
  \
  \ !>
  \
  \ Interpretation: ( x "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `constant`, and make _x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `constant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( x -- )
  \
  \ Make _x_ the current value of constant "name".
  \
  \ Origin: IsForth.
  \
  \ }doc

[unneeded] 2!> ?(
: 2!>  ( Int: xd "name" -- ) ( Comp: "name" -- ) ( Exe: xd -- )
  ' >body compiling? if    postpone literal postpone 2! exit
                     then  2!  ; immediate ?)

  \ doc{
  \
  \ 2!>
  \
  \ Interpretation: ( xd "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `2constant`, and make _xd_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `2constant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( xd -- )
  \
  \ Make _xd_ the current value of double-cell constant "name".
  \
  \ Origin: IsForth `!>`.
  \
  \ }doc

[unneeded] c!> ?(
: c!>  ( Int: c "name" -- ) ( Comp: "name" --) ( Exe: c -- )
  ' >body compiling? if    postpone literal postpone c! exit
                     then  c!  ; immediate ?)

  \ doc{
  \
  \ c!>
  \
  \ Interpretation: ( c "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `cconstant`, and make _c_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `cconstant`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( c -- )
  \
  \ Make _c_ the current value of the character constant
  \ "name".
  \
  \ Origin: IsForth `!>`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.user.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604211656

  \ -----------------------------------------------------------
  \ Description

  \ Words to use the user data space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09: First draft.
  \ 2016-04-21: New version, moved from the kernel.

( ?user uallot ucreate user 2user )

: ?user  ( -- )
  udp @ dup /user > #-279 ?throw  \ user area overflow?
            0< #-280 ?throw  ;    \ user area underflow?

  \ doc{
  \
  \ ?user  ( -- )
  \
  \ Throw an exception if the user area pointer is out of bounds.
  \
  \ }doc

: uallot  ( n -- )  udp +! ?user  ;

  \ doc{
  \
  \ uallot  ( n -- )
  \
  \ If _n_ is greater than zero, reserve _n_ address units of
  \ user data space. If _n_ is less than zero, release _n_
  \ address units of user data space. If _n_ is zero, leave the
  \ user data-space pointer unchanged. An exception is thrown
  \ if the user-data pointer is out of bounds after the
  \ operation.
  \
  \ }doc

: ucreate  ( "name" -- )  udp @ (user)  ;

  \ doc{
  \
  \ ucreate  ( "name" -- )
  \
  \ Create a header _name_ which points to the first available
  \ offset within the user area.  Execution of _name_ leaves
  \ its absolute user area storage address. No user space is
  \ allocated. See: `uallot`, `user`.
  \
  \ }doc

: user  ( "name" -- )  ucreate cell uallot  ;

  \ doc{
  \
  \ user  ( n "name" -- )
  \
  \ Create a user variable _name_ in the first available offset
  \ within the user area.  Execution of _name_ leaves its
  \ absolute user area storage address.
  \
  \ }doc

: 2user  ( "name" -- )  ucreate [ 2 cells ] literal uallot  ;

  \ doc{
  \
  \ 2user  ( "name" -- )
  \
  \ Create a user double variable _name_ in the first available
  \ offset within the user area.  Execution of _name_ leaves
  \ its absolute user area storage address.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.value.val.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605110157

  \ -----------------------------------------------------------
  \ Description

  \ This module defines `val` and `toval`, which behave like
  \ standard `value` and `to` except `valto` doesn't parse: it
  \ changes the run-time behaviour of the value.
  \
  \ Also double-cell variant `2val` and `2toval` are included.
  \
  \ These words are 3-4 times slower than `value` and `2value`
  \ (from module "data.value.default.fsb"), but since they are
  \ non-parsing they may be useful in special cases.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-08: First versions of `value` with non-standard
  \ non-parsing `to`, inspired by lina.
  \
  \ 2015-09-25: Benchmarked. `perform` and flag versions are
  \ faster than the `defer` version.
  \
  \ 2016-05-10: Fix typo. Improve documentation.
  \
  \ 2016-05-11: Rename `value` to `val` and `to` to `toval`.
  \ Factor the initialization. Add a double-cell version.

( val 2val )

need ?(

[unneeded] val ?(

variable (val)
: init-val  ( -- )   ['] @ (val) !  ;  init-val
: val  ( x "name" -- )
  create ,  does>  ( -- ) ( pfa ) (val) perform  init-val  ;
: toval    ( -- )  ['] ! (val) !  ;  ?)

[unneeded] 2val ?(

variable (2val)
: init-2val  ( -- )   ['] 2@ (2val) !  ;  init-2val
: 2val  ( xd "name" -- )
  create 2,  does>  ( -- ) ( pfa ) (2val) perform  init-2val  ;
: 2toval    ( -- )  ['] 2! (2val) !  ;  ?)

  \ vim: filetype=soloforth
  \ data.value.default.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605132232

  \ -----------------------------------------------------------
  \ Description

  \ This module provides:
  \
  \ - Standard `value` and `to` for single-cell values.
  \ - Non-standard `2value` and `2to` for double-cell values.
  \ - Non-standard `cvalue` and `cto` for character values.
  \
  \ Note: There's a standard implementation of `value`,
  \ `2value` and `to` in module "data.value.forth-2012.fsb",
  \ but it's bigger and slower.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: First versions.
  \
  \ 2015-09-25: Benchmark all versions.
  \
  \ 2015-10-07: Add `cvalue` and `cto`.
  \
  \ 2016-03-24: Split the code into several library modules.
  \
  \ 2016-05-11: Combine three library modules into one. Rewrote
  \ all words as aliases. Document them.
  \
  \ 2016-05-13: Fix `to`, `2to` and `cto`: `immediate` was
  \ missing.

( value to 2value 2to cvalue cto )

need alias  need ?(

[unneeded] value [unneeded] to and ?(

' constant alias value  ( x "name"  -- )

  \ doc{
  \
  \ value  ( x "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _x_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

need !>  ' !> alias to immediate ?)

  \ doc{
  \
  \ to
  \
  \ Interpretation: ( x "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `value`, and make _x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `value`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( x -- )
  \
  \ Make _x_ the current value of value "name".
  \
  \ }doc

[unneeded] 2value [unneeded] 2to and ?(

' 2constant alias 2value  ( xd "name"  -- )

  \ doc{
  \
  \ 2value  ( xd "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _xd_ on the stack.
  \
  \ Note: This word is not the standard `2value` of Forth-94
  \ and Forth-2012. In Solo Forth, words created with this
  \ version of `2value` must be modified using the non-standard
  \ word `2to` instead of `to`.
  \
  \ See `2to`.
  \
  \ }doc

need 2!>  ' 2!> alias 2to immediate ?)

  \ doc{
  \
  \ 2to
  \
  \ Interpretation: ( xd "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `2value`, and make _xd_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `2value`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( xd -- )
  \
  \ Make _xd_ the current value of double-cell value "name".
  \
  \ }doc

[unneeded] cvalue [unneeded] cto and ?(

need cconstant ' cconstant alias cvalue  ( c "name"  -- )

  \ doc{
  \
  \ cvalue  ( c "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _c_ on the stack.
  \
  \ See `cto`.
  \
  \ }doc

need c!>  ' c!> alias cto immediate ?)

  \ doc{
  \
  \ cto
  \
  \ Interpretation: ( c "name" -- )
  \
  \ Parse "name", which is the name of a word created by
  \ `cvalue`, and make _c_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `cvalue`, and
  \ append the execution execution semantics given below to the
  \ current definition.
  \
  \ Execution: ( c -- )
  \
  \ Make _c_ the current value of the character value
  \ "name".
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.value.standard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170047

  \ -----------------------------------------------------------
  \ Description

  \ A standard implemention of `value`, `2value` and `to`.
  \
  \ This is provided as an alternative, when compatibility is
  \ required, but the code is bigger and slower than the
  \ default version provided by module
  \ "data.value.default.fsb", which uses the non-standard word
  \ `2to`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-09-25: Benchmark.
  \ 2016-05-10: Improve `2value`.
  \ 2016-05-11: Document.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( value 2value to )

need >body

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;

  \ doc{
  \
  \ value  ( x "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _x_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: 2value  ( n "name"  -- )  create  1 c, 2,  does> 1+ 2@  ;

  \ doc{
  \
  \ 2value  ( xd "name" -- )
  \
  \ Create a definition "name" with the following execution
  \ semantics: place _xd_ on the stack.
  \
  \ See `to`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: to  ( Int: i*x "name" -- ( Comp: "name" -- ( Exe: i*x -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

  \ doc{
  \
  \ to
  \
  \ Interpretation: ( i*x "name" -- )
  \
  \ Parse "name", which is a word created by `value` or
  \ `2value`, and make _i*x_ its value.
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name", which is a word created by `value` or
  \ `2value`, and append the execution execution semantics
  \ given below to the current definition.
  \
  \ Execution: ( i*x -- )
  \
  \ Make _i*x_ the value of "name".
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ data.xstack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `xstack`, an implementation of named
  \ extra stacks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( xstack )

  \ Credit:
  \
  \ Code adapted from Galope (xstack module).

  \ Creation and core manipulation of xstacks

need value  need allocate  need free

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- )
    \ Make an xstack the current one.
    ( pfa ) dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: xfree  ( -- )  xp0 free throw  ;

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

need xstack

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( 2x@ 2>x 2x> 2xdrop 2xdup )

  \ xstack double-number operations

need xstack  need x@  need >x  need xpick  need xover

: 2x@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: 2xdrop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: 2xdup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xdepth .x )

  \ xstack tools

need xstack

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the right-most item.
: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack,
  \ followed by a list of the items, if any; TOS is the right-most item.
  \ data_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605020046

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the data stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-22: Add `2nip`.
  \ 2015-10-16: Move `roll` from the kernel.
  \ 2015-11-09: Add `swapped`.
  \ 2015-11-22: Add `3drop`, `4drop`.
  \ 2015-12-16: Add `nup`, `drup`, `dip`.
  \ 2015-12-22: Move `3dup` from the assembler and rewrite in Z80.
  \ 2016-02-26: Add `ndrop`, `2ndrop`.
  \ 2016-04-24: Move `pick` from the kernel.
  \ 2016-05-02: Join several blocks to save space.

( 2nip pick roll )

need [if]

  \ Credit:
  \
  \ Code from Afera; original code from DZX-Forth.

[needed] 2nip [if]  code 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  E1 c, D1 c, F1 c, F1 c, C3 c, pushhlde ,  end-code  [then]
    \ pop hl
    \ pop de
    \ pop af
    \ pop af
    \ jp pushhlde

  \ doc{
  \
  \ 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  \
  \ }doc

[needed] pick [if]
code pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
  E1 c,  29 c,  39 c,  C3 c, fetchhl ,  end-code  [then]
    \ pop hl
    \ add hl,hl
    \ add hl,sp
    \ jp fetch.hl

  \ doc{
  \
  \ pick  ( xu .. x1 x0 u -- xu .. x1 x0 xu )
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

[needed] pick [if]  need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp  bc tstp
    \ push bc
    \ ld b,d
    \ ld c,e
    \ ld d,h
    \ ld e,l
    \ ld a,b
    \ or c

  0000 jpz |mark 0 unresolved !   hl decp  hl decp  lddr
    \ jp z,roll.end
    \ dec hl
    \ dec hl
    \ lddr
    \ roll.end:
  0 unresolved @ >resolve  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl
  jpnext  end-code

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

[then]

( 3drop 4drop 3dup )

need [if]

[needed] 3drop [if]
code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop hl
    \ pop hl
    \ jp next

  \ doc{
  \
  \ 3drop  ( x1 x2 x3 -- )
  \
  \ }doc

[needed] 4drop [if]
code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
    \ jp next

  \ doc{
  \
  \ 4drop  ( x1 x2 x3 x4 -- )
  \
  \ }doc

[needed] 3dup [if]
code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  D9 c,
    \ exx
  C1 c,  D1 c,  E1 c,  E5 c,  D5 c,  C5 c,  E5 c,  D5 c,  C5 c,
    \ pop bc
    \ pop de
    \ pop hl
    \ push hl
    \ push de
    \ push bc
    \ push hl
    \ push de
    \ push bc
  D9 c,  jpnext  end-code  [then]
    \ exx
    \ jp next

  \ doc{
  \
  \ 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  \
  \ }doc

  \ slower and smaller version of `3dup`:

  \ : 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

( 2rot swapped )

need [if]

[needed] 2rot [if]

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

  \ doc{
  \
  \ 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  \
  \ }doc

  \ Credit:
  \
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

[then]

[needed] swapped [if]

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

[then]

( nup drup dip 0dup -dup )

need [if]

[needed] nup [if]  code nup  ( x1 x2 -- x1 x1 x2 )
  E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,  end-code  [then]
    \ pop hl
    \ pop de
    \ push de
    \ jp pushhlde
  \ Also called `under`.

  \ doc{
  \
  \ nup  ( x1 x2 -- x1 x1 x2 )
  \
  \ }doc

[needed] drup [if]  code drup  ( x1 x2 -- x1 x1 )
  D1 c,  E1 c,  E5 c,  E5 c,  jpnext  end-code  [then]
    \ pop de
    \ pop hl
    \ push hl
    \ push hl
    \ jp next

  \ doc{
  \
  \ drup  ( x1 x2 -- x1 x1 )
  \
  \ }doc

[needed] dip [if]  code dip  ( x1 x2 -- x2 x2 )
  E1 c, D1 c, E5 c, E5 c,  jpnext  end-code  [then]
    \ pop hl
    \ pop de
    \ push hl
    \ push hl
    \ jp next

  \ doc{
  \
  \ dip  ( x1 x2 -- x2 x2 )
  \
  \ }doc

[needed] 0dup [if]  code 0dup  ( x -- x | 0 0 )
  E1 c,  78 04 + c,  B0 05 + c,
    \ pop hl
    \ ld a,h
    \ or l
  C2 c, pushhl ,  E5 c,  jppushhl  end-code  [then]
    \ jp z,push_hl
    \ push hl
    \ jp push_hl

  \ doc{
  \
  \ 0dup  ( x -- x | 0 0 )
  \
  \ Duplicate _x_ if it's zero.
  \
  \ }doc

[needed] -dup [if]  code -dup  ( x -- x | 0 0 )
  E1 c,  CB c, 7C c,  C2 c, pushhl ,  E5 c,  jppushhl  end-code
    \ pop hl
    \ bit 7,h ; negative?
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  [then]

  \ doc{
  \
  \ -dup  ( x -- x x | x )
  \
  \ Duplicate _x_ if it's negative.
  \
  \ }doc

( ndrop 2ndrop )

need [if]  need z80-asm

[needed] ndrop [if]

code ndrop  ( x1..xn n -- )

  hl pop  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext  end-code

  \ doc{
  \
  \ ndrop  ( x1..xn n -- )
  \
  \ Drop _n_ cell items from the stack.
  \
  \ }doc

[then]

[needed] 2ndrop [if]

code 2ndrop  ( dx1..dxn n -- )

  hl pop  hl addp  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext  end-code

  \ doc{
  \
  \ ndrop  ( dx1..dxn n -- )
  \
  \ Drop _n_ double cell items from the stack.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth
  \ define.alias.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605052257

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of `alias`.  Features of an alias defined with
  \ `alias`:
  \
  \ - It has the execution token of the original word.
  \ - It does not inherit the attributes of the original word,
  \   which can be set with `immediate` and `compile-only`.
  \ - It does not use data space memory.
  \ - It can be reconfigured with `realias` and `alias!`, but
  \   the compiled aliases don't change.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `alias`: it creates a deferred
  \ word and initializes it. Second version: it recognizes code
  \ words and patches their code field instead.
  \
  \ 2015-12-26: New alternative version, adapted to DTC: if
  \ _xt_ is a deferred word, the alias will point to the word
  \ it's associated to.
  \
  \ 2016-02-27: Fixed the DTC version: the alias of an
  \ unitialized deferred word executed the default error even
  \ after the initialization of the deferred word.
  \
  \ 2016-03-04: Removed the ITC version.
  \
  \ 2016-04-17: Improved `alias`: nowe the aliases have the xt
  \ of the original word.
  \
  \ 2016-04-18: Wrote `realias`.
  \
  \ 2016-04-29: Add `alias!`, a useful common factor of
  \ `alias` and `realias`.
  \
  \ 2016-05-05: Add conditional compilation. Improve
  \ documentation.

( alias! alias realias )

need name>>  need !s

[defined] alias!
?\ : alias!  ( xt nt -- )  name>> !s  ;

  \ doc{
  \
  \ alias!  ( xt nt -- )
  \
  \ Set the alias _nt_ to execute _xt_.
  \
  \ See `alias`, `realias`.
  \
  \ }doc

[unneeded] alias
?\ : alias  ( xt "name" -- )  header reveal latest alias!  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.
  \
  \ Aliases have the execution token _xt_ of the original word,
  \ but don't inherit its precedence (set by `immediate`) and
  \ restricted (set by `compile-only`) attributes.
  \
  \ See `realias`, `alias!`.
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] realias ?exit

: realias  ( xt "name" -- )
  defined dup 0= #-13 ?throw alias!  ;

  \ doc{
  \
  \ realias  ( xt "name" -- )
  \
  \ Set the alias _name_ to execute _xt_.
  \
  \ See `alias`, `alias!`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.colon-no-name.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241823

  \ -----------------------------------------------------------
  \ Description

  \ `:name`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Moved `:noname` from the library.

( :noname )

: :noname  ( -- xt )
  here  dup lastxt !  last off  !csp
  docolon code-field,
  noname? on  ]  ;

  \ XXX TODO -- documentation

  \ doc{
  \
  \ :noname  ( -- xt )
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ define.deferred.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605040149

  \ -----------------------------------------------------------
  \ Description

  \ Words related to deferred words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added `deferred`, using the old definition of
  \ `alias`.
  \
  \ 2016-05-04: Move `defer@` from the kernel, document most
  \ words, compact the blocks.

( deferred defers defer@ action-of )

[unneeded] deferred
?\ : deferred  ( xt "name" -- )  defer latest name> defer!  ;

  \ doc{
  \
  \ deferred  ( xt "name" -- )
  \
  \ Create a deferred word _name_ that will execute _xt_.  The
  \ effect is the same than `defer name  xt ' name defer!`.
  \
  \ }doc

[unneeded] defers
?\ : defers  ( "name" -- )  ' defer@ compile,  ; immediate

  \ doc{
  \
  \ defers  ( Compilation: "name" -- )
  \
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  \
  \ Origin: Gforth.
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from Afera.

[unneeded] defer@
?\ : defer@  ( xt1 -- xt2 )  >defer @  ;

  \ doc{
  \
  \ defer@  ( xt1 -- xt2 )
  \
  \ Return the word _xt2_ currently associated to the deferred
  \ word _xt1_.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] deferred?
?\ : deferred?  ( xt -- f )  c@ $C3 =  ;

  \ doc{
  \
  \ deferred?  ( xt -- f )
  \
  \ Is _xt_ a deferred word?
  \
  \ The code of a deferred word starts with a Z80 jump ($C3) to
  \ the word it's associated to.
  \
  \ }doc

[unneeded] action-of ?exit

: action-of  ( Interpretation: "name" -- xt )
             ( Compilation:    "name" -- )
             ( Runtime:        -- xt )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ doc{
  \
  \ action-of  ( -- )
  \   ( Interpretation: "name" -- xt )
  \   ( Compilation:    "name" -- )
  \   ( Runtime:        -- xt )
  \
  \ Return the code field address of a deferred word.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

  \ Credit:
  \
  \ Code adapted from Afera.

( <is> [is] is  )

  \ Credit:
  \
  \ Code adapted from Afera.

: <is>  ( xt "name" -- )  ' defer!  ;

: [is]  ( xt "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

: is  ( xt "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

  \ vim: filetype=soloforth
  \ define.nextname.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604152121

  \ -----------------------------------------------------------
  \ Description

  \ Words to define words with specific names.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

( nextname )

2variable nextname-string

  \ doc{
  \
  \ nextname-string  ( -- a )
  \
  \ A double variable that may hold the address and length of a
  \ name to be used by the next defining word.  This variable
  \ is set by `nextname`.
  \
  \ }doc

: nextname-header  ( -- )
  nextname-string 2@ header, default-header  ;

  \ doc{
  \
  \ nextname-header  ( -- )
  \
  \ Create a dictionary header using the name string set by
  \ `nextname`.  Then restore the default behaviour of
  \ `header`.
  \
  \
  \ }doc

: nextname  ( ca len -- )
  nextname-string 2!
  ['] nextname-header ['] header defer!  ;

  \ doc{
  \
  \ nextname  ( ca len -- )
  \
  \ The next defined word will have the name _ca len_; the
  \ defining word will leave the input stream alone. `nextname`
  \ works with any defining word.
  \
  \
  \ Origin: Gforth.
  \
  \ }doc

  \ Credit:
  \ This word is borrowed from Gforth.

  \ vim: filetype=soloforth
  \ define.semicolon-code.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242027

  \ -----------------------------------------------------------
  \ Description

  \ `;code`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-24: Move `;code` from the library.

( ;code )

: ;code  ( -- )
  postpone (;code)  finish-code  ; immediate compile-only

  \ XXX TODO -- Improve documentation.

  \ doc{
  \
  \ ;code  ( -- )
  \
  \ Stop compilation and terminate a new defining word by
  \ compiling the run-time routine `(;code)`.
  \
  \ Origin: fig-Forth, Forth-79 (Assembler Word Set), Forth-83
  \ (Assembler Extension Word Set), Forth-94 (TOOLS EXT),
  \ Forth-2012 (TOOLS EXT).
  \
  \ }doc
  \ define.synonym.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241841

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of Forth-2012 `synonym`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-25: First version of `synonym`, using `create
  \ does>`.
  \
  \ 2015-12-23: New improved version, using `alias`. Keep the
  \ first version, just in case.
  \
  \ 2016-04-18: Removed the old first version.
  \
  \ 2016-04-24: Add `need nextname`, because `nextname` has been
  \ moved from the kernel to the library.


( synonym )

need alias  need nextname

: synonym  ( "newname" "oldname" -- )
  parse-name nextname ' dup >r alias
  r> >name dup immediate?     if  immediate     then
               compile-only?  if  compile-only  then  ;

  \ doc{
  \
  \ synonym  ( "newname" "oldname" -- )
  \
  \ Create a definition for _newname_ with the the semantics
  \ defined below. _newname_ may be the same as _oldname_; when
  \ looking up _oldname_, _newname_ shall not be found.
  \
  \ newname ( Interpretation: i*x -- j*x )
  \
  \ Perform the interpretation semantics of _oldname_.
  \
  \ newname ( Compilation: i*x -- j*x )
  \
  \ Perform the compilation semantics of _oldname_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ dos.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604260229

  \ -----------------------------------------------------------
  \ Description

  \ G+DOS support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \
  \ 2016-04-11: Start `plusd-in`, plusd-out`, `plusd-in,`,
  \ plusd-out,`.
  \
  \ 2016-04-26: Remove `char`.

( plusd-in plusd-out )

  \ XXX UNDER DEVELOPMENT -- second version

need z80-asm  need --hook-codes--

code plusd-in  ( -- )
  patch hook
  jpnext
  end-code

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ }doc

code plusd-out  ( -- )
  D3 c, #231 c,     \ out (231),a
  jpnext
  end-code

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ }doc

( plusd-in plusd-out )

  \ XXX UNDER DEVELOPMENT -- first version

code plusd-in  ( -- )
  DB c, #231 c,     \ in a,(231)
  jpnext
  end-code

  \ doc{
  \
  \ plusd-in  ( -- )
  \
  \ Page in the Plus D memory.
  \
  \ }doc

code plusd-out  ( -- )
  D3 c, #231 c,     \ out (231),a
  jpnext
  end-code

  \ doc{
  \
  \ plusd-out  ( -- )
  \
  \ Page out the Plus D memory.
  \
  \ }doc

( plusd-in, plusd-out, )

  \ XXX UNDER DEVELOPMENT

need macro

macro plusd-in,  ( -- )
  DB c, #231 c,     \ in a,(231)
  endm

  \ doc{
  \
  \ plusd-in,  ( -- )
  \
  \ Compile machine code to page in the Plus D memory.
  \
  \ }doc

macro plusd-out,  ( -- )
  D3 c, #231 c,     \ out (231),a
  endm

  \ doc{
  \
  \ plusd-out,  ( -- )
  \
  \ Compile machine code to page out the Plus D memory.
  \
  \ }doc

( ufia )

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1   \ drive: 1 or 2
ufia 1+   constant fstr1   \ program number
ufia 2+   constant sstr1   \ stream number
ufia 3 +  constant device  \ device: "D" or "d"
ufia 4 +  constant nstr1   \ directory description
ufia 5 +  constant nstr2   \ file name
ufia 15 + constant hd00    \ file type
ufia 16 + constant hd0b    \ file length
ufia 18 + constant hd0d    \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

'd' device c! \ "d" or "D"
2 sstr1 c!  \ stream 2
1 dstr1 c!  \ drive 1

variable file-length   \ copy of `hd0b` used by `(<file)`
variable file-address  \ copy of `hd0d` used by `(<file)`

( --file-types-- )

0 constant basic-filetype
1 constant data-array-filetype
2 constant string-array-filetype
3 constant code-filetype

: --file-types--  ;

( --directory-descriptions-- )

01 constant basic-file-dir      02 constant data-array-dir
03 constant string-array-dir    04 constant code-file-dir
05 constant snapshot-48k-dir    06 constant microdrive-file-dir
07 constant screens$-file-dir   08 constant special-file-dir
09 constant snapshot-128k-dir   10 constant opentype-file-dir
11 constant execute-file-dir

: --directory-descriptions--  ;

( --hook-codes-- )

$33 constant hxfer  $34 constant ofsm  $35 constant hofile
$36 constant sbyte  $37 constant hsvbk $38 constant cfsm
$39 constant pntp   $3A constant cops  $3B constant hgfile
$3C constant lbyte  $3D constant hldbk $3E constant wsad
$3F constant sad    $40 constant rest  $41 constant heraz
$42 constant cops2  $43 constant pcat  $44 constant hrsad
$45 constant hwsad  $46 constant otfoc $47 constant patch

: --hook-codes--  ;

( dosior>error ?dos-error dosior>ior )

: dosior>error  ( dosior -- f n )
  dup 1 and negate swap   \ calculate f
  flip %11111111 and      \ upper 8 bits of ior
  1000 + negate  ;
  \ Convert a DOS ior to a Forth error number.
  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ f = error?
  \ n = error number:
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26
  \ XXX OLD -- obsolete

: ?dos-error  ( dosior -- )
  \ dosior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: OS error; unset: DOS error
  dosior>error ?throw  ;
  \ XXX OLD -- obsolete

: dosior>ior  ( dosior -- ior )
  dup 1 and negate          \ error?
  swap flip %11111111 and   \ get upper 8 bits
  1000 + negate and  ;
  \ Convert a DOS ior to a Forth ior.
  \ dosior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ ior = error number:
  \     0: no error
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26
  \ XXX TODO -- check

( get-drive set-drive )

need z80-asm  need --hook-codes--

code get-drive  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  \ save the Forth IP
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp  end-code

code set-drive  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  \ save the Forth IP
  l a ld  21 hook   \ select drive in a
  bc pop   next ix ldp#  \ restore the Forth registers
  jpnext  end-code

( delete-file )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia  need dosior>ior

code (delete-file)  ( -- ior )
  bc push  \ save the Forth registers
  ufia ix ldp#
  heraz hook  \ erase the file
  bc pop  next ix ldp#  \ restore the Forth registers
  af push
  jpnext
  end-code
  \ Delete a disk file using the data hold in UFIA.
  \ Return a G+DOS _ior_.

: delete-file  ( ca len -- ior )
  filename>ufia (delete-file) dosior>ior  ;
  \ Delete a disk file _ca len_ and return I/O result code
  \ _ior_.

( -filename filename! >ufia filename>ufia )

need ufia  need get-drive

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;
  \ XXX TODO -- rename to `set-filename`?

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  get-drive dstr1 c!  ;

1 set-drive  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  bc pop  next ix ldp#  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- ior )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) dosior>ior  ;

( <file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- ior )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) dosior>ior  ;

( file>screen )

  \ XXX UNDER DEVELOPMENT
  \ Experimental code to read lines from a file

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (file>screen)  ( -- dosior )

  \ Print a file on the screen, line by line, using the data
  \ hold in UFIA.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    patch hook  4000 de ldp#  128 bc ldp#
      \ page +D in
      \ destination and count

    d h ld
    begin   lbyte hook  de stap
            a l ld  de push  bc push  1744 call  bc pop  de pop
              \ print HL
            de incp  bc decp  b a ld  c or
    z until  E7 out  \ page +D out
    \ begin
    \   lbyte hook  af push  10 hook  af pop  13 cp
    \ z until

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code -->

( file>screen )

: file>screen  ( ca2 len2 -- ior )
  \ Copy a file to the screen, line by line.
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (file>screen) dosior>ior  ;

( .100 )

  \ XXX TMP -- for debugging

code .100  ( u -- )
  hl pop
  bc push
  hl push
  patch hook
  hl pop
  1744 call
  E7 out  \ page +D out
  bc pop  next ix ldp#  jpnext
  end-code

( <file-as-is )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need dosior>ior

code (<file-as-is)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    hd0d de ftp  hd0b bc ftp  hldbk hook
      \ Use the address and length from the header.
      \ Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ Restore the Forth registers and save the ior.

  jpnext  end-code

: <file-as-is  ( ca len -- ior )
  \ Load a file from disk.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2swap >ufia (<file-as-is) dosior>ior  ;

( file? )

need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )

  bc push  \ save the Forth IP
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  ' true jpz
  ' false jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ $3E01 constant ufia1
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  exx
    \ Get the parameter in hl' and save the Forth IP

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  \ exx  l a ld  24B5 call  168E call \ XXX OLD
    \ 24B5 = CAT_RUN (input: cat type in the A register)
    \ 168E = BORD_REST (restore the border)

  exx  l a ld  09A5 call \ XXX NEW
    \ 09A5 = SCAN_CAT  (input: cat or search type in the A register)

  E7 out  bc pop  next ix ldp#  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need z80-asm  need --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

need z80-asm  need --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

need z80-asm  need --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( !dos )

need z80-asm  need --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  \ save the Forth IP
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ bc pop  next ix ldp#  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

  \ vim: filetype=soloforth
  \ editor.specforth.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605140159

  \ -----------------------------------------------------------
  \ Description

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum.  Its original
  \ name is "Specforth Editor V1.1".
  \
  \ It has been adapted to Solo Forth.
  \
  \ Word descriptions and stack comments have been added after
  \ the Specforth manual, the Abersoft Forth manual and Dr.
  \ C.H. Ting's book _Systems Guide to fig-Forth_. The word
  \ `copy` has been adapted from Abersoft Forth. The word
  \ `text` has been rewritten.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright (C) 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-11: Adapted to Solo Forth.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \ 2016-05-14: Update with `parse-all`, a fixed version of old
  \ `parse-line`.

( editor )

only forth definitions

need list  need update  need flush  need parse-all

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "ccc<char>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "ccc<eol>" -- )
  pad c/l 1+ blank  parse-all  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type '_' emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "ccc<eol>"  -- )  text r  ;
  \ Put "ccc" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear block _n_ with blanks and select for editing.

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= leave  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 leave  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "ccc<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "ccc" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "ccc<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "ccc".

: till  ( "ccc<eol>" -- )
  #lead + text 1line 0= #-270 ?throw
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "ccc".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "ccc<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "ccc" to the cursor line at the cursor position.

also forth

: copy  ( n1 n2 -- )
  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ vim: filetype=soloforth
  \ environmental_queries.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `environment?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( environment? )

need wid-of

vocabulary environment ( -- )
wid-of environment constant environment-wordlist ( -- wid )
  \ Wordlist that is searched by environmental queries.

: environment? ( ca len -- false | i*x true )
  environment-wordlist search-wordlist
  if  execute true  else  false  then  ;

also environment definitions

8 constant address-unit-bits ( -- n )
  \ Size of one address unit, in bits.

255 constant max-char ( -- u )
  \ Maximum value of any character in the character set.

255 constant /counted-string ( -- n )
  \ Maximum size of a counted string, in characters.

  \ XXX TODO
address-unit-bits cells 2* 2+ constant /hold ( -- n )
  \ Size of the pictured numeric string output buffer, in
  \ characters.

  \ XXX TODO calculate
84 constant /pad ( -- n )
  \ Size of the scratch area pointed to by `pad`, in
  \ characters.

1 -3 mod 0< constant floored ( -- f )
  \ True if `/` etc. perform floored division

-->

( environment? )

32767 constant max-n ( -- n )
  \ Largest usable signed integer.

-1 constant max-u ( -- u )
  \ Largest usable unsigned integer.

-1 max-n 2constant max-d ( -- d )
  \ Largest usable signed double.

-1. 2constant max-ud ( -- ud )
  \ Largest usable unsigned double.

  \ XXX TODO -- calculate
$50 constant return-stack-cells ( -- n )
  \ : return-stack-cells ( -- n )
    \ [ forthstart 6 cells + ] literal @ cell / ;
    \ Maximum size of the return stack, in cells.

  \ XXX TODO -- calculate
$50 constant stack-cells ( -- n )
  \ : stack-cells ( -- n )
    \ [ forthstart 4 cells + ] literal @ cell / ;
    \ Maximum size of the data stack, in cells.

  \ XXX TODO -- add "#locals" when needed

forth definitions  previous

  \ exception.codes.0001.standard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070017

  \ -----------------------------------------------------------
  \ Description

  \ The standard Forth error codes (range -255..-1).

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( Standard error codes #-01..#-15 )

\ #-01 ABORT
\ #-02 ABORT"
\ #-03 stack overflow
\ #-04 stack underflow
\ #-05 return stack overflow
\ #-06 return stack underflow
\ #-07 do-loops nested too deeply during execution
\ #-08 dictionary overflow
\ #-09 invalid memory address
\ #-10 division by zero
\ #-11 result out of range
\ #-12 argument type mismatch
\ #-13 undefined word
\ #-14 interpreting a compile-only word
\ #-15 invalid FORGET

( Standard error codes #-16..#-30 )

\ #-16 attempt to use zero-length string as a name
\ #-17 pictured numeric output string overflow
\ #-18 parsed string overflow
\ #-19 definition name too long
\ #-20 write to a read-only location
\ #-21 unsupported operation
\ #-22 control structure mismatch
\ #-23 address alignment exception
\ #-24 invalid numeric argument
\ #-25 return stack imbalance
\ #-26 loop parameters unavailable
\ #-27 invalid recursion
\ #-28 user interrupt
\ #-29 compiler nesting
\ #-30 obsolescent feature

( Standard error codes #-31..#-45 )

\ #-31 >BODY used on non-CREATEd definition
\ #-32 invalid name argument
\ #-33 block read exception
\ #-34 block write exception
\ #-35 invalid block number
\ #-36 invalid file position
\ #-37 file I/O exception
\ #-38 non-existent file
\ #-39 unexpected end of file
\ #-40 invalid BASE for floating point conversion
\ #-41 loss of precision
\ #-42 floating-point divide by zero
\ #-43 floating-point result out of range
\ #-44 floating-point stack overflow
\ #-45 floating-point stack underflow

( Standard error codes #-46..#-60 )

\ #-46 floating-point invalid argument
\ #-47 compilation word list deleted
\ #-48 invalid POSTPONE
\ #-49 search-order overflow
\ #-50 search-order underflow
\ #-51 compilation word list changed
\ #-52 control-flow stack overflow
\ #-53 exception stack overflow
\ #-54 floating-point underflow
\ #-55 floating-point unidentified fault
\ #-56 QUIT
\ #-57 exception in sending or receiving a character
\ #-58 [IF], [ELSE], or [THEN] exception
\ #-59 ALLOCATE
\ #-60 FREE

( Standard error codes #-61..#-75 )

\ #-61 RESIZE
\ #-62 CLOSE-FILE
\ #-63 CREATE-FILE
\ #-64 DELETE-FILE
\ #-65 FILE-POSITION
\ #-66 FILE-SIZE
\ #-67 FILE-STATUS
\ #-68 FLUSH-FILE
\ #-69 OPEN-FILE
\ #-70 READ-FILE
\ #-71 READ-LINE
\ #-72 RENAME-FILE
\ #-73 REPOSITION-FILE
\ #-74 RESIZE-FILE
\ #-75 WRITE-FILE

( Standard error codes #-76..#-79 )

\ #-76 WRITE-LINE
\ #-77 malformed xchar
\ #-78 SUBSTITUTE
\ #-79 REPLACES
\ #-80
\ #-81
\ #-82
\ #-83
\ #-84
\ #-85
\ #-86
\ #-87
\ #-88
\ #-89
\ #-90

  \ vim: filetype=soloforth
  \ exception.codes.0256.system.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070017

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256), except
  \ those reserved for the OS and the DOS.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( System error codes #-256..#-270 )

\ #-256 not a word nor a number
\ #-257 warning: is not unique
\ #-258 stack imbalance
\ #-259 trying to load from block 0
\ #-260 wrong digit
\ #-261 deferred word is uninitialized
\ #-262 assertion failed
\ #-263 execution only
\ #-264 definition not finished
\ #-265 loading only
\ #-266 off current editing block
\ #-267 warning: not present, though required
\ #-268 required, but not located
\ #-269 relative jump too long
\ #-270 text not found

( System error codes #-271..#-285 )

\ #-271 immediate word not allowed in this structure
\ #-272 array index out of range
\ #-273 invalid assembler condition
\ #-274 command line history overflow
\ #-275 wrong number
\ #-276 dictionary reached the zone of memory banks
\ #-277 required, but not indexed
\ #-278 empty block found: quit indexing
\ #-279 user area overflow
\ #-280 user area underflow
\ #-281
\ #-282
\ #-283
\ #-284
\ #-285

  \ vim: filetype=soloforth

  \ exception.codes.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070018

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ G+DOS (range -1031..-1000).

( G+DOS error codes #-1000..#-1014 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1000 G+DOS: Nonsense in G+DOS
\ #-1001 G+DOS: Nonsense in GNOS
\ #-1002 G+DOS: Statement end error
\ #-1003 G+DOS: Break requested
\ #-1004 G+DOS: Sector error
\ #-1005 G+DOS: Format data lost
\ #-1006 G+DOS: Check disk in drive
\ #-1007 G+DOS: No +SYS file
\ #-1008 G+DOS: Invalid file name
\ #-1009 G+DOS: Invalid station
\ #-1010 G+DOS: Invalid device
\ #-1011 G+DOS: Variable not found
\ #-1012 G+DOS: Verify failed
\ #-1013 G+DOS: Wrong file type
\ #-1014 G+DOS: Merge error

( G+DOS error codes #-1015..#-1029 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1015 G+DOS: Code error
\ #-1016 G+DOS: Pupil set
\ #-1017 G+DOS: Invalid code
\ #-1018 G+DOS: Reading a write file
\ #-1019 G+DOS: Writing a read file
\ #-1020 G+DOS: O.K. G+DOS
\ #-1021 G+DOS: Network off
\ #-1022 G+DOS: Wrong drive
\ #-1023 G+DOS: Disk write protected
\ #-1024 G+DOS: Not enough space on disk
\ #-1025 G+DOS: Directory full
\ #-1026 G+DOS: File not found
\ #-1027 G+DOS: End of file
\ #-1028 G+DOS: File name used
\ #-1029 G+DOS: No G+DOS loaded

( G+DOS error codes #-1030..#-1031 )

\ #-1030 G+DOS: STREAM used
\ #-1031 G+DOS: CHANNEL used

  \ vim: filetype=soloforth
  \ exception.codes.os.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605070018

  \ -----------------------------------------------------------
  \ Description

  \ The Forth system error codes (range -4095..-256) used for
  \ ZX Spectrum OS (range -1154..-1128).

( OS error codes #-1128..#-1142 )

  \ XXX TODO -- it seems OS error codes (there are 28 of them)
  \ may be returned by G+DOS.  they are detected and converted
  \ by `ior>error`.

\ #-1128 OS:
\ #-1129 OS:
\ #-1130 OS:
\ #-1131 OS:
\ #-1132 OS:
\ #-1133 OS:
\ #-1134 OS:
\ #-1135 OS:
\ #-1136 OS:
\ #-1137 OS:
\ #-1138 OS:
\ #-1139 OS:
\ #-1140 OS:
\ #-1141 OS:
\ #-1142 OS:

( OS error codes #-1143..#-1154 )

\ #-1143 OS:
\ #-1144 OS:
\ #-1145 OS:
\ #-1146 OS:
\ #-1147 OS:
\ #-1148 OS:
\ #-1149 OS:
\ #-1150 OS:
\ #-1151 OS:
\ #-1151 OS:
\ #-1152 OS:
\ #-1153 OS:
\ #-1154 OS:

  \ vim: filetype=soloforth
  \ exception.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605032252

  \ -----------------------------------------------------------
  \ Description

  \ The management of exceptions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09: Main development.
  \
  \ 2015-10: Fixes.
  \
  \ 2016-04-14: Restored the file from the repository. It was
  \ removed from version 0.3.0+2016-04-09 by mistake. Updated
  \ the headers and documentation.  Renamed `(.throw)` to
  \ `.throw-message`, and `msg-scr` to `error-messages-block`.
  \ Fixed `error>ordinal`.
  \
  \ 2016-04-25: Add carriage return before the exception
  \ message in `.throw-message`.
  \
  \ 2016-04-29: Add `warning"`.
  \
  \ 2016-05-03: Document `warning"`.

( abort" )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only

( error>ordinal error>line )

: error>ordinal  ( -n1 -- +n2 )
  abs dup 256 < ?exit
      dup 1000 < if  [ 256 091 - ] literal - exit  then
      [ 1000 286 - 256 091 - + ] literal -   ;

  \ XXX TODO  add OS codes

  \ doc{
  \
  \ error>ordinal  ( -n1 -- +n2 )
  \
  \ Convert an error code _n1_ to its ordinal position _+n2_ in
  \ the library.

  \ ----
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146
  \ ----

  \ }doc

: error>line  ( -n1 -- n2 )
  error>ordinal dup >r
  begin  dup dup 16 / - r@ <>  while  1+  repeat  rdrop  ;

  \ doc{
  \
  \ error>line  ( -n1 -- n2 )
  \
  \ Convert error code _-n1_ to line _n2_ relative to the block
  \ that contains the error messages.
  \
  \ }doc

( error-messages-block .throw-message )

need error>line  need .line

variable error-messages-block
s" Standard error codes" located error-messages-block !
  \ XXX TODO rename!

  \ doc{
  \
  \ error-messages-block  ( -- a )
  \
  \ Variable that holds the block that holds the error
  \ messages.
  \
  \ }doc

: .throw-message  ( n -- )
  error-messages-block @
  if    cr error>line error-messages-block @ .line space
  else  .throw#  then  ;

' .throw-message ' .throw defer!

  \ doc{
  \
  \ .throw-message  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`: Print the
  \ text of throw error _n_.  The variable
  \ `error-messages-block` holds the number of the first
  \ block where messages are hold. If it contains zero, only
  \ the error number is printed.
  \
  \ }doc

( ?compiling ?executing )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc

( warning" )

  \ Credit:
  \
  \ Adapted from pForth and modified.

need string-parameter

: (warning")  ( f -- )
  string-parameter rot if  type  else  2drop  then  ;

  \ doc{
  \
  \ (warning") ( f -- )
  \
  \ Inner procedure compiled by `warning"`.  If _f_ is not
  \ zero, print the compiled message; else do nothing.
  \
  \ }doc

: warning"
  \ Compilation: ( "ccc<quote>" -- )
  \ Execution:   ( f -- )
  postpone (warning") ,"  ; immediate compile-only

  \ doc{
  \
  \ warning"
  \
  \ Compilation: ( "ccc<quote>" -- )
  \
  \ Parse and compile a message.
  \
  \ Execution:   ( f -- )
  \
  \ If _f_ is not zero, print the compiled message; else do
  \ nothing.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.associative-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `associative-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Frank Sergeant, for Pygmy Forth.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-09: Fixed the file header.

( associative-case: )

need create:

: associative-case: ( "name" -- )
  create:
  does> ( n -- ) ( n pfa ) cell+  \ move past `lit`
  begin   2dup @ dup 0= >r  ( n a n n')
          =  r> or  0= ( n a f )
  while   ( n a )  [ 3 cells ] literal +  \ no match
  repeat  nip cell+ perform  ;

  \ doc{

  \ associative-case: ( "name" -- )
  \
  \ Create an associative case definition "name":
  \ `name  ( i*x n -- j*x )`.

  \ Usage example:

  \ ----
  \ : red       ." red"  ;
  \ : blue      ." blue"  ;
  \ : orange    ." orange"  ;
  \ : pink      ." pink"  ;
  \ : black     ." black"  ;
  \
  \ associative-case: color  ( n -- )
  \   7 red  12 blue  472 orange  15 pink  0 black  ;
  \
  \ 7 color cr  472 color cr  3000 color cr
  \ ----

  \ _n_ for default must be 0 and the default pair must be
  \ last.  Numbers can be in any order except 0 must be last.
  \ An actual zero or a no match causes the default to be
  \ executed.  Numbers can't be constants.

  \ }doc

  \ vim: filetype=soloforth
  \ flow.begin-execute.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `begin-execute`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( base-execute )

  \ Credit:
  \
  \ Word from Gforth.

: base-execute  ( xt n -- )  base @ >r execute r> base !  ;
  \ Execute _xt_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

  \ vim: filetype=soloforth
  \ flow.begincase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271851

  \ -----------------------------------------------------------
  \ Description

  \ `begincase repeatcase`, an improved version of standard
  \ `case` that repeats like `begin again`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Original code by Ed:
  \ http://dxforth.netbay.com.au/cfsext.html

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10-26: Start.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \ 2016-04-27: Rename `nextcase` to `repeatcase`. Add
  \ `compile-only`.

( begincase )

need cs-push  need cs-pop

: begincase
  postpone case  postpone begin  cs-push
  ; immediate compile-only

: (repeatcase)
  cs-pop  postpone again  postpone endcase  ;

: repeatcase
  postpone drop  postpone (repeatcase)
  ; immediate compile-only

-->

( begincase )

  \ XXX TMP --

: test
  begincase
    cr ." press a key ('2' '4' '9' exits) : " key
    '2' of  ." ... 2 "  endof
    '4' of  ." ... 4 "  endof
    '9' of  ." ... 9 "  endof
      dup emit ."  try again"
  repeatcase  ;

  \ vim: filetype=soloforth
  \ flow.bracket-switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170048

  \ -----------------------------------------------------------
  \ Description

  \ `[switch`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need :noname` and `need pick`, because
  \ those words have been moved from the kernel to the library.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.
  \
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( [switch switch] )

  \ 2015-11-15

  \ Credit:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,  need pick  need >body

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default xt
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched xt. If no match is found, leave _n_ on
  \ the stack and execute the default xt.

: :switch  ( xt "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _xt_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head xt n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _xt_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the xt of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

need :noname  need evaluate

: run:  ( head n "ccc<semicolon>" -- )
  :noname ';' parse evaluate postpone ; ( xt )
  swap >switch  ;

( [switch-test )

  \ without syntactic sugar

need :noname

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test )

  \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

  \ vim: filetype=soloforth
  \ flow.call.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `call`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( call )

code call  ( a -- )

  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next

  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

  \ vim: filetype=soloforth
  \ flow.case.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060116

  \ -----------------------------------------------------------
  \ Description

  \ Several implementations of the standard Eaker's `case`
  \ structure and some variants of `of`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \
  \ 2016-05-06: Replace two remaining `[compile]` with
  \ `postpone`.

( case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: x -- )
  postpone drop  begin  ?dup  while  postpone then  repeat
  ; immediate compile-only

( eforth-case )

  \ Credit:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  postpone then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( 94-doc-case )

  \ Credit:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( abersoft-case )

  \ Credit:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credit:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credit:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credit:
  \
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?  need pick

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credit:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID: <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credit:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

  \ vim: filetype=soloforth
  \ flow.cases-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `cases:` structure, an alternative to the standard `case`.
  \
  \ The `cases:` structure is named.  It's built as an array of
  \ pairs (value and associated vector).  It saves space, but
  \ is slower than standard `case`. The default case of the
  \ structure is mandatory.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code written by Dan Lerner, published on Forth
  \ Dimensions (volume 3, number 6, page 189, 1982-03).

  \ Marcos Cruz (programandala.net), adapted, renamed and
  \ commented the original code, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: First version.
  \ 2016-04-27: Rename `other>` to `othercase>`. Improve
  \ documentation and file header.

( cases: )

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  leave
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10      ." dek"  ;
  \ : say100     ." cent" ;
  \ : say1000    ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>      say10
  \    100 case>      say100
  \   1000 case>      say1000
  \        othercase> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: othercase>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ doc{
  \
  \ othercase>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required,
  \ `othercase> noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.ccase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281721

  \ -----------------------------------------------------------
  \ Description

  \ `ccase` is a positional control structure that uses the
  \ position of a character in a string as key, and has a
  \ mandatory default option at the end.  Data space used
  \ (without requirements): 69 bytes.
  \
  \ `ccase0` is a simpler variant of `ccase` that uses the
  \ first compiled option as a mandatory default option.  Data
  \ space used (without requirements): 44 bytes.
  \
  \ `?ccase` is a simpler variant of `ccase` with no default
  \ option.  Data space used (without requirements): 34 bytes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ `?ccase` was inspired by MMSFORTH's `acase`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-28: Write `?ccase`, `ccase0`.

( ?ccase )

need alias  need char-position?

' >resolve alias end?ccase  immediate compile-only
  \ Compilation: ( C: orig -- )
  \ Run-time: ( -- )

  \ doc{
  \
  \ end?ccase
  \
  \   Compilation: ( C: orig -- )
  \   Run-time: ( -- )
  \
  \ End of a `?ccase` control structure.
  \ See `?ccase` for a usage example.
  \
  \ }doc

: (?ccase)  ( c ca len -- )
  rot char-position? if  2+ cells r@ + perform  then  ;

  \ doc{
  \
  \ (?ccase) ( c ca len -- )
  \
  \ Run-time procedure compiled by `?ccase`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `?ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1).  If _c_ is not in _ca len_, do nothing.
  \
  \ See: `?ccase`.
  \
  \ }doc

: ?ccase
  \ Compilation: ( C: -- orig )
  \ Run-time: ( c ca len -- )
  postpone (?ccase) postpone ahead  ; immediate compile-only

  \ doc{
  \
  \ ?ccase
  \
  \ Compilation: ( C: -- orig ) Run-time: ( c ca len -- )
  \
  \ Start a `?ccase end?ccase` structure. If _c_ is in the string
  \ _ca len_, execute the n-th word compiled after `?ccase`,
  \ where _n_ is the position of the first _c_ in the string
  \ (0..len-1), then continue after `endcase`.  If _c_ is not
  \ in _ca len_, just continue after `end?ccase`.
  \
  \ Usage example:

  \ ----
  \ : .a   ( -- )  ." Letter A"  ;
  \ : .b   ( -- )  ." Letter B"  ;
  \ : .c   ( -- )  ." Letter C"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ?ccase  .a .b .c  end?ccase  ."  The End" cr  ;
  \ ----
  \
  \ }doc

( ccase0 )

need alias  need char-position?

' >resolve alias endccase0  immediate compile-only
  \ Compilation: ( C: orig -- )
  \ Run-time: ( -- )

  \ doc{
  \
  \ endccase0
  \
  \   Compilation: ( C: orig -- )
  \   Run-time: ( -- )
  \
  \ End of a `ccase0` control structure.
  \ See `ccase0` for a usage example.
  \
  \ }doc

: (ccase0)  ( c ca len -- )
  rot char-position? if    ( +n ) 3 +
                           \ character found:
                           \ calculate the cells offset to the option
                     else  2
                           \ character not found:
                           \ leave cells offset to the default option
                     then  cells r@ + perform  ;

  \ doc{
  \
  \ (ccase0) ( c ca len -- )
  \
  \ Run-time procedure compiled by `ccase0`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase0`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1.  If _c_ is not in _ca len_,
  \ execute the word compiled right after `ccase0`.
  \
  \ See: `ccase0`.
  \
  \ }doc

: ccase0
  \ Compilation: ( C: -- orig )
  \ Run-time: ( c ca len -- )
  postpone (ccase0) postpone ahead  ; immediate compile-only

  \ doc{
  \
  \ ccase0
  \
  \ Compilation: ( C: -- orig ) Run-time: ( c ca len -- )
  \
  \ Start a `ccase0 endccase` structure. If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1, then continue after `endcase`.
  \ If _c_ is not in _ca len_, execute the word compiled right
  \ after `ccase0`, then continue after `endccase`.
  \
  \ Usage example:

  \ ----
  \ : .a     ( -- )  ." Letter A"  ;
  \ : .b     ( -- )  ." Letter B"  ;
  \ : .c     ( -- )  ." Letter C"  ;
  \ : .nope  ( -- )  ." Nope!"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ccase0  .nope .a .b .c  endccase0
  \   ."  The End" cr  ;
  \ ----
  \
  \ }doc

( ccase )

need char-position?

: endccase
  \ Compilation: ( C: orig1 orig2 -- )
  \ Run-time: ( -- )
  here cell- swap !
    \ resolve _orig2_, the address of the default option
  >resolve
    \ resolve _orig1_, the branch to `endccase`
  ; immediate compile-only

  \ doc{
  \
  \ endccase
  \
  \   Compilation: ( C: orig1 orig2 -- )
  \   Run-time: ( -- )
  \
  \ End of a `ccase` control structure.
  \ See `ccase` for a usage example.
  \
  \ }doc

: (ccase)  ( c ca len -- )
  rot char-position? if    ( +n ) 3 + cells r@ +
                           \ character found:
                           \ calculate address of the option
                     else  [ 2 cells ] literal r@ + @
                           \ character not found:
                           \ calculate address of the default option
                     then  perform  ;

  \ doc{
  \
  \ (ccase) ( c ca len -- )
  \
  \ Run-time procedure compiled by `ccase`.  If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1).  If _c_ is not in _ca len_,
  \ execute the word compiled right before `endccase`.
  \
  \ See: `ccase`.
  \
  \ }doc

: ccase
  \ Compilation: ( C: -- orig1 orig2 )
  \ Run-time: ( c ca len -- )
  postpone (ccase)  postpone ahead  >mark
  ; immediate compile-only

  \ doc{
  \
  \ ccase
  \
  \ Compilation: ( C: -- orig1 orig2 )
  \ Run-time: ( c ca len -- )
  \
  \ Start a `ccase endccase` structure. If _c_ is in the
  \ string _ca len_, execute the n-th word compiled after
  \ `ccase`, where _n_ is the position of the first _c_ in the
  \ string (0..len-1) plus 1, then continue after `endcase`.
  \ If _c_ is not in _ca len_, execute the word compiled right
  \ after `ccase`, then continue after `endccase`.
  \
  \ Usage example:

  \ ----
  \ : .a     ( -- )  ." Letter A"  ;
  \ : .b     ( -- )  ." Letter B"  ;
  \ : .c     ( -- )  ." Letter C"  ;
  \ : .nope  ( -- )  ." Nope!"  ;
  \
  \ : letter  ( c -- )
  \   s" abc" ccase  .a .b .c .nope  endccase
  \   ."  The End" cr  ;
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.conditionals.negative.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Negative conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch ,
    \ jp z,branch_code ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( -exit )

code -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                   \ pop hl
  CB c, 7C c,             \ bit 7,h ; negative?
  C2 c, ' exit ,          \ jp nz,exit_code
  jpnext                  \ jp next

  end-code

  \ doc{
  \
  \ -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _n_ is negative, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `-exit` is not intended to be used within a do-loop. Use
  \ `0< if unloop exit then` instead.
  \
  \ In Solo Forth `-exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.conditions.zero.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Zero conditionals.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( 0if 0while 0until )

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( 0exit )

code 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                 \ pop hl
  78 04 + c,            \ ld a,h
  B0 05 + c,            \ or l
  CA c, ' exit ,        \ jp z,exit_code
  jpnext                \ jp next

  end-code

  \ doc{
  \
  \ 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _f_ is zero, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `0exit` is not intended to be used within a do-loop. Use
  \ `0= if unloop exit then` instead.
  \
  \ In Solo Forth `0exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.create-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160427

  \ -----------------------------------------------------------
  \ Description

  \ Provide `create:`, a defining word that creates a word
  \ which is compiled as a colon word but, when executed, will
  \ return the address of its pfa.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ The idea for `create:` was borrowed from CP/M-volksForth
  \ 3.80a.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ doc{
  \
  \ create:  ( "name" -- )
  \
  \ Create a word "name" which is compiled as a colon word but,
  \ when executed, will return the address of its pfa.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.dfor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160145

  \ -----------------------------------------------------------
  \ Description

  \ `dfor dstep`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-01: Written, a double-cell variant of `for step`.
  \
  \ 2015-03-23: Renamed `di` to `dfor-i`, after `for-i`,
  \ because `i` cannot be used since the implementation of the
  \ Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header.  Fixed stack
  \ notations.

( dfor dstep di )

: (dstep)  ( R: x d -- x d' )

  \ doc{
  \
  \ (dstep)  ( R: x d -- x d' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( d -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest ) Run-time: ( d -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `dfor-i`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' 2r@ alias dfor-i  ( -- d )

  \ doc{
  \
  \ dfor-i  ( -- d )
  \
  \ Return the current index _d_ of a `dfor` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.dijkstra.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Dijkstra control structures.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming". Originally published
  \ on Forth Dimensions (volume 18, number 4, pp 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh.

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 ?do  postpone then  loop  ; immediate compile-only
  \ end a conditional

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credit:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming" Originally published
  \ on Forth Dimensions (number 18, number 4, pages 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ vim: filetype=soloforth
  \ flow.doer.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170049

  \ -----------------------------------------------------------
  \ Description

  \ Leo Brodie's `doer make` construct.

  \ -----------------------------------------------------------
  \ Credit

  \ Original code by Leo Brodie, 1983, published on _Thinking
  \ Forth_, Appendix A. Public domain.

  \ This version was adapted from PFE by Marcos Cruz
  \ (programanadla.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( doer )

need >body

: doer-noop ;

: doer  ( "name" -- )
  create  ['] doer-noop >body ,  does>  ( pfa ) @ >r ;
  \ Define a word whose behaviour is vectorable.

: (make)
  \ Stuff the address of further code into the parameter field
  \ of a doer word.
  r> dup cell+ dup cell+
    ( a1 a2 a2 )
    \ a1 = address of an optional continuation after `;and`,
    \      or zero
    \ a2 = address of the doer word
    \ a3 = address of the code to associate the doer word with
  swap @ >body !
    \ Get the pfa of the doer word and store the code address
    \ into it.
  @ ?dup if  >r  then ;
    \ Manage the optional continuation after `;and`.

variable >;and
  \ Hold the address of optional continuation pointer.

: make
  \ Used interpretively:
  \   make doer-name forth-code ;
  \ Or inside a definition:
  \   : definition  make doer-name forth-code  ;
  compiling? if     postpone (make)  here >;and ! 0 ,
             else   here ' >body ! ]  then  ; immediate

: ;and  ( -- )  postpone exit  here >;and @ !  ; immediate
  \ Allow continuation of the "making" definition.

: undo  ( "name" -- )  ['] doer-noop >body  ' >body ! ;
  \ Make the doer word "name" safe to execute.

( doer-test )

need doer

doer test
  .( Test 1: ) test
make test  cr ." test 2" ;
  .( Test 2: ) test
: change    make test ." test 3" ;and  test ;
change
  .( Test 3: ) test
undo test
  .( Test 4: ) test

  \ vim: filetype=soloforth
  \ flow.dont.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `don't`

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ flow.dtimes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `dtimes`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

  \ vim: filetype=soloforth
  \ flow.executions.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242017

  \ -----------------------------------------------------------
  \ Description

  \ `executions`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need 2rdrop`, because `2rdrop` has been
  \ moved from the kernel to the library.

( executions )

  \ Credit:
  \
  \ Code from Galope (module times.fs).

need 2rdrop

: executions  ( xt n -- )
  \ Execute _xt_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

  \ vim: filetype=soloforth
  \ flow.for.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604160140

  \ -----------------------------------------------------------
  \ Description

  \ `for step`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Adapted and modified from code written by Garry Lancaster
  \ for Z88 CamelForth, 2001.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-07-06: Adapted from Z88 CamelForth.
  \
  \ 2015-08-14: Checked. Removed the fig-Forth compiler
  \ security.  Moved from the kernel to the library.  Improved
  \ after Gforth: now the index is checked before decrementing
  \ it.  Documented.
  \
  \ 2015-03-23: Added `for-i`, because `i` cannot be used since
  \ the implementation of the Forth-83 `do loop`.
  \
  \ 2016-04-16: Revised. Improved file header. Fixed stack
  \ notations.

( for step )

  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch ,
    \ jp nz,branch_code ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( n -- )
  \
  \ Start of a `for step` loop, that will iterate _n+1_ times,
  \ starting with _n_ and ending with 0.
  \
  \ The current value of the index can be retrieved with
  \ `for-i`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: n -- n' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

need alias

' r@ alias for-i  ( -- n )

  \ doc{
  \
  \ for-i  ( -- n )
  \
  \ Return the current index _n_ of a `for` loop.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.j.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605041254

  \ -----------------------------------------------------------
  \ Description

  \ `j` and `k`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-15: Written.
  \ 2016-04-28: Calculate the secondary entry point of `i`,
  \ instead of using the constant `(i)`, which has been
  \ removed from the kernel.
  \ 2016-05-04: Compact two blocks into one.

( j k )

need [if]

[needed] j [if]

code j  ( -- n|u ) ( R: do-sys1 do-sys2 -- do-sys1 do-sys2 )
  2A c, rp ,  11 c, 3 cells ,  19 c,  C3 c, ' i 3 + ,  end-code
    \ ld hl,(return_stack_pointer)
    \ ld de,3*cell
    \ add hl,de
    \ jp i.hl ; secondary entry point in `i`

[then]

  \ doc{
  \
  \ j  ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
  \
  \ Return a copy _n|u_ of the next-outer loop index.
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE),
  \ Forth-2012 (CORE).  Note: `k` was also in Forth-79
  \ (Reference word set), but returned a signed number.
  \
  \ }doc

[needed] k [if]

code k  ( -- n|u )
  ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  2A c, rp ,  11 c, 6 cells ,  19 c,  C3 c, ' i 3 + ,  end-code
    \ ld hl,(return_stack_pointer)
    \ ld de,6*cell
    \ add hl,de
    \ jp i.hl ; secondary entry point in `i`

[then]

  \ doc{
  \
  \ k  ( -- n|u ) ( R: loop-sys1..loop-sys3 -- loop-sys1..loop-sys3 )
  \
  \ Return a copy _n|u_ of the second outer loop index.
  \
  \ Origin: Forth-83 (Controlled reference words). Note: `k`
  \ was also in Forth-79 (Reference word set), but returned a
  \ signed number.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.options-bracket.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604290244

  \ -----------------------------------------------------------
  \ Description

  \ `options[ ]options` control structure, an alternative to
  \ `case` with single-word options and a specific default
  \ case. The compilation of options is done in interpretation
  \ mode.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit:

  \ `options[` is a port of IsForth's `case:`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-15: Finish porting IsForth's `case:`, with
  \ different names.  In the original code the word `docase`
  \ (called `(options)` in this port) is written in x86
  \ assembler.  It has been rewritten from scratch, without
  \ investigating the assembler code.
  \
  \ 2016-04-29: Improve documentation.

( options[ )

  \ XXX TODO -- alternative version `coptions[`

  \ Data space used: 166 bytes.

variable (default-option)
  \ Execution token of the default option.

variable #options
  \ Number of compiled options.

: default-option ( "name" -- )  ' (default-option) !  ;

  \ doc{
  \
  \ default-option ( "name" -- )
  \
  \ Set the default option "name" of an `options[ ]options`
  \ structure.  It can be anywhere inside the structure.
  \
  \ See `options[` for a usage example.
  \
  \ }doc

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option xt
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  leave then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

  \ doc{
  \
  \ (options)  ( i*x x -- j*x )
  \
  \ Run-time procedure compiled by `options[`.
  \
  \ x = option to search for
  \
  \ }doc

( options[ )

: options[

  \ Compilation: ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of the xt of the default option
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ init number of options
  postpone (options)          \ compile run-time handler
  >mark >mark >mark           ( a1 a2 a3 )
  postpone [                  \ start interpreting options
  ; immediate compile-only

  \ doc{
  \
  \ options[
  \
  \ Compilation: ( -- a1 a2 a3 )
  \
  \ Start an `options[ ]options` structure.
  \
  \ The addresses left on the stack will be resolved by
  \ `]options`:
  \
  \ - a1 = address of exit point
  \ - a2 = address of the xt of the default option
  \ - a3 = address of number of options
  \
  \ Usage example:
  \
  \ ----
  \ : say10      ." dek"   ;
  \ : say100     ." cent"  ;
  \ : say1000    ." mil"   ;
  \ : say-other  ." alia"  ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  ,  ' compile,  1 #options +!  ;

  \ doc{
  \
  \ option  ( x "name" -- )
  \
  \ Compile the action "name" of an option _x_ in an `options[
  \ ]options` control structure.
  \
  \ See `options[` for a usage example.
  \
  \ }doc

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option xt
  >resolve                    \ store exit point
  ]  ;

  \ doc{
  \
  \ ]options  ( a1 a2 a3 -- )
  \
  \ End a `options[ ]options` structure. Resolve the addresses
  \ left by `options[`:
  \
  \ - a1 = address of exit point
  \ - a2 = address of default option xt
  \ - a3 = address of number of options
  \
  \ See `options[` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.positional-case-colon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604092020

  \ -----------------------------------------------------------
  \ Description

  \ `positional-case:`.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code from F83's `case:`, by Henry Laxen and
  \ Michael Perry.

  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-08-11: Adapted.
  \ 2015-11-22: Modified to use `create:`.
  \ 2015-12-14: Renamed to `positional-case:`.
  \ 2016-04-09: Fixed the file header. Documented.

( positional-case: )

need create:

: positional-case:  ( "name" -- )
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;


  \ doc{
  \
  \ positional-case:  ( "name" -- )
  \
  \ Create a positional case word "name". At runtime, "name"
  \ will execute the n-th word compiled in its definition,
  \ depending upon the value on the stack. No range checking.
  \
  \ Usage example:

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ positional-case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.question-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `??`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ?? )

  \ Credit:
  \
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

  \ vim: filetype=soloforth
  \ flow.question-repeat.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281437

  \ -----------------------------------------------------------
  \ Description

  \ An alternative exit point for `begin until` loops.

  \ -----------------------------------------------------------
  \ Credit

  \ Code from the documentation of Forth-2012 and Forth-94.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-03-04: Copy from the Forth-2012 documentation.
  \ 2016-04-28: Fix the stack notation.

( ?repeat )

need cs-pick

: ?repeat  ( C: dest -- dest ) \ Compilation
           ( f -- )            \ Execution
    0 cs-pick   postpone until
  ; immediate

  \ doc{
  \
  \ ?repeat  Compilation: ( C: dest -- dest )
  \          Execution:   ( f -- )
  \
  \ Usage example:

  \ ----
  \ : xx  ( -- )
  \     begin
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag ?repeat  \ Go back to `begin` if flag is false
  \       ...
  \     flag until    \ Go back to `begin` if flag is false
  \     ...
  \   ;
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ flow.recurse.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241816

  \ -----------------------------------------------------------
  \ Description

  \ `recurse`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-05: Written in the kernel.
  \
  \ 2016-04-17: Moved to the library.
  \
  \ 2016-04-24: Fixed with `latestxt`: now it can be used
  \ in words created with `:noname`.

( recurse )

: recurse  ( -- )  latestxt compile,  ; immediate compile-only

  \ doc{
  \
  \ recurse  ( -- )
  \
  \ Append the execution semantics of the current definition to
  \ the current definition.
  \
  \ Origin: Forth-83 (Controlled Reference Words), Forth-94
  \ (CORE), Forth-2012 (CORE).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.retry.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604262145

  \ -----------------------------------------------------------
  \ Description

  \ `retry` and `?retry`: unconditional and conditional
  \ branches to the start of the current definition.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on the article "RETRY, EXIT, and Word-Level
  \ Factoring", by Richard Astle, published on Forth Dimensions
  \ (volume 17, number 4, page 19, 1995-11).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-07: First version.
  \ 2016-04-26: Documented.

( retry ?retry )

need name>body

: retry  ( Compilation: -- ) ( Run-time: -- )
  latest name>body postpone again
  ; immediate compile-only

  \ doc{
  \
  \ retry  ( -- )
  \
  \ Do an unconditional branch to the start of the word.
  \
  \ }doc

: ?retry  ( Compilation: -- ) ( Run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

  \ doc{
  \
  \ : ?retry  ( Compilation: -- ) ( Run-time: f -- )
  \
  \ Do a conditional branch to the start of the word.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.select.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242202

  \ -----------------------------------------------------------
  \ Description

  \ `select`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credit:
  \
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 f )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 f )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Point "              else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  'a'  .(   ) dup emit  select-test
cr  ','  .(   ) dup emit  select-test
cr  '8'  .(   ) dup emit  select-test
cr  '?'  .(   ) dup emit  select-test
cr  'K'  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

  \ vim: filetype=soloforth
  \ flow.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241713

  \ -----------------------------------------------------------
  \ Description

  \ Words to manipulate the control flow
  \ stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( cs-pick cs-roll cs-swap cs-drop )

need alias  need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this:

  \  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  \  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value:
  \  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credit:
  \
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

  \ vim: filetype=soloforth
  \ flow.switch.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `switch`, a case selector with word
  \ lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

  \ flow.thiscase.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271840

  \ -----------------------------------------------------------
  \ Description

  \ `thiscase`, an alternative `case` structure that makes any
  \ calculation easier.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: First version.
  \
  \ 2016-03-24: Rename the words to avoid standard names
  \ `case`, `of` and `endof`.
  \
  \ 2016-04-27: Improve documentation and file header.

( thiscase )

need alias

: ifcase  ( x f -- )
  postpone if  postpone drop  ; immediate compile-only

  \ doc{
  \
  \ ifcase  ( x f -- )
  \
  \ Part of a `thiscase ifcase
  \ exitcase` structure that checks _x_.
  \
  \ See `thiscase` for a usage example.
  \ See also: `exitcase`, `othercase`.
  \
  \ }doc

: exitcase  ( -- )
  postpone exit  postpone then  ; immediate compile-only

  \ doc{
  \
  \ exitcase  ( -- )
  \
  \ Part of a `thiscase ifcase exitcase` structure.
  \
  \ See `thiscase` for a usage example.
  \ See also: `ifcase`, `othercase`.
  \
  \ }doc

' dup alias thiscase  ( x -- x x )

  \ doc{
  \
  \ thiscase  ( x -- x x )
  \
  \ Mark the start of a `thiscase ifcase exitcase` structure
  \ that checks _x_.
  \
  \ See: `ifcase`, `exitcase`, `othercase`.
  \
  \ Usage example:

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;
  \
  \ : test  ( x -- )
  \   thiscase 0 = ifcase  say0  exitcase
  \   thiscase 1 = ifcase  say1  exitcase
  \   thiscase 2 = ifcase  say2  exitcase
  \            othercase say-other  ;
  \ ----
  \
  \ }doc

' drop alias othercase  ( n -- )

  \ doc{
  \
  \ othercase  ( x -- )
  \
  \ Mark the start of the default option of a `thiscase ifcase
  \ exitcase` structure that checks _x_.
  \
  \ See `thiscase` for a usage example.
  \ See also: `ifcase`, `exitcase`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ flow.times.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604161626

  \ -----------------------------------------------------------
  \ Description

  \ `times`, a control flow structure which executes _n_ times
  \ the next word compiled.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ `times` was inspired by cmForth's `repeats`.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Several drafts, with different behaviours
  \ during compilation.
  \
  \ 2016-04-16: Finished. Simplest version. Documented.

( times )

variable times-xt  \ the _xt_ executed by `times`

: times  ( i*x n -- j*x )
  rp@ @  dup cell+ rp@ !  @ times-xt !
  0 ?do  times-xt perform  loop  ; compile-only

  \ doc{
  \
  \ times  ( i*x n -- j*x )
  \
  \ Repeat the next compiled instruction _n_ times.  If _n_ is
  \ zero, continue executing the following instruction.
  \
  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.
  \
  \ Usage example:
  \
  \ ----
  \ : blink  ( -- )  7 0 do  i border  loop  0 border  ;
  \ : blinking  ( -- )  100 times blink  ." Done" cr  ;
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.attributes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to screen attributes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( attr )

need z80-asm need (attr-addr)

code attr ( col line -- b )

  \ Return the color attribute of the given cursor coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  jppushhl

  end-code

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col line -- a )

  \ Return the color attribute address of the given cursor
  \ coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  jppushhl

  end-code

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  \ Address of a Z80 routine that calculates the color
  \ attribute address of a cursor position.  This is a modified
  \ version of the ROM routine at 0x2583.

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

  \ vim: filetype=soloforth
  \ graphics.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words which manipulate screen blocks
  \ (windows)

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( clear-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code clear-block  ( column row width height -- )

  \ doc{
  \
  \ clear-block  ( column row width height -- )
  \
  \ Clear a screen block at the given character coordinates and
  \ of the given size in characters.  Only the bitmap is
  \ cleared. The color attributes remain unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+6 = column
    \ ; ix+4 = row
    \ ; ix+2 = width
    \ ; ix+0 = height

  #4 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #6 ix orx
    \ ld a,(ix+4) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+6) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a
  #2 ix c ftx  #0 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+2) ; width
    \ ld a,(ix+0) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  0 hl ldp#  sp addp  #4 cells de ldp#  de addp  ldsp
    \ djnz delete_bitmap
    \ ; Drop the parameters:
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( color-block )

  \ Credit:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code color-block  ( column row width height color -- )

  \ doc{
  \
  \ color-block  ( column row width height color -- )
  \
  \ Color a screen block at the given character coordinates and
  \ of the given size in characters.  Only the color attributes
  \ are changed; the bitmap remains unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
  #2 ix b ftx  #4 ix c ftx
    \ ld b,(ix+2) ; height
    \ ld c,(ix+4) ; width
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( wipe-block )

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code wipe-block  ( column row width height color -- )

  \ doc{
  \
  \ wipe-block  ( column row width height color -- )
  \
  \ Wipe a screen block at the given character coordinates and
  \ of the given size in characters.  The bitmap is erased and
  \ the color attributes are changed with the given color.
  \
  \ This word is written in assembler and it combines the
  \ functions of `clear-block` and `color-block`. It may be
  \ defined also this way (with slower but much smaller code):

  \ ----
  \ : wipe-block  ( column row width height color -- )
  \   >r 2over 2over clear-block r> color-block  ;
  \ ----

  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #8 ix orx
    \ ld a,(ix+6) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+8) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a ; DE = top left address of the block
  #4 ix c ftx  #2 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+4) ; width
    \ ld a,(ix+2) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  -->
    \ djnz delete_bitmap

( wipe-block )

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld  #2 ix b ftx
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
    \ ld b,(ix+2) ; height
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.circle.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201603311653

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw circles.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( circle )

  \ XXX UNDER DEVELOPMENT

  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( gx gy radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

  \ vim: filetype=soloforth
  \ graphics.cls.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that clear the screen with special
  \ effects.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( cls-chars0 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Anselmo Moreno
  \ Lorente, published on Microhobby, issue 121 (1987-03), page
  \ 7:
  \
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code cls-chars0  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( cls-chars1 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code cls-chars1  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin
      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
    z until

  step

  bc pop  jpnext  end-code

( horizontal-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color attribute _b_ from the
  \ top and bottom rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credit:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.display.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604101641

  \ -----------------------------------------------------------
  \ Description

  \ Words to save and restore the display status, in order to
  \ call ROM routines that prints to the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( nonfull-display full-display save-display restore-display )

: nonfull-display  ( -- )  2 23659 c!  ;

  \ doc{
  \
  \ nonfull-display  ( -- )
  \
  \ Set the nonfull screen mode: 2 lines in the lower screen
  \ and 22 lines in the upper main screen, which is the default
  \ configuration in BASIC.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: full-display  ( -- )  0 23659 c!  ;

  \ doc{
  \
  \ full-display  ( -- )
  \
  \ Set the full screen mode: no lines in the lower screen,
  \ thus 24 lines in the upper main screen, which is the
  \ default configuration in Solo Forth.
  \
  \ }doc

  \ Note: 23659 is the system variable DF_SZ (lines in the
  \ lower screen).

: save-display  ( -- ) ( R: -- col row )
  r> xy 2>r >r save-mode nonfull-display  ;

  \ doc{
  \
  \ save-display  ( -- ) ( R: -- col row )
  \
  \ Save the status of the display.  This word is intended to
  \ be used before calling a ROM routine that uses the display.
  \ The display can be restored to its previous status with
  \ `restore-display`.
  \
  \ }doc

: restore-display  ( -- ) ( R: col row -- )
  display full-display restore-mode  r> 2r> at-xy >r  ;

  \ doc{
  \
  \ restore-display  ( -- ) ( R: col row -- )
  \
  \ Restore the status of the display, saved by `save-display`.
  \ Intended to be used after calling a ROM routine that uses
  \ the display.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.g-emit.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604231907

  \ -----------------------------------------------------------
  \ Description

  \ Words to print characters at high resolution coordinates.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-03: First version.

  \ 2016-04-23: Rename "hires-" prefix to "g-". Rename
  \ `g-emit-udg` to `g-emit-0udg`, because zero-index is used,
  \ instead of the default UDG char codes 128..255. Add
  \ `g-emit-udg` for codes 128..255. Improve documentation.
  \ First versions of `g-emitted` and `g-cr`.

( g-emit g-type )


  \ XXX TODO -- `g-emit` use the current coordinates

need z80-asm  need g-emit-routine  need g-emit-udg
need os-chars  need os-coords  need g-emitted

code (g-emit)  ( c -- )

  hl pop  l a ld
  bc push
  os-coords bc ftp
  os-chars de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit  ( c -- )
  \
  \ Display character _c_ (32..127) at the current graphic
  \ coordinates.
  \
  \ The character is printed with overprinting (equivalent to `1
  \ overprint`).
  \
  \ }doc

: g-emit  ( c -- )
  dup 127 > if  g-emit-udg  else  (g-emit)  then
  g-emitted  ;

  \ XXX TODO -- update the coordinates

  \ doc{
  \
  \ g-emit  ( gx gy c -- )
  \
  \ Display character _c_ (32..255) at the current graphic
  \ coordinates.  If _c_ is 32..127, it is printed from the
  \ main font.  If _c_ is 128..255, it is printed from the UDG
  \ font.
  \
  \ The character is printed with overprinting (equivalent to `1
  \ overprint`).
  \
  \ }doc

: g-type  ( ca len -- )
  bounds ?do  i c@ g-emit  loop  drop  ;

  \ doc{
  \
  \ g-type  ( ca len -- )
  \
  \ If _len_ is greater than zero, display the character string
  \ _ca len_ at the current graphic coordinates.
  \
  \ }doc

( g-cr g-emitted )

  \ XXX UNDER DEVELOPMENT

need g-x  need g-y
need g-at-x  need g-at-y
need c+!  need c-!

: g-cr  ( -- )
  0 g-at-x  8 (g-y) c-!  g-y 6 > ?exit  191 g-at-y  ;

  \ Move the graphic coordinates to the next printing
  \ position.

: g-emitted  ( -- )
  8 (g-x) c+!  g-x [ 255 6 - ] literal < ?exit  g-cr  ;

  \ Update the current graphic coordinates after printing a
  \ character at them. See `g-emit`, `g-cr`.

( g-emit-0udg )

need z80-asm  need g-emit-routine  need os-udg  need os-coords

code g-emit-0udg  ( gx gy b -- )

  hl pop  l a ld
  bc push
  os-coords bc ftp
  os-udg de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit-0udg  ( gx gy b -- )
  \
  \ Display UDG _b_ (0..255) at the current graphic
  \ coordinates, from the font pointed by system variable
  \ `os-udg`, which contains the address of the first UDG
  \ bitmap (0).
  \
  \ The UDG character is printed with overprinting (equivalent
  \ to `1 overprint`).
  \
  \ }doc

( g-emit-udg )

need z80-asm  need g-emit-routine  need os-udg  need os-coords

code g-emit-udg  ( c -- )

  hl pop  l a ld  80 sub#
  bc push
  os-coords bc ftp
  os-udg de ftp
  g-emit-routine call
  bc pop  next ix ldp#  jpnext
  end-code

  \ doc{
  \
  \ g-emit-udg  ( gx gy c -- )
  \
  \ Display UDG _c_ (127..255) at the current graphic
  \ coordinates, from the font pointed by system variable
  \ `os-udg`, which contains the address of the first UDG
  \ bitmap (127).
  \
  \ The UDG character is printed with overprinting (equivalent
  \ to `1 overprint`).
  \
  \ }doc

( g-emit-routine )

need z80-asm  need (pixel-addr)

  \ Credit:
  \
  \ Code Adapted from "Smooth Move",
  \ written by Simon N. Goodwin,
  \ published on Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create g-emit-routine  ( -- a )

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

  \ doc{
  \
  \ g-emit-routine  ( -- a )
  \
  \ Address of a machine code routine that prints an 8x8 bits
  \ charater at graphic coordinates. Used by `g-emit-udg`
  \ and `g-emit-0udg`.
  \
  \ Input registers:
  \
  \ - DE = address of the first char (0) bitmap in a charset
  \ - A = char code (0..255)
  \ - B = y coordinate
  \ - C = x coordinate
  \
  \ Modifies: AF BC HL IX DE
  \
  \ }doc

  \ vim: filetype=soloforth
  \ graphics.g-xy.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604231943

  \ -----------------------------------------------------------
  \ Description

  \ Words to manage the graphic coordinates.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-23: First version.

( g-x g-y g-xy g-at-x g-at-y g-at-xy g-home )

need os-coords  need os-coordx  need os-coordy  need alias

' os-coords alias (g-xy)
' os-coordx alias (g-x)
' os-coordy alias (g-y)

: g-x  ( -- gx )  (g-x) c@  ;
: g-y  ( -- gy )  (g-y) c@  ;

: g-xy  ( -- gx gy )  g-x g-y  ;

: g-at-x  ( gx -- )  (g-x) c!  ;
: g-at-y  ( gy -- )  (g-y) c!  ;

: g-at-xy  ( gx gy -- )  g-at-y g-at-x  ;

: g-home  ( -- )  (g-xy) off  ;

  \ vim: filetype=soloforth
  \ graphics.lines.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605070026

  \ -----------------------------------------------------------
  \ Description

  \ Words to draw lines.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Make block titles compatible with `indexer`.

( rdraw )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( gx gy -- )

  \ Draw a line relative to the current coordinates.
  \
  \ gx gy = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

( (rdraw )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- finish adapting the DRAW-LINE ROM routine

need z80-asm

create (rdraw
asm


  \  ld      a,c
  \  cp      b
  \  jr      nc,dl_x_ge_y
  \
  \  ld      l,c
  \  push    de
  \  xor     a
  \  ld      e,a
  \  jr      dl_larger
  \
  \ dl_x_ge_y:
  \  or      c
  \  ret     z
  \
  \  ld      l,b
  \  ld      b,c
  \  push    de
  \  ld      d,$00
  \
  \ dl_larger:
  \  ld      h,b
  \  ld      a,b
  \  rra
  \
  \ d_l_loop:
  \  add     a,l
  \  jr      c,d_l_diag
  \
  \  cp      h
  \  jr      c,d_l_hr_vt
  \
  \ d_l_diag:
  \  sub     h
  \  ld      c,a
  \  exx
  \  pop     bc
  \  push    bc
  \  jr      d_l_step
  \
  \ d_l_hr_vt:
  \  ld      c,a
  \  push    de
  \  exx
  \  pop     bc
  \
  \ d_l_step:
  \  ld      hl,($5c7d) ; coords
  \  ld      a,b
  \  add     a,h
  \  ld      b,a
  \  ld      a,c
  \  inc     a
  \  add     a,l
  \  jr      c,d_l_range
  \  jr      z,report_bc ; XXX TODO -- adapt, integer out of range
  \
  \ d_l_plot:
  \  dec     a
  \  ld      c,a
  \  call    l22e5      ; routine plot-sub \ XXX TODO
  \ XXX TODO -- replace `call PLOT-SUB` with `call PLOT-SUB+7`
  \  exx
  \  ld      a,c
  \  djnz    d_l_loop
  \
  \  pop     de
  \  ret
  \
  \ d_l_range:
  \  jr      z,d_l_plot

end-asm

( adraw )

  \ Credit:
  \
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot  need os-coordx  need os-coordy

2variable x1  2variable incx  2variable y1  2variable incy

: adraw  ( gx gy -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  [ os-coordy ] literal c@ ( y0 )
  dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )

  [ os-coordx ] literal c@ ( x0 )
  dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )

  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then

  -->

( adraw )

  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

  \ vim: filetype=soloforth
  \ graphics.ocr.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that recognize characters on the
  \ screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( ocr )

  \ Credit:
  \
  \ Adapted from anonymous code published on Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  jppushhl  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

need os-chars  need os-udg

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  os-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ set pointed by the system variable UDG.
  os-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

  \ vim: filetype=soloforth
  \ graphics.pixels.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604071548

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate pixels.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( gx gy -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

\ (pixel-addr) \

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( gx gy -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credit:
  \
  \ Author of the original code: Jos Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( gx gy -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credit:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( gx gy -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( gx gy -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true jpnz
  ' false jp
  end-code

( pixels )

need z80-asm

code pixels  ( -- u )

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code

  \ doc{
  \
  \ pixels  ( -- u )
  \
  \ Number of pixels set on the screen.
  \
  \ }doc

  \ 26 bytes used.

  \ Credit:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret

( slow-pixels )

  \ Slower version of `pixels`.

need bits
: pixels  ( -- u )  16384 6144 bits  ;

  \ vim: filetype=soloforth
  \ graphics.screen_filters.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words that make filter effects to the
  \ whole screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credit:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 46: <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credit:
  \
  \ Code adapted from a routine written by Javier Granadino,
  \ published on Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credit:
  \
  \ Code adapted from a routine written by Juan Jos Rivas,
  \ published on Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
           begin   m rrc  hl decp  h 6 bit  z until
  step

  bc pop  jpnext

  end-code

  \ vim: filetype=soloforth
  \ graphics.scroll.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words to scroll the screen.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( scroll-1px-right )

  \ Credit:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
    m srl  hl incp  \ first char column
    1F b ld#  \ remaining columns
    begin   m rr  hl incp  step
    c dec
  z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credit:
  \
  \ Code adapted from a routine written by Ivn Sansa,
  \ published on Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

  \ vim: filetype=soloforth
  \ graphics.udg.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604231622

  \ -----------------------------------------------------------
  \ Description

  \ Words to define User Defined Graphics.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-23: Add `0udg:`. Factor `0udg!` from `udg!`.
  \ Improve the documentation.
  \
  \ 2016-04-24: Add `udg[` and `0udg[`.

( 0udg! udg! 0udg: udg: )

need os-udg

: 0udg!  ( b0..b7 n -- )
  8 * os-udg @ + dup 7 + do  i c!  -1 +loop  ;

  \ doc{
  \
  \ udg!  ( b0..b7 n -- )
  \
  \ Store the given 8 bytes into UDG number _n_ (0..127).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg!  ( b0..b7 c -- )  128 - 0udg!  ;

  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into UDG char _c_ (128..255).
  \
  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;

  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant "name" for UDG char _c_ (128..255) and
  \ store the given 8 bytes into that UDG char.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

: 0udg:  ( b0..b7 n "name" -- )  dup constant 0udg!  ;

  \ doc{
  \
  \ 0udg:  ( b0..b7 n "name" -- )
  \
  \ Create a constant "name" for UDG number _n_ (0..127) and
  \ store the given 8 bytes into UDG char _128+n_.

  \ - b0 = first (top) scan
  \ - b7 = last (bottom) scan
  \
  \ }doc

( 0udg[ udg[ )

need os-udg

variable first-udg
variable current-udg
variable current-scan

[defined] binary ?\  : binary  ( -- )  2 base !  ;

: 0udg[  ( b -- )
  dup first-udg !  current-udg !  current-scan off  binary  ;

  \ doc{
  \
  \ 0udg[  ( b -- )
  \
  \ Start a set of UDG definitions, from UDG number _b_
  \ (0..255).
  \
  \ See: `udg[`, `|`, `||`, `||]`.
  \
  \ }doc

: udg[  ( c -- )  128 - 0udg[  ;

  \ doc{
  \
  \ udg[  ( c -- )
  \
  \ Start a set of UDG definitions, from UDG character _c_
  \ (128..255).
  \
  \ See: `0udg[`, `|`, `||`, `||]`.
  \
  \ Usage example:
  \
  \ ----
  \ 140 udg[  \ define UDG 140..144
  \
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01011110 ||
  \ 11111111 | 11111111 | 11111111 | 10111111 | 10111111 ||
  \ 11111111 | 11111111 | 10111111 | 10111111 | 11111111 ||
  \ 11111111 | 10111111 | 10111111 | 11111111 | 11111111 ||
  \ 11001111 | 11011111 | 11111111 | 11111111 | 11111111 ||
  \ 01111110 | 01111110 | 01111110 | 01111110 | 01111110 ||
  \ 00111100 | 00111100 | 00111100 | 00111100 | 00111100 ||]
  \ ----
  \
  \ }doc

: |  ( b -- )
  os-udg @ current-udg @ 8 * current-scan @ + + c!
  1 current-udg +!  ;

  \ doc{
  \
  \ |  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined.
  \
  \ See: `0udg[`, `udg[`, `||`, `||]`.
  \
  \ }doc

: || ( b -- )
  |  1 current-scan +!  first-udg @ current-udg !  ;

  \ doc{
  \
  \ || ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and start
  \ a new row of scans.
  \
  \ See: `0udg[`, `udg[`, `|`, `||]`.
  \
  \ }doc


: ||]  ( b -- )  ||  decimal  ;

  \ doc{
  \
  \ ||]  ( b -- )
  \
  \ Store scan _b_ into the current UDG being defined and stop
  \ defining UDGs.
  \
  \ See: `0udg[`, `udg[`, `|`, `||`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ keyboard.casp_lock.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words related to manipulate caps lock.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( capslock )

need os-flags2
need c!toggle-bits  need c@test-bits
need c!reset-bits   need c!reset-bits

%1000 os-flags2 2constant capslock
  \ Bit and system variable that control the capslock.

: toggle-capslock  ( -- )    capslock c!toggle-bits  ;
: set-capslock     ( -- )    capslock c!set-bits  ;
: unset-capslock   ( -- )    capslock c!reset-bits  ;
: capslock?        ( -- f )  capslock c@test-bits 0<>  ;

  \ vim: filetype=soloforth
  \ keyboard.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605132207

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the keyboard.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.

( at-accept clear-accept set-accept )

  \ XXX UNDER DEVELOPMENT
  \ Common code for several versions of `accept`
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

2variable accept-xy       \ coordinates of the edited string
  \ doc{
  \
  \ accept-xy  ( -- a )
  \
  \ A double variable that holds the cursor position at the
  \ start of the most recent `accept`.
  \
  \ }doc

variable accept-buffer    \ address of the edited string
  \ doc{
  \
  \ accept-buffer  ( -- a )
  \
  \ A variable that holds the buffer address used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable /accept          \ max length of the edited string
  \ doc{
  \
  \ /accept  ( -- a )
  \
  \ A variable that holds the buffer max length used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable >accept          \ offset to the cursor position
  \ doc{
  \
  \ >accept  ( -- a )
  \
  \ A variable that holds the offset of the cursor in the
  \ string being edited by `accept`.
  \
  \ }doc

: at-accept  ( -- )  accept-xy 2@ at-xy  ;
  \ doc{
  \
  \ at-accept  ( -- )
  \
  \ Set the cursor position at the start of the most recent
  \ `accept`.
  \
  \ }doc

: clear-accept  ( -- )
  at-accept span @ spaces at-accept  span off  ;
  \ doc{
  \
  \ clear-accept ( -- )
  \
  \ Clear the string currently edited by `accept`.
  \
  \ }doc

: set-accept  ( ca1 len1 -- ca1' )
  clear-accept /accept @ min  ( ca1 len1' )
  dup span ! 2dup system-bank type default-bank
  dup >r
  accept-buffer @  ( ca1 len1' ca2 )
  smove accept-buffer @  ( ca2 )
  r> +  ( ca1' )  ;
  \ doc{
  \
  \ set-accept  ( ca1 len1 -- ca1' )
  \
  \ Set string _ca len_ as the string being edited by `accept`.
  \ Return the address _ca1'_ after its last character.
  \
  \ }doc

( acceptx )

  \ XXX UNDER DEVELOPMENT
  \
  \ Alternative version of `accept` with more editing features
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

need at-accept  need set-accept

: .acceptx  ( -- )

  accept-buffer @ >accept @ at-accept type
    \ Print the start of the string, before the cursor.

  1 inverse  >accept @ span @ <
  if accept-buffer @ >accept @ + c@ emit  else  space  then
  0 inverse
    \ Print the cursor.

  accept-buffer @ span @ >accept @ 1+ min /string type
    \ Print the end of the string, after the cursor.
  ;

-->

( acceptx )

need toggle-capslock

: accept-edit  ( -- )  clear-accept init-accept  ;
: accept-left  ( -- )  ;
: accept-right  ( -- )  ;
: accept-up  ( -- )  ;
: accept-down  ( -- )  ;
: accept-delete  ( -- )  ;

create accept-commands ] noop noop noop noop noop noop
toogle-capslock accept-edit accept-left accept-right
accept-down accept-up accept-delete noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop [

: >accept-command  ( c -- a )  cells accept-commands +  ;
: accept-command  ( c -- )  >accept-command perform  ;

-->

( acceptx )

: init-acceptx  ( ca len -- )
  /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;

: (acceptx) ( ca len -- len' )  2dup init-accept

  over + over ( bot eot cur )
  begin  key dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;  -->

( acceptx )

: acceptx ( ca len -- len' )
  span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;

  \ XXX TMP -- for debugging

: ax  ( -- )  ['] acceptx ['] accept defer!  ;
: a0  ( -- )  ['] default-accept ['] accept defer!  ;

( nuf? )

  \ Credit:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29, 1988-05).

need aborted?  need 'cr'

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's _c_, else return _false_.
  \
  \ This word is a useful factor of `nuf?`.
  \
  \ Usage example:
  \
  \ ----
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \ ----
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( kk-ports kk, kk@ )

  \ Adapted from Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \
  \ "kk" stands for "keyboard key". This notation was chosen
  \ first in order to prevent future name clashes with standard
  \ words which uses the "k-" prefix, and second because these
  \ words manage only physical keys of the keyboard, not key
  \ combinations.
  \
  \ -----------------------------------------------------------

  \ There are two versions of `kk,` and `kk@`. They depend on
  \ the value of `/kk`, a constant that holds the bytes
  \ ocuppied by every key in `kk-ports`, 3 or 4.
  \
  \ The application must define `/kk` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/kk 3 <> dup

?\ : kk,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `kk@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/kk 4 <> dup

?\ : kk,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( kk-ports )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2
$04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4
$10 $F7FE 2constant kk-5

$01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w
$04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r
$10 $FBFE 2constant kk-t

$01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s
$04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f
$10 $FDFE 2constant kk-g

$01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z
$04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c
$10 $FDFE 2constant kk-v

-->

( kk-ports )

$01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9
$04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7
$10 $EFFE 2constant kk-6

$01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o
$04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u
$10 $DFFE 2constant kk-y

$01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l
$04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j
$10 $BFFE 2constant kk-h

$01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss
$04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n
$10 $7FFE 2constant kk-b

-->

( kk-ports )

  \ This table contains the key double constants (port and
  \ bitmak) of all keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

need kk,

40 constant keys

create kk-ports

kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,
kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,
kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,
kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,
kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,
kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,
kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,
kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,

( kk-1# )

  \ Key number constants, to be used as indexes of the key
  \ tables.

need enum

0
enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#
enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#
enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#
enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#
enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#
enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#
enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#
enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#
drop

( kk-chars )

  \ This table contains the chars used as names of the keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

  \ By default, the first 4 UDG are used for keys whose names
  \ are not a printable char:
  \
  \ 128 = Caps Shift
  \ 129 = Enter
  \ 130 = Space
  \ 131 = Symbol Shift

create kk-chars

'1' c,  '2' c,  '3' c,  '4' c,  '5' c,
'q' c,  'w' c,  'e' c,  'r' c,  't' c,
'a' c,  's' c,  'd' c,  'f' c,  'g' c,
128 c,  'z' c,  'x' c,  'c' c,  'v' c,
'0' c,  '9' c,  '8' c,  '7' c,  '6' c,
'p' c,  'o' c,  'i' c,  'u' c,  'y' c,
129 c,  'l' c,  'k' c,  'j' c,  'h' c,
130 c,  131 c,  'm' c,  'n' c,  'b' c,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need kk-ports

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need kk-ports

0. 2variable kk-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. kk-pressed 2! \ none by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed?
  if  kk-pressed 2@ + if
  then
  /kk +loop
  kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ vim: filetype=soloforth
  \ keyboard.get-inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-inkey )

  \ Credit:
  \
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code get-inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

  \ vim: filetype=soloforth
  \ keyboard.get-key-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `get-key?` and `fast-get-key?`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false jp

  end-code

( fast-get-key? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code fast-get-key?  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false jp

  end-code

  \ keyboard.inkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `inkey`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

  \ vim: filetype=soloforth
  \ keyboard.yes-question.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Words for "yes/no" questions.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( y/n? y/n no? yes? )

  \ Credit:
  \
  \ Code adapted from Afera.

need value

'Y' value "y"  'N' value "n"
  \ Default (uppercase) letters for "yes" and "no".

: y/n?  ( c -- f )  dup "y" = swap "n" = or  ;
  \ Is the given (uppercase) char _c_
  \ a valid answer for a "y/n" question?

: y/n  ( -- c )
  begin  key upper dup y/n? 0=  while  drop  repeat  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return its code.

: no?  ( -- f )  y/n "n" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "no",
  \ else return _false_.

: yes?  ( -- f )  y/n "y" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "yes",
  \ else return _false_.

  \ vim: filetype=soloforth
  \ locals.anon.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170056

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of locals using an array of anonymous
  \ variables.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code written by Leonard Morgenstern, published on
  \ Forth Dimensions (volume 6, number 1, page 33, 1984-05).
  \
  \ Adapted, modified, improved and commented by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Adapted from the original code.
  \ 2016-04-09: Fixed the file header.
  \ 2016-05-17: Need `body>`, which has been moved to the
  \ library.

( create-anon anon +anon n>anon )

need body>

variable (anon)  ( -- a )
  \ xt of the latest anonymous variable.

: create-anon  ( -- )
  here (anon) !
  [ (anon) body> @ ] literal compile, 0 ,  ;
  \ Create a new anonymous variable.  `(anon)` is used to get
  \ and compile the xt executed by all variables.

: anon  ( Compilation: -- ) ( Run-time: -- a )
  (anon) @
  compiling? if  compile,  else  execute  then  ; immediate
  \ Current anonymous variable (first cell),
  \ equivalent to `0 +anon`.

: +anon  ( Compilation:  n -- ) ( Run-time: -- )
  cells (anon) @ execute +
  compiling? if  postpone literal  then ; immediate
  \ Current anonymous variable (cell _n_, first is 0).

: n>anon  ( x1..xn n -- )
  cells postpone anon swap bounds do  i !  cell +loop  ;
  \ Store the given _n_ cells into the current anonymous
  \ variable.

  \ Usage example:

  \ create-anon 5 cells allot
  \
  \ : test
  \   400 300 200 100 000  5 n>anon
  \   anon ?          \ prints 0
  \   123 anon !
  \   anon ?          \ prints 123
  \   [ 2 ] +anon ?   \ prints 200
  \   555 [ 2 ] +anon !
  \   [ 2 ] +anon ?   \ prints 555
  \   ;

  \ vim: filetype=soloforth
  \ locals.arguments.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604091850

  \ -----------------------------------------------------------
  \ Description

  \ An implementation of nestable locals, with a predefined set
  \ of ten variables which return their contents.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Marc Perkel, published on Forth Dimensions
  \ (volume 3, number 6, page 185, 1982-03).
  \
  \ Adapted to Solo Forth and improved by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Start.
  \ 2016-04-09: Fixed, improved, renamed, documented, finished.

( arguments results )

need cell/

variable >args
  \ address of the current arguments in the data stack

create arg-actions ] @ ! +! [
  \ execution table of the argument actions

variable arg-action  arg-action off
  \ id (offset) of the argument action:
  \ 0 = fetch; 2 (1 cell) = store; 4 (2 cells) = add

: arg:  ( +n "name" -- )
  create  c,
  does>  ( -- x ) ( x -- )
    \ ( pfa | x pfa )
    c@ >args @ swap -
    arg-action @ arg-actions + perform  arg-action off  ;
  \ create a new argument "name" with offset _+n_

$00 arg: l0 $02 arg: l1 $04 arg: l2 $06 arg: l3 $08 arg: l4
$0A arg: l5 $0C arg: l6 $0E arg: l7 $10 arg: l8 $12 arg: l9

-->

( arguments results )

: toarg  ( -- )  cell arg-action !  ;

  \ doc{
  \
  \ toarg  ( -- )
  \
  \ Set the store action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: +toarg  ( -- )  [ 2 cells ] literal arg-action !  ;

  \ doc{
  \
  \ +toarg  ( -- )
  \
  \ Set the add action for the next local variable. Used with
  \ locals created by `arguments`.  See `arguments` for a usage
  \ example.
  \
  \ }doc

: arguments  ( i*x +n -- j*x )
  r> >args @ >r >r
  cells sp@ + dup >args ! [ 10 cells ] literal - sp@ swap -
  cell/ 0 do  0  loop  ; compile-only

  \ doc{
  \
  \ arguments  ( i*x +n -- j*x )
  \
  \ Define the number _+n_ of arguments to take from the stack
  \ and assign them to the first local variables from `l0` to
  \ `l9`.
  \
  \ The local variables are modified with `toarg`, `+toarg`,
  \ and returned  with `results`.
  \
  \ Example: The phrase `3 arguments` assigns the names of
  \ local variables `l0` through `l9` to ten stack positions,
  \ with `l0`, `l1` and `l2` returning the top 3 stack values
  \ that were there before `3 arguments` was executed. `l3`
  \ through `l9` are zero-filled and the stack pointer is set
  \ to just below `l9`.
  \
  \ `l0` through `l9` act as local variables returning their
  \ contents, not their addresses.  To write them you precede
  \ them with the word `toarg`. For example `5 toarg l4` writes
  \ a 5 into `l4`. Execution of `l4` returns 5 to the stack.
  \
  \ After all calculating is done, the phrase `3 results`
  \ leaves that many results on the stack relative to the stack
  \ position when `arguments` was executed. All intermediate
  \ stack values are lost, which is good because you can leave
  \ the stack "dirty" and it doesn't matter.
  \
  \ Usage example:

  \ ----
  \ : test  ( length width height -- length' volume surface )
  \   3 arguments
  \   l0 l1 * toarg l5       \ surface
  \   l5 l2 * toarg l4       \ volume
  \   $2000 +toarg l0        \ length+$2000
  \   l4 toarg l1            \ volume
  \   l5 toarg l2            \ surface
  \   3 results  ;
  \ ----

  \ }doc

: results  ( +n -- )
  cells >args @ swap - sp@ -
  cell/ 0 do  drop  loop
  r> r> >args ! >r  ; compile-only

  \ doc{
  \
  \ results  ( +n -- )
  \
  \ Define the number _+n_ of local variables to leave on the
  \ stack as results. Used with locals created by `arguments`.
  \ See `arguments` for a usage example.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ locals.local.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170051

  \ -----------------------------------------------------------
  \ Description

  \ A simple solution to use an ordinary variable as local,
  \ saving its current value on the return stack and restoring
  \ it at the end.

  \ -----------------------------------------------------------
  \ Authors

  \ Original code by Henning Hanseng, published on Forth
  \ Dimensions (volume 9, number 5, page 6, 1988-01).
  \
  \ Adapted by Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-14: Adapted from the original code.
  \
  \ 2016-03-24: An alternative implementation with `:noname`.
  \
  \ 2016-04-24: Add `need :noname`, because `:noname` has been
  \ moved from the kernel to the library.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( local )

need :noname  need >body

:noname  \ Compilation: ( -- xt )
         \ Run-time:    ( -- ) ( R: a x -- )
  2r> swap !  ;
  \ Restore variable address _a_ and value _x_.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token to restore the variable
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap                     \ save top return address
  dup @ 2>r                   \ save variable address and value
  [ dup >body ] literal >r    \ force exit via `restore-local`
  >r  ;                       \ restore top return address
  compile-only

  drop  \ delete xt

  \ doc{
  \
  \ local  ( a -- )
  \
  \ Save the value of variable _a_, which will be restored at
  \ the end of the current definition.
  \
  \ Usage example:

  \ ----
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value
  \ ----
  \
  \ }doc

( local )

  \ XXX OLD
  \ 2015-11-14: First port of the original.

: (restore-local)  ( -- )  ( R: a x -- )  2r> swap !  ;
  \ Restore value _x_ of variable _a_.
  \ Can not be used directly.

: local  \ Compilation: ( xt -- xt )
         \ Run-time: ( a0 -- ) ( R: a1 -- a0 x pfa a1 )
           \ xt  = execution token of `restore-local`
           \ a0  = address of a variable
           \ x   = its current value
           \ a1  = return address
           \ pfa = pfa of `restore-local`
  r> swap  dup @ 2>r
    \ save return address
    \ save variable address and value
  ['] (restore-local) >body >r  >r  ;  compile-only
    \ force exit via `(restore-local)`
    \ restore return address

  \ vim: filetype=soloforth
  \ math.calculator.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604201956

  \ -----------------------------------------------------------
  \ Description

  \ ROM calculator support.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development, as part of the
  \ floating-point module.
  \
  \ 2016-04-11: Revision. Code reorganized. Improvements.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Extracted the code from the floating-point
  \ module, in order to reuse it. Much improved. Added `if then
  \ else`. Added `int`.
  \
  \ 2016-04-20: Improved `2dup`. Commented out `=`, `<>`, `<`,
  \ `<=`, `>` and `>=`, which can not be used yet.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Move the stack and make it configurable. The
  \ default location is limited by the small free memory left
  \ to BASIC.
  \
  \ XXX FIXME -- When the calculator stack is out of bounds,
  \ the calculator could issue a BASIC error and crash the
  \ system. Test it.
  \
  \ XXX TODO -- Add more control structures.
  \
  \ XXX TODO -- Test everything.
  \
  \ XXX TODO -- Document.
  \

( calculator )

need alias

wordlist constant calculator-wordlist

: calculator  ( -- )
  calculator-wordlist >order  $C5 c, $EF c,  ;
  \ Add `calculator-wordlist` to the search order and
  \ compile the assembler instructions to start the ROM
  \ calculator:
  \ ----
  \ push bc ; save the Forth IP
  \ rst $28 ; call the ROM calculator
  \ ----

calculator-wordlist >order
get-current  calculator-wordlist set-current

: end-calc  ( -- )  $38 c,  ;
  \ Compile the `end-calc` ROM calculator command.
  \ ----
  \ db $38 ; exit the ROM calculator
  \ ----

: end-calculator  ( -- )  previous end-calc $C1 c,  ;
  \ Restore the search order and
  \ compile the assembler instructions to exit the ROM calculator:
  \ ----
  \ db $38 ; `end-calc` ROM calculator command
  \ pop bc ; restore the Forth IP
  \ ----

-->

( calculator )

: +  ( -- )  $0F c,  ;
  \ Compile the `addition` ROM calculator command.
: -  ( -- )  $03 c,  ;
  \ Compile the `subtract` ROM calculator command.

: *  ( -- )  $04 c,  ;
  \ Compile the `multiply` ROM calculator command.
: /  ( -- )  $05 c,  ;
  \ Compile the `division` ROM calculator command.
: mod  ( -- )  $32 c,  ;
  \ Compile the `n-mod-m` ROM calculator command.

: **  ( -- )  $06 c,  ;
  \ Compile the `to-power` ROM calculator command.
: sqrt  ( -- )  $28 c,  ;
  \ Compile the `sqr` ROM calculator command.

-->

( calculator )

: negate  ( -- )  $1B c,  ;
  \ Compile the `negate` ROM calculator command.
: sgn  ( -- )  $29 c,  ;
  \ Compile the `sgn` ROM calculator command.
: abs  ( -- )  $2A c,  ;
  \ Compile the `abs` ROM calculator command.

: int  ( -- )  $27 c,  ;
  \ Compile the `int` ROM calculator command.
: truncate  ( -- )  $3A c,  ;
  \ Compile the `truncate` ROM calculator command.

: re-stack  ( r -- r' )  $3D c,  ;
  \ Compile the `re-stack` ROM calculator command.

: zero  ( -- )  $A0 c,  ;
  \ Compile the ROM calculator command that stacks 0.
: one  ( -- )  $A1 c,  ;
  \ Compile the ROM calculator command that stacks 1.
: half  ( -- )  $A2 c,  ;
  \ Compile the ROM calculator command that stacks 1/2.
: pi2/  ( -- )  $A3 c,  ;
  \ Compile the ROM calculator command that stacks pi/2.
: ten  ( -- )  $A4 c,  ;
  \ Compile the ROM calculator command that stacks 10.

-->

( calculator )

: ln  ( -- )  $25 c,  ;
  \ Compile the `ln` ROM calculator command.
: exp  ( -- )  $26 c,  ;
  \ Compile the `exp` ROM calculator command.

: acos  ( -- )  $23 c,  ;
  \ Compile the `acos` ROM calculator command.
: asin  ( -- )  $22 c,  ;
  \ Compile the `asin` ROM calculator command.
: atan  ( -- )  $24 c,  ;
  \ Compile the `atan` ROM calculator command.
: cos  ( -- )  $20 c,  ;
  \ Compile the `cos` ROM calculator command.
: sin  ( -- )  $1F c,  ;
  \ Compile the `sin` ROM calculator command.
: tan  ( -- )  $21 c,  ;
  \ Compile the `tan` ROM calculator command.

-->

( calculator )

: drop  ( -- )  $02 c,  ;
  \ Compile the `delete` ROM calculator command.

: dup  ( -- )  $31 c,  ;
  \ Compile the `duplicate` ROM calculator command.

: swap  ( -- )  $01 c,  ;
  \ Compile the `exchange` ROM calculator command.

: >mem  ( n -- )  $C0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `st-mem` ROM calculator command for memory
  \ number _n_ (0..5). Note: The floating-point stack TOS is
  \ copied, not moved.

: mem>  ( n -- )  $E0 [ also forth ] + [ previous ] c,  ;
  \ Compile the `get-mem` ROM calculator command for memory
  \ number _n_ (0..5).

: over  ( -- )
  2 >mem drop 1 >mem 2 mem> 1 mem>  ;
  \ Compile the ROM calculator commands to do `over`.

: 2dup  ( -- )
  2 >mem drop 1 >mem drop 1 mem> 2 mem>  1 mem> 2 mem>  ;
  \ Compile the ROM calculator commands to do `2dup`.

-->

( calculator )

: 0=  ( -- )  $30 c,  ;
  \ Compile the `not` ROM calculator command.

: 0<  ( -- )  $36 c,  ;
  \ Compile the `less-0` ROM calculator command.

: 0>  ( -- )  $37 c,  ;
  \ Compile the `greater-0` ROM calculator command.

-->

( = <> < > <= >= )

-->  \ XXX TMP -- ignore this block

  \ XXX FIXME -- These commands always return true.
  \
  \ 2016-04-20:
  \
  \ After some research, it seems the reason is the numbers are
  \ compared as strings.  Some commands of the ROM calculator
  \ are used to compare numbers and strings, and the routine
  \ checks the parameters before doing the comparison.
  \
  \ Somehow the ROM routine at $353B gets confused because the
  \ command is not restored from $5C67 (the BREG system
  \ variable).
  \
  \ I examined the source of the ROM calculator and followed
  \ its execution using the debugger of the Fuse emulator, in
  \ BASIC and Forth. So far I got the following clues:
  \
  \ $335E: the command in B is saved to $5C67. This is at the
  \ start of the calculator, so it doesn't makes sense the
  \ first time, because the command is not in B. In Forth, B
  \ contains the high part of the IP ($78 at the time of
  \ writing). But this address is a re-entry point, forced by
  \ the calculator by manipulating the Z80 stack.
  \
  \ $336C: the command is in A, ok.
  \
  \ $338C: the command is modified for indexing, ok.
  \
  \ $339D: the command should be restored by `ld bc,($5C66)`,
  \ which is the low part of STKEND and the high part of BREG.
  \ The register B should contain the command, but not right
  \ after the first entry into the calculator.
  \
  \ $33A1: BREG is in B, which in Forth is $78, bad.
  \
  \ $33A1: Restore the ROM calculator literal: `ld a,($5C67)`.
  \ This is not executed by Forth's `f=`, but it is when the
  \ BASIC command `print 1=1` is interpreted.
  \
  \ $353B: B contains $78, not the command. The routine does a
  \ string comparison. But in BASIC, at this point register B
  \ contains the command.

: =  ( -- )  $0E c,  ;
  \ Compile the `nos-eql` ROM calculator command.

: <>  ( -- )  $0B c,  ;
  \ Compile the `nos-neql` ROM calculator command.

: >  ( -- )  $0C c,  ;
  \ Compile the `no-grtr` ROM calculator command.

: <  ( -- )  $0D c,  ;
  \ Compile the `no-less` ROM calculator command.

: <=  ( -- )  $09 c,  ;
  \ Compile the `no-l-eql` ROM calculator command.

: >=  ( -- )  $0A c,  ;
  \ Compile the `no-gr-eql` ROM calculator command.

-->

( calculator )

: ?branch  ( -- )  $00 c,  ;
  \ Compile the `jump-true` ROM calculator command.

: 0branch  ( -- )  0= ?branch  ;
  \ Compile the ROM calculator commands to do a branch if
  \ the TOS of the calculator stack is zero.

: branch  ( -- )  $33 c,  ;
  \ Compile the `jump` ROM calculator command.

-->

( calculator )

: >mark  ( -- a )  here 0 c,  ;

  \ Compile space for the displacement of a ROM calculator
  \ forward branch which will later be resolved by
  \ `>resolve`.
  \
  \ Typically used after either `branch` or
  \ `?branch`.

: from-here  ( a -- n )
  here [ also forth ] swap - [ previous ] ;
  \ Calculate the displacement _n_ from the current data-space
  \ pointer to address _a_.

: >resolve  ( a -- )
  [ also forth ] dup [ previous ] from-here
  [ also forth ] swap [ previous ] c!  ;

  \ Resolve a ROM calculator forward branch by placing the
  \ displacement to the current position into the space
  \ compiled by `>mark`.

' here alias <mark  ( -- a )

  \ Leave the address of the current data-space pointer as the
  \ destination of a ROM calculator backward branch which will
  \ later be resolved by `<resolve`.
  \
  \ Typically used before either `branch` or `?branch`.

: <resolve  ( a -- )  from-here c,  ;

  \ Resolve a ROM calculator backward branch by compiling the
  \ displacement from the current position to address _a_,
  \ which was left by `<mark`.

: if  ( -- a )  0branch >mark  ;

: else  ( a1 -- a2 )
  branch >mark [ also forth ] swap [ previous ] >resolve  ;

' >resolve alias then  ( a -- )

set-current  previous
  \ restore the current word list and the search order
  \ math.floating_point.rom.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605050022

  \ -----------------------------------------------------------
  \ Description

  \ A floating point implementation that uses the ROM
  \ calculator.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-23: Start. Main development.
  \
  \ 2016-04-11: Revision. Code reorganized. First improvements.
  \
  \ 2016-04-12: Started `f.` and `f,`.
  \
  \ 2016-04-13: Fixes and improvements. First usable version.
  \
  \ 2016-04-18: Made `f.` immune to the ROM bug. Fixed
  \ `ftrunc`. Moved the ROM calculator to its own file.
  \ Improved. Added `floor`.
  \
  \ 2016-04-20: Added `fnip`, `ftuck`, `f2dup`, `f2drop`.
  \ Wrote `calculator-command>flag` and rewrote `f=`, `f<>`,
  \ `f<`, `f<=`, `f>` and `f>=` after it, because calling the
  \ equivalents command of the ROM calculator directly always
  \ returned a true flag; the details of the debugging are
  \ noted in the ROM calculator module. Fixed `fmax` and
  \ `fmin`.
  \
  \ 2016-04-21: Added `fround`, `f~`, `f~abs`, `f~rel`,
  \ `f~relabs`, `f==`, `flnp1`, `?fln`, `'?flnp1`.
  \
  \ 2016-05-05: Update `s=` to `str=`.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- Write `fliteral`, `ffield:`, `fvalue`,
  \ environmental queries.
  \
  \ XXX TODO -- Write safer alternatives for the ambiguous
  \ conditions listed in Forth-2012, or better yet, use the
  \ standard name for the safe version, and factor the faster
  \ unsafe code.
  \
  \ XXX TODO -- `init-fs`, call to ROM routine STK_STK ($16C5).
  \
  \ XXX TODO -- Test everything.
  \
  \ XXX TODO -- Document.

( float float+ float- floats )

5 constant float

: float+  ( fa1 -- fa2 )  float +  ;
: float-  ( fa1 -- fa2 )  float -  ;
: floats  ( n1 -- n2 )  float *  ;

( fp0 fp (fp@ fp@ empty-fs fdepth )

need float

23651 constant fp0  \ STKBOT system variable
23653 constant fp   \ STKEND system variable

  \ Note: The calculator stack grows towards higher memory, and
  \ `fp` points to the first free position, therefore above top
  \ of stack.

: (fp@  ( -- a )  fp @  ;

: fp@  ( -- a )  (fp@ float -  ;

: empty-fs  ( -- )  fp0 @ fp !  ;

: fdepth  ( -- n )  (fp@ fp0 @ - float /  ;

( f>flag )

need (f>s

: f>flag  ( -- f ) ( F: rf -- )  (f>s negate  ;
  \ Convert a floating-poing flag _rf_ (1|0) to an actual flag
  \ _f_ in the data stack.

( end-calculator-flag )

need macro  need f>flag  need call-xt

macro end-calculator-flag  ( -- f ) ( F: 1|0 -- )
  [ calculator-wordlist >order ] end-calculator [ previous ]
  ['] f>flag call-xt  jpnext endm

  \ Exit the ROM calculator and convert a flag calculated by
  \ it (_1|0_) to a well-formed flag on the data stack.
  \
  \ This macro is a common factor of all floating point logical
  \ operators.

( calculator-command )

need calculator

: calculator-command  ( b -- )
  $C5 c,  $06 c, c,
    \ push bc ; save the Forth IP
    \ ld b,command
  calculator  $3B c,
    \ `fp-calc-2` calculator command, which executes the
    \ calculator command stored in the b register.
  [ calculator-wordlist >order ] end-calculator [ previous ]
  $C1 c,  ;
    \ pop bc ; restore the Forth IP

  \ doc{
  \
  \ calculator-command  ( b -- )
  \
  \ Compile the assembler instructions needed to execute the
  \ _b_ command of the ROM calculator.
  \
  \ }doc

( calculator-command>flag )

need calculator-command  need f>flag  need call-xt

: calculator-command>flag  ( b -- )
  calculator-command ['] f>flag call-xt
  [ also assembler ] jpnext [ previous ]  ;

  \ doc{
  \
  \ calculator-command>flag  ( b -- )
  \
  \ Compile the assembler instructions needed to execute the
  \ _b_ command of the ROM calculator and to return the
  \ floating-point result as a flag on the data stack.
  \
  \ }doc

( f= f<> )

need calculator-command>flag

code f=  ( -- f ) ( F: r1 r2 -- )
  0E calculator-command>flag  end-code
  \ `nos-eql` calculator command

code f<>  ( -- f ) ( F: r1 r2 -- )
  0B calculator-command>flag  end-code
  \ `nos-neql` calculator command

( f~abs f~rel f~relabs f== )

  \ Credit:
  \
  \ Most of this code is based on the words `f~`, `f~abs` and
  \ `f~rel` implemented in Gforth 0.7.3. Parts have been
  \ factored and adapted.

need frot  need f-  need fabs  need fswap  need f<  need fover
need f+  need f*  need fp@  need float-  need float  need str=
need fdrop  need fsgn

: f~abs  ( -- f ) ( F: r1 r2 r3 -- )
  frot frot f- fabs fswap f<  ;

  \ doc{
  \
  \ f~abs  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with absolute error: `|r1-r2|<r3`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than _r3_.
  \
  \ Origin: Gforth.
  \
  \ }doc

: f~rel  ( -- f ) ( F: r1 r2 r3 -- )
  frot frot fover fabs fover fabs f+
  frot frot f- fabs frot frot f* f<  ;

  \ doc{
  \
  \ f~rel  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with relative error:
  \ `|r1-r2|<r3*|r1+r2|`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than the value of _r3_ times the sum of the absolute values
  \ of _r1_ and _r2_.
  \
  \ }doc

: f~relabs  ( -- f ) ( F: r1 r2 r3 -- )  fabs f~rel  ;

  \ XXX TODO -- better name

  \ doc{
  \
  \ f~relabs  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Approximate equality with relative error:
  \ `|r1-r2|<|r3|*|r1+r2|`.
  \
  \ Flag _f_ is true if the absolute value of _r1-r2_ is less
  \ than the absolute value of _r3_ times the sum of the
  \ absolute values of _r1_ and _r2_.
  \
  \ }doc

: f==  ( -- f ) ( F: r1 r2 -- )
  fp@ dup float- float tuck str= fdrop fdrop  ;

  \ doc{
  \
  \ f==  ( -- f ) ( F: r1 r2 -- )
  \
  \ Exact bitwise equality.
  \
  \ Are _r1_ and _r2_ exactly identical? Flag _f_ is true if
  \ the bitwise comparison of _r1_ and _r2_ is succesful.
  \
  \ }doc

( f~ )

need f~abs  need f==  need f~relabs

     ' f~abs ,
here ' f== ,
     ' f~relabs ,

      constant (f~) \ execution table of `f~`

: f~  ( -- f ) ( F: r1 r2 r3 -- )
  fdup fsgn f>s cells (f~) + perform  ;

  \ doc{
  \
  \ f~  ( -- f ) ( F: r1 r2 r3 -- )
  \
  \ Medley for comparing _r1_ and _r2_ for equality:
  \
  \ - _r3_>0: `f~abs`;
  \ - _r3_=0: `f==`;
  \ - _r3_<0: `f~relabs`.
  \
  \ See: `f~abs`, `f==`, `f~rel`,`f~relabs`.
  \
  \ Origin: Forth-94 (FLOATING EXT), Forth-2012 (FLOATING EXT).
  \
  \ }doc

( f< f<= f> f>= )

need calculator-command>flag

code f<  ( -- f ) ( F: r1 r2 -- )
  0D calculator-command>flag  end-code
  \ `no-less` calculator command

code f<=  ( -- f ) ( F: r1 r2 -- )
  09 calculator-command>flag  end-code
  \ `no-l-eql` calculator command

code f>  ( -- f ) ( F: r1 r2 -- )
  0C calculator-command>flag  end-code
  \ `no-grtr` calculator command

code f>=  ( -- f ) ( F: r1 r2 -- )
  0A calculator-command>flag  end-code
  \ `no-gr-eql` calculator command

( f0< f0= f0<> f0> )

need calculator  need end-calculator-flag

code f0<  ( -- f ) ( F: r -- )
  calculator  0<  end-calculator-flag  end-code

code f0=  ( -- f ) ( F: r -- )
  calculator  0=  end-calculator-flag  end-code

code f0<>  ( -- f ) ( F: r -- )
  calculator  0= 0=  end-calculator-flag  end-code

code f0>  ( -- f ) ( F: r -- )
  calculator  0>  end-calculator-flag  end-code

( fdrop fdup fswap fover )

need calculator

code fdrop  ( F: r -- )
  calculator  drop  end-calculator  jpnext  end-code

code fdup  ( F: r -- r r )
  calculator  dup  end-calculator  jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calculator  swap  end-calculator  jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calculator  over  end-calculator  jpnext  end-code

( f2dup f2drop )

code f2dup  ( F: r -- r r )
  calculator  2dup  end-calculator  jpnext  end-code

code f2drop  ( F: r -- )
  calculator  drop drop  end-calculator  jpnext  end-code

( fnip ftuck )

need calculator

code fnip  ( F: r1 r2 -- r2 )
  calculator  swap drop  end-calculator  jpnext
  end-code

code ftuck  ( F: r1 r2 -- r2 r1 r2 )
  calculator  2 >mem swap 2 mem>  end-calculator  jpnext
  end-code

( frot -frot )

need calculator

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calculator
    1 >mem drop swap 1 mem> swap
  end-calculator  jpnext  end-code

code -frot  ( F: r1 r2 r3 -- r3 r1 r2 )
  calculator
    swap 1 >mem drop swap 1 mem>
  end-calculator  jpnext  end-code

( f+ f- f* f/ ?f/ fmod )

need calculator  need fdup  need f0=

code f+  ( F: r1 r2 -- r3 )
  calculator  +  end-calculator  jpnext  end-code

code f-  ( F: r1 r2 -- r3 )
  calculator  -  end-calculator  jpnext  end-code

code f*  ( F: r1 r2 -- r3 )
  calculator  *  end-calculator  jpnext  end-code

code f/  ( F: r1 r2 -- r3 )
  calculator  /  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r2_ is zero, the calculator issues
  \ "number too big" BASIC error, what crashes the system.  A
  \ safe alternative `?f/` is provided.

: ?f/  ( F: r1 r2 -- r3 )  fdup f0= #-42 ?throw f/  ;
  \ Safe version of `f/`. If _r2_ is zero, an exception
  \ is thrown.

code fmod  ( F: r1 -- r2 )
  calculator  mod  end-calculator  jpnext  end-code

( fmax )

need calculator  need calculator-command

code fmax  ( F: r1 r2 -- r1|r2 )
  calculator  2dup  end-calculator
  0C calculator-command  ( F: r1 r2 rf -- )
    \ `no-grtr` ROM calculator command
  calculator
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

  \ XXX OLD -- Original, simpler version. The problem is the
  \ calculator's `>`. See the calculator module for details of
  \ the problem.

  \ code fmax  ( F: r1 r2 -- r1|r2 )
  \   calculator
  \     2dup >  ( F: r1 r2 rf -- )
  \     if    drop  ( F: r1 )
  \     else  swap drop  ( F: r2 )
  \     then
  \   end-calculator  jpnext  end-code

( fmin )

need calculator  need calculator-command

code fmin  ( F: r1 r2 -- r1|r2 )
  calculator  2dup  end-calculator
  0D calculator-command  ( F: r1 r2 rf -- )
    \ `no-less` ROM calculator command
  calculator
    if    drop  ( F: r1 )
    else  swap drop  ( F: r2 )
    then
  end-calculator  jpnext  end-code

  \ XXX OLD -- Original, simpler version. The problem is the
  \ calculator's `<`. See the calculator module for details of
  \ the problem.

  \ code fmin  ( F: r1 r2 -- r1|r2 )
  \   calculator
  \     2dup <  ( F: r1 r2 rf -- )
  \     if    drop  ( F: r1 )
  \     else  swap drop  ( F: r2 )
  \     then
  \   end-calculator  jpnext  end-code

( fsgn fabs fnegate )

need calculator

code fsgn  ( F: r1 -- -1|0|1 )
  calculator  sgn  end-calculator  jpnext  end-code

code fabs  ( F: r1 -- r2 )
  calculator  abs  end-calculator  jpnext  end-code

code fnegate  ( F: r1 -- r2 )
  calculator  negate  end-calculator  jpnext  end-code

( fln ?fln flnp1 ?flnp1 fexp f** fsqrt ?fsqrt )

need calculator  need fdup  need f0<  need f<=

code fln  ( F: r1 -- r2 )
  calculator  ln  end-calculator  jpnext  end-code
  \ XXX FIXME -- The ROM calculator checks that the argument is
  \ a positive non-zero number (address $3713). If not, it
  \ throws a BASIC error "invalid argument", what crashes the
  \ system.  A safe alternative `?fln` is provided.

: ?fln  ( F: r1 -- r2 )  fdup f0 f<= #-46 ?throw fln  ;
  \ Safe version of `fln`. If _r1_ is less than or equal to
  \ zero, an exception is thrown.

code flnp1  ( F: r1 -- r2 )
  calculator  one + fln  end-calculator  jpnext  end-code

: ?flnp1  ( F: r1 -- r2 )
  fdup f1 fnegate f<= #-46 ?throw fln  ;
  \ Safe version of `flnp1`. If _r1_ is less than or equal to
  \ negative one, an exception is thrown.

code fexp  ( F: r1 -- r2 )
  calculator  exp  end-calculator  jpnext  end-code

code f**  ( F: r1 -- r2 )
  calculator  **  end-calculator  jpnext  end-code

code fsqrt  ( F: r1 -- r2 )
  calculator  sqrt  end-calculator  jpnext  end-code
  \ XXX FIXME -- when _r1_ is negative, the calculator issues
  \ "invalid argument" BASIC error, what crashes the system.  A
  \ safe alternative `?fsqrt` is provided.

: ?fsqrt  ( F: r1 -- r2 )  fdup f0< #-46 ?throw fsqrt  ;
  \ Safe version of `fsqrt`. If _r1_ is negative, an exception
  \ is thrown.

( f0 f1 fhalf fpi2/ f10 )

need calculator

code f0  ( F: -- r )
  calculator  zero  end-calculator  jpnext  end-code

code f1  ( F: -- r )
  calculator  one  end-calculator  jpnext  end-code

code fhalf  ( F: -- r )
  calculator  half  end-calculator  jpnext  end-code

code fpi2/  ( F: -- r )
  calculator  pi2/  end-calculator  jpnext  end-code

code f10  ( F: -- r )
  calculator  ten  end-calculator  jpnext  end-code

( (f>s )

  \ XXX REMARK -- This word must be in other block than `f>s`,
  \ to avoid a circular `need`.

code (f>s  ( -- n ) ( F: r -- )
  C5 c,  CD c, 2DA2 ,
    \ push bc
    \ call $2DA2 ; FP_TO_BC ROM routine
  60 00 + c,  68 01 + c,  C1 c,  jppushhl
    \ ld h,b
    \ ld l,c
    \ pop bc
    \ jp push_hl
  end-code

( frestack b>f u>f s>f f>s )

need calculator  need fnegate  need fdup  need (f>s  need f0<

code frestack  ( F: r -- r' )
  calculator  re-stack  end-calculator  jpnext end-code
  \ Restack an integer in full floating-point form.

code b>f  ( b -- ) ( F: -- r )
  D9 c, E1 c, 78 05 + c, CD c, 2D28 , D9 c,  jpnext  end-code
    \ exx
    \ pop hl
    \ ld a,l
    \ call $2D28 ; STACK_A ROM routine
    \ exx
  \ XXX TODO -- test

code u>f  ( u -- ) ( F: -- r )
  D9 c, C1 c, CD c, 2D2B , D9 c,  jpnext  end-code
    \ exx
    \ pop bc
    \ call $2D2B ; STACK_BC ROM routine
    \ exx

: s>f  ( n -- ) ( F: -- r )
  dup 0< if  abs u>f fnegate  else  u>f  then  ;
  \ XXX TODO -- test

: f>s  ( -- n ) ( F: r -- )  fdup (f>s f0< ?negate  ;
  \ XXX TODO -- test

  \ code f>d  ( -- d ) ( F: r -- )
  \ end-code
  \ XXX TODO

  \ code d>f  ( d -- ) ( F: -- r )
  \ end-code
  \ XXX TODO

  \ code f>string  ( -- ca len ) ( F: r -- )
  \ end-code
  \ XXX TODO -- ROM calculator command $2E

  \ : >float  ;
  \ XXX TODO -- ROM calculator command `val`

( f! f@ )

need z80-asm

code f!  ( fa -- ) ( F: r -- )
  exx  2BF1 call  \ STK_FETCH ROM routine
       hl pop  a m ld  hl incp
               e m ld  hl incp  d m ld  hl incp
               c m ld  hl incp  b m ld
  exx  jpnext end-code

  \ doc{
  \
  \ f!  ( fa -- ) ( F: r -- )
  \
  \ Store _r_ at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

code f@  ( fa -- ) ( F: -- r )
  exx  hl pop m a ld  hl incp
              m e ld  hl incp  m d ld  hl incp
              m c ld  hl incp  m b ld
              2AB6 call  \ STK_STORE ROM routine
  exx  jpnext end-code

  \ doc{
  \
  \ f@  ( fa -- ) ( F: -- r )
  \
  \ _r_ is the value stored at _fa_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

( f, fconstant fvariable )

need float  need f!  need f@

: f,  ( -- ) ( F: r -- )  here float allot f!  ;

  \ doc{
  \
  \ f,  ( -- ) ( F: r -- )
  \
  \ Reserve data space for one floating-point number and store
  \ _r_ in that space.
  \
  \ Origin: Gforth.
  \
  \ }doc

: fconstant  ( "name" -- )  ( F: r -- )
  create  f,  does>  f@  ;

  \ doc{
  \
  \ fconstant  ( "name" -- )  ( F: r -- )
  \
  \ Create a floating-point constant called "name" with value
  \ _r_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

: fvariable  ( "name" -- )  create  float allot  ;

( facos fasin fatan fcos fsin ftan )

need calculator

code facos  ( F: r1 -- r2 )
  calculator  acos  end-calculator  jpnext  end-code

code fasin  ( F: r1 -- r2 )
  calculator  asin  end-calculator  jpnext  end-code

code fatan  ( F: r1 -- r2 )
  calculator  atan  end-calculator  jpnext  end-code

code fcos  ( F: r1 -- r2 )
  calculator  cos  end-calculator  jpnext  end-code

code fsin  ( F: r1 -- r2 )
  calculator  sin  end-calculator  jpnext  end-code

code ftan  ( F: r1 -- r2 )
  calculator  tan  end-calculator  jpnext  end-code

( (f. f. )

need fdepth  need fdrop

code (f.  ( F: r -- )
  C5 c,  CD c, 2DE3 ,  C1 c,
    \ push bc
    \ call $2DE3  ; PRINT_FP ROM routine
    \ pop bc
  jpnext  end-code
  \ Note: `exx` can no be used to preserve `bc`, the Forth IP,
  \ because the routine uses the alternative registers.  `bc`
  \ is saved on the stack instead.

: f.  ( F: r -- )
  fdepth >r  (f. space
  fdepth r> = if  fdrop  then  ;

  \ Note: the depth of the stack must be checked because
  \ there's a bug in the PRINT-FP ROM routine called "unbalaced
  \ stack error". When the number is a non-integer less than 1,
  \ a zero is left on the stack.  This bug is documented in the
  \ ZX Spectrum ROM disassembly. Credit: Tony Stratton, 1982.

  \ XXX FIXME -- The Forth-2012 standard reads `f.` must use
  \ fixed-point notation, but in this implementation the
  \ decimal point is not shown at the end when the number is
  \ integer.

( .fs dump-fs )

need (fp@  need fp0  need f@  need f.
need fdepth  need float  need float+  need .depth

: (.fs  ( -- )  (fp@ fp0 @ ?do  i f@ f.  float +loop  ;

: .fs   ( -- )  fdepth dup .depth 0> if  (.fs  then  ;

: (dump-fs  ( -- )
  cr ." Bottom"
  (fp@ fp0 @ ?do
    i dup cr u. float bounds ?do  i c@ 4 .r  loop
  float +loop  cr ." Top" cr  ;
  \ XXX TODO -- improve: print the top at the top

: dump-fs  ( -- )  fdepth dup .depth 0> if  (dump-fs  then  ;

( floor ftrunc fround )

need calculator  need fdup  need fsgn  need f*  need f+

code floor  ( F: r1 -- r2 )
  calculator  int  end-calculator  jpnext  end-code

  \ doc{
  \
  \ floor  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ negative infinity" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc


code ftrunc  ( F: r1 -- r2 )
  calculator  truncate  end-calculator  jpnext  end-code

  \ doc{
  \
  \ ftrunc  ( F: r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round toward
  \ zero" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

  \ Example from the documentation of Forth-2012:

  \ : ftrunc  ( F: r1 -- r2 )
  \   fdup f0= 0= if
  \     fdup f0< if  fnegate floor fnegate  else  floor  then
  \   then  ;

  \ From Gforth:

  \ : ftrunc  ( F: r1 -- r2 )  f>d d>f  ;

: fround  ( F: r1 -- r2 )  fdup fsgn fhalf f* f+ ftrunc  ;

  \ doc{
  \
  \ fround  ( r1 -- r2 )
  \
  \ Round _r1_ to an integral value using the "round to
  \ nearest" rule, giving _r2_.
  \
  \ Origin: Forth-94 (FLOATING), Forth-2012 (FLOATING).
  \
  \ }doc

( falign faligned sfalign sfaligned dfalign dfaligned )

need alias

' noop alias falign     ( -- )        immediate
' noop alias faligned   ( a -- fa )   immediate

' noop alias sfalign    ( -- )        immediate
' noop alias sfaligned  ( a -- dfa )  immediate

' noop alias dfalign    ( -- )        immediate
' noop alias dfaligned  ( a -- dfa )  immediate

  \ vim: filetype=soloforth
  \ math.number.conversion.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160325

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number conversion.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( number )

: number  ( ca len -- n | d )  number? 0= #-275 ?throw  ;
  \ doc{
  \
  \ number  ( ca len -- n | d )
  \
  \ Attempt to convert a string _ca len_ into a number. If
  \ a valid point is found, return _d_; if there is no
  \ valid point, return _n_. If conversion fails due to an
  \ invalid character, an exception #-275 is thrown.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ math.number.point.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242143

  \ -----------------------------------------------------------
  \ Description

  \ Words to configure the charactes accepted as number point.

  \ -----------------------------------------------------------
  \ Authors

  \ Wil Baden, published on Forth Dimensions (volume 20, number
  \ 3 page 26, 1998-10).

  \ Adapted by Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( standard-number-point? extended-number-point? )

need [if]

[needed] classic-number-point? [if]

: classic-number-point?  ( c -- f )
  dup ':' = swap ',' - 4 u< or  ;
  \ doc{
  \
  \ standard-number-point?  ( c -- f )
  \
  \ Is character _c_ a classic number point?  Allowed
  \ points are: comma, hyphen, period, slash and
  \ colon.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

[needed] extended-number-point? [if]

: extended-number-point?  ( c -- f )
  dup ':' = swap '+' - 5 u< or  ;

  \ doc{
  \
  \ extended-number-point?  ( c -- f )
  \
  \ Is character _c_ an extended number point?  Allowed points
  \ are: plus sign, comma, hyphen, period, slash and colon,
  \ after _Forth Programmer's Handbook_.
  \
  \ This word is an alternative behaviour for the deferred word
  \ `number-point?`, which is used in `number?`, and whose
  \ default behaviour is `standard-number-point?`.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth

  \ math.number.prefix.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605140240

  \ -----------------------------------------------------------
  \ Description

  \ Numeric prefix words. Solo Forth recognizes the standard
  \ notations, but these words may be useful in some cases.

  \ -----------------------------------------------------------
  \ Author

  \ XXX TODO -- update

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.

( base# b# d# h# )

  \ Credit:
  \
  \ Based on code from eForth and code written by Wil Baden
  \ (published on Forth Dimensions 20-3, p. 27).

need evaluate

: base# ( -- ) ( "name" -- )
  create c, immediate
  does> c@
  base c@ >r  base !    \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

 2 base# b#
10 base# d#
16 base# h#

( x# b# o# d# h# t# )

  \ Credit:
  \
  \ Code from eForth.

need evaluate

: x# ( -- ) ( "name" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create o# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate
create t# ( "name" -- n | d ) 36 c, x# immediate

( c# )

  \ Credit:
  \
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate

  \ doc{
  \
  \ c#  ( "name" -- c )
  \
  \ Parse "name" and return the code _c_ of the its first
  \ character.
  \
  \ This is a short and state-smart alternative to the standard
  \ words `char` and `[char]`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.number.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605010407

  \ -----------------------------------------------------------
  \ Description

  \ Words related to number printing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-01: Add `holds`.

( ud.r ud. )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

: ud.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;

  \ : u.r  ( n1 n2 -- )  >r 0 r> ud.r  ;

: ud.  ( d -- )  0 ud.r space  ;

( bin. dec. hex. )

  \ Credit:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credit:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credit:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

( holds )

  \ Credit:
  \ Code from the documentation of Forth-2012.

: holds  ( ca len -- )
  begin  dup  while  1- 2dup + c@ hold  repeat
  2drop  ;

  \ doc{
  \
  \ holds  ( ca len -- )
  \
  \ Add string _ca len_ to the pictured numeric output string.
  \
  \ Origin: Forth-2012 (CORE EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.operators.1-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605020257

  \ -----------------------------------------------------------
  \ Description

  \ Single-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015: Add `within`, `between`, and common operators.
  \ 2015-08-12: Add `lshift`. Improve `2/`.
  \ 2015-08-14: Add `under+`, in Forth.
  \ 2015-11-01: Add `rshift` and faster `lshift`.
  \ 2015-11-13: Add `sqrt` (version by Wil Baden).
  \ 2015-12-15: Rewrote `under+` in Z80.
  \ 2015-12-21: Add `polarity`.
  \ 2015-12-22: Add `%` and `u%`.
  \ 2015-12-29: Add second version of `sqrt` (from Computer One
  \ Forth).
  \ 2016-03-20: Add `+under`, a variant of `under+`.
  \ 2016-04-05: Add `cell/`.
  \ 2016-04-07: Add `bits`, generic version of `pixels`.
  \ 2016-04-27: Add `sgn`, `<=>`, `either`, `neither`.
  \ 2016-04-28: Fix `<=>`. Add `0max`.
  \ 2016-05-01: Add `clshift`.
  \ 2016-05-02: Compact the blocks to save space. Remove `sgn`
  \ because `polarity` does the same already.

( under+ +under )

need [if]

[needed] under+ [if]

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c, D1 c, C1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop de
  \ pop bc
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `+under`.
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \   rot + swap  ;
  \ ----
  \
  \ }doc

[then]

[needed] +under [if]

code +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  D9 c, C1 c, D1 c, E1 c, 19 c, E5 c, C5 c, D9 c,
  \ exx
  \ pop bc
  \ pop de
  \ pop hl
  \ add hl,de
  \ push hl
  \ push bc
  \ exx
  jpnext  end-code

  \ doc{
  \
  \ +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ See `under+`
  \
  \ Origin: Comus.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : +under  ( n1|u1 n2|u2 x -- n3|u3 x )
  \   >r + r>  ;
  \ ----
  \
  \ }doc

[then]

  \ XXX TODO -- variant after PFE's `(under+)`:
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;

( within between % u% )

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ Credit:
  \
  \ Code from DZX-Forth.

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit

: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ Credit:
  \
  \ http://dxforth.netbay.com.au/between.html

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ }doc

[unneeded] %
?\ : %  ( n1 n2 -- n3 )  100 swap */  ;
  \ _n1_ is percentage _n3_ of _n2_

[unneeded] u%
?\ : u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;
  \ _u1_ is percentage _u3_ of _u2_

( polarity <=> )

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code
  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve
  78 05 + c,  F6 c, 01 c,  68 07 + c,  jppushhl
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

  \ doc{
  \
  \ polarity  ( n -- -1|0|1 )
  \
  \ If _n_ is zero, return zero.
  \ If _n_ is negative, return negative one.
  \ If _n_ is positive, return positive one.
  \
  \ The word is written in Z80. This is an example
  \ implementation in Forth:
  \
  \ ----
  \ : polarity  ( n -- -1|0|1 )
  \   dup 0= ?exit  0< ?dup ?exit  1  ;
  \ ----
  \
  \ }doc

  \ Credit:
  \
  \ Assembler version of `polarity` adapted from Z88
  \ CamelForth.

[unneeded] <=>
?\ : <=>  ( n1 n2 -- -1|0|1 )  - polarity  ;

  \ doc{
  \
  \ <=>  ( n1 n2 -- -1|0|1 )
  \
  \ If _n1_ equals _n2_, return zero.
  \ If _n1_ is less than _n2_, return negative one.
  \ If _n1_ is greater than _n2_, return positive one.
  \
  \ }doc

( u<= u>= <= >= 0>= 0<= 0max )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;  exit

[unneeded] 0max ?exit

code 0max  ( n -- n | 0 )
  E1 c,  CB c, 10 05 + c,  DA c, ' false ,  CB c, 18 05 + c,
    \ pop hl
    \ rl h ; negative?
    \ jp c,false_
    \ rr h
  jppushhl  end-code
    \ jp push_hl

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ 0max  ( n -- n | 0 )
  \
  \ If _n_ is negative, return 0; else return _n_.
  \ This is a faster alternative to the idiom `0 max`.
  \
  \ }doc

( lshift )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 16 bytes.

need z80-asm

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

  \ Data space used: 19 bytes.

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credit:
  \
  \ Code adapted from DZX-Forth.

  \ This version is 3 bytes smaller but slower (133% the
  \ execution time of the version adapted from Z88 CamelForth).

  \ Data space used: 16 bytes.

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( clshift )

code clshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,  80 07 + c,  C3 c, ,
    \ dec e
    \ jp z,push_a
    \ add a,a
    \ jp begin
  end-code

( crshift )

  \ XXX UNDER DEVELOPMENT -- 2016-05-01

code crshift  ( b1 u -- b2 )

  D1 c,  E1 c,  78 05 + c,  1C c,
    \ pop de
    \ pop hl
    \ ld a,l
    \ inc e
  here
    \ begin:
  1D c,  CA c, pusha ,
    \ dec e
    \ jp z,push_a
  \ 80 07 + c,
    \ rra
  C3 c, ,
    \ jp begin

  end-code

( bits )

  \ Credit:
  \
  \ Based on a pixels counter written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

  \ Data space used: 29 bytes.

need z80-asm

code bits  ( ca len -- u )

  0 hl ldp#  \ init bit count
  exx  \ save IP and count
  de pop  hl pop  \ memory zone
  begin
    d a ld  e or  nz if
      08 b ld#  \ bits per byte
      begin  m rrc  cy if  exx hl incp exx  then  step
      hl incp  de decp  \ next byte
  2swap again then
    \ Note: `2swap` is needed because `begin again` and `if
    \ then` are not nested.

  exx jppushhl end-code

  \ doc{
  \
  \ bits  ( ca len -- u )
  \
  \ Count the number of bits set in memory zone _ca len_.
  \
  \ }doc

( 2/ cell/ )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

need [if]

[needed] 2/ [needed] cell/ or [if]

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  jppushhl        \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

[then]

[unneeded] cell/  ?\ need alias  ' 2/ alias cell/
  \ Credit:
  \
  \ Idea from IsForth.

( sqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

  \ XXX TODO -- benchmark

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credit:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

  \ XXX TODO -- benchmark

need 2/

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ XXX TODO -- remove, it's in the kernel

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need sm/rem

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

  \ Credit:
  \
  \ Forth-94 documentation.

need fm/mod

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? either neither )

need [if]

[needed] any? [if]  need roll  variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;

  \ doc{
  \
  \ any?  ( x0 x1..xn n -- f )
  \
  \ Is any _x1..xn_ equal to _x0_?
  \
  \ Origin: F83.
  \
  \ }doc

  \ Credit:
  \
  \ Code from F83.

[then]

  \ Credit:
  \
  \ Code from IsForth (version 1.23b).

[needed] either [if]

: either  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over = -rot = or  ;

  \ doc{
  \
  \ either  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ equals either _n2|u2_ or _n3|u3_;
  \ else return _false_.
  \
  \ }doc

[then]

[needed] neither [if]

: neither  ( n1|u1 n2|u2 n3|u3 -- f )
  -rot over <> -rot <> and  ;

  \ doc{
  \
  \ neither  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Return _true_ if _n1|u1_ is not equal to either _n2|u2_ or
  \ _n3|u3_; else return _false_.
  \
  \ }doc

[then]

( split join )

need [if]

[needed] split [if]

code split  ( x -- b1 b2 )
  E1 c,
    \ pop hl
  16 c, 00 c,  58 05 + c,  68 04 + c,  26 c, 00 c,
    \ ld d,0
    \ ld e,l
    \ ld l,h
    \ ld h,0
  C3 c, pushhlde ,  end-code
    \ jp push_hlde

  \ Credit:
  \
  \ Idea from IsForth.

  \ doc{
  \
  \ split  ( x -- b1 b2 )
  \
  \ Get _b1_ and _b2_ from the 2 bytes which compose _x_: _b1_
  \ is the high-order byte and _b2_ is the low-order byte.
  \
  \ See `join`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

[needed] join [if]

code join  ( b1 b2 -- x )
  D1 c,  60 03 + c,  D1 c,  68 03 + c,
    \ pop de
    \ ld h,e
    \ pop de
    \ ld l,e
  jppushhl  end-code
    \ jp push_hl

  \ doc{
  \
  \ join  ( b1 b2 -- x )
  \
  \ _b1_ is the low-order byte of _x_, and _b2_ is the
  \ high-order byte of _x_.
  \
  \ See `split`.
  \
  \ Origin: IsForth.
  \
  \ }doc

[then]

  \ vim: filetype=soloforth
  \ math.operators.2-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271707

  \ -----------------------------------------------------------
  \ Description

  \ Double-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-13: Add `dsqrt`.

( ud* )

  \ Credit:
  \
  \ Code from Z88 CamelForth.

: ud*  ( ud1 u2 -- ud3 )  dup >r um* drop  swap r> um* rot +  ;

( d* )

  \
  \ Credit:
  \
  \ Code from DX-Forth 4.13.

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0000

: d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;

  \ --------------------------------------------
  \ Alternative implementation.
  \
  \ Credit:
  \
  \ Adapted from code written by Robert L. Smith,
  \ published on Forth Dimensions (volume 4, number 1, page 3,
  \ 1982-05).
  \
  \ This implementation uses 36 bytes.
  \ Relative speed: 1.0582
  \
  \ : d*  ( d1 d2 -- d3 )
  \  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ --------------------------------------------
  \ Alternative implementation.

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 33, 1998-04).

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0008

  \ : d*  ( d1 d2 -- d3 )
  \   >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  \   2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  \   r> * swap r> * + +  ; ( d1*d2 ) ( R: )

( du/mod )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

need tum*  need t+  need t-  need tum/  need d2*  need lshift

: normalize-divisor  ( d1 -- d1' shift )
  0 >r begin  dup 0< while  d2*  r> 1+ >r  repeat  r>  ;

  \ XXX TODO rename as `ud/mod`?
  \ XXX TODO stack comments

: du/mod  ( ud1 ud2 -- ud3 ud4 )

  ?dup 0= if
    \ there is a leading zero "digit" in divisor
    >r  0 r@ um/mod  r> swap >r  um/mod  0 swap r>  exit
  then

  normalize-divisor dup >r rot rot 2>r
  1 swap lshift tum*
    \ normalize divisor and dividend

  dup  r@ = if   -1  else  2dup  r@ um/mod nip  then
    \ guess leading "digit" of quotient

  2r@  rot dup >r  tum*  t-
    \ multiply divisor by trial quot and substract from
    \ dividend

  dup 0< if  r> 1-  2r@  rot >r  0 t+
    \ if negative, decrement quot and add to dividend

    dup 0< if  r> 1-  2r@  rot >r  0 t+  then
    \ if still negative, do it one more time

  then

  r> 2r> 2drop  1 r>  rot >r  lshift tum/  r> 0  ;
    \ undo nurmalization of dividend to get remainder

  \ Double unsigned divide with remainder.  Given a dividend
  \ _ud1_ and a divisor _ud2_, return remainder _ud3_ and
  \ quotient _ud4_.

( d0= d0< d< du< )

  \ Credit:
  \
  \ Code from DZX-Forth.

[unneeded] d0= ?\ : d0=  ( d -- f )  or 0=  ;  exit

[unneeded] d0< ?\ : d0<  ( d -- f )  nip 0<  ; exit

need [if]

[needed] d< [if]

need 2nip

: d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;  exit

[then]

[needed] du< [if]

  \ XXX TODO rewrite in Z80

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop [ true ] literal exit  then
  -   if  2drop [ false ] literal exit  then  u<  ;  exit

  \ Note: the flags are compiled with `literal` to make
  \ execution a bit faster.

[then]

( dmin dmax )

  \ Credit:
  \
  \ Code from DZX-Forth.

need [if]

[needed] dmin [if]
: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;  exit  [then]
  \ XXX TODO -- use `d>` when available

[needed] dmax [if]
: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;  [then]

( d= d<> )

  \ XXX TODO -- rewrite in Z80

: d<>  ( d1 d2 -- f )  rot <> if  2drop true exit  then  <>  ;

: d=  ( d1 d2 -- f )  d<> 0=  ;

  \ XXX OLD
  \ XXX TODO benchmark
  \ : d=  ( d1 d2 -- f ) rot = >r = r> and  ;
  \ : d<>  ( d1 d2 -- f )  d= 0=  ;

( d- )

need z80-asm

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  jppushhl
  end-code

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  D1 c, E1 c,
    \ pop de / pop hl
  29 c,  CB c, 13 c,  CB c, 12 c,
    \ add hl,hl
    \ rl e
    \ rl d
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  E1 c, D1 c,
    \ pop hl / pop de
  CB c, 2C c,  CB c, 1C c,  CB c, 1D c,
    \ sra h  /  rr h /  rr l
  CB c, 1A c,  CB c, 1B c,
    \ rr d /  rr e
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

( d2* d2/ )

  \ Credit:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]  need z80-asm

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  de pop  hl pop
  hl addp  e rl  d rl
                              \ alternatives:
  exde  pushhlde jp           \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  hl pop  de pop
  h sra  l rr  d rr  e rr

                              \ alternatives:
  pushhlde jp                 \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

( dxor dor dand )

  \ Credit:
  \
  \ Code written by Everett F. Carter, published on Forth
  \ Dimensions (volume 16, number 2, page 17, 1994-08).

[unneeded] dxor
?\ : dxor  ( d1 d2 -- d3 )  rot xor -rot xor swap  ;

[unneeded] dor
?\ : dor  ( d1 d2 -- d3 )  rot or -rot or swap  ;

[unneeded] dand
?\ : dand  ( d1 d2 -- d3 )  rot and -rot and swap  ;

( m* )

  \ Credit:
  \
  \ Code by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

  \ XXX TODO benchmark with the version in the kernel

need d*

: m*  ( n1 n2 -- d )
  >r s>d r> s>d d* ;

( m+ )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need z80-asm

code m+  ( d1|ud1 n -- d2|ud2 )
  exx     \ save Forth IP
  bc pop  \ n
  de pop  \ d1 hi cell
  hl pop  \ d1 lo cell
  bc addp  hl push
  cy if  de inc  then  de push
  exx      \ restore Forth IP
  jpnext
  end-code

  \ doc{
  \
  \ m+  ( d1|ud1 n -- d2|ud2 )
  \
  \ Add _n_ to _d1|ud1_, giving the sum _d2|ud2_.
  \
  \ Origin: Forth-94 (DOUBLE) Forth-2012 (DOUBLE).
  \
  \ }doc

exit

  \ This alternative is slower (1.48), but saves 4 bytes.

: m+  ( d1|ud1 n -- d2|ud2 )  s>d d+  ;

( m*/ )

  \ Credit:
  \
  \ Code from Gforth 0.7.3.

: m*/  ( d1 n1 +n2 -- d2 )

  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;

  \ doc{
  \
  \ m*/  ( d1 n1 +n2 -- d2 )
  \
  \ Multiply _d1_ by _n1_ producing the triple-cell
  \ intermediate result _t_.  Divide _t_ by _+n2_ giving the
  \ double-cell quotient _d2_.
  \
  \ }doc

  \ XXX TODO -- see difference Gforth - Forth-94

( m*/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need mt*  need tnegate  need ut/

: m*/  ( d1 n1 +n2 -- d2 )
    >r mt* dup 0< if    tnegate r> ut/ dnegate
                  else  r> ut/  then  ;

( dsqrt )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need q2*  need d2*  need d<  need m+  need d- need 2rot
need 2nip  [defined] cell-bits ?\ 16 constant cell-bits

  \ XXX FIXME wrong results
  \
  \ It worked fine, but something got wrong
  \ Perhaps because of some wrong dependency?
  \ maybe `d<`?
  \
  \ It works in Gforth

: (dsqrt)  ( radicand . -- remainder . root . )
  0. 0.             ( radicand . remainder . root . )
  cell-bits 0 do    ( radicand . remainder . root . )
    cr .s  key drop  \ XXX INFORMER
    2>r q2* q2* 2r>  d2*
    2over 2over d2* 2swap
      cr .s ." d< ?"  \ XXX INFORMER
      d< if
      cr .s ." d<"  \ XXX INFORMER
      2dup 2>r d2* d- -1 m+ 2r>  1 m+
    then
  loop  cr .s 2rot 2drop  ;

: dsqrt  ( radicand . -- root . )  (dsqrt) 2nip  ;

( d10* )

  \ Credit:
  \ Code from Pygmy Forth.

: d10*  ( ud -- ud*10 )  d2* 2dup d2* d2* d+  ;

  \ vim: filetype=soloforth
  \ math.operators.3-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604150254

  \ -----------------------------------------------------------
  \ Description

  \ Triple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( tum* tum/ t+ t- )

  \ Credit:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

  \ XXX TODO -- test

need d-

: +carry  ( n1 n2 -- n1+n2 carry )  0 tuck d+  ;

: -borrow  ( n1 n2 -- n1-n2 borrow )  0 tuck d-  ;

: tum*  ( d n -- t )  2>r  r@ um*  0 2r>  um* d+  ;
  \ Triple unsigned mixed multiply.

: tum/  ( t n -- d )  dup >r um/mod r> swap >r um/mod nip r>  ;
  \ Triple unsigned mixed division.

: t+  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r +carry  0 r> r> +carry d+ r> r> + +  ;
  \ Triple add.

: t-  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r -borrow
  s>d r> r> -borrow d+ r> r> - +  ;
  \ Triple substract.

( tnegate )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: tnegate  ( t1 -- t2 )
  invert >r
  invert >r
  invert 0 -1 -1 d+ s>d r> 0 d+
  r> +  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ tnegate  ( t1 -- t2 )
  \
  \ _t2_ is the negation of _t1_.
  \
  \ }doc

( ut* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut*   ( ud u -- t )
  swap >r dup >r
  um* 0 r> r> um* d+  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut*   ( ud u -- t )
  \
  \ _t_ is the signed product of _ud_ times _u_.
  \
  \ }doc

( mt* )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

need ut*  need tnegate

: mt*   ( d n -- t )
  dup 0<
  if   abs over 0< if   >r dabs r> ut*  else ut* tnegate then
  else over 0< if  >r dabs r> ut* tnegate  else  ut*  then
  then ;

  \ XXX TODO -- test

  \ doc{
  \
  \ mt*   ( d n -- t )
  \
  \ _t_ is the signed product of _d_ times _n_.
  \
  \ }doc

( ut/ )

  \ Credit:
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

: ut/   ( ut n -- d )
  dup >r um/mod -rot r> um/mod nip swap  ;

  \ XXX TODO -- test

  \ doc{
  \
  \ ut/   ( ut n -- d )
  \
  \ Divide a triple unsigned number _ut_ by a single number _n_
  \ giving the double number result _d_.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ math.operators.4-cell.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604271709

  \ -----------------------------------------------------------
  \ Description

  \ Quadruple-cell operators.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-11-13: Add `q2*`.

( q2* )

  \ Credit:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need d2*

: q2*  ( n . . . -- 2n . . . )
  d2* >r >r
  dup 0< if     d2* r> 1+ r>
         else   d2* r> r>
         then  ;

( q+ q- q0< q0= qu< qnegate qabs )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

code q+  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

code q-  ( nq1 nq2 -- nq3 )
  \ XXX TODO -- port to Z80
end-code

: q0<  ( nq -- f )  0< push drop 2drop pop  ;
: q0=  ( nq -- f )  or or or 0=  ;
: qu<  ( uq uq -- f )  q- q0<  ;
: qnegate  ( nq -- nq' )  0 0 0 0 4swap q-  ;
: qabs  ( nq -- uq )  dup 0< if qnegate then  ;

( udm* dm* )

  \ Credit:
  \
  \ copyright 1990-2007  Frank Sergeant
  \ License:  http://pygmy.utoh.org/license.html

need qnegate

code udm*  ( ud ud - quad )
  \ XXX TODO -- port to Z80
end-code

: dm* ( nd nd - nq )
  2>r dup 0< dup >r if  dnegate  then
  r> 2r> dup 0< dup >r if  dnegate  then
  rot >r udm* 2r> xor 0< if  qnegate  then  ;

  \ vim: filetype=soloforth
  \ memory.address_register.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605101814

  \ -----------------------------------------------------------
  \ Description

  \ Address register store and fetch words.
  \
  \ There aren't any spare registers to make this as efficient
  \ as it could be. However, it can still give a useful
  \ improvement in loops, and in many cases also results in
  \ cleaner-looking code.  (From the original source of Z88
  \ CamelForth, by Garry Lancaster.)

  \ -----------------------------------------------------------
  \ Authors

  \ Garry Lancaster wrote the original code for Z88 CamelForth,
  \ 2001.
  \
  \ Marcos Cruz (programandala.net) adapted the code for Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-07-20: Copy the code from Z88 CamelForth. Start
  \ adapting it.
  \ 2015-07-21: Finish the adaption. Not tested yet.
  \ 2015-07-22: Let independent loading of the words.
  \ 2016-05-07: Make block titles compatible with `indexer`.
  \ 2016-05-10: Compact the blocks. Fix `!a`, `!a+`, `c@a+`.
  \ Document.

( a a! a@ )

variable a

  \ doc{
  \
  \ a  ( -- a )
  \
  \ A variable that holds the address register.
  \
  \ See `a!`, `a@`,
  \ `!a`, `@a`, `c!a`, `c@a`, `!a+`, `@a+`, `c!a+`, `c@a+`.
  \
  \ }doc

code a!  ( a0 -- )  E1 c, 22 c, a , jpnext  end-code
    \ pop hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ a!  ( a -- )
  \
  \ Set the address register.
  \
  \ See `a`, `a@`.
  \
  \ }doc

code a@  ( -- a0 )  2A c, a , C3 c, pushhl ,  end-code
    \ ld hl,(a)
    \ jp pushhl

  \ doc{
  \
  \ a@  ( -- a )
  \
  \ Get the address register.
  \
  \ See `a`, `a!`.
  \
  \ }doc

( !a @a c!a c@a )

need a  need ?(

[unneeded] !a ?(
code !a  ( x -- )  D1 c, 2A c, a , 70 03 + c, 23 c, 70 02 + c,
                   jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ jp next

  \ doc{
  \
  \ !a  ( x -- )
  \
  \ Store _x_ at the address register.
  \
  \ See `a`, `@a`.
  \
  \ }doc

[unneeded] @a ?(
code @a  ( -- x )  2A c, a , 5E c, 23 c, 66 c, 68 03 + c,
                   C3 c, pushhl ,  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld h,(hl)
    \ ld l,e
    \ jp pushhl

  \ doc{
  \
  \ @a ( -- x )
  \
  \ Fetch _x_ at the address register.
  \
  \ See `a`, `!a`.
  \
  \ }doc

[unneeded] c!a ?(
code c!a  ( c -- )  D1 c, 2A c, a , 70 03 + c, jpnext
                    end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ c!a  ( c -- )
  \
  \ Store _c_ at the address register.
  \
  \ See `a`, `c@a`.
  \
  \ }doc

[unneeded] c@a ?(
code c@a  ( -- c )  2A c, a , 6E c, 26 c, 00 c, C3 c, pushhl ,
                    end-code ?)
    \ ld hl,(a)
    \ ld l,(hl)
    \ ld h,0
    \ jp pushhl

  \ doc{
  \
  \ c@a ( -- c )
  \
  \ Fetch _c_ at the address register.
  \
  \ See `a`, `c!a`.
  \
  \ }doc

( !a+ @a+ c!a+ c@a+ )

need a  need ?(

[unneeded] !a+ ?(
code !a+  ( x -- )
  D1 c, 2A c, a , 70 03 + c, 23 c, 70 02 + c, 23 c, 22 c, a ,
  jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ inc hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ !a+  ( x -- )
  \
  \ Store _x_ at the address register and increment the address
  \ register by one cell.
  \
  \ See `a`, `@a+`.
  \
  \ }doc

[unneeded] @a+ ?(
code @a+  ( -- x )
  2A c, a , 5E c, 23 c, 56 c, 23 c, 22 c, a , D5 c, jpnext
  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc hl
    \ ld (a),hl
    \ push de
    \ jp next

  \ doc{
  \
  \ @a+ ( -- x )
  \
  \ Fetch cell at the address register and increment the
  \ address register by one cell.
  \
  \ See `a`, `!a+`.
  \
  \ }doc


[unneeded] c!a+ ?(
code c!a+  ( c -- )  D1 c, 2A c, a , 70 03 + c, 23 c,
                     22 c, a , jpnext  end-code ?)
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (a),hl
    \ jp next

  \ doc{
  \
  \ c!a+  ( c -- )
  \
  \ Store _c_ at the address register and increment the address
  \ register by one address unit.
  \
  \ See `a`, `c@a+`.
  \
  \ }doc

[unneeded] c@a+ ?(
code c@a+  ( -- c )  2A c, a , 5E c, 23 c, 16 c, 00 c,
                     22 c, a , D5 c, jpnext  end-code ?)
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld d,0
    \ ld (a),hl
    \ push de
    \ jp next

  \ doc{
  \
  \ c@a+  ( -- c )
  \
  \ Fetch _c_ at the address register and increment the address
  \ register by one address unit.
  \
  \ See `a`, `c!a+`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.alocate.charlton.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604031945

  \ -----------------------------------------------------------
  \ Description

  \ A standard implementation of the memory-allocation word
  \ set.

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, `allocate`,
  \ `free`, and `resize` which give the minimum functionality
  \ required to use the heap. These are given in areas 3, 4 and
  \ 5 respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant `heapsize`. the constant
  \ `hysteresis` controls the amount of spare space that is
  \ added to an allocation, to reduce the need for block moves
  \ during resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright Gordon Charlton, 1994-09-12.

  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ Solo Forth version of the code:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ Original code:

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.  <gordon at charlton dot
  \ demon dot co dot uk>

( heap )


  \ XXX REMARK: 1614 bytes used

  \ XXX TODO use top of memory instead of dictionary space?
  \ problem: memory banks could not be used at the same time.
  \
  \ XXX TODO use a memory bank instead of dictionary space?
  \ problem: only words below 0xC000 could manipulate the heap.

also forth definitions
need wid-of
vocabulary heap-voc  wid-of heap-voc constant heap-wordlist
also heap-voc definitions

  \ XXX TODO -- alternative
  \ forth-wordlist set-current
  \ wordlist heap-wordlist

  \ **1** General Purpose Extensions

0 1 2 um/mod nip 1- constant maxpos
  \ XXX TODO use `environment?` instead when available

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  --  Constants

256 cells constant heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 cells 1- constant hysteresis

  \ Node lengths are rounded up according to the value of
  \ `hysteresis` to reduce the number of block moves during
  \ `resize` operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

3 cells constant headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis or  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize constant overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  --  Structure

create sentinel  here cell+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

create heap  heapsize allot

  \ The heap is as described in `headsize`.

variable nextnode  -->

  \ Searching is done using a "nextfit" algorithm. `nextnode`
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr1 -- addr2)  cell+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr1 -- addr2)  [ 2 cells ] literal +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )
  heap dup nextnode !
  dup dup !
  dup heapsize  over >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does
  \ `nextnode`.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  --  List Searching

: attach ( addr)
  >prev @  dup sentinel rot !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (_addr_) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >r begin 2@ swap R@ < invert until
  r> drop  >prev @  ;

  \ Search the nodelist, starting at the node specified
  \ (_addr_), for a free node larger than or equal to the
  \ specified _size_.  Return the address of the first node
  \ that matches, or zero for no match. The heap structure is
  \ set up to make this a near optimal search loop. The "size"
  \ field is next to the "next" field so that both can be
  \ collected in a single operation (2@). Nodes in use have
  \ negated sizes so they never match the search. The
  \ "previous" field is included to allow the search to
  \ overshoot the match by one node and then link back outside
  \ the loop, rather than remembering the address of the node
  \ just examined. The sentinel removes the need for a separate
  \ test for failure. `search` assumes the sentinel is in
  \ place.

: detach ( addr)  dup >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           dup      attach
           dup rot  search
           swap     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ `nextnode`, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  --  Head Creation

: fits ( size addr -- flag)  >size @ swap -  overhead  <  ;

  \ Returns _true_ if the size of the node specified is the
  \ same as the specified size, or larger than it by less than
  \ the size of the smallest possible node. Returns _false_
  \ otherwise.

: togglesize ( addr)  >size dup @  negate swap !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2dup + >r  >size 2dup @ swap -
  R@ >size !   swap negate swap !  r>  ;

  \ Given a free node (_addr_), reduce its size to that
  \ specified and mark it as in use. Start to construct a new
  \ node within the specified node beyond its new length, by
  \ storing the length of the remainder of the node in the size
  \ field of the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2dup swap @  2dup  swap !  >prev !
  2dup >prev !   swap !  ;


  \ _Addr1_ is an existing node. _Addr2_ is the address of a
  \ new node just above the existing node. Break the links from
  \ the existing node to the next node and from the next node
  \ to the existing node and join the new node to them.


  \ ANSI heap  --  Node Construction  ALLOCATE

: newnode ( size addr)  tuck sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)
  2dup fits if  togglesize drop  else  newnode  then  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

forth-wordlist set-current

: allocate ( u -- addr ior)
  dup 0< if  -59  \ `allocate` error code
       else  adjustsize
       dup findspace
       dup if  dup next!
         tuck makenode
         headsize +  0
         else  drop -59  \ `allocate` error code
         then
       then  ;

heap-wordlist set-current  -->

  \ Make an in-use node with a data field at least _u_ address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and the standard ior.  The
  \ standard specifies that the argument to `allocate` is
  \ unsigned. As the implementation uses the sign bit of the
  \ size field for its own purposes any request for an amount
  \ of space greater than `maxpos` must fail. As this would be
  \ a request for half the addressable memory or more this is
  \ not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  --  Head Destruction

: mergesizes ( addr1 addr2)
  >size @ swap >size +!  ;

  \ Make the size field of the node at _addr1_ equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at _addr2_ will be the one immediately above _addr1_.

: mergelinks ( addr1 addr2)
  @ 2dup swap !  >prev !  ;

  \ The node at _addr2_ is removed from the node list. As with
  \ `mergesizes` the node at _addr2_ will be immediately above
  \ that at _addr1_. Destroy the link from node1 to node2 and
  \ relink node1 to the node above node2. Destroy the backward
  \ link from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that `nextnode` may point to it. This is cured by
  \ making it point to the node prior to the one removed. We do
  \ not want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically `nextnode` is set to
  \ point to the node pointed to by the "previous" field of the
  \ node pointed to in the "next" field of the node pointed to
  \ by `nextnode`. Ordinarily this is a no-op (ie I am my
  \ father's son) but when the node has had its links merged it
  \ sets `nextnode` to point to the node prior to the node it
  \ pointed to (ie when I died my father adopted my son, so now
  \ my son is my father's son).

: merge ( addr)
  dup @ 2dup mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  --  Node Removal

: ?merge ( addr1 addr2)
  >size @ 0> if
    dup dup @
    u< if  dup merge  then
  then  drop  ;  -->

  \ Merge the node at _addr1_ with the one above it on two
  \ conditions, firstly that the node at _addr2_ is free, and
  \ secondly that the node pointed to by the next field in
  \ _addr1_ is actually above _addr1_ (ie that it does not wrap
  \ around because it is the topmost node). In usage _addr2_
  \ will be either _addr1_ or the node above it. In each
  \ instance the other affected node (either the node above
  \ _addr1_ or _addr1_) is known to be free, so no test is
  \ needed for this.

( heap )

: ?mergenext ( addr)  dup @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ dup ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

forth-wordlist set-current

: free ( addr -- ior)
  headsize -  dup togglesize  dup ?mergenext  ?mergeprev  0  ;

heap-wordlist set-current

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  --  Node Repairing

variable stash

  \ the `resize` algorithm is simplified and made faster by
  \ assuming that it will always succeed. `stash` holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ saves the contents of the `>next` field of the node being
  \ `resize`d in `stash` (above).

: restorelink ( addr)  stash @  swap !  ;

  \ Converse operation to `savelink` (above).

: fixprev ( addr)  dup >prev @ !  ;

  \ The `>next` field of the node prior to the node being
  \ `resize`d should point to the node being `resize`d. it may
  \ very well do already, but this makes sure.

: fixnext ( addr)  dup @ >prev !  ;

  \ The `>prev` field of the node after the node resized may
  \ need correcting.  This corrects it whether it needs it or
  \ not.  (Its quicker just to do it than to check first.)

: fixlinks ( addr)  dup fixprev  dup fixnext  @ fixnext  ;

  \ `resize` may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of `jiggle` (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)
  dup >size @ 0>
  if  dup @  2dup <
      if    over - swap >size !  else  2drop  then
  else  drop  then  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the `>next` field provided
  \ that the node is free and it is not the topmost node in the
  \ heap (ie there is no wraparound). Both these conditions
  \ need to be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  dup fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to `resize` (damaged by
  \ `?mergenext`) and its predecessor (damaged by `?mergeprev`).

: repair ( addr)
  dup restorelink
  dup fixlinks  dup fixsizes
  togglesize  ;

  \ Make good the damage done by `resize`. Restore the `>next`
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer `nextnode`
  \ may have moved back one or two nodes by virtue of having
  \ been `jiggle`d about if it happened to be pointing to the
  \ wrong node. This is not serious, so I have chosen to ignore
  \ it.


  \ ANSI Heap  --  Node Movement

: toobig? ( addr size -- flag)
  swap  >size @  >  ;

  \ _Flag_ is true if the node at _addr_ is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
  over >size @  headsize -
  rot  headsize + rot rot move  ;

  \ Move the contents of the data field of the node at _addr1_
  \ to the data field at _addr2_. Assumes _addr2_ is large
  \ enough. It will be.

: enlarge ( addr1 size -- addr2 ior)
  over  ?mergeprev
  allocate dup >r
  if  swap repair  else  tuck copynode  then  r>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of _addr1_ to the new node. Merge the node at addr1 with
  \ the one preceding it, if possible. This last behaviour is
  \ to finish off removing the node at _addr1_. The word
  \ `adjust` (below) starts removing the node. The node is
  \ removed before allocation to increase the probability of
  \ `allocate` succeeding. The address returned by `enlarge` is
  \ that returned by `allocate`, which is that of the data
  \ field, not the head. If the allocation fails repair the
  \ damage done by removing the node at _addr1_.


  \ ANSI Heap  --  Node Restructuring

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >r
  headsize -
  dup savelink
  dup togglesize
  dup ?mergenext r>  ;

  \ _Addr1_ points to the data field of a node, not the "next"
  \ field. This needs correcting. _Size1_ also needs adjusting
  \ as per `adjustsize`. In addition it is easier to work with
  \ free nodes than live ones as the size field is correct,
  \ and, as we intend to change the nodes size we will
  \ inevitably want to muck about with the next node, if its
  \ free, so lets merge with it straight away. Sufficient
  \ information is first saved to put the heap back as it was,
  \ if necessary.  Now we are ready to get down to business.

-->

( heap )

forth-wordlist set-current

: resize ( addr1 u -- addr2 ior)
  dup 0<  if  drop -61  \ `resize` error code
          else  adjust  2dup toobig?
                if enlarge
                else  over makenode headsize +  0  then
          then  ;

  \ Resize the node at _addr1_ to the specified size. Return
  \ the address of the resized node _addr2_ along with an _ior_
  \ of zero if successful and -61 if not. _Addr2_ may be the
  \ same as, or different to, _addr1_.  If _ior_ is non-zero
  \ then _addr2_ is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using `makenode`,
  \ which has just the right functionality.  In this case the
  \ ior is zero. As this is a standard word it takes an
  \ unsigned size argument, but excessive requests fail
  \ automatically, as with `allocate`.

  \ vim: filetype=soloforth
  \ memory.alocate.gil.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604242144

  \ -----------------------------------------------------------
  \ Description

  \ An alternative implementation of the
  \ common heap based on code written by Javier Gil.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Based on "Gestor de memoria dinmica (version 1)" by Javier
  \ Gil, from his book _Introduccin a Forth_ (2007-01),
  \ <http://disc.ua.es/~gil/#forth>.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-18: Start.
  \ 2015-11-21: Changes.
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( create-heap )

need value  need set-bit  need reset-bit  need bit?
need reserve  need alias

0 value heap  ( -- a )
  \ Address of the current heap.

8 constant address-unit-bits
16 value /chunk \ bytes per chunk

: groups ( n1 n2 -- n3 )  /mod swap 0<> abs +  ;
  \ Return the number _n3_ of groups of _n2_ elements, needed
  \ to hold _n1_ elements.

: bytes>chunks ( n1 -- n2 )  /chunk groups  ;
  \ Return the chunks _n2_ required to allocate _n1_ bytes.

: chunks>bytes ( n1 -- n2 )  address-unit-bits groups  ;
  \ Return the bytes _n2_ required for a bitmap of _n1_ chunks.

' heap alias heap-chunks  ( -- a )
  \ Address that holds the number of chunks of the current
  \ heap.

: heap-unused-chunks  ( -- a )  heap-chunks cell+  ;
  \ Address that holds the number of unused chunks of the
  \ current heap.

: heap-map  ( -- a )  heap-unused-chunks cell+  ;
  \ Address of the current heap's map.

: /heap-map  ( -- n )  heap-chunks @ chunks>bytes  ;
  \ Number of bytes of the current heap's map.

: heap-data  ( -- a ) heap-map /heap-map +  ;  -->
  \ Address of the current heap's data space.

( create-heap )

: (mapbit)  ( n1 -- n2 ca )
  address-unit-bits /mod heap-map +  ;
  \ n1 = number of bit in the bitmap
  \ n2 = number of bit in the byte at _a2_
  \ ca = address of the bitmap that holds bit _n2_

: mapbit ( n1 -- a2 b n2 )  (mapbit) dup @ rot  ;
  \ n1 = number of bit in the bitmap
  \ a2 = address of the correspondent byte
  \ b =  correspondent byte
  \ n2 = number of bit in _b_

: used-chunk? ( n -- f )  (mapbit) @ swap bit?  ;
  \ Is chunk _n_ used?

: use-chunk ( n -- )  mapbit set-bit swap !  ;
  \ Mark chunk _n_ as used.

: free-chunk ( n -- )  mapbit reset-bit swap !  ;
  \ Mark chunk _n_ as free.

: allocated>chunks  ( a -- n )  cell- @  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its number of chunks.

: allocated>index  ( a -- n )  heap-data - /chunk /  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n_ in the map of the heap
  \ chunks.

: allocated>map  ( a -- n1 n2 )
  dup allocated>index swap allocated>chunks  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n1_ in the map of heap chunks
  \ and the number _n2_ of ocuppied chunks.

-->

( create-heap )

: locate-chunks  ( n1 -- n1 n2 0 | ior )
  0 tuck  ( n2 n1 count )
  heap-chunks @ 0 do  ( n2 n1 count )
    i used-chunk? if  drop >r i 1+ r> 0  else  1+  then
    2dup = if  drop swap 0 unloop exit  then
  loop  2drop drop -59  ;
  \ Locate _n1_ consecutive free chunks in the current heap.
  \ If succesful, _n2_ is the first chunk of the group;
  \ else return _ior_ -59, the error code for `allocate`.

: chunk>address  ( n1 -- a )  /chunk * heap-data +  ;

: (allocate)  ( n1 n2 -- a )
  dup chunk>address >r
  swap bounds do  i use-chunk  loop
  r>  ;
  \ Allocate _n1_ chunks of the current heap, starting from
  \ chunk _n2_; return the address _a_ of the allocated space.

-->

( create-heap )

  \ User interface

: create-heap ( n "name" -- )
  create  bytes>chunks dup ,  0 ,
            \ max chunks and free chunks
          dup chunks>bytes reserve drop
            \ bitmap
          /chunk * allot  ;
            \ data space
  \ Create a new heap "name" to hold _n_ bytes.

: allocate  ( n -- a ior )
  bytes>chunks locate-chunks ?dup ?exit  (allocate) 0  ;

: free  ( a -- ior )
  allocated>map dup >r
  bounds do  i free-chunk  loop
  r> heap-unused-chunks +! 0  ;

  \ XXX TODO -- update with `resize`
  \ doc{
  \
  \ free  ( a -- ior )
  \
  \ Return the contiguous region of data space indicated by _a_
  \ to the system for later allocation. _a_ shall indicate a
  \ region of data space that was previously obtained by
  \ `allocate`.
  \
  \ If the operation succeeds, _ior_ is zero. If the operation
  \ fails, _ior_ is -60.
  \
  \ Origin: Forth-94 (MEMORY), Forth-2012 (MEMORY).
  \
  \ }doc

: empty-heap  ( -- )  heap-chunks @ 0 do  i free-chunk  loop  ;
  \ Empty the current heap, setting all chunks free.

: .heap ( -- )
  heap-chunks @ 0 do
    i used-chunk? if  'x'  else  '-'  then  emit
  loop  ;

  \ Print the map of the current heap. Occupied chunks are
  \ marked with a "x"; free chunks are marked with a "-".

  \ vim: filetype=soloforth

  \ memory.bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604241652

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory banks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-17: Moved `!s` and `!cs` from the kernel.
  \
  \ 2016-04-24: Moved `get-default-bank` and `set-default-bank`
  \ from the kernel.

( !s c!s )

: !s  ( x a -- )  system-bank ! default-bank  ;

  \ doc{
  \
  \ !s  ( x a -- )
  \
  \ Store _x_ into address _a_ of the system bank.
  \
  \ }doc

: c!s  ( c ca -- )  system-bank c! default-bank  ;

  \ doc{
  \
  \ c!s  ( c ca -- )
  \
  \ Store _c_ into address _ca_ of the system bank.
  \
  \ }doc

( get-default-bank set-default-bank )


: get-default-bank  ( -- +n )  default-bank# c@  ;

  \ doc{
  \
  \ get-default-bank  ( -- +n )
  \
  \ Get the current default bank _+n_ (0..7) paged in at
  \ $C000..$FFFF.
  \
  \ }doc

: set-default-bank  ( +n -- )  default-bank# c!  ;

  \ doc{
  \
  \ set-default-bank  ( +n -- )
  \
  \ Set _+n_ (0..7) as the default memory bank paged in at
  \ $C000..$FFFF.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.code-bank.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 20160326

  \ -----------------------------------------------------------
  \ Description

  \ Tool to use a 16-KiB memory bank to store binary code,
  \ Forth words or data.  The intent is to use it mainly for
  \ binary modules, saving dictionary space.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-03-19: First version.

( code-bank )

need save-here  need call

variable cp  bank-start cp !  \ code pointer

: code-here   ( -- a )  cp @  ;
: code-there  ( a -- )  cp !  ;
: code-allot  ( n -- )  cp +!  ;

variable code-bank#  3 code-bank# !
  \ Memory bank used as code bank.

: code-bank  ( -- )  code-bank# @ bank  ;
  \ Page the code bank in.

: code-bank{  ( -- )  save-here code-here there code-bank  ;
  \ Start compiling code into the code bank.

: }code-bank  ( -- )  default-bank restore-here  ;
  \ End compiling code into the code bank.

: ?bank  ( -- )  bank-start here u< #-276 ?throw  ;
  \ If the dictionary has reached the zone of memory banks,
  \ throw error #-276; else do nothing.  This check is required
  \ after compiling code that manipulates memory banks.

: code-bank-caller  ( i*x a "name" -- j*x )
  create ?bank ,
  does>  ( -- )  ( pfa ) @ code-bank call default-bank  ;
  \ Create a word "name" which will call the machine code
  \ routine at _a_, in the code bank.

?bank

  \ vim: filetype=soloforth
  \ memory.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605101657

  \ -----------------------------------------------------------
  \ Description

  \ Words related to memory.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-17: Added `-!`. Documented some words.
  \ 2016-04-23: Added `c-!`.
  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.
  \ 2016-04-25: Add `@cell+`. Move `n,`, `n@`, `n!` from the
  \ module "compilation.fsb".  Add `nn@`, `nn,`, `nn!`.
  \ 2016-04-26: Remove unused words, specific of the TED
  \ editor.
  \ 2016-04-27: Add `/!`, `*!`, `2/!`, `2*!`.
  \ 2016-05-09: Add `align`, `aligned`.
  \ 2016-05-10: Remove the dependency on the assembler.
  \ Compact the blocks. Remove unfinished words from cmForth.
  \ Rename `@cell+` to `@+`. Add `2@+`.

( -! c+! c-! c@+ )

need ?(

[unneeded] -! ?(

code -!  ( n|u a -- )
  E1 c, D1 c, 7E c, 90 03 + c, 70 07 + c, 23 c,
    \ pop hl ; address
    \ pop de ; number
    \ ld a,(hl)
    \ sub a,e
    \ ld (hl),a
    \ inc hl
  7E c, 98 02 + c, 70 07 + c, jpnext  end-code ?)
    \ ld a,(hl)
    \ sbc a,d
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ -!  ( n|u a -- )
  \
  \ Subtract n|u from the single-cell number at _a_.
  \
  \ }doc

[unneeded] c+! ?(

code c+!  ( c ca -- )
  E1 c, D1 c, 78 03 + c, 86 c, 70 07 + c, jpnext  end-code ?)
    \ pop hl
    \ pop de
    \ ld a,e
    \ add a,(hl)
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ code c+!  ( c ca - )
  \
  \ Add _c_ to the char at _ca_
  \
  \ }doc

[unneeded] c-! ?(

code c-!  ( c ca -- )
  E1 c, D1 c, 7E c, 90 03 + c, 70 07 + c, jpnext  end-code ?)
    \ pop hl
    \ pop de
    \ ld a,(hl)
    \ sub e
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ c-!  ( c ca - )
  \
  \ Subtract _c_ from the char at _ca_
  \
  \ }doc

( 1+! 1-! c1+! c1-! )

need ?(

[unneeded] 1+! ?(

code 1+!  ( a -- )
  E1 c, 5E c, 23 c, 56 c, 13 c, 70 02 + c, 2B c, 70 03 + c,
  jpnext end-code
    \ pop hl
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the single-cell number at _a_.
  \
  \ }doc

[unneeded] 1-! ?(

code 1-!  ( a -- )
  E1 c, 5E c, 23 c, 56 c, 1B c, 70 02 + c, 2B c, 70 03 + c,
  jpnext end-code
    \ pop hl
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl)
    \ inc de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e
    \ jp next

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the single-cell number at _a_.
  \
  \ }doc

[unneeded] c1+!
?\  code c1+!  ( ca -- )  E1 c, 34 c, jpnext  end-code
    \ pop hl
    \ inc (hl)
    \ jp next

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the char at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  E1 c, 35 c, jpnext  end-code
    \ pop hl
    \ dec (hl)
    \ jp next

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the char at _ca_.
  \
  \ }doc

( @+ 2@+ c@+ )

[unneeded] @+
?\ : @+  ( a -- a' x )  dup cell+ swap @  ;

  \ doc{
  \
  \ @+  ( a -- a' x )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by one cell.
  \ This is handy for stepping through cell arrays.
  \
  \ }doc

[unneeded] 2@+
?\ : 2@+  ( a -- a' xd )  dup [ 2 cells ] literal + swap 2@  ;

  \ doc{
  \
  \ @+  ( a -- a' x )
  \
  \ Fetch data _x_ from _a_. Return _a'_, which is _a_
  \ incremented by two cells.
  \ This is handy for stepping through double-cell arrays.
  \
  \ }doc

[unneeded] c@+ ?exit

code c@+  ( ca -- ca' c )
  E1 c, 7E c, 23 c, E5 c, C3 c, pusha ,  end-code
    \ pop hl
    \ ld a,(hl)
    \ inc hl
    \ push hl
    \ jp push_a

  \ Credit:
  \
  \ Code adapted from Pygmy Forth.

  \ doc{
  \
  \ code c@+  ( ca -- ca' c )
  \
  \ Fetch the character _c_ at _ca_. Return _ca'_, which is
  \ _ca_ incremented by one address unit.
  \ This is handy for stepping through character arrays.
  \
  \ }doc

( n, nn, n@ nn@ n! nn! )

[unneeded] n, ?\ : n,  ( xu..x1 u -- )  0 ?do  ,  loop  ; exit
  \ If _u_ is not zero, store _u_ cells _xu..x1_ into data
  \ space, being _x1_ the first one stored and _xu_ the last
  \ one.

need ?(  [unneeded] nn, ?(  need need-here  need-here n,
: nn,  ( xu..x1 u -- )  dup , n,  ; ?)
  \ Store the count _u_ into data space.  If _u_ is not zero,
  \ store also _u_ cells _xu..x1_ into data space, being _x1_
  \ the first one stored and _xu_ the last one.

[unneeded] n@ ?(
: n@  ( a u -- xu..x1 )
  tuck 1- cells +  \ point _a_ to _xu_
  swap 0 ?do  dup i cells - @ swap  loop  drop  ; exit ?)
  \ If _u_ is not zero, read _u_ cells _xu..x1_ from
  \ _a_, being _x1_ the first one stored and _xu_ the last
  \ one.

[unneeded] nn@ ?( need need-here  need-here n@
: nn@  ( a -- x1..xu u | 0 )  dup @ >r cell+ r@ n@ r>  ; ?)
  \ Read the count _u_ from _a_.  If it's zero, return it.  If
  \ _u_ is not zero, read _u_ cells _xu..x1_ from the next cell
  \ address, being _x1_ the first cell stored there and _xu_
  \ the last one.

[unneeded] n! ?(
: n!  ( xu..x1 u a -- )
  swap 0 ?do  dup >r ! r> cell+  loop  drop  ; exit ?)
  \ If _u_ is not zero, store _u_ cells at address _a_, being
  \ _x1_ the first cell stored there and _xu_ the last one.

[unneeded] nn! ?( need need-here  need-here n!
: nn!  ( xu..x1 u a -- )  2dup ! cell+ n!  ; ?)
  \ Store the count _u_ at _a_.  If _u_ is not zero, store also
  \ _u_ cells _xu..x1_ at the next cell address, being _x1_ the
  \ first one stored and _xu_ the last one.

( bit>mask bit? set-bit reset-bit )

[unneeded] bit? [unneeded] set-bit? [unneeded] reset-bit?
[unneeded] bit>bask and and and
?\ need lshift  : bit>mask  ( n -- b )  1 swap lshift  ;

  \ doc{
  \
  \ bit>mask  ( n -- b )
  \
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.
  \
  \ }doc

[unneeded] bit?
?\ : bit? ( b n -- f )  bit>mask and 0<> ;

  \ doc{
  \
  \ bit? ( b n -- f )
  \
  \ Is bit _n_ of _b_ set?
  \
  \ }doc

[unneeded] set-bit?
?\ : set-bit ( b1 n -- b2 )  bit>mask or ;

  \ doc{
  \
  \ set-bit ( b1 n -- b2 )
  \
  \ Set bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

[unneeded] reset-bit?
?\ : reset-bit ( b1 n -- b2 )  bit>mask invert and ;

  \ doc{
  \
  \ reset-bit ( b1 n -- b2 )
  \
  \ Reset bit _n_ of _b1_, returning the result _b2_.
  \
  \ }doc

( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credit:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need ?(

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- f )
  \   hl pop  de pop  e a ld  m and
  \   ' true jpnz  ' false jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s '<' emit type '>' emit cr

[unneeded] c@test-bits ?(
code c@test-bits  ( b1 ca -- b2 )
  E1 c, D1 c, 78 03 + c, A6 c, C3 c, pusha , jpnext end-code ?)
    \ pop hl
    \ pop de
    \ ld a,e
    \ and (hl)
    \ jp push_a

  \ doc{
  \
  \ c@test-bits  ( b1 ca -- b2 )
  \
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.
  \
  \ }doc

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[unneeded] c!toggle-bits ?(
code c!toggle-bits  ( b ca -- )
  E1 c, D1 c, 7E c, A8 03 + c, 70 07 + c, jpnext end-code ?)
    \ pop hl
    \ pop de
    \ ld a,(hl)
    \ xor e
    \ ld (hl),a
    \ jp next

  \ doc{
  \
  \ c!toggle-bits  ( b ca -- )
  \
  \ Invert the bits at _ca_ specified by the bitmask _b_.
  \
  \ }doc

( exchange reserve alloted align aligned )

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

[unneeded] reserve
?\ : reserve  ( n -- a )  here tuck over erase allot  ;

  \ doc{
  \
  \ reserve  ( n -- a )
  \
  \ Reserve _n_ address units of data space, erase the zone and
  \ return its address _a_.
  \
  \ }doc

[unneeded] alloted
?\ : allotted  ( n -- a )  here swap allot ;

  \ doc{
  \
  \ allotted  ( n -- a )
  \
  \ Reserve _n_ address units of data space and return its
  \ address _a_.
  \
  \ }doc

[unneeded] align
?\ need alias  ' noop alias align immediate

[unneeded] aligned
?\ need alias  ' noop alias aligned immediate

( /! *! 2/! 2*! )

[unneeded] /!
?\ : /!  ( n a -- )  tuck @ swap / swap !  ;

  \ doc{
  \
  \ /!  ( n a -- )
  \
  \ Divide _n_ by the single-cell number at _a_ and store
  \ the quotient in _a_
  \
  \ }doc

[unneeded] *!
?\ : *!  ( n a -- )  tuck @ swap * swap !  ;

  \ doc{
  \
  \ *!  ( n|u a -- )
  \
  \ Multiply _n|u_ by the single-cell number at _a_ and store
  \ the product in _a_
  \
  \ }doc

[unneeded] 2*!
?\ : 2*!  ( a -- )  dup @ 2* swap !  ;

  \ doc{
  \
  \ 2*!  ( a -- )
  \
  \ Do a `2*` shift to the single-cell number at _a_.
  \
  \ See `2*`.
  \
  \ }doc

[unneeded] 2/!
?\ need 2/  : 2/!  ( a -- )  dup @ 2/ swap !  ;

  \ doc{
  \
  \ 2/!  ( a -- )
  \
  \ Do a `2/` shift to the single-cell number at _a_.
  \
  \ See `2/`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ memory.ports.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605071939

  \ -----------------------------------------------------------
  \ Description

  \ Words for ports input and output.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Improve documentation. Compact the blocks.

( @p !p )

need ?(

[unneeded] @p ?(
code @p  ( a -- b )
  E1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 68 c,
    \ pop hl
    \ push bc
    \ ld c,l
    \ ld b,h
    \ in l,(c)
  C1 c,  26 c, 00 c,  jppushhl  end-code
    \ pop bc
    \ ld h,0x00
    \ jp pushhl

  \ doc{
  \
  \ @p  ( a -- b )
  \
  \ Input byte _b_ from port _a_.
  \
  \ }doc

?)

[unneeded] !p ?(
code !p  ( b a -- )
  E1 c,  D1 c,  C5 c,  48 05 + c,  40 04 + c,  ED c, 59 c,
    \ pop hl
    \ pop de ; char in e
    \ push bc
    \ ld c,l
    \ ld b,h
    \ out (c),e
  C1 c,  jpnext  end-code
    \ pop bc
    \ jp next

  \ doc{
  \
  \ !p  ( b a -- )
  \
  \ Output byte _b_ to port _a_.
  \
  \ }doc

?)

  \ vim: filetype=soloforth
  \ modules.begin-module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604262155

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of named and unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation supports any number of groups of
  \ private and public words, in any order. Beside, named
  \ modules make it possible to use the private words of the
  \ module, if needed.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ Code adapted and modified from Galope.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-09: First version, adapted from Galope.

( begin-module: begin-module public private end-module )

need get-order  need wordlist

  \ Inner words

get-order get-current

wordlist dup set-current  >order

variable current-wid  variable module-wid

: (begin-module)  ( -- wid )
  get-current current-wid !
  wordlist dup module-wid ! dup >order  ;

set-current

  \ Interface words

: public  ( -- )  current-wid @ set-current  ;
  \ doc{
  \
  \ public  ( -- )
  \
  \ Public definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: private  ( -- )  module-wid @ set-current  ;
  \ doc{
  \
  \ private  ( -- )
  \
  \ Private definitions of a module follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc


: begin-module:  ( "name" -- )
  (begin-module) constant private  ;
  \ doc{
  \
  \ begin-module:  ( "name" -- )
  \
  \ Start a named module "name".
  \ Private definitions follow.

  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ Usage example:

  \ ----
  \ begin-module: my_module
  \   \ Inner/helper words.
  \ public
  \   \ Interface words,
  \   \ compiled in the outer vocabulary,
  \   \ thus seen from the extern.
  \ private
  \   \ Inner/helper words again.
  \ public
  \   \ Interface words again. And so on.
  \ end-module
  \ ----

  \ The private words can be found using the module name,
  \ which returns the _wid_ of its word list.

  \ As an alternative, the word `begin-module` starts an
  \ unnamed module.
  \
  \ }doc

: begin-module  ( -- )  (begin-module) drop private  ;
  \ doc{
  \
  \ begin-module  ( -- )
  \
  \ Start an anonymous module.
  \ Private definitions follow.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

: end-module  ( -- )  public previous  ;
  \ doc{
  \
  \ end-module  ( -- )
  \
  \ End a module.
  \ See `begin-module:` for a usage example.
  \
  \ }doc

set-order

  \ vim: filetype=soloforth
  \ modules.minus-transient.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604262043

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of transient modules, whose code is
  \ discarded after being used. First intended for assemblers,
  \ but can be used for any other tool needed during the
  \ compilation of a program, but not during the execution.
  \ The size of the discarded code must be known in advance.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ The code was adapted from the Afera library. The Afera
  \ version was adapted from Spectrum Forth-83 (by Lennart
  \ Benschop, 1988), where it was used only for the assembler.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( transient[ )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- Finish and test.
  \
  \ XXX TODO -- Check if `current-latest` (old fig-Forth
  \ `latest`) must be used instead of `latest`, which now
  \ (2016-04-26) is standard.

need >>link

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - there  ;
  \ doc{
  \
  \ transient[  ( u -- )
  \
  \ Start transient code, reserving _u_ bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.
  \
  \ See: `]transient`, `-transient`.
  \
  \ }doc


: ]transient  ( -- )  old-dp @ there  old-np @ np !  ;

  \ doc{
  \
  \ ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.
  \
  \ See: `transient[`, `-transient`.
  \
  \ }doc

: -transient  ( -- )
  old-voc-link @ voc-link !
  \ XXX TODO -- finish adapt to Solo Forth:
  old-latest @ old-np @ >>link !s  ;

  \ doc{
  \
  \ -transient  ( -- )
  \
  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.
  \
  \ The inner operation is: Store the _nt_ of the latest word
  \ created before compiling the transient code, into the _lfa_
  \ of the first word created after the transient code was
  \ finished by `]transient`.
  \
  \ See: `transient[`, `]transient`.
  \
  \ }doc

  \ See: `transient[`, `-transient`.
  \ vim: filetype=soloforth
  \ modules.module.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060224

  \ -----------------------------------------------------------
  \ Description

  \ Simple and small implementation of unnamed modules.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.
  \
  \ This implementation uses the data stack for temporary
  \ values and does no error checking.

  \ -----------------------------------------------------------
  \ Authors

  \ Deway Val Schorre wrote the original code for fig-Forth,
  \ which was published on the article _Structured programming
  \ by adding modules to FORTH_, on Forth Dimensions (volume 2,
  \ number 5, page 132, 1981-01).

  \ Marcos Cruz (programandala.net), adapted it to Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10-27: First version, as a simpler alternative to
  \ `privatize`, even with the same names at first.
  \
  \ 2016-04-26: Use `current-latest` (old fig-Forth `latest`)
  \ instead of current standard `latest`. Update the
  \ documentation.
  \
  \ 2016-05-06: Update the requirements: `current-lastest`
  \ moved to the kernel.

( module )

need alias  need >>link

' current-latest alias internal  ( -- nt )

  \ doc{
  \
  \ internal  ( -- nt )
  \
  \ Start private definitions.
  \
  \ Return the _nt_ of the latest word created in the `current`
  \ vocabulary.
  \
  \ See `module` for a usage example.
  \
  \ }doc

' np@ alias external  ( -- a )

  \ doc{
  \
  \ external  ( -- a )

  \ End internal definitions.
  \
  \ Returne the current value of the names pointer, which is
  \ the _xtp_ (execution token pointer) of the next word
  \ defined.
  \
  \ See `module` for a usage example.
  \
  \ }doc

: module  ( nt xtp -- )  >>link !s  ;

  \ doc{
  \
  \ module  ( nt xtp -- )
  \
  \ Hide all words defined between the latest pair `internal`
  \ and `external`, by linking the first word after `external`
  \ to the word before `internal`, thus making the private
  \ words invisible.
  \
  \ Those words are supposed to be needed only within a module
  \ and do not need to be exported.
  \
  \ Usage example:
  \
  \ ----
  \ internal
  \
  \ : hello  ( -- )  ." hello"  ;
  \
  \ external
  \
  \ : salute  ( -- )  hello  ;
  \
  \ module
  \
  \ salute  \ ok!
  \ hello   \ error!
  \ ----
  \
  \ }doc

  \ vim: filetype=soloforth
  \ modules.privatize.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060225

  \ -----------------------------------------------------------
  \ Description

  \ Implementation of unnamed modules with error checking.
  \
  \ Modules hide the internal implementation and leave visible
  \ the words of the outer interface.

  \ -----------------------------------------------------------
  \ Authors

  \ Copyright 1996 Phil Burk.

  \ Adapted from pForth to Solo Forth by Marcos Cruz
  \ (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-10: First version.
  \
  \ 2016-04-26: Use `current-latest` (old fig-Forth `latest`)
  \ instead of current standard `latest`.
  \
  \ 2016-05-06: Update the requirements: `current-lastest`
  \ moved to the kernel.

( privatize )

need name<name  need abort"

variable private-start  variable private-stop

: private{  ( -- )
  current-latest private-start !  private-stop off  ;

  \ doc{
  \
  \ private{  ( -- )
  \
  \ Start private definitions.  See `privatize` for a usage
  \ example.
  \
  \ }doc

: }private  ( -- )
  private-stop @ abort" Extra }private"
  current-latest private-stop !  ;

  \ doc{
  \
  \ }private  ( -- )
  \
  \ End private definitions. See `privatize` for a usage
  \ example.
  \
  \ }doc

: privatize  ( -- )
  private-start @ 0= abort" Missing private{"
  private-stop @ dup 0= abort" Missing }private"
  begin   dup private-start @ u>
  while   dup hide name<name
  repeat  drop  private-start off  private-stop off  ;

  \ doc{
  \
  \ privatize  ( -- )
  \
  \ Hide all words defined between the latest valid pair of
  \ `private{` and `}private`.

  \ Usage example:
  \
  \ ----
  \ private{
  \ \ everything between `private{` and `}private`
  \ \ will become private.
  \ : foo ;
  \ : moo ;
  \ }private
  \
  \ : goo   foo moo ;  \ can use foo and moo
  \ privatize          \ hide foo and moo
  \ ' foo              \ will fail
  \ ----

  \ }doc

  \ vim: filetype=soloforth
  \ multitask.benschop.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- not finished

  \ Last modified: 201605171738

  \ -----------------------------------------------------------
  \ Description

  \ Multitask support, adapted from Spectrum Forth-83.

  \ -----------------------------------------------------------
  \ Authors

  \ L.C. Benschop wrote the original code Spectrum Forth-83,
  \ 1988.
  \
  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-17: Start.

( benschop-multitasker )

code switch
  rptr ldhl h push d push h clr sp addp exde uptr
  ldhl h dec d m ld h dec e m ld h dec begin h dec m d ld h
  dec m e ld exde m a ld a or z until
  h inc m e ld h inc  m d ld h inc uptr sthl  exde ldsp
  d pop h pop rptr  sthl jpix end-code

27028 constant uptr  variable task-link  variable first-task

: task:  ( "name" -- )
  create here $243 + , ( eerste adres ip)
  task-link @ ,  here task-link !  ( link naar vorige taak)
  here first-task @ !  ( maak cirkel rond)
  1 c, 0 , ( nog niet starten&ruimte sp)
  uptr @ here $3C cmove  here 23c + here $0E + ! here
  $013C + here $10 + ! $023C allot ( user-variabelen+stack)
  smudge ] current @ context ! !csp -->

( benschop-multitasker )

  does> dup $15 + @ 4 - ( stackpointer)
  2dup swap 5 + !  2dup swap @ swap !  ( ip op stack)
  over $17 + @ swap 2+ !  ( rp op stack)
  0 swap 4 + c! ( runnable) ;

: terminate 2 uptr @ 3 - c!  switch  ;
: sleep     3 uptr @ 3 - c!  switch  ;
: stop  ( tid -- )  4 swap 7 + c!  ;
: start ( tid -- )  0 swap 7 + c!  ;

: ;task compile terminate ?csp smudge [compile] [ ; immediate

task: main-task
 cr ." multi-tasking operating system"
 begin cr &> emit query
 interpret state @ 0= if ." ok" then 0 until ;task

' main-task 5 + first-task !  ' main-task 7 + task-link !
task-link @ first-task @ !  -->

( benschop-multitasker )

code (start)
  ' switch h ldp# (wait) sthl first-task @ 5 +
  h ldp# uptr sthl h dec m d ld h dec m e ld exde ldsp d pop
  h pop rptr sthl jpix end-code

: startup  ( -- )  main-task (start)  ;

: tasks  ( -- )
  uptr @ dup 27039 = cr if  ." multitasking not active"  else
  dup 10 - >name id. 6 emit ." active"
  begin  5 - @ 3 + dup uptr @ -  while
    cr dup 10 - >name id. 6 emit dup 3 -
    c@ dup 0 = if ." runnable" then
       dup 1 = if ." new"      then
       dup 2 = if ." terminated" then
       dup 3 = if ." sleeping" then
           4 = if ." stopped" then  repeat then drop  ;

  \ vim: filetype=soloforth
  \ multitask.gplusdos.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The Jiffy tool for multitasking on
  \ G+DOS.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( jiffy! jiffy@ -jiffy )

  \ Note: This code is specific for G+DOS.

  \ Credit:
  \
  \ Idea inspired by an article by Paul King, published on
  \ Format (volume 2, number 3, 1988-10).
  \
  \ XXX TODO link to the WoS archive ftp, when available

need !dosvar  need @dosvar

: jiffy!  ( a -- )  16 !dosvar  ;
  \ Set the Z80 routine to be called by G+DOS after the OS
  \ interrupts routine, every 50th of a second.

: jiffy@  ( -- a )  16 @dosvar  ;
  \ Get the current Z80 routine that is called by G+DOS after
  \ the OS interrupts routine, every 50th of a second.

: -jiffy  ( -- )  8335 jiffy!  ;
  \ Deactivate the jiffy call, setting its default value
  \ (a noop routine in the RAM of the +D interface).

  \ vim: filetype=soloforth
  \ multitask.muench-koh.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT -- not finished

  \ Last modified: 201605171604

  \ -----------------------------------------------------------
  \ Description

  \ Multitask support, adapted from eForth and hForth.
  \
  \ Reference: Forth Dimensions (volume 18, number 2, page 32).

  \ -----------------------------------------------------------
  \ Authors

  \ Bill Muench wrote the original code for eForth, 1993-1997.
  \
  \ Wonyong Koh adapted it to hForth, 1995,1997.
  \
  \ Marcos Cruz (programandala.net) wrote a version for Solo
  \ Forth, based on eForth and hForth, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-17: Start.

( muench-koh-multitasker )

get-current forth-wordlist set-current  need user

  \ Structure of a task created by TASK:
  \
  \ userP (points `follower`)
  \ return_stack
  \ data_stack
  \ user_area
  \ user1
  \ taskName
  \ throwFrame
  \ tos
  \ status
  \ follower
  \ sp0
  \ rp0

  \ user u1        \ free
  \ user tf        \ throw frame
  \ user tid       \ back link tid
user tos       \ top of stack
user status    \ `branch` or `wake`
user follower  \ address of next task's `status`

: pause  ( -- )
  rp@ sp@ tos !  follower @ >r  ; compile-only

  \ doc{
  \
  \ pause  ( -- )
  \
  \ Allow another task to execute:
  \ Stop current task and transfer control to the task of which
  \ `status` user variable is stored in `follower` user variable
  \ of current task.
  \
  \ }doc


: wake  ( -- )
  r> userp !  \ `userp` points `follower` of current task
  tos @ sp! rp!  ; compile-only

  \ doc{
  \
  \ wake  ( -- )
  \
  \ Wake current task.
  \
  \ }doc

: stop  ( -- )  ['] branch status ! pause  ;

  \ doc{
  \
  \ stop  ( -- )
  \
  \ Sleep current task.
  \
  \ }doc

: 's  ( tid a -- a' )
  \ follower  cell+ - swap @ + ;  \ XXX TMP -- eForth
  userP @ - swap  ( offset tid )  @ +  ;

  \ doc{
  \
  \ 's  ( tid a -- a' )
  \
  \ Index another task's user variable.
  \
  \ }doc

: sleep  ( tid -- )  status 's  ['] branch  swap !  ;

  \ doc{
  \
  \ Sleep another task.
  \
  \ }doc


: awake  ( tid -- )  status 's  ['] wake  swap !  ;

  \ doc{
  \
  \
  \ awake  ( tid -- )
  \
  \ Wake another task.
  \
  \ }doc

-->

( muench-koh-multitasker )

  \ XXX TMP -- eForth version of `task` (called `hat`):
 \ : HAT ( u s r "name" -- ) ( -- tid )
 \   CREATE + SWAP
 \   [ D# 7 CELLS ] LITERAL + ( TF\TID\TOS\STATUS\FOLLOWER\r>--<s )
 \   DUP HERE + ( rp0 ) , +
 \   DUP HERE + ( sp0 ) , ALLOT ;


: task  ( user_size ds_size rs_size "name" -- )
  create here >r  \ user_size ds_size rs_size  r: tid
  0 ,  \ reserve space for `userp` pointer
  allot here cell- >r  ( user_size ds_size ) ( r: tid rp0 )
  allot here cell- >r  ( user_size ) ( r: tid rp0 sp0 )
  [ 6 cells ] literal + allot  \ minimum user variables
  here cell-  ( user_pointer   ) ( r: tid rp0 sp0 )
  r> , r> , ( store sp0 and rp0  )
  r@ !  \ store `userp` pointer
  lastname r> taskname 's !  ;
  \ store task name in new task's 'taskname'

  \ doc{
  \
  \ task  ( user_size ds_size rs_size "name" -- )
  \
  \ Create a new task.
  \
  \ }doc

-->

( muench-koh-multitasker )


: build  ( tid -- )
  dup sleep                       \ sleep new task
  follower @ over follower 's !   \ link new task
  status 's follower !  ;         \ link old task

  \ doc{
  \
  \ Initialize and link new task into `pause` chain.
  \
  \ }doc

: activate  ( tid -- )

  \ XXX TMP -- eForth:
  dup 2@        ( tid sp rp )

  \ XXX TMP -- hForth:
  \ dup @ cell+ 2@ cell-  \ top of stack is in bx register
  \ swap      ( tid sp0 rp0 )

  r> over !      \ save entry at rp
  over !         \ save rp at sp
  over tos 's !  \ save sp in tos
  awake ; compile-only

  \ doc{
  \
  \ activate  ( tid -- )
  \
  \ Activate the task identified by _tid_. `activate` must be
  \ used only in definition. The code following `activate` must
  \ not `exit`. In other words it must be an infinite loop like
  \ `quit`.
  \
  \ }doc

-->

( muench-koh-multitasker )


: tasks  ( -- )
  follower      \ current task's follower
  begin
    cr dup [ taskname follower - ] literal + @ .name
    dup cell- @ ['] wake =
    if  ." awaked "  else  ." sleeping "  then
    @ cell+     \ next task's follower
      dup follower =
  until drop cr ;

  \ doc{
  \
  \ tasks  ( -- )
  \
  \ Display tasks list in status-follower chain.
  \
  \ }doc

set-current

  \ vim: filetype=soloforth
  \ parsing.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605140234

  \ -----------------------------------------------------------
  \ Description

  \ Words related to parsing.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-13: Add `parse-char`.
  \ 2015-10-06: Move `word` from the kernel.
  \ 2015-10-18: Move `command` from the editor and rename it to
  \ `parse-line`.
  \ 2015-10-22: Fix `parse-char`.
  \ 2016-04-24: Move `char` and `[char]` from the kernel.
  \ 2016-05-10: Fix `[char]`.
  \ 2016-05-14: Compact the blocks. Fix `parse-line` and rename
  \ it to `parse-all`. Finish and document `execute-parsing`.
  \ Move `string>source` and `evaluate` from the kernel.
  \ Rewrite `evaluate` after `execute-parsing`.

( defined? parse-char parse-all )

[unneeded] defined?
?\ : defined?  ( ca len -- f )  undefined? 0=  ; exit

[unneeded] parse-char
?\ : parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ; exit
  \ Parse the next char in the input stream and return its
  \ code.

need ?(  [unneeded] parse-all ?(
: parse-all  ( "ccc<eol>" -- ca len )
  stream dup parsed save-string  ; ?)

  \ doc{
  \
  \ parse-all  ( "ccc" -- ca len )
  \
  \ Parse the rest of the source.
  \
  \ This word is a useful factor of Specforth editor's `text`.
  \
  \ }doc

( execute-parsing string>source evaluate )

need ?(

[unneeded] string>source ?(
: string>source  ( ca len -- )
  blk off  (source-id) on  set-source  ; ?)

  \ doc{
  \
  \ string>source  ( ca len -- )
  \
  \ Set the string _ca len_ as the current source.
  \
  \ }doc

[unneeded] execute-parsing ?( need need-here
need-here string>source
: execute-parsing  ( ca len xt -- )
  nest-source >r string>source r> execute unnest-source  ; ?)

  \ doc{
  \
  \ execute-parsing  ( ca len xt -- )
  \
  \ Make _ca len_ the current input source, execute _xt_, then
  \ restore the previous input source.
  \
  \ Origin: Gforth.
  \
  \ }doc

[unneeded] evaluate ?(  need need-here
need-here execute-parsing
: evaluate  ( i*x ca len -- j*x )
  ['] interpret execute-parsing  ; ?)

  \ doc{
  \
  \ evaluate  ( i*x ca len -- j*x )
  \
  \ Save the current input source specification. Store
  \ minus-one (-1) in `source-id`. Make the  string described
  \ by _ca len_ both the input source and input buffer,  set
  \ `>in` to zero,  and interpret.  When the  parse area  is
  \ empty, restore the prior input source specification.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

( char [char] word )

[unneeded] char [unneded] char and
?\ : char  ( "name" -- c )  parse-name drop c@  ;
[needed] char ?exit

  \ doc{
  \
  \ char  ( "name" -- c )
  \
  \ Parse "name" and put the value of its first character on
  \ the stack.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

need ?(  [uneeded] [char]  ?(  need cliteral

: [char]  ( "name" -- c )
  char postpone cliteral  ; immediate compile-only  ?)

  \ doc{
  \
  \ [char]
  \
  \ Compilation: ( "name" -- )
  \
  \ Parse "name" and append the run-time semantics given below
  \ to the current definition.
  \
  \ Run-time: ( -- c )
  \
  \ Place _c_, the value of the first character of _name_, on
  \ the stack.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \ }doc

  \ Credit:
  \
  \ Code from Z88 CamelForth.

[unneeded] word
: word  ( c "<chars>ccc<char>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -  ( ca' len ) here place  here ( ca )
  bl over count + c!  ; ?)    \ append trailing blank

  \  doc{
  \
  \  word  ( c "<chars>ccc<char>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: save-input ( -- xn ... x1 n )
  source-id 0>
  if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove
     r> to tib  >in @
     source-id file-position throw
     5
  else blk @ >in @ 2 then
  ;

-->

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: restore-input ( xn ... x1 n -- f )
  source-id 0>
  if dup 5 <> if 0 ?do drop loop -1 exit then
     drop source-id reposition-file ?dup
     if >r 2drop drop r> exit then
     >in ! #tib ! to tib false
  else dup 2 <> if 0 ?do drop loop -1 exit then
     drop >in ! blk ! false
  then
  ;

  \ vim: filetype=soloforth
  \ printing.color.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605040109

  \ -----------------------------------------------------------
  \ Description

  \ Words related to color.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-01: Start. New words:

  \   color@ color! color-mask@ color-mask! color 2color
  \   permcolor@ permcolor! permcolor-mask@ permcolor-mask!
  \   permcolor 2permcolor paper@ paper! ink@ ink!  bright@
  \   bright! flash! flash@
  \
  \ 2016-05-04: Move `inverse` and `overprint` from the kernel.

  \ -----------------------------------------------------------
  \ Documentation

  \ (From the ZX Spectrum +3 manual transcribed by Russell
  \ Marks et al.; and from the ZX Spectrum ROM disassembly.)

  \ System variables:

  \ 23693 = ATTR_P -- permanent colors

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ ATTR_P  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23693   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23694 = MASK_P -- permanent mask
  \ MASK_P is used for transparent colours. Any bit that is 1
  \ shows that the corresponding attribute is taken not from
  \ ATTR_P but from what is already on the screen.

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ MASK_P  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23694   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23695 = ATTR_T -- temporary colors

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ ATTR_T  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23695   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ 23696 = MASK_T -- temporary mask
  \ MASK_T is used for transparent colours. Any bit that is 1
  \ shows that the corresponding attribute is taken not from
  \ ATTR_T but from what is already on the screen.

  \         {fl}{br}{   paper   }{  ink    }
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ MASK_T  |   |   |   |   |   |   |   |   |
  \         |   |   |   |   |   |   |   |   |
  \ 23696   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

  \ P_FLAG holds the print flags.  Even bits are the temporary
  \ flags; odd bits are the permanent flags.

  \         {paper9 }{ ink9 }{ inv1 }{ over1}
  \          ___ ___ ___ ___ ___ ___ ___ ___
  \ P_FLAG  |   |   |   |   |   |   |   |   |
  \         | p | t | p | t | p | t | p | t |
  \ 23697   |___|___|___|___|___|___|___|___|
  \           7   6   5   4   3   2   1   0

( color@ color! color-mask@ color-mask! color 2color )

need os-attr-t  need os-mask-t

: color@  ( -- b )  os-attr-t c@  ;

  \ doc{
  \
  \ color!  ( b -- )
  \
  \ Set temporary color attribute _b_.
  \
  \ }doc

: color!  ( b -- )  os-attr-t c!  ;

  \ doc{
  \
  \ color!  ( b -- )
  \
  \ Set temporary color attribute _b_.
  \
  \ }doc

: color-mask@  ( -- b )  os-mask-t c@  ;

  \ doc{
  \
  \ color-mask!  ( b -- )
  \
  \ Set temporary color attribute mask _b_.
  \
  \ }doc

: color-mask!  ( b -- )  os-mask-t c!  ;

  \ doc{
  \
  \ color-mask!  ( b -- )
  \
  \ Set temporary color attribute mask _b_.
  \
  \ }doc

: color  ( b "name" -- )
  create ,  does>  ( -- ) ( pfa ) @ color!  ;

  \ doc{
  \
  \ color  ( b "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set temporary color attribute _b_.
  \
  \ }doc

: 2color  ( b1 b2 "name" -- )
  create 2,  does>  ( -- ) ( pfa ) 2@ color! color-mask!  ;

  \ doc{
  \
  \ 2color  ( b1 b2 "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set temporary color attribute _b2_ and mask _b1_.
  \
  \ }doc

( permcolor@ permcolor! permcolor-mask@ permcolor-mask! )

need os-attr-p  need os-mask-p

: permcolor@  ( -- b )  os-attr-p c@  ;

  \ doc{
  \
  \ permcolor!  ( -- b )
  \
  \ Get permanent color attribute _b_.
  \
  \ }doc

: permcolor!  ( b -- )  os-attr-p c!  ;

  \ doc{
  \
  \ permcolor!  ( b -- )
  \
  \ Set permanent color attribute _b_.
  \
  \ }doc

: permcolor-mask@  ( -- b )  os-mask-p c@  ;

  \ doc{
  \
  \ permcolor-mask@  ( -- b )
  \
  \ Get permanent color attribute mask _b_.
  \
  \ }doc

: permcolor-mask!  ( b -- )  os-mask-p c!  ;

  \ doc{
  \
  \ permcolor-mask!  ( b -- )
  \
  \ Set permanent color attribute mask _b_.
  \
  \ }doc

( permcolor 2permcolor )

need permcolor!  need permcolor-mask!

: permcolor  ( b "name" -- )
  create ,
  does>  ( -- ) ( pfa ) @ permcolor!  ;

  \ doc{
  \
  \ permcolor  ( b "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set permanent color attribute _b_.
  \
  \ }doc

: 2permcolor  ( b1 b2 "name" -- )
  create 2,
  does>  ( -- ) ( pfa ) 2@ permcolor! permcolor-mask!  ;

  \ doc{
  \
  \ 2permcolor  ( b1 b2 "name" -- )
  \
  \ Create a definition "name" that, when executed, will
  \ set permanent color attribute _b2_ and mask _b1_.
  \
  \ }doc

( paper@ paper! ink@ ink! )

need lshift  need rshift  need color@  need color!

: paper>  ( n1 -- n2 )  %00111000 and 3 rshift  ;
: >paper  ( n1 -- n2 )  %00000111 and 3 lshift  ;

: paper@  ( -- b )  color@ paper>  ;

: paper!  ( b -- )  >paper color@ %11000111 and or color!  ;

: ink@  ( -- b )
  color@ %00000111 and  ;

: ink!  ( b -- )
  %00000111 and color@ %11111000 and or color!  ;

( bright@ bright! flash! flash@ )

need color@  need color!

: bright@  ( -- f )
  color@ %01000000 and 0=  ;

: bright!  ( f -- )
  %10000000 and color@ %10111111 and or color!  ;

: flash@  ( -- f )
  color@ %10000000 and 0=  ;

: flash!  ( f -- )
  %10000000 and color@ %01111111 and or color!  ;

( inverse overprint )

code inverse  ( f -- )
  E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,
    \ pop hl
    \ ld a,h
    \ or l
    \ jr z,inverse.off
  FD c, CB c, 57 c, C6 08 02 * + c,  jpnext
    \ set 2,(iy+sys_p_flag_offset) ; temporary inverse flag
    \ _jp_next
    \ inverse.off:
  FD c, CB c, 57 c, 86 08 02 * + c,  jpnext  end-code
    \ res 2,(iy+sys_p_flag_offset) ; temporary inverse flag
    \ _jp_next

  \ doc{
  \
  \ inverse  ( f -- )
  \
  \ If _f_ is zero, turn the inverse mode off; else turn it on.
  \
  \ }doc

code overprint  ( f -- )
  E1 c,  78 04 + c,  B0 05 + c,  28 c, 06 c,
    \ pop hl
    \ ld a,h
    \ or l
    \ jr z,overprint.off
  FD c, CB c, 57 c, C6 08 00 * + c,  jpnext
    \ set 0,(iy+sys_p_flag_offset) ; temporary overprint flag
    \ _jp_next
    \ overprint.off:
  FD c, CB c, 57 c, 86 08 00 * + c,  jpnext  end-code
    \ res 0,(iy+sys_p_flag_offset) ; temporary overprint flag
    \ _jp_next

  \ doc{
  \
  \ overprint  ( f -- )
  \
  \ If _f_ is zero, turn the overprint mode off; else turn it
  \ on.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ printing.control.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060140

  \ -----------------------------------------------------------
  \ Description

  \ Words related to printing control characters.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Add words to print cr, bs, backspaces.
  \
  \ 2016: Add `tabulate`.
  \
  \ 2016-05-01: Test and document `tabulate`.
  \
  \ 2016-05-04: Move `printer` from the kernel.
  \
  \ 2016-05-06: Fix and add conditional compilation.

( printer tabulate )

[unneeded] printer
?\ : printer  ( -- )  3 channel printing on  ;  exit

need column

variable /tabulate  8 /tabulate !
  \ doc{
  \
  \ /tabulate  ( -- a )
  \
  \ A variable that holds the number of spaces that `tabulate`
  \ counts for. Its default value is 8.
  \
  \ See `tabulate`.
  \
  \ }doc

: tabulate  ( -- )  column 1+ /tabulate @ tuck mod - spaces  ;
  \ doc{
  \
  \ tabulate  ( -- )
  \
  \ Display the appropriate number of spaces to tabulate to the
  \ next position, using the value of `/tabulate`.
  \
  \ Note `tabulate` does not uses the "tab" control code, whose
  \ behaviour depends on the screen mode (in the default screen
  \ mode, it moves the cursor 16 positions to right).
  \ `tabulate` is independent on the screen mode, since it uses
  \ spaces.
  \
  \ See `/tabulate`.
  \
  \ }doc

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

[unneeded] 'tab' [unneeded] tab [unneeded] tabs and and
?\ 6 constant 'tab'

[unneeded] 'bs' [unneeded] backspace [unneeded] backspaces
and and ?\ 8 constant 'bs'

[unneeded] 'cr' [unneeded] crs and ?\ 13 constant 'cr'

[unneeded] tab [unneeded] tabs and
?\ : tab  ( -- )  'tab' emit  ;

[unneeded] backspace [unneeded] backspaces and
?\ : backspace    ( -- )  'bs'  emit  ;

[unneeded] crs  ?\ : crs   ( n -- )  'cr'  emits  ;
[unneeded] tabs ?\ : tabs  ( n -- )  'tab' emits  ;

[unneeded] backspaces
?\ : backspaces    ( n -- )  'bs'  emits  ;

  \ vim: filetype=soloforth
  \ printing.cursor.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605072052

  \ -----------------------------------------------------------
  \ Description

  \ Words related to the cursor position.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-14: Add `column`, `row`, `at-x`, `at-y`, adapted
  \ from Galope.
  \ 2016-05-01: Add conditional compilation and documentation.
  \ 2016-05-07: Fix typos and conditional compilation.

( column last-column row last-row at-x at-y )

[unneeded] column [unneeded] last-column and
[unneeded] at-y and
?\ : column  ( -- col )  xy drop  ;
  \ doc{
  \
  \ column  ( -- col )
  \
  \ Current column (x coordinate).
  \
  \ }doc

[unneeded] last-column
?\ : last-column  ( -- row  )  column 1-  ;
  \ doc{
  \
  \ last-column  ( -- col )
  \
  \ Last column (x coordinate) in the current screen mode.
  \
  \ }doc

[unneeded] row [unneeded] last-row [unneeded] at-x and and
?\ : row  ( -- row )  xy nip  ;
  \ doc{
  \
  \ row  ( -- row )
  \
  \ Current row (y coordinate).
  \
  \ }doc

[unneeded] last-row
?\ : last-row  ( -- row  )  row 1-  ;
  \ doc{
  \
  \ last-row  ( -- row )
  \
  \ Last row (y coordinate) in the current screen mode.
  \
  \ }doc

[unneeded] at-x
?\ : at-x  ( col -- )  row at-xy  ;
  \ doc{
  \
  \ at-x ( col -- )
  \
  \ Set the cursor at the given column (x coordinate) and the
  \ current row (y coordinate).
  \
  \ }doc

[unneeded] at-y
?\ : at-y  ( row -- )  column swap at-xy  ;
  \ doc{
  \
  \ at-y ( row -- )
  \
  \ Set the cursor at the current column (x coordinate) and the
  \ given row (y coordinate).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ printing.print.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604220029

  \ -----------------------------------------------------------
  \ Description

  \ Tool to print left justified texts.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( print )

  \ XXX UNDER DEVELOPMENT
  \ Adapted from Galope <print.fs>.

need last-row  need /name

  \ export

variable #printed   \ Printed chars in the current line.
variable #indented   \ Indented chars in the current line.
: printed+  ( u -- )  #printed +!  ;
: indented+  ( u -- )  #indented +!  ;
: (.word) ( ca len -- )  dup printed+ type  ;
: .char  ( c -- )  emit 1 printed+  ;
: not-at-home?  ( -- 0f )  xy +  ;

  \ export

: no-printed  ( -- )  #printed off #indented off  ;
: print-home  ( -- )  home no-printed  ;
: print-page  ( -- )  page print-home  ;

-->

( print )

: print-start-of-line  ( -- )
  #printed @ trm+move-cursor-left no-printed  ;

  \ : print-cr  ( -- )  not-at-home? if  cr  then  no-printed  ;
  \ XXX OLD first version

  \ hide

: at-last-start-of-line?  ( -- f )
  xy last-row = swap 0= and  ;
: not-at-start-of-line?  ( -- f )  column 0<>  ;
: print-cr?  ( -- f )
  not-at-home? not-at-start-of-line? and
  \ xxx fixme 2012-09-30 what this was for?:
  \ at-last-start-of-line? 0= or
  ;

  \ export

defer (print-cr) ' (print-cr) ' cr defer!

: print-cr print-cr? ?? (print-cr) no-printed ;

variable print-width

-->

( print )

  \ hide

: previous-word?  ( -- f )  #printed @ #indented @ >  ;
: ?space  ( -- ) previous-word? if  bl .char  then  ;
: current-print-width  ( -- u )
  print-width @ ?dup 0= ?? cols  ;
: too-long?  ( u -- f )
  1+ #printed @ + current-print-width >  ;
: .word  ( ca len -- )
  dup too-long? if  print-cr  else  ?space  then  (.word)  ;

-->

( print )

: (print-indentation)  ( u -- )
  dup trm+move-cursor-right dup indented+ printed+  ;

  \ export

: print-indentation  ( u -- )  ?dup ?? (print-indentation)  ;

  \ hide

: >word  ( ca1 len1 ca2 len2 -- ca2 len2 ca1 len4 )
  \ ca1 len1 = Text, from the start of its first word.
  \ ca2 len2 = Same text, from the char after its first word.
  \ ca1 len4 = First word of the text.
  tuck 2>r -  2r> 2swap  ;

: first-word  ( ca1 len1 -- ca2 len2 ca3 len3 )  /name >word  ;

: (print)  ( ca1 len1 -- ca2 len2 )  first-word .word  ;

-->

( print )

  \ export

: print  ( ca len --)
  begin  dup   while  (print)  repeat  2drop  ;

  \ Suggested usage in the application:

  \ 4 value indentation
  \ : paragraph  ( ca len -- )
  \   print-cr indentation print-indentation print  ;

  \ vim: filetype=soloforth
  \ printing.type.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281733

  \ -----------------------------------------------------------
  \ Description

  \ Versions of `type`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-04-27: Move `ascii-type` from module "tool.dump.fsb"
  \ and rename it to `type-ascii`.
  \
  \ 2016-04-27: Start `type-center`, `type-left` and
  \ `type-right`.
  \
  \ 2016-04-28: First working versions of `type-center`,
  \ `type-left` and `type-right`.

( type-ascii )

need ascii-char?  need control-char?

: type-ascii  ( ca len -- )
  bounds ?do
    i c@ dup dup ascii-char? 0= swap control-char? or
    if  drop '.'  then  emit
  loop  ;

  \ doc{
  \
  \ type-ascii  ( ca len -- )
  \
  \ Type string _ca len_, replacing non-ASCII and control chars
  \ with a dot.
  \
  \ }doc

( drop-type padding-spaces type-left )

[unneeded] drop-type
?\ : drop-type  ( ca len x -- )  drop type  ;  exit

: padding-spaces  ( len1 len2 -- )
  swap - 0 max spaces  ;

  \ doc{
  \
  \ : padding-spaces  ( len1 len2 -- )
  \
  \ If _len2_ minus _len1_ is a positive number, print that
  \ number of spaces; else do nothing.
  \
  \ }doc

[needed] padding-spaces ?exit

: type-left  ( ca len1 len2 -- )
  2dup 2>r min type 2r> padding-spaces  ;

  \ doc{
  \
  \ type-left  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the left of a field of _len2_
  \ characters.
  \
  \ }doc

( type-right )

need drop-type  need <=>

: type-right-crop  ( ca len1 len2 -- )
  over swap - /string type  ;

  \ doc{
  \
  \ type-right-crop  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters, which is shorter than the string.
  \
  \ }doc

: type-right-fit  ( ca len1 len2 -- )  over - spaces type  ;

  \ doc{
  \
  \ type-right-fit  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters, which is longer than the string.
  \
  \ }doc

      ' type-right-fit ,
here  ' drop-type ,
      ' type-right-crop ,
constant type-right-cases
  \ Execution table of `type-right`.

: type-right  ( ca len1 len2 -- )
  2dup <=> cells type-right-cases + perform  ;

  \ doc{
  \
  \ type-right  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the right of a field of _len2_
  \ characters.
  \
  \ }doc

( type-center )

need drop-type  need <=>

: type-center-fit  ( ca len1 len2 -- )
  over - 2 /mod dup >r + spaces type r> spaces  ;

  \ doc{
  \
  \ type-center-fit  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters, which is longer than the string.
  \
  \ }doc

: type-center-crop  ( ca len1 len2 -- )
  over swap - 2 /mod dup >r + /string r> - type  ;

  \ doc{
  \
  \ type-center-crop  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters, which is shorter than the string.
  \
  \ }doc

      ' type-center-fit ,
here  ' drop-type ,
      ' type-center-crop ,
constant type-center-cases
  \ Execution table of `type-center`.

: type-center  ( ca len1 len2 -- )
  2dup <=> cells type-center-cases + perform  ;

  \ doc{
  \
  \ type-center  ( ca len1 len2 -- )
  \
  \ Type string _ca len1_ at the center of a field of _len2_
  \ characters.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ random.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604082315

  \ -----------------------------------------------------------
  \ Description

  \ Pseudo-random number generators.
  \
  \ See benchmark results in <development_benchmarks.rng.fsb>.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( rnd random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: Found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: Adapted to Solo Forth.
  \
  \ 2016-04-08: Updated the constant after the latest
  \ benchmarks.

2variable rnd-seed  $0111 rnd-seed !

: rnd  ( -- u )
  rnd-seed 2@ $62DC um* rot 0 d+ over rnd-seed 2!  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).

( fast-rnd fast-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code fast-rnd  ( -- u )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: fast-random  ( n -- 0..n-1 )  fast-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

( crnd crandom )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need os-seed

code crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

: crandom  ( b -- 0..b-1 )  crnd um* nip  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( randomize randomize0 )

[defined] randomize
?\  need os-seed  : randomize  ( n -- )  os-seed !  ;
  \ Set the seed of the random number generator.

[needed] randomize ?exit

need os-frames

: randomize0  ( n -- )
  ?dup 0=  if  os-frames @  then  randomize  ;
  \ Set the seed of the random number generator;
  \ if _n_ is zero use the system frames counter instead.

  \ vim: filetype=soloforth
  \ return_stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604281333

  \ -----------------------------------------------------------
  \ Description

  \ Words that manipulate the return stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-09-10: Add `n>r`, `nr>`.
  \ 2015-10-27: Add `r'@`.
  \ 2016-04-24: Move `2rdrop` from the kernel.
  \ 2016-04-28: Add `dup>r`.

( n>r )

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

  \ doc{
  \
  \ n>r  ( x1..xn n -- ) ( R: -- x1..xn n )
  \
  \ }doc

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  jppushhl
  end-code

  \ doc{
  \
  \ nr>  ( -- x1..xn n ) ( R: x1..xn n -- )
  \
  \ }doc

need n>r

( rdepth r'@ )

  \ Credit:
  \
  \ `rdepth` from Afera.

[unneeded] rdepth
?\ : rdepth  ( -- n )  rp@ rp0 @ - -2 /  ;

  \ doc{
  \
  \ rdepth  ( -- n )
  \
  \ }doc

  \ Credit:
  \
  \ `r'@` by Wil Baden.

[unneeded] r'@ ?exit

: r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  r> 2r@ drop swap >r  ;

  \ doc{
  \
  \ r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  \
  \ }doc

( 2rdrop )


code 2rdrop  ( R: x1 x2 -- )
  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  11 c, 02 cells ,
    \ ld de,cell*2
  19 c,
    \ add hl,de
  22 c, rp ,
    \ ld (return_stack_pointer),hl
  jpnext
  end-code

  \ doc{
  \
  \ 2rdrop  ( R: x1 x2 -- )
  \
  \ }doc

( dup>r )

  \ Credit:
  \ Idea from IsForth.

code dup>r  ( x -- x ) ( R: -- x )
  D1 c, D5 c,
    \ pop de
    \ push de
  C3 c, ' >r 1+ ,
    \ jp to_r_.de ; secondary entry of `>r`, in the kernel
  end-code

  \ doc{
  \
  \ dup>r  ( x -- x ) ( R: -- x )
  \
  \ A faster alternative to the idiom `dup >r`.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ screen_mode.32.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605071629

  \ -----------------------------------------------------------
  \ Description

  \ The screen mode 32.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Change `latest >name` to `latestxt`.
  \
  \ 2016-05-07: Improve documentation.

( mode32 )

need columns  need rows  need set-font  need set-mode-output

: mode32  ( -- )
  [ latestxt ] literal current-mode !
  15360 set-font  2548 set-mode-output
  32 to columns  24 to rows
  ['] mode32-xy ['] xy defer!
  ['] mode32-at-xy ['] at-xy defer!  ;

  \ doc{
  \
  \ mode32 ( -- )
  \
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).
  \
  \ This word is loaded when `mode42` or `mode64` are loaded,
  \ in order to make it the default mode.
  \
  \ }doc

' mode32 ' default-mode defer!

  \ vim: filetype=soloforth
  \ screen_mode.42.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605071346

  \ -----------------------------------------------------------
  \ Description

  \ A 42 CPL screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ Marcos Cruz (programandala.net) integrated it into Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Update `latest >name` to `latestxt`.
  \ 2016-05-07: Compact the blocks. Improve the file header.
  \ Fix: `need mode32` was missing.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- integrate the source of the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

( mode42 banked-mode42 )

  \ ............................
  \ Common requirements

need mode32  need <file-as-is need (mode42 need [if]

[needed] mode42 [if]  need set-mode-output

  \ ............................
  \ mode42

: mode42  ( -- )  [ latestxt ] literal current-mode !
                  (mode42 set-mode-output  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

get-drive 1 set-drive  s" prnt42.bin" <file-as-is throw
                       s" ea5aky.f42" <file-as-is throw
            set-drive
  \ Load the driver and the font.

exit [then]

  \ ............................
  \ banked-mode42

  \ XXX UNDER DEVELOPMENT -- A variant of `mode42` that stores
  \ the driver and the font in the code bank.

  \ XXX FIXME -- crash!

need set-banked-mode-output  need code-bank

: banked-mode42  ( -- )  [ latestxt ] literal current-mode !
                         (mode42 set-banked-mode-output  ;

code-bank{  get-drive 1 set-drive
            s" prnt42.bin" <file-as-is throw
            s" ea5aky.f42" <file-as-is throw
            set-drive  }code-bank
  \ Load the driver and the font into the code bank.

( (mode42 )

need columns  need rows  need set-font

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode42-xy  ( -- col row )  0 0  ;  \ XXX TODO

: (mode42  ( -- a )
  42 to columns  24 to rows
  ['] mode42-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  [ 64600 256 - ] literal set-font 63900  ;
  \ Set the 42 cpl font and `at-xy`;
  \ Return the address of the output routine.

  \ vim: filetype=soloforth
  \ screen_mode.64.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605071351

  \ -----------------------------------------------------------
  \ Description

  \ A 64 CPL screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ Author of the original code: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1
  \ Modified and adapted to Solo Forth by Marcos Cruz.

  \ Marcos Cruz (programandala.net) integrated it into Solo
  \ Forth, 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-26: Update `latest name>` to `latestxt`.
  \ 2016-05-07: Improve the file header.

  \ -----------------------------------------------------------
  \ To-do

  \ XXX TODO -- integrate the source of the driver

( mode64 )

  \ XXX TMP -- The driver is loaded from disk to memory address
  \ 60000.

need mode32  need <file-as-is  need 4x8font

get-drive 1 set-drive
s" 4x8fd.bin" <file-as-is throw
set-drive
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: mode64-xy  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latestxt ] literal current-mode !
  64 to columns  24 to rows
  ['] mode64-xy ['] xy defer!
  ['] (at-xy) ['] at-xy defer!
  4x8font set-font  60000 set-mode-output  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

  \ XXX TODO mode64-home

code mode64-emit  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if  FF a ld#  then
  \ check_cr

  end-code

: mode64  ( -- )
  mode64-chars @ set-font  mode64-emit set-mode-outupt
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credit:
  \
  \ Author of the font: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

  \ vim: filetype=soloforth
  \ screen_mode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170052

  \ -----------------------------------------------------------
  \ Description

  \ Words that are common to all screen
  \ modes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Compact the blocks.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( columns rows set-mode-output set-font )

[unneeded] columns [unneeded] rows and
?\ need value  32 value columns  24 value rows  exit

[unneeded] set-font
?\ need os-chars  : set-font  ( a -- )  os-chars !  ;  exit

  \ doc{
  \
  \ set-font  ( a -- )
  \
  \ Set the system font to _a_.  This is used by all modes:
  \ `mode32`, `mode42` and `mode64`. The value of _a_ depends
  \ on the mode: In `mode32` and `mode42`, _a_ is the address
  \ of char 0, i.e. 256 bytes below the space char; In `mode64`
  \ _a_ is the address of space char.
  \
  \ }doc

need os-chans

: set-mode-output  ( a -- )
  os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

  \ doc{
  \
  \ set-mode-output  ( a -- )
  \
  \ Associate the output routine at _a_ to the system channels
  \ "K", "S" and "P".
  \
  \ }doc
  \ XXX TODO -- why also "P"?

( set-banked-mode-output )

need set-mode-output  need >body

0 constant (output-routine)

code (banked-mode-output)  ( -- )
  C5 c,  CD c, 0 ,
    \ push bc ; save Forth IP
    \ call output_routine ; to be patched
  here cell- ' (output-routine) >body !
    \ Store the address where the address of the output routine
    \ must be stored, into the constant `(output-routine)`.
  C1 c,  DD c, 21 c, next ,  jpnext  end-code
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore IX, just in case
    \ jp next

: set-banked-mode-output  ( a -- )
  (output-routine) !  \ patch `(banked-mode-output)`
  ['] (banked-mode-output) set-mode-output  ;
  \ Associate the output routine at _a_ (which is in the code
  \ bank) to the system channels "K", "S" and "P", using and
  \ intermediate routine to page the code bank in and out.

  \ vim: filetype=soloforth
  \ screen_mode.fzx.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242159

  \ -----------------------------------------------------------
  \ Description

  \ The FZX screen mode.

  \ -----------------------------------------------------------
  \ Authors

  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \
  \ Adapted to Solo Forth by Marcos Cruz (programandala.net),
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `char`, which has been moved to the
  \ library.

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 set-drive  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( gx gy -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credit:
  \
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  '?' 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    r now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  r add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) call
  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ sound.128.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140107

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 128k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.

( sound-register-port sound-write-port )

65533 constant sound-register-port
49149 constant sound-write-port

( !sound vol shutup noise )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !p  need sound-register-port  need sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  vocabulary music  current @  also music definitions
need roll  need pick

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b  -->

( music )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l   ( n -- )  len !  ;
: o+  ( -- )    octave @ 2 * octave !  ;
: o-  ( -- )    octave @ 2 / octave !  ;
: r   ( -- )    tempo @ len @ * ms  ;
: >>  ( -- )    1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )    1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: sound, )

  \ Credit:
  \
  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !p  need sound-register-port  need sound-write-port

14 constant /sound

: play  ( a -- )
  \ a = address of a table with 14 bytes
  /sound 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

: sound,  ( b0 ... b13 -- )
  here /sound allot here 1- do  i c!  -1 +loop  ;

: sound:  ( b0 ... b13 "name" -- )  create  sound,  ;

( play sound: sound, )

  \ XXX TODO -- alternative:

need roll

: sound:  ( b0 ... b13 "name" -- )
  create  14 0 do  14 i - roll ,  loop  ;

: sound,  ( b0 ... b13 -- a )
  here >r 14 0 do  14 i - roll ,  loop  r>  ;

( play )

  \ Faster version of the previous `play`, using `c@+`,
  \ which requires the assembler.

need !p  need c@+
need sound-register-port  need sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  c@+ sound-write-port !p
  loop  drop  ;

( play )

  \ Z80 version of the previous `play`.

need z80-asm

need sound-register-port  need sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter1 train )

  \ Sounds to be played with `play`.

need sound:

  \ Credit:
  \
  \ `waves` and `shoot` are
  \ adapted from code written by Juan Jos Ruiz,
  \ published on Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

0  0  0  0  0  0  7 71  20  20  20  0  38  14
sound: waves

10  0  177  0  191  0  31 71  20  20  20  92  28  3
sound: shoot

  \ Credit:
  \
  \ `helicopter` and `train` are
  \ adapted from code written by Jos ngel Martn,
  \ published on Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

200  15  200  15  200  15  0 7 23  23  23  255  1  12
sound: helicopter1

100  120  48  97  12  200  55 15  9  11  55  180  4  8
sound: train

( bomber whip metalic rain2 lightning1 lighting2 )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Adapted from data written by Francisco Majn,
  \ published on Microhobby, issue 194 (1989-12), page 26:
  \ http://microhobby.org/numero194.htm
  \ http://microhobby.speccy.cz/mhf/194/MH194_26.jpg

need sound:

73 82 62 165 90 138 159 140 102 77 100 162 87 201 sound: bomber

5 18 8 6 19 11 5 11 0 19 3 24 21 1 sound: whip

149 64 104 236 210 180 0 32 0 194 146 73 81 177 sound: metalic

16 17 25 10 19 9 4 31 245 1 6 30 2 sound: rain2

1 4 0 16 36 67 8 4 31 245 1 6 30 2 sound: lighting1

0 0 0 0 0 255 7 4 255 25 0 60 60 3 sound: lighting2

( Sound effects )

  \ Sounds to be played with `play`.

  \ Credit:
  \
  \ Data extracted a program written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter2
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop2

decimal

( rain1 waterdrop1 )

  \ Sounds to be played with `play`.

need sound:

  \ Credit:
  \
  \ Data extracted from a program written by Carlos Ventura,
  \ published on Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX FIXME -- these effects don't sound fine, though the data
  \ are correct

44 24 6 6 7 3 3 5 44 6 3 5 3 3 sound: rain1

20 83 94 39 0 8 31 71 23 23 22 90 0 0 sound: waterdrop1

  \ vim: filetype=soloforth
  \ sound.48.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604140114

  \ -----------------------------------------------------------
  \ Description

  \ Words related to 48k sound.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015: Main development.
  \ 2016-04-14: Documented `bleep` and `beep>bleep`.

( bleep )

  \ Credit:
  \
  \ Code modified from Abersoft Forth.

code bleep  ( duration pitch -- )
  E1 c,  D1 c,  C5 c,  CD c, 03B5 ,
    \ pop hl
    \ pop de
    \ push bc ; save Forth IP
    \ call rom_beeper
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore ix
  jpnext
  end-code

  \ doc{
  \
  \ bleep  ( duration pitch -- )
  \
  \ Produce a tone in the internal beeper.
  \
  \ }doc


( beep>bleep )

  \ Credit:
  \
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( frequency duration1 -- duration2 pitch )
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

  \ doc{
  \
  \ beep>bleep  ( frequency duration1 -- duration2 pitch )
  \
  \ Convert the parameters of Sinclair BASIC `beep` to Solo
  \ Forth `bleep`. See `bleep`.
  \
  \ }doc

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published on Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credit:
  \
  \ Author of the original code: Lder Software.
  \ Published on Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ vim: filetype=soloforth
  \ string.cquote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604290255

  \ -----------------------------------------------------------
  \ Description

  \ Two implementations of `c"` and
  \ `csliteral`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-03-14: Write `c"` with a new, system-independent
  \ implementation of `csliteral`.
  \
  \ 2016-03-15: Set the previous, system-dependent
  \ implementation of `csliteral` as default.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( cslit csliteral c" )

  \ This is the default definition of `csliteral`, based on a
  \ system-dependent `cslit`, which makes it possible to decode
  \ `c"`.

  \ Data space used: 43 bytes.

: cslit  ( -- ca )  r@ dup c@ 1+ r> + >r  ;
  \ doc{
  \
  \ cslit  ( -- ca )
  \
  \ Return a string that is compiled after the calling word, and
  \ adjust the instruction pointer to step over the inline string.
  \
  \ }doc

: csliteral  ( ca len -- )
  compile cslit s,  ; immediate compile-only
  \ doc{
  \
  \ csliteral  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Compile a string _ca len_ which at run-time will
  \ be returned as a counted string.
  \
  \ }doc

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  '"' parse postpone csliteral  ; immediate compile-only
  \ doc{
  \
  \ c"  ( Compilation: "ccc<quote>" -- ) ( Run-time: -- ca )
  \
  \ Parse a string delimited by double quotes and
  \ compile it into the current definition.
  \ At run-time the string will be returned as a
  \ counted string _ca_.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( csliteral c" )

  \ This is an alternative system-independent definition of
  \ `csliteral`.

  \ Data space used: 43 bytes.

: csliteral  ( Compilation: ca len -- )
             ( Run-time: -- ca )
  2>r postpone ahead here 2r> s, >r postpone then
  r> postpone literal  ; immediate compile-only
  \ Credit:
  \ Code from Gforth's `CLiteral`.

: c"  ( Compilation: "ccc<quote>" -- )
      ( Run-time: -- ca )
  '"' parse postpone csliteral  ; immediate compile-only

  \ vim: filetype=soloforth
  \ strings.escaped.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242153

  \ -----------------------------------------------------------
  \ Description

  \ Words related to escaped strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]` and `char`, which have been
  \ moved to the library.

( parse-escaped-string )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
'"' 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
'"' 1 2constant "  '\' 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( parse-escaped-string )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  '\' 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "ccc<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup '"' <>  while  \ not finished?
    dup '\' =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

( s\" )

need parse-escaped-string

: s\"  ( Interpretation: "ccc<quote>" -- ca len )
       ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "ccc<quote>"  - ca len )
  \
  \ }doc

( .\" )

need parse-escaped-string

: .\"  ( Compilation: "ccc<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only

  \ vim: filetype=soloforth
  \ strings.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605110243

  \ -----------------------------------------------------------
  \ Description

  \ Misc words related to strings.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-22: Add `s""`, moved from the kernel.
  \ 2016-04-24: Add `need pick`, because `pick` has been moved
  \ from the kernel to the library.
  \ 2016-04-27: Add `char-in-string?` and `char-position?`.
  \ 2016-05-05: Rename `s=` to `str=`. Add `str<` and `str>`.
  \ 2016-05-11: Fix `-prefix`. Start compacting the blocks.

( str= str< str> trim )

[unneeded] str=
?\ : str=  ( ca1 len1 ca2 len2 -- f )  compare 0=  ;  exit

[unneeded] str<
?\ : str<  ( ca1 len1 ca2 len2 -- f )  compare 0<  ;  exit

[unneeded] str>
?\ : str>  ( ca1 len1 ca2 len2 -- f )  compare 0>  ;  exit

[unneeded] trim
: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

( sconstant char>string chars>string +place hunt )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
            bounds do  i c!  loop  2r>
      else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

  \ Credit:
  \
  \ Code from Afera.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ Credit:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( s+ )

  \ Credit:
  \
  \ Code adapted from Afera.

need pick

[defined] lengths
?\ : lengths   2over nip over  ;
   \ ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( #spaces #chars )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credit:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credit:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  bl skip 2dup bl scan  ;
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

need trim
: last-name  ( ca1 len1 -- ca2 len2 )
  trim  begin  2dup bl scan bl skip dup
        while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need str=  need ?(

  \ Credit:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[unneeded] prefix? ?(

: prefix?  ( ca1 len1 ca2 len2 -- f )
  tuck 2>r min 2r> str=  ; ?)

  \ Credit:
  \
  \ Code from Galope (module string-suffix-question.fs).

[unneeded] suffix? (?

need pick

: suffix? ( ca1 len1 ca2 len2 -- f )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string str=  ; ?)

( -prefix -suffix )

  \ Credit:
  \
  \ Code from Galope (module minus-prefix.fs).

need ?(

[unneeded] -prefix ?(  need prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ; ?)

  \ Credit:
  \
  \ Code from Galope (module minus-suffix.fs).

[unneeded] -suffix ?(  need suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap suffix?
  if  r> -  else  rdrop  then  ; ?)

( ud>str d>str chop s"" )

  \ Credit:
  \
  \ Code from Galope (module ud-to-str.fs).

[unneeded] ud>str
?\ : ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credit:
  \
  \ Code from Galope (module d-to-str.fs).

[unneeded] d>str
?\ : d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credit:
  \
  \ Code from Galope (module chop.fs).

[unneeded] chop
?\ : chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

[unneeded] s""
?\ : s""  ( -- ca len )  0 allocate-string 0  ;

  \ doc{
  \
  \ s""  ( -- ca len )
  \
  \ Return an empty string in the circular string buffer.
  \
  \ }doc

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( string/ char-in-string? char-position? ruler )

need ?(

code string/  ( ca1 len1 len2 -- ca2 len2 )
  D9 c, C1 c, D1 c, E1 c, 19 c, A7 c, ED c, 42 c,
    \                           ;   T  B
    \                           ;  -- --
    \ exx          ; save IP    ;  04 01
    \ pop bc       ; len2       ;  10 01
    \ pop de       ; len1       ;  10 01
    \ pop hl       ; ca1        ;  10 01
    \ add hl,de                 ;  11 01
    \ and a        ; cy=0       ;  04 01
    \ sbc hl,bc    ; hl=ca2     ;  15 02
  E5 c, C5 c, D9 c, jpnext  end-code
    \ push hl                   ;  11 01
    \ push bc                   ;  11 01
    \ exx          ; restore IP ;  04 01
    \ jp (ix)                   ;  08 02
    \                           ;  -- --
    \                           ;  98 13 Total

  \ doc{
  \
  \ string/  ( ca1 len1 len2 -- ca2 len2 )
  \
  \ Return the _len2_ ending characters of string _ca1 len1_.
  \
  \ }doc

[unneeded] char-in-string? ?(  need -rot

: char-in-string? ( ca len c -- f )
  -rot bounds ?do   dup i c@ = if  drop true unloop exit  then
              loop  drop false  ; ?)

  \ doc{
  \
  \ char-in-string? ( ca len c -- f )
  \
  \ Is char _c_ in string _ca len_?
  \
  \ }doc

[unneeded] char-position? ?(  need -rot

: char-position?  ( ca len c -- +n true | false )
  -rot 0 ?do   2dup i + c@ = if  2drop i true unloop exit  then
         loop  2drop false  ; ?)

  \ doc{
  \
  \ char-position?  ( ca len c -- +n true | false )
  \
  \ If char _c_ is in string _ca len_, return its first
  \ position _+n_ and _true_; else return _false_.
  \
  \ }doc


[unneeded] ruler ?(

: ruler  ( c len -- ca len )
  dup allocate-string swap 2dup 2>r rot fill 2r>  ; ?)

  \ doc{
  \
  \ ruler  ( c len -- ca len )
  \
  \ Return a string _ca len_ of characters _c_.
  \
  \ }doc

  \ vim: filetype=soloforth

  \ strings.replaces.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ `replaces`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( replaces )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credit:
  \
  \ Code adapted from the Forth-2012 documentation.

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

vocabulary replaces-voc
wid-of replaces-voc constant wid-subst
  \ wordlist id of the wordlist used to hold substitution names and replacement text.

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

-->

( replaces )

: findsubst  ( ca len -- xt f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _xt_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if
    nip nip execute    \ get buffer address
  else
     makesubst
  then
  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )

  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc

  \ vim: filetype=soloforth
  \ strings.s-quote.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242149

  \ -----------------------------------------------------------
  \ Description

  \ `s'`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( s' )

  \ Credit:
  \
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  \
  \ Identical to the standard word `s"`, but using single
  \ quote as delimiter. A simple alternative to `s\"` when only
  \ double quotes are needed in a string.
  \
  \ }doc

: s'  ( Compilation: "ccc<char>" -- ) ( Run-time:  -- ca len )
  ''' parse-string  ; immediate

  \ vim: filetype=soloforth
  \ system_variables.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605011901

  \ -----------------------------------------------------------
  \ Description

  \ Constants for the system variables.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-23: Fix: graphic coordinates variables were not
  \ included in the block title.
  \
  \ 2016-05-01: Add `os-attr-p`, `os-mask-p`, `os-attr-t`,
  \ `os-mask-t`

( os-chars os-chans os-flags2 os-seed os-frames os-udg )

[unneeded] os-chars    ?\ 23606 constant os-chars
  \ 1 cell:
  \ address of character 0 of the font (actual characters 32..127)

[unneeded] os-chans    ?\ 23631 constant os-chans
  \ 1 cell:
  \ address of the channels

[unneeded] os-flags2   ?\ 23658 constant os-flags2
  \ 1 byte:
  \ several flags

[unneeded] os-seed     ?\ 23670 constant os-seed
  \ 1 cell:
  \ seed of the random number generator

[unneeded] os-frames   ?\ 23672 constant os-frames
  \ 3 bytes:
  \ 24-bit counter of frames (1 frame = 20 ms)

[unneeded] os-udg      ?\ 23675 constant os-udg
  \ 1 cell:
  \ address of the User Defined Graphics (characters 128..255)

( os-coords os-coordx os-coordy )

[unneeded] os-coords      ?\ 23677 constant os-coords
  \ 2 cells:
  \ coordinates of last point plotted

[unneeded] os-coordx      ?\ 23677 constant os-coordx
  \ 1 cell:
  \ x-coordinate of last point plotted

[unneeded] os-coordy      ?\ 23678 constant os-coordy
  \ 1 cell:
  \ y-coordinate of last point plotted

( os-attr-p os-mask-p os-attr-t os-mask-t os-p-flag )

[unneeded] os-attr-p      ?\ 23693 constant os-attr-p
  \ 1 cell:
  \ permanent color attribute

[unneeded] os-mask-p      ?\ 23694 constant os-mask-p
  \ 1 cell:
  \ permanent transparent color attribute mask

[unneeded] os-attr-t      ?\ 23695 constant os-attr-t
  \ 1 cell:
  \ temporary color attribute

[unneeded] os-mask-t      ?\ 23696 constant os-mask-t
  \ 1 cell:
  \ temporary transparent color attribute mask

[unneeded] os-p-flag      ?\ 23697 constant os-mask-t
  \ 1 cell:
  \ print flags

  \ vim: filetype=soloforth
  \ tape.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604110003

  \ -----------------------------------------------------------
  \ Description

  \ Tape files support. The only supported filetype is "code".
  \ Contrary to BASIC, saving starts immediately (the message
  \ "Start tape, then press any key" is not printed).
  \
  \ Known issues:
  \
  \ 1) If the space key is pressed while reading or writing
  \ files, the ROM routine will issue a BASIC error and make
  \ the system crash.  This may be solved in the future, with
  \ the help of G+DOS, by trapping the error.
  \
  \ 2) Tape loading errors are not trapped. They make the
  \ system crash.
  \
  \ 3) No support to verify saved files. It may be added in the
  \ future, though it's not useful with emulators, without
  \ actual tapes.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-12-04: Started adapting the tape words from the Afera
  \ library.
  \ 2015-12-23: Changes.
  \ 2016-04-10: Fixed. First working version.
  \ 2016-04-10: Improved: no "Start tape" message.

  \ -----------------------------------------------------------
  \ Development documentation

  \ The information was guessed from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119), the ZX Spectrum ROM
  \ disassembly (whose description of the tape headers is
  \ wrong), the _Abersoft Forth disassembled_ project
  \ (http://programandala.net/en.program.abersoft_forth.html)
  \ and the Afera library
  \ (http://programandala.net/en.program.afera.html).

  \ Structure of a tape header:

  \ +00 : byte, filetype (3 for code files)
  \ +01 : 10-char filename, padded with spaces
  \ +11 : cell, length
  \ +13 : cell, start address
  \ +15 : cell, not used for code files

  \ Arrangement of both tape headers:

  \ IX addresses the first header, which must contain the data.
  \ The second header is used by the system when loading and
  \ verifying. Only the "CODE" file type column is relevant to
  \ Solo Forth.

  \                 File types
  \                 -----------------------
  \ NEW     OLD     PROG   DATA  DATA  CODE
  \ HEADER  HEADER         num   chr          NOTES
  \ ------  ------  ----   ----  ----  ----   ----------------------------
  \ IX+$00  IX+$11  0      1     2     3      File type
  \ IX+$01  IX+$12  x      x     x     x      F  ($FF if filename is null)
  \ IX+$02  IX+$13  x      x     x     x      i
  \ IX+$03  IX+$14  x      x     x     x      l
  \ IX+$04  IX+$15  x      x     x     x      e
  \ IX+$05  IX+$16  x      x     x     x      n
  \ IX+$06  IX+$17  x      x     x     x      a
  \ IX+$07  IX+$18  x      x     x     x      m
  \ IX+$08  IX+$19  x      x     x     x      e
  \ IX+$09  IX+$1A  x      x     x     x      .
  \ IX+$0A  IX+$1B  x      x     x     x      Padding spaces
  \ IX+$0B  IX+$1C  lo     lo    lo    lo     Total...
  \ IX+$0C  IX+$1D  hi     hi    hi    hi     ...length of datablock
  \ IX+$0D  IX+$1E  Auto   -     -     Start  Various
  \ IX+$0E  IX+$1F  Start  a-z   a-z   addr   ($80 if no autostart).
  \ IX+$0F  IX+$20  lo     -     -     -      Length of program only...
  \ IX+$10  IX+$21  hi     -     -     -      ...i.e. without variables

( write-tape-file read-tape-file )

17 constant /tape-header
  \ doc{
  \
  \ /tape-header  ( -- n )
  \
  \ A constant. Length of the tape header stored at
  \ `tape-header`: 17 bytes.
  \
  \ }doc

create tape-header  /tape-header 2 * allot

  \ doc{
  \
  \ tape-header  ( -- a )

  \ Address of the tape header, which is used by the ROM
  \ routines. Its structure is the following:

  \ |===
  \ | Offset  | Size     | Description
  \
  \ | +00     | byte     | filetype
  \ | +01     | 10-chars | filename, padded with spaces
  \ | +11     | cell     | length
  \ | +13     | cell     | start address
  \ | +15     | cell     | not used for code files
  \ |===

  \ When the first char of the filename is code 255, it is
  \ regarded as a wildcard which will match any filename. The
  \ word `read-tape-file` sets the wildcard when the provided
  \ filename is empty. See `any-tape-filename` and
  \ `?set-tape-filename`.
  \
  \ A second tape header follows the main one. It is used by
  \ the ROM routines while loading.

  \ }doc

10 constant /tape-filename \ filename max length

: tape-filetype  ( -- ca )  tape-header  ;

  \ doc{
  \
  \ tape-filetype  ( -- ca )
  \
  \ Address of the file type (one byte) in the tape header.
  \ See `tape-header`.
  \
  \ }doc

: tape-filename  ( -- ca )  tape-header 1+  ;

  \ doc{
  \
  \ tape-filename  ( -- ca )
  \
  \ Address of the filename in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-length    ( -- a )   tape-header 11 +  ;

  \ doc{
  \
  \ tape-length  ( -- a )
  \
  \ Address of the file length in the tape header. See
  \ `tape-header`.
  \
  \ }doc

: tape-start     ( -- a )   tape-header 13 +  ;

  \ doc{
  \
  \ tape-start  ( -- a )
  \
  \ Address of the file start in the tape header pointed by
  \ `tape-header`.
  \
  \ }doc

3 tape-filetype c!  \ "code" filetype by default

-->

( write-tape-file read-tape-file )

: -tape-filename  ( -- )  tape-filename /tape-filename blank  ;

  \ doc{
  \
  \ -tape-filename  ( -- )
  \
  \ Blank the filename of the tape header.
  \
  \ }doc

: any-tape-filename  ( -- )  255 tape-filename c!  ;

  \ doc{
  \
  \ any-tape-filename  ( -- )
  \
  \ Configure the tape header to load any filename,
  \ by replacing the first char of the filename with 255,
  \ which will be recognized as a wild card.
  \
  \ }doc

: set-tape-filename  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-filename swap cmove  ;

  \ doc{
  \
  \ set-tape-filename  ( ca len -- )
  \
  \ Store filename _ca len_ into the tape header.
  \
  \ }doc

: ?set-tape-filename  ( ca len -- )
  dup if    set-tape-filename
      else  2drop any-tape-filename  then  ;

  \ doc{
  \
  \ ?set-tape-filename  ( ca len -- )
  \
  \ If filename _ca len_ is not empty, store it into the tape
  \ header; else use a wildcard instead.
  \
  \ }doc

: set-tape-memory  ( ca len -- )
  tape-length ! tape-start !  ;

  \ doc{
  \
  \ set-tape-memory  ( ca len -- )
  \
  \ Configure the tape header with the memomy zone _ca len_ (to
  \ be read or written).
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (read-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,  2A c, tape-start ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
    \ ld hl,(tape_start)
  3E c, 01 c,  32 c, 5C74 ,  CD c, 075A ,
    \ ld a,1      ; 1=load
    \ ld (5C74),A ; T_ADDR system variable
    \ call 075A   ; SA_ALL ROM routine
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore the address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (read-tape-file)  ( -- )
  \
  \ Low-level action of `read-tape-file`: read a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: read-tape-file  ( ca1 len1 ca2 len2 -- )
  ?set-tape-filename set-tape-memory (read-tape-file)  ;

  \ doc{
  \
  \ read-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Read a tape file _ca2 len2_ (_len2_ is zero if filename is
  \ unspecified) into a memory region _ca1 len1_.
  \
  \ _ca1_ is zero if the address must be taken from the file
  \ header instead, which is the address the file was saved
  \ from.  _len1_ is zero if is unspecified.
  \
  \ }doc

-->

( write-tape-file read-tape-file )

code (write-tape-file)  ( -- )
  C5 c,  DD c, 21 c, tape-header ,
    \ push bc ; save Forth IP
    \ ld ix,tape_header
  A8 07 + c,  32 c, 5C74 ,
    \ xor a       ; 0=save
    \ ld (5C74),a ; T_ADDR system variable
  21 c, here 0A + ,  E5 c,
    \ ld hl,return_from_ROM
    \ push hl ; simulate a call
  2A c, tape-start ,  E5 c,
    \ ld hl,(tape_start) ; start of data
    \ push hl ; needed by entry point $0984,
    \         ; because it's done at the main entry point $0970
  C3 c, 0984 ,
    \ jp $0984  ; alternative entry point to SA_ALL, after the save message
    \           ; note: `jp` is used, but it works as a `call`,
    \           ; because the return address has been pushed
    \ return_from_ROM:
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore address of Forth `next`
  jpnext  end-code

  \ doc{
  \
  \ (write-tape-file)  ( -- )
  \
  \ Low-level action of `write-tape-file`: write a tape file
  \ using the data stored at `tape-header`.
  \
  \ }doc

: write-tape-file  ( ca1 len1 ca2 len2 -- )
  set-tape-filename set-tape-memory (write-tape-file)  ;

  \ doc{
  \
  \ write-tape-file  ( ca1 len1 ca2 len2 -- )
  \
  \ Write a memory region _ca1 len1_ into a tape file _ca2
  \ len2_.
  \
  \ }doc

( .tape )

  \ XXX TMP -- for debugging

: .tape  ( -- )
  cr ." Tape header " tape-header u. cr
     ." Filetype    " tape-filetype c@ . cr
     ." Filename    " tape-filename /tape-filename type cr
     ." Length      " tape-length @ u. cr
     ." Start       " tape-start @ u. cr
     .s cr
     ." Press any key" key drop  ;


  \ vim: filetype=soloforth
  \ time.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170054

  \ -----------------------------------------------------------
  \ Description

  \ Words related to time.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-07: Make block titles compatible with `indexer`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( ms )

need os-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / os-frames @ +
  begin  dup os-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

need os-frames

: frames@  ( -- d )
  os-frames @ [ os-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ os-frames 2+ ] literal c! os-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-xt  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-xt  hl pop  execute-hl
      \ execute the xt hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-xt

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-xt
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but its current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl  need >body

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm  need execute-hl  need >body

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the xt hold in `(wait)`:

    ' (wait) >body fthl execute-hl

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- adapt `pause` to DTC, needed?

( just-pause )

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credit:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit  then
  dup 100 mod 0= if  drop false  exit  then
        4 mod 0= if       false  exit  then
  false  ;

exit

  \ Alternative.

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

( set-date get-date )

create (date)  1 c,  1 c,  2016 ,
  \ day, month, year

: get-date  ( -- day month year )
  (date) c@
  [ (date) 1+ ] literal c@
  [ (date) 2+ ] literal @  ;

  \ doc{
  \
  \ get-date  ( -- day month year )
  \
  \ Get the current date. The default date is 2016-01-01. It
  \ can be changed with `set-date`. The date is not updated by
  \ the system.
  \
  \ }doc

: set-date  ( day month year -- )
  [ (date) 2+ ] literal !
  [ (date) 1+ ] literal c!
  (date) !  ;

  \ doc{
  \
  \ set-date  ( day month year -- )
  \
  \ Set the current date. The default date is 2016-01-01. It
  \ can be fetch with `get-date`. The date is not updated by
  \ the system.
  \
  \ }doc

( set-time get-time reset-time )

need frames@  need frames!  need m+  need alias  need ud*

: get-time  ( -- second minute hour )
  frames@ 50 um/mod nip s>d   ( sec . )
          60 um/mod s>d       ( sec min . )
          60 um/mod           ( sec min hour )  ;

  \ doc{
  \
  \ get-time  ( -- second minute hour )
  \
  \ Return the current time.
  \
  \ The system doesn't have an actual clock. The system frames
  \ counter is used instead. It is increased by the interrupts
  \ routine every 20th ms. The counter is a 24-bit value, so
  \ its maximum is $FFF ticks of 20 ms (5592 minutes, 93
  \ hours), then it starts again from zero.
  \
  \ }doc

: set-time  ( second minute hour -- )
  3600 um*  rot 60 * m+  rot m+  ( seconds )
  50. ud* frames!  ;

  \ doc{
  \
  \ set-time  ( second minute hour -- )
  \
  \ Set the current time. See `get-time`.
  \
  \ }doc

' reset-frames alias reset-time  ( -- )

  \ doc{
  \
  \ reset-time  ( -- )
  \
  \ Reset the current time to 00:00:00. See `get-time`.
  \
  \ }doc

( .time .system-time .date .system-date .time&date time&date )

  \ XXX TODO document

need get-time  need get-date

: .00  ( n -- )  s>d <# # # #> type  ;
: .0000  ( n -- )  s>d <# # # # # #> type  ;

: .time  ( second minute hour -- )
  .00 ':' emit .00 ':' emit .00  ;

: .system-time  ( -- )  get-time .time  ;

: .date  ( day month year -- )
  .0000 '-' emit .00 '-' emit .00  ;

: .system-date  ( -- )  get-date  .date  ;

: .time&date  ( second minute hour day month year -- )
  .date 'T' emit .time  ;

: time&date  ( -- second minute hour day month year )
  get-time get-date  ;

  \ doc{
  \
  \ time&date  ( -- second minute hour day month year )
  \
  \ Return the current time and date: second (0..59), minute
  \ (0..59), hour (0..23), day (1..31), month (1..12) and year
  \ (e.g., 2016).
  \
  \ See: `get-time`, `get-date`, `set-time`, `set-date`.
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-201 (FACILITY
  \ EXT).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tool.debug.assert.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ Versions of the `assert` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( assert assert= )

  \ Credit:
  \
  \ Taken from Brad Nelson's code:
  \ http://bradn123.github.io/literateforth/out/events.fs

: assert   ( n -- )    0= if  abort  then  ;
: assert=  ( a b -- )  = assert  ;

( assert( )

  \ Credit:
  \
  \ Code and documentation from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

  \ vim: filetype=soloforth
  \ tool.debug.tilde-tilde.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 20160324

  \ -----------------------------------------------------------
  \ Description

  \ The `~~` debugging tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( ~~ )

  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->


( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

  \ vim: filetype=soloforth
  \ tool.debug.where.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242149

  \ -----------------------------------------------------------
  \ Description

  \ `where`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-21: 3 bytes shorter.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr #" dec. cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces '^' emit
  else  2drop  then  ;

  \ vim: filetype=soloforth
  \ tool.decode.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170054

  \ -----------------------------------------------------------
  \ Description

  \ The `decode` utility.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ Credit

  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions (volume 4, number 2, page 28, 1982-07).

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-06-05: Copied from Afera. First changes to adapt it.
  \
  \ 2015-06-19: Added `?branch`.
  \
  \ 2015-07-23: Fix: `clit` was not included in the recognized
  \ special cases.
  \
  \ 2015-08-14: Fixed a recent bug: `sp0 sp!` was used when
  \ quitting, instead of `sp0 @ sp!`!
  \
  \ 2015-10-09: Fix: `slit` was missing from the special cases.
  \
  \ 2015-12-21: Fixed `decode-special` after the Forth-83
  \ version of `do loop`: now the branch address is after `do`
  \ or `?do`; also added `-branch` to it, in case it is already
  \ defined during the compilation of `decode-special`.
  \
  \ 2015-12-24: Start converting from ITC to DTC.
  \
  \ 2016-04-15: Fixed `decode-compile`, which had not been
  \ adapted from ITC to DTC.
  \
  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore. Updated the history from the
  \ development history of the project.
  \
  \ 2016-04-24: Add support for `2lit`.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-05-17: Need `>body` and `body>`, which has been moved
  \ to the library.

( decode )

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]
need recurse  need >body  need body>

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2* spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-2literal   ( a1 -- a2 )  cell+ dup 2@ d. cell+  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )  cell+ dup @ >name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] 2lit      of  decode-2literal   endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof

-->

( decode )

    [defined] cslit [if]
      ['] cslit     of  decode-sliteral  endof
    [then]
    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof
    [then]

  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD <> if  drop false exit  then
  1+ @  docolon =  ;
  \ Is _cfa_ a colon definition?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the colon interpreter.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is _pfa_ a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @  ( pfa+n xt ) dup decode-end? 0=
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      >body ( pfa+n pfa' ) dup indent+  body>name .name
      key case  'q' of  sp0 @ sp! quit  endof
                bl  of  drop            endof
                swap recurse  \ default
          endcase  decode-special  cell+  -1 decode-level +!
    repeat  indent >name .name
            \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined  ( nt | 0 )  dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

  \ vim: filetype=soloforth
  \ tool.dump.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604271523

  \ -----------------------------------------------------------
  \ Description

  \ Two versions of the `dump` tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-15: Fixed `dump` (the loop printed one byte more
  \ than requested). Improved `ascii-type` (now also characters
  \ above 127 are printed as dots, not masked).
  \
  \ 2016-04-24: Fix `dump`: nothing was printed when length was
  \ less than 8.
  \
  \ 2016-04-27: Move `ascii-char?` and `control-char?` to
  \ module "chars.fsb".  Move `ascii-type` to module
  \ "printing.type.fsb" and rename it to `type-ascii`. Replace
  \ `bs` with `backspace`, which is part of the library.

( dump )

need 16hex.  need type-ascii  need backspace

: dump  ( ca len -- )
  8 max 8 2dup mod - + 8 / 1- 0
  ?do
    cr dup 16hex.
    8 0 do  i over + @ flip 16hex.  cell +loop
    dup backspace 8 type-ascii
    break-key? ?leave
  8 + loop  drop  ;
  \ Show the contents of _n_ bytes starting from _ca_.

( wdump )

need 16hex.

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  ?do
    i 4 mod 0= if  cr dup 16hex. space  then  \ show address
    dup @ 16hex. cell+
    break-key? ?leave
  loop  drop  ;

  \ vim: filetype=soloforth
  \ tool.history.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201605070041

  \ -----------------------------------------------------------
  \ Description

  \ The command line history tool.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-05-05: Update `s=` to `str=`.
  \
  \ 2016-05-07: Make block titles compatible with `indexer`.

( history )

  \ XXX NEW -- upwards version, with back linked strings

  \ Every entry in the command line history has the following
  \ structure:
  \
  \ +0    : length byte
  \ +1..n : string
  \ +n+1  : address of +0

variable /history
  \ Size of the history space, where all strings are hold.

variable hp0
  \ Address of the bottom of the history.

variable hp
  \ The history pointer: Address of the free space in the
  \ history.

: used-history  ( -- u )  hp0 @ hp @  -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

: allot-history  ( +n -- )  hp +!  ;
  \ Reserve _+n_ bytes in the history.

: len>history  ( len -- +n )  1+ cell+  ;
  \ Convert a string length to space required to store it into
  \ the history.

: history>link  ( ca -- a )  cell-  ;
  \ Convert a history string address to its link field.

: history<history  ( ca1 -- ca2 )  history>link @s  ;
  \ Convert a history string address to the previous one.

: history>history  ( ca1 -- ca2 )
  system-bank count default-bank  + cell+  ;
  \ Convert a history string address to the next one.

: history>string  ( ca1 -- ca2 len2 )
  system-bank count save-string default-bank  ;  -->
  \ Copy a history string to a string in the circular string
  \ buffer.

( history )

variable browsed-history
  \ Address of the history string being browsed.

: oldest-history?  ( -- f )  browsed-history @ hp0 @ =  ;
  \ Are we browsing the oldest string of history?

: browse-older-history  ( -- )
  oldest-history? ?exit
  browsed-history @ history<history browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newest-history?  ( -- )
  browsed-history @ history>history hp @ =
  browsed-history @ hp @ =  or  ;
  \ Are we browsing the newest string of history?

: browse-newer-history  ( -- )
  newest-history? ?exit
  browsed-history @ history>history browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( n -- )
  dup /history !  $FFFF swap -
  dup hp0 !  dup hp !  browsed-history !  0 hp0 @ c!s  ;

1024 init-history  -->

( history )

need str=

: history-empty?  ( -- f )  used-history 0=  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

-->

( history )

: latest-history$  ( -- ca len )
  hp @ history<history history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: duplicated-history?  ( ca len -- f )  latest-history$ str=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: longer-history?  ( len -- f )
  len>history unused-history >  ;
  \ Is _len_ too long?

: history,  ( ca len -- )
  hp @ dup >r  over >r  ( ca len ca1 ) ( R: len ca1 -- )
  system-bank place default-bank
  r> 1+ allot-history  r> hp @ !s  cell allot-history  ;
  \ Add a string to the command line history.

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
  2dup duplicated-history? if  2drop exit  then
  dup longer-history? if  dup allocate-history throw  then
  history,  hp @ browsed-history !  ;
  \ Save string _ca len_ into the command line history,
  \ provided the string is valid (not empty, not duplicated).
  \ Make room if necessary. Then update the pointer to the
  \ browsed history.

-->

( history )

: browsed-history$  ( -- ca len )
  browsed-history @ history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: get-history   ( -- ca )  browsed-history$ set-accept  ;

: (history-up)    ( -- ca )
  get-history browse-older-history  ;
: (history-down)  ( -- ca )
  get-history browse-newer-history  ;

-->

( history )

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  ['] 2drop ['] >history defer!
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  ['] (>history) ['] >history defer!
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

-->

( history )

: .history  ( -- )
  hp0 @ begin  dup hp @ u<  while
          dup history>string type cr  history>history
        repeat  drop  ;

need dump

: hdump  ( ca len -- )  system-bank dump default-bank  ;

: .h  ( -- )  hp0 dup hp @ - hdump  ;

\ history-on

( history-xxx-old )

  \ XXX OLD -- downwards version

  \ 2016-03-07: Start.

  \ Command line history is implemented as a list of counted
  \ string at the top of a memory bank. It's the same bank
  \ where name fields are stored. Name fields are stored
  \ upwards from the bottom of the 16-KiB space; command line
  \ history grows downwards from the top.
  \
  \ The length of the every counted string is used as a link
  \ field to the previous string.  The bottom of the list is
  \ the highest address of the bank, and it holds one byte, the
  \ length of the first string stored in the history, or zero
  \ when the history is empty.
  \
  \ There's a maximum space usable for the history. When
  \ there's no free space left to store a new string, oldest
  \ strings are removed as necessary.

  \ 2016-03-08: XXX TODO -- Rewrite, simpler: grow upwards.

variable hp
  \ Pointer to the most recent string in the history.

$FFFF constant hp0
  \ Pointer to the bottom of the history, which contains a copy
  \ of the length of the first string.

variable /history  1024 /history !
  \ Size of the history space, where all strings are hold.

: init-hp0  ( -- )  0 hp0 c!s  ;

: history-bounds  ( -- ca1 ca2 )  hp0 hp @  ;
  \ Return bottom of history _a1_ and address of the latest
  \ string _ca2:

: used-history  ( -- u )  history-bounds -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

-->

( history-xxx-old )

variable previously-browsed-history
  \ Address of the history string previously browsed.

variable currently-browsed-history
  \ Address of the history string being browsed.

: older-history  ( -- )
  currently-browsed-history @ dup previously-browsed-history !
  system-bank count default-bank +
  currently-browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newer-history  ( -- )
  currently-browsed-history @
  previously-browsed-history @ currently-browsed-history !
  currently-browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( -- )
  init-hp0  hp0 dup hp ! currently-browsed-history !  ;

init-history  -->

( history-xxx-old )

need str=

: allot-history  ( +n -- )  negate hp +!  ;
  \ Reserve _+n_ bytes in the history.

: history-empty?  ( -- f )  history-bounds =  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

: latest-history  ( -- ca len )
  system-bank  hp @ count  save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.
  \ XXX OLD

: browsed-history  ( -- ca len )
  currently-browsed-history @
  system-bank  count save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: (history>)  ( -- ca len )
  browsed-history  dup 0= ?exit
                   dup 1+ negate allot-history
  history-empty? if  init-hp0  then  ;  -->
  \ Get a string from the command line history, and return it
  \ as _ca len_ in the circular string buffer.
  \ XXX TODO -- adapt the browser variables

( history-xxx-old )

: duplicated-history?  ( ca len -- f )  latest-history str=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: too-long-for-history?  ( len -- f )  1+ unused-history > ;

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
    \ If string is empty, do nothing.
  history-empty? if  dup hp0 c!s  then
    \ If history is empty, init its bottom with the length
    \ of the string.
  2dup duplicated-history? if  2drop exit  then
  dup too-long-for-history?
  if  dup allocate-history throw  then
    \ If there's no space left, allocate it.
  dup 1+ allot-history
  hp @ dup system-bank place default-bank
           currently-browsed-history !  ;
  \ Save string _ca len_ into the command line history.

-->

( history-xxx-old )

: get-history   ( -- ca )  browsed-history set-accept  ;
: (history-up)    ( -- ca )  get-history older-history  ;
: (history-down)  ( -- ca )  get-history newer-history  ;

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  \ XXX OLD
  \ ['] 2drop ['] >history defer!
  \ ['] s""   ['] history> defer!  history off  ;
  \ XXX NEW
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  \ XXX OLD
  \ ['] (>history) ['] >history defer!
  \ ['] (history>) ['] history> defer!  history on  ;
  \ XXX NEW
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

: .history  ( -- )
  hp @  begin  dup hp0 <  while
          system-bank count 2dup type cr default-bank  +
        repeat  drop  ;

\ history-on

  \ vim: filetype=soloforth
  \ tool.list.blocks.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604021142

  \ -----------------------------------------------------------
  \ Description

  \ Words to list blocks.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.


( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap ?do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap ?do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap ?do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

  \ vim: filetype=soloforth
  \ tool.list.stack.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242150

  \ -----------------------------------------------------------
  \ Description

  \ Words to examine the stack.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.
  \
  \ 2016-04-12: Divided into 3 blocks, in order to reuse
  \ `.depth` for the floating point `.fs`. Fixed the check: the
  \ stacks are not printed when their depth is negative.
  \
  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.

( .depth )


: .depth  ( n -- )  '<' emit 0 .r '>' emit space  ;

( .s )

  \ Credit:
  \ Code from Afera. Original algorithm from v.Forth.

need .depth

: .s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ .  [ cell negate ] literal +loop
  then  ;

( u.s )

need .depth

: u.s   ( -- )
  depth dup .depth 0> if
    sp@ sp0 @ cell- do i @ u.  [ cell negate ] literal +loop
  then  ;

  \ vim: filetype=soloforth
  \ tool.list.word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605060218

  \ -----------------------------------------------------------
  \ Description

  \ Tool words to list word lists.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015..2016: Main development.
  \ 2016-04-11: Documented.
  \ 2016-05-01: Update.
  \ 2016-05-02: Join two blocks to save space.
  \ 2016-05-05: Remove unnecessary `space` from `.wid`.
  \ 2016-05-06: Improve printing of nameless word lists.

( wordlists .wid .current .context order )

need [if]

[needed] wordlists [if]

: wordlists  ( -- )
  voc-link begin  @ ?dup  while  dup .wid wid>link  repeat  ;
  \ List all wordlists.
  \ XXX FIXME -- prints only one

exit [then]

need wid>name  need get-order

: .wid  ( wid -- )
  dup wid>name ?dup if  .name drop exit  then  u.  ;

  \ doc{
  \
  \ .wid  ( wid -- )
  \
  \ Display the id of the word list _wid_: it can be an
  \ associated name or the number _wid_.
  \
  \ }doc

: .current  ( -- )  get-current .wid  ;

  \ doc{
  \
  \ .current  ( -- )
  \
  \ Display the word list into which new definitions will be
  \ placed.
  \
  \ }doc

: .context  ( -- )
  get-order begin  ?dup  while  swap .wid 1-  repeat  ;

  \ doc{
  \
  \ .context  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched.
  \
  \ }doc

: order  ( -- )
  cr ." Search: " .context cr ." Compile: " .current  ;

  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

  \ doc{
  \
  \ order  ( -- )
  \
  \ Display the word lists in the search order in their search
  \ order sequence, from first searched to last searched. Also
  \ display the word list into which new definitions will be
  \ placed.
  \
  \ Origin: Forth-2012 (SEARCH EXT).

  \ }doc

  \ vim: filetype=soloforth
  \ tool.list.words.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605042236

  \ -----------------------------------------------------------
  \ Description

  \ Words to list words.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2015-09-12: Fix `words-like`.
  \ 2016-05-04: Compact the blocks. Add `words#`. Document.

( more-words? words wordlist-words )

need nuf?

: more-words?  ( nt|0 -- nt|0 f )  dup 0<>  nuf? 0= and  ;

  \ doc{
  \
  \ more-words?  ( nt|0 -- nt|0 f )
  \
  \ A common factor of `words` and `words-like`.
  \
  \ }doc


[needed] more-word? ?exit

  \ Credit:
  \
  \ Code adapted from Spectrum Forth-83.

need trail  need name<name  need tab

: words  ( -- )
  trail begin  more-words?  while
          dup .name tab  name<name
        repeat drop  ;

  \ doc{
  \
  \ words  ( -- )
  \
  \ List the definition names in the first word list of
  \ the search order.
  \
  \ Origin: Forth-83 (Uncontrolled Reference Words), Forth-94
  \ (TOOLS), Forth-2012 (TOOLS).
  \
  \ }doc

[needed] words  ?exit

: wordlist-words  ( wid -- )  >order  words  previous  ;

  \ doc{
  \
  \ wordlist-words  ( wid -- )
  \
  \ List the definition names in word list _wid_.
  \
  \ }doc

( words-like words# )

need trail  need name<name  need tab  need more-words?
need [if]

[needed] words-like [if]  [defined] contains
?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
   \ Does the string _ca1 len1_ contains the string _ca2
   \ len2?_

: words-like  ( "name" -- )
  parse-name 2dup uppers trail  ( ca len nt )
  begin  more-words?  while
    dup >r name>string 2over contains if  r@ .name tab  then
        r> name<name
  repeat drop 2drop  ;  [then]

  \ doc{
  \
  \ words-like  ( "name" -- )
  \
  \ List the definition names, from the first word list of
  \ the search order, that contain substring "name".
  \
  \ }doc

  \ Credit:
  \
  \ Code of `words-like` adapted from pForth.

[needed] words# [if]
: words#  ( -- n ) 0 trail begin  ( n nt ) dup 0<>  while
                             swap 1+ swap  name<name
                           repeat drop  ;  [then]

  \ doc{
  \
  \ words#  ( -- n )
  \
  \ Return number _n_ of words defined in the first word list
  \ of the search order.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ tool.marker.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604251942

  \ -----------------------------------------------------------
  \ Description

  \ `marker`, `anew`.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2015-10-27: Add `possibly`, `anew`.
  \
  \ 2015..2016: Drafts of `marker`.
  \
  \ 2016-01-01: Add example of `marker` from m3forth.
  \
  \ 2016-04-24: Move `n,` to module "compilation.fsb".
  \
  \ 2016-04-25: First working version of `marker`. Move
  \ `possibly` to the module "compilation.fsb".

( marker )

  \ XXX TODO -- save and restore also the nt associated (+4):
  \ |===
  \ | +0 | _nt_ of last definition
  \ | +2 | _wid|0_, next wordlist in chain, or zero
  \ | +4 | _nt|0_, word list name pointer, or zero
  \ |===

: wordlists,  ( -- )
  voc-link @ begin
    dup cell- @  ( a nt ) , @
  ?dup 0= until  ;

  \ doc{
  \
  \ wordlists,  ( -- )
  \
  \ Store the latest definition of every word list in the data
  \ space.
  \
  \ }doc

: @wordlists  ( a -- )
  voc-link @ begin
    2dup  swap @ swap cell- !
    swap cell+ swap  @
  ?dup 0= until  drop  ;

  \ doc{
  \
  \ @wordlists  ( a -- )
  \
  \ Fetch the latest definition of every word list from _a_.
  \
  \ }doc

-->

( marker )

  \ Credit:
  \
  \ Code partly inspired by m3forth's `marker`:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

need get-order  need @cell+  need nn,  need nn@

: @order  ( a -- )  nn@ set-order  ;

: unmarker  ( a -- )
  dup there
  @cell+ np!  @cell+ last !  @cell+ lastxt !  @cell+ voc-link !
  @cell+ set-current
  dup dup @ 1+ cells + >r  @order  r> @wordlists  ;

  \ doc{
  \
  \ unmarker  ( a -- )
  \
  \ Set the data-space pointer to _a_ and restore the names
  \ pointer, the latest definition pointers, the word lists
  \ pointer, the compilation word list, the search order and
  \ the configuration of word lists that were saved at _a_ by
  \ `marker,`.
  \
  \ This word is a factor of `marker`.
  \
  \ }doc

: order,  ( -- )  get-order nn,  ;

: marker,  ( -- a )
  here  np@ ,  last @ ,  lastxt @ ,  voc-link @ ,
        get-current ,  order,  wordlists,  ;

  \ doc{
  \
  \ marker,  ( -- a )
  \
  \ Store the names pointer, the latest definition pointers,
  \ the word lists pointer, the current compilation word list,
  \ the search order and the configuration of word lists at the
  \ current data-space pointer, and return its address _a_, for
  \ later restoration by `unmarker`.
  \
  \ This word is a factor of `marker`.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

: marker  ( "name" -- )
  marker, create ,  does>  ( -- )  ( pfa ) @ unmarker  ;

  \ doc{
  \
  \ marker  ( "name" -- )
  \
  \ Create a definition "name". When "name" is executed, it
  \ will restore the data-space pointer, the word lists
  \ pointer, the compilation word list, the search order and
  \ the configuration of word lists to the state they had just
  \ prior to the definition of "name".
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( anew )

need possibly  need marker

  \ Credit:
  \
  \ Code adapted from Wil Baden.

  \ XXX TODO -- test
  \ XXX TODO -- use `save-input` and `restore-source` when
  \ possible

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

  \ vim: filetype=soloforth
  \ tool.turnkey.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

  \ Last modified: 201604262107

  \ -----------------------------------------------------------
  \ Description

  \ Words to save the system.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( extend size system turnkey )

  \ XXX WARNING -- Since name fields are saved in a memory
  \ bank, the best way to save a modified Forth system is to
  \ make a snapshot with the ZX Spectrum emulator; otherwise a
  \ multipart saving and loading would be needed.  Anyway,
  \ these words are meant to save a Forth program that does not
  \ need to search the dictionary.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )

  \ XXX TODO -- update:

  latest $08 +origin !  \ top most word in `forth` vocabulary
  here $1F +origin !   \ `dp` init value
  np@ $26 +origin !   \ `np` init value
  voc-link @ $0C +origin !  ;  \ `voc-link` init value

  \ doc{
  \
  \ extend  ( -- )
  \
  \ }doc
  \
  \ Change the `cold` start parameters to extend the system to
  \ its current state.

: size  ( -- u )  here 0 +origin -  ;

  \ doc{
  \
  \ size  ( -- u )
  \
  \ Size of the system.
  \
  \ }doc

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ doc{
  \
  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.
  \
  \ }doc

: turnkey  ( xt -- a len )  boot defer! system  ;

  \ doc{
  \
  \ turnkey  ( xt -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given xt after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.
  \
  \ }doc

  \ vim: filetype=soloforth
  \ word_lists.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605171849

  \ -----------------------------------------------------------
  \ Description

  \ Words related to word lists.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-17: Added the requisite of `recurse`, which is not
  \ in the kernel anymore.
  \
  \ 2016-05-02: Join several blocks, to save space.
  \
  \ 2016-05-04: Improve the documentation of `trail`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library. Improve conditional compilation.

( wid>link wid>name named-wid wid>vocabulary )

  \ XXX TODO -- test

[unneeded] wid>link
?\ need alias  ' cell+ alias wid>link  ( wid -- a ) exit

[unneeded] (wid>name)
?\ : (wid>name)  ( wid -- a )  [ 2 cells ] literal +  ;

  \ doc{
  \
  \ (wid>name)  ( wid -- a )
  \
  \ Return the address _a_ which holds the _nt_ of word list
  \ _wid_ (or zero if the word list has no associated name).
  \
  \ }doc

need ?(

[unneeded] wid>name ?(  need need-here  need-here (wid>name)
: wid>name  ( wid -- nt|0 )  (wid>name) @  ; ?)

  \ doc{
  \
  \ wid>name  ( wid -- nt|0 )
  \
  \ Return the _nt_ associated to word list _wid_ (or zero if
  \ the word list has no associated name).
  \
  \ }doc

[unneeded] named-wid ?(  need need-here  need-here wid>name
: named-wid  ( wid -- )  (wid>name) latest swap !  ; ?)

  \ doc{
  \
  \ named-wid ( wid -- )
  \
  \ Associate the latest name to word list _wid_.
  \
  \ }doc

[unneeded] wid>vocabulary ?(
need need-here  need-here named-wid
: wid>vocabulary  ( wid "name" -- )
  create dup , named-wid
  does>  ( -- )  ( pfa )  @ context !  ; ?)

  \ doc{
  \
  \ wid>vocabulary  ( wid "name" -- )
  \
  \ Create a vocabulary "name" for the word list _wid_.
  \
  \ }doc

( get-order order@ )

  \ Credit: Code from eForth.

need recurse

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@  ;

( wid-of swap-current trail find-name-in find )

[unneeded] wid-of
?\ need >body  : wid-of  ( "name" -- wid )  ' >body  ;  exit

  \ doc{
  \
  \ wid-of  ( "name" -- wid )
  \
  \ Return the _wid_ of vocabulary "name".
  \
  \ Note: this word works with original vocabularies created
  \ with `vocabulary`, but not with those created with
  \ `wid>vocabulary`.
  \
  \ }doc

  \ Credit:
  \
  \ Adapted from eForth's `widof`.

[unneeded] trail
?\ : trail  ( -- nt )  context @ @  ;  exit

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the first word list
  \ of the search order.
  \
  \ }doc

need ?(  [unneeded] swap-current ?(
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ; ?)

  \ Credit:
  \
  \ Idea from lpForth.

[unneeded] find-name-in ?(
: find-name-in  ( ca len wid -- nt | 0 )
  @ find-name-from  ; ?)

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in
  \ word list _wid_. If the definition is found, return its
  \ _nt_, else return zero.
  \
  \ The search is case-sensitive.  // XXX TODO -- confirm
  \
  \ }doc

[unneeded] find ?(
: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ; ?)

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

  \ vim: filetype=soloforth
  \ meta.benchmark.flow.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604011826

  \ -----------------------------------------------------------
  \ Description

  \ Flow control benchmarks written during the development of
  \ Solo Forth in order to choose from different implementation
  \ options.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

( case-benchs )

  \ Comparison of case-like structures.
  \
  \ 2015-11-14: `case` (4 versions), `case:`, `options[` and
  \ `cases:`.
  \ 2015-12-14: Updated the comments: `case:` has been renamed
  \ to `positional-case:`.

need bench{

warnings off

: .used  ( u -- )  unused - cr u. ." B used " ;

32767 constant iterations

defer (case-bench)  ( -- )

: case-bench  ( n xt -- )
  cr ." ..."
  ['] (case-bench) defer!
  bench{
  iterations 0 do  i %11 and (case-bench)  loop
  }bench.  ;

-->

( case-benchs )

cr .( case)
unused need case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( eForth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

cr .( case from the Forth-94 docs)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( Abersoft Forth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

  \ Note: the `positional-case:` structure is more specific
  \ than the other structures: it lacks a default option and
  \ its argument is positional.

cr .( positional-case:)
unused need positional-case: .used  unused
positional-case:  positional-case:-example  ( n -- )
  noop  noop  noop  noop ;
.used .( by its example)  ' positional-case:-example case-bench

cr .( options[)
unused need options[ .used  unused
: options[-example  ( n -- )
  options[
    0 option noop  1 option noop  2 option noop
      default-option noop
  ]options  ;
.used .( by its example)  ' options[-example case-bench

-->

( case-benchs )

cr .( cases:)
unused need cases: .used  unused
cases: cases:-example  ( n -- )
  0 case> noop  1 case> noop  2 case> noop  other> noop
.used .( by its example)  ' cases:-example case-bench

cr .( baden-case)
unused need baden-case .used  unused
: baden-case-example  ( n -- )
  case 0 = of  noop  endof
  case 1 = of  noop  endof
  case 2 = of  noop  endof
           othercase noop  ;
.used .( by its example)  ' baden-case-example case-bench

-->

( case-benchs )

cr .( baden-case-like)
unused .used  unused
: baden-case-like-example  ( n -- )
  dup 0 = if drop  noop  exit then
  dup 1 = if drop  noop  exit then
      2 = if       noop  exit then
  noop  ;
.used .( by its example)  ' baden-case-like-example case-bench

cr .( vannorman-switch)
unused need [switch .used  unused
[switch vannorman-switch-example drop
  0 runs noop  1 runs noop  2 runs noop
switch]
.used .( by its example)  ' vannorman-switch-example case-bench


  \                        Bytes used            Speed (3)
  \                        --------------------- --------------
  \ Structure              Code (1)  Example (2) Frames Seconds
  \ ---------              --------- ----------- ------ -------
  \ case (7)                 48       62          1365   27
  \ eforth-case (8)          54       62          1366   27
  \ 94-doc-case (6)          54       62          1365   27
  \ abersoft-case (5)        64       62          1365   27
  \ positional-case: (4)     21       12           823   16
  \ options[ (9)            166       24          3627   72
  \ cases: (10)             109       18          3155   63
  \ baden-case (11)          18       56          1472   29
  \ baden-case (12)          36       56          1472   29
  \ baden-case (13)           0       50          1353   27
  \ vannorman-switch (14)   124       24          3573   71

  \ (1) Bytes used by the compilation of the structure's code.
  \
  \ (2) Bytes used by the tested example: a structure with
  \ three options plus default, that execute a `noop`.
  \
  \ (3) For 32767 iterations with parameter 0..3. One system
  \ frame is 20 ms.

  \ (4) A port of F83's `case:`. It is more specific than the
  \ other structures: it lacks a default option and its
  \ argument is positional.
  \
  \ (5) Eaker/Forth-94 `case` of Abersoft Forth, but with
  \ compiler security removed.
  \
  \ (6) Eaker/Forth-94 `case` copied from the Forth-94
  \ documentation.
  \
  \ (7) Eaker/Forth-94 `case` of eForth, with a little
  \ simplification. This is the default `case` used in Solo
  \ Forth.
  \
  \ (8) Eaker/Forth-94 `case` of eForth.
  \
  \ (9) A port of IsForth's `case:`.
  \
  \ (10) A port of a structure written by Dan Lerner, published
  \ on Forth Dimensions (volume 3, number 6, page 189,
  \ 1982-03).
  \
  \ (11) "Ultimate CASE Statement", written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).
  \
  \ (12) The same "Ultimate CASE Statement", by Wil Baden, with
  \ two syntactic sugar words added: `endof` and `othercase`.
  \
  \ (13) The same "Ultimate CASE Statement", by Wil Baden,
  \ emulated with standard words. This is a bit faster because,
  \ without the syntactic sugar definitions, one `dup` and two
  \ `drop` are saved.
  \
  \ (14) Code by Rick VanNorman, published on Forth Dimensions
  \ (volume 20, number 3, pages 19..22, 1998-09).

( do-bench )

  \ 2015-12-17

need bench{

32767 0 2constant range

: forth-83-do  ( -- )  bench{  range do83  loop83  }bench.  ;

: forth-79-do  ( -- )  bench{  range do  loop  }bench.  ;

: forth-83-i  ( -- )
  bench{  range do83  i83 drop  loop83  }bench.  ;

: forth-79-i  ( -- )
  bench{  range do  i drop  loop  }bench.  ;

: forth-83-+loop  ( -- )
  bench{  range do83  2 +loop83  }bench.  ;

: forth-79-+loop  ( -- )  bench{  range do  2 +loop  }bench.  ;

: do-bench  ( -- )
  forth-83-do forth-79-do
  forth-83-i forth-79-i
  forth-83-+loop forth-79-+loop  ;

  \           Frames by 32767 iterations
  \           --------------------------
  \ Bench     Forth-79  Forth-83
  \ --------  --------  --------
  \ loop           143       109
  \ i              264       258
  \ +loop          108        97

  \ Note: 1 frame = 50th of second

  \ vim: filetype=soloforth

  \ meta.benchmark.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170051

  \ -----------------------------------------------------------
  \ Description

  \ Misc benchmarks written during the development of Solo
  \ Forth in order to choose from different implementation
  \ options.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]`, which has been moved to the
  \ library.
  \
  \ 2016-04-29: Add benchmark of two versions of `u<=` and
  \ `u>=`.  Fix benchmark of `u<`.
  \
  \ 2016-05-01: Add benchamark for comparing `3 clshift` and
  \ `8 *`.
  \
  \ 2016-05-05: Add benchmark for `search`.
  \
  \ 2016-05-06: Add benchmarks for `<` and `=`.
  \
  \ 2016-05-13: Add benchmark for `?throw`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( number-base-bench )

  \ 2015-10-09

: number-base-1  ( ca len -- ca' len' n )
  \ This is the current version defined in the kernel.
  over c@ '$' = if  1 /string 16  exit  then
  over c@ '%' = if  1 /string  2  exit  then
  over c@ '#' = if  1 /string 10  exit  then  base @  ;

: number-base-2  ( ca len -- ca' len' n )
  over c@ >r
  r@ '$' = if  1 /string 16  rdrop exit  then
  r@ '%' = if  1 /string  2  rdrop exit  then
  r> '#' = if  1 /string 10  exit  then  base @  ;

: number-base-3  ( ca len -- ca' len' n )
  over c@
  dup >r '$' = if  1 /string 16  rdrop exit  then
      r@ '%' = if  1 /string  2  rdrop exit  then
      r> '#' = if  1 /string 10  exit  then  base @  ;

-->

( number-base-bench )

: number-base-4  ( ca len -- ca' len' n )
  over c@
  dup '$' = if  drop 1 /string 16  exit  then
  dup '%' = if  drop 1 /string  2  exit  then
      '#' = if  1 /string 10  exit  then  base @  ;

need frames@  need reset-frames  defer (number-base)

: (number-base-bench)  ( n xt -- )
  ['] (number-base) defer!
  reset-frames  0 do  s" 000" (number-base) drop 2drop  loop
  frames@ d. cr  ;

: number-base-bench  ( n -- )
  dup ['] number-base-1 (number-base-bench)
  dup ['] number-base-2 (number-base-bench)
  dup ['] number-base-3 (number-base-bench)
      ['] number-base-4 (number-base-bench) ;

  \ 2015-10-09
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          1    2    3    4
  \       ---- ---- ---- ----
  \ 01000   73   75   74   69
  \ 10000  732  744  736  686
  \ 32000 2343 2382 2367 2194

( fill-bench )

  \ 2015-09-25: Benchmark three implementations of `fill`:
  \
  \ `fill` is the original implementation from Abersoft Forth
  \ `fill2` is a modified version
  \ `fill88` is the code adapted from Z88 CamelForth

need frames@  need reset-frames  need rnd

defer (fill)

: (fill-bench)  ( n xt -- )
  ['] (fill) defer!
  reset-frames  0
  do  16384 6144 rnd (fill)  loop
  \ do  16384 1 rnd (fill)  loop
  \ do  16384 0 rnd (fill)  loop
  \ do  16384 2048 rnd (fill)  loop
  frames@ cr d.
  key drop  ;

: fill-bench  ( n -- )
  dup ['] fill (fill-bench)
  dup ['] fill2 (fill-bench)
      ['] fill88 (fill-bench)  ;

  \ Kernel code: `16384 6144 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010   10    10      5
  \ 00100  491   522    252
  \ 01000 4909  5218   2524

  \ Kernel code: `16384 1 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    9     8      8
  \ 01000   85    84     84
  \ 05000  425   423    422
  \ 10000  850   846    845

  \ Kernel code: `16384 0 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    8     8      8
  \ 01000   84    83     84
  \ 05000  421   418    421
  \ 10000  842   837    842

  \ Kernel code: `16384 2048 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill  fill2 fill88
  \       ----- ----- ------
  \ 00010    17    18      9
  \ 00100   169   180     89
  \ 01000  1693  1795    898
  \ 30000 50770 53863  26933

( value-bench )

need frames@  need reset-frames

0 value v1

: value-bench  ( n -- )
  reset-frames  0 do  v1 drop  loop  frames@ cr d.  ;

( 2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2value-bench  ( n -- )
  reset-frames  0 do  v2 2drop  loop  frames@ cr d.  ;

( to-value-bench )

need frames@  need reset-frames

0 value v1

: to-value-bench  ( n -- )
  reset-frames  0
  do  0 to v1   loop
  frames@ cr d.  ;

( to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: to-2value-bench  ( n -- )
  reset-frames  0
  do  0. to v2   loop
  frames@ cr d.  ;

( 2to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2to-2value-bench  ( n -- )
  reset-frames  0
  do  0. 2to v2   loop
  frames@ cr d.  ;

( rshift-bench lshift-bench )

need frames@  need reset-frames

: rshift-bench  ( n -- )
  reset-frames  0
  do  128 255 rshift drop   loop
  frames@ cr d.  ;

: lshift-bench  ( n -- )
  reset-frames  0
  do  128 255 lshift drop   loop
  frames@ cr d.  ;

  \ 2015-11-01

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       rshift         lshift
  \       -------------- --------------
  \        Z88  DZX    %  Z88  DZX    %
  \       ---- ---- ---- ---- ---- ----
  \ 10000 1203 1609 133% 1016 1723 169%
  \ 30000 3607 4826 133% 3048 5170 169%

  \ Z88 = code adapted from Z88 CamelForth
  \ DZX = code adapted from DZX-Forth

( /-bench )

  \ 2015-09-22: This bench compares the execution speed of
  \ Abersoft Forth's `m/` and Z88 CamelForth's `sm/rem`. Both
  \ words are equivalent.  Abersoft Forth's `m/` is much
  \ faster.

need frames@  need reset-frames  need rnd

: drnd  ( -- d )  rnd rnd  ;

[defined] (/)  ?\ defer (/)

: (/-bench)  ( n -- )
  reset-frames
  1+ 1 do  drnd i (/) 2drop  loop  frames@ cr d.  ;

: /-bench  ( n -- )
  dup ['] m/ ['] (/) defer! (/-bench)
      ['] sm/rem ['] (/) defer! (/-bench)  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       m/    sm/rem
  \       ----- ------
  \ 00010     3      4
  \ 00100    33     44
  \ 01000   326    442

  \ m/     = word from Abersoft Forth
  \ sm/rem = word from Z88 Camel Forth

( um*-bench )

need frames@  need reset-frames

: um*-bench  ( n -- )
  reset-frames  0 do  i i um* 2drop  loop  frames@ d.  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       DZX   hForth R hForth A Z88 R Z88 A
  \       ----- -------- -------- ----- -----
  \ 00100     3        3        3     3     3
  \ 01000    29       32       31    32    31
  \ 10000   297      328      319   323   316
  \ 20000   598      659      643   647   633
  \ 32000   961     1060     1037  1037  1016

  \            Bytes free Code from
  \            ---------- ---------
  \ DZX      = 33783      DZX-Forth
  \ hForth R = 33787      hForth, with relative jumps
  \ hForth A = 33784      hForth, with absolute jumps
  \ Z88 R    = 33786      Z88 CamelForth, with relative jumps
  \ Z88 A    = 33784      Z88 CamelForth, with absolute jumps

( um/mod-bench )

  \ 2015-11-24

need bench{

: um/mod-bench  ( n -- )
  bench{  0 do  i s>d i um/mod 2drop  loop  }bench.  ;

: um/mod-bench88  ( n -- )
  bench{  0 do  i s>d i um/mod88 2drop  loop  }bench.  ;

: um/mod-bench  ( n -- )
  dup cr ." Abersoft Forth  U/MOD ..." um/mod-bench
      cr ." Z88 CamelForth UM/MOD ..." um/mod-bench88  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          AF      Z88
  \       ----- --------------
  \ 00100     6        5
  \ 01000    59       42 (71%)
  \ 10000   587      428 (72%)
  \ 20000  1157      875 (75%)
  \ 32000  1881     1372 (72%)

  \            Bytes free Code from
  \            ---------- ---------
  \ AF         32689      Abersoft Forth
  \ Z88        32707      Z88 CamelForth

( ud/mod-bench )

  \ 2015-12-21

need bench{

: a-m/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod drop 2drop  loop  }bench.  ;

: z1-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod881 drop 2drop  loop  }bench.  ;

: z2-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod882 drop 2drop  loop  }bench.  ;

: run  ( n -- )
  dup cr ." Abersoft Forth  M/MOD ..." a-m/mod
  dup cr ." Z88 CamelForth UD/MOD 1..." z1-ud/mod
      cr ." Z88 CamelForth UD/MOD 2..." z2-ud/mod  ;

  \ 10000 run  20000  run 65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ 10000     964    967      944
  \ 20000    1928   1934     1888
  \ 65535    6300   6316     6161

  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ B used:    22     22      20 (3)

  \ (1) Z88 CamelForth code
  \ (2) Z88 CamelForth code, with `-rot` instead of `rot rot`
  \ (3) Not including the size of `-rot`

( ud/mod-bench )

  \ 2016-03-15: Second benchmark. Faster results because of
  \ DTC.

need bench{

: a-m/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod drop 2drop  loop  }bench.  ;

: z-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod88 drop 2drop  loop  }bench.  ;


: run  ( n -- )
      cr ." UD/MOD from:"
  dup cr ." Abersoft Forth and Gforth ..." a-m/mod
  dup cr ." Z88 CamelForth .............." z-ud/mod  ;

  \ 10000 run  20000  run 65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \            AF    Z88
  \         ----- ------
  \ 10000     900    882
  \ 20000    1799   1765
  \ 65535    5870   5759

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 12345" num?   s" 12345." num?
    s" -12345" num?  s" -12345." num?  empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

                                    \ Version of `number?`
  \    ' number? ' num? defer! benchs  \ pForth
  \  ' c.number? ' num? defer! benchs  \ CamelForth
  \ ' dzx-number? ' num? defer! benchs  \ DZX-Forth
   ' solo-number? ' num? defer! benchs  \ Solo Forth

  \ Note: The CamelForth code is for single numbers only.
  \       The DZX-Forth code is a bit obfuscated.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       pForth CamelForth DZX-Forth Solo Forth
  \       ------ ---------- --------- ----------
  \ 00100    256        257       259        266
  \ 01000   2559       2565      2594       2658
  \ 10000  25591      25652     25933      26581

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 123x45." num?   s" 12345.999x" num?
    s" -12345.x" num?  s" -12345.999x" num?
    s" -12345.000.000" num?
    empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

' solo-number? ' num? defer! benchs

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \ 00100   416
  \ 01000  4165
  \ 10000 41649

( dummy-needed )

( buffer-benchmark-1 )

  2 load need reset-frames
  reset-frames

  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed

  frames@ cr .( Frames ) d. cr

  \ 2015-11-04

  \ Benchmark: Locate and load 16 times empty block #457.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \        512-byte buffer 1024-byte buffer
  \       ---------------- ----------------
  \    16             6323       8621 (136%)

( buffer-benchmark-2 )

  2 load  need reset-frames  warnings off  reset-frames

  need list  need dump  need wdump  need decode
  need life  need hanoi  need tt need siderator  need pong
  need doer  need a!  need defer  need value  need editor
  need case  need times  need dtimes  need for

  frames@ cr .( Frames ) d. cr

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-04 512-byte buffer       33742        20960 (1.00)
  \            1024-byte buffer      33277 (-465) 24310 (1.15)
  \                                               24042 (1.14)

  \ This is not good for benchmarking the headers, because most
  \ of the time is wasted locating the blocks. That's why
  \ both methods are equally fast:

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

need bench{ warnings off bench{ : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        490 (9 s)
  \            `next-name` (4)       32791        494 (9 s)
  \            `nextname` (2)        32781        491 (9 s)
  \            `nextname` (3)        32765        494 (9 s)

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.
  \
  \ (3) Same as (2) but with zero-length name check.
  \
  \ (4) Same as (1) but with zero-length name check.

( header-benchmark )

need bench{ warnings off blk @ 1+ constant b bench{ b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ -----------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

  }bench. sp0 @ sp!

  \ How `interpret`
  \ interprets numbers   Bytes free  Frames         Date
  \ ------------------   ----------  -------------  ----------
  \ branches (1)              32766     500 (1.00)  2015-11-12
  \ execution table (1)       32770     497 (0.99)  2015-11-12
  \ execution table (2)       32761     498 (0.99)  2015-11-12
  \ execution table (3)                 476 (0.95)  2016-03-19

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor
  \ (3): same as (2), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

: foo  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ;

  }bench.

  \ How `interpret`
  \ compiles numbers    Bytes free  Frames         Date
  \ ----------------    ----------  -------------  ----------
  \ branches (1)             32766     510 (1.00)  2015-11-12
  \ execution table (1)      32770     507 (0.99)  2015-11-12
  \ execution table (2)      32761     508 (0.99)  2015-11-12
  \ execution table (3)                483 (0.94)  2016-03-19

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor
  \ (3): same as (2), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop

  }bench.

  \ How `interpret`
  \ interprets words       Bytes free  Frames      Date
  \ ---------------------  ----------  ----------- ----------
  \ branches (0)           32770       192 (1.00)  2015-11-12
  \ independent table (1)  32746       190 (0.98)  2015-11-12
  \ combined table (2)     32747       190 (0.98)  2015-11-12
  \ combined table (3)     32753       192 (1.00)  2015-11-12
  \ combined table (4)     32761       190 (0.98)  2015-11-12
  \ combined table (5)                 191 (0.99)  2016-03-19

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor
  \ (5): same as (4), but when the Forth system is DTC

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  need bench{  bench{

: foo noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop ;

  }bench.

  \ How `interpret`
  \ compiles words        Bytes free  Frames      Date
  \ ------------------    ----------  ----------  ----------
  \ branches (0)          32770       199 (1.00)  2015-11-12
  \ independent table (1) 32746       198 (0.98)  2015-11-12
  \ combined table (2)    32747       198 (0.99)  2015-11-12
  \ combined table (3)    32753       200 (1.00)  2015-11-12
  \ combined table (4)    32761       198 (0.98)  2015-11-12
  \ combined table (5)                191 (0.95)  2016-03-19

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor
  \ (5): same as (4), but when the Forth system is DTC

  \ 1 frame = 50th of second

( constant-bench )

  \ 2016-02-16: New version.

need bench{ need }bench.

3 constant const1

: bench1  ( n -- )
  bench{ 0 do  const1 drop  loop }bench.  ;

: bench2  ( n -- )
  bench{ 0 do  3 drop  loop }bench.  ;

: constant-bench  ( n -- )  dup cr bench1 cr bench2  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \  1000                      6      5
  \ 52000                    307    284
  \ 65535                    386    358

( constant-bench )

need reset-frames  need frames@

0 constant const1

: bench1  ( n -- )
  reset-frames 0 do  const1 drop  loop
  frames@ d. cr ;

: const2  ( -- x )  const1 cell+  ;

: bench2  ( n -- )
  reset-frames 0 do  const2 drop  loop
  frames@ d. cr ;

( literal-bench )

need reset-frames  need frames@

: bench1  ( n -- )
  reset-frames 0 do  cell negate drop  loop
  frames@ d. cr ;

: bench2  ( n -- )
  reset-frames 0 do  [ cell negate ] literal drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \ 32000                    320    249

( 0-bench false-bench )

need reset-frames  need frames@

  \ This bench compares `0` (implemented as a `cconstant`) and
  \ `false` (written in assembler).

: 0-bench  ( n -- )
  reset-frames 0 do  0 drop  loop
  frames@ d. cr ;

: false-bench  ( n -- )
  reset-frames 0 do  false drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                           0       false
  \                       ----- -----------
  \ 32000                   251   236 (94%)

( d*-bench )

  \ `d*` by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 33, 1998-04).

: baden-d*  ( d1 d2 -- d3 )
  >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  r> * swap r> * + +  ; ( d1*d2 ) ( R: )

  \ `d*` by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

need pick  need roll

: smith-d*  ( d1 d2 -- d3 )
  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ `d*` from DX-Forth 4.13

unused
: dx-d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;
unused - . cr key drop

-->

( d*-bench )

need bench{

: baden-d*-bench  ( n -- )  0 do  1. 2. baden-d* 2drop  loop  ;
: smith-d*-bench  ( n -- )  0 do  1. 2. smith-d* 2drop  loop  ;
: dx-d*-bench  ( n -- )  0 do  1. 2. dx-d* 2drop  loop  ;

: d*-benchs  ( -- )
  page
  32767 dup bench{ baden-d*-bench }bench.
        dup bench{ smith-d*-bench }bench.
            bench{ dx-d*-bench }bench.  ;

  \ 2015-11-09: baden-d*, smith-d*

  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4920 (98 seconds)  1.00
  \ smith-d*  5189 (103 seconds) 1.05

  \ 2015-12-22:
  \
  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4860 (97 seconds)   1.0008
  \ smith-d*  5139 (102 seconds)  1.0582
  \ dx-d*     4856 (97 seconds)   1.0000

( misc-benchs )

  \ Some misc speed benchs.

need bench{  need 0if

: bench1  ( n -- )
  begin  ?dup if  1 - else  exit  then  again  ;

: bench1a  ( n -- )
  begin  ?dup if  1- else  exit  then  again  ;

: bench2  ( n -- )
  begin  dup 0= if  drop  exit  then  1-  again  ;

: bench2a  ( n -- )
  begin  dup 0if  drop exit  then  1-  again  ;

: bench3  ( n -- )
   begin  ?dup 0if  exit  then  1-  again  ;


: misc-benchs  ( -- )
  32767 dup bench{ bench1 }bench.
        dup bench{ bench2 }bench.
            bench{ bench3 }bench.  ;

  \ Bench    Frames for 32767 iterations
  \ -----   ---------------------------
  \ bench1   655 (`1 -`)
  \ bench1a  576 (`1-`)
  \ bench2   320 (`0= if`: 100%)
  \ bench2a  245 (`0if`:    76%)
  \ bench3   528

( 2swap-bench )

  \ 2015-11-24

need bench{

: 2swap-bench  ( -- )
  32767 0 bench{ 2dup do  2swap  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From DZX-Forth                271 (5 s) (1.00)
  \ Adapted from Z88 CamelForth   243 (4 s) (0.89)

( dnegate-bench )

  \ 2015-11-24

need bench{

: dnegate-bench  ( -- )
  32767 0 bench{ 2dup do  dnegate  loop  }bench. 2drop  ;

: dnegate-bench2  ( -- )
  32767 0 bench{ 2dup do  dnegate2  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From Abersoft Forth           243 (4 s) (1.00)
  \ From Spectrum Forth-83        253 (5 s) (1.04)

( ?dup-bench )

  \ 2016-01-01

need bench{  variable times  40000 times !

: iterations  ( -- n1 n2 )  times @ 0  ;

: forth-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup drop  loop  }bench.  ;

: z80-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup80 drop  loop  }bench.  ;

: forth-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup 2drop  loop  }bench.  ;

: z80-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup80 2drop  loop  }bench.  ;

: ?dup-bench  ( -- )
  cr ." Forth version:" cr ." 0 ?dup :" forth-0-?dup-bench cr
                           ." 1 ?dup :" forth-1-?dup-bench cr
     ." Z80 version:"   cr ." 0 ?dup :" z80-0-?dup-bench cr
                           ." 1 ?dup :" z80-1-?dup-bench cr  ;

  \ Code        Frames for 40000 iterations
  \ -----       ---------------------------
  \             Forth  Z80
  \             -----  ----
  \ `0 ?dup`    532    288
  \ `1 ?dup`    585    312

( #spaces-bench )

need under+

: #spaces1  ( ca len -- +n )
  0 rot rot  0 do  count bl = 1 and under+  loop  drop ;
  \ From:
  \ http://forth.sourceforge.net/mirror/comus/index.html

: #spaces2  ( ca len -- +n )
  0 rot rot  bounds do  i c@ bl = +  loop  abs  ;
  \ First variant.

: #spaces3  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Second variant, the fastest one.

need bench{

defer #spaces

: #spaces-bench  ( n -- )
  cr bench{  0 do  0 32767 #spaces drop  loop  }bench.  ;

: run  ( n -- )
  dup ['] #spaces1 ['] #spaces defer! ." 1..." #spaces-bench
  dup ['] #spaces2 ['] #spaces defer! ." 2..." #spaces-bench
      ['] #spaces3 ['] #spaces defer! ." 3..." #spaces-bench  ;

  \         Frames
  \         ----------------------------
  \ Version 10 iterations 100 iterations
  \ ------- ------------- --------------
  \ 1                 123           1231
  \ 2                 103           1036
  \ 3                  95            951

  \ Note: 1 frame = 50th of second

( emit-udg-bench )

  \ 2015-12-18

need bench{

: e  ( n -- )
  bench{ 0 ?do  home 128 emit  loop  }bench.  ;
: eu  ( n -- )
  bench{ 0 ?do  home 128 emit-udg  loop  }bench.  ;

  \             Frames (20 ms)
  \             -----------------------
  \ Iterations  emit        emit-udg
  \ ----------  ----------- -----------
  \ 32000       1904 (1.00) 1856 (0.97)

( m+-bench )

  \ 2016-04-15

need bench{  need m+

: code-m+-bench  ( n -- )
  bench{  0 do  i s>d i m+ 2drop  loop  }bench.  ;

unused
: high-m+  ( n -- )  s>d d+  ;
unused - cr .( bytes of high M+ ) .

: high-m+-bench  ( d1|ud1 n -- d2|ud2 )
  bench{  0 do  i s>d i high-m+ 2drop  loop  }bench.  ;


: run  ( n -- )
  cr dup cr ." Code M+ ..." code-m+-bench
         cr ." High M+ ..." high-m+-bench  ;

  \ 10000 run  65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         code M+ (13 bytes)  high M+ (9 bytes)
  \         ------------------  -----------------
  \ 10000                  134         196 (1.44)
  \ 65535                  883        1308 (1.48)

( du<-bench )

  \ 2016-04-15

need bench{  need j

unused
  \ 2016-04-15: Current version in the library
: dzx-forth-du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;
unused - cr .( DZX-Forth ) . .( bytes)  \ 41

unused
: m3forth-du< ( ud1 ud2 -- f )
  rot 2dup = if 2drop u< else u> nip nip then  ;
unused - cr .( m3forth ) . .( bytes)  \ 29
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

-->

( du<-bench )

defer (u<)

: du<-bench  ( n xt -- )
  ['] (u<) defer!
  bench{
    dup 0 ?do  0 ?do  i s>d j s>d (u<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." DU< from:"
  dup cr ." DZX-Forth ..." ['] dzx-forth-du< du<-bench
      cr ." 3mforth ....." ['] m3forth-du< du<-bench  ;

  \ 10 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         DZX-Forth DU< m3forth DU<
  \         ------------- -----------
  \ 10               3623      crash!

( m*/-bench )

  \ XXX UNDER DEVELOPMENT

  \ 2016-04-15: Start.


unused
  \ 2016-04-15: This is the current implementation.
  \ Credit: from Gforth 0.7.3.
: gforth-m*/  ( d1 n1 +n2 -- d2 )
  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;
unused - cr .( gforth ) . .( bytes)  \ 89 bytes

-->

( m*/-bench )

  \ Alternative implementation of `m*/`
  \
  \ Credit:
  \
  \ Robert Smith (from COLDFORTH Version 0.8, GPL)
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/double.f

unused
need mt*  need tnegate  need ut/
unused
: coldforth-m*/  ( d1 n1 +n2 -- d2 )
    >r mt* dup 0< if    tnegate r> ut/ dnegate
                  else  r> ut/  then  ;
         cr .( coldforth:)
unused - cr .( m*/ only ) . .( bytes)  \ 33 bytes
unused - cr .( with requirements) . .( bytes)  \ 185 bytes

-->

( m*/-bench )

need bench{

defer (m*/)

: m*/-bench  ( n xt -- )
  ['] (m*/) defer!
  bench{
    1+ 1 ?do  i s>d i i (m*/) 2drop  loop
    \ XXX FIXME -- use better range of numbers
  }bench.  ;

: run  ( n -- )
      cr ." M*/ from:"
  dup cr ." Gforth ......" ['] gforth-m*/ m*/-bench
      cr ." ColdForth ..." ['] coldforth-m*/ m*/-bench  ;

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         Gforth M*/  ColdForth M*/
  \         ----------  -------------
  \ 10000         1690           1719 (1.01)
  \ 20000         3381           3442 (1.01)
  \ 65535        11621              0 \ XXX FIXME --
  \

( u<-bench )

  \ 2016-04-16: Start.
  \ 2016-04-29: Fix the loop. First working version.

need bench{  need j

defer (u<)

variable times

: u<-bench  ( n xt -- )
  ['] (u<) defer!  times !
  bench{
    times @ 0 ?do  times @ 0 ?do  i j
    \ 2dup . . key drop  \ XXX INFORMER
    (u<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." Implementation of U<"
  dup cr ."   DZX-Forth .........." ['] u< u<-bench
      cr ."   Z88 CamelForth ....." ['] z88u< u<-bench  ;

  \ 2016-04-29

  \ Times   Frames (1 frame = 50th of second)
  \ -----   --------------------------------------
  \         DZX-Forth u<  Z88 CamelForth u<
  \         ------------- ------------------------
  \   50               31                30 (0.96)
  \  100              125               120 (0.96)
  \  250              773               744 (0.96)
  \ 1000            12148             11869 (0.97)

( u<=-bench u>=-bench )

  \ 2016-04-29

need alias  need alias!  need j  need bench{  need }bench.

: 0(u<=)  ( u1 u2 -- f )  u> 0=  ;
: 1(u<=)  ( u1 u2 -- f )  1+ u<  ;

: 0(u>=)  ( u1 u2 -- f )  u< 0=  ;
: 1(u>=)  ( u1 u2 -- f )  1- u>  ;

' drop alias operator
latest constant operator-nt

variable times

: operator-bench  ( n xt -- )
  operator-nt alias!  times !
  bench{
    times @ 0 ?do  times @ 0 ?do  i j operator drop  loop  loop
  }bench.  ;

-->

( u<=-bench u>=-bench )

: run  ( n -- )
      cr ." Implementation of U<="
  dup cr ."   u> 0= ..." ['] 0(u<=) operator-bench
  dup cr ."   1+ u< ..." ['] 1(u<=) operator-bench
      cr ." Implementation of U>="
  dup cr ."   u< 0= ..." ['] 0(u>=) operator-bench
      cr ."   1- u< ..." ['] 1(u>=) operator-bench  ;

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \         u<=             u>=
  \         ------------    ------------
  \         u> 0=  1+ u<    u< 0=  1- u<
  \         -----  -----    -----  -----
  \  100      106    107      107    107
  \ 1000    10560  10560    10560  10560

( 3clshift-bench 8*-bench )

  \ 2016-05-01

need bench{  need }bench.  need clshift

: 3clshift-bench  ( n -- )
  bench{  0 do  1 3 clshift drop   loop  }bench.  ;

: 8*-bench  ( n -- )
  bench{  0 do  1 8 * drop   loop  }bench.  ;

: run  ( n -- )
  dup cr ." 3 clshift ..." 3clshift-bench
      cr ." 8 * ........." 8*-bench  ;

  \ Times  Frames (1 frame = 50th of second)
  \ -----  ---------------------------------
  \        3 clshift  8 *
  \        ---------  -------
  \ 10000        106      480

( search-bench )

  \ 2016-05-05

need bench{  need }bench.  need alias  need alias!

0 $FFFF 2constant haystack
  \ String to search: the whole memory

s" Need" $FF00 1- place 'l' $FF04 c! 'e' $FF05 c!
  \ Store "Needle" at $FF00, but hide it in this block

$FF00 6 2constant needle

defer do-search

: search-bench  ( n xt -- )
  ['] do-search defer!
  bench{  0 do  haystack needle do-search drop 2drop   loop
  }bench.  ;

: run  ( n -- )
  dup cr ." DZX-Forth .........." ['] search search-bench
  dup cr ." Z88 CamelForth 1 ..." ['] search881 search-bench
      cr ." Z88 CamelForth 2 ..." ['] search88 search-bench  ;

  \ Times  Frames (1 frame = 50th of second)
  \ -----  -----------------------------------------------
  \        DZX-Forth  Z88 CamelForth 1  Z88 CamelForth 2
  \        ---------  ----------------  ----------------
  \     1        207                24                24
  \   100      20704              2396              2395
  \   200                         4790              4791

  \                   Bytes free
  \                   ----------
  \ DZX-Forth              32797
  \ Z88 CamelForth 1       32776
  \ Z88 CamelForth 2       32786

( <-bench )

  \ 2016-05-06

need bench{  need j

defer (<)

variable times

: <-bench  ( n xt -- )
  ['] (<) defer!  times !
  bench{
    times @ 0 ?do  times @ 0 ?do  i j
    (<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." Implementation of <"
  dup cr ."   DZX-Forth .........." ['] < <-bench
      cr ."   Z88 CamelForth ....." ['] <88 <-bench  ;

  \ 2016-05-06

  \ Times   Frames (1 frame = 50th of second)
  \ -----   --------------------------------------
  \         DZX-Forth `<`  Z88 CamelForth `<`
  \         ------------- ------------------------
  \   50               33                31 (0.93)
  \  100              129               122 (0.94)
  \  250              803               755 (0.94)
  \ 1000            12534             12049 (0.96)

( =-bench )

  \ 2016-05-06

need bench{

defer (=)

variable times

: =-bench  ( n xt -- )
  ['] (=) defer!  times !
  bench{
    times @ 0 ?do  2 2 (=) 1 0 (=) 2drop  loop
  }bench.  ;

: run  ( n -- )
      cr ." Implementation of ="
  dup cr ."   DZX-Forth .........." ['] = =-bench
  dup cr ."   Z88 CamelForth 1...." ['] =881 =-bench
      cr ."   Z88 CamelForth 2...." ['] =882 =-bench  ;

  \ 2016-05-06

  \ ; DXZ-Forth
  \ _code_header equals_,'='
  \ pop de
  \ pop hl
  \ call compare_de_hl_unsigned
  \ jp z,true_
  \ jp false_

  \ ; Z88 CamelForth 1
  \ _code_header equals881_,'=881'
  \ pop de
  \ pop hl
  \ or a
  \ sbc hl,de
  \ jp z,true_
  \ jp false_

  \ ; Z88 CamelForth 2
  \ _code_header equals882_,'=882'
  \ pop de
  \ pop hl
  \ or a
  \ sbc hl,de
  \ jp nz,false_
  \ ; execution continues into `true`

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -------------------------------------------
  \         DZX-Forth Z88 CamelForth 1 Z88 CamelForth 2
  \         --------- ---------------- ----------------
  \ 10000         175       164 (0.93)       162 (0.92)
  \ 65535        1148      1073 (0.93)      1060 (0.92)

( min-bench )

  \ 2016-05-06

need bench{  need j

defer (<)

variable times

: <-bench  ( n xt -- )
  ['] (<) defer!  times !
  bench{
    times @ 0 ?do  times @ 0 ?do  i j
    (<) drop  loop  loop
  }bench.  ;

: run  ( n -- )
      cr ." Implementation of <"
  dup cr ."   DZX-Forth .........." ['] < <-bench
      cr ."   Z88 CamelForth ....." ['] <88 <-bench  ;

  \ 2016-05-06

  \ Times   Frames (1 frame = 50th of second)
  \ -----   --------------------------------------
  \         DZX-Forth `<`  Z88 CamelForth `<`
  \         ------------- ------------------------
  \   50               33                31 (0.93)
  \  100              129               122 (0.94)
  \  250              803               755 (0.94)
  \ 1000            12534             12049 (0.96)

( ?throw-bench )

need >body  need bench{  need }bench.

: ?throw0  ( f n -- )  swap if  throw  else  drop  then  ;
: ?throw1  ( f n -- )
  swap ?branch [ ' throw >body , ] drop  ;
: ?throw2  ( f n -- )  swap 0<> and throw  ;
: ?throw3  ( f n -- )  and throw  ;
: ?throw4  ( f n -- )  swap if  throw  then  drop  ;

: run  ( n -- )
  cr ." Versions"
  dup cr ." 0: " bench{ 0 ?do  0 0 ?throw0  loop }bench.
  dup cr ." 1: " bench{ 0 ?do  0 0 ?throw1  loop }bench.
  dup cr ." 2: " bench{ 0 ?do  0 0 ?throw2  loop }bench.
  dup cr ." 3: " bench{ 0 ?do  0 0 ?throw3  loop }bench.
      cr ." 4: " bench{ 0 ?do  0 0 ?throw4  loop }bench.  ;

  \ 2016-05-13

  \ Times   Frames (1 frame = 50th of second)
  \ -----   --------------------------------------------
  \          ?throw0  ?throw1  ?throw2  ?throw3  ?throw4
  \          -------  -------  -------  -------  -------
  \  1000         15       15       23       20       15
  \ 10000        149      148      230      198      150
  \ 65535        979      969     1507     1294      978

  \ vim: filetype=soloforth
  \ meta.benchmark.rng.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201604242022

  \ -----------------------------------------------------------
  \ Description

  \ RNG benchmarks written during the development of Solo Forth
  \ in order to choose the best implementations.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Add `need 2rdrop`, because `2rdrop` has been
  \ moved from the kernel to the library.

( rnd-benchmark )

  \ XXX UNDER DEVELOPMENT -- new benchmark
  \ 2016-04-07: Start

need bits  need u%

$FFFF constant #sampled
8 constant /byte  \ bits
#sampled /byte / constant /sample

create sample  /sample allot

: -sample  ( -- )  sample /sample erase  ;
  \ Erase the sample.

: sampled  ( -- u )  sample /sample bits  ;
  \ Count the bits of the sample.

: remember  ( u -- )  /byte /mod sample + c!set-bits  ;
  \ Remember random number _u_, by setting its associated bit
  \ in the sample.

: sampled%.  ( u -- )  #sampled u% 0.r ." %"  ;
  \ Print _u_ sampled numbers as a percentage.

: .sampled  ( u -- )  dup u. ." (" sampled%. ." )"  ;
  \ Print _u_ as the number of sampled numbers.

: report  ( ca len -- )  type sampled .sampled cr  ;

: rnd-benchmark  ( ca len xt -- )
  -sample
  #sampled 0 do  dup execute remember  loop  drop
  report  ;

( random-pix-benchmark )

  \ Random pixels benchmark

need set-pixel  need bench{  need pixels  need u%  need 3dup

256 192 * constant #pixels
  \ number of pixels of the screen

defer rng  ( n -- 0..n-1 )

: pixels%.  ( u -- )  #pixels u% 0.r ." %"  ;
  \ Print _u_ pixels as a percentage of the maximum number of
  \ pixels.

: .pixels  ( u -- )  dup u. ." pixels (" pixels%. ." )"  ;
  \ Print _u_ as the number of pixels.

: .title  ( ca len -- )  ." Code: " type  ;

variable cycles

defer .cycles  ( -- )

: (.cycles)  ( -- )
  cycles ?  s" cycles" cycles @ 1 = + type  ;
  \ Print the number of cycles.

: .time  ( d -- )  bench. ." per cycle" cr  ;

: .result  ( ca len d -- )
  2>r pixels >r  .title cr  r> .pixels cr
  2r> .time .cycles   ;
  \ Calculate and print the result of the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

-->

( random-pix-benchmark )

defer random-coords  ( -- gx gy )
  \ Random graphic coordinates. Configurable depending on the
  \ type of `random` to benchmark.

: (random-coords)  ( -- gx gy )  256 rng 192 rng  ;
  \ Default behaviour of `random-coords`.

: fill-screen  ( -- )
  #pixels 0 do  random-coords set-pixel  loop  ;
  \ Fill the screen with random pixels.

: signal  ( -- )  cycles @ %111 and border  ;
  \ Change the border color according to the current count
  \ of cycles, just to show that the benchmark is running.

: (random-pix-benchmark)  ( -- d )
  1 cycles +!  signal  bench{ fill-screen }bench  ;
  \ Do one cycle of the benchmark and return its result.

: wait  ( -- )  key drop  ;

: finish  ( ca len d -- )  0 border  .result  wait  ;
  \ Finish the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

: init  ( xt1 xt2 xt3 -- )
  ['] random-coords defer!  ['] .cycles defer!  ['] rng defer!
  page  -1 cycles !  ;

defer finish?  ( i*x -- j*x f )
  \ Finish the benchmark?

: new-pixels?  ( n1 -- n2 f )  pixels tuck =  ;
  \ Are there new pixels on the screen, comparing the previous
  \ count _n1_ with the new count _n2_?

' new-pixels? ' finish? defer!  -->

( random-pix-benchmark )

defer random-pix-benchmark  ( ca len xt -- )
  \ Do a RNG benchmark for the `random` word _xt_ with title
  \ _ca len_.

: (random-pix-benchmark2)  ( ca len -- )
  0 begin   (random-pix-benchmark) 2>r
            finish? dup 0= if  2rdrop  then
  until     drop 2r> finish  ;
  \ Do a double RNG benchmark with title _ca len_: The time
  \ required to complete one cycle (49152 random pixels), plus
  \ the number of cycles required until the number of pixels
  \ doesn't change.

: random-pix-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] (random-coords) init
  (random-pix-benchmark2)  ;
  \ Do a double RNG benchmark for the `random` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

  \ The best `random` words need several cycles. In such cases
  \ it's useful a simpler test to show only the pixels set at
  \ the end of the first cycle:

' random-pix-benchmark2 ' random-pix-benchmark defer!
  \ default benchmark

: (.cycle)  ( -- )  ." First cycle only"  ;

: (random-pix-benchmark1)  ( ca len -- )
  (random-pix-benchmark) .result wait  ;
  \ Do a one-cycle RNG benchmark with title _ca len_: Only the
  \ time required to complete one cycle (49152 random pixels).

: random-pix-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] (random-coords) init
  (random-pix-benchmark1)  ;  -->
  \ Do a one-cycle RNG benchmark for `random` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( random-pix-benchmark )

  \ Versions for 8-bit `rnd`.

: crnd-coords  ( -- gx gy )  rng rng 192 min  ;
  \ Random graphic coordinates for 8-bit `rnd`.

: crnd-pix-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] crnd-coords init
  (random-pix-benchmark2)  ;
  \ Do a double RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

: crnd-pix-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] crnd-coords init
  (random-pix-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( 16-bit-random-pix-benchmarks )

  \ Execute all of the 16-bit random pixels benchmarks

need random-pix-benchmark  need +thru  2 21 +thru

ace-random-pix-benchmark

cgm-5E9B-random-pix-benchmark
cgm-61BF-random-pix-benchmark
cgm-62DC-random-pix-benchmark
cgm-6363-random-pix-benchmark
cgm-6594-random-pix-benchmark
cgm-65E8-random-pix-benchmark

dx-random-pix-benchmark gf-random-pix-benchmark
jer-random-pix-benchmark jml-random-pix-benchmark
lb-random-pix-benchmark lina-random-pix-benchmark
mb-random-pix-benchmark

  \ mm-random-pix-benchmark  \ XXX TMP --

sf83-random-pix-benchmark tt-random-pix-benchmark
vf-random-pix-benchmark z88-random-pix-benchmark
zh-random-pix-benchmark  -->

( 16-bit-random-pix-benchmarks )

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' random-pix-benchmark1 ' random-pix-benchmark defer!

cgm-5E9B-random-pix-benchmark
cgm-61BF-random-pix-benchmark
cgm-62DC-random-pix-benchmark
cgm-6363-random-pix-benchmark
cgm-6594-random-pix-benchmark
cgm-65E8-random-pix-benchmark

dx-random-pix-benchmark  vf-random-pix-benchmark

( ace-random )

  \ Credit:
  \
  \ Adapted from ACE Forth, after the Jupiter ACE manual.
  \ Also used by Abersoft Forth in its bundled game
  \ "Bertie".

need os-seed

: ace-rnd  ( -- u )
  os-seed @ 75 um* 75. d+ 2dup u< - - 1- dup os-seed !  ;

: ace-random  ( n -- 0..n-1 )  ace-rnd um* nip  ;

need random-pix-benchmark

: ace-random-pix-benchmark  ( -- )
  os-seed off  s" Jupiter ACE manual"
  ['] ace-random random-pix-benchmark  ;

( cgm-5E9B-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-5E9B-rnd  ( -- u )
  rloc 2@ $5E9B um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-5E9B-random  ( n -- 0..n-1 )  cgm-5E9B-rnd um* nip  ;

need random-pix-benchmark

: cgm-5E9B-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $5E9B"
  ['] cgm-5E9B-random random-pix-benchmark  ;

( cgm-61BF-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-61BF-rnd  ( -- u )
  rloc 2@ $61BF um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-61BF-random  ( n -- 0..n-1 )  cgm-61BF-rnd um* nip  ;

need random-pix-benchmark

: cgm-61BF-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $61BF"
  ['] cgm-61BF-random random-pix-benchmark  ;

( cgm-62DC-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-62DC-rnd  ( -- u )
  rloc 2@ $62DC um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-62DC-random  ( n -- 0..n-1 )  cgm-62DC-rnd um* nip  ;

need random-pix-benchmark

: cgm-62DC-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $62DC"
  ['] cgm-62DC-random random-pix-benchmark  ;

( cgm-6363-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-6363-rnd  ( -- u )
  rloc 2@ $6363 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-6363-random  ( n -- 0..n-1 )  cgm-6363-rnd um* nip  ;

need random-pix-benchmark

: cgm-6363-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $6363"
  ['] cgm-6363-random random-pix-benchmark  ;

( cgm-6594-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-6594-rnd  ( -- u )
  rloc 2@ $6594 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-6594-random  ( n -- 0..n-1 )  cgm-6594-rnd um* nip  ;

need random-pix-benchmark

: cgm-6594-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $6594"
  ['] cgm-6594-random random-pix-benchmark  ;

( cgm-65E8-random )

  \ Random Number Generator by C. G. Montgomery

  \ 2015-12-13: found here:
  \ http://web.archive.org/web/20060707001752/http://www.tinyboot.com/index.html
  \
  \ 2016-03-31: adapted to Solo Forth.

2variable rloc  $111 rloc !  \ seed with nonzero

: cgm-65E8-rnd  ( -- u )
  rloc 2@ $65E8 um* rot 0 d+ over rloc 2!  ;
  \ good values for 16-bit systems: 61BF 62DC 6594 6363 5E9B 65E8

: cgm-65E8-random  ( n -- 0..n-1 )  cgm-65E8-rnd um* nip  ;

need random-pix-benchmark

: cgm-65E8-random-pix-benchmark  ( -- )
  s" C. G. Montgomery $65E8"
  ['] cgm-65E8-random random-pix-benchmark  ;

( dx-random )

  \ Credit:
  \
  \ Code from DX-Forth 4.13.

2variable dx-seed  1. dx-seed 2!

need d*

: dx-rnd ( -- u )
  dx-seed 2@ $15A4E35. d* 1. d+ tuck dx-seed 2!  ;
  \ Get random number

: dx-random ( u -- 0..u-1 )  dx-rnd um* nip  ;
  \ Get random number between 0 and u-1

need random-pix-benchmark

: dx-random-pix-benchmark  ( -- )
  s" DX-Forth" ['] dx-random random-pix-benchmark  ;

( gf-random )

  \ Credit:
  \
  \ Adapted from Gforth.

need os-seed  need ud*

: gf-rnd  ( -- n )
  272958469. os-seed @ ud* d>s 1+ dup os-seed !  ;

: gf-random  ( n -- 0..n-1 )  gf-rnd um* nip  ;

need random-pix-benchmark

: gf-random-pix-benchmark  ( -- )
  os-seed off  s" Gforth"
  ['] gf-random random-pix-benchmark  ;

( jer-random )

  \ Credit:
  \
  \ Random number generator by J. E. Rickenbacker, published on
  \ Forth Dimensions (volume 2, number 2, page 34, 1980-07).

need os-seed

: jer-rnd  ( -- n )
  os-seed @ 259 * 3 + 32767 and dup os-seed !  ;

: jer-random ( n1 -- n2 )
  jer-rnd 32767 */  ;
  \ Return a random number _n2_ (0 <= n2 < n1).

  \ XXX Note: patterns

need random-pix-benchmark

: jer-random-pix-benchmark  ( -- )
  os-seed off  s" J. E. Rickenbacker"
  ['] jer-random random-pix-benchmark  ;

( jml-random )

  \ Credit:
  \
  \ Adapted from code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need z80-asm  need os-seed

code jml-rnd  ( -- u )

  os-seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  os-seed sthl
  jppushhl
  end-code

: jml-random  ( n -- 0..n-1 )  jml-rnd um* nip  ;

need random-pix-benchmark

: jml-random-pix-benchmark  ( -- )
  os-seed off  s" J. M. Lazo"
  ['] jml-random random-pix-benchmark  ;

( lb-random )

  \ Credit:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: lb-rnd  ( -- u )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: lb-random  ( n -- 0..n-1 )  lb-rnd um* nip  ;

need random-pix-benchmark

: lb-random-pix-benchmark  ( -- )
  os-seed off  s" Leo Brodie"
  ['] lb-random random-pix-benchmark  ;

( lina-random )

need os-seed

: lina-rnd  ( -- n )
  os-seed @ 107465 * 234567 + dup os-seed !  ;

: lina-random  ( n -- 0..n-1 )  lina-rnd um* nip ;

need random-pix-benchmark

: lina-random-pix-benchmark  ( -- )
  os-seed off  s" lina"
  ['] lina-random random-pix-benchmark  ;

( mb-random )

  \ Credit:
  \
  \ Adapted from code published by Milos Bazelides:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

need z80-asm  need os-seed

code mb-rnd  ( -- u )
  os-seed de ftp
  d a ld  e h ld  #253 l ld#
  a or  de sbcp
  0 sbc#  de sbcp
  0 d ld#  d sbc  a e ld  de sbcp
  cy if  hl incp  then
  os-seed sthl
  jppushhl   end-code

: mb-random  ( n -- 0..n-1 )  mb-rnd um* nip  ;

  \ Original code:

  \ ----
  \ ; Input: none
  \ ; Output: HL = pseudo-random number, period 65536

  \ Rand16:
  \  ld  de,Seed    ; Seed is usually 0
  \  ld  a,d
  \  ld  h,e
  \  ld  l,253
  \  or  a
  \  sbc  hl,de
  \  sbc  a,0
  \  sbc  hl,de
  \  ld  d,0
  \  sbc  a,d
  \  ld  e,a
  \  sbc  hl,de
  \  jr  nc,Rand
  \  inc  hl
  \ Rand:
  \  ld  (Rand16+1),hl
  \  ret
  \ ----

need random-pix-benchmark

: mb-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides"
  ['] mb-random random-pix-benchmark  ;

( mm-random )

  \ Credit:
  \ IsForth Random Number Generator, by Mark I Manning IV.

  \ 2016-04-04: Adapted to Solo Forth. Strange negative
  \ results.
  \ XXX TODO -- check the original

need cell/  need frames@

variable seed1  variable seed2

: randomize  ( -- )  frames@ seed1 ! seed2 !  ;

: 0seed  ( -- )  seed1 off seed2 off  ;  0seed
  \ Reset random number generator seed to zero.

: mm-random  ( n1 --- n2 )
  seed1 @ 123 * 234 + seed2 @ 234 * 123 +
  2dup + seed2 ! 2dup xor seed1 !
  + swap cells mod cell/ ;

need random-pix-benchmark

: mm-random-pix-benchmark  ( -- )
  s" IsForth" ['] mm-random random-pix-benchmark  ;

  \ ' random-pix-benchmark2 ' random-pix-benchmark defer!

  \ mm-random-pix-benchmark

  \ ' random-pix-benchmark1 ' random-pix-benchmark defer!

  \ mm-random-pix-benchmark

( sf83-random )

  \ Credit:
  \
  \ Code from Spectrum Forth-83.

need os-seed  3 os-seed !

: sf83-random  ( n -- 0..n-1 )
  os-seed @ 743 * 43 + dup os-seed ! um* swap drop  ;

need random-pix-benchmark

: sf83-random-pix-benchmark  ( -- )
  s" Spectrum Forth-83"
  ['] sf83-random random-pix-benchmark  ;

( tt-random )

  \ Credit:
  \
  \ Code from tt.pfe, Tetris for terminals, redone in
  \ ANSI-Forth.  Written 1994-04-05 by Dirk Uwe Zoller.
  \
  \ Note: the seed can not be zero.

need os-seed

: tt-random   ( n -- 0..n-1 )
    os-seed @ 13 * $7FFF and
    dup os-seed !  swap mod ;

need random-pix-benchmark

: tt-random-pix-benchmark  ( -- )
  os-seed on  s" Tetris for terminals"
  ['] tt-random random-pix-benchmark  ;

( vf-random )

  \ Credit:
  \
  \ Code from vForth.

need os-frames

: vf-random  ( n -- 0..n-1 )
  1+ 8195 os-frames @ um* 1. d+
  16383 um/mod drop
  \ dup os-seed !
  swap mod  ;

need random-pix-benchmark

: vf-random-pix-benchmark  ( -- )
  s" vForth" ['] vf-random random-pix-benchmark  ;

( z88-random )

  \ Credit:
  \
  \ Code adapted from Z88 CamelForth.

need ud*  need os-seed  need 2rdrop

: z88-random  ( n -- 0..n-1 )
  1103515245. \ 20077 16838
  os-seed @ ud* 12345. d+ over os-seed !
  rot ud/mod 2drop  ;

need random-pix-benchmark

: z88-random-pix-benchmark  ( -- )
  os-seed off  s" Z88 CamelForth"
  ['] z88-random random-pix-benchmark  ;

( zh-random )

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code zh-rnd  ( -- u )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  jppushhl   end-code

: zh-random  ( n -- 0..n-1 )  zh-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

need random-pix-benchmark

: zh-random-pix-benchmark  ( -- )
  os-seed off  s" Z80 Heaven"
  ['] zh-random random-pix-benchmark  ;

( random-byte )

code random-byte  ( -- b )
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

need bench{

: random-byte-test  ( -- )
  ['] random-byte ['] rng defer!  cls  bench{ pixels
  do  rng rng 192 min set-pixel  loop  }bench.
  ." Z80 R register" cr key drop ;

( lcm-random )

  \ XXX UNDER DEVELOPMENT

  \ Credit:
  \
  \ Adapted from code written by Everett F. Carter, published
  \ on Forth Dimensions (volume 16, number 2, page 17,
  \ 1994-08).
  \
  \ Linear Congruential Method, the "minimal standard
  \ generator", Park & Miller, 1988, Comm of the ACM, 31(10),
  \ pp. 1192-1201

need d*  need du/mod  need 2nip

2variable 2seed

2147483647. 2constant max32

: lcm-rnd  ( -- d )
  2seed 2@ 16807. d*
  max32 du/mod  2nip
  2dup 2seed 2!  ;
  \ XXX FIXME -- it always returns 0

  \ \ Original code:
  \ : lcm-rnd  ( -- d )
  \   2seed 2@ 16807. umd*
  \   max32 umd/mod
  \   2drop 2seed 2!  ;

: lcm-random  ( n -- 0..n-1 )  lcm-rnd d>s um* nip  ;

need random-pix-benchmark

: lcm-random-pix-benchmark  ( -- )
  s" LCM" ['] lcm-random random-pix-benchmark  ;

( 8-bit-random-pix-benchmarks )

  \ Execute all of the 8-bit random pixels benchmarks

need random-pix-benchmark  need +thru  1 5 +thru

' crnd-pix-benchmark2 ' random-pix-benchmark defer!

  \ libzx-random-pix-benchmark
  \ jw-random-pix-benchmark
  mb1-random-pix-benchmark
  mb2-random-pix-benchmark
  \ zh-random-pix-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' crnd-pix-benchmark1 ' random-pix-benchmark defer!

  \ jw-random-pix-benchmark
  \ libzx-random-pix-benchmark

( jw-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need z80-asm  need os-seed

code jw-crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

need random-pix-benchmark

: jw-random-pix-benchmark  ( -- )
  os-seed off  s" Joe Wingbermuehle"
  ['] jw-crnd random-pix-benchmark  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( mb1-crnd )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

  \ This is a very simple linear congruential generator. The
  \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
  \ advantage is small size and simplicity. Due to nature of
  \ such generators only a couple of higher bits should be
  \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb1-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  a inc  os-seed sta
    \  inc  a    ; another possibility is ADD A,7
    \  ld  (seed),a
  pusha jp
  end-code

: mb1-crandom  ( n1 -- n2 )  mb1-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need random-pix-benchmark

  \ : mb1-random-pix-benchmark  ( -- )
  \   s" Milos Bazelides 1" ['] mb1-crandom random-pix-benchmark  ;

: mb1-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides 1 (8 bit)"
  ['] mb1-crnd random-pix-benchmark  ;

( mb2-crnd )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credit:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb2-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  07 add#  os-seed sta
    \  add a,7
    \  ld  (seed),a
  pusha jp  end-code

: mb2-crandom  ( n1 -- n2 )  mb2-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need random-pix-benchmark

  \ : mb2-random-pix-benchmark  ( -- )
  \   s" Milos Bazelides 2" ['] mb2-crandom random-pix-benchmark  ;

: mb2-random-pix-benchmark  ( -- )
  os-seed off  s" Milos Bazelides 2 (8 bit)"
  ['] mb2-crnd random-pix-benchmark  ;

( zh-crnd )

  \ 2015-12-25

  \ Credit:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

code zh-crnd  ( -- b )

  os-seed fta  a e ld
  a add  e add  a add  a add  e add  #83 add#
  os-seed sta
  pusha jp

  end-code

need random-pix-benchmark

: zh-random-pix-benchmark  ( -- )
  s" Z80 Heaven (8 bit)" ['] zh-crnd random-pix-benchmark  ;

  \ This is one of many variations of PRNGs. This routine is
  \ not particularly useful for many games, but is fairly
  \ useful for shuffling a deck of cards. It uses SMC, but that
  \ can be fixed by defining randSeed elsewhere and using ld
  \ a,(randSeed) at the beginning.

  \ PseudoRandByte:
  \ ;f(n+1)=13f(n)+83
  \ ;97 cycles
  \      .db 3Eh     ;start of ld a,*
  \ randSeed:
  \      .db 0
  \      ld c,a
  \      add a,a
  \      add a,c
  \      add a,a
  \      add a,a
  \      add a,c
  \      add a,83
  \      ld (randSeed),a
  \      ret

( opt3-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized and modified
  \ the original code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  rom-pointer off  os-seed off

code opt3-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ftp  hl incp
  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld hl,(romPointer)
    \ inc hl
    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  rom-pointer off  os-seed off  s" libzx opt3 (8 bit)"
  ['] opt3-libzx-crnd random-pix-benchmark  ;

' crnd-pix-benchmark2 ' random-pix-benchmark defer!
libzx-random-pix-benchmark  \ XXX TMP --

( opt2-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized and modified
  \ the original code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  rom-pointer off  os-seed off

code opt2-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ftp  hl incp
  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld hl,(romPointer)
    \ inc hl
    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta
    \ ld (lastRandomNumber), a        ; save this number

  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  rom-pointer off  os-seed off  s" libzx opt2 (8 bit)"
  ['] opt2-libzx-crnd random-pix-benchmark  ;

libzx-random-pix-benchmark  \ XXX TMP --

( opt1-libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth. Optimized the original
  \ code.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  3 rom-pointer !  33 os-seed c!

code opt1-libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer bc ftp 3 hl ldp#  bc addp

    \ ld bc,(romPointer)
    \ ld hl,3
    \ add hl,bc ; HL := ROM pointer advanced by 3

  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld a, h
    \ and %00111111
    \ ld h, a     ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed sta
    \ ld (lastRandomNumber), a        ; save this number

  bc pop  pusha jp  end-code

: libzx-random-pix-benchmark  ( -- )
  3 rom-pointer !  33 os-seed c!
  s" libzx opt1 (8 bit)"
  ['] opt1-libzx-crnd random-pix-benchmark  ;

( libzx-crnd )

  \ Credit:
  \ Original code from the ZX Spectrum libzx library,
  \ written by Sebastian Mihai, 2016

  \ 2016-04-09: Adapted to Solo Forth.

need z80-asm  need os-seed  need random-pix-benchmark

variable rom-pointer  3 rom-pointer !  33 os-seed c!

code libzx-crnd  ( -- b )

  \ Gets an 8-bit random number.
  \ It is computed using a combination of:
  \     - the last returned random number
  \     - a byte from ROM, in increasing order
  \     - current values of various registers
  \     - a flat incremented value

  bc push  af push
    \ save Forth IP and the AF register

  \ 1) advance ROM pointer

  rom-pointer hl ldp#
  m c ld  hl incp  m b ld  3 hl ldp#  bc addp
    \ XXX TODO -- simpler
    \ XXX REMARK -- original code is not optimized

    \ ld hl, romPointer
    \ ld c, (hl)
    \ inc hl
    \ ld b, (hl)        ; BC := word (romPointer)
    \ ld hl, 3
    \ add hl, bc        ; HL := ROM pointer advanced by 3

  h a ld  %00111111 and  a h ld  hl rom-pointer stp

    \ ld a, h
    \ and %00111111
    \ ld h, a          ; H := H mod %00111111
    \             ; essentially, HL := HL mod 16384, to make sure
    \             ; HL points at a ROM location
    \ ld (romPointer), hl    ; save new location

  \ 2) compute the random number

  bc pop  c rlc  b rlc  os-seed fta
    \ pop bc          ; BC := AF
    \ rlc c
    \ rlc b
    \ ld a, (lastRandomNumber)
  47 add#  b add  c add  d add  e add  h add  l add
    \ add a, 47
    \ add a, b  ; current register values are "pretty random"
    \ add a, c  ; so add them in the mix
    \ add a, d
    \ add a, e
    \ add a, h
    \ add a, l

  rom-pointer hl ldp#  m add
    \ ld hl, romPointer
    \ add a, (hl) ; the contents of the ROM are "pretty random"
    \             ; so add it in the mix

  os-seed ldp#  m a ld
    \ ld hl, lastRandomNumber
    \ ld (hl), a        ; save this number
    \ XXX REMARK -- original code is not optimized

  bc pop  0 h ld#  a l ld  jppushhl end-code

: libzx-random-pix-benchmark  ( -- )
  3 rom-pointer !  33 os-seed c!
  s" libzx (8 bit)" ['] libzx-crnd random-pix-benchmark  ;


  \ ===========================================================

  \ 2016-03-31
  \ Results of the 16-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Jupiter ACE manual     | 05937 (012%) | 07652 (153 s) | 1
  \ | C. G. Montgomery $5E9B | 49151 (099%) | 06917 (138 s) | 11
  \ | C. G. Montgomery $5E9B | 30985 (063%) | 06917 (138 s) | first only
  \ | C. G. Montgomery $61BF | 49152 (100%) | 06916 (138 s) | 11
  \ | C. G. Montgomery $61BF | 31024 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $62DC | 49152 (100%) | 06917 (138 s) | 12
  \ | C. G. Montgomery $62DC | 30964 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $6363 | 49152 (100%) | 06917 (138 s) | 11
  \ | C. G. Montgomery $6363 | 30917 (062%) | 06917 (138 s) | first only
  \ | C. G. Montgomery $6594 | 49151 (099%) | 06917 (138 s) | 10
  \ | C. G. Montgomery $6594 | 31009 (063%) | 06916 (138 s) | first only
  \ | C. G. Montgomery $65E8 | 49152 (100%) | 06917 (138 s) | 12
  \ | C. G. Montgomery $65E8 | 31006 (063%) | 06917 (138 s) | first only
  \ | DX-Forth               | 49152 (100%) | 17733 (354 s) | 12
  \ | DX-Forth               | 31076 (063%) | 17734 (354 s) | first only
  \ | Gforth                 | 31189 (063%) | 09746 (194 s) | 1
  \ | J. E. Rickenbacker     | 08149 (016%) | 18458 (369 s) | 1
  \ | J. M. Lazo             | 12637 (025%) | 03349 (066 s) | 1
  \ | Leo Brodie             | 20818 (042%) | 09150 (183 s) | 1
  \ | lina                   | 23945 (048%) | 09179 (183 s) | 1
  \ | Milos Bazelides        | 28465 (057%) | 03316 (066 s) | 1
  \ | Spectrum Forth-83      | 05194 (010%) | 08741 (174 s) | 1
  \ | Tetris for terminals   | 02038 (004%) | 14200 (284 s) | 1
  \ | vForth                 | 27448 (055%) | 14806 (296 s) | 10
  \ | vForth                 | 20804 (042%) | 14806 (296 s) | first only
  \ | Z88 CamelForth         | 05496 (011%) | 15683 (313 s) | 1
  \ | Z80 Heaven             | 32599 (066%) | 03371 (067 s) | 1

  \ 2016-03-31
  \ Results of the 8-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Joe Wingbermuehle      | 49145 (099%) | 01076 (021 s) | 29
  \ | Joe Wingbermuehle      | 25234 (051%) | 01075 (021 s) | first only
  \ | Milos Bazelides 1      | 00096 (000%) | 01047 (020 s) | 1
  \ | Milos Bazelides 2      | 00096 (000%) | 01048 (021 s) | 1
  \ | Z80 Heaven             | 00096 (000%) | 01055 (021 s) | 1

  \ 2016-04-07
  \ Results of the 16-bit version of `random-pix-benchmark`,
  \ with `os-seed` initialized to zero every time, except when
  \ the implementation needs a non-zero value:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Jupiter ACE manual     | 02272 (004%) | 07635 (152 s) | 1
  \ | C. G. Montgomery $5E9B | 49151 (099%) | 06899 (137 s) | 11
  \ | C. G. Montgomery $5E9B | 31064 (063%) | 06900 (138 s) | first only
  \ | C. G. Montgomery $61BF | 49152 (100%) | 06899 (137 s) | 12
  \ | C. G. Montgomery $61BF | 30983 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $62DC | 49152 (100%) | 06900 (138 s) | 10
  \ | C. G. Montgomery $62DC | 31054 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $6363 | 49152 (100%) | 06899 (137 s) | 10
  \ | C. G. Montgomery $6363 | 31063 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $6594 | 49152 (100%) | 06900 (138 s) | 11
  \ | C. G. Montgomery $6594 | 31084 (063%) | 06899 (137 s) | first only
  \ | C. G. Montgomery $65E8 | 49151 (099%) | 06900 (138 s) | 11
  \ | C. G. Montgomery $65E8 | 31123 (063%) | 06899 (137 s) | first only
  \ | DX-Forth               | 49152 (100%) | 17717 (354 s) | 11
  \ | DX-Forth               | 31031 (063%) | 17718 (354 s) | first only
  \ | Gforth                 | 31104 (063%) | 09725 (194 s) | 1
  \ | J. E. Rickenbacker     | 08192 (016%) | 18460 (369 s) | 1
  \ | J. M. Lazo             | 12608 (025%) | 03325 (066 s) | 1
  \ | Leo Brodie             | 20928 (042%) | 09131 (182 s) | 1
  \ | lina                   | 24064 (048%) | 09161 (183 s) | 1
  \ | Milos Bazelides        | 28715 (058%) | 03297 (065 s) | 1
  \ | Spectrum Forth-83      | 05120 (010%) | 08723 (174 s) | 1
  \ | Tetris for terminals   | 00096 (000%) | 14210 (284 s) | 1
  \ | vForth                 | 29248 (059%) | 14807 (296 s) | 9
  \ | vForth                 | 21694 (044%) | 14806 (296 s) | first only
  \ | Z88 CamelForth         | 00384 (000%) | 15683 (313 s) | 1
  \ | Z80 Heaven             | 32768 (066%) | 03352 (067 s) | 1

  \ 2016-04-08
  \ Results of the 8-bit version of `random-pix-benchmark`:

  \ | Code | Pixels | Time per cycle in frames (and seconds) | Cycles

  \ | Joe Wingbermuehle      | 49140 (099%) | 01075 (021 s) | 27
  \ | Joe Wingbermuehle      | 25308 (051%) | 01075 (021 s) | first only
  \ | libzx                  | 25650 (052%) | 01389 (027 s) | 2
  \ | libzx                  | 25380 (051%) | 01390 (027 s) | first only
  \ | libzx (opt1)           | 25650 (052%) | 01389 (027 s) | 2
  \ | libzx (opt2)           | 25784 (052%) | 01382 (027 s) | 2
  \ | libzx (opt2)           | 25650 (052%) | 01382 (027 s) | first only
  \ | Milos Bazelides 1      | 00096 (000%) | 01052 (021 s) | 1
  \ | Milos Bazelides 2      | 00096 (000%) | 01055 (021 s) | 1
  \ | Z80 Heaven             | 00096 (000%) | 01061 (021 s) | 1


  \ vim: filetype=soloforth
  \ meta.test.hayes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170051

  \ -----------------------------------------------------------
  \ Description

  \ this program tests the core words of an ans forth system.
  \ the program assumes a two's complement implementation where
  \ the range of signed numbers is -2^(n-1) ... 2^(n-1)-1 and the
  \ range of unsigned numbers is 0 ... 2^(n)-1.  i haven't
  \ figured out how to test key, quit, abort, or abort"...  i
  \ also haven't thought of a way to test environment?...

  \ -----------------------------------------------------------
  \ Authors

  \ John Hayes S1I, 1995-11-27.

  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2016.

  \ -----------------------------------------------------------
  \ License

  \ Original version:

  \ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS
  \ LABORATORY MAY BE DISTRIBUTED FREELY AS LONG AS THIS
  \ COPYRIGHT NOTICE REMAINS.  VERSION 1.2

  \ This version:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-09: Start.
  \ 2016-05-10: First working version.
  \ 2016-05-14: Update: `evaluate` has been moved to the
  \ library.
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( hayes-test )

need hayes-tester  verbose on  hex  warnings off

{ -> }  \ start with clean slate

  \ Test if any bits are set; answer in base 1.

{ : bitsset? if 0 0 else 0 then ; -> }
{  0 bitsset? -> 0 } {  1 bitsset? -> 0 0 }
  \ Zero is all bits clear; other number have at least one bit.

{ -1 bitsset? -> 0 0 }

testing( invert and or xor)

{ 0 0 and -> 0 } { 0 1 and -> 0 }
{ 1 0 and -> 0 } { 1 1 and -> 1 }

{ 0 invert 1 and -> 1 } { 1 invert 1 and -> 0 }

0  constant 0s  0 invert constant 1s

{ 0s invert -> 1s } { 1s invert -> 0s } { 0s 0s and -> 0s }
{ 0s 1s and -> 0s } { 1s 0s and -> 0s } { 1s 1s and -> 1s }
{ 0s 0s or -> 0s } { 0s 1s or -> 1s } { 1s 0s or -> 1s }
{ 1s 1s or -> 1s } { 0s 0s xor -> 0s } { 0s 1s xor -> 1s }
{ 1s 0s xor -> 1s } { 1s 1s xor -> 0s }  -->

( hayes-test )

testing( 2* 2/)  need rshift  need 2/

  \ We trust `1s`, `invert`, and `bitsset?`; we will confirm
  \ `rshift` later.

1s 1 rshift invert constant msb { msb bitsset? -> 0 0 }

{ 0s 2* -> 0s } { 1 2* -> 2 } { 4000 2* -> 8000 }
{ 1s 2* 1 xor -> 1s } { msb 2* -> 0s } { 0s 2/ -> 0s }
{ 1 2/ -> 0 } { 4000 2/ -> 2000 }
{ 1s 2/ -> 1s }  \ msb propagated
{ 1s 1 xor 2/ -> 1s } { msb 2/ msb and -> msb }  -->

( hayes-test )

testing( lshift rshift)  need lshift  need rshift

{ 1 0 lshift -> 1 } { 1 1 lshift -> 2 } { 1 2 lshift -> 4 }
{ 1 f lshift -> 8000 }  \ biggest guaranteed shift
{ 1s 1 lshift 1 xor -> 1s } { msb 1 lshift -> 0 }

{ 1 0 rshift -> 1 } { 1 1 rshift -> 0 } { 2 1 rshift -> 1 }
{ 4 2 rshift -> 1 }
{ 8000 f rshift -> 1 }  \ biggest
{ msb 1 rshift msb and -> 0 }  \ rshift zero fills msbs
{ msb 1 rshift 2* -> msb }  -->

( hayes-test )

testing( 0= = 0< < > u< min max)

0 invert  constant max-uint
0 invert 1 rshift  constant max-int
0 invert 1 rshift invert  constant min-int
0 invert 1 rshift  constant mid-uint
0 invert 1 rshift invert  constant mid-uint+1

0s constant <false> 1s constant <true>

{ 0 0= -> <true> } { 1 0= -> <false> } { 2 0= -> <false> }
{ -1 0= -> <false> } { max-uint 0= -> <false> }
{ min-int 0= -> <false> } { max-int 0= -> <false> }  -->

( hayes-test )

{ 0 0 = -> <true> } { 1 1 = -> <true> } { -1 -1 = -> <true> }
{ 1 0 = -> <false> } { -1 0 = -> <false> } { 0 1 = -> <false> }
{ 0 -1 = -> <false> } { 0 0< -> <false> } { -1 0< -> <true> }
{ min-int 0< -> <true> } { 1 0< -> <false> }
{ max-int 0< -> <false> } { 0 1 < -> <true> }
{ 1 2 < -> <true> } { -1 0 < -> <true> } { -1 1 < -> <true> }
{ min-int 0 < -> <true> } { min-int max-int < -> <true> }
{ 0 max-int < -> <true> } { 0 0 < -> <false> }
{ 1 1 < -> <false> } { 1 0 < -> <false> } { 2 1 < -> <false> }
{ 0 -1 < -> <false> } { 1 -1 < -> <false> }
{ 0 min-int < -> <false> } { max-int min-int < -> <false> }
{ max-int 0 < -> <false> } { 0 1 > -> <false> }
{ 1 2 > -> <false> } { -1 0 > -> <false> }
{ -1 1 > -> <false> } { min-int 0 > -> <false> }
{ min-int max-int > -> <false> } { 0 max-int > -> <false> } -->

( hayes-test )

{ 0 0 > -> <false> } { 1 1 > -> <false> } { 1 0 > -> <true> }
{ 2 1 > -> <true> } { 0 -1 > -> <true> } { 1 -1 > -> <true> }
{ 0 min-int > -> <true> } { max-int min-int > -> <true> }
{ max-int 0 > -> <true> } { 0 1 u< -> <true> }
{ 1 2 u< -> <true> } { 0 mid-uint u< -> <true> }
{ 0 max-uint u< -> <true> } { mid-uint max-uint u< -> <true> }
{ 0 0 u< -> <false> } { 1 1 u< -> <false> }
{ 1 0 u< -> <false> } { 2 1 u< -> <false> }
{ mid-uint 0 u< -> <false> } { max-uint 0 u< -> <false> }
{ max-uint mid-uint u< -> <false> } { 0 1 min -> 0 }
{ 1 2 min -> 1 } { -1 0 min -> -1 } { -1 1 min -> -1 }
{ min-int 0 min -> min-int } { min-int max-int min -> min-int }
{ 0 max-int min -> 0 } { 0 0 min -> 0 } { 1 1 min -> 1 }
{ 1 0 min -> 0 } { 2 1 min -> 1 } -->

( hayes-test )

{ 0 -1 min -> -1 } { 1 -1 min -> -1 }
{ 0 min-int min -> min-int } { max-int min-int min -> min-int }
{ max-int 0 min -> 0 } { 0 1 max -> 1 } { 1 2 max -> 2 }
{ -1 0 max -> 0 } { -1 1 max -> 1 } { min-int 0 max -> 0 }
{ min-int max-int max -> max-int } { 0 max-int max -> max-int }
{ 0 0 max -> 0 } { 1 1 max -> 1 } { 1 0 max -> 1 }
{ 2 1 max -> 2 } { 0 -1 max -> 0 } { 1 -1 max -> 1 }
{ 0 min-int max -> 0 } { max-int min-int max -> max-int }
{ max-int 0 max -> max-int }  -->

( hayes-test )

testing( stack ops)

{ 1 2 2drop -> } { 1 2 2dup -> 1 2 1 2 }
{ 1 2 3 4 2over -> 1 2 3 4 1 2 } { 1 2 3 4 2swap -> 3 4 1 2 }
{ 0 ?dup -> 0 } { 1 ?dup -> 1 1 } { -1 ?dup -> -1 -1 }
{ depth -> 0 } { 0 depth -> 0 1 } { 0 1 depth -> 0 1 2 }
{ 0 drop -> } { 1 2 drop -> 1 } { 1 dup -> 1 1 }
{ 1 2 over -> 1 2 1 } { 1 2 3 rot -> 2 3 1 }
{ 1 2 swap -> 2 1 }

testing( >r r> r@)

{ : gr1 >r r> ; -> } { : gr2 >r r@ r> drop ; -> }
{ 123 gr1 -> 123 } { 123 gr2 -> 123 }
{ 1s gr1 -> 1s }  \ return stack holds cells

-->

( hayes-test )

testing( + - 1+ 1- abs negate)

{ 0 5 + -> 5 } { 5 0 + -> 5 } { 0 -5 + -> -5 } { -5 0 + -> -5 }
{ 1 2 + -> 3 } { 1 -2 + -> -1 } { -1 2 + -> 1 }
{ -1 -2 + -> -3 } { -1 1 + -> 0 }
{ mid-uint 1 + -> mid-uint+1 } { 0 5 - -> -5 } { 5 0 - -> 5 }
{ 0 -5 - -> 5 } { -5 0 - -> -5 } { 1 2 - -> -1 }
{ 1 -2 - -> 3 } { -1 2 - -> -3 } { -1 -2 - -> 1 }
{ 0 1 - -> -1 } { mid-uint+1 1 - -> mid-uint } { 0 1+ -> 1 }
{ -1 1+ -> 0 } { 1 1+ -> 2 } { mid-uint 1+ -> mid-uint+1 }
{ 2 1- -> 1 } { 1 1- -> 0 } { 0 1- -> -1 }
{ mid-uint+1 1- -> mid-uint } { 0 negate -> 0 }
{ 1 negate -> -1 } { -1 negate -> 1 } { 2 negate -> -2 }
{ -2 negate -> 2 } { 0 abs -> 0 } { 1 abs -> 1 }
{ -1 abs -> 1 } { min-int abs -> mid-uint+1 } -->

( hayes-test )

testing( s>d * m* um*)

{ 0 s>d -> 0 0 } { 1 s>d -> 1 0 } { 2 s>d -> 2 0 }
{ -1 s>d -> -1 -1 } { -2 s>d -> -2 -1 }
{ min-int s>d -> min-int -1 } { max-int s>d -> max-int 0 }
{ 0 0 m* -> 0 s>d } { 0 1 m* -> 0 s>d } { 1 0 m* -> 0 s>d }
{ 1 2 m* -> 2 s>d } { 2 1 m* -> 2 s>d } { 3 3 m* -> 9 s>d }
{ -3 3 m* -> -9 s>d } { 3 -3 m* -> -9 s>d }
{ -3 -3 m* -> 9 s>d } { 0 min-int m* -> 0 s>d }
{ 1 min-int m* -> min-int s>d } { 2 min-int m* -> 0 1s }
{ 0 max-int m* -> 0 s>d } { 1 max-int m* -> max-int s>d }
{ 2 max-int m* -> max-int 1 lshift 0 }
{ min-int min-int m* -> 0 msb 1 rshift }
{ max-int min-int m* -> msb msb 2/ }
{ max-int max-int m* -> 1 msb 2/ invert } -->

( hayes-test )

  \ testing( Identities)

{ 0 0 * -> 0 } { 0 1 * -> 0 } { 1 0 * -> 0 } { 1 2 * -> 2 }
{ 2 1 * -> 2 } { 3 3 * -> 9 } { -3 3 * -> -9 } { 3 -3 * -> -9 }
{ -3 -3 * -> 9 }

{ mid-uint+1 1 rshift 2 * -> mid-uint+1 }
{ mid-uint+1 2 rshift 4 * -> mid-uint+1 }
{ mid-uint+1 1 rshift mid-uint+1 or 2 * -> mid-uint+1 }

{ 0 0 um* -> 0 0 } { 0 1 um* -> 0 0 } { 1 0 um* -> 0 0 }
{ 1 2 um* -> 2 0 } { 2 1 um* -> 2 0 } { 3 3 um* -> 9 0 }

{ mid-uint+1 1 rshift 2 um* -> mid-uint+1 0 }
{ mid-uint+1 2 um* -> 0 1 } { mid-uint+1 4 um* -> 0 2 }
{ 1s 2 um* -> 1s 1 lshift 1 }
{ max-uint max-uint um* -> 1 1 invert } -->

( hayes-test )

testing( fm/mod sm/rem um/mod */ */mod / /mod mod)

need fm/mod

{ 0 s>d 1 fm/mod -> 0 0 } { 1 s>d 1 fm/mod -> 0 1 }
{ 2 s>d 1 fm/mod -> 0 2 } { -1 s>d 1 fm/mod -> 0 -1 }
{ -2 s>d 1 fm/mod -> 0 -2 } { 0 s>d -1 fm/mod -> 0 0 }
{ 1 s>d -1 fm/mod -> 0 -1 } { 2 s>d -1 fm/mod -> 0 -2 }
{ -1 s>d -1 fm/mod -> 0 1 } { -2 s>d -1 fm/mod -> 0 2 }
{ 2 s>d 2 fm/mod -> 0 1 } { -1 s>d -1 fm/mod -> 0 1 }
{ -2 s>d -2 fm/mod -> 0 1 } {  7 s>d  3 fm/mod -> 1 2 }  -->

( hayes-test )

{  7 s>d -3 fm/mod -> -2 -3 } { -7 s>d  3 fm/mod -> 2 -3 }
{ -7 s>d -3 fm/mod -> -1 2 }
{ max-int s>d 1 fm/mod -> 0 max-int }
{ min-int s>d 1 fm/mod -> 0 min-int }
{ max-int s>d max-int fm/mod -> 0 1 }
{ min-int s>d min-int fm/mod -> 0 1 }
{ 1s 1 4 fm/mod -> 3 max-int }
{ 1 min-int m* 1 fm/mod -> 0 min-int }
{ 1 min-int m* min-int fm/mod -> 0 1 }
{ 2 min-int m* 2 fm/mod -> 0 min-int }
{ 2 min-int m* min-int fm/mod -> 0 2 }
{ 1 max-int m* 1 fm/mod -> 0 max-int }
{ 1 max-int m* max-int fm/mod -> 0 1 }
{ 2 max-int m* 2 fm/mod -> 0 max-int }
{ 2 max-int m* max-int fm/mod -> 0 2 } -->

( hayes-test )

{ min-int min-int m* min-int fm/mod -> 0 min-int }
{ min-int max-int m* min-int fm/mod -> 0 max-int }
{ min-int max-int m* max-int fm/mod -> 0 min-int }
{ max-int max-int m* max-int fm/mod -> 0 max-int }

{ 0 s>d 1 sm/rem -> 0 0 } { 1 s>d 1 sm/rem -> 0 1 }
{ 2 s>d 1 sm/rem -> 0 2 } { -1 s>d 1 sm/rem -> 0 -1 }
{ -2 s>d 1 sm/rem -> 0 -2 } { 0 s>d -1 sm/rem -> 0 0 }
{ 1 s>d -1 sm/rem -> 0 -1 } { 2 s>d -1 sm/rem -> 0 -2 }
{ -1 s>d -1 sm/rem -> 0 1 } { -2 s>d -1 sm/rem -> 0 2 }
{ 2 s>d 2 sm/rem -> 0 1 } { -1 s>d -1 sm/rem -> 0 1 }
{ -2 s>d -2 sm/rem -> 0 1 } {  7 s>d  3 sm/rem -> 1 2 }
{  7 s>d -3 sm/rem -> 1 -2 } { -7 s>d  3 sm/rem -> -1 -2 }
{ -7 s>d -3 sm/rem -> -1 2 }
{ max-int s>d 1 sm/rem -> 0 max-int }
{ min-int s>d 1 sm/rem -> 0 min-int } -->

( hayes-test )

{ max-int s>d max-int sm/rem -> 0 1 }
{ min-int s>d min-int sm/rem -> 0 1 }
{ 1s 1 4 sm/rem -> 3 max-int }
{ 2 min-int m* 2 sm/rem -> 0 min-int }
{ 2 min-int m* min-int sm/rem -> 0 2 }
{ 2 max-int m* 2 sm/rem -> 0 max-int }
{ 2 max-int m* max-int sm/rem -> 0 2 }
{ min-int min-int m* min-int sm/rem -> 0 min-int }
{ min-int max-int m* min-int sm/rem -> 0 max-int }
{ min-int max-int m* max-int sm/rem -> 0 min-int }
{ max-int max-int m* max-int sm/rem -> 0 max-int }
{ 0 0 1 um/mod -> 0 0 } { 1 0 1 um/mod -> 0 1 }
{ 1 0 2 um/mod -> 1 0 } { 3 0 2 um/mod -> 1 1 }
{ max-uint 2 um* 2 um/mod -> 0 max-uint }
{ max-uint 2 um* max-uint um/mod -> 0 2 } -->

( hayes-test )

{ max-uint max-uint um* max-uint um/mod -> 0 max-uint }
: iffloored
  [ -3 2 / -2 = invert ] literal if postpone \ then ;
: ifsym
  [ -3 2 / -1 = invert ] literal if postpone \ then ;

  \ The system might do either floored or symmetric division.
  \ since we have already tested `m*`, `fm/mod`, and `sm/rem`
  \ we can use them in test.

iffloored : t/mod  >r s>d r> fm/mod ;
iffloored : t/  t/mod swap drop ;
iffloored : tmod  t/mod drop ;
iffloored : t*/mod >r m* r> fm/mod ;
iffloored : t*/  t*/mod swap drop ;
ifsym  : t/mod  >r s>d r> sm/rem ;
ifsym  : t/  t/mod swap drop ;
ifsym  : tmod  t/mod drop ;
ifsym  : t*/mod >r m* r> sm/rem ;
ifsym  : t*/  t*/mod swap drop ; -->

( hayes-test )

{ 0 1 /mod -> 0 1 t/mod } { 1 1 /mod -> 1 1 t/mod }
{ 2 1 /mod -> 2 1 t/mod } { -1 1 /mod -> -1 1 t/mod }
{ -2 1 /mod -> -2 1 t/mod } { 0 -1 /mod -> 0 -1 t/mod }
{ 1 -1 /mod -> 1 -1 t/mod } { 2 -1 /mod -> 2 -1 t/mod }
{ -1 -1 /mod -> -1 -1 t/mod } { -2 -1 /mod -> -2 -1 t/mod }
{ 2 2 /mod -> 2 2 t/mod } { -1 -1 /mod -> -1 -1 t/mod }
{ -2 -2 /mod -> -2 -2 t/mod } { 7 3 /mod -> 7 3 t/mod }
{ 7 -3 /mod -> 7 -3 t/mod } { -7 3 /mod -> -7 3 t/mod }
{ -7 -3 /mod -> -7 -3 t/mod }
{ max-int 1 /mod -> max-int 1 t/mod }
{ min-int 1 /mod -> min-int 1 t/mod }
{ max-int max-int /mod -> max-int max-int t/mod }
{ min-int min-int /mod -> min-int min-int t/mod } -->

( hayes-test )

{ 0 1 / -> 0 1 t/ } { 1 1 / -> 1 1 t/ } { 2 1 / -> 2 1 t/ }
{ -1 1 / -> -1 1 t/ } { -2 1 / -> -2 1 t/ }
{ 0 -1 / -> 0 -1 t/ } { 1 -1 / -> 1 -1 t/ }
{ 2 -1 / -> 2 -1 t/ } { -1 -1 / -> -1 -1 t/ }
{ -2 -1 / -> -2 -1 t/ } { 2 2 / -> 2 2 t/ }
{ -1 -1 / -> -1 -1 t/ } { -2 -2 / -> -2 -2 t/ }
{ 7 3 / -> 7 3 t/ } { 7 -3 / -> 7 -3 t/ }
{ -7 3 / -> -7 3 t/ } { -7 -3 / -> -7 -3 t/ }
{ max-int 1 / -> max-int 1 t/ }
{ min-int 1 / -> min-int 1 t/ }
{ max-int max-int / -> max-int max-int t/ }
{ min-int min-int / -> min-int min-int t/ }

{ 0 1 mod -> 0 1 tmod } { 1 1 mod -> 1 1 tmod }
{ 2 1 mod -> 2 1 tmod } { -1 1 mod -> -1 1 tmod }
{ -2 1 mod -> -2 1 tmod } { 0 -1 mod -> 0 -1 tmod }  -->

( hayes-test )

{ 1 -1 mod -> 1 -1 tmod } { 2 -1 mod -> 2 -1 tmod }
{ -1 -1 mod -> -1 -1 tmod } { -2 -1 mod -> -2 -1 tmod }
{ 2 2 mod -> 2 2 tmod } { -1 -1 mod -> -1 -1 tmod }
{ -2 -2 mod -> -2 -2 tmod } { 7 3 mod -> 7 3 tmod }
{ 7 -3 mod -> 7 -3 tmod } { -7 3 mod -> -7 3 tmod }
{ -7 -3 mod -> -7 -3 tmod } { max-int 1 mod -> max-int 1 tmod }
{ min-int 1 mod -> min-int 1 tmod }

{ max-int max-int mod -> max-int max-int tmod }
{ min-int min-int mod -> min-int min-int tmod }

{ 0 2 1 */ -> 0 2 1 t*/ } { 1 2 1 */ -> 1 2 1 t*/ }
{ 2 2 1 */ -> 2 2 1 t*/ } { -1 2 1 */ -> -1 2 1 t*/ }
{ -2 2 1 */ -> -2 2 1 t*/ } { 0 2 -1 */ -> 0 2 -1 t*/ }
{ 1 2 -1 */ -> 1 2 -1 t*/ } { 2 2 -1 */ -> 2 2 -1 t*/ }
{ -1 2 -1 */ -> -1 2 -1 t*/ } { -2 2 -1 */ -> -2 2 -1 t*/ }
{ 2 2 2 */ -> 2 2 2 t*/ }  -->

( hayes-test )

{ -1 2 -1 */ -> -1 2 -1 t*/ } { -2 2 -2 */ -> -2 2 -2 t*/ }
{ 7 2 3 */ -> 7 2 3 t*/ } { 7 2 -3 */ -> 7 2 -3 t*/ }
{ -7 2 3 */ -> -7 2 3 t*/ } { -7 2 -3 */ -> -7 2 -3 t*/ }
{ max-int 2 max-int */ -> max-int 2 max-int t*/ }
{ min-int 2 min-int */ -> min-int 2 min-int t*/ }

{ 0 2 1 */mod -> 0 2 1 t*/mod } { 1 2 1 */mod -> 1 2 1 t*/mod }
{ 2 2 1 */mod -> 2 2 1 t*/mod }
{ -1 2 1 */mod -> -1 2 1 t*/mod }
{ -2 2 1 */mod -> -2 2 1 t*/mod }
{ 0 2 -1 */mod -> 0 2 -1 t*/mod }
{ 1 2 -1 */mod -> 1 2 -1 t*/mod }
{ 2 2 -1 */mod -> 2 2 -1 t*/mod }
{ -1 2 -1 */mod -> -1 2 -1 t*/mod }
{ -2 2 -1 */mod -> -2 2 -1 t*/mod }
{ 2 2 2 */mod -> 2 2 2 t*/mod } -->

( hayes-test )

{ -1 2 -1 */mod -> -1 2 -1 t*/mod }
{ -2 2 -2 */mod -> -2 2 -2 t*/mod }
{ 7 2 3 */mod -> 7 2 3 t*/mod }
{ 7 2 -3 */mod -> 7 2 -3 t*/mod }
{ -7 2 3 */mod -> -7 2 3 t*/mod }
{ -7 2 -3 */mod -> -7 2 -3 t*/mod }
{ max-int 2 max-int */mod -> max-int 2 max-int t*/mod }
{ min-int 2 min-int */mod -> min-int 2 min-int t*/mod }

testing( here , @ ! cell+ cells c, c@ c! chars 2@ 2! +! aligned
align allot)

here 1 allot here constant 2nda constant 1sta
{ 1sta 2nda u< -> <true> } { 1sta 1+ -> 2nda }
  \ `here` must grow with allot by one address unit

  \ missing test: negative allot

-->

( hayes-test )

here 1 , here 2 , constant 2nd constant 1st
{ 1st 2nd u< -> <true> } { 1st cell+ -> 2nd }
  \ `here` must grow with allot by one cell.

{ 1st 1 cells + -> 2nd } { 1st @ 2nd @ -> 1 2 } { 5 1st ! -> }
{ 1st @ 2nd @ -> 5 2 } { 6 2nd ! -> } { 1st @ 2nd @ -> 5 6 }
{ 1st 2@ -> 6 5 } { 2 1 1st 2! -> } { 1st 2@ -> 2 1 }
{ 1s 1st !  1st @ -> 1s }  \ can store cell-wide value

here 1 c, here 2 c, constant 2ndc constant 1stc
{ 1stc 2ndc u< -> <true> } { 1stc char+ -> 2ndc }
  \ `here` must grow with allot by one char.

{ 1stc 1 chars + -> 2ndc } { 1stc c@ 2ndc c@ -> 1 2 }
{ 3 1stc c! -> } { 1stc c@ 2ndc c@ -> 3 2 }
{ 4 2ndc c! -> } { 1stc c@ 2ndc c@ -> 3 4 }

-->

( hayes-test )

need align  need aligned

align 1 allot here align here 3 cells allot
constant a-addr  constant ua-addr
{ ua-addr aligned -> a-addr }
{  1 a-addr c!  a-addr c@ ->  1 }
{ 1234 a-addr  !  a-addr  @ -> 1234 }
{ 123 456 a-addr 2!  a-addr 2@ -> 123 456 }
{ 2 a-addr char+ c!  a-addr char+ c@ -> 2 }
{ 3 a-addr cell+ c!  a-addr cell+ c@ -> 3 }
{ 1234 a-addr cell+ !  a-addr cell+ @ -> 1234 }
{ 123 456 a-addr cell+ 2!  a-addr cell+ 2@ -> 123 456 }

-->

( hayes-test )

: bits ( x -- u )
  0 swap begin   dup
         while   dup msb and if  >r 1+ r>  then  2*
         repeat  drop ;

{ 1 chars 1 < -> <false> } { 1 chars 1 cells > -> <false> }
  \ Characters >= 1 au, <= size of cell, >= 8 bits.
  \ XXX TODO -- How to find number of bits?

{ 1 cells 1 < -> <false> } { 1 cells 1 chars mod -> 0 }
{ 1s bits 10 < -> <false> }
  \ Cells >= 1 au, integral multiple of char size, >= 16 bits.

{ 0 1st ! -> } { 1 1st +! -> } { 1st @ -> 1 }
{ -1 1st +! 1st @ -> 0 }

testing( char [char] [ ] bl s") need char  need [char]

{ bl -> 20 } { char X -> 58 } { char HELLO -> 48 }
{ : gc1 [char] X ; -> } { : gc2 [char] HELLO ; -> }
{ gc1 -> 58 } { gc2 -> 48 } { : gc3 [ gc1 ] literal ; -> }
{ gc3 -> 58 } { : gc4 s" XY" ; -> } { gc4 swap drop -> 2 }
{ gc4 drop dup c@ swap char+ c@ -> 58 59 } -->

( hayes-test )

testing( ' ['] find execute immediate count literal postpone
state)

need find

{ : gt1 123 ; -> } { ' gt1 execute -> 123 }
{ : gt2 ['] gt1 ; immediate -> } { gt2 execute -> 123 }
here 3 c, char G c, char T c, char 1 c, constant gt1string
here 3 c, char G c, char T c, char 2 c, constant gt2string
{ gt1string find -> ' gt1 -1 } { gt2string find -> ' gt2 1 }
  \ how to search for non-existent word?
{ : gt3 gt2 literal ; -> } { gt3 -> ' gt1 }
{ gt1string count -> gt1string char+ 3 }
{ : gt4 postpone gt1 ; immediate -> } { : gt5 gt4 ; -> }
{ gt5 -> 123 } { : gt6 345 ; immediate -> }
{ : gt7 postpone gt6 ; -> } { gt7 -> 345 }
{ : gt8 state @ ; immediate -> } { gt8 -> 0 }
{ : gt9 gt8 literal ; -> } { gt9 0= -> <false> } -->

( hayes-test )

testing( if else then)

{ : gi1 if 123 then ; -> } { : gi2 if 123 else 234 then ; -> }
{ 0 gi1 -> } { 1 gi1 -> 123 } { -1 gi1 -> 123 }
{ 0 gi2 -> 234 } { 1 gi2 -> 123 } { -1 gi1 -> 123 }

testing( begin while repeat until recurse)

{ : gi3 begin dup 5 < while dup 1+ repeat ; -> }
{ 0 gi3 -> 0 1 2 3 4 5 }
{ 4 gi3 -> 4 5 } { 5 gi3 -> 5 } { 6 gi3 -> 6 }

{ : gi4 begin dup 1+ dup 5 > until ; -> }
{ 3 gi4 -> 3 4 5 6 } { 5 gi4 -> 5 6 } { 6 gi4 -> 6 7 }

{ : gi5 begin dup 2 >
    while dup 5 < while dup 1+ repeat 123 else 345 then ; -> }

{ 1 gi5 -> 1 345 }      { 2 gi5 -> 2 345 }
{ 3 gi5 -> 3 4 5 123 }  { 4 gi5 -> 4 5 123 }
{ 5 gi5 -> 5 123 }  -->

( hayes-test )

testing( recurse) need recurse

{ : gi6 ( n -- 0,1,..n ) dup if dup >r 1- recurse r> then ;
-> }

{ 0 gi6 -> 0 } { 1 gi6 -> 0 1 } { 2 gi6 -> 0 1 2 }
{ 3 gi6 -> 0 1 2 3 } { 4 gi6 -> 0 1 2 3 4 }

testing( do loop +loop i j unloop leave exit)  need j

{ : gd1 do i loop ; -> } { 4 1 gd1 -> 1 2 3 }
{ 2 -1 gd1 -> -1 0 1 } { mid-uint+1 mid-uint gd1 -> mid-uint }

{ : gd2 do i -1 +loop ; -> } { 1 4 gd2 -> 4 3 2 1 }
{ -1 2 gd2 -> 2 1 0 -1 }
{ mid-uint mid-uint+1 gd2 -> mid-uint+1 mid-uint }

{ : gd3 do 1 0 do j loop loop ; -> }
{ 4 1 gd3 -> 1 2 3 } { 2 -1 gd3 -> -1 0 1 }
{ mid-uint+1 mid-uint gd3 -> mid-uint } -->

( hayes-test )

{ : gd4 do 1 0 do j loop -1 +loop ; -> }
{ 1 4 gd4 -> 4 3 2 1 }
{ -1 2 gd4 -> 2 1 0 -1 }
{ mid-uint mid-uint+1 gd4 -> mid-uint+1 mid-uint }

{ : gd5 123 swap 0 do i 4 > if drop 234 leave then loop ; -> }
{ 1 gd5 -> 123 } { 5 gd5 -> 123 } { 6 gd5 -> 234 }

{ : gd6
    0 swap 0 do
    i 1+ 0 do i j + 3 = if i unloop i unloop exit then 1+ loop
    loop ; -> }
  \ Pat: {0 0},{0 0}{1 0}{1 1},{0 0}{1 0}{1 1}{2 0}{2 1}{2 2}.

{ 1 gd6 -> 1 }  { 2 gd6 -> 3 }  { 3 gd6 -> 4 1 2 } -->

( hayes-test )

testing( : ; constant variable create does> >body)

need >body

{ 123 constant x123 -> } { x123 -> 123 }
{ : equ constant ; -> } { x123 equ y123 -> } { y123 -> 123 }

{ variable v1 -> } { 123 v1 ! -> } { v1 @ -> 123 }

{ : nop : postpone ; ; -> }
{ nop nop1 nop nop2 -> } { nop1 -> } { nop2 -> }

{ : does1 does> @ 1 + ; -> } { : does2 does> @ 2 + ; -> }
{ create cr1 -> } { cr1 -> here }
{ ' cr1 >body -> here }
{ 1 , -> } { cr1 @ -> 1 } { does1 -> }
{ cr1 -> 2 } { does2 -> } { cr1 -> 3 }

{ : weird: create does> 1 + does> 2 + ; -> }
{ weird: w1 -> } { ' w1 >body -> here }
{ w1 -> here 1 + } { w1 -> here 2 + }  -->

( hayes-test )

testing( evaluate)

need evaluate

: ge1 s" 123" ; immediate   : ge2 s" 123 1+" ; immediate
: ge3 s" : ge4 345 ;" ;     : ge5 evaluate ; immediate

{ ge1 evaluate -> 123 } { ge2 evaluate -> 124 }
{ ge3 evaluate -> } { ge4 -> 345 }
  \ test `evaluate` in interpretation state

{ : ge6 ge1 ge5 ; -> } { ge6 -> 123 }
{ : ge7 ge2 ge5 ; -> } { ge7 -> 124 }
  \ test `evaluate` in compilation state

testing( source >in word)

: gs1 s" SOURCE" 2dup evaluate >r swap >r = r> r> = ;
{ gs1 -> <true> <true> }

variable scans  2 scans !
: rescan?  -1 scans +! scans @ if 0 >in ! then ;

-->

( hayes-test )

{ 345 rescan?  -> 345 345 }
  \ Note: this test must be the first code in its block.

: gs2  5 scans ! s" 123 RESCAN?" evaluate ;

-->

( hayes-test )

{ gs2 -> 123 123 123 123 123 }
  \ XXX REMARK: this test must be the first code in its block.

need word

: gs3 word count swap c@ ;
{ bl gs3 HELLO -> 5 char H }
{ char " gs3 GOODBYE" -> 7 char G }

need +thru need continued  1 2 +thru  blk @ 3 + continued
  \ Load the two following blocks and then continue loading
  \ after them.  This is needed, because `-->` can not be used
  \ in those blocks.

( hayes-test )

\ line 1
\ line 2
\ line 3
\ line 4
\ line 5
\ line 6
\ line 7
\ line 8
\ line 9
\ line 10
\ line 11
\ line 12
\ line 13
\ line 14

  \ Note: The following test must start at the end of the last
  \ line of the block (line 15):

                                                       { bl gs3

( hayes-test )

drop -> 0 }  \ blank line return zero-length string
  \ Note: This line must be the first code of the block,
  \ because the first part of the test must be at the end of
  \ the last line of a block.

: gs4 source >in ! drop ;

{ gs4 123 456
  \ Note: This line must be the last code of the block.

( hayes-test )

-> }
  \ Note: This line must be the first code of the block,
  \ because the first part of the test must be at the end of a
  \ block.

testing( <# # #s #> hold sign base >number hex decimal)

: s=  \ ( addr1 c1 addr2 c2 -- t/f ) compare two strings.
  >r swap r@ = if  \ make sure strings have same length
  r> ?dup if  \ if non-empty strings
    0 do  over c@ over c@ - if  2drop <false> unloop exit  then
          swap char+ swap char+  loop
  then  2drop <true>  \ if we get here, strings match
  else  r> drop 2drop <false>  then ; \ lengths mismatch

: gp1  <# 41 hold 42 hold 0 0 #> s" BA" s= ; { gp1 -> <true> }

: gp2  <# -1 sign 0 sign -1 sign 0 0 #> s" --" s= ;
{ gp2 -> <true> }

: gp3  <# 1 0 # # #> s" 01" s= ; { gp3 -> <true> }

: gp4  <# 1 0 #s #> s" 1" s= ; { gp4 -> <true> } -->

( hayes-test )

24 constant max-base  \ base 2 .. 36
: count-bits
  0 0 invert begin dup while >r 1+ r> 2* repeat drop ;

count-bits 2* constant #bits-ud  \ number of bits in ud

: gp5
  base @ <true>
  max-base 1+ 2 do  \ for each possible base
    i base !  \ tbd: assumes base works
    i 0 <# #s #> s" 10" s= and
  loop  swap base ! ;  { gp5 -> <true> } -->

( hayes-test )

: gp6
  base @ >r  2 base !
  max-uint max-uint <# #s #>  \ maximum ud to binary
  r> base !  \ s: c-addr u
  dup #bits-ud = swap 0 do  \ s: c-addr flag
                          over c@ [char] 1 = and  \ all ones
                          >r char+ r>
                        loop swap drop ;  { gp6 -> <true> }

: gp7
  base @ >r  max-base base !  <true>
  a 0 do  i 0 <# #s #>  1 = swap c@ i 30 + = and and  loop
  max-base a do
    i 0 <# #s #>  1 = swap c@ 41 i a - + = and and
  loop  r> base ! ;  { gp7 -> <true> }  -->

( hayes-test )

  \ `>number` tests

create gn-buf 0 c,
: gn-string  gn-buf 1 ;
: gn-consumed  gn-buf char+ 0 ;
: gn'  [char] ' word char+ c@ gn-buf c!  gn-string ;

{ 0 0 gn' 0' >number -> 0 0 gn-consumed }
{ 0 0 gn' 1' >number -> 1 0 gn-consumed }
{ 1 0 gn' 1' >number -> base @ 1+ 0 gn-consumed }
{ 0 0 gn' -' >number -> 0 0 gn-string }
  \ Should fail to convert these.

{ 0 0 gn' +' >number -> 0 0 gn-string }
{ 0 0 gn' .' >number -> 0 0 gn-string }

-->

( hayes-test )

: >number-based
  base @ >r base ! >number r> base ! ;

{ 0 0 gn' 2' 10 >number-based -> 2 0 gn-consumed }
{ 0 0 gn' 2'  2 >number-based -> 0 0 gn-string }
{ 0 0 gn' f' 10 >number-based -> f 0 gn-consumed }
{ 0 0 gn' g' 10 >number-based -> 0 0 gn-string }
{ 0 0 gn' g' max-base >number-based -> 10 0 gn-consumed }
{ 0 0 gn' z' max-base >number-based -> 23 0 gn-consumed }

-->

( hayes-test )

: gn1  ( ud base -- ud' len )
  base @ >r base !
  <# #s #>
  0 0 2swap >number swap drop  \ return length only
  r> base ! ;
  \ ud should equal ud' and len should be zero.
{ 0 0 2 gn1 -> 0 0 0 }
{ max-uint 0 2 gn1 -> max-uint 0 0 }
{ max-uint dup 2 gn1 -> max-uint dup 0 }
{ 0 0 max-base gn1 -> 0 0 0 }
{ max-uint 0 max-base gn1 -> max-uint 0 0 }
{ max-uint dup max-base gn1 -> max-uint dup 0 }

: gn2  \ ( -- 16 10 )
  base @ >r  hex base @  decimal base @  r> base ! ;
{ gn2 -> 10 a } -->

( hayes-test )

testing( fill move)

create fbuf 00 c, 00 c, 00 c,
create sbuf 12 c, 34 c, 56 c,
: seebuf fbuf c@  fbuf char+ c@  fbuf char+ char+ c@ ;

{ fbuf 0 20 fill -> } { seebuf -> 00 00 00 }

{ fbuf 1 20 fill -> } { seebuf -> 20 00 00 }

{ fbuf 3 20 fill -> } { seebuf -> 20 20 20 }

{ fbuf fbuf 3 chars move -> } { seebuf -> 20 20 20 }
  \ Bizarre special case.

{ sbuf fbuf 0 chars move -> } { seebuf -> 20 20 20 }

{ sbuf fbuf 1 chars move -> } { seebuf -> 12 20 20 }

{ sbuf fbuf 3 chars move -> } { seebuf -> 12 34 56 }

{ fbuf fbuf char+ 2 chars move -> } { seebuf -> 12 12 34 }

{ fbuf char+ fbuf 2 chars move -> } { seebuf -> 12 34 34 } -->

( hayes-test )

testing( . ." cr emit space spaces type u.)

: output-test
  ." You should see the standard graphic characters:" cr
  41 bl do i emit loop cr 61 41 do i emit loop cr
  7F 61 do i emit loop cr
  ." You should see 0-9 separated by a space:" cr
  9 1+ 0 do i . loop cr
  ." You should see 0-9 (with no spaces):" cr
  [char] 9 1+ [char] 0 do i 0 spaces emit loop cr
  ." You should see A-G separated by a space:" cr
  [char] G 1+ [char] A do i emit space loop cr
  ." You should see 0-5 separated by two spaces:" cr
  5 1+ 0 do i [char] 0 + emit 2 spaces loop cr

-->

( hayes-test )

  ." You should see two separate lines:" cr
  s" line 1" type cr s" line 2" type cr
  ." You should see the number ranges" cr
  ." of signed and unsigned numbers:" cr
  ."   signed: " min-int . max-int . cr
  ." unsigned: " 0 u. max-uint u. cr  ;  { output-test -> }

testing( accept)

create abuf 80 chars allot

: accept-test
  cr ." Please type up to 80 characters:" cr  abuf 80 accept
  cr ." Received: " [char] " emit
  abuf swap type [char] " emit cr  ;  { accept-test -> }

testing( dictionary search rules)

{ : gdx  123 ; : gdx  gdx 234 ; -> } { gdx -> 123 234 }

decimal cr .( Test passed) cr

  \ vim: filetype=soloforth
  \ meta.test.misc.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605170052

  \ -----------------------------------------------------------
  \ Description

  \ Development tests.

  \ -----------------------------------------------------------
  \ Author

  \ Marcos Cruz (programandala.net), 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ Latest changes

  \ 2016-04-24: Remove `[char]` and `char`, which have been
  \ moved to the library.
  \
  \ 2016-04-28: Move the tests of `type-center`, `type-left`
  \ and `type-right` from the module "printing.type.fsb".
  \ Add `?ccase-test`, `ccase0-test`. Add `jk-test`.
  \
  \ 2016-05-01: Add `color-test`.
  \
  \ 2016-05-05: Add `search-test`.
  \
  \ 2016-05-07: Add `need-test`, `?(-test`.
  \
  \ 2016-05-17: Need `>body`, which has been moved to the
  \ library.

( alias-test synonym-test )

  \ 2015-11-24

need alias need synonym

' literal alias literal-a
' border alias border-a
' if alias if-a

synonym border-s border
synonym literal-s literal
synonym if-s if

  \ XXX TMP -- alternative `synonym` that uses `alias`
synonym2 border-s2 border
synonym2 literal-s2 literal
synonym2 if-s2 if

  \ : ifa if-a ." yes" then ;   \ "then" error #-4
  \ : ifs if-s ." yes" then ;   \ ok
  \ : ifs2 if-s2 ." yes" then ;   \ "then" error #-4
  \
  \ 1 literal     \ error -14 \ ok
  \ 1 literal-a   \ no error
  \ 1 literal-s   \ error -14 \ ok
  \ 1 literal-s2  \ no error
  \
  \ : zx [ 1 ] literal ;      \ ok
  \ : zx [ 1 ] literal-a ;    \ error #-264
  \ : zx [ 1 ] literal-s ;    \ no error \ ok
  \ : zx [ 1 ] literal-s2 ;   \ error #-264

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump  need >body

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test >body 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump  need >body

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test >body dup here swap - dump

( {if-test {do-test )

  \ 2015-11-11

: test2  ( n -- )
  {do   dup 5 <   do> ." <5" cr 1+
  |do|  dup 10 <  do> ." <10" cr 1+
  do} drop  ;

: test1  ( n1 n2 -- )
  {if   2dup > if> ." >" cr
  |if|  2dup < if> ." <" cr
  if}  ;

( options[-test )

: o1 ." option 1" ;  : o2 ." option 2" ;  : o3 ." option 3" ;

: test  ( c -- )
  options[
    'a' option o1  'b' option o2  'c' option o3
  ]options  ." end of test" cr   ;

: retest  ( -- )  'a' test ." end of retest" cr  ;

: o0 ." default" ;

: testd  ( c -- )
  options[
    'a' option o1  'b' option o2  'c' option o3
    default-option o0
  ]options  ;

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( exception-test )

  \ Credit:
  \
  \ Code from MPE Forth for TiniARM User Manual.

: could-fail  ( -- c )
  key dup 'q' =
  if  -1 throw  then  ;

: do-it  ( a b -- c )
  2drop could-fail  ;

: try-it  ( -- )
  1 2 ['] do-it catch
  if    ( x1 x2 )  2drop ." There was an exception" cr
  else  ." The character was " emit cr then  ;

: retry-it  ( -- )
  begin   1 2 ['] do-it catch
  while   ( x1 x2 ) 2drop ." Exception, keep trying" cr
  repeat  ( c )
  ." The character was " emit cr  ;

( err>ord )

  \ XXX TMP -- `err>ord` tests `error>ordinal`

: err>ord  ( -- )
  91 1 do  i . i error>ordinal ."  -> " . cr  loop
  286 256 do  i . i error>ordinal ."  -> " . cr  loop
  1025 1000 do  i . i error>ordinal ."  -> " . cr  loop ;

( type-fields-test )

need type-left  need type-center  need type-right

s" La Mancha" 2constant text

: ruler  ( -- )  home '-' 32 emits home  ;

: ready  ( -- )
  0 1 at-xy ." Press any key to continue"
  key drop ruler  ;

-->

( type-fields-test )

: test  ( -- )  page

  ready text text nip type-left
  ready text 32 type-left
  ready text 5 type-left

  ready text text nip type-center
  ready text 32 type-center
  ready text 5 type-center

  ready text text nip type-right
  ready text 32 type-right
  ready text 5 type-right  ;

: tc  ( ca len1 len2 -- )
  2dup <=> cells type-center-cases + @ >name .name  ;

: tr  ( ca len1 len2 -- )
  2dup <=> cells type-right-cases + @ >name .name  ;

( ?ccase-test ccase0-test )

need ?ccase  need ccase0

: .a     ( -- )  ." Letter A"  ;
: .b     ( -- )  ." Letter B"  ;
: .c     ( -- )  ." Letter C"  ;
: .nope  ( -- )  ." Nope!"  ;
: .end   ( -- )  ."  The End" cr  ;

: ?letter  ( c -- )
  cr ." ?letter... " key drop
  s" abc" ?ccase  .a .b .c  end?ccase  .end  ;

'a' ?letter  'b' ?letter  'c' ?letter  'x' ?letter

: letter0  ( c -- )
  cr ." letter0... " key drop
  s" abc" ccase0 .nope  .a .b .c  endccase0  .end  ;

'a' letter0  'b' letter0  'c' letter0  'x' letter0

( ccase-test )

need ccase

: .a     ( -- )  ." Letter A"  ;
: .b     ( -- )  ." Letter B"  ;
: .c     ( -- )  ." Letter C"  ;
: .nope  ( -- )  ." Nope!"  ;
: .end   ( -- )  ."  The End" cr  ;

: letter  ( c -- )
  cr ." letter... " key drop
  s" abc" ccase  .a .b .c  .nope  endccase  .end  ;

'a' letter  'b' letter  'c' letter  'x' letter

( jk-test )

need j  need k

: jk-test  ( -- )
  3 0 do
    13 10 do
      23 20 do
        k . j . i . cr
      loop
    loop
  loop  ;

cr jk-test

( color-test )

  \ 2016-05-01

need color  need permcolor

: c?  ( ca -- ) c@ .  ;

: .color  ( -- )
  cr ." os-attr-t " os-attr-t c?
  cr ." os-mask-t " os-mask-t c?
  cr ." os-attr-p " os-attr-p c?
  cr ." os-mask-p " os-mask-p c?  ;

( search-test )

  \ 2016-05-05

  \ Test the bug recently discovered in the code of `search`
  \ that was adapted from DZX-Forth.

256 constant /long-string
create long-string /long-string allot

: -long-string  ( -- )  long-string /long-string blank  ;
  \ Blank the long string.

s"  zx " 2constant substring

: place-substring  ( n -- )
  -long-string substring rot long-string + 1- swap cmove  ;
  \ Place the substring at offset _n_ of the long string.

: search-at  ( n -- )
  dup place-substring long-string swap substring search
  .s drop 2drop  ;
  \ Search the first _n_ characters of the long string for the
  \ substring, which is placed at offset _n_.

: run  ( -- )
  cr ." Search at 128:" 128 search-at
  cr ." Search at 64:" 64 search-at
  cr ." Search at 32:" 32 search-at  ;

  \ XXX NOTE: In fact, the substring is found at any position.

( foo3 foo4 )

  \ 2016-05-07

cr .( foo3)
cr .( foo4)

( need-test foo1 foo2 )

  \ 2016-05-07

need foo3 need [if]

[needed] foo1 [if] need foo4
cr .( foo1) exit [then]

cr .( foo2)

( ?(-test )

  \ 2016-05-07

need ?(

0 dup ?(  create zx1a  create zx1b ?)
1 ?(

\ nope
nope

?) ?(  : zx1c
 ." zx1c"
 ; : zx1d
 ; ?)

( lineload-test )

  \ To test `lineload`:
  \ Do `n locate lineload-test lineload` where "n" is the line
  \ number of this block.

  .( line 1 ) cr
  .( line 2 ) cr
  .( line 3 ) cr
  .( line 4 ) cr
  .( line 5 ) cr
  .( line 6 ) cr
  .( line 7 ) cr
  .( line 8 ) cr
  .( line 9 ) cr
  .( line 10 ) cr
  .( line 11 ) cr
  .( line 12 ) cr
  .( line 13 ) cr
  .( line 14 ) cr
  .( line 15 ) cr

( load-section-test )

  \ To test `load-section`:
  \ Do `load-section load-section-test`.

  .( section line 1 ) cr  need [if]
  .( section line 2 ) cr
  .( section line 3 ) cr
  .( section line 4 ) cr
  .( section line 5 ) cr
  .( section line 6 ) cr
  .( section line 7 ) cr
  .( section line 8 ) cr
  .( section line 9 ) cr
  .( section line 10 ) cr
  .( section line 11 ) cr
  .( section line 12 ) cr
  .( section line 13 ) cr
  0 [if]  .( section line 14 NOT! ) cr
  .( section line 15 NOT! ) cr

.( section line 16 NOT! ) cr

  \ To test `load-section`:
  \ Do `load-section load-section-test`.

  .( section line 17 NOT! ) cr [else]
  .( section line 18 ) cr
  .( section line 19 ) cr
  .( section line 20 ) cr [then]
  .( section line 21 ) cr
  .( section line 22 ) cr
  .( section line 23 ) cr
  .( section line 24 ) cr
  .( section line 25 ) cr
  .( section line 26 ) cr
end-section
  .( End of section) cr
.( block x line 0)
  .( block x line 1 ) cr
  .( block x line 2 ) cr
  .( block x line 3 ) cr
  .( block x line 4 ) cr
  .( block x line 5 ) cr
  .( block x line 6 ) cr
  .( block x line 7 ) cr
  .( block x line 8 ) cr
  .( block x line 9 ) cr
  .( block x line 10 ) cr
  .( block x line 11 ) cr
  .( block x line 12 ) cr
  .( block x line 13 ) cr
  .( block x line 14 ) cr
  .( block x line 15 ) cr
.( block x+1 line 0)
  .( block x+1 line 1 ) cr
  .( block x+1 line 2 ) cr
  .( block x+1 line 3 ) cr
  .( block x+1 line 4 ) cr
  .( block x+1 line 5 ) cr
  .( block x+1 line 6 ) cr
  .( block x+1 line 7 ) cr
  .( block x+1 line 8 ) cr
  .( block x+1 line 9 ) cr
  .( block x+1 line 10 ) cr
  .( block x+1 line 11 ) cr
  .( block x+1 line 12 ) cr
  .( block x+1 line 13 ) cr
  .( block x+1 line 14 ) cr
  .( block x+1 line 15 ) cr

( XXX TMP -- block for temporary tries)

need thru
blk @ 1+ blk @ 2+ thru

( XXX TMP -- block for temporary tries)

: hello  ( -- )

  ;

  \ vim: filetype=soloforth
  \ meta.tester.hayes.fsb
  \
  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Last modified: 201605100125

  \ -----------------------------------------------------------
  \ Description

  \ Development tests.

  \ -----------------------------------------------------------
  \ Authors

  \ John Hayes S1I, 1995-11-27.

  \ Marcos Cruz (programandala.net) adapted it to Solo Forth,
  \ 2015, 2016.

  \ -----------------------------------------------------------
  \ License

  \ Original version:

  \ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS
  \ LABORATORY MAY BE DISTRIBUTED FREELY AS LONG AS THIS
  \ COPYRIGHT NOTICE REMAINS.  VERSION 1.1

  \ This version:

  \ You may do whatever you want with this work, so long as you
  \ retain every copyright, credit and authorship notice, and
  \ this license.  There is no warranty.

  \ -----------------------------------------------------------
  \ History

  \ 2016-05-09: First version.

( hayes-tester )

need where

variable verbose  verbose off
  \ Set this flag to true for more verbose output;
  \ this may allow you to tell which test caused your system to
  \ hang.

: testing(  ( "ccc<paren>" -- )
  verbose @ if    cr ." Testing " postpone .(  exit  then
            postpone (  ;
  \ Talking comment.

: empty-stack  ( i*x -- )
  depth ?dup if  dup 0< if    negate 0 do  0  loop
                        else  0 do  drop  loop  then  then  ;
  \ Empty stack. Handle underflowed stack too.

: test-error  ( -- )
  cr ." Use WHERE to see the error line." empty-stack  abort  ;
  \ Complete an error message and abort.

variable actual-depth  \ stack record
create actual-results $20 cells allot

: {  ( -- )  ;  \ syntactic sugar.

-->

( hayes-tester )

: ->  ( i*x -- )
  depth dup actual-depth !  \ record depth
  ?dup if  0 do actual-results i cells + ! loop  then  ;
  \ Record depth and content of stack.

: }  ( ... -- )
  depth actual-depth @ = if  \ depths match
    depth ?dup if  \ there is something on the stack
      0 do  \ for each stack item
        actual-results i cells + @
          \ compare actual with expected
        <> if  cr ." Incorrect result" test-error leave  then
      loop
    then
  else  cr ." Wrong number of results:"
        cr ." Expected=" depth . cr ." Actual=" actual-depth ?
        test-error
  then  ;
  \ Compare stack (expected) contents with saved (actual)
  \ contents.

  \ vim: filetype=soloforth
