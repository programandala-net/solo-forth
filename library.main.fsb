( Solo Forth library )

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

  \ This file is the library of Solo Forth.

  \ XXX UNDER DEVELOPMENT

\ Last modified: 201512040307

  \ ------------------------------------------------------------
  \ Acknowledgements

  \ See the file
  \ <AKNOWLEDGMENTS.adoc>

  \ ------------------------------------------------------------
  \ License

\ You may do whatever you want with this work, so long as you
\ retain all copyright notices, all credit notices, and this
\ license in all files of all redistributed copies and derived
\ works. There is no warranty.

  \ ------------------------------------------------------------
  \ History

  \ See
  \ http://programandala.net/en.program.solo_forth.history.html

( ) \ scr 1 -- testing load block

  \ XXX FIXME

2 load need [if]

0 [if]

code zx1  jpnext  end-code
: hola1 ." hola" ;

[then]

1 [if]

code zx2  jpnext  end-code
: hola2 ." hola" ;

[then]

  \ }}} =======================================================
  \ Need {{{

  \ This section contains `need` and all related words that

( contains delimited located )

  \ This block must be at a fixed location.

  \ XXX TMP
  \ XXX INFORMER
  \ : contains  ( ca1 len1 ca2 len2 -- f )  2dup cr type ." in"
  \ 2over -trailing cr type ." ?" cr .s key drop search nip nip ;

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does the string ca1 len1 contains the string ca2 len2?
  \
  \ }doc


variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited   ( ca1 len1 -- ca2 len2 )
  \
  \ Add a leading space and trailing space to the string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
    contains if  2drop i unloop exit  then
    \ break-key? ?exhaust
    \ XXX TODO -- `break-key?` is not in the kernel
  loop  2drop false  ;

  \ doc{
  \
  \ located  ( ca len -- block | false )
  \
  \ Locate the first block whose header contains the string
  \ _ca len_ (surrounded by spaces), and return its number. If
  \ not found, return _false_.
  \ The search is case-sensitive.
  \
  \ }doc

-->

( ?located locate from reneeded reneed )

: ?located  ( block | 0 -- )  dup 0= #-268 ?throw  ;

  \ doc{
  \
  \ ?located ( f -- )
  \
  \ If f is zero, throw an exception -268.
  \
  \ }doc

: locate  ( "name" -- block | false )
  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- block | false )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return _false_.
  \ The search is case-sensitive.
  \
  \ }doc

: from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268.
  \
  \ This word is intended to prevent undesired matches clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker. Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures== need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

: reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string
  \ _ca len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268.
  \
  \ }doc

: reneed  ( "name" -- )  parse-name save-string reneeded  ;

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and load it.
  \
  \ }doc

-->

( needed-word [needed] [unneeded] needed need )

2variable needed-word

  \ XXX TODO -- make `[needed]` and `[unneeded]` optional.

: [needed]  ( "name" -- wf )
  parse-name needed-word 2@ 2dup or
  if  compare 0=  exit  then  2drop 2drop true   ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- wf )
  \
  \ Is "name" the needed word specified by the last execution
  \ of `need` or `needed`?
  \
  \ }doc

: [unneeded]  ( "name" -- wf )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- wf )
  \
  \ Is "name" different than the needed word specified by the
  \ last execution of `need` or `needed`?
  \
  \ }doc

: needed  ( ca len -- )

  \ XXX OLD
  \
  \ XXX FIXME usually the final check fails because the saved
  \ string has been overwritten in the circular string buffer.
  \ the only solution is to store the string apart, in an ad
  \ hoc zone.

  \ 2dup undefined?
  \   if  2dup reneeded  then
  \ 2dup undefined? warnings @ and
  \   if  type 28 warning exit  then  2drop  ;

  needed-word 2@ 2>r
  -trailing -leading save-string 2dup needed-word 2!
  2dup undefined?
  if  reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header
  \ (surrounded by spaces), and load it.
  \
  \ }doc

: need  ( "name" -- )  parse-name needed  ;

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.
  \
  \ }doc

blk @ 1+ dup default-first-locatable !  first-locatable !

  \ }}} =======================================================
  \ Exceptions {{{

( abort" )

  \ Credits:
  \ Code adapted from DZX-Forth.

  \ XXX TODO use `error`, by modifying `throw`

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only

( error>ordinal error>line )

: error>ordinal  ( -n1 -- +n2 )
  \ Convert an error code to its ordinal position in the
  \ library.
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146

  \ XXX TODO  add OS codes

  abs
  dup 256 < ?exit
  dup 1000 < if  [ 255 091 - ] literal - exit  then
  [ 1000 286 - 255 091 - + ] literal -   ;

: error>line  ( n1 -- n2 )
  error>ordinal dup >r
  begin
    dup dup 16 / - r@ <>  while  1+
  repeat  rdrop  ;

\ msg-scr (.throw) \

need error>line  need .line

variable msg-scr
s" Standard error codes" locate msg-scr !
  \ XXX TODO rename!

  \ doc{
  \
  \ msg-scr  ( -- a )
  \
  \ Variable that holds the block that holds the error
  \ messages.
  \
  \ }doc

: (.throw)  ( n -- )
  msg-scr @
  if  error>line msg-scr @ .line space  else  .throw#  then  ;

' (.throw) ' .throw defer!

  \ doc{
  \
  \ (.throw)  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`:
  \ Print the text of throw error _n_.  The variable `msg-scr`
  \ contains the number of the first block where messages are
  \ hold. If it contains zero, only the error number is printer.
  \
  \ }doc

( ?compiling ?executing )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc

  \ }}} =======================================================
  \ Parsing {{{

( parse-line )  \ ==parsing==

  \ XXX OLD -- 2015-09-13: moved to kernel
  \ : source  ( -- a len )  \ Forth-94
  \   blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

need /string

: parse-line  ( "text<eol>" -- ca len )
  source span @ min c/l min  >in @ span @ min /string
  dup >in +! save-string  ;

  \ doc{
  \
  \ parse-line  ( "text<eol>" -- ca len )
  \
  \ Get the text string until the end of line.  Note: this is a
  \ factor of the editor's `text`.
  \
  \ }doc

( evaluate )

  \ XXX UNDER DEVELOPMENT

  \ XXX Gforth:
: execute-parsing  ( ca len cfa -- )
  >in @ >r >in off
  source >r >r ;

: evaluate  ( ca len -- )  ['] interpret execute-parsing  ;

( parse-char )

: parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ;
  \ Parse the next char in the input stream and return its
  \ code.

( word )

  \ Credits:
  \ Code from Z88 CamelForth.

: word  ( c "<c...>text<c>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -                      ( ca' len )
  here place  here            ( ca )
  bl over count + c!  ;       \ append trailing blank

  \  doc{
  \
  \  word  ( c "<c...>text<c>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Standard: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( defined? )

: defined?  ( ca len -- wf )  undefined? 0=  ;

  \ }}} =======================================================
  \ Data stack {{{

( -rot )  \ ==datastack==

  \ Credits:
  \ Code adapted from Afera.

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,      \ pop hl / pop de
  E3 c,            \ ex (sp),hl
  EB c,            \ ex de,hl
  C3 c, pushhlde , \ jp pushhlde

  end-code

( 2nip )

  \ Credits:
  \ Code from Afera; original code from DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

( roll )

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

  \ Credits:
  \ Code adapted from DZX-Forth.

need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp
    \ push bc
    \ ld c,e
    \ ld b,d
    \ ld e,l
    \ ld d,h

    \ ld a,b
    \ or c
  bc tstp
    \ jp z,roll.end
  0000 jpz |mark 0 unresolved !

  hl decp  hl decp  lddr
    \ dec hl
    \ dec hl
    \ lddr

    \ roll.end:
  0 unresolved @ >resolve
  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl

  jpnext

  end-code

( 3drop 4drop )

code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

( 2rot )

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

( swapped )

  \ Credits:
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

  \ }}} =======================================================
  \ Return stack {{{

( n>r )  \ ==returnstack==

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  pushhl jp
  end-code

need n>r

( rdepth r'@ )

  \ Credits:
  \ `rdepth` from Afera.

[unneeded] rdepth
?\ : rdepth  ( -- n )  rp@ rp0 @ - -2 /  ;

  \ Credits:
  \ `r'@` from Wil Baden.

[unneeded] r'@ dup
?\ : r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
?\   r> 2r@ drop swap >r  ;

  \ }}} =======================================================
  \ User variables {{{

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

: uallot ( n -- )  udp @ swap udp +!  ;
  \ XXX from Gforth

: user  ( "name" -- )  create cell uallot , does> @ up @ +  ;

: user  ( "name" -- )  create cell uallot c, does> c@ up @ +  ;


  \ }}} =======================================================
  \ Screen modes {{{

( columns rows )  \ ==screenmodes==

need value

32 value columns  24 value rows

( mode32 )

need columns  need rows

[defined] sys-chans ?\ 23631 constant sys-chans
  \ System variable that holds the address of the channels.

[defined] sys-chars ?\ 23606 constant sys-chars
  \ System variable that holds the address of the font.

: mode-output  ( a -- )
  \ Associate the output
  \ routine at _a_ to the system channels "K", "S" and "P".
  sys-chans @ 2dup ! 2dup 5 + ! 15 + !  ;

: set-mode  ( a1 a2 -- )
  \ Set the system font to _a1_ and associate the output
  \ routine at _a2_ to the system channels.
  sys-chars !  mode-output  ;

: mode32  ( -- )
  [ latest name> ] literal current-mode !
  2548 15360 set-mode
  32 to columns  24 to rows
  ['] (mode32-xy) ['] xy defer!
  ['] (mode32-at-xy) ['] at-xy defer!  ;
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).

' mode32 ' default-mode defer!

( mode42 )

  \ Credits:
  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published in Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- integrate the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

need mode32  need <file-as-is

drive@ 1 drive!
s" prnt42.bin" <file-as-is ?throw
s" ea5aky.f42" <file-as-is ?throw
drive!
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode42-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode42  ( -- )
  [ latest name> ] literal current-mode !
  63900 [ 64600 256 - ] literal set-mode
  42 to columns  24 to rows
  ['] (mode42-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ Credits:
  \ Author of the original code: Andrew Owen.
  \ Published in the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1
  \ Modified and adapted to Solo Forth by Marcos Cruz.

  \ XXX OLD temporary first version
  \ First the driver and the font were in a disk file
  \ that is loaded at 60000. Later the font was compiled
  \ into the dictionary.

need mode32  need <file-as-is  need 4x8font

drive@ 1 drive!
s" 4x8fd.bin" <file-as-is ?throw
drive!
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode64-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latest name> ] literal current-mode !
  60000 4x8font set-mode
  64 to columns  24 to rows
  ['] (mode64-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

  \ XXX TODO (mode64-home)

code (mode64-emit)  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if
    FF a ld#
  then
  \ check_cr

  end-code

: mode64  ( -- )  (mode64-emit) mode64-chars @ set-mode
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credits:
  \ Author of the font: Andrew Owen.
  \ Published in the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 drive!  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) >body hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( xc yc -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credits:
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    \ now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  l add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) >body call
  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Strings {{{

( s= )  \ ==strings==

: s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

( s\" )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( s\" )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "text<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

: s\"  ( Compiling: "text<quote>" -- ) ( Run-time: -- ca len )
  parse-escaped-string  postpone sliteral
  ; immediate compile-only

  \ XXX TODO documentation

  \ doc{
  \
  \ s\"  ( "text<quote>"  - ca len )
  \
  \ }doc

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credits:
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credits:
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( s' )

  \ Credits:
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "text<'>" -- ) ( Run-time:  -- ca len )
  \
  \ }doc

: s'  ( Compilation: "ccc<'>" -- ) ( Run-time:  -- ca len )
  [char] ' parse-string  ; immediate

( begin-stringtable end-stringtable )

  \ Credits:
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

( csliteral cslit )

  \ XXX TODO test

: cslit  ( -- ca len )  r@ dup c@ 1+ r> + >r  ;

: csliteral  ( ca -- )
  compile cslit s,  ; immediate compile-only

( hunt )

  \ Credits:
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( /name first-name trim last-name )

  \ Credits:
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need s=  need [if]

  \ Credits:
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]
: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> s=  ;
[then]

  \ Credits:
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]
: suffix? ( ca1 len1 ca2 len2 -- wf )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string s=  ;
[then]

( -prefix )

  \ Credits:
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credits:
  \ Code from Galope (module minus-suffix.fs).

need string-suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credits:
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credits:
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credits:
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( replaces )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \ Code adapted from the Forth-2012 documentation.

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

vocabulary replaces-voc
wid-of replaces-voc constant wid-subst
  \ wordlist id of the wordlist used to hold substitution names and replacement text.

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

-->

( replaces )

: findsubst  ( ca len -- cfa f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _cfa_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if
    nip nip execute    \ get buffer address
  else
     makesubst
  then
  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )

  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc



  \ }}} =======================================================
  \ Printing {{{

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

 6 constant 'tab'
 8 constant 'bs'
13 constant 'cr'

: tab          ( -- )  'tab' emit  ;
: backspace    ( -- )  'bs'  emit  ;

: crs           ( n -- )  'cr'  emits  ;
: tabs          ( n -- )  'tab' emits  ;
: backspaces    ( n -- )  'bs'  emits  ;

( column last-column row last-row at-x at-y )

: column  ( -- col )  xy drop  ;
  \ Current column (x coordinate).

: last-column  ( -- row  )  column 1-  ;
  \ Last column (x coordinate).

: row  ( -- row )  xy nip  ;
  \ Current row (y coordinate).

: last-row  ( -- row  )  row 1-  ;
  \ Last row (y coordinate).

: at-x  ( col -- )  row at-xy  ;
  \ Set the cursor
  \ at the given column (x coordinate)
  \ and the current row (y coordinate).

: at-y  ( row -- )  column swap at-xy  ;
  \ Set the cursor
  \ at the current column (x coordinate)
  \ and the given row (y coordinate).

( ud.r ud. )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

: ud.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;
  \ : u.r  ( n1 n2 -- )  >r 0 r> ud.r  ;
: ud.  ( d -- )  0 ud.r space  ;

( print )

  \ XXX UNDER DEVELOPMENT
  \ Adapted from Galope <print.fs>.

need last-row  need /name

  \ export

variable #printed   \ Printed chars in the current line.
variable #indented   \ Indented chars in the current line.
: printed+  ( u -- )  #printed +!  ;
: indented+  ( u -- )  #indented +!  ;
: (.word) ( ca len -- )  dup printed+ type  ;
: .char  ( c -- )  emit 1 printed+  ;
: not-at-home?  ( -- f )  xy +  ;

  \ export

: no-printed  ( -- )  #printed off #indented off  ;
: print-home  ( -- )  home no-printed  ;
: print-page  ( -- )  page print-home  ;

-->

( print )

: print-start-of-line  ( -- )
  #printed @ trm+move-cursor-left no-printed  ;

  \ : print-cr  ( -- )  not-at-home? if  cr  then  no-printed  ;
  \ XXX OLD first version

  \ hide

: at-last-start-of-line?  ( -- wf )
  xy last-row = swap 0= and  ;
: not-at-start-of-line?  ( -- wf )  column 0<>  ;
: print-cr?  ( -- wf )
  not-at-home? not-at-start-of-line? and
  \ xxx fixme 2012-09-30 what this was for?:
  \ at-last-start-of-line? 0= or
  ;

  \ export

defer (print-cr) ' (print-cr) ' cr defer!

: print-cr print-cr? ?? (print-cr) no-printed ;

variable print-width

-->

( print )

  \ hide

: previous-word?  ( -- wf )  #printed @ #indented @ >  ;
: ?space  ( -- ) previous-word? if  bl .char  then  ;
: current-print-width  ( -- u )
  print-width @ ?dup 0= ?? cols  ;
: too-long?  ( u -- wf )
  1+ #printed @ + current-print-width >  ;
: .word  ( ca len -- )
  dup too-long? if  print-cr  else  ?space  then  (.word)  ;

-->

( print )

: (print-indentation)  ( u -- )
  dup trm+move-cursor-right dup indented+ printed+  ;

  \ export

: print-indentation  ( u -- )  ?dup ?? (print-indentation)  ;

  \ hide

: >word  ( ca1 len1 ca2 len2 -- ca2 len2 ca1 len4 )
  \ ca1 len1 = Text, from the start of its first word.
  \ ca2 len2 = Same text, from the char after its first word.
  \ ca1 len4 = First word of the text.
  tuck 2>r -  2r> 2swap  ;

: first-word  ( ca1 len1 -- ca2 len2 ca3 len3 )  /name >word  ;

: (print)  ( ca1 len1 -- ca2 len2 )  first-word .word  ;

-->

( print )

  \ export

: print  ( ca len --)
  begin  dup   while  (print)  repeat  2drop  ;

  \ Suggested usage in the application:

  \ 4 value indentation
  \ : paragraph  ( ca len -- )
  \   print-cr indentation print-indentation print  ;


  \ }}} =======================================================
  \ Decompressor {{{

( zx7 )

  \ XXX TODO  -- adapt

  \ }}} =======================================================
  \ Graphics {{{

( udg! udg: )  \ ==graphics==

[defined] sys-udg ?\  23675 constant sys-udg
  \ System variable that holds the address of the User Defined
  \ Graphics.

: udg!  ( b0..b7 c -- )
  128 - 8 * sys-udg @ + 1 - dup 8 + do  i c!  -1 +loop  ;
  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;
  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant called "name" for the UDG char _c_.
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

( hires-emit-udg )

need z80-asm  need (hires-emit)

code hires-emit-udg  ( x y b -- )

  \ Display the user graphic character _b_ (0..255) at graphic
  \ coordinates _x y_. The system variable "UDG" is supossed to
  \ hold the address of a graphic charset (the address of the
  \ char 0 bitmap).
  \
  \ The UDG character will be printed with overwritting
  \ (equivalent to `1 overwritte`).

  \ XXX FIXME  -- crash?

  hl pop  l a ld
  de pop  hl pop  bc push  e b ld  l c ld
  5C7B de ftp  \ system variable UDG
  (hires-emit) call
  bc pop  next ix ldp#  jpnext
  end-code

\ (hires-emit) \

need z80-asm  need (pixel-addr)

  \ Credits:
  \ Code Adapted from "SMOOTH MOVE",
  \ written by Simon N.  Goodwin,
  \ published in Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create (hires-emit)  ( -- )

  \ Print a 8x8 bits char at high resolution coordinates.

  \ Input:
  \   DE = address of the first char (0) bitmap in a charset
  \   A = char code (0..255)
  \   B = y coordinate
  \   C = x coordinate
  \ Modifies:
  \   AF BC HL IX DE

  \ XXX FIXME  -- crash?

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

( ocr )

  \ Credits:
  \ Adapted from anonymous code published in Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  pushhl jp  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

[defined] sys-chars ?\ 23606 constant sys-chars
  \ System variable that holds the address of the font.

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  sys-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

[defined] sys-udg ?\  23675 constant sys-udg
  \ System variable that holds the address of the User Defined
  \ Graphics.

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ charset pointed by the system variable UDG.
  sys-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

( (pixel-addr) )

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( xc yc -- )

  D9 c,               \ exx
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credits:
  \ Author of the original code: Jos Manuel Lazo.
  \ Published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( xc yc -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credits:
  \ Based on code written by Jos Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credits:
  \ Based on code written by Jos Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( xc yc -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true >body jpnz
  ' false >body jp
  end-code

( rdraw )

  \ Credits:
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( x y -- )

  \ Draw a line relative to the current coordinates.
  \
  \ x y = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

( adraw ) \ from Abersoft Forth

  \ Credits:
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot

2variable x1  2variable incx  2variable y1  2variable incy

  \ System variables used:
  \   23677 = COORDX
  \   23678 = COORDY

: adraw  ( x y -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  23678 c@ ( y0 ) dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )
  23677 c@ ( x0 ) dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )
  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

( attr )

need z80-asm need (attr-addr)

code attr ( col line -- b )

  \ Return the color attribute of the given cursor coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  pushhl jp

  end-code

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col line -- a )

  \ Return the color attribute address of the given cursor
  \ coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  pushhl jp

  end-code

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  \ Address of a Z80 routine that calculates the color
  \ attribute address of a cursor position.  This is a modified
  \ version of the ROM routine at 0x2583.

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

( circle )


  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

  \ XXX TODO

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot >body call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( x y radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credits:
  \ Code adapted from a routine written by Pablo Ariza,
  \ published in Microhobby Especial, issue 7 (1987-12), page 46:
  \ <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credits:
  \ Code adapted from a routine written by Javier Granadino,
  \ published in Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credits:
  \ Code adapted from a routine written by Juan Jos Rivas,
  \ published in Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
            begin   m rrc  hl decp  h 6 bit  z until
            step

  bc pop  jpnext

  end-code

( clsx )

  \ Clear the screen by rotating all bytes
  \ of the bitmap.

  \ Credits:
  \ Code adapted from a routine written by Anselmo Moreno Lorente,
  \ published in Microhobby, issue 121 (1987-03), page 7:
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code clsx  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( scroll-1px-right )

  \ Credits:
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

  \ XXX FIXME

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
          m srl  hl incp  \ first char column
          1F b ld#  \ remaining columns
          begin   m rr  hl incp  step
          c dec
          z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credits:
  \ Code adapted from a routine written by Ivn Sansa,
  \ published in Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

( xy-scroll )

  \ Credits:
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

  \ XXX FIXME

need z80-asm

code xy-scroll  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin

      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
      z until

    step

  bc pop  end-code

( horizontal-curtain )

  \ Credits:
  \ Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the top and bottom
  \ rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credits:
  \ Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  \ XXX FIXME crash!

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ }}} =======================================================
  \ Sound 128 {{{

( !sound vol shutup noise )  \ ==sound128==

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  vocabulary music  current @  also music definitions
need roll

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b  -->

( music )

  \ Credits:
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l  ( n -- )  len !  ;
: o+  ( -- )  octave @ 2 * octave !  ;
: o-  ( -- )  octave @ 2 / octave !  ;
: r  ( -- )  tempo @ len @ * ms  ;
: >>  ( -- )  1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )  1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: )

  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan Jos Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

  \ XXX TODO

: sound:  ( b0 ... b13 "name" -- )
  create  here 1- 14 allot here -1 do  i c!  -1 +loop  ;

( play )

  \ Z80 version of the previous `play`.

need z80-asm

[defined] sound-register-port
?\ 65533 constant sound-register-port
[defined] sound-write-port
?\ 49149 constant sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter train )

  \ Sounds to be played with `play`.

  \ Credits:
  \ `waves` and `shoot` are
  \ adapted from code written by Juan Jos Ruiz,
  \ published in Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

create waves  ( -- a )
  0 c,  0 c,  0 c,  0 c,  0 c,  0 c,  7 c,
  71 c,  20 c,  20 c,  20 c,  0 c,  38 c,  14 c,

create shoot  ( -- a )
  10 c,  0 c,  177 c,  0 c,  191 c,  0 c,  31 c,
  71 c,  20 c,  20 c,  20 c,  92 c,  28 c,  3 c,

  \ Credits:
  \ `helicopter` and `train` are
  \ adapted from code written by Jos ngel Martn,
  \ published in Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

create helicopter  ( -- a )
  200 c,  15 c,  200 c,  15 c,  200 c,  15 c,  0 c,
  7 c, 23 c,  23 c,  23 c,  255 c,  1 c,  12 c,

create train  ( -- a )
  100 c,  120 c,  48 c,  97 c,  12 c,  200 c,  55 c,
  15 c,  9 c,  11 c,  55 c,  180 c,  4 c,  8 c,

( sound effects )

  \ Sounds to be played with `play`.

  \ Data extracted a program written by Juan Jos Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop

  decimal

( rain water-drops )

  \ Sounds to be played with `play`.

  \ Data extracted from a program written by Carlos Ventura,
  \ published in Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX this effects don't sound fine, but the data is right

create rain  ( -- a )
  44 c, 24 c, 6 c, 6 c, 7 c, 3 c, 3 c,
  5 c, 44 c, 6 c, 3 c, 5 c, 3 c, 3 c,

create water-drop  ( -- a )
  20 c, 83 c, 94 c, 39 c, 0 c, 8 c, 31 c,
  71 c, 23 c, 23 c, 22 c, 90 c, 0 c, 0 c,

  \ }}} =======================================================
  \ Sound 48 {{{

( bleep )  \ ==sound48==

  \ Credits:
  \ Code modified from Abersoft Forth.

code bleep  ( n1 n2 -- )
  \ Produce a tone in the noise maker.
  \ n1 = duration
  \ n2 = pitch
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5 ,        \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)
  end-code

( beep>bleep )

  \ Credits:
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( freq duration -- n1 n2 )
  \ n1 = duration
  \ n2 = pitch
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published in Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published in Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credits:
  \ Author of the original code: Lder Software.
  \ Published in Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Memory access {{{

( exchange )  \  ==memoryaccess==

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;


( c+! c@+ )

need z80-asm

[unneeded] c+! dup
?\  code c+!  ( b ca -- )
?\    hl pop  de pop  e a ld  m a add  a m ld  jpnext  end-code

  \ doc{
  \
  \ code c+!  ( b ca - )
  \
  \ Add _b_ to the 8-bit number at _ca_
  \
  \ }doc

[unneeded] c@+ dup
?\ code c@+  ( ca - ca+1 c )

  \ Credits:
  \ Code adapted from Pygmy Forth.

  \ First version
  \ de pop  de ftap  de incp  0 h ld# a l ld  pushhlde jp

  \ Second version
?\  hl pop  m a ld  hl incp  hl push  pusha jp  end-code

  \ doc{
  \
  \ code c@+  ( ca - ca+1 c )
  \
  \ Fetch the byte at _ca_ a and increments the address.
  \ This is handy for stepping through byte arrays.
  \
  \ }doc

( 1+! 1-! )

need z80-asm  need [if]

[needed] 1+! [if]
code 1+!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de incp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the cell number at _a_.
  \
  \ }doc

[needed] 1-! [if]
code 1-!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de decp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the cell number at _a_.
  \
  \ }doc

( c1+! c1-! )

need z80-asm

[unneeded] c1+!
?\  code c1+!  ( ca -- )  hl pop  m inc  jpnext  end-code

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the 8-bit number at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  hl pop  m dec  jpnext  end-code

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the 8-bit number at _ca_.
  \
  \ }doc

( c@+ c!+ -c@ -c! )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credits:
  \ Words from the TED editor.
  \ http://dxforth.netbay.com.au/ted.html

  \ Note: these words are too specific for the TED editor.

: c@+  ( ca -- c )  dup @ c@ swap 1+!  ;
: c!+  ( c ca -- )  tuck @ c! 1+!  ;
: -c@  ( ca -- c )  dup 1-! @ c@  ;
: -c!  ( c ca -- )  dup 1-! @ c!  ;

( @+ @- !+ !- c@+ c@- c!+ c!- )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credits:
  \ Words written after cmForth.

  \ XXX Note: the original descriptions didn't include stack
  \ notations. Some of them are not clear.

  \ @+  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is incremented by n.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ @-  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is decremented by n.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ !+  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then incremented by n.

  \ !-  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then decremented by n.

  \ c@+  ( ca n -- b ca' )
  \
  \ Fetch a byte from memory and increment the address by n.

  \ c@-  ( ca n -- b ca' )
  \
  \ Fetch a byte from memory and decrement the address by n.

  \ c!+  ( b ca n -- ca' )
  \
  \ Store a byte to memory and increment the address by n.

  \ c!-  ( b ca n -- ca' )
  \
  \ Store a byte to memory and decrement the address by n.

( bit? set-bit reset-bit )

need lshift

: bit>mask  ( n -- b )  1 swap lshift  ;
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.

: bit? ( b n -- f )  bit>mask and 0<> ;
  \ Is bit _n_ of _b_ set?

: set-bit ( b1 n -- b2 )  bit>mask or ;
  \ Set bit _n_ of _b1_, returning the result _b2_.

: reset-bit ( b1 n -- b2 )  bit>mask invert and ;
  \ Reset bit _n_ of _b1_, returning the result _b2_.

( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credits:
  \ Words inspired by MPE PowerForth for TiniARM.

need z80-asm  need [if]

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- wf )
  \   hl pop  de pop  e a ld  m and
  \   ' true >body jpnz  ' false >body jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s char < emit type char > emit cr

[needed] c@test-bits [if]
code c@test-bits  ( b1 ca -- b2 )
  hl pop  de pop  e a ld  m and  pusha jp
  end-code  exit  [then]
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[needed] c!toggle-bits [if]
code c!toggle-bits  ( b ca -- )
  hl pop  de pop  m a ld  e xor  a m ld  jpnext
  end-code  exit  [then]
  \ Invert the bits at _ca_ specified by the bitmask _b_.

( reserve )

: reserve  ( n -- a )  here tuck over erase allot  ;
  \ Reserve a zone of _n_ bytes in the dictionary, erase it
  \ and return its address _a_.

  \ }}} =======================================================
  \ Single-cell operators {{{

( under+ )  \ ==operators==

: under+  ( n1 n2 n3 -- n4 n3 )  >r + r>  ;

( within between )

  \ Credits:
  \ Code from DZX-Forth.

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Standard: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit
need -rot
: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )

  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.

  \ name  ( -- )
  \
  \ }doc

  \ Credits:
  \ http://dxforth.netbay.com.au/between.html

( u<= u>= <= >= 0>= 0<= )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;

( lshift )

need z80-asm

  \ Credits:
  \ Code adapted from Z88 CamelForth.

  \ 16 bytes used

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credits:
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credits:
  \ Code adapted from Z88 CamelForth.

  \ 19 bytes used

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credits:
  \ Code adapted from DZX-Forth.

  \ This version is smaller (16 bytes used) but slower (133%
  \ the execution time of the version adapted from Z88 CamelForth).

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( 2/ )

  \ Credits:
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  C3 c, pushhl ,  \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Standard: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

( sqrt )

  \ Credits:
  \ Original code by Wil Baden, published on
  \ Forth Dimensions 18/5 p. 27 (1997-01).

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sm/rem )

  \ Credits:
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Standard: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credits:
  \ Forth-94 documentation.

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credits:
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Standard: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

need fm/mod

  \ Credits:
  \ Forth-94 documentation.

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? )

  \ Credits:
  \ Code from F83.

need roll

variable (any?)

: any?  ( x0 x1..xn n -- f )
  \ Is any _x1..xn_ equal to _x0_?
  dup 1+ roll (any?) !  0 swap 0 do swap (any?) @ = or loop  ;

  \ }}} =======================================================
  \ Double-cell operators {{{

( ud* )

  \ Credits:
  \ Code from Z88 CamelForth.

: ud*  ( ud1 d2 -- ud3 )  dup >r um* drop  swap r> um* rot +  ;

( d* )

  \ Credits:
  \ Code by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 33, 1998-04).

  \ This implementation uses 30 bytes.

: d*  ( d1 d2 -- d3 )
  >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  r> * swap r> * + +  ; ( d1*d2 ) ( R: )

  \ Alternative implementation.
  \
  \ Credits:
  \ Adapted from code written by Robert L. Smith,
  \ published on Forth Dimensions (volume 4, number 1, page 3).
  \
  \ This implementation uses 36 bytes and is 5% slower.
  \
  \ : d*  ( d1 d2 -- d3 )
  \  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

( du/mod )

  \ Credits:
  \ Code by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 34, 1998-04).

need tum*  need t+  need t-  need tum/  need d2*

: normalize-divisor  ( d1 -- d1' shift )
  0 >r begin  dup 0< while  d2*  r> 1+ >r  repeat  r>  ;

  \ XXX TODO rename as `ud/mod`?
  \ XXX TODO stack comments

: du/mod  ( ud1 ud2 -- rem quot )

  ?dup 0= if
    \ there is a leading zero "digit" in divisor
    >r  0 r@ um/mod  r> swap >r  um/mod  0 swap r>  exit
  then

  normalize-divisor dup >r rot rot 2>r
  1 swap lshift tum*
    \ normalize divisor and dividend


  dup  r@ = if   -1  else  2dup  r@ um/mod nip  then
    \ guess leading "digit" of quotient

  2r@  rot dup >r  tum*  t-
    \ multiply divisor by trial quot and substract from
    \ dividend

  dup 0< if  r> 1-  2r@  rot >r  0 t+
    \ if negative, decrement quot and add to dividend

    dup 0< if  r> 1-  2r@  rot >r  0 t+  then
    \ if still negative, do it one more time

  then  ;
  \ Double unsigned divide with remainder.

( d0= d0< d< du< )

  \ Credits:
  \ Code from DZX-Forth.

[unneeded] d0= ?\ : d0=  ( d -- f )  or 0=  ;  exit

[unneeded] d0< ?\ : d0<  ( d -- f )  nip 0<  ; exit

need [if]

[needed] d< [if]

need 2nip

: d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;  exit

[then]

[needed] du< [if]

  \ XXX TODO rewrite in Z80

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;  exit

[then]

( dmin dmax )

  \ Credits:
  \ Code from DZX-Forth.

need [if]

[needed] dmin [if]
: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;  exit  [then]

[needed] dmax [if]
: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;  [then]

( d= d<> )

  \ XXX TODO -- rewrite in Z80

: d<>  ( d1 d2 -- f )
  rot <> if  2drop true exit  then  <>  ;
: d=  ( d1 d2 -- f )  d<> 0=  ;

  \ XXX OLD
  \ : d=  ( d1 d2 -- f ) rot = >r = r> and  ;
  \ : d<>  ( d1 d2 -- f )  d= 0=  ;

( d- )

need z80-asm

  \ Credits:
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  pushhl jp
  end-code

( d2* d2/ )

  \ Credits:
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  D1 c, E1 c,
    \ pop de / pop hl
  29 c,  CB c, 13 c,  CB c, 12 c,
    \ add hl,hl
    \ rl e
    \ rl d
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  E1 c, D1 c,
    \ pop hl / pop de
  CB c, 2C c,  CB c, 1C c,  CB c, 1D c,
    \ sra h  /  rr h /  rr l
  CB c, 1A c,  CB c, 1B c,
    \ rr d /  rr e
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

( d2* d2/ )

  \ Credits:
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]  need z80-asm

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  de pop  hl pop
  hl addp  e rl  d rl
                              \ alternatives:
  exde  pushhlde jp           \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  hl pop  de pop
  h sra  l rr  d rr  e rr

                              \ alternatives:
  pushhlde jp                 \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

( m* )

  \ Credits:
  \ Code by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3).

  \ XXX TODO benchmark with the version in the kernel

need d*
: m*  ( n1 n2 -- d )
  >r s>d r> s>d d* ;

( m+ )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need z80-asm

code m+  ( d1 n -- d2 )
  exx     \ save Forth IP
  bc pop  \ n
  de pop  \ d1 hi cell
  hl pop  \ d1 lo cell
  bc addp  hl push
  cy if  de inc  then  de push
  exx      \ restore Forth IP
  jpnext
  end-code

  \ doc{
  \
  \ m+  ( d1|ud1 n -- d2|ud2 )
  \
  \ Add _n_ to _d1|ud1_, giving the sum _d2|ud2_.
  \
  \ Standard: Forth-94 (DOUBLE) Forth-2012 (DOUBLE).
  \
  \ }doc

( dsqrt )

  \ Credits:
  \ Original code by Wil Baden, published on
  \ Forth Dimensions 18/5 p. 29 (1997-01).

need q2*  need d2*  need d<  need m+  need d- need 2rot
need 2nip  [defined] cell-bits ?\ 16 constant cell-bits

  \ XXX FIXME wrong results
  \
  \ It worked fine, but something got wrong
  \ Perhaps because of some wrong dependency?
  \ maybe `d<`?
  \
  \ It works in Gforth

: (dsqrt)  ( radicand . -- remainder . root . )
  0. 0.             ( radicand . remainder . root . )
  cell-bits 0 do    ( radicand . remainder . root . )
    cr .s  key drop  \ XXX INFORMER
    2>r q2* q2* 2r>  d2*
    2over 2over d2* 2swap
      cr .s ." d< ?"  \ XXX INFORMER
      d< if
      cr .s ." d<"  \ XXX INFORMER
      2dup 2>r d2* d- -1 m+ 2r>  1 m+
    then
  loop  cr .s 2rot 2drop  ;

: dsqrt  ( radicand . -- root . )  (dsqrt) 2nip  ;

  \ }}} =======================================================
  \ Triple-cell operators {{{

( tum* tum/ t+ t- )

  \ Credits:
  \ Code by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 34, 1998-04).

  \ XXX TODO -- test

need d+  need d-

: +carry  ( n1 n2 -- n1+n2 carry )  0 tuck d+  ;
: -borrow  ( n1 n2 -- n1-n2 borrow )  0 tuck d-  ;

: tum*  ( d n -- t )  2>r  r@ um*  0 2r>  um* d+  ;
  \ Triple unsigned mixed multiply.

: tum/  ( t n -- d )  dup >r um/mod r> swap >r um/mod nip r>  ;
  \ Triple unsigned mixed division.

: t+  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r +carry  0 r> r> +carry d+ r> r> + +  ;
  \ Triple add.

: t-  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r -borrow
  s>d r> r> -borrow d+ r> r> - +  ;
  \ Triple substract.

  \ }}} =======================================================
  \ Quadruple-cell operators {{{

( q2* )

  \ Credits:
  \ Original code by Wil Baden, published on
  \ Forth Dimensions 18/5 p. 29 (1997-01).

need d2*

: q2*  ( n . . . -- 2n . . . )
  d2* >r >r
  dup 0< if     d2* r> 1+ r>
         else   d2* r> r>
         then  ;


  \ }}} =======================================================
  \ Compilation {{{

( [if] [else] [then] )  \ ==compilation==

need s=

: [else]  ( "..." -- )

  \ 1 begin   parse-name 2dup swap c@ and \ XXX OLD
  1 begin   parse-name dup
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( ?--> )

: ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "text<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc


( body>name name>body link>name name>link >>link name<name )

[unneeded] body>name
?\ : body>name  ( pfa -- nfa ) body> >name  ;

[unneeded] name>body
?\ : name>body  ( nfa -- pfa ) name> >body  ;

[unneeded] link>name dup  ?\ need alias
?\ ' cell+ alias link>name  ( nfa -- pfa )

[unneeded] name>link dup  ?\ need alias
?\ ' cell- alias name>link  ( nfa -- pfa )

[unneeded] >>link dup  ?\ need alias
?\ ' cell+ alias >>link  ( cfap -- lfa )

[unneeded] name<name dup  ?\ need name>link
?\ : name<name  ( nfa1 -- nfa2 )  name>link @n  ;
  \ Get the previous _nfa2_ from _nfa1_.

( name>interpret name>compile )

  \ XXX UNDER DEVELOPMENT

: name>interpret  ( nfa -- cfa | 0 )
  ;

  \ doc{
  \
  \ name>interpret  ( nfa -- cfa | 0 )
  \
  \ Return a _cfa_ that represents the interpretation semantics
  \ of the word _nfa_. If _nfa_ has no interpretation
  \ semantics, return zero.
  \
  \ Standard: Forth-2012 (TOOLS EXT).
  \
  \ }doc

: name>compile  ( nfa -- x cfa )
  ;

  \ doc{
  \
  \ name>compile  ( nfa -- x cfa )
  \
  \ Return _x cfa_ that represents the compilation semantics
  \ of the word _nfa_. The  returned _cfa_ has the stack
  \ effect ( i*x  x -- j*x  ).  Executing _cfa_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nfa_.
  \
  \ Standard: Forth-2012 (TOOLS EXT).
  \
  \ }doc

( smudge smudged )

need c!toggle-bits

: smudged  ( nfa -- )
  smudge-mask swap names-bank c!toggle-bits default-bank  ;

  \ doc{
  \
  \ smudged  ( nfa -- )
  \
  \ Toggle the "smudge bit" of the given name field address.
  \
  \ This word is obsolete. `hided` and `revealed` are used
  \ instead.
  \
  \ }doc

 : smudge  ( -- )  latest smudged  ;

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Standard: fig-Forth.
  \
  \ }doc

( ?pairs )

: ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;
  \ If _x1_ not equals _x2_ throw an error -22 (control
  \ structure mismatch).

( privatize )

  \ Usage example:
  \
  \ ----
  \ private{
  \
  \ : hello  ( -- )  ." hello"  ;
  \
  \ }private
  \
  \ : salute  ( -- )  hello  ;
  \
  \ privatize
  \
  \ salute  \ ok!
  \ hello   \ error!
  \ ----

  \ Credits:
  \
  \ The idea for this code was taken from an article by Deway
  \ Val Schorre, _Structured programming by adding modules to
  \ FORTH_, published in Forth Dimensions 2/5 page 132
  \ (1981-01). The following original code is for fig-Forth.
  \ I added stack effects and comments:

  \ : INTERNAL  ( -- nfa )  CURRENT @ @  ;
  \   \ Start the definition of internal words of the module.
  \   \ Return the nfa of the latest word created in the
  \   \ `current` vocabulary.
  \
  \ : EXTERNAL  ( -- nfa )  HERE  ;
  \   \ Start the definition of external words of the module.
  \   \ Return the nfa of the next word to be defined.
  \
  \ : MODULE  ( nfa1 nfa2 -- )  PFA LFA !  ;
  \   \ End the module.
  \   \ Link the first external word to the word before the
  \   \ first internal word, thus making the internal words
  \   \ invisible.

  \ The names have been changed after an analogous code from
  \ pForth, for clarity.

need >>link

: private{  ( -- nfa )  latest  ;
  \ Start private definitions.
  \ Return the nfa of the latest word created in the
  \ `current` vocabulary.

: }private  ( -- cfap )  np@  ;
  \ End private definitions.
  \ Return the cfap (code field address pointer) of the first
  \ word to be defined as public, that is, the current value
  \ of the names pointer.

: privatize  ( nfa cfap -- )  >>link !n  ;
  \ Hide all words between `private{` and `}private`:
  \ Link the first public word to the word before the
  \ first private word, thus making the private words
  \ invisible.

( privatize )

  \ Credits:
  \ Code adapted from pForth.

  \ ____
  \
  \ @(#) private.fth 98/01/26 1.2
  \ PRIVATIZE
  \
  \ Privatize words that are only needed within the file
  \ and do not need to be exported.

  \ Usage example:
  \
  \    private{
  \    \ everything between private{ and }private
  \    \ will become private.
  \    : foo ;
  \    : moo ;
  \    }private
  \    : goo   foo moo ;  \ can use foo and moo
  \    privatize          \ hide foo and moo
  \    ' foo              \ will fail

  \ Copyright 1996 Phil Burk
  \ ____

need abort"  need name<name

variable private-start  variable private-stop

: private{  ( -- )
  latest private-start !  private-stop off  ;
  \ Start private definitions.

: }private  ( -- )
  private-stop @ abort" Extra }private"
  latest private-stop !  ;
  \ End private definitions.

: privatize  ( -- )
  private-start @ 0= abort" Missing private{"
  private-stop @ dup 0= abort" Missing }private"
  begin   dup private-start @ u>
  while   dup hide name<name
  repeat  drop  private-start off  private-stop off  ;
  \ Hide all words between `private{` and `}private`.

( begin-module: begin-module public private end-module )

  \ Credits:
  \ Code adapted and modified from Galope.

need get-order  need wordlist

  \ Inner words

get-order get-current

wordlist dup set-current  >order

variable current-wid  variable module-wid

: (module)  ( -- wid )
  get-current current-wid !
  wordlist dup module-wid ! dup >order  ;

set-current

  \ Interface words

: public  ( -- )  current-wid @ set-current  ;
  \ Public definitions follow.

: private  ( -- )  module-wid @ set-current  ;
  \ Private definitions follow.

: begin-module:  ( "name" -- )  (module) constant private  ;
  \ Start a named module.
  \ Private definitions follow.

: begin-module  ( -- )  (module) drop private  ;
  \ Start an anonymous module.
  \ Private definitions follow.

: end-module  ( -- )  public previous  ;
  \ End a module.

set-order

  \ Description and usage.

  \ Modules hide the internal implementation and leave visible the
  \ words of the outer interface. Example:

  \ begin-module: my_module
  \   \ Inner/helper words.
  \ public
  \   \ Interface words,
  \   \ compiled in the outer vocabulary,
  \   \ thus seen from the extern.
  \ private
  \   \ Inner/helper words again.
  \ public
  \   \ Interface words again. And so on.
  \ end-module

  \ As an alternative, the word 'begin-module' starts an unnamed module.

  \ }}} =======================================================
  \ G+DOS {{{

( ufia )  \ ==g+dos==

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1 \ drive: 1 or 2
ufia 1+   constant fstr1 \ program number
ufia 2+   constant sstr1 \ stream number
ufia 3 +  constant device \ device: "D" or "d"
ufia 4 +  constant nstr1 \ directory description
ufia 5 +  constant nstr2 \ file name
ufia 15 + constant hd00  \ file type
ufia 16 + constant hd0b  \ file length
ufia 18 + constant hd0d  \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

char d device c! \ "d" or "D"
2 sstr1 c! \ stream 2
1 dstr1 c! \ drive 1

variable file-length  \ copy of `hd0b` used by `(<file)`
variable file-address \ copy of `hd0d` used by `(<file)`

( File types and directory descriptions)

  \ File types

0 constant basic-filetype  1 constant data-array-filetype
2 constant string-array-filetype  3 constant code-filetype

  \ Directory descriptions

01 constant basic-file-dir      02 constant data-array-dir
03 constant string-array-dir    04 constant code-file-dir
05 constant snapshot-48k-dir    06 constant microdrive-file-dir
07 constant screens$-file-dir   08 constant special-file-dir
09 constant snapshot-128k-dir   10 constant opentype-file-dir
11 constant execute-file-dir

( --hook-codes-- )

hex

33 constant hxfer  34 constant ofsm  35 constant hofile
36 constant sbyte  37 constant hsvbk 38 constant cfsm
39 constant pntp   3A constant cops  3B constant hgfile
3C constant lbyte  3D constant hldbk 3E constant wsad
3F constant sad    40 constant rest  41 constant heraz
42 constant cops2  43 constant pcat  44 constant hrsad
45 constant hwsad  46 constant otfoc 47 constant patch

decimal

: --hook-codes--  ;

( ior>error ?dos-error )

: ior>error  ( ior -- f n )

  \ Convert a DOS ior to a Forth error number.

  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ f = error?
  \ n = error number: 1000..1031: G+DOS error number
  \                   1128..1154: OS error number
  dup 1 and negate swap   \ calculate f
  flip %11111111 and      \ upper 8 bits of ior
  1000 + negate  ;

: ?dos-error  ( ior -- )
  \ ior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: OS error; unset: DOS error
  ior>error ?throw  ;

( drive@ drive! )

need z80-asm  need --hook-codes--

code drive@  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  \ save the Forth registers
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp  end-code

code drive!  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  \ save the Forth registers
  l a ld  21 hook   \ select drive in a
  bc pop   next ix ldp#  \ restore the Forth registers
  jpnext  end-code

( -file )

need z80-asm  need ufia  need --hook-codes--

code (-file)  ( -- ior )

  \ Delete a disk file using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  heraz hook \ erase the file
  bc pop  next ix ldp#  \ restore the Forth registers
  af push
  jpnext
  end-code

need ior>error

: -file  ( ca len -- f n )
  \ Delete a disk file.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  filename>ufia (-file) ior>error  ;

( -filename filename! >ufia filename>ufia )

need ufia  need drive@

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  drive@ dstr1 c!  ;

1 drive!  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  bc pop  next ix ldp#  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) ior>error  ;

( <file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) ior>error  ;

( <file-as-is )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file-as-is)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    hd0d de ftp  hd0b bc ftp  hldbk hook
      \ Use the address and length from the header.
      \ Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ Restore the Forth registers and save the ior.

  jpnext  end-code

: <file-as-is  ( ca len -- f n )
  \ Load a file from disk.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2swap >ufia (<file-as-is) ior>error  ;

( file? )

need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )

  bc push  \ save the Forth IP
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  ' true >body jpz
  ' false >body jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ hex 3E01 constant ufia1 decimal
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  exx
    \ Get the parameter in hl' and save the Forth IP

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  exx  l a ld  24B5 call  168E call
    \ 24B5 = CAT_RUN (input: cat type in the a register)
    \ 168E = BORD_REST (restore the border)

  E7 out  bc pop  next ix ldp#  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( ca len -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( ca len -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need z80-asm  need --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

need z80-asm  need --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

need z80-asm  need --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( !dos )

need z80-asm  need --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  \ save the Forth IP
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ bc pop  next ix ldp#  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

  \ }}} =======================================================
  \ Disk blocks {{{

( update flush continued ?load thru +load +thru reload )

: update  ( -- )
  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Standard: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

: flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Standard: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \ }doc

: continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Standard: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

: ?load  ( block f -)  if  dup load  then  drop  ;

  \ Credits:
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ }doc


: thru  ( block1 block2 -- )  1+ swap do  i load  loop  ;

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Standard: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

: +load  ( block -- )  blk @ + load  ;

: +thru  ( block1 block2 -- )  1+ swap do  i +load  loop  ;

  \ Credits:
  \ `thru`, `+load` and `+thru` from Afera.

: loads  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loads  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load
  \ block _block_.
  \
  \ Standard: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

: reload  ( -- )  empty-buffers  scr @ load  ;

exit

: loads  ( block n -- )  bounds do  i load  loop  drop  ;

  \ Credits:
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ block starting from block _block_.
  \
  \ }doc

( .line )

  \ XXX TODO -- `line>string` is in the kernel because
  \ `located` uses it.
  \
  \ : line>string  ( n1 n2 -- ca len )
  \   >r  c/l b/buf */mod  r> +
  \   block + c/l  ;

  \ doc{
  \
  \ line>string  ( n1 n2 -- ca len )
  \
  \ Convert the line number _n1_ and the block number _n2_ to
  \ a string in the disk buffer containing the data.
  \
  \ }doc

: .line  ( n1 n2 -- )  line>string -trailing type  ;

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Standard: fig-Forth.
  \
  \ }doc

  \ }}} =======================================================
  \ Tape files {{{

( >tape <tape )

  \ XXX UNDER DEVELOPMENT

  \ Credits:
  \ Code adapted from Afera.

  \ XXX TODO finish adapting the code

  \ -----------------------------------------------------------
  \ Development documentation

  \ Credits:
  \
  \ Information retrieved from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119).

  \ The load tape header is pointed by IX before calling the ROM
  \ routine. Its structure is the following:

  \ +00 : 3 (identifier of code file type)
  \ +01 : "<filename->" = 10-char filename, padded with spaces
  \ +11 : 0 = length
  \ +13 : 0 = start address
  \ +15 : "  " (2 spaces) = not used for code files

  \ The save tape header is right after the save header.

17 constant /tape-header  \ bytes per tape header
create tape-header  /tape-header 2 * allot

10 constant /tape-filename \ filename max length

: >tape-filename  ( ca1 -- ca2 )   1+   ;
: >tape-length    ( ca1 -- ca2 )  11 +  ;
: >tape-start     ( ca1 -- ca2 )  13 +  ;

code (tape)  ( n -- )

  \ n = 1 load
  \ n = 0 save

  \ pop hl
  \ push bc
  \ push ix
  \ ld a,l ; 1=LOAD, 0=SAVE
  \ ; this instruction is at 0x7618:
  \ ; XXX OLD ; ld hl,D000  ; start address to save or load
  \ ld hl,( XXX )  ; start address to save or load ; XXX NEW
  \ ld ix,tape-header
  \ ld (5C74),A
  \ call 075A
  \ pop ix
  \ pop bc
  \ jp next1

  end-code

-->

( >tape <tape )

: -tape-filename  ( -- )
  tape-header >tape-filename /tape-filename blanks ;
  \ Blank the filename of the load header.

  \  XXX TODO use the file execution table
  \  to share one word with the disk support?
: tape-filename!  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-header >tape-filename swap cmove  ;
  \ Store a filename into the load header.

: any-tape-filename  ( -- )
  255 tape-header >tape-filename c!  ;
  \ Configure the load header to load any filename.

: tape-length!  ( len -- )
  tape-header >tape-length !  ;
  \ Set the given code length for the next tape loading,
  \ storing it into the load header.

: tape-start!  ( a -- )
  tape-header >tape-start !  ;
  \ Set the given code start for the next tape loading,
  \ storing it into the load header and patching
  \ the code of the word `(TAPE)`.

-->

( >tape <tape )

: <tape  ( ca1 len1 ca2 len2 -- )
  dup if  tape-filename!  else  2drop any-tape-filename  then
  tape-length! tape-start!  1 (tape)  ;
  \ Load a file from tape.
  \ ca1      = destination
  \ len1     = length (or zero if unspecified)
  \ ca2 len2 = filename (len2 is zero if unspecified) 

: >tape  ( ca1 len1 ca2 len2 -- )
  tape-filename! tape-length! tape-start!  0 (tape)  ;
  \ Save a memory region into a tape file.
  \ ca1      = start
  \ len1     = length
  \ ca2 len2 = filename

  \ }}} =======================================================
  \ Tools {{{

( transient[ )  \ ==tools==

  \ XXX TODO -- Finish.

need >>link

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  \ Start transient code, reserving u bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - dp !  ;

: ]transient  ( -- )  old-dp @ dp !  old-np @ np !  ;

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.

: -transient  ( -- )

  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.

  old-voc-link @ voc-link !

  \ Store the nfa of the latest word created before compiling
  \ the transient code, into the lfa of the first word created
  \ after the transient code was finished by `]transient`.

  \ XXX TODO

  old-latest @ old-np @ >>link !n  ;

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( bin. dec. hex. )

  \ Credits:
  \ Code modified from eForth.

[defined] base.
?\  : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credits:
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credits:
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  \ XXX TODO use `?do` instead of `if` when available
  dup if
    bounds do
      i c@ 127 and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

( dump )

need break-key?  need 16hex.  need ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

  \ XXX FIXME -- when len=0 a row is shown; `wdump` does
  \ nothing.

: dump  ( ca len -- )
  8 2dup mod - + 8 / 0
  \ XXX TODO use `?do` instead of `if` when available
  2dup <> if
    do
      cr dup 16hex.
      8 0 do  i over + @ flip 16hex.  cell +loop
      \ 16 0 do  i over + c@ hexb.  loop
      dup bs 8 ascii-type
      break-key? ?exhaust
    8 + loop
  else  2drop  then  drop  ;

( wdump )

need break-key?  need 16hex.

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  \ XXX TODO use `?do` instead of `if` when available
  2dup <> if
    do
      i 4 mod 0= if  cr dup 16hex. space  then  \ show address
      dup @ 16hex. cell+
      break-key? ?exhaust
    loop
  else  2drop  then  drop  ;

( decode )

  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

  \ Credits:
  \
  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published in Forth
  \ Dimensions IV,#2 p28 (1982-07).

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-compile   ( a1 -- a2 )  2+ dup @ 2+ body>name id.  ;

: decode-literal   ( a1 -- a2 )  2+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  2+ dup c@ . 1-  ;

: decode-branch    ( a1 -- a2 )  2+ dup @ u.  ;

: decode-sliteral  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-sliteral   endof
  endcase  ;

-->

( decode )

  \ Checks of the main code

  \ XXX FIXME -- `;s` is not a valid check anymore
: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] exit =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  body> @ ['] : @ =  ;

-->

( decode )

  \ Main code

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent  ." : " dup body>name id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      2+ ( pfa+n pfa' ) dup indent+  body>name id.
      key case  [char] q  of  sp0 @ sp! quit  endof \ q
                      bl  of  drop            endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ body>name id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage

  \ XXX OLD -- defined  ( "name" -- x 0 | cfa 1 | cfa -1 )
  \ defined if  >body  0 decode-level !  (decode)
  \         else  drop  -13 throw  then  ;

  \ XXX OLD -- defined  ( "name" -- ca len false | cfa b true )
  \ defined 0= -13 ?throw
  \ drop >body  0 decode-level !  (decode)  ;

  \ XXX NEW -- defined  ( "name" -- nfa | 0 )
  defined dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

( list )

need break-key?  need .line

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    break-key? ?exhaust
  loop cr  ;

( break-key? )

code break-key?  ( -- f )

  \ Is the Break key pressed?

  CD c, 1F54 ,              \ call rom_break_key
  D2 c, ' true >body ,    \ jp nc,true
  C3 c, ' false >body ,   \ jp false

  end-code

( index .index )

need break-key?  need .line

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap do
    cr i 3 .r space 0 i .line
    break-key? if  exhaust  then
  loop  ;

( index-like )

need break-key?  need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap do
    0 i line>string 2over contains if  i .index  then
    break-key? if  exhaust  then
  loop  2drop  ;

( index-ilike )

need break-key?  need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    break-key? if  exhaust  then
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.

( words wordlist-words )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ XXX TODO -- pause with the space bar

need break-key?  need trail  need name>link  need tab

: words  ( -- )
  trail
  begin  dup 0<> break-key? 0= and  while
    dup id. tab  name>link @n
  repeat drop  ;

[unneeded] wordlist-words ?exit

: wordlist-words  ( wid -- )  >order  words  previous  ;

( words-like )

  \ Credits:
  \ Code adapted from pForth.

need break-key?  need trail  need name>link  need tab

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: words-like  ( "name" -- )
  \ Print all words (from the `context` vocabulary) containing a substring.
  parse-name 2dup uppers trail  ( ca len nfa )
  begin  dup 0<> break-key? 0= and  while
    dup >r
    name>string 2over contains if  r@ id. tab  then
    r> name>link @n
  repeat drop 2drop  ;

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr # " decimal dup . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s u.s )

  \ Credits:
  \ Code from Afera. Original algorithm from v.Forth.

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.

: .depth  ( n -- )  [char] < emit 0 .r [char] > space  ;

: .s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ . -2 +loop  then  ;

: u.s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ u. -2 +loop  then  ;

( possibly anew )

need marker

  \ Credits:
  \ Code adapted from Wil Baden.

  \ XXX TODO test

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ;

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

( marker ) \ second approach

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r
  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  set-order 0 do  2@ !  loop  ;

-->

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )  \ first approach

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ dp !  ;

-->

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT
  \ Code from eForth, for reference.

 \ : _MARKER ( -- ) ( R: dfa -- ) \ ???
 \   R> 2@ ( * ) DUP @ FOLLOWER !  DUP CONTEXT
 \   BEGIN >R CELL+ DUP @ DUP R@ ! WHILE R> CELL+ REPEAT ( search order )
 \   CELL+ DUP 2@ CURRENT 2!  CELL+ DUP @ ( cur wid & head )
 \   BEGIN >R  CELL+ DUP @ R@ !  R> CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   R> 2DROP ( * ) DP 2! ; COMPILE-ONLY

 \ : MARKER ( "name" -- ) \ ???
 \   ALIGN DP 2@ ( * ) FOLLOWER @ ,  CONTEXT
 \   BEGIN DUP @ DUP , WHILE CELL+ REPEAT  DROP ( search order )
 \   CURRENT 2@ , DUP , ( cur wid & head )
 \   BEGIN DUP @ , CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   ['] _MARKER : REVEAL COMPILE, ( * ) , , ;

( assert( )

  \ Credits:
  \ Code from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

( extend size system turnkey )

  \ XXX OLD
  \
  \ XXX WARNING -- Since name field addresses are saved in a
  \ memory bank, the best way to save a modified Forth system
  \ is to make a snapshot with the ZX Spectrum emulator;
  \ otherwise a multipart saving and loading would be needed.
  \ Anyway, these words are meant to save a Forth program that
  \ does not need to search the dictionary.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  \ XXX TODO -- update this word!

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 24 +origin !   \ `dp` init value
  \ XXX TODO -- change also the names pointer
  \ `voc-link` init value:
  [ ' forth >body 8 + ] literal 26 +origin !  ;

  \ size  ( -- u )
  \
  \ Size of the system.

: size  ( -- u )  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.

: turnkey  ( cfa -- a len )  boot defer! system  ;


  \ }}} =======================================================
  \ Control structures {{{

( 0if 0while 0until )  \ ==controlstructures==

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch >body ,
    \ jp z,branch_pfa ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( retry )

  \ Credits:
  \ Code of `retry` from an article by Richard Astle in
  \ Forth Dimensions 17/4 p. 36 (1995-11).

: retry  ( -- )
  latest name> >body postpone again
  ; immediate compile-only

: ?retry  ( run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

( base-execute )

  \ Credits:
  \ Word from Gforth.

: base-execute  ( cfa n -- )  base @ >r execute r> base !  ;
  \ Execute _cfa_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

( cs-pick cs-roll cs-swap cs-drop )

need alias need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this in the kernel:

  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value
  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

( begincase )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \ http://dxforth.netbay.com.au/cfsext.html

need cs-push  need cs-pop

: begincase
  postpone case  postpone begin  cs-push  ; immediate

: (nextcase)
  cs-pop  postpone again  postpone endcase  ; immediate

: nextcase
  postpone drop  postpone (nextcase)  ; immediate

: test
  begincase
    cr ." press a key ('2' '4' '9' exits) : " key
    [char] 2 of  ." ... 2 "  endof
    [char] 4 of  ." ... 4 "  endof
    [char] 9 of  ." ... 9 "  endof
      dup emit ."  try again"
  nextcase  ;

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX first version

  \ Credits:
  \ `(times)` was inspired by cmForth's `repeats`.

  \ XXX TODO
  \ code (times)  ( n -- )
  \   \ ld h,b
  \   \ ld l,c
  \   \ ld e,(hl)
  \   \ inc hl
  \   \ ld d,(hl) ; de = cfa to execute
  \   end-code

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 do  dup execute  loop  drop  ;
  \ XXX TODO ?do

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times) postpone [']  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX second version
  \ Immediate words are not allowed.

  \ Credits:
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 do  dup execute  loop  drop  ;
  \ XXX TODO ?do

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)
  defined ( nfa | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( cfa f )  -271 ?throw  compile,
  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX third version
  \ No check is done during compilation.

  \ Credits:
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 do  dup execute  loop  drop  ;
  \ XXX TODO ?do

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( ?? )

  \ Credits:
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nfa | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( cfa f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

( >l l> )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO create the leave stack; create the leave stack
  \ pointer as a user variable

  \ Credits:
  \ Code adapted from Z88 CamelForth.

code >l  ( x -- ) ( L: -- x )
  \ Move to leave stack.
  de pop
  lp hl fthl
  e m ld  hl incp  d m ld  hl incp
  hl lp sthl
  jpnext
  end-code

code l>  ( -- x ) ( L: x -- )
  \ Move from leave stack.
  lp hl fthl
  hl decp  m d ld  hl decp  m e ld
  hl lp sthl
  pushhl jp
  next

( do )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO adapt from hForth

: (do)  ( n1|u1 n2|u2 -- ) ( R: -- n1 n2-n1-0x8000 )
  >r $8000 + r> over - swap r> swap >r swap >r >r ;

  \ (do)  ( n1|u1 n2|u2 -- ) ( R: -- n1 n2-n1-0x8000 )
  \
  \ Run-time funtion of `do`.
  \
  \ 0x8000 is the maximum negative.

: do    ( n1|u1 n2|u2 -- )
  0 rakevar !  0      \ ?do-orig is 0 for do
  postpone (do)  here  bal+  \ do-dest
  ; immediate compile-only

  \ doc{
  \
  \ do
  \
  \ Compilation: ( C: -- do-sys )
  \
  \  Run-time: ( n1|u1 n2|u2 -- ) ( R: -- loop-sys )
  \
  \  Start a DO-LOOP structure in a colon definition. Place do-sys
  \  on control-flow stack, which will be resolved by `loop` or
  \  `+loop`.
  \
  \  Standard: Forth-94, Forth-2012
  \
  \  }doc

code (loop)  ( -- ) ( R: loop-sys1 -- | loop-sys2 )

    \ rp fthl
    \ m inc
    \ ; jr z,doloop2  ;12/7t a fast dec is ok, only
    \ db  doloop2-doloop1   ;      failed every 255 time
  \ doloop1   db  01ah  ; ld  a,(de)  ; 7t go back to the loop
    \ a l ld
    \ bc incp
    \ de ftap \ ld  a,(de)  ; 7t
    \ a h ld  \ db  067h  ; ld  h,a ; 4t
    \ next2 jp  \ $nexthl
 \ doloop2   db  023h  ; inc hl  ; 6t
    \ db  034h  ; inc (hl)  ;11t
    \ db  0e2h  ; jp po,doloop1 ;10/7t ?loop end
    \ dw  doloop1
    \ db  0ebh  ; ex  de,hl ; 4t yes,continue past the branch offset
    \ db  011h  ; ld  de,4  ;10t clear return stack
    \ dw  4
    \ db  0ddh,019h ; add ix,de ;15h
    \ db  023h  ; inc hl  ; 6t
    \ db  023h  ; inc hl  ; 6t
    \ next2 jp  \ $nexthl
    end-code

: loop  postpone (loop) rake  ; immediate compile-only

  \ loop
  \
  \ Compilation: ( C: do-sys -- )
  \ Run-time: ( -- ) ( R: loop-sys1 -- loop-sys2 )
  \ Terminate a DO|?DO ... LOOP structure. Resolve the destination
  \ of all unresolved occurences of LEAVE.
  \
  \ Standard: Forth-83, Forth-94, Forth-2012.

: +loop  postpone (+loop) rake  ; immediate compile-only

  \ +loop
  \
  \ Compilation: ( C: do-sys -- )
  \ Run-time: ( n -- ) ( R: loop-sys1 -- | loop-sys2 )
  \
  \ Terminate a `do +loop` structure. Resolve the destination of all
  \ unresolved occurences of `leave`.
  \ On execution add _n_ to the loop index. If loop index did not
  \ cross the boundary between loop_limit-1 and loop_limit,
  \ continue execution at the beginning of the loop. Otherwise,
  \ finish the loop.
  \
  \ Standard: Forth-83, Forth-94, Forth-2012.

( ?do )

  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ
  \ Draft by Rod Pemberton

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

: (do)  ( n1 n2 -- )  2>r  ;

: (?do) 2dup = if 2drop r> drop then  ;
  \ exit the calling word

: (loop)  ;
  ( increments index -2nd item- on return stack)
  ( calculates flag for until )

: (+loop)  ;

: do      postpone (do) postpone begin
  ; immediate compile-only

: ?do     postpone (?do) postpone (do) postpone begin
  ; immediate compile-only

: loop    postpone (loop) postpone until postpone unloop
  ; immediate compile-only

: +loop   postpone (+loop) postpone until postpone unloop
  ; immediate compile-only

  \ : unloop
  \   ( removes 2nd and 3rd return stack items )
  \   ( 1st return stack item is itc saved ip for unloop )  ;
  \ : i ( gets 2nd return stack item to data stack )  ;
  \ : j ( gets 4th ... )  ;
  \ : k ( gets 6th ... )  ;

( ?do )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ Draft by Elisabeth Rather.

: do ( -- flag addr)
  postpone (do) 0   postpone begin  ; immediate compile-only

: ?do ( -- addr1 flag addr2)
    postpone (?do) postpone begin
    postpone (do) 1   postpone begin  ; immediate compile-only

  \ ...where (DO) and (?DO) are the run-time actions. (?DO)
  \ contains a forward branch which compile-time LOOP or +LOOP
  \ must resolve.    (BEGIN) leaves on the compile-time stack an
  \ address for LOOP or +LOOP to branch back to, and a flag.

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

variable ?do?

: exchange ( x1 addr -- x2 ) dup @ rot rot !  ;
: 2dup<> ( x1 x2 -- x1 x2 flag ) 2dup = 0=  ;

: do
  postpone 2>r 0 ?do? exchange <mark
  ; immediate compile-only
: ?do
  postpone 2dup<> postpone if postpone do ?do? on
  ; immediate compile-only
: loop
  postpone (loop) <resolve ?do? exchange if postpone then then
  ; immediate compile-only
: +loop
  postpone (+loop) <resolve ?do? exchange if postpone then then
  ; immediate compile-only

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

variable ?do?

: 2dup= ( x1 x2 -- x1 x2 flag )  2dup =  ;

: do
  ?do? @ ?do? off [compile] (do) >mark
  ; immediate compile-only

: ?do
  postpone 2dup= postpone if postpone do ?do? on
  ; immediate compile-only

: complete-?do ( x dest | x -- )
  ?do? @ if postpone then then ?do? !  ;

: loop postpone (loop) <resolve complete-?do
  ; immediate compile-only

: +loop postpone (+loop) <resolve complete-?do
  ; immediate compile-only

( ?dov dov loopv +loopv )

  \ Credits:
  \ Code from v.Forth.

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO adapt

: dov
  compile (do) csp @ !csp here 3  ; immediate compile-only

: ?dov
  compile 2dup  compile (do)  compile <>
  postpone if
  2drop here swap 1 6  ; immediate compile-only

: (resolve)
  begin  sp@ csp @ -  while  2 postpone then  repeat  csp !
  ; immediate compile-only

: loopv
  postpone (loop) (resolve)  ; immediate compile-only

: +loopv
  postpone (+loop) (resolve)  ; immediate compile-only

( j )

code j
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 2 cells , \ ld de,2*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( k )

code k
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the third loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 4 cells , \ ld de,4*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( i' )

code i'  ( -- x )
         ( R: loop-sys -- loop-sys )

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,        \ ld hl,(return_stack_pointer)
  23 c,             \ inc hl
  23 c,             \ inc hl
  C3 c, fetchhl ,   \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 3 cells , \ ld de,3*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( k' )

code k'
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the second next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 5 cells , \ ld de,5*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( for step )

  \ Credits:
  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch >body ,
    \ jp nz,branch_pfa ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( u -- )
  \
  \ Start of a `for step` loop, that will iterate _u+1_ times,
  \ starting with _u_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `i`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

( dfor dstep di )

: (dstep)  ( R: x ud -- x ud' )

  \ doc{
  \
  \ (dstep)  ( R: x ud -- x ud' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( ud -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest )
  \ Run-time: ( ud -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `di`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

: di  ( -- ud )  ( R: x ud -- x ud )
  r> 2r@ rot >r  ;

  \ doc{
  \
  \ di  ( -- ud )  ( R: x ud -- x ud )
  \
  \ Return the current index _ud_ of a `dfor` loop.
  \
  \ }doc

( case )

  \ Credits:
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop  begin  ?dup  while  [compile] then  repeat
  ; immediate compile-only

( case )  \ baden-case )

  \ An alternative `case` structure that makes any
  \ calculation easier.

  \ 2015-11-15

  \ Credits:
  \
  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

  \ XXX TODO rename, avoid standard names: `case`, `of`,
  \ `endof`.

defer case  ( n -- n n )  ' dup ' case defer!
defer othercase  ( n -- )  ' drop ' othercase defer!

: of  ( n f -- )
  postpone if  postpone drop  ; immediate compile-only

: endof  ( n f -- )
  postpone exit  postpone then  ; immediate compile-only  exit

  \ Usage example

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;

  \ : test  ( n -- )
  \   case 0 = of  say0  endof
  \   case 1 = of  say1  endof
  \   case 2 = of  say2  endof
  \            othercase say-other  ;
  \ ----

( case )  \ eforth-case )

  \ Credits:
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  [compile] then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( case )  \ 94-doc-case )

  \ Credits:
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  \ XXX TODO use `?do` when available
  postpone drop  \ discard case value
  0 do  postpone then  loop  ; immediate compile-only

( case )  \ abersoft-case )

  \ Credits:
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credits:
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credits:
  \ Code from Galope.

[defined] nup ?\  : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credits:
  \ Code from Galope.

[defined] nup ?\  : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credits:
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credits:
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID:
  \ <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credits:
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credits:
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

need -rot

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 wf )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 wf )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Punctuation "        else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  char a  .(   ) dup emit  select-test
cr  char ,  .(   ) dup emit  select-test
cr  char 8  .(   ) dup emit  select-test
cr  char ?  .(   ) dup emit  select-test
cr  char K  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ Create a word that will return the address of its pfa.
  \
  \ The idea for this word was borrowed from CP/M-volksForth
  \ 3.80a.

( case: )

  \ Credits:
  \ Code adapted from F83.

need create:

: case:  ( "name" -- )
  \ Create a positional case word.
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;
  \ A positional case statement.  At runtime, the n-th word is
  \ executed, depending upon the value on the stack. No
  \ range checking.

  \ Usage example:
  \
  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

( cases: )

  \ `cases:` structure, alternative to the standard `case`.
  \ It saves space, but is slower.

  \ 2015-11-15

  \ Credits:
  \
  \ Adapted, renamed and commented from code written by Dan
  \ Lerner, published on Forth Dimensions (volume 3, number 6,
  \ page 189, 1982-03).

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  exhaust
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>  say10
  \    100 case>  say100
  \   1000 case>  say1000
  \        other> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: other>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ XXX TODO -- rename? `anycase>`, `othercase>`...

  \ doc{
  \
  \ other>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required, `other>
  \ noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

( options[ )

  \ Credits:
  \ `options[` is a port of IsForth's `case:`.

  \ Note: in the original IsForth code the word `(options`)
  \ (called `docase` in IsForth) is written in x86 assembler. I
  \ rewrote it from scratch, without investigating the
  \ assembler code.

  \ XXX TODO alternative version `coptions[`

  \ 166 bytes used.

variable (default-option)
  \ default option cfa

variable #options
  \ number of compiled options

: default-option ( "name" -- )  ' (default-option) !  ;
  \ Set the default option.
  \ It can go anywhere inside a the options statement.

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option cfa
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  exhaust then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

( options[ )

: options[  ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of default option cfa
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ number of options is 0 so far
  compile (options)           \ compile run time handler
  >mark >mark >mark  ( a1 a2 a3 )
  postpone [  ; immediate compile-only

  \ doc{
  \
  \ options[  ( -- )
  \
  \ Start an `options[` structure.

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  \ Compile an option _x_ and the cfa of its action "name".
  ,  ' ,  1 #options +!  ;

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option cfa
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option cfa
  >resolve                    \ store exit point
  ]  ;

( executions )

  \ Credits:
  \ Code from Galope (module times.fs).

: executions  ( cfa n -- )
  \ Execute _cfa_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \ Adapted from:
  \ Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03
  \ Listing in "Towards a Discipline of ANS Forth Programming"
  \ Originally published in Forth Dimensions XVIII, No.4, pp5-14
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 do  postpone then  loop  ; immediate compile-only
  \ end a conditional
  \ XXX TODO use `?do` when available

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \ Adapted from:
  \ Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03
  \ Listing in "Towards a Discipline of ANS Forth Programming"
  \ Originally published in Forth Dimensions XVIII, No.4, pp5-14
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ }}} =======================================================
  \ Keyboard {{{

( xaccept )  \ ==keyboard==

  \ XXX TODO -- accept

  \ Credits:
  \ Code adapted from eForth.

  \ XXX TODO show cursor
  \
  \ XXX TODO compare with the kernel version and move the best
  \ version to the kernel (probably this one)

: xaccept ( ca len -- len )
  over + over ( bot eot cur )
  begin xkey dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

( nuf? )

  \ Credits:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29).

need aborted?

[defined] 'cr' ?\ 13 constant 'cr' \ code of carriage return

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Ther return _true_ if
  \ it's _c_, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( inkey )

  \ Credits:
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

( key?? )

  \ An alternative to `key?` that works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true >body jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false >body jp

  end-code

( key?? )

  \ An alternative to `key?` that works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true >body jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false >body jp

  end-code

( y/n? y/n yes? no? )

  \ Credits:
  \ Code adapted from Afera.

need value

char Y value "y"  char N value "n"
  \ Default (uppercase) letters for "yes" and "no".

: y/n?  ( c -- f )  dup "y" = swap "n" = or  ;
  \ Is the given (uppercase) char _c_
  \ a valid answer for a "y/n" question?

: y/n  ( -- c )
  begin  key upper dup y/n? 0=  while  drop  repeat  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return its code.

: no?  ( -- f )  y/n "n" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "no",
  \ else return _false_.

: yes?  ( -- f )  y/n "y" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "yes",
  \ else return _false_.

( Keyboard rows ports)

  \ From Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \ -----------------------------------------------------------


( k-table k, k@ )

  \ There are two versions of `k,` and `k@`. They depend on the
  \ value of `/k`, a constant that holds the bytes ocuppied by
  \ every key in `k-table`, 3 or 4.
  \
  \ The application must define `/k` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/k 3 = dup

?\ : k,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : k@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `k@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/k 4 = dup

?\ : k,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : k@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( k-table )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant k-1  $02 $F7FE 2constant k-2
$04 $F7FE 2constant k-3  $08 $F7FE 2constant k-4
$10 $F7FE 2constant k-5

$01 $FBFE 2constant k-q  $02 $FBFE 2constant k-w
$04 $FBFE 2constant k-e  $08 $FBFE 2constant k-r
$10 $FBFE 2constant k-t

$01 $FDFE 2constant k-a  $02 $FDFE 2constant k-s
$04 $FDFE 2constant k-d  $08 $FDFE 2constant k-f
$10 $FDFE 2constant k-g

$01 $FDFE 2constant k-cs  $02 $FDFE 2constant k-z
$04 $FDFE 2constant k-x   $08 $FDFE 2constant k-c
$10 $FDFE 2constant k-v

-->

( k-table )

$01 $EFFE 2constant k-0  $02 $EFFE 2constant k-9
$04 $EFFE 2constant k-8  $08 $EFFE 2constant k-7
$10 $EFFE 2constant k-6

$01 $DFFE 2constant k-p  $02 $DFFE 2constant k-o
$04 $DFFE 2constant k-i  $08 $DFFE 2constant k-u
$10 $DFFE 2constant k-y

$01 $BFFE 2constant k-en  $02 $BFFE 2constant k-l
$04 $BFFE 2constant k-k   $08 $BFFE 2constant k-j
$10 $BFFE 2constant k-h

$01 $7FFE 2constant k-sp $02 $7FFE 2constant k-ss
$04 $7FFE 2constant k-m  $08 $7FFE 2constant k-n
$10 $7FFE 2constant k-b

-->

( k-table )

need k,

40 constant keys

create k-table

k-1 k, k-2 k, k-3 k, k-4 k, k-5 k, k-q k, k-w k, k-e k, k-r k,
k-t k, k-a k, k-s k, k-d k, k-f k, k-g k, k-cs k, k-z k, k-x k,
k-c k, k-v k, k-0 k, k-9 k, k-8 k, k-7 k, k-6 k, k-p k, k-o k,
k-i k, k-u k, k-y k, k-en k, k-l k, k-k k, k-j k, k-h k,
k-sp k, k-ss k, k-m k, k-n k, k-b k,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need k-table

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ k-table keys /k * bounds swap ] literal literal
  do  i k@ pressed? if  drop i k@ 1 exhaust  then  /k +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need k-table

0. 2variable k-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. k-pressed 2! \ none by default
  [ k-table keys /k * bounds swap ] literal literal
  do  i k@ pressed?
  if  k-pressed 2@ + if
  then
  /k +loop
  k-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ }}} =======================================================
  \ Hardware {{{

( @p )  \ ==hardware==

code @p  ( ca -- c )

  \ Input char _c_ from port _ca_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  C3 c, pushhl ,  \ jp pushhl
  end-code

( !p )

code !p  ( c ca -- )

  \ Output char _c_ to port _ca_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  end-code

  \ }}} =======================================================
  \ Number conversion and notation {{{

( b# d# h# )  ==numberconversion==

  \ Credits:
  \ Code adapted from eForth.

  \ XXX TODO -- finish the conversion

: x# ( -- ) ( "ccc" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate

( c# )

  \ Credits:
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate
  \ Parse a name and return the code of the its first
  \ character. This is an alternative to `char` and `[char]`.

  \ }}} =======================================================
  \ Data structures {{{

( associative: )  \ ==datastructures==

  \ Credits:
  \ Code adapted from F83.

need -rot

: associative:  ( n -- )
  \ Create a table lookup word.
  \ n = number of entries in the table
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \
  \ 1000 constant zx1  200 constant zx2  30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

( associative-list )

  \ Credits:
  \ Based on code written by Wil Baden, published in:
  \ Forth Dimensions Volume XVII number 4 page 11.

  \ XXX UNDER DEVELOPMENT

need words  need abort"

: associative-list  ( "name" -- )  wordlist constant  ;

: entry  ( ca len wid "name" -- )
  current @ >r current !  create  s,  r> current !
  does>  ( -- ca len )  ( pfa ) count  ;

: item?  ( ca len -- 0 | cfa )
  search-wordlist dup if  drop  then  ;

: item  ( ca1 len1 wid -- ca2 len2 )
  item? dup 0= abort" Not an item." execute  ;

: items  ( wid -- )  >order words previous  ;

( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

( buffer: cvariable )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;

( value to )

  \ Standard: Forth-94.

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone !
                     else  !  then  ; immediate

( 2value 2to )

  \ Implementation of `2value` (from Forth-2012) but with
  \ the non-standard word `2to`

: 2value  ( d "name"  -- )  2constant  ;

: 2to  ( Interpretation: d "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone 2!
                     else  2!  then  ; immediate

( cvalue cto )

: cvalue  ( b "name"  -- )  cconstant  ;

: cto  ( Interpretation: b "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone c!
                       else  c!  then  ; immediate

( value 2value to )

  \ Standard: Forth-2012.

  \ This Forth-2012 implementation of `to` is provided as an
  \ alternative, but it's bigger and slower than the Forth-94
  \ `to` and the non-standard `2to`.

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;
: 2value  ( n "name"  -- )  create  1 c, , ,  does> 1+ 2@  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

( value to )

  \ Non-standard implementation of `value` with non-parsing
  \ `to`. This could be useful in special cases.

  \ Credits:
  \ Code inspired by lina.

variable (value)  ['] @ (value) !
: to    ( -- )  ['] ! (value) !  ;
: value  ( n "name" -- )
  create ,  does>   (value) perform  ['] @ (value) !  ;

( set )

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

  \ doc{
  \
  \ set  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will  cause  the
  \ value _x_  to be stored at _a_.
  \
  \ Standard: Forth-79 (Reference Word Set); Forth-83 (Appendix
  \ B.  Uncontrolled Reference Words).
  \
  \ }doc

( link@ link, )

  \ 2015-11-15

  \ Credits:
  \
  \ Code written after the description by Rick VanNorman,
  \ published on Forth Dimensions (volume 20, number 3, pages
  \ 19..22, 1998-09).

defer link@  ( node1 -- node2 )
  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

( [switch switch] )

  \ 2015-11-15

  \ Credits:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default cfa
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched cfa. If no match is found, leave _n_ on
  \ the stack and execute the default cfa.

: :switch  ( cfa "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _cfa_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head cfa n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _cfa_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the cfa of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

: run:  ( head n "text<;>" -- )
  :noname [char] ; parse evaluate postpone ; ( cfa )
  swap >switch  ;

( [switch-test ) \ without syntactic sugar

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test ) \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( user )

  \ XXX UNDER DEVELOPMENT -- improved version, which uses the
  \ first free offset.

  \ doc{
  \
  \ user  ( +n "name" -- )
  \
  \ Create a user variable _name_.  _+n_ is the offset within
  \ the user area where the value for _name_ is stored.
  \ Execution of _name_ leaves its absolute user area storage
  \ address.
  \
  \ Standard: Forth-79, Forth-83.
  \
  \ }doc

: user  ( n "name -- )
  create c,  does>  c@ up @ +  ;

exit

: user  ( n "name -- )
  cconstant
  ;code asm
  de incp  \ de=pfa
  exde
  m e ld
  00 d ld#  \ de = index of the user variable
  up fthl \ ld hl,(user_variables_pointer) \ XXX FIXME
  de addp  \ hl= address of the user variable
  pushhl jp end-asm

( 1array ) \ noble-arrays

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble

  \ 2015-11-15

  \ ---------------------------------------------------
  \ (c) Copyright 2001 Julian V. Noble. \
  \ Permission is granted by the author to \
  \ use this software for any application pro- \
  \ vided this copyright notice is preserved. \
  \ ---------------------------------------------------

  \ ...........................................................
  \ References:
  \
  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ ...........................................................
  \ Description:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ Implementation:

  \ words for 1-dimensional arrays

need <=

: long ; immediate

: 1array ( len #bytes/datum --) \ ( #b len data ...)
  create 2dup , , * allot ;

: _len ( base_addr -- len)  cell+ @ ;
  \ determine length of an array

: } ( base_adr indx -- adr[indx] )
  over _len over <= over 0< or #-272 ?throw
    \ #-272 = array index out of range
  over @ * + cell+ cell+ ;

( 2array ) \ noble-arrays

  \ words for 2-dimensional arrays

need 1array

: wide ; immediate

: 2array ( hgt wid data_size --) \ ( wid #b len data ...)
  create >r tuck , ( wid hgt)
  r@ , * dup , r> * allot ;

: }} ( base_adr m n -- adr[m,n] ) \ data stored row-wise
  2>r cell+ dup cell- @
  r> * r> + ( base_adr+cell m+n*w)
  } ;

  \ ...........................................................
  \ Usage examples:

  \ 20 long 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 long 20 wide 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 long 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

( array ato ) \ wong-arrays )

  \ One-dimensional arrays by Leo Wong

  \ 2015-11-15

  \ ...........................................................
  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ ...........................................................
  \ Description:

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ ...........................................................
  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of array array> ato +ato. A Flight
  \ scripter would not be expected to implement these words.

  \ ...........................................................
  \ Sample implementation:

need within

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

( xstack )

  \ Credits:
  \ Code adapted from Galope (xstack module).

  \ Creation and core manipulation of xstacks

need value  need allocate  need free

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- )
    \ Make an xstack the current one.
    ( pfa ) dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: xfree  ( -- )  xp0 free throw  ;

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

need xstack

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( x2@ 2>x 2x> x2drop x2dup )

  \ xstack double-number operations

need xstack  need x@  need >x  need xpick  need xover

: x2@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: x2drop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: x2dup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xdepth .x )

  \ xstack tools

need xstack

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the right-most item.
: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack,
  \ followed by a list of the items; TOS is the right-most item.

  \ }}} =======================================================
  \ Environmental queries {{{

( environment? )

need wid-of

vocabulary environment ( -- )
wid-of environment constant environment-wordlist ( -- wid )
  \ Wordlist that is searched by environmental queries.

: environment? ( ca len -- false | i*x true )
  environment-wordlist search-wordlist
  if  execute true  else  false  then  ;

also environment definitions

8 constant address-unit-bits ( -- n )
  \ Size of one address unit, in bits.

255 constant max-char ( -- u )
  \ Maximum value of any character in the character set.

255 constant /counted-string ( -- n )
  \ Maximum size of a counted string, in characters.

  \ XXX TODO
address-unit-bits cells 2* 2+ constant /hold ( -- n )
  \ Size of the pictured numeric string output buffer, in
  \ characters.

  \ XXX TODO calculate
84 constant /pad ( -- n )
  \ Size of the scratch area pointed to by `pad`, in
  \ characters.

1 -3 mod 0< constant floored ( -- f )
  \ True if `/` etc. perform floored division

-->

( environment? )

32767 constant max-n ( -- n )
  \ Largest usable signed integer.

-1 constant max-u ( -- u )
  \ Largest usable unsigned integer.

-1 max-n 2constant max-d ( -- d )
  \ Largest usable signed double.

-1. 2constant max-ud ( -- ud )
  \ Largest usable unsigned double.

  \ XXX TODO -- calculate
$50 constant return-stack-cells ( -- n )
  \ : return-stack-cells ( -- n )
    \ [ forthstart 6 cells + ] literal @ cell / ;
    \ Maximum size of the return stack, in cells.

  \ XXX TODO -- calculate
$50 constant stack-cells ( -- n )
  \ : stack-cells ( -- n )
    \ [ forthstart 4 cells + ] literal @ cell / ;
    \ Maximum size of the data stack, in cells.

  \ XXX TODO -- add "#locals" when needed

forth definitions  previous

  \ }}} =======================================================
  \ Multitask {{{

( jiffy! jiffy@ -jiffy )

  \ Note: This code is specific for G+DOS.

  \ Credits:
  \ Idea inspired by an article by Paul King, published in
  \ Format, vol. 2 no. 3 (1988-10).
  \ XXX TODO link to the WoS archive ftp, when available

need !dosvar  need @dosvar

: jiffy!  ( a -- )  16 !dosvar  ;
  \ Set the Z80 routine to be called by G+DOS after the OS
  \ interrupts routine, every 50th of a second.

: jiffy@  ( -- a )  16 @dosvar  ;
  \ Get the current Z80 routine that is called by G+DOS after
  \ the OS interrupts routine, every 50th of a second.

: -jiffy  ( -- )  8335 jiffy!  ;
  \ Deactivate the jiffy call, setting its default value
  \ (a noop routine in the RAM of the +D interface).



  \ }}} =======================================================
  \ Locals {{{

( local restore-local )

  \ A simple solution to use an ordinary variable as local,
  \ saving its current value on the return stack and restoring
  \ it at the end.

  \ 2015-11-14

  \ Credits:
  \
  \ Original code by Henning Hanseng, published on Forth
  \ Dimensions 9/5 p. 6 (1988-01).

: restore-local  ( -- )  ( R: a x -- )  2r> swap !  ;
  \ a = address of a variable
  \ x = its original value
  \ Restore variable address and value.

: local  ( a0 -- )  ( R: a1 -- a0 x pfa a1 )
  \ a0 = address of a variable
  \ x = its current value
  \ a1 = return address
  \ pfa = pfa of `restore-local`
  r> swap                     \ save top return address
  dup @ 2>r                   \ save variable address and value
  ['] restore-local >body >r  \ force exit via `restore-local`
  >r  ;                       \ restore top return address

  \ Usage example:
  \
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value

( local restore-local )

  \ A simple solution to use an ordinary variable or value as
  \ local, saving its current value on the return stack and
  \ restoring it at the end.

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-14: Start.

  \ Credits:
  \
  \ Original code by Michael Barr, published on Forth
  \ Dimensions 10/1 p. 6 (1988-05).

code (restore-local)
  \ XXX TODO
  jpnext
  end-code

: restore-local
  (restore-local)  ;

code (local)  ( a0 -- )  ( R: a1 -- a0 x pfa a1 )
  \ a0 = address of a variable
  \ x = its current value
  \ a1 = return address
  \ pfa = pfa of `restore-local`
  \ XXX TODO
  jpnext
  end-code

: local  ( "name" -- )
  ' >body postpone literal postpone (local)
  ; immediate compile-only

  \ Usage example:
  \
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value

( arguments results )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-14: Start.

  \ Credits:
  \ Original code by Marc Perkel, published on
  \ Forth Dimensions 3/6 p. 6 (1982-03).

need 2/

variable >args
  \ address of the current arguments in the data stack
variable arg-action
  \ id of the argument action (fetch, store or add)

: arg:  ( n "name" -- )
  create  ,
  does>  ( a -- x ) ( x a -- )
    \ ( a pfa | x a pfa )
    @ >args @ swap -
    arg-action @ ?dup if    0< if  +!  else  !  then
                      else  @
                      then  arg-action off  ;
  \ create a new argument

$00 arg: s0 $02 arg: s1 $04 arg: s2 $06 arg: s3 $08 arg: s4
$0A arg: s5 $0C arg: s6 $0E arg: s7 $0A arg: s8 $0C arg: s9

: to  ( -- )  1 arg-action !  ;
  \ set the store action

: +to  ( -- )  -1 arg-action !  ;
  \ set the add action

-->

( arguments results )

  \ XXX OLD -- original
  \ : arguments  ( n -- )
  \   r> >args @ >r >r  \ save the contents of `>args`
  \   cells sp@ + dup >args ! 12 - sp@ swap -
  \   2/ 0 do  0  loop  arg-action !  ;

  : arguments  ( n -- )
  r> >args @ >r >r        \ save `>args`
  cells sp@ + dup >args ! 12 - sp@ swap -
  2/ 0 do  0  loop  arg-action !  ;

: results  ( n -- )
  cells >args @ swap - sp@ -
  2/ 0 do drop loop
  r> r> >args ! >r  ;     \ restore `>args`

-->

( arguments results )

  \ test

: test  ( n1 n2 n3 -- )
  cr ." check 1" .s \ XXX INFORMER
  3 arguments
  cr ." check 2" .s \ XXX INFORMER
  s0 s1 s2 * * to s4
  s0 s1 s2 + + to s5
  s5 to s2
  s4 to s1
  cr ." check 3" .s \ XXX INFORMER
  2 results
  cr ." check 4" .s \ XXX INFORMER
  ;

( create-anon anon +anon n>anon )

  \ Anonymous variables.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted, modified, improved and commented from original
  \ code written by Leonard Morgenstern, published on Forth
  \ Dimensions 6/1 p. 33 (1984-05).

variable (anon)  ( -- a )
  \ cfa of the latest anonymous variable.

: create-anon  ( -- )
  here (anon) !
  [ (anon) body> @ ] literal compile, 0 ,  ;
  \ Create a new anonymous variable.  `(anon)` is used to get
  \ and compile the cfa executed by all variables.

: anon  ( Compilation: -- ) ( Run-time: -- a )
  (anon) @
  compiling? if  compile,  else  execute  then  ; immediate
  \ Current anonymous variable (first cell),
  \ equivalent to `0 +anon`.

: +anon  ( Compilation:  n -- ) ( Run-time: -- )
  cells (anon) @ execute +
  compiling? if  postpone literal  then ; immediate
  \ Current anonymous variable (cell _n_, first is 0).

: n>anon  ( x1..xn n -- )
  cells postpone anon swap bounds do  i !  cell +loop  ;
  \ Store the given _n_ cells into the current anonymous
  \ variable.

  \ Usage example:

  \ create-anon 5 cells allot
  \
  \ : test
  \   400 300 200 100 000  5 n>anon
  \   anon ?          \ prints 0
  \   123 anon !
  \   anon ?          \ prints 123
  \   [ 2 ] +anon ?   \ prints 200
  \   555 [ 2 ] +anon !
  \   [ 2 ] +anon ?   \ prints 555
  \   ;

( { } )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO -- this depends on `(local)` and `refill`

  \ XXX TODO -- an alternative implementation with string
  \ comparisons is in the Forth-2012 documentation, but a
  \ dictionary search seems a better option.

  \ Credits:
  \ Code adapted from pForth.

  \ ____
  \
  \ @(#) $M$ 98/01/26 1.2 standard { v0 v1 ... vn | l0 l1 .. lm
  \ -- } syntax based on ANSI basis words (LOCAL) and TO
  \
  \ Author: Phil Burk Copyright 1994 3DO, Phil Burk, Larry
  \ Polansky, Devid Rosenboom
  \
  \ The pForth software code is dedicated to the public domain,
  \ and any third party may reproduce, distribute and modify
  \ the pForth software code or any derivative works thereof
  \ without any compensation or license.  The pForth software
  \ code is provided on an "as is" basis without any warranty
  \ of any kind, including, without limitation, the implied
  \ warranties of merchantability and fitness for a particular
  \ purpose and their equivalents under the laws of any
  \ jurisdiction.
  \
  \ MOD: PLB 2/11/00 Allow EOL and \ between { }.  ____

need privatize

private{
variable loc-temp-mode
  \ if true, declaring temporary variables
variable loc-comment-mode
  \ if true, in comment section
variable loc-done
}private

-->

( { } )

: {  ( <local-declaration}> -- )
  loc-done off  loc-temp-mode off  loc-comment-mode off
  begin
    parse-name dup 0>  \ not at the end of a line?
    if
      over c@ case
        \ handle special characters

        [char] }  of  loc-done on          2drop  endof
        [char] |  of  loc-temp-mode on     2drop  endof
        [char] -  of  loc-comment-mode on  2drop  endof
        [char] )  of  ." { ... ) imbalance!" cr abort  endof
        [char] \  of  postpone \
                      2drop endof

        -->

( { } )

        \ process name
        >r  \ save char
        ( addr len ) loc-comment-mode @
        if  2drop else  loc-temp-mode @ if  compile false  then
          \ if in temporary mode, assign local var = 0
          \ otherwise take value from stack
          (local)
        then  r>

      endcase

    else  2drop refill 0=
          abort" end of input while defining local variables!"

    then  loc-done @

  until  0 0 (local)  ; immediate  privatize

( {}-tests )

  \ tests

: tlv1  { n -- }  n  dup n *  dup n *  ;

: tlv2 { v1 v2 | l1 l2 -- }
  v1 . v2 . cr
  v1 v2 + -> l1
  l1 . l2 . cr
  ;

  \ }}} =======================================================
  \ Time {{{

( ms )  \ ==time==

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Standard: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

[defined] sys-frames ?\ 23672 constant sys-frames

: frames@  ( -- d )
  sys-frames @ [ sys-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ sys-frames 2+ ] literal c! sys-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-cfa  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-cfa  hl pop  execute-hl
      \ execute the cfa hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-cfa

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-cfa
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but it's current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the cfa hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the cfa hold in `(wait)`:

    ' (wait) >body fthl
    here 6 + bc ldp# \ point IP to phony_compiled_word
    next2 jp  \ execute the cfa in `(wait)`
    \ phony_compiled_word:
    here cell+ ,  \ point to the phony cfa following
    here cell+ ,  \ phony cfa, point to the code following

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `pause` has to be modified.

( just-pause )

  \ Credits:
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credits:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

  \ XXX TODO -- adapt when baden-case is modified

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit then
  dup 100 mod 0= if  drop false  exit then
        4 mod 0= if       false  exit then
  false  ;

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

  \ }}} =======================================================
  \ Vocabularies {{{

( .context .current order vocs )  \ ==vocabularies==

  \ Credits:
  \ Code adapted from F83.

need body>name

  \ XXX FIXME -- this fails with wordlists, because they don't
  \ have a name
: .context  ( -- )
  context #vocs 0 do
    dup @ ?dup if  body>name id.  then  cell+
  loop drop  ;
  \ Display the search order currently in effect.

: .current  ( -- )  current @ body>name id.  ;
  \ Display the name of the `current` vocabulary.

: order  ( -- )
  cr ." context: " .context cr ." current: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

: vocs  ( -- )
  voc-link @
  begin  dup cell - body>name id.  @ dup 0= until  drop  ;
  \ List all of the vocabularies that have been defined so
  \ far, in the order of their definition (more recent first).

( get-order )

  \ XXX TODO use the actual number of vocs in context, not
  \ the maximum

: (get-order)  ( n -- widn..wid1 n)
  \ Do get the search order.
  1- -1 swap do  context i cells + @  -1 +loop  ;

: get-order  ( -- 0 | widn..wid1 n)
  \ Get the search order.
  #vocs ?dup if  (get-order)  then  #vocs  ;

( set-order )

  \ XXX TODO use the actual number of vocs in context, not
  \ the maximum

  \ XXX TODO move to the kernel

get-current also root definitions

: (set-order)  ( widn..wid1 n -- )
  \ Do set a search order.
  0 do  context i cells + !  loop  ;

: set-order  ( -1 | 0 | widn..wid1 n -- )
  \ Set a search order.
  dup -1 =  if  drop only exit  then  -order
  ?dup if  (set-order)  then  ;

previous set-current

  \ doc{
  \
  \ set-order  ( -1 | 0 | widn..wid1 n -- )
  \
  \ Set the search order to the word lists identified by
  \ _widn..wid1_. Subsequently, word list _wid1_ will be
  \ searched first, and word list _widn_ searched last. If _n_
  \ is zero, empty the search order. If _n_ is minus one, set
  \ the search order to the implementation-defined minimum
  \ search order.
  \
  \ This word is defined in Forth-94 but its implementation in
  \ Solo Forth is not fully Forth-94 compliant.
  \
  \ }doc

( wid-of wid> >wid )

  \ Credits:
  \ Code of `wid-of` adapted from eForth's `widof`.

: wid>  ( wid -- cfa )  body>  ;
  \ Convert a _wid_ to the _cfa_ of its vocabulary.
  \ XXX TODO confirm this description

: >wid  ( cfa -- wid )  >body  ;
  \ Convert the _cfa_ of a vocabulary to its _wid_.

: wid-of  ( "name" -- wid )  ' >wid  ;

( swap-current trail >order )

[unneeded] trail
?\ : trail  ( -- nfa )  context @ @  ;

  \ doc{
  \
  \ trail ( -- nfa )
  \
  \ Leave the name field address of the topmost word in the
  \ `context` vocabulary.
  \
  \ }doc

[unneeded] swap-current ?\ exit
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ;

  \ Credits:
  \
  \ Idea from lpForth.

  \ }}} =======================================================
  \ Random number generators {{{

( seed rnd random randomize )  \ ==rng==

  \ Credits:
  \ Code adapted from Leo Brodie's code and Gforth.

[defined] seed ?\ 23670 constant seed  \ system variable

: rnd  ( -- n )  seed @ 31421 * 6927 + dup seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

: randomize  ( n -- )  seed !  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).


( random-tt )

  \ Credits:
  \
  \ Code from tt.pfe  Tetris for terminals, redone in
  \ ANSI-Forth.  Written 05Apr94 by Dirk Uwe Zoller, e-mail duz
  \ AT roxi DOT rz DOT fht-mannheim DOT de.

[defined] seed ?\ 23670 constant seed  \ system variable

: random-tt   ( n -- 0..n-1 )
    seed @ 13 * $07FFF and
    dup seed !  swap mod ;

( random-b )

code random-b  ( -- b )
  \ XXX FIXME this returns patterns; see `random-b-test`
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

( ace-rnd )

  \ Credits:
  \ Adapted from ACE Forth, as of the Jupiter ACE manual.

[defined] seed        ?\ 23670 constant seed
[defined] sys-frames  ?\ 23672 constant sys-frames
  \ system variables

: seedon  ( -- n )
  \ XXX FIXME
  seed @ 75 um* d>s 75 0 d+ 2dup u< - - 1- dup seed !  ;

: rnd  ( n1 -- n2 )  seedon um* d>s swap drop  ;

: randomize  ( n -- )
  ?dup 0=  if  sys-frames @  then  seed !  ;

( v.Forth pseudo random number generator )

  \ Credits:
  \ Code from v.Forth.

  \ XXX TODO adapt and try

[defined] seed ?\ 23670 constant seed

  : vrnd  ( n1 -- n2 )
    1+ 8195 23672 @ um* 1 0 d+
    16383 u/ drop dup seed !
    swap mod  ;

( random-n )

  \ Credits:
  \ Adapted from code written by Jos Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

[defined] seed
?\ 23670 constant seed  \ system variable

code random-n  ( -- x )

  \ Return a random number (0000..FFFF)

  \ XXX FIXME this returns patterns; see `random-n-test`

  seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  seed sthl
  pushhl jp
  end-code

( z88random )

  \ XXX UNDER DEVELOPMENT

  \ Credits:
  \ Code adapted from Z88 CamelForth.

[defined] seed
?\ 23670 constant seed  \ system variable

  \ XXX TODO adapt.
: z88random  ( u1 -- u2 )
  20077 16838 seed @
  ud* 12345 0 d+ over seed !
  rot ud/mod 2drop  ;

( random-test random-b-test random-n-test )

need set-pixel

need random

: random-test  ( n -- )
  cls  0 do  256 random 193 random set-pixel  loop  ;

need random-b

: random-b-test  ( n -- )
  cls  0 do  random-b random-b 192 min set-pixel  loop  ;

need random-n

: random-n-test  ( n -- )
  cls
  0 do  random-n 255 and
        random-n 255 and 192 umin set-pixel
  loop  ;

  \ }}} =======================================================
  \ Deferred words {{{

( defers action-of )  \ ==deferredwords==

  \ Credits:
  \ Code adapted from the Afera library.

: defers  ( "name" -- )  ' defer@ compile,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.

: action-of  ( Interpretation: "name" -- cfa )
             ( Compilation:    "name" -- )
             ( Runtime:        -- cfa )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.

( <is> [is] is  )

  \ Credits:
  \ Code adapted from the Afera library.

: <is>  ( cfa "name" -- )  ' defer!  ;

: [is]  ( cfa "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

: is  ( cfa "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

( code? code-alias? defer-alias code-alias alias )

: code?  ( cfa -- wf )  dup >body swap @ =  ;
  \ Is _cfa_ a word created by `code`?

: code-alias?  ( cfa -- wf )  @ dup body> @ =  ;
  \ Is _cfa_ a word created by `code-alias` or `code`?

: defer-alias  ( cfa "name" -- )
  defer latest name> defer!  ;
  \ Create a deferred word _name_ that executes _cfa_.

: code-alias  ( cfa "name" -- )
  @ header reveal latest name> !  ;
  \ Create a code word that executes the code pointed by _cfa_.

: alias  ( cfa "name" -- )
  dup code-alias? if  code-alias exit  then  defer-alias  ;

  \ doc{
  \
  \ alias  ( cfa "name" -- )
  \
  \ Create an alias _name_ that will execute _cfa_.  If _cfa_
  \ is a primitive word, the address hold in _name_'s own cfa
  \ will be the same than the address hold in _cfa_. Otherwise
  \ _name_ will be a deferred word executing _cfa_.
  \
  \ }doc

( synonym )

  \ Credits:
  \
  \ The code of `synonym` is adapted from the example provided
  \ in the Forth-2012 documentation, and improved with
  \ `compile-only?`.

  \ XXX FIXME -- `' newname` would not work fine
: synonym  ( "newname" "oldname" -- )
  create immediate
    hide ' , reveal
  does>  ( -- )
   ( pfa ) @ ( cfa ) dup >name dup ( cfa nfa nfa )
   compile-only? executing? and -14 ?throw
   immediate? executing? or
   if  execute  else  compile,  then  ;

  \ XXX TODO -- new approach
need alias
: synonym2  ( "newname" "oldname" -- )
  parse-name nextname ' alias  ;

  \ doc{
  \
  \ synonym  ( "newname" "oldname" -- )
  \
  \ Create a definition for _newname_ with the the semantics
  \ defined below. _newname_ may be the same as _oldname_; when
  \ looking up _oldname_, _newname_ shall not be found.

  \ newname ( Interpretation: i*x -- j*x )
  \         Perform the interpretation semantics of _oldname_.
  \
  \ newname ( Compilation: i*x -- j*x )
  \         Perform the compilation semantics of _oldname_.
  \
  \ Standard: Forth-2012 (TOOLS EXT).
  \
  \ }doc

  \ }}} =======================================================
  \ Assembler {{{

( call )

code call  ( a -- )
  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next

  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

( z80-asm )

\ Z80 assembler for Solo Forth

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).


  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- defining words for z80 instructions)

need -rot

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm -- opcodes)

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook \ rst 0x08
D7 m1 prt  \ rst 0x16

-->

( z80-asm -- index register opcodes)

need -rot
[defined] 3dup
?\ : 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  postpone : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( calc end-calc )

need z80-asm

current @  also assembler definitions

macro calc  ( -- )  exx EF c,  endm
  \ 0xEF = `rst 0x28`, call the ROM calculator

macro end-calc  ( -- )  38 c, exx  next ix ldp  endm
  \ 0x38 = ROM calculator `end-calc` command
  \
  \ XXX TODO It seems IX is not used by the calculator,
  \ so this code will work:
  \ macro end-calc  ( -- )  38 c, exx  endm

current !  previous

( << >> )

  \ For dumping assembled code to screen.

  \ Credits:
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

( execute-hl call-cfa )

  \ Assembler macros to call any Forth word from code words.

  \ Credits:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call a cfa hold in a
  \ variable. The code has been converted from DTC to ITC and
  \ factored to two assembler macros in order to make it
  \ reusable.

macro execute-hl  ( -- )
  \ Compile an `execute` with the cfa hold in HL.
  here 6 + bc ldp# \ point IP to phony_compiled_word
  next2 jp  \ execute the cfa in HL
  \ phony_compiled_word:
  here cell+ ,  \ point to the phony cfa following
  here cell+ ,  \ phony cfa, point to the code following
  endm

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `execute-hl` has to be modified.

macro call-cfa  ( cfa -- )
  \ Compile a call to _cfa_.
  \ This is the low-level equivalent of `execute`.
  hl ldp#  execute-hl
  endm

  \ }}} =======================================================
  \ Address register {{{

( a! a@ )  \ ==addressregister==

  \ Address register store and fetch words.

  \ Credits:
  \ Code adapted from Z88 CamelForth.

  \ Note by Gary Lancaster in the Z88 CamelForth source file:
  \ Sadly, there aren't any spare registers to make this as
  \ efficient as it could be. However, it can still give a
  \ useful improvement in loops, and in many cases also results
  \ in cleaner-looking code.

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,  22 c, a ,  jpnext
    \ pop hl
    \ ld (a),hl
    \ jp (ix)
  end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,  C3 c, pushhl ,
    \ ld hl,(a)
    \ jp pushhl
  end-code

( !a @a )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,  2A c, a ,  70 03 + c,  23 c,  70 04 + c,  jpnext
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ jp (ix)
  end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,  5E c,  23 c,  66 c,  68 03 + c,  C3 c, pushhl ,
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld h,(hl)
    \ ld l,e
    \ jp pushhl
  end-code

( c!a c@a )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  jpnext                \ jp (ix)
  end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a+ @a+ )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code @a+  ( -- u )      \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

( c!a+ c@a+ )

  \ Credits:
  \ Code adapted from Z88 CamelForth.

need a!

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

  \ }}} =======================================================
  \ Common heap {{{

( heap )

  \ An implementation of the Forth-94 Memory-Allocation Word
  \ Set.

  \ XXX Note: 1614 bytes used!

  \ XXX TODO use top of memory instead of dictionary space?
  \ problem: memory banks could not be used at the same time.
  \
  \ XXX TODO use a memory bank instead of dictionary space?
  \ problem: only words below 0xC000 could manipulate the heap.

  \ Credits:
  \ Adapted from code written by Gordon Charlton, 1994:

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, `allocate`,
  \ `free`, and `resize` which give the minimum functionality
  \ required to use the heap. These are given in areas 3, 4 and
  \ 5 respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant `heapsize`. the constant
  \ `hysteresis` controls the amount of spare space that is
  \ added to an allocation, to reduce the need for block moves
  \ during resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

also forth definitions
need wid-of
vocabulary heap-voc  wid-of heap-voc constant heap-wordlist
also heap-voc definitions

  \ XXX TODO -- alternative
  \ forth-wordlist set-current
  \ wordlist heap-wordlist

  \ **1** General Purpose Extensions

0 1 2 um/mod nip 1- constant maxpos
  \ XXX TODO use `environment?` instead when available

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  --  Constants

256 cells constant heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 cells 1- constant hysteresis

  \ Node lengths are rounded up according to the value of
  \ `hysteresis` to reduce the number of block moves during
  \ `resize` operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

3 cells constant headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis or  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize constant overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  --  Structure

create sentinel  here cell+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

create heap  heapsize allot

  \ The heap is as described in `headsize`.

variable nextnode  -->

  \ Searching is done using a "nextfit" algorithm. `nextnode`
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr1 -- addr2)  cell+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr1 -- addr2)  [ 2 cells ] literal +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )
  heap dup nextnode !
  dup dup !
  dup heapsize  over >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does
  \ `nextnode`.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  --  List Searching

: attach ( addr)
  >prev @  dup sentinel rot !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (_addr_) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >r begin 2@ swap R@ < invert until
  r> drop  >prev @  ;

  \ Search the nodelist, starting at the node specified
  \ (_addr_), for a free node larger than or equal to the
  \ specified _size_.  Return the address of the first node
  \ that matches, or zero for no match. The heap structure is
  \ set up to make this a near optimal search loop. The "size"
  \ field is next to the "next" field so that both can be
  \ collected in a single operation (2@). Nodes in use have
  \ negated sizes so they never match the search. The
  \ "previous" field is included to allow the search to
  \ overshoot the match by one node and then link back outside
  \ the loop, rather than remembering the address of the node
  \ just examined. The sentinel removes the need for a separate
  \ test for failure. `search` assumes the sentinel is in
  \ place.

: detach ( addr)  dup >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           dup      attach
           dup rot  search
           swap     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ `nextnode`, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  --  Head Creation

: fits ( size addr -- flag)  >size @ swap -  overhead  <  ;

  \ Returns _true_ if the size of the node specified is the
  \ same as the specified size, or larger than it by less than
  \ the size of the smallest possible node. Returns _false_
  \ otherwise.

: togglesize ( addr)  >size dup @  negate swap !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2dup + >r  >size 2dup @ swap -
  R@ >size !   swap negate swap !  r>  ;

  \ Given a free node (_addr_), reduce its size to that
  \ specified and mark it as in use. Start to construct a new
  \ node within the specified node beyond its new length, by
  \ storing the length of the remainder of the node in the size
  \ field of the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2dup swap @  2dup  swap !  >prev !
  2dup >prev !   swap !  ;


  \ _Addr1_ is an existing node. _Addr2_ is the address of a
  \ new node just above the existing node. Break the links from
  \ the existing node to the next node and from the next node
  \ to the existing node and join the new node to them.


  \ ANSI heap  --  Node Construction  ALLOCATE

: newnode ( size addr)  tuck sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)
  2dup fits if  togglesize drop  else  newnode  then  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

forth-wordlist set-current

: allocate ( u -- addr ior)
  dup 0< if  -59  \ `allocate` error code
       else  adjustsize
       dup findspace
       dup if  dup next!
         tuck makenode
         headsize +  0
         else  drop -59  \ `allocate` error code
         then
       then  ;

heap-wordlist set-current  -->

  \ Make an in-use node with a data field at least _u_ address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and the standard ior.  The
  \ standard specifies that the argument to `allocate` is
  \ unsigned. As the implementation uses the sign bit of the
  \ size field for its own purposes any request for an amount
  \ of space greater than `maxpos` must fail. As this would be
  \ a request for half the addressable memory or more this is
  \ not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  --  Head Destruction

: mergesizes ( addr1 addr2)
  >size @ swap >size +!  ;

  \ Make the size field of the node at _addr1_ equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at _addr2_ will be the one immediately above _addr1_.

: mergelinks ( addr1 addr2)
  @ 2dup swap !  >prev !  ;

  \ The node at _addr2_ is removed from the node list. As with
  \ `mergesizes` the node at _addr2_ will be immediately above
  \ that at _addr1_. Destroy the link from node1 to node2 and
  \ relink node1 to the node above node2. Destroy the backward
  \ link from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that `nextnode` may point to it. This is cured by
  \ making it point to the node prior to the one removed. We do
  \ not want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically `nextnode` is set to
  \ point to the node pointed to by the "previous" field of the
  \ node pointed to in the "next" field of the node pointed to
  \ by `nextnode`. Ordinarily this is a no-op (ie I am my
  \ father's son) but when the node has had its links merged it
  \ sets `nextnode` to point to the node prior to the node it
  \ pointed to (ie when I died my father adopted my son, so now
  \ my son is my father's son).

: merge ( addr)
  dup @ 2dup mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  --  Node Removal

: ?merge ( addr1 addr2)
  >size @ 0> if
    dup dup @
    u< if  dup merge  then
  then  drop  ;  -->

  \ Merge the node at _addr1_ with the one above it on two
  \ conditions, firstly that the node at _addr2_ is free, and
  \ secondly that the node pointed to by the next field in
  \ _addr1_ is actually above _addr1_ (ie that it does not wrap
  \ around because it is the topmost node). In usage _addr2_
  \ will be either _addr1_ or the node above it. In each
  \ instance the other affected node (either the node above
  \ _addr1_ or _addr1_) is known to be free, so no test is
  \ needed for this.

( heap )

: ?mergenext ( addr)  dup @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ dup ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

forth-wordlist set-current

: free ( addr -- ior)
  headsize -  dup togglesize  dup ?mergenext  ?mergeprev  0  ;

heap-wordlist set-current

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  --  Node Repairing

variable stash

  \ the `resize` algorithm is simplified and made faster by
  \ assuming that it will always succeed. `stash` holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ saves the contents of the `>next` field of the node being
  \ `resize`d in `stash` (above).

: restorelink ( addr)  stash @  swap !  ;

  \ Converse operation to `savelink` (above).

: fixprev ( addr)  dup >prev @ !  ;

  \ The `>next` field of the node prior to the node being
  \ `resize`d should point to the node being `resize`d. it may
  \ very well do already, but this makes sure.

: fixnext ( addr)  dup @ >prev !  ;

  \ The `>prev` field of the node after the node resized may
  \ need correcting.  This corrects it whether it needs it or
  \ not.  (Its quicker just to do it than to check first.)

: fixlinks ( addr)  dup fixprev  dup fixnext  @ fixnext  ;

  \ `resize` may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of `jiggle` (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)
  dup >size @ 0>
  if  dup @  2dup <
      if    over - swap >size !  else  2drop  then
  else  drop  then  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the `>next` field provided
  \ that the node is free and it is not the topmost node in the
  \ heap (ie there is no wraparound). Both these conditions
  \ need to be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  dup fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to `resize` (damaged by
  \ `?mergenext`) and its predecessor (damaged by `?mergeprev`).

: repair ( addr)
  dup restorelink
  dup fixlinks  dup fixsizes
  togglesize  ;

  \ Make good the damage done by `resize`. Restore the `>next`
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer `nextnode`
  \ may have moved back one or two nodes by virtue of having
  \ been `jiggle`d about if it happened to be pointing to the
  \ wrong node. This is not serious, so I have chosen to ignore
  \ it.


  \ ANSI Heap  --  Node Movement

: toobig? ( addr size -- flag)
  swap  >size @  >  ;

  \ _Flag_ is true if the node at _addr_ is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
  over >size @  headsize -
  rot  headsize + rot rot move  ;

  \ Move the contents of the data field of the node at _addr1_
  \ to the data field at _addr2_. Assumes _addr2_ is large
  \ enough. It will be.

: enlarge ( addr1 size -- addr2 ior)
  over  ?mergeprev
  allocate dup >r
  if  swap repair  else  tuck copynode  then  r>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of _addr1_ to the new node. Merge the node at addr1 with
  \ the one preceding it, if possible. This last behaviour is
  \ to finish off removing the node at _addr1_. The word
  \ `adjust` (below) starts removing the node. The node is
  \ removed before allocation to increase the probability of
  \ `allocate` succeeding. The address returned by `enlarge` is
  \ that returned by `allocate`, which is that of the data
  \ field, not the head. If the allocation fails repair the
  \ damage done by removing the node at _addr1_.


  \ ANSI Heap  --  Node Restructuring

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >r
  headsize -
  dup savelink
  dup togglesize
  dup ?mergenext r>  ;

  \ _Addr1_ points to the data field of a node, not the "next"
  \ field. This needs correcting. _Size1_ also needs adjusting
  \ as per `adjustsize`. In addition it is easier to work with
  \ free nodes than live ones as the size field is correct,
  \ and, as we intend to change the nodes size we will
  \ inevitably want to muck about with the next node, if its
  \ free, so lets merge with it straight away. Sufficient
  \ information is first saved to put the heap back as it was,
  \ if necessary.  Now we are ready to get down to business.

-->

( heap )

forth-wordlist set-current

: resize ( addr1 u -- addr2 ior)
  dup 0<  if  drop -61  \ `resize` error code
          else  adjust  2dup toobig?
                if enlarge
                else  over makenode headsize +  0  then
          then  ;

  \ Resize the node at _addr1_ to the specified size. Return
  \ the address of the resized node _addr2_ along with an _ior_
  \ of zero if successful and -61 if not. _Addr2_ may be the
  \ same as, or different to, _addr1_.  If _ior_ is non-zero
  \ then _addr2_ is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using `makenode`,
  \ which has just the right functionality.  In this case the
  \ ior is zero. As this is a standard word it takes an
  \ unsigned size argument, but excessive requests fail
  \ automatically, as with `allocate`.

( create-heap )

  \ XXX UNDER DEVELOPMENT

  \ Inspired by:
  \
  \ Gestor de memoria dinmica (version 1)
  \ By Javier Gil
  \ From his book _Introduccin a Forth_ (2007-01)

  \ 2015-11-18: Start.
  \ 2015-11-21: Changes.

need value  need set-bit  need reset-bit  need bit?
need reserve  need alias

0 value heap  ( -- a )
  \ Address of the current heap.

8 constant address-unit-bits
16 value /chunk \ bytes per chunk

: groups ( n1 n2 -- n3 )  /mod swap 0<> abs +  ;
  \ Return the number _n3_ of groups of _n2_ elements, needed
  \ to hold _n1_ elements.

: bytes>chunks ( n1 -- n2 )  /chunk groups  ;
  \ Return the chunks _n2_ required to allocate _n1_ bytes.

: chunks>bytes ( n1 -- n2 )  address-unit-bits groups  ;
  \ Return the bytes _n2_ required for a bitmap of _n1_ chunks.

' heap alias heap-chunks  ( -- a )
  \ Address that holds the number of chunks of the current
  \ heap.

: heap-unused-chunks  ( -- a )  heap-chunks cell+  ;
  \ Address that holds the number of unused chunks of the
  \ current heap.

: heap-map  ( -- a )  heap-unused-chunks cell+  ;
  \ Address of the current heap's map.

: /heap-map  ( -- n )  heap-chunks @ chunks>bytes  ;
  \ Number of bytes of the current heap's map.

: heap-data  ( -- a ) heap-map /heap-map +  ;  -->
  \ Address of the current heap's data space.

( create-heap )

: (mapbit)  ( n1 -- n2 ca )
  address-unit-bits /mod heap-map +  ;
  \ n1 = number of bit in the bitmap
  \ n2 = number of bit in the byte at _a2_
  \ ca = address of the bitmap that holds bit _n2_

: mapbit ( n1 -- a2 b n2 )  (mapbit) dup @ rot  ;
  \ n1 = number of bit in the bitmap
  \ a2 = address of the correspondent byte
  \ b =  correspondent byte
  \ n2 = number of bit in _b_

: used-chunk? ( n -- f )  (mapbit) @ swap bit?  ;
  \ Is chunk _n_ used?

: use-chunk ( n -- )  mapbit set-bit swap !  ;
  \ Mark chunk _n_ as used.

: free-chunk ( n -- )  mapbit reset-bit swap !  ;
  \ Mark chunk _n_ as free.

: allocated>chunks  ( a -- n )  cell- @  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its number of chunks.

: allocated>index  ( a -- n )  heap-data - /chunk /  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n_ in the map of the heap
  \ chunks.

: allocated>map  ( a -- n1 n2 )
  dup allocated>index swap allocated>chunks  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n1_ in the map of heap chunks
  \ and the number _n2_ of ocuppied chunks.

-->

( create-heap )

: locate-chunks  ( n1 -- n1 n2 0 | ior )
  0 tuck  ( n2 n1 count )
  heap-chunks @ 0 do  ( n2 n1 count )
    i used-chunk? if  drop >r i 1+ r> 0  else  1+  then
    2dup = if  drop swap 0 unloop exit  then
  loop  2drop drop -59  ;
  \ Locate _n1_ consecutive free chunks in the current heap.
  \ If succesful, _n2_ is the first chunk of the group;
  \ else return _ior_ -59, the error code for `allocate`.

: chunk>address  ( n1 -- a )  /chunk * heap-data +  ;

: (allocate)  ( n1 n2 -- a )
  dup chunk>address >r
  swap bounds do  i use-chunk  loop
  r>  ;
  \ Allocate _n1_ chunks of the current heap, starting from
  \ chunk _n2_; return the address _a_ of the allocated space.

-->

( create-heap )

  \ User interface

: create-heap ( n "name" -- )
  create  bytes>chunks dup ,  0 ,
            \ max chunks and free chunks
          dup chunks>bytes reserve drop
            \ bitmap
          /chunk * allot  ;
            \ data space
  \ Create a new heap "name" to hold _n_ bytes.

: allocate  ( n -- a ior )
  bytes>chunks locate-chunks ?dup ?exit  (allocate) 0  ;

: free  ( a -- ior )
  allocated>map dup >r
  bounds do  i free-chunk  loop
  r> heap-unused-chunks +! 0  ;

  \ XXX TODO -- update with `resize`
  \ doc{
  \
  \ free  ( a -- ior )
  \
  \ Return the contiguous region of data space indicated by _a_
  \ to the system for later allocation. _a_ shall indicate a
  \ region of data space that was previously obtained by
  \ `allocate`.
  \
  \ If the operation succeeds, _ior_ is zero. If the operation
  \ fails, _ior_ is -60.
  \
  \ Standard: Forth-94 (MEMORY), Forth-2012 (MEMORY).
  \
  \ }doc


: empty-heap  ( -- )  heap-chunks @ 0 do  i free-chunk  loop  ;
  \ Empty the current heap, setting all chunks free.

: .heap ( -- )
  heap-chunks @ 0 do
    i used-chunk? if  [char] x  else  [char] -  then  emit
  loop  ;

  \ Print the map of the current heap. Occupied chunks are
  \ marked with a "x"; free chunks are marked with a "-".

  \ }}} =======================================================
  \ Leo Brodie's DOER ... MAKE construct {{{

( doer )

  \ Credits:
  \ Code adapted from PFE.
  \ Original code by Leo Brodie, 1983,
  \ published in _Thinking Forth_, Appendix A. Public domain.

: doer-noop ;

: doer  ( "name" -- )
  \ Define a word whose behaviour is vectorable.
  create  ['] doer-noop >body ,
  does>  ( pfa ) @ >r ;

: (make)
  \ Stuff the address of further code into the parameter field
  \ of a doer word.
  r> dup cell+ dup cell+
    ( a1 a2 a2 )
    \ a1 = address of an optional continuation after `;and`,
    \      or zero
    \ a2 = address of the doer word
    \ a3 = address of the code to associate the doer word with
  swap @ >body !
    \ Get the pfa of the doer word and store the code address
    \ into it.
  @ ?dup if  >r  then ;
    \ Manage the optional continuation after `;and`.

variable >;and
  \ Hold the address of optional continuation pointer.

: make
  \ Used interpretively:
  \   make doer-name forth-code ;
  \ Or inside a definition:
  \   : definition  make doer-name forth-code  ;
  compiling? if     postpone (make)  here >;and ! 0 ,
             else   here ' >body ! ]  then  ; immediate

: ;and  ( -- )  postpone exit  here >;and @ !  ; immediate
  \ Allow continuation of the "making" definition.

: undo  ( "name" -- )  ['] doer-noop >body  ' >body ! ;
  \ Make the doer word "name" safe to execute.

( doer-test )

need doer

doer test
  .( Test 1: ) test
make test  cr ." test 2" ;
  .( Test 2: ) test
: change    make test ." test 3" ;and  test ;
change
  .( Test 3: ) test
undo test
  .( Test 4: ) test

  \ }}} =======================================================
  \ Floating point after Spectrum Forth-83 {{{

  \ XXX TODO

  \ }}} =======================================================
  \ Floating point using the ROM calculator {{{

  \ XXX UNDER DEVELOPMENT

  \ The ROM calculator is used to implement most words of the
  \ Forth-2012 FLOATING and FLOATING EXT word sets, and some
  \ words not provided by Forth-2012.

  \ XXX FIXME -- The ROM calculator calls the BASIC error
  \ routines, what crashes the system.

( fp-load )

need +thru
1 9 +thru

( float float+ floats s>f f>s )

5 constant float

: float+  ( n1 -- n2 )  float +  ;
: floats  ( n1 -- n2 )  float *  ;

need z80-asm  need calc

code s>f  ( n -- ) ( F: -- r )
  exx  bc pop  2D2B call  exx  jpnext  end-code

code f>s  ( -- n ) ( F: r -- )
  exx  2DA2 call  bc push  exx  jpnext  end-code

code f>d  ( -- d ) ( F: r -- )
  \ XXX TODO
  end-code

( fvariable )

: fvariable  ( "name" -- )  create  float allot  ;

: f!  ( a -- ) ( F: r -- )  ;
  \ XXX TODO

: f,  ( -- )  here float allot f!  ;

: fconstant  ( "name" -- )  ( F: f -- )  create  f,  does>  ;
  \ XXX TODO

( f** f+ f- f/ )

  \ Operators

need z80-asm  need calc

code f**  ( F: r1 -- r2 )
  calc 06 c, end-calc jpnext  end-code
code f+  ( F: r1 r2 -- r3 )
  calc 0F c, end-calc jpnext  end-code
code f-  ( F: r1 r2 -- r3 )
  calc 03 c, end-calc jpnext  end-code
code f/  ( F: r1 r2 -- r3 )
  calc 05 c, end-calc jpnext  end-code

  \ XXX TODO
  \ code fmax  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code
  \ code fmin  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code

code fsign  ( F: r1 -- r2 )
  calc 29 c, end-calc jpnext  end-code

( fabs fexp fln fmod fnegate fsqrt )

  \ Operators

need z80-asm  need calc

code fabs  ( F: r1 -- r2 )
  calc 2A c, end-calc jpnext  end-code
code fexp  ( F: r1 -- r2 )
  calc 26 c, end-calc jpnext  end-code
code fmod  ( F: r1 -- r2 )
  calc 32 c, end-calc jpnext  end-code
code fnegate  ( F: r1 -- r2 )
  calc 1B c, end-calc jpnext  end-code

code fln  ( F: r1 -- r2 )
  calc 25 c, end-calc jpnext  end-code
code fsqrt  ( F: r1 -- r2 )
  calc 28 c, end-calc jpnext  end-code

code fround  ( F: r1 -- r2 )
  calc 3A c, end-calc jpnext  end-code

( f0 f1 fhalf fpi2/ f10 )

  \ Constants

need z80-asm  need calc

code f0  ( F: -- r1 )
  calc A0 c, end-calc jpnext  end-code
code f1  ( F: -- r1 )
  calc A1 c, end-calc jpnext  end-code
code fhalf  ( F: -- r1 )
  calc A2 c, end-calc jpnext  end-code
code fpi2/  ( F: -- r1 )
  calc A3 c, end-calc jpnext  end-code
code f10  ( F: -- r1 )
  calc A4 c, end-calc jpnext  end-code

( jp-f>s )

need z80-asm  need f>s

  \ XXX TODO -- optimize; `f>s` has another pair of `exx`. A
  \ specific word will be faster and smaller, instead of
  \ `end-calc jp-f>s`.

  \ XXX FIXME -- `macro` is not recognized here.

macro jp-f>s  ( -- )
  ['] f>s call-cfa
  endm

( f0< f0= f< f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm  need calc  need jp-f>s

code f0<  ( F: r1 -- rwf )
  calc 36 c, 1B c, end-calc jp-f>s  end-code

code f0=  ( F: r1 -- rwf )
  calc 30 c, 1B c, end-calc jp-f>s  end-code

code f0<>  ( F: r1 -- rwf )
  calc 30 c, 30 c, 1B c, end-calc jp-f>s  end-code

code f<  ( F: r1 r2 -- rwf )
  calc 0D c, 1B c, end-calc jp-f>s  end-code

  \ code f~ \ XXX TODO

( f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm

code f<=  ( F: r1 r2 -- rwf )
  calc 09 c, 1B c, end-calc jp-f>s  end-code

code f<>  ( F: r1 r2 -- rwf )
  calc 0B c, 1B c, end-calc jp-f>s  end-code

code f=  ( F: r1 r2 -- rwf )
  calc 0E c, 1B c, end-calc jp-f>s  end-code

code f>  ( F: r1 r2 -- rwf )
  calc 0C c, 1B c, end-calc jp-f>s  end-code

code f>=  ( F: r1 r2 -- rwf )
  calc 0A c, 1B c, end-calc jp-f>s  end-code

( fdrop fdup fswap fover frot )

  \ Stack

need z80-asm  need float  need calc

23651 constant fp0  23653 constant fp  : fp@  ( -- a )  fp @  ;
  \ 23651 = STKBOT system variable
  \ 23653 = STKEND system variable

: fdepth  ( -- n )  fp@ fp0 @ - float /  ;

code fdrop  ( F: r1 -- )
  calc 02 c, end-calc jpnext  end-code

code fdup  ( F: r1 -- r1 r1 )
  calc 31 c, end-calc jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calc 01 c, end-calc jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calc C2 c, C1 c, E1 c, E2 c, E1 c, end-calc jpnext  end-code

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calc C3 c, C2 c, C1 c, E2 c, E3 c, E1 c, end-calc
  jpnext  end-code

( facos fasin fatan fcos fsin ftan )

  \ Trigonometrical functions

need z80-asm  need calc

code facos  ( F: r1 -- r2 )
  calc 23 c, end-calc jpnext  end-code
code fasin  ( F: r1 -- r2 )
  calc 22 c, end-calc jpnext  end-code
code fatan  ( F: r1 -- r2 )
  calc 24 c, end-calc jpnext  end-code
code fcos  ( F: r1 -- r2 )
  calc 20 c, end-calc jpnext  end-code
code fsin  ( F: r1 -- r2 )
  calc 1F c, end-calc jpnext  end-code
code ftan  ( F: r1 -- r2 )
  calc 21 c, end-calc jpnext  end-code

  \ }}} =======================================================
  \ Editor {{{

( editor )

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum. It has been
  \ adapted to Solo Forth.
  \
  \ Descriptions and stack comments have been added after the
  \ Specforth manual, the Abersoft Forth manual and the book
  \ _Systems Guide to fig-Forth_. The word `copy` has been
  \ adapted from Abersoft Forth. The word `text` has been
  \ rewritten.

  \ Credits:
  \ Specforth Editor V1.1
  \ Copyright 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983
  \ Modified by Marcos Cruz (programandala.net), 2015

only forth definitions

need list  need update  need flush  need parse-line

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "text<c>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "text<eol>" -- )
  pad c/l 1+ blank  parse-line  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type [char] _ emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "text<eol>"  -- )  text r  ;
  \ Put "text" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear block _n_ with blanks and select for editing.

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= exhaust  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 exhaust  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "text<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "text" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "text<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "text".

: till  ( "text<eol>" -- )
  #lead + text 1line 0= #-270 ?throw
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "text".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "text<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "text" to the cursor line at the cursor position.

also forth

: copy  ( n1 n2 -- )
  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ }}} =======================================================
  \ Sample game: Siderator 2 {{{

( siderator )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO -- less stars!

\ Siderator
\ A game for the ZX Spectrum

\ Copyright (C) 2009,2010,2013,2015 Marcos Cruz
\ (programandala.net)

  \ History

  \ 2015-09-02: Start, with the code of the Jupiter ACE
  \ version: http://programandala.net/en.program.siderator.html

  \ Known bugs (or special features)

  \ The craft's autodestruction creates a new star.

only forth definitions  decimal

need random  need randomize  need udg:  need inkey
need break-key?  need between  need ocr  need frames@
need j  need between

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

vocabulary siderator
also siderator definitions

-->

( siderator )

  \ Game variables and constants:

variable x          variable speed
variable parsecs    variable record  record off

999 constant max-speed
char 5 constant left-key  char 8 constant right-key

  \ System variables and addresses:

8192 constant 'screen \ XXX OLD

  \ Common words:

: at  ( row col -- )  swap at-xy  ;
: pause  ( -- )  begin  inkey  until  ;  -->

( siderator )

  \ Graphics

15360 constant charset  \ ROM charset
: char>a  ( c -- a )  8 * charset +  ;
: udg>a  ( c -- a )  128 - 8 * sys-udg @ +  ;
: char>udg  ( c0 c1 -- )  swap char>a swap udg>a 8 cmove  ;

128 constant star0-udg  char * star0-udg char>udg

binary
00011000
00001000
00011000
00010000
00011000
00001000
00011000
00010000 decimal 129 udg: star1-udg  -->

( siderator )

130 constant star2-udg
char | star2-udg char>udg

binary
00001000
00000000
00001000
00000000
00001000
00000000
00001000
00000000 decimal 131 udg: star3-udg  -->

( siderator )

binary
10000001
10000001
11000011
11100111
11111111
01100110
00111100
00011000 decimal 132 udg: craft-udg  -->

( siderator )

  \ Keyboard

: pressed?  ( c -- f )  inkey =  ;
: left  ( col -- col' )  left-key pressed? + 0 max  ;
: right  ( col -- col' )  right-key pressed? - 31 min  ;
: rudder  ( -- )  x @ right left x !  ;

-->

( siderator )

  \ Stars

4 constant #stars
: star-coords  ( -- y x )  23 31  ;
: .star  ( c -- )
  star-coords 1+ random at 1 bright emit 0 bright  ;
: stars/speed  ( -- n )  speed @ #stars 1- max-speed */ 1+  ;
: scroll  ( -- )  star-coords at cr cr  ;
: .stars  ( -- )
  stars/speed dup [ star0-udg 1- ] literal + swap 0
  do  dup .star  loop  drop  ;
: star=  ( c -- f )  star0-udg star3-udg between  ;
: star<>  ( c -- f )  star= 0=  ;

-->

( siderator )

  \ Craft

: craft-coords  ( -- y x )  10 x @  ;
: craft-at  ( -- )  craft-coords at  ;
: -craft  ( -- )  craft-at space  ;
: .craft  ( -- )  craft-at craft-udg 5 ink emit 7 ink  ;

-->

( siderator )

  \ Speed, parsecs, record

: .datum  ( u -- ) 0 <# # # # #> type space  ;
: delay  ( -- )  max-speed speed @ - 2 / 0  do  loop  ;
: .speed  ( -- )  ." Speed:" speed @ .datum  ;
: +speed  ( u1 -- u2 )
  dup 10 / 1 max  parsecs @ 4 mod 0= abs *  + max-speed min  ;
: faster  ( -- )  speed @ +speed speed !  ;
: .parsecs  ( -- )  ." Parsecs:" parsecs @ .datum  ;
: farther  ( -- )  parsecs @ 1+ parsecs !  ;
: .record  ( -- )  ." Record:" record @ .datum  ;
: .info  ( -- )  0 dup at .speed .parsecs .record  ;

-->

( siderator )

  \ End

: blast-delay  ( -- )  32 0  do  loop  ;
: (blast)  ( -- )
  .craft blast-delay craft-at star0-udg emit blast-delay  ;
: blast  ( -- )  256 0  do  (blast)  loop  ;

: halt  ( -- )
  32 0  do  24 0 do
    i j ocr star= if  i j at-xy  star0-udg emit  then
  loop  loop  ;
  \ XXX TODO

-->

( siderator )

: safe?  ( -- f )  craft-coords swap ocr star<>  ;
: continue?  ( -- f )  safe? break-key? 0= and  ;
: new-record  ( -- )
  parsecs @ record @ >  if  parsecs @ record !  then  ;
: game-over  ( -- )
  blast halt  11 dup at ." GAME OVER"
  new-record .info 22 0 at  default-colors  ;

-->

( siderator )

\ Instructions

: about  ( -- )
  cr ." Siderator 2: Jugdement Day"  cr
  cr ." Copyright (C) Marcos Cruz"
  cr ." (programandala.net)"
  cr ." Version: 2015-09-02"  ;

: objective  ( -- )
  cr ." Your objective is to travel as"
  cr ." much parsecs as possible"
  cr ." while dodging the stars."
  cr ." Anyway you're supposed to die"
  cr ." before the 1000th parsec"
  cr ." because four digits would ruin"
  cr ." the score panel."  ;

-->

( siderator )

\ Instructions

: keys  ( -- )
  cr ." Rudder keys: "
  left-key emit space right-key emit
  cr ." Autodestruction key: Break"  ;

: instructions  ( -- )  objective cr keys  ;

: wait  ( -- )  cr cr ." Press any key to start." pause  ;

-->

( siderator )

  \ Init

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;

: init-screen  ( -- )
  init-colors cls about cr instructions wait cls  ;

: 4+-  ( n1 -- n2 )  9 random 4 - +  ;

: init  ( -- )
  frames@ s>d randomize  udg-ocr
  init-screen  15 4+- x ! parsecs off  speed off  ;

-->

( siderator )

  \ Main

: run ( -- )
  init
  begin   -craft scroll  faster farther .info  continue?
  while   rudder .craft .stars  delay
  repeat  game-over  ;

  \ }}} =======================================================
  \ Sample game: tt (Tetris for terminals) {{{

( tt )

  \ tt (Tetris for terminals) is an improved port of a game
  \ written in Forth-94 by Dirk Uwe Zoller in 1994.

  \ Credits:

  \ ----------------------------------------------------------
  \ tt.pfe  Tetris for terminals, redone in ANSI-Forth.
  \
  \ Written 05Apr94 by Dirk Uwe Zoller, e-mail duz AT roxi DOT
  \ rz DOT fht-mannheim DOT de.
  \
  \ Look&feel stolen from Mike Taylor's "TETRIS FOR TERMINALS".
  \
  \ Please copy and share this program, modify it for your
  \ system and improve it as you like. But don't remove this
  \ notice.
  \
  \ Thank you.
  \ ----------------------------------------------------------

only forth also definitions

  [undefined] forget-tt ?\ forget-tt
  \ XXX TODO
  \ marker forget-tt

need random  need j  need >=  need <=  need 2/
need value  need d<>  need d=  need case  need ms  need frames@
need yes?  need begin-stringtable  need case:  need tab

[defined] >body ?\  : >body  ( cfa -- pfa )  >body  ;

vocabulary tt  also tt definitions  decimal

bl bl 2constant empty
  \ An empty position of the pit.

variable wiping
  \ If true, wipe brick, else draw brick.

2 constant col0  0 constant row0
  \ Position of the pit, not including the frame.

14 constant wide  22 constant deep
  \ Size of pit, not including the frame.
  \ Wide in stones; deep in rows.

-->

( tt )

  \ c1 = left key
  \ c2 = right key
  \ c3 = rotate key
  \ c4 = drop key
  \ c5 = pause key
  \ c6 = quit key

7 constant edit-char

: actual-cursor-keys  ( -- c1 c2 c3 c4 c5 c6 )
  8 9 11 10 bl edit-char  ;
  \ Actual cursor keys, useful for PC keyboards with cursor
  \ keys

: spanish-dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] H [char] . [char] A bl edit-char  ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] R [char] ' [char] A bl edit-char  ;

: qwerty-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] O [char] P [char] Q [char] A bl edit-char ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: cursor-digits-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 5 [char] 8 [char] 7 [char] 6 bl edit-char  ;
  \ Cursor keys, actually the digits keys they are associated with.

: sinclair1-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 1 [char] 2 [char] 3 [char] 4  bl edit-char  ;
  \ Sinclair 1 joystick.

: sinclair2-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 6 [char] 7 [char] 8 [char] 9  bl edit-char  ;  -->
  \ Sinclair 2 joystick.

( tt )

6 constant max-keyset
  \ Maximum number of the keyset (first is zero).

variable keyset
  \ Number of the current keyset.

case: keyset>keys  ( n -- c1 c2 c3 c4 c5 c6 )
  actual-cursor-keys
  dvorak-keys
  spanish-dvorak-keys
  sinclair1-keys
  sinclair2-keys
  cursor-digits-keys
  qwerty-keys  ;

-->

( tt )

begin-stringtable keyset>name  ( n -- ca len )
  s" Cursor        " s,
  s" Dvorak        " s,
  s" Spanish Dvorak" s,
  s" Sinclair 1    " s,
  s" Sinclair 2    " s,
  s" Cursor digits " s,
  s" QWERTY        " s,
end-stringtable

: keyset-name  ( -- ca len )  keyset @ keyset>name  ;

-->

( tt )

0 value quit-key  0 value pause-key  0 value drop-key
0 value rot-key   0 value right-key  0 value left-key

: keys!  ( c1 c2 c3 c4 c5 c6 -- )
  to quit-key to pause-key to drop-key
  to rot-key to right-key to left-key   ;

: set-keyset   ( n -- )  dup keyset ! keyset>keys keys!  ;
  \ Set the keyset layout number _n_.

: next-keyset  ( -- n )  keyset @ 1+ dup max-keyset > 0= and  ;
  \ Calculate the next keyset.

: change-keyset  ( -- )  next-keyset set-keyset  ;
  \ Set the next keyset.

0 set-keyset  \ default

-->

( tt )

variable score
variable pieces
variable levels
variable delay  \ in ms

variable brick-row  variable brick-col
  \ Position of the current brick.

: 2c@  ( a -- c1 c2 )  dup 1+ c@ swap c@  ;
  \ Fetch a pair of characters.

: 2c!  ( c1 c2 a -- )  dup >r c! r> 1+ c!  ;
  \ Store a pair of characters.

: 2emit  ( c1 c2 -- )   emit emit  ;

: position  ( row col -- )
  2* col0 + swap row0 + at-xy  ;
  \ Cursor to the position in the pit.

: stone  ( c1 c2 -- )
  wiping @ if  2drop 2 spaces  else  2emit  then  ;
  \ Draw or undraw these two characters.

-->

( tt )

wide deep * 2 * constant /pit
  \ Size of the pit in memory.

create 'pit /pit allot
  \ The pit.

: pit  ( col row -- a )  'pit rot wide * rot + 2* +  ;
  \ Convert pit coords to the correspondent address.

: empty-pit  ( -- )  'pit /pit blank  ;
  \ Empty the pit.

: draw-bottom  ( -- )
  deep -1 position  [char] + dup stone
  wide 0 do  [char] = dup stone  loop
  [char] + dup stone  ;
  \ Draw the bottom of the pit.

: draw-frame  ( -- )
  deep 0 do   i -1   position [char] | dup stone
              i wide position [char] | dup stone
  loop  draw-bottom  ;  -->
  \ Draw the frame of the pit.

( tt )

: bottom-msg  ( addr cnt -- )
  deep over 2/ wide swap - 2/ position 1 flash type 0 flash  ;
  \ Output a message at the bottom of the pit.

: draw-line  ( line -- )
  dup 0 position  wide 0 do  dup i pit 2c@ 2emit  loop  drop  ;
  \ Draw the contents of a pit line.

: draw-pit  ( -- )  deep 0 do  i draw-line  loop  ;
  \ Draw the contents of the pit.

begin-stringtable c>name  ( c -- ca len )
  s" Edit" s, s" Left" s, s" Right" s, s" Down" s, s" Up" s,
end-stringtable
  \ Names of the control chars 7..11.

: control-char-name  ( c -- ca len )  7 - c>name  ;
  \ Name of a control char (7..11).

: show-key  ( c -- )
  2 spaces  dup bl = if  drop ." Space"  else
            dup bl < if    control-char-name type
                     else  emit  then
            then  tab  ;
  \ Display the name of char _c_.
  \ Control chars are not supported except cursor keys and edit.

-->

( tt )

: show-keys  ( -- )
  \ display the game keys
  \  <------------------------------>
  ." Keys: " keyset-name type cr cr
  left-key     show-key ."  Move left" cr
  right-key    show-key ."  Move right" cr
  rot-key      show-key ."  Rotate" cr
  drop-key     show-key ."  Drop" cr
  pause-key    show-key ."  Pause" cr
  quit-key     show-key ."  Quit"  ;
  \  <------------------------------>

-->

( tt )

: (show-help)  ( -- )
  0 0 at-xy
  \  <------------------------------>
  ." TT (Tetris for Terminals)" cr cr
  ." Original ANS Forth code written" cr
  ." by Dirk Uwe Zoller, 1994." cr
  ." Ported to Solo Forth" cr
  ." by Marcos Cruz, 2015." cr cr
  show-keys  ;
  \ Display some explanations.

: show-help  ( -- )
  page
  begin  (show-help) cr cr
          \  <------------------------------>
         ." Press Space to change the keys" cr
         ." or any other key to start."
         key bl =
  while  change-keyset  repeat  ;  -->
  \ Display some explanations and change the keyset.

( tt )

23 constant score-row

: at-score  ( col -- )  score-row at-xy  ;
  \ Set cursor at column _col_ of the score row.

: score-labels ( -- )
   0 at-score ." Score:"
  10 at-score ." Pieces:"
  21 at-score ." Levels:"  ;
  \ Display the labels of the score.

: .score  ( a col -- )  at-score @ 3 .r  ;
  \ Display the contents of the score variable _a_ at column
  \ _col_.

: update-score  ( -- )
  score 6 .score  pieces 17 .score  levels 28 .score  ;
  \ Display the current score.

: arena  ( --)
  draw-frame draw-pit score-labels update-score  ;
  \ Redraw everything on screen.

-->

( tt )


: brick:  ( ca1 len1 ca2 len2 ca3 len3 ca4 len4 "name" -- )
  create  4 0 do
            0 do  dup i chars + c@ c,  loop drop
          loop
  does>  ( x1 x2 -- a ) ( pfa )  rot 4 * rot + 2* +  ;
  \ Define the shape of a brick.
  \ Every brick has 4 rows, defined by 4 strings.
  \ XXX TODO stack notation of `does>`

s"         " 2constant empty-brick-row

empty-brick-row
s"   ##    "
s" ######  "  empty-brick-row  brick: brick1

empty-brick-row 2dup
s" <><><><>"  empty-brick-row  brick: brick2

empty-brick-row
s"   {}    "
s"   {}{}{}"  empty-brick-row  brick: brick3  -->

( tt )

empty-brick-row
s"     ()  "
s" ()()()  "  empty-brick-row brick: brick4

empty-brick-row
s"   [][]  "
s"   [][]  "  empty-brick-row brick: brick5

empty-brick-row
s"   @@@@  "
s" @@@@    "  empty-brick-row brick: brick6

empty-brick-row
s" %%%%    "
s"   %%%%  "  empty-brick-row brick: brick7

empty-brick-row 2dup 2dup 2dup brick: brick
  \ brick actually in use

empty-brick-row 2dup 2dup 2dup brick: scratch  -->

( tt )

create bricks  ' brick1 ,  ' brick2 ,  ' brick3 ,  ' brick4 ,
               ' brick5 ,  ' brick6 ,  ' brick7 ,

create brick-value 1 c, 2 c, 3 c, 3 c, 4 c, 5 c, 5 c,

32 constant /brick
  \ Bytes per brick shape.

: is-brick  ( brick -- )
  >body [ ' brick >body ] literal /brick cmove  ;
  \ Activate a shape of brick.

: new-brick  ( -- )
  1 pieces +!  7 random
  bricks over cells + @ is-brick
  brick-value swap chars + c@ score +!  ;
  \ Select a new brick by random, count it.

: rotate-left  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  3 i - j scratch 2c!
  loop loop
  ['] scratch is-brick  ;  -->
  \ Rotate the current brick left.

( tt )


: rotate-right  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  i 3 j - scratch 2c!
  loop loop
  ['] scratch is-brick  ;
  \ Rotate the current brick right.

: draw-brick  ( row col -- )
  4 0 do 4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i +  position
        j i brick 2c@  stone
    then
  loop loop  2drop  ;
  \ Draw the current brick at the given coords.

: show-brick  ( row col -- )  wiping off draw-brick  ;

: hide-brick  ( row col -- )  wiping on  draw-brick  ;

-->

( tt )

: put-brick  ( row col -- )
  4 0 do 4 0 do
      j i brick 2c@  empty d<>
      if  over j +  over i +  pit
          j i brick 2c@  rot 2c!
      then
  loop loop  2drop  ;
  \ Put the brick into the pit.

: remove-brick  ( row col -- )
  4 0 do  4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i + pit empty rot 2c!  then
  loop  loop  2drop  ;
  \ Remove the brick from that position.

-->

( tt )

: test-brick  ( row col -- f )
  4 0 do 4 0 do
    j i brick 2c@ empty d<>
    if  over j +  over i +
        over dup 0< swap deep >= or
        over dup 0< swap wide >= or
        2swap pit 2c@  empty d<>
        or or if  unloop unloop 2drop false  exit  then
    then
  loop loop  2drop true  ;
  \ Could the brick be there?

-->

( tt )


: move-brick  ( rows cols -- f )
  brick-row @ brick-col @ remove-brick
  swap brick-row @ + swap brick-col @ + 2dup test-brick
  if    brick-row @ brick-col @ hide-brick
        2dup brick-col ! brick-row !
        2dup show-brick put-brick  true
  else  2drop brick-row @ brick-col @ put-brick  false
  then  ;
  \ Try to move the brick.

-->

( tt )

: rotate-brick  ( f1 -- f2 )
  \ f1 = rotate right?, else rotate left
  \ f2 = success
  brick-row @ brick-col @ remove-brick
  dup if  rotate-right  else  rotate-left  then
  brick-row @ brick-col @ test-brick
  over if  rotate-left  else  rotate-right  then
  if  brick-row @ brick-col @ hide-brick
      if  rotate-right  else  rotate-left  then
      brick-row @ brick-col @ put-brick
      brick-row @ brick-col @ show-brick  true
  else  drop false  then  ;
  \ Rotate the current brick.

-->

( tt )

: insert-brick  ( row col -- f )
  2dup test-brick
  if  2dup brick-col ! brick-row !
      2dup put-brick  draw-brick  true
  else  false  then  ;
  \ Introduce a new brick.

: drop-brick  ( -- )  begin  1 0 move-brick 0=  until  ;
  \ Move brick down fast.

: move-line  ( from to -- )
    over 0 pit  over 0 pit  wide 2*  cmove  draw-line
    dup 0 pit  wide 2*  blank  draw-line  ;

: line-full?  ( line-no -- f )
    true  wide 0
    do  over i pit 2c@ empty d=
        if  drop false  exhaust  then
    loop nip  ;

-->

( tt )

: adjust-delay  ( -- )
  levels @
  dup  50 < if  100 over -  else
  dup 100 < if   62 over 4 / -  else
  dup 500 < if   31 over 16 / -  else  0  then then then
  delay !  drop  ;
  \ Make it faster with increasing level.

-->

( tt )

: new-level  ( -- )  1 levels +!  10 score +!  adjust-delay  ;

: remove-lines  ( -- )
  deep deep
  begin
    swap
    begin
      1- dup 0< if  2drop exit  then  dup line-full?
    while
      new-level
    repeat
    swap 1- 2dup <> if  2dup move-line  then
  again  ;

-->

( tt )

: interaction  ( -- f )
  case  key upper
    left-key      of  0 -1 move-brick drop  endof
    right-key     of  0  1 move-brick drop  endof
    rot-key       of  0 rotate-brick drop  endof
    drop-key      of  drop-brick  endof
    pause-key     of  S"  Paused " bottom-msg  key drop
                      draw-bottom  endof
    quit-key      of  false exit  endof
  endcase  true  ;

: initialize  ( -- )
  frames@ d>s randomize
  score off  pieces off  levels off  adjust-delay
  empty-pit page arena  ;
  \ Prepare for playing.

-->

( tt )

: play-game  ( -- )
  begin
    new-brick  -1 3 insert-brick
  while
    begin
      4 0 do
        delay @ ms key?
        if  interaction 0= if  unloop exit  then  then
      loop
      1 0 move-brick 0=
    until
    remove-lines  update-score  adjust-delay
  repeat  ;
  \ Play one tt game.

-->

( tt )

also forth definitions

: again?  ( -- f )  s"  Again? (Y/N) " bottom-msg yes?  ;

: start-message  ( -- )  ." Type RUN to start tt" cr  ;

: end-message  ( -- )  0 23 at-xy cr start-message  ;

: run  ( -- )
  show-help
  begin  initialize play-game again? 0=  until
  draw-bottom end-message  ;
  \ Play the tt game.

cr start-message

only forth definitions

  \ }}} =======================================================
  \ Sample game: Towers of Hanoi {{{

( hanoi )

  \ XXX UNDER DEVELOPMENT

  \ Credits:
  \ Code converted from hForth

  \ -----------------------------------------------------------
  \ hanoi.4th
  \
  \ Towers of Hanoi puzzle
  \
  \ From a posting to comp.lang.forth, 30 May 2002, by Marcel
  \ Hendrix and Brad Eckert. According  to Marcel Hendrix, the
  \ code for the HANOI algorithm was originally posted to clf
  \ by Raul Deluth Miller in 1994.
  \
  \ -----------------------------------------------------------
  \ kForth includes and defs  (2002-05-30  K. Myneni)
  \ -----------------------------------------------------------

  \ include strings
  \ include ansi

  \ -----------------------------------------------------------

only forth definitions

need don't  need ms  need mode64

vocabulary hanoi  also hanoi definitions

variable slowness  1000 slowness !
  \ ms delay between screen updates

3 constant pegs

create PegSPS  pegs cells allot
  \ pointers for three disk stacks

: PegSP     ( peg -- addr ) cells PegSPS + ;
: PUSH      ( c peg -- )    PegSP tuck @ c!  1 chars swap +! ;
: POP       ( peg -- c )    PegSP -1 chars over +!  @ c@ ;

create PegStacks  30 chars allot
  \ stack area for up to 10 disks

: PegStack  ( peg -- addr )   10 * PegStacks + ;

: clear-peg    ( peg -- )  dup PegStack  swap PegSP ! ;
: clear-pegs  ( -- )  pegs 0 do  i clear-peg  loop  ;

  \ : PegDepth  ( peg -- depth )  dup PegSP @  swap PegStack - ;
  \ XXX OLD not needed

-->

( hanoi )

: show-disk  ( level diameter peg -- )
  22 * 10 + over -  rot 10 swap - at-xy
  2* [char] * emits ;

: show-peg   ( peg -- )
  dup >r PegStack
  BEGIN   r@ PegSP @ over <>
  WHILE   dup r@ PegStack - over c@  ( addr level diameter )
          r@ show-disk  char+
  REPEAT  drop r> drop ;

-->

( hanoi )

: ?allot  ( n -- )  here swap allot ;

: maketab  ( n1..nn n -- XXX ) \ XXX TODO stack effect
  create
    dup ?allot over 1- + swap 0
    2dup <> if    do  dup >r c! r> 1-  loop
            else  2drop
            then  drop
  does>  + c@ ;

#3 base !
00 02 01 12 00 10 21 20  #8 maketab TO!
00 21 12 20 00 02 10 01  #8 maketab FRO!
decimal

-->

( hanoi )

: finished  ( -- )  key drop 0 11 at-xy ." Stopped" cr abort  ;

: show-pegs  ( -- )
  page  pegs 0 do  i show-peg  loop  slowness @ ms
  key? if  finished  then ;

: move-ring  ( ring -- ring )
  dup to! 3 / pop  over fro! 3 mod push show-pegs ;

: tower ( depth direction -- depth direction )
  swap 1- swap over
  IF    to!  recurse  to! move-ring fro! recurse  fro!
  ELSE  move-ring
  THEN  swap 1+ swap ;

-->

( hanoi )

: run  ( depth -- )

  clear-pegs

  dup BEGIN ?dup WHILE 1- dup 0 push REPEAT
    \ stack up some disks

  show-pegs 1 tower 2drop
    \ move them

  0 11 at-xy ;

mode64 page
  \  <-------------------------->
  .( Towers of Hanoi) cr
  .( Type 'n run' to play where) cr
  .( 'n' is the number of disks.) cr
  \  <-------------------------->

  \ }}} =======================================================
  \ Sample game: Life {{{

( life )

  \ XXX UNDER DEVELOPMENT
  \
  \ XXX -- works in Gforth, but freezes here.

  \ Credits:
  \ Code adapted from kForth. Original Credits:

  \ ____
  \
  \ Conway's Game of Life, or Occam's Razor Dulled
  \
  \ The original ANS Forth version by Leo Wong (see bottom) has
  \ been modified slightly to allow it to run under kForth.
  \ Also, delays have been changed from 1000 ms to 100 ms for
  \ faster update --- K. Myneni, 12-26-2001
  \
  \ 950724 + 970703 +
  \ Copyright 1995 Leo Wong
  \ hello at albany dot net
  \ http://www.albany.net/~hello/
  \ ____

need ms  need c+!  need 2/

1 CHARS CONSTANT /Char

  \ the universal pattern
32 CONSTANT How-Deep  24 CONSTANT How-Wide

How-Wide How-Deep *
  \  1-  \ 1- prevents scrolling on my screen \ XXX OLD
   CONSTANT Homes

  \ world wrap
: World  ( "name" -- )
  CREATE  Homes CHARS ALLOT
  DOES>  ( u -- c-addr )
    ( u pfa ) SWAP Homes +  Homes MOD  CHARS + ;

World old  World new

-->

( life )

  \ biostatistics

  \ begin hexadecimal numbering
  \ hex xy : x holds life , y holds neighbors count

$10 CONSTANT Alive  \ 0y = not alive

  \ Conway's rules:
  \ a life depends on the number of its next-door neighbors

  \ it dies if it has fewer than 2 neighbors
: Lonely  ( char -- flag )  $12 < ;

  \ it dies if it has more than 3 neighbors
: Crowded  ( char -- flag )  $13 > ;

: -Sustaining  ( char -- flag )  DUP Lonely  SWAP Crowded  OR ;

  \ it is born if it has exactly 3 neighbors
: Quickening  ( char -- flag )  $03 = ;

-->

( life )

  \ compass points
: N  ( i -- j )  How-Wide - ;
: S  ( i -- j )  How-Wide + ;
: E  ( i -- j )  1+ ;
: W  ( i -- j )  1- ;

  \ census
: Home+!  ( -1|1 i -- )  >R  Alive *  R> new C+! ;

: Neighbors+!  ( -1|0|1 i -- )
   2DUP N W new C+!  2DUP N new C+!  2DUP N E new C+!
   2DUP   W new C+!  (     i      )  2DUP   E new C+!
   2DUP S W new C+!  2DUP S new C+!       S E new C+! ;

: Bureau-of-Vital-Statistics ( -1|1 i -- )
   2DUP Home+!  Neighbors+! ;

  \ mortal coils
CHAR ? CONSTANT Soul  BL CONSTANT Body

-->

( life )

: Home  ( char i -- )  How-Wide /MOD AT-XY  EMIT ;

: Is-Born  ( i -- )
  Soul OVER Home  1 SWAP Bureau-of-Vital-Statistics ;

: Dies  ( i -- )
  Body OVER Home  -1 SWAP Bureau-of-Vital-Statistics ;

: One  ( c-addr -- i )  0 old -  /Char / ;

-->

( life )

: there  ( -- )  How-Wide 1- 0 AT-XY ;

: Everything  ( -- )
   0 old  Homes
   BEGIN  DUP
   WHILE  OVER C@  DUP Alive AND
      IF   -Sustaining IF  OVER One Dies     THEN
      ELSE  Quickening IF  OVER One Is-Born  THEN THEN
      1 /STRING
   REPEAT  2DROP
   there  ;

-->

( life )

  \ in the beginning
: Void  ( -- )  0 old  Homes BLANK ;

  \ spirit
: Voice  ( -- c-addr u )
   PAGE ." Say: "  0 new  DUP Homes ACCEPT ;

  \ subtlety
: Serpent  ( -- )
  0 2 AT-XY  ." Press a key for knowledge."  KEY DROP
  0 2 AT-XY  ." Press space to re-start, Esc to escape life." ;

  \ the primal state
: Innocence  ( -- )
   Homes 0 DO  I new C@  Alive /  I Neighbors+!  LOOP ;

  \ children become parents
: Passes  ( -- )  0 new  0 old  Homes  CMOVE ;

-->

( life )

  \ a garden
: Paradise  ( c-addr u -- )
   >R  How-Deep How-Wide *  How-Deep 2 MOD 0=  How-Wide AND -
   R@  -  2/  old
   R>  CMOVE
   0 old  Homes 0
   DO  COUNT BL <>
       DUP IF  Soul I Home  THEN
       Alive AND  I new C!
   LOOP  DROP
   Serpent
   Innocence Passes ;

-->

( life )

: Creation  ( -- )  Void Voice Paradise ;

  \ the human element

100 CONSTANT Ideas
: Dreams  ( -- )  Ideas MS ;

100 CONSTANT Images
: Meditation  ( -- )  Images MS ;

  \ free will
: Action  ( -- char )
  KEY? DUP
  IF  DROP KEY  DUP BL = IF  Creation  THEN
  THEN ;

  \ environmental dependence
7 CONSTANT Escape

  \ history
: Goes-On  ( -- )
   BEGIN  Everything Passes  Dreams Action Meditation
          Escape = UNTIL ;

  \ a vision
: Life  ( -- )  Creation Goes-On ;

  \ Life


  \ }}} =======================================================
  \ Sample game: Toe {{{

( toe )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-24: Changes.

  \ Credits:
  \
  \ Based on code from Leo Brodie's _Starting Forth_, ANSized
  \ by Benjamin Hoyt in 1997.

9 constant squares

1 constant player-x  2 constant player-o

create board  squares allot

: clear  ( -- )  board squares erase  ;  clear

: >square  ( square -- ca )  board +  ;
: square@  ( square -- c )  >square c@  ;
: square!  ( c square -- )  >square c!  ;

: bar  ( -- )  ." | "  ;
: dashes  ( -- )  cr  9 0 do  '-' emit  loop cr  ;

: .player-mark  ( player -- )
  player-x = if ." x " else ." o " then  ;

: .box-contents  ( n -- )
  ?dup if  .player-mark  else  2 spaces  then  ;

: .box  ( square -- )  square@  .box-contents  ;

-->

( toe )

: display  ( -- )
  home
  squares 0 do
    i if    i 3 mod  0= if  dashes  else  bar  then
      then  i .box
  loop  cr  ;

: limited  ( square -- square' )  0 max squares min  ;

: play  ( square player -- )  swap 1- limited square! ;

: x  ( square -- )  player-x play  display ;
: o  ( square -- )  player-o play  display ;

  \ }}} =======================================================
  \ Sample game: Pong {{{

( pong )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO slow the rackets

  \ Credits:
  \ Code adapted from IsForth (version 1.23v).

  \ ____
  \
  \ pong.f
  \ Written june 2002 by Robert Oestling
  \ <robost at telia dot com>
  \ Tested with IsForth, http://isforth.clss.net/
  \ ____

need columns  need rows  need udg:  need rnd  need ??
3 constant /k  need pressed?
need cvariable  need 2/  need pixel-addr
need break-key?  need hires-emit-udg  need c!toggle-bits

0 cconstant black  7 cconstant white

  \ XXX OLD
  \ 500 constant initial-speed
  \ variable speed
  \ Delay in milliseconds.

8 cconstant ball-delay0
  \ Counter: Times the ball is not moved in the main loop.
variable ball-delay
  \ XXX NEW

4 cconstant racket-size

: brighty  ( n1 -- n2 )  %1000000 or  ;
: paper-color  ( n1 -- n2 )  8 *  ;

white paper-color brighty cconstant racket-color

22528 constant top-line-attr
  \ address of the top left screen attribute
23264 constant bottom-line-attr
  \ address of the bottom left screen attribute

code sync  ( -- )  78 c,  jpnext  end-code
  \ Z80 halt

-->

( pong )

  \ Key constant are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant left1-key   char 1 cconstant left1-char
$02 $F7FE 2constant right1-key  char 2 cconstant right1-char
  \ Player 1 keys.

$10 $EFFE 2constant left2-key   char 6 cconstant left2-char
$08 $EFFE 2constant right2-key  char 7 cconstant right2-char
  \ Player 2 keys.

variable x  variable y
  \ Coordinates of the ball.

cvariable direction
  \ Direction of ball.
  \ Bit 0: 1 = down, 0 = up.
  \ Bit 1: 1 = right, 0 = left.

variable points1  variable points2
  \ Player points.

variable racket1-x  columns racket-size - 2/  racket1-x !
  \ Top racket x coordinate.

variable racket2-x  racket1-x @ racket2-x !
  \ Bottom racket x coordinate.

0 cconstant racket1-y
  \ Top racket y coordinate.

rows 1- cconstant racket2-y
  \ Bottom racket y coordinate.

-->

( pong )

%00111100
%01111110
%11111111
%11111111
%11111111
%11111111
%01111110
%00111100 128 udg: (ball)  0 cconstant ball \ XXX TMP

  \ XXX TODO -- frames

  \ %00111100
  \ %01111110
  \ %11111011
  \ %11111101
  \ %11111111
  \ %11111111
  \ %01111110
  \ %00111100 128 udg: ball0

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111101
  \ %11111101
  \ %11111111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111101
  \ %11111011
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11100111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11110011
  \ %01111110
  \ %00111100 130 udg: ball1

-->

( pong )

: restore-screen  ( -- )  default-colors page  ;

: init-screen  ( -- )  restore-screen white ink  ;

: ball-xy  ( -- x y )  x @ y @  ;

: show-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: erase-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: (border)  ( a -- )
  columns [ white paper-color ] literal sync fill  ;

: top-border  ( -- )  top-line-attr (border)  ;

: bottom-border  ( -- )  bottom-line-attr (border)  ;

-->

( pong )

: show-racket  ( a -- )  racket-size racket-color sync fill  ;

: show-racket1  ( -- )
  top-line-attr dup (border) racket1-x @ + show-racket  ;

: show-racket2  ( -- )
  bottom-line-attr dup (border) racket2-x @ + show-racket  ;

: show-rackets  ( -- )  show-racket1 show-racket2  ;

: racket-initial-x  ( -- n )
  columns 2/ [ racket-size 2/ ] literal -  ;

: reset-rackets  ( -- )
  racket-initial-x dup racket1-x ! racket2-x !  ;

-->

( pong )

: erase-racket  ( a1 a2 -- )  @ + racket-size erase  ;
  \ Erase a racket.
  \ a1 = address of the first screen attribute on the row
  \ a2 = variable that holds the racket x coordinate

: erase-racket1  ( -- )
  top-line-attr racket1-x erase-racket  ;
  \ Erase racket of player 1.

: erase-racket2  ( -- )
  bottom-line-attr racket2-x erase-racket  ;
  \ Erase racket of player 2.

-->

( pong )

: (print-points)  ( n y -- )
  0 swap at-xy s>d <# # # # #>
  black ink sync type white ink  ;
  \ Print the points of a player.

: print-points1  ( -- )
  points1 @ racket1-y (print-points) show-racket1  ;
  \ Print the points of player 1.

: print-points2  ( -- )
  points2 @ racket2-y (print-points) show-racket2  ;
  \ Print the points of player 2.

: print-points  ( -- )  print-points1 print-points2  ;
  \ Print the points of both players.

: change-x  ( -- )  %10 direction c!toggle-bits  ;
  \ Change the x direction of the ball.

: change-y  ( -- )  %01 direction c!toggle-bits  ;
  \ Change the y direction of the ball.

: faster  ( -- )
  exit  ;  \ XXX OLD
  \ speed @ 40 > if  speed @ dup 20 / - speed !   then  ;
  \ If the delay is more than 40 ms, reduce it with 5%.

-->

( pong )

: ball-moving-right?  ( -- f )  direction c@ %10 and  ;
: ball-moving-down?  ( -- f )  direction c@ %01 and  ;
  \ : ball-at-right?  ( -- wf )  x @ columns 1- =  ;
: ball-at-right?  ( -- wf )  x @ 247 >  ;
: ball-at-left?  ( -- wf )  x @ 1 <  ;
  \ : ball-at-bottom?  ( -- wf )  y @ rows 2- =  ;
: ball-at-bottom?  ( -- wf )  y @ 16 <  ;
  \ : ball-at-top?  ( -- wf )  y @ 1 =  ;
: ball-at-top?  ( -- wf )  y @ 182 >  ;

: move-ball-x  ( -- )
  ball-moving-right?
  if
    \ 0 2 at-xy ." right" \ XXX INFORMER
    ball-at-right?  if  change-x  then  1
  else
    \ 0 2 at-xy ." left " \ XXX INFORMER
    ball-at-left?   if  change-x  then  -1
  then  x +!  ;

-->

( pong )

: reset-ball  ( -- )
  128 x !  95 y !  rnd %11 and direction c!  ;
  \ Reset the ball position and direction.

: ready  ( -- )  reset-rackets reset-ball  ;

: score-player1  ( -- )  1 points1 +! print-points1  ;
  \ Increase player 1's points by one.

: score-player2  ( -- )  1 points2 +! print-points2  ;
  \ Increase player 2's points by one.

[defined] 8* ?\ : 8*  ( n1 -- n2 )  2* 2* 2*  ;

: hit-racket1?  ( -- wf )
  x @ racket1-x @ 8* 1- >
  x @ racket1-x @ 8* racket-size 8* + <  and  ;
  \ Is racket1 hit by the ball?
  \ Is racket1-x <= x < racket1-x + racket-size?

: hit-racket2?  ( -- wf )
  x @ racket2-x @ 8* 1- >
  x @ racket2-x @ 8* racket-size 8* + <  and  ;
  \ Is racket2 hit by the ball?
  \ Is racket2-x <= x < racket2-x + racket-size?

  \ : hit-racket?  ( a -- wf )
  \   \ XXX NEW -- alternative
  \   \ XXX TODO try
  \   \ a = address that holds the x coordinate of a racket
  \   @ 8* x @ swap  ( ball-x pad-x )
  \   2dup 1- > >r
  \   racket-size 8* + <  r> and  ;

-->

( pong )

: possible-top-hit  ( -- )
  hit-racket2? if change-y  else  score-player1 ready  then  ;

: move-ball-down  ( -- )
  ball-at-bottom? if  possible-top-hit  else  -1 y +!  then  ;

: possible-bottom-hit  ( -- )
  hit-racket1? if  change-y  else  score-player2 ready  then  ;

: move-ball-up  ( -- )
  ball-at-top? if  possible-bottom-hit  else  1 y +!  then  ;

: move-ball-y  ( -- )
  ball-moving-down?
  if  move-ball-down  else  move-ball-up  then  ;

8 cconstant racket-delay0
  \ Counter: Times the rackets are not moved in the main loop.
variable racket1-delay
variable racket2-delay

-->

( pong )

: ?move-ball  ( -- )
  -1 ball-delay +!  ball-delay @ if  unnest  exit  then
  ball-delay0 ball-delay !  ;

: move-ball  ( -- )
  ?move-ball
  erase-ball move-ball-x move-ball-y show-ball  ;

: frame  ( -- )  white border  top-border bottom-border  ;

: arena-line  ( -- )
  [ 0 96 pixel-addr nip ] literal columns %10101010 fill
  [ 0 95 pixel-addr nip ] literal columns %01010101 fill  ;

: arena  ( -- )
  cls  frame arena-line show-rackets print-points show-ball  ;

-->

( pong )

: ?move-racket1  ( -- )
  -1 racket1-delay +!  racket1-delay @ if  unnest exit  then
  racket-delay0 racket1-delay !  ;

: (move-racket1)  ( 1|-1 -- )  racket1-x +!  show-racket1  ;

: move-racket1-left  ( -- )
  ?move-racket1
  racket1-x @ 0= ?exit
  -1 (move-racket1)  ;

: move-racket1-right  ( -- )
  ?move-racket1
  racket1-x @ racket-size + columns = ?exit
  1 (move-racket1)  ;

-->

( pong )

: ?move-racket2  ( -- )
  -1 racket2-delay +!  racket2-delay @ if  unnest exit  then
  racket-delay0 racket2-delay !  ;

: (move-racket2)  ( 1|-1 -- )  racket2-x +!  show-racket2  ;

: move-racket2-left  ( -- )
  ?move-racket2
  racket2-x @ 0= ?exit
  -1 (move-racket2)  ;

: move-racket2-right  ( -- )
  ?move-racket2
  racket2-x @ racket-size + columns = ?exit
  1 (move-racket2)  ;

-->

( pong )

: reset-points  ( -- )  points1 off  points2 off  ;

: init-game  ( -- )
  init-screen reset-points
  racket-delay0  dup racket1-delay !  racket2-delay !
  ball-delay0 ball-delay ! ready  ;

: quit-game  ( -- )
  restore-screen  ." Player 1 score: " points1 ? cr
                  ." Player 2 score: " points2 ?  quit  ;

  : keypress  ( key -- )
    left1-key     pressed? ?? move-racket1-left
    right1-key    pressed? ?? move-racket1-right
    left2-key     pressed? ?? move-racket2-left
    right2-key    pressed? ?? move-racket2-right
                break-key? ?? quit-game  ;  -->

( pong )

: show-player-key  ( c ca len -- )
  space rot emit ."  = " type cr  ;

: show-player-keys  ( c1 c2 -- )
  s" left" show-player-key  s" right" show-player-key  ;

: show-game-keys  ( -- )
  ." Player 1:" cr right1-char left1-char show-player-keys
  ." Player 2:" cr right2-char left2-char show-player-keys
  ." Break (Shift+Space) = quit"  ;

-->

( pong )

: show-credits  ( -- )

  \  <------------------------------>
  ." Forth Pong" cr cr
  ." Original code by:" cr
  ."   Robert Oestling, 2002" cr
  ." Ported to IsForth by:" cr
  ."   Mark Manning, 2012" cr
  ." Rewritten for Solo Forth by:" cr
  ."   Marcos Cruz" cr
  ."   (programandala.net), 2015" cr  ;
  \  <------------------------------>

: press-any-key  ( -- )
  \  <------------------------------>
  ." Press any key to start the game." key drop  ;

: welcome  ( -- )
  page show-credits cr show-game-keys cr cr press-any-key  ;

-->

( pong )

: pong  ( -- )
  init-game welcome page arena
  begin  move-ball
  \ begin key? until key drop  \ XXX TMP -- for debugging
  keypress  again  ;

  \ }}} =======================================================
  \ Benchmarks {{{

  \ This section contains generic benchmarks.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between differen implementation
  \ options, are in "Development benchamarks" section.

( bench marque )

  \ Code adapted from:
  \ Forth Dimensions Volume XVII number 4 page 11.

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench  ( -- )  reset-frames  ;
  \ start timing

  \ XXX OLD
  \ : sec.  ( n -- )  s>d <# # # [char] . hold #s #> type  ;

: marque  ( -- )
  frames@ 2dup d. ." frames (" 50 m/ nip . ." s) " cr  ;
  \ stop timing and show the frames and the seconds

exit

  \ System-dependent timing routines.

  \ Original code.

  \ This is the ForthCMP/ZEN/ANS version,
  \ output doubles are seconds since midnight.

: gettime  ( -- sec min hour )  time&date 2drop drop  ;

: t>b  ( sec min hour -- d )  60 * +  60 um*  rot s>d d+  ;

: bench  ( -- d )  cr gettime t>b 2dup d.  ;
  \ start timing

: marque  ( d -- )  gettime t>b 2dup d. d- dnegate d.   ;
  \ stop timing

( byte-magazine-benchmark )

  \ Code adapted from:
  \ Forth Dimensions Volume XVII number 4 page 11.

need bench  need marque

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop  u. ." PRIMES" cr  ;

-->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( -- )
  ." 1000 iterations" cr
  bench 100 0 do  do-prime  loop marque  ;

  .( To run the BYTE Magazine benchmark type:) cr
  .(   byte-magazine-benchmark)

( interface-age-benchmark )

  \ Code adapted from:
  \ Forth Dimensions Volume XVII number 4 page 11.

  \ Interface Age Benchmark, 1985-11-16.
  \ This is the Interface Age benchmark
  \ program described in Appendix D of the
  \ forthCMP Manual.

  \ XXX UNDER DEVELOPMENT
  \ XXX FIXME crash because Forth-83 `leave` is not fully implemented

need bench  need marque

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop  if  .  else  drop  then
  loop  drop cr  ;

-->

( interface-age-benchmark )

: interface-age-benchmark  ( -- )
  bench 5000 (interface-age-benchmark) marque  ;

  .( To run the interface age benchmark type:) cr
  .(   interface-age-benchmark  )

( vector-loop-benchmark )

  \ Code adapted from:
  \ Forth Dimensions Volume XVII number 4 page 11.

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench  need marque

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

-->

( vector-loop-benchmark )

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !  1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  \ XXX FIXME crash!
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !  1+ dup vsize =
  until  drop  ;

: loop3 ( -- ) \ vector divide
  0 begin  dup vec1 @ over vec2 @ / over vec3 !  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench 0 begin  loop0 1+ dup reps =  until  drop marque
  ." Vector No-Op" cr ;

: bench1 ( -- ) \ benchmark loop1
  bench 0 begin  loop1 1+ dup reps =  until  drop marque
  ." Vector +    " cr ;

: bench2 ( -- ) \ benchmark loop2 )
  bench 0 begin  loop2 1+ dup reps =  until  drop marque
  ." Vector *    " cr ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench 0 begin  loop3 1+ dup reps =  until  drop marque
  ." Vector /    " cr ;

: bench4 ( -- ) \ benchmark loop4
  bench 0 begin  loop4 1+ dup reps =  until  drop marque
  ." Vector */   " cr ;

: vector-loop-benchmark  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  .( To run the vector benchmarks type:) cr
  .(   vector-loop-benchmark )

( all-benchmarks )

  \ Code adapted from:
  \ Forth Dimensions Volume XVII number 4 page 11.

  .( hola)

exit

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  .( To run all benchmarks type:) cr
  .(   all-benchmarks)

  \ }}} =======================================================
  \ Development benchmarks {{{

  \ This section contains specific benchmarks written during
  \ the development of Solo Forth in order to decide between
  \ different implementation options.
  \
  \ Generic benchmarks are in the "Benchamarks" section.

( number-base-bench )

: number-base-1  ( ca len -- ca' len' n )
  \ This is the current version defined in the kernel.
  over c@ [char] $ = if  1 /string 16  exit  then
  over c@ [char] % = if  1 /string  2  exit  then
  over c@ [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-2  ( ca len -- ca' len' n )
  over c@ >r
  r@ [char] $ = if  1 /string 16  rdrop exit  then
  r@ [char] % = if  1 /string  2  rdrop exit  then
  r> [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-3  ( ca len -- ca' len' n )
  over c@
  dup >r [char] $ = if  1 /string 16  rdrop exit  then
      r@ [char] % = if  1 /string  2  rdrop exit  then
      r> [char] # = if  1 /string 10  exit  then  base @  ;

-->

( number-base-bench )

: number-base-4  ( ca len -- ca' len' n )
  over c@
  dup [char] $ = if  drop 1 /string 16  exit  then
  dup [char] % = if  drop 1 /string  2  exit  then
      [char] # = if  1 /string 10  exit  then  base @  ;

need frames@  need reset-frames  defer (number-base)

: (number-base-bench)  ( n cfa -- )
  ['] (number-base) defer!
  reset-frames  0 do  s" 000" (number-base) drop 2drop  loop
  frames@ d. cr  ;

: number-base-bench  ( n -- )
  dup ['] number-base-1 (number-base-bench)
  dup ['] number-base-2 (number-base-bench)
  dup ['] number-base-3 (number-base-bench)
      ['] number-base-4 (number-base-bench) ;

  \ 2015-10-09
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          1    2    3    4
  \       ---- ---- ---- ----
  \ 01000   73   75   74   69
  \ 10000  732  744  736  686
  \ 32000 2343 2382 2367 2194

( fill-bench )

  \ 2015-09-25: Benchmark three implementations of `fill`:
  \
  \ `fill` is the original implementation from Abersoft Forth
  \ `fill2` is a modified version
  \ `fill88` is the code adapted from Z88 CamelForth

need frames@  need reset-frames  need rnd

defer (fill)

: (fill-bench)  ( n cfa -- )
  ['] (fill) defer!
  reset-frames  0
  do  16384 6144 rnd (fill)  loop
  \ do  16384 1 rnd (fill)  loop
  \ do  16384 0 rnd (fill)  loop
  \ do  16384 2048 rnd (fill)  loop
  frames@ cr d.
  key drop  ;

: fill-bench  ( n -- )
  dup ['] fill (fill-bench)
  dup ['] fill2 (fill-bench)
      ['] fill88 (fill-bench)  ;

  \ Kernel code: `16384 6144 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010   10    10      5
  \ 00100  491   522    252
  \ 01000 4909  5218   2524

  \ Kernel code: `16384 1 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    9     8      8
  \ 01000   85    84     84
  \ 05000  425   423    422
  \ 10000  850   846    845

  \ Kernel code: `16384 0 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    8     8      8
  \ 01000   84    83     84
  \ 05000  421   418    421
  \ 10000  842   837    842

  \ Kernel code: `16384 2048 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill  fill2 fill88
  \       ----- ----- ------
  \ 00010    17    18      9
  \ 00100   169   180     89
  \ 01000  1693  1795    898
  \ 30000 50770 53863  26933

( value-bench )

need frames@  need reset-frames

0 value v1

: value-bench  ( n -- )
  reset-frames  0 do  v1 drop  loop  frames@ cr d.  ;

( 2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2value-bench  ( n -- )
  reset-frames  0 do  v2 2drop  loop  frames@ cr d.  ;

( to-value-bench )

need frames@  need reset-frames

0 value v1

: to-value-bench  ( n -- )
  reset-frames  0
  do  0 to v1   loop
  frames@ cr d.  ;

( to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: to-2value-bench  ( n -- )
  reset-frames  0
  do  0. to v2   loop
  frames@ cr d.  ;

( 2to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2to-2value-bench  ( n -- )
  reset-frames  0
  do  0. 2to v2   loop
  frames@ cr d.  ;

( rshift-bench lshift-bench )

need frames@  need reset-frames

: rshift-bench  ( n -- )
  reset-frames  0
  do  128 255 rshift drop   loop
  frames@ cr d.  ;

: lshift-bench  ( n -- )
  reset-frames  0
  do  128 255 lshift drop   loop
  frames@ cr d.  ;

  \ 2015-11-01

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       rshift         lshift
  \       -------------- --------------
  \        Z88  DZX    %  Z88  DZX    %
  \       ---- ---- ---- ---- ---- ----
  \ 10000 1203 1609 133% 1016 1723 169%
  \ 30000 3607 4826 133% 3048 5170 169%

  \ Z88 = code adapted from Z88 CamelForth
  \ DZX = code adapted from DZX-Forth

( /-bench )

  \ 2015-09-22: This bench compares the execution speed of
  \ Abersoft Forth's `m/` and Z88 CamelForth's `sm/rem`. Both
  \ words are equivalent.  Abersoft Forth's `m/` is much
  \ faster.

need frames@  need reset-frames  need rnd

: drnd  ( -- d )  rnd rnd  ;

[defined] (/)  ?\ defer (/)

: (/-bench)  ( n -- )
  reset-frames
  1+ 1 do  drnd i (/) 2drop  loop  frames@ cr d.  ;

: /-bench  ( n -- )
  dup ['] m/ ['] (/) defer! (/-bench)
      ['] sm/rem ['] (/) defer! (/-bench)  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       m/    sm/rem
  \       ----- ------
  \ 00010     3      4
  \ 00100    33     44
  \ 01000   326    442

  \ m/     = word from Abersoft Forth
  \ sm/rem = word from Z88 Camel Forth

( um*-bench )

need frames@  need reset-frames

: um*-bench  ( n -- )
  reset-frames  0 do  i i um* 2drop  loop  frames@ d.  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       DZX   hForth R hForth A Z88 R Z88 A
  \       ----- -------- -------- ----- -----
  \ 00100     3        3        3     3     3
  \ 01000    29       32       31    32    31
  \ 10000   297      328      319   323   316
  \ 20000   598      659      643   647   633
  \ 32000   961     1060     1037  1037  1016

  \            Bytes free Code from
  \            ---------- ---------
  \ DZX      = 33783      DZX-Forth
  \ hForth R = 33787      hForth, with relative jumps
  \ hForth A = 33784      hForth, with absolute jumps
  \ Z88 R    = 33786      Z88 CamelForth, with relative jumps
  \ Z88 A    = 33784      Z88 CamelForth, with absolute jumps

( um/mod-bench )

  \ 2015-11-24

need bench

: um/mod-bench  ( n -- )
  bench  0 do  i s>d i um/mod 2drop  loop  marque  ;

: um/mod-bench88  ( n -- )
  bench  0 do  i s>d i um/mod88 2drop  loop  marque  ;

: um/mod-bench  ( n -- )
  dup cr ." Abersoft Forth  U/MOD ..." um/mod-bench
      cr ." Z88 CamelForth UM/MOD ..." um/mod-bench88  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          AF      Z88
  \       ----- --------------
  \ 00100     6        5
  \ 01000    59       42 (71%)
  \ 10000   587      428 (72%)
  \ 20000  1157      875 (75%)
  \ 32000  1881     1372 (72%)

  \            Bytes free Code from
  \            ---------- ---------
  \ AF         32689      Abersoft Forth
  \ Z88        32707      Z88 CamelForth

( number? )

  \ XXX UNDER DEVELOPMENT
  \ Improved alternative to `number?`.

: solo-number?   ( ca len -- 0 | n 1 | d 2 )
  dup 0= if  2drop 0 exit  then
  base @ >r number-base base !
  skip-sign? >r
  0 0 2swap  dpl on
  begin
    >number dup
  while
    over c@ [char] . <>  \ not a decimal point?
    dpl @ 0< 0=  or  \ or not the first decimal point?
    if  2drop 2rdrop 0 exit  then
    dup 1- dpl !  1 /string
  repeat  2drop  dpl @ 0<
  if    d>s r> ?negate  1
  else  r> ?dnegate  2  then  r> base !  ;

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 12345" num?   s" 12345." num?
    s" -12345" num?  s" -12345." num?  empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

                                    \ Version of `number?`
  \    ' number? ' num? defer! benchs  \ pForth
  \  ' c.number? ' num? defer! benchs  \ CamelForth
  \ ' dzx-number? ' num? defer! benchs  \ DZX-Forth
   ' solo-number? ' num? defer! benchs  \ Solo Forth

  \ Note: The CamelForth code is for single numbers only.
  \       The DZX-Forth code is a bit obfuscated.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       pForth CamelForth DZX-Forth Solo Forth
  \       ------ ---------- --------- ----------
  \ 00100    256        257       259        266
  \ 01000   2559       2565      2594       2658
  \ 10000  25591      25652     25933      26581

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 123x45." num?   s" 12345.999x" num?
    s" -12345.x" num?  s" -12345.999x" num?
    s" -12345.000.000" num?
    empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

' solo-number? ' num? defer! benchs

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \ 00100   416
  \ 01000  4165
  \ 10000 41649

( dummy-needed )

( buffer-benchmark-1 )

  2 load need reset-frames
  reset-frames

  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed

  frames@ cr .( Frames ) d. cr

  \ 2015-11-04

  \ Benchmark: Locate and load 16 times empty block #457.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \        512-byte buffer 1024-byte buffer
  \       ---------------- ----------------
  \    16             6323       8621 (136%)

( buffer-benchmark-2 )

  2 load  need reset-frames  warnings off  reset-frames

  need list  need dump  need wdump  need decode
  need life  need hanoi  need tt need siderator  need pong
  need doer  need a!  need defer  need value  need editor
  need case  need times  need dtimes  need for

  frames@ cr .( Frames ) d. cr

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-04 512-byte buffer       33742        20960 (1.00)
  \            1024-byte buffer      33277 (-465) 24310 (1.15)
  \                                               24042 (1.14)

  \ This is not good for benchmarking the headers, because most
  \ of the time is wasted locating the blocks. That's why
  \ both methods are equally fast:

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

  \ XXX UNDER DEVELOPMENT

002 load need bench warnings off bench : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; marque

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        490 (9 s)
  \            `next-name` (4)       32791        494 (9 s)
  \            `nextname` (2)        32781        491 (9 s)
  \            `nextname` (3)        32765        494 (9 s)

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.
  \
  \ (3) Same as (2) but with zero-length name check.
  \
  \ (4) Same as (1) but with zero-length name check.

( header-benchmark )

  \ XXX UNDER DEVELOPMENT


2 load need bench warnings off blk @ 1+ constant b bench b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load marque

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

  frames@ cr .( Frames ) d. cr  sp0 @ sp!

  \ 2015-11-12
  \
  \ How `interpret`
  \ interprets numbers   Bytes free  Frames
  \ ------------------   ----------  -------------
  \ branches (1)              32766     500 (1.00)
  \ execution table (1)       32770     497 (0.99)
  \ execution table (2)       32761     498 (0.99)

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

: foo  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ;

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ compiles numbers    Bytes free  Frames
  \ ----------------    ----------  ------------
  \ branches (1)             32766     510 (1.00)
  \ execution table (1)      32770     507 (0.99)
  \ execution table (2)      32761     508 (0.99)

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ interprets words               Bytes free  Frames
  \ ------------------             ----------  -------------
  \ branches (0)                        32770     192 (1.00)
  \ independent table (1)               32746     190 (0.98)
  \ combined table (2)                  32747     190 (0.98)
  \ combined table (3)                  32753     192 (1.00)
  \ combined table (4)                  32761     190 (0.98)

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

: foo noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop ;

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ compiles words                 Bytes free  Frames
  \ ------------------             ----------  -------------
  \ branches (0)                        32770     199 (1.00)
  \ independent table (1)               32746     198 (0.98)
  \ combined table (2)                  32747     198 (0.99)
  \ combined table (3)                  32753     200 (1.00)
  \ combined table (4)                  32761     198 (0.98)

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor

  \ 1 frame = 50th of second

( constant-bench )

need reset-frames  need frames@

0 constant const1

: bench1  ( n -- )
  reset-frames 0 do  const1 drop  loop
  frames@ d. cr ;

: const2  ( -- x )  const1 cell+  ;

: bench2  ( n -- )
  reset-frames 0 do  const2 drop  loop
  frames@ d. cr ;

( literal-bench )

need reset-frames  need frames@

: bench1  ( n -- )
  reset-frames 0 do  cell negate drop  loop
  frames@ d. cr ;

: bench2  ( n -- )
  reset-frames 0 do  [ cell negate ] literal drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \ 32000                    320    249

( 0-bench false-bench )

need reset-frames  need frames@

  \ This bench compares `0` (implemented as a `cconstant`) and
  \ `false` (written in assembler).

: 0-bench  ( n -- )
  reset-frames 0 do  0 drop  loop
  frames@ d. cr ;

: false-bench  ( n -- )
  reset-frames 0 do  false drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                           0       false
  \                       ----- -----------
  \ 32000                   251   236 (94%)

( d*-bench )


  \ `d*` by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 33, 1998-04).

: baden-d*  ( d1 d2 -- d3 )
  >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  r> * swap r> * + +  ; ( d1*d2 ) ( R: )

  \ `d*` by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3).

need pick  need roll

: smith-d*  ( d1 d2 -- d3 )
  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

need bench  need marque

: baden-d*-bench  ( n -- )  0 do  1. 2. baden-d* 2drop  loop  ;
: smith-d*-bench  ( n -- )  0 do  1. 2. smith-d* 2drop  loop  ;

: d*-benchs  ( -- )
  32767 dup bench baden-d*-bench marque
            bench smith-d*-bench marque  ;

  \ 2015-11-09

  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4920 (98 seconds)
  \ smith-d*  5189 (103 seconds) (105%)

( case-benchs )

  \ Comparison of case-like structures.
  \
  \ 2015-11-14: `case` (4 versions), `case:`, `options[` and
  \ `cases:`.

need bench

warnings off

: .used  ( u -- )  unused - cr u. ." B used " ;

32767 constant iterations

defer (case-bench)  ( -- )

: case-bench  ( n cfa -- )
  cr ." ..."
  ['] (case-bench) defer!
  bench
  iterations 0 do  i %11 and (case-bench)  loop
  marque  ;

-->

( case-benchs )

cr .( case)
unused need case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( eForth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

cr .( case from the Forth-94 docs)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( Abersoft Forth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

  \ Note: the `case:` structure is more specific than the other
  \ structures: it lacks a default option and its argument is
  \ positional.

cr .( case:)
unused need case: .used  unused
case:  case:-example  ( n -- )  noop  noop  noop  noop ;
.used .( by its example)  ' case:-example case-bench

cr .( options[)
unused need options[ .used  unused
: options[-example  ( n -- )
  options[
    0 option noop  1 option noop  2 option noop
      default-option noop
  ]options  ;
.used .( by its example)  ' options[-example case-bench

-->

( case-benchs )

cr .( cases:)
unused need cases: .used  unused
cases: cases:-example  ( n -- )
  0 case> noop  1 case> noop  2 case> noop  other> noop
.used .( by its example)  ' cases:-example case-bench

cr .( baden-case)
unused need baden-case .used  unused
: baden-case-example  ( n -- )
  case 0 = of  noop  endof
  case 1 = of  noop  endof
  case 2 = of  noop  endof
           othercase noop  ;
.used .( by its example)  ' baden-case-example case-bench

-->

( case-benchs )

cr .( baden-case-like)
unused .used  unused
: baden-case-like-example  ( n -- )
  dup 0 = if drop  noop  exit then
  dup 1 = if drop  noop  exit then
      2 = if       noop  exit then
  noop  ;
.used .( by its example)  ' baden-case-like-example case-bench

cr .( vannorman-switch)
unused need [switch .used  unused
[switch vannorman-switch-example drop
  0 runs noop  1 runs noop  2 runs noop
switch]
.used .( by its example)  ' vannorman-switch-example case-bench


  \                        Bytes used            Speed (3)
  \                        --------------------- --------------
  \ Structure              Code (1)  Example (2) Frames Seconds
  \ ---------              --------- ----------- ------ -------
  \ case (7)               48       62          1365   27
  \ eforth-case (8)        54       62          1366   27
  \ 94-doc-case (6)        54       62          1365   27
  \ abersoft-case (5)      64       62          1365   27
  \ case: (4)              21       12           823   16
  \ options[ (9)          166       24          3627   72
  \ cases: (10)           109       18          3155   63
  \ baden-case (11)        18       56          1472   29
  \ baden-case (12)        36       56          1472   29
  \ baden-case (13)         0       50          1353   27
  \ vannorman-switch (14) 124       24          3573   71

  \ (1) Bytes used by the compilation of the structure's code.
  \
  \ (2) Bytes used by the tested example: a structure with
  \ three options plus default, that execute a `noop`.
  \
  \ (3) For 32767 iterations with parameter 0..3. One system
  \ frame is 20 ms.

  \ (4) A port of F83's `case:`. It is more specific than the
  \ other structures: it lacks a default option and its
  \ argument is positional.
  \
  \ (5) Eaker/Forth-94 `case` of Abersoft Forth, but with
  \ compiler security removed.
  \
  \ (6) Eaker/Forth-94 `case` copied from the Forth-94
  \ documentation.
  \
  \ (7) Eaker/Forth-94 `case` of eForth, with a little
  \ simplification. This is the default `case` used in Solo
  \ Forth.
  \
  \ (8) Eaker/Forth-94 `case` of eForth.
  \
  \ (9) A port of IsForth's `case:`.
  \
  \ (10) A port of a structure written by Dan Lerner, published
  \ on Forth Dimensions (volume 3, number 6, page 189,
  \ 1982-03).
  \
  \ (11) "Ultimate CASE Statement", written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).
  \
  \ (12) The same "Ultimate CASE Statement", by Wil Baden, with
  \ two syntactic sugar words added: `endof` and `othercase`.
  \
  \ (13) The same "Ultimate CASE Statement", by Wil Baden,
  \ emulated with standard words. This is a bit faster because,
  \ without the syntactic sugar definitions, one `dup` and two
  \ `drop` are saved.
  \
  \ (14) Code by Rick VanNorman, published on Forth Dimensions
  \ (volume 20, number 3, pages 19..22, 1998-09).

( misc-benchs )

  \ Some misc speed benchs.

need bench  need 0if

: bench1  ( n -- )
  begin  ?dup if  1 - else exit then  again  ;

: bench1a  ( n -- )
  begin  ?dup if  1- else exit then  again  ;

: bench2  ( n -- )
  begin  dup 0= if  drop exit then 1-  again  ;

: bench2a  ( n -- )
  begin  dup 0if  drop exit then 1-  again  ;

: bench3  ( n -- )
  begin  ?dup 0if  exit then 1-  again  ;


: misc-benchs  ( -- )
  32767 dup bench bench1 marque
        dup bench bench2 marque
            bench bench3 marque  ;

  \ Bench    Frames for 32767 iterations
  \ -----   ---------------------------
  \ bench1   655 (`1 -`)
  \ bench1a  576 (`1-`)
  \ bench2   320 (`0= if`: 100%)
  \ bench2a  245 (`0if`:    76%)
  \ bench3   528

( 2swap-bench )

  \ 2015-11-24

need bench

: 2swap-bench  ( -- )
  32767 0 bench 2dup do  2swap  loop  marque 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From DZX-Forth                271 (5 s) (1.00)
  \ Adapted from Z88 CamelForth   243 (4 s) (0.89)

( dnegate-bench )

  \ 2015-11-24

need bench

: dnegate-bench  ( -- )
  32767 0 bench 2dup do  dnegate  loop  marque 2drop  ;

: dnegate-bench2  ( -- )
  32767 0 bench 2dup do  dnegate2  loop  marque 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From Abersoft Forth           243 (4 s) (1.00)
  \ From Spectrum Forth-83        253 (5 s) (1.04)

  \ }}} =======================================================
  \ Development tests {{{

( alias-test synonym-test )

  \ 2015-11-24

need alias need synonym

' literal alias literal-a
' border alias border-a
' if alias if-a

synonym border-s border
synonym literal-s literal
synonym if-s if

  \ XXX TMP -- alternative `synonym` that uses `alias`
synonym2 border-s2 border
synonym2 literal-s2 literal
synonym2 if-s2 if

  \ : ifa if-a ." yes" then ;   \ "then" error #-4
  \ : ifs if-s ." yes" then ;   \ ok
  \ : ifs2 if-s2 ." yes" then ;   \ "then" error #-4
  \
  \ 1 literal     \ error -14 \ ok
  \ 1 literal-a   \ no error
  \ 1 literal-s   \ error -14 \ ok
  \ 1 literal-s2  \ no error
  \
  \ : zx [ 1 ] literal ;      \ ok
  \ : zx [ 1 ] literal-a ;    \ error #-264
  \ : zx [ 1 ] literal-s ;    \ no error \ ok
  \ : zx [ 1 ] literal-s2 ;   \ error #-264

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test >body 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test >body dup here swap - dump

( {if-test {do-test )

  \ 2015-11-11

: test2  ( n -- )
  {do   dup 5 <   do> ." <5" cr 1+
  |do|  dup 10 <  do> ." <10" cr 1+
  do} drop  ;

: test1  ( n1 n2 -- )
  {if   2dup > if> ." >" cr
  |if|  2dup < if> ." <" cr
  if}  ;

( options[-test )

: o1 ." option 1" ;  : o2 ." option 2" ;  : o3 ." option 3" ;

: test  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
  ]options  ." end of test" cr   ;

: retest  ( -- )  [char] a test ." end of retest" cr  ;

: o0 ." default" ;

: testd  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
    default-option o0
  ]options  ;

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( exception-test )

  \ Credits:
  \ Code from MPE Forth for TiniARM User Manual.

: could-fail  ( -- c )
  key dup [char] q =
  if  -1 throw  then  ;

: do-it  ( a b -- c )
  2drop could-fail  ;

: try-it  ( -- )
  1 2 ['] do-it catch
  if    ( x1 x2 )  2drop ." There was an exception" cr
  else  ." The character was " emit cr then  ;

: retry-it  ( -- )
  begin   1 2 ['] do-it catch
  while   ( x1 x2 ) 2drop ." Exception, keep trying" cr
  repeat  ( c )
  ." The character was " emit cr  ;

( err>ord )

  \ XXX TMP -- `err>ord` tests `error>ordinal`

: err>ord  ( -- )
  91 1 do  i . i error>ordinal ."  -> " . cr  loop
  286 256 do  i . i error>ordinal ."  -> " . cr  loop
  1025 1000 do  i . i error>ordinal ."  -> " . cr  loop ;

.( block x line 0 ) cr
  .( block x line 1 ) cr
  .( block x line 2 ) cr
  .( block x line 3 ) cr
  .( block x line 4 ) cr
  .( block x line 5 ) cr
  .( block x line 6 ) cr
  .( block x line 7 ) cr
  .( block x line 8 ) cr
  .( block x line 9 ) cr
  .( block x line 10 ) cr
  .( block x line 11 ) cr
  .( block x line 12 ) cr
  .( block x line 13 ) cr
  .( block x line 14 ) cr
  .( block x line 15 ) cr
.( block x+1 line 0 ) cr
  .( block x+1 line 1 ) cr
  .( block x+1 line 2 ) cr
  .( block x+1 line 3 ) cr
  .( block x+1 line 4 ) cr
  .( block x+1 line 5 ) cr
  .( block x+1 line 6 ) cr
  .( block x+1 line 7 ) cr
  .( block x+1 line 8 ) cr
  .( block x+1 line 9 ) cr
  .( block x+1 line 10 ) cr
  .( block x+1 line 11 ) cr
  .( block x+1 line 12 ) cr
  .( block x+1 line 13 ) cr
  .( block x+1 line 14 ) cr
  .( block x+1 line 15 ) cr

  \ }}} =======================================================
  \ Error codes {{{

( Standard error codes #-01..#-15 )  \ scr 5

\ #-01 ABORT
\ #-02 ABORT"
\ #-03 stack overflow
\ #-04 stack underflow
\ #-05 return stack overflow
\ #-06 return stack underflow
\ #-07 do-loops nested too deeply during execution
\ #-08 dictionary overflow
\ #-09 invalid memory address
\ #-10 division by zero
\ #-11 result out of range
\ #-12 argument type mismatch
\ #-13 undefined word
\ #-14 interpreting a compile-only word
\ #-15 invalid FORGET

( Standard error codes #-16..#-30 )

\ #-16 attempt to use zero-length string as a name
\ #-17 pictured numeric output string overflow
\ #-18 parsed string overflow
\ #-19 definition name too long
\ #-20 write to a read-only location
\ #-21 unsupported operation
\ #-22 control structure mismatch
\ #-23 address alignment exception
\ #-24 invalid numeric argument
\ #-25 return stack imbalance
\ #-26 loop parameters unavailable
\ #-27 invalid recursion
\ #-28 user interrupt
\ #-29 compiler nesting
\ #-30 obsolescent feature

( Standard error codes #-31..#-45 )

\ #-31 >BODY used on non-CREATEd definition
\ #-32 invalid name argument
\ #-33 block read exception
\ #-34 block write exception
\ #-35 invalid block number
\ #-36 invalid file position
\ #-37 file I/O exception
\ #-38 non-existent file
\ #-39 unexpected end of file
\ #-40 invalid BASE for floating point conversion
\ #-41 loss of precision
\ #-42 floating-point divide by zero
\ #-43 floating-point result out of range
\ #-44 floating-point stack overflow
\ #-45 floating-point stack underflow

( Standard error codes #-46..#-60 )

\ #-46 floating-point invalid argument
\ #-47 compilation word list deleted
\ #-48 invalid POSTPONE
\ #-49 search-order overflow
\ #-50 search-order underflow
\ #-51 compilation word list changed
\ #-52 control-flow stack overflow
\ #-53 exception stack overflow
\ #-54 floating-point underflow
\ #-55 floating-point unidentified fault
\ #-56 QUIT
\ #-57 exception in sending or receiving a character
\ #-58 [IF], [ELSE], or [THEN] exception
\ #-59 ALLOCATE
\ #-60 FREE

( Standard error codes #-61..#-75 )

\ #-61 RESIZE
\ #-62 CLOSE-FILE
\ #-63 CREATE-FILE
\ #-64 DELETE-FILE
\ #-65 FILE-POSITION
\ #-66 FILE-SIZE
\ #-67 FILE-STATUS
\ #-68 FLUSH-FILE
\ #-69 OPEN-FILE
\ #-70 READ-FILE
\ #-71 READ-LINE
\ #-72 RENAME-FILE
\ #-73 REPOSITION-FILE
\ #-74 RESIZE-FILE
\ #-75 WRITE-FILE

( Standard error codes #-76..#-79 )

\ #-76 WRITE-LINE
\ #-77 malformed xchar
\ #-78 SUBSTITUTE
\ #-79 REPLACES
\ #-80
\ #-81
\ #-82
\ #-83
\ #-84
\ #-85
\ #-86
\ #-87
\ #-88
\ #-89
\ #-90

( System error codes #-256..#-270 )

\ #-256 not a word nor a number
\ #-257 warning: is not unique
\ #-258 stack imbalance
\ #-259 trying to load from block 0
\ #-260 wrong digit
\ #-261 deferred word is uninitialized
\ #-262 assertion failed
\ #-263 execution only
\ #-264 definition not finished
\ #-265 loading only
\ #-266 off current editing block
\ #-267 warning: not present, though required
\ #-268 required, but not located
\ #-269 relative jump too long
\ #-270 text not found

( System error codes #-271..#-285 )

\ #-271 immediate word not allowed in this structure
\ #-272 array index out of range
\ #-273
\ #-274
\ #-275
\ #-276
\ #-277
\ #-278
\ #-279
\ #-280
\ #-281
\ #-282
\ #-283
\ #-284
\ #-285


  \ vim: filetype=soloforth
