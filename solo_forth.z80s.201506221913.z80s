; Solo Forth

; A disk-based Forth for ZX Spectrum,
; intended for cross-development of ZX Spectrum programs.
; http://programandala.net/en.program.solo_forth.html

; Copyright (C) 2015 Marcos Cruz (programandala.net)

; ==============================================================
; Version A-00-201506221842

; Latest important changes (in chronological order)
; - change: new format for the name field, without end bit.
; - change: new, modern `find`, after Forth-83 and Forth-94
; - both recent changes seem to work fine.
; - basic string support.
; - `<mark`, `<resolve`, `>mark` and `>resolve`.
; - `compare`, `search`.
; - `count` in Z80.
; - New versions of `0>`, `<` and `>`.

; ==============================================================
; Aknowledgments

; Solo Forth started with the code of Abersoft Forth, that was
; first studied and much improved
; (http://programandala.net/en.program.afera.html) and finally
; fully disassembled
; (http://programandala.net/en.program.abersoft_forth.html).

; Solo Forth was made possible thanks to code, documentation,
; ideas and inspiration from the following Forth systems
; (acknowledgment notes are included in the source, at the
; correspondent places):

; Afera library for Abersoft Forth, by Marcos Cruz, 2015.
;
; Abersoft Forth (for ZX Spectrum 48K), by John Jones Steele
; 1983.
;
; CP/M fig-Forth 1.1g, adaptative version by EHR et al.,
; 1980-1984.
;
; DZX-Forth (for ZX Spectrum +3e), by Marcos Cruz, 2014 (under
; development).
;
; eForth (for MS-DOS), by Bill Muench, 1989-997.
;
; lina ciforth (for Linux x86), by Albert van der Horst,
; 2000-2004.
;
; Spectrum Forth-83 (for ZX Spectrum 48K/128K), by Lennart
; Benschop, 1988.
;
; v.Forth (for ZX Spectrum 48K/128K), by Matteo Vitturi,
; 1990-2015.

; ==============================================================
; License

; Copying and distribution of this file, with or without
; modification, are permitted in any medium without royalty
; provided the copyright notice, the aknowledgments list and
; this notice are preserved.  This file is offered as-is,
; without any warranty.

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

origin:                           equ 0x5E00

false:                            equ 0
true:                             equ 1

cell:                             equ 2

cells_per_data_stack:             equ 0x50
cells_per_return_stack:           equ 0x50

bytes_per_terminal_input_buffer:  equ 0x50

buffers:                          equ 0x02
data_bytes_per_buffer:            equ 0x0200
total_bytes_per_buffer:           equ data_bytes_per_buffer+4
blocks_per_screen:                equ 0x02
screens_per_disk:                 equ 0x030C ; 780 KiB per disk in G+DOS
characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10

name_bound_bit:       equ 7
name_bound_bit_mask:  equ 1 shl name_bound_bit
precedence_bit:       equ 6
precedence_bit_mask:  equ 1 shl precedence_bit
smudge_bit:           equ 5
smudge_bit_mask:      equ 1 shl smudge_bit

max_word_length:                equ 0x1F
max_word_length_bit_mask:       equ max_word_length

; Error messages are in the disk, starting from the screen
; number hold in the `msg-scr` constant.  Error codes 0, 16, 32
; etc are not used, because they coincide with the first line of
; screens.

; XXX TODO change the order

not_understood_error:               equ 01
stack_empty_error:                  equ 02
dictionary_full_error:              equ 03 ; not used
not_unique_error:                   equ 04
not_found_error:                    equ 05
out_of_disk_range_error:            equ 06
full_stack_error:                   equ 07
number_08_error:                    equ 08 ; free
loading_from_screen_0_error:        equ 09
number_10_error:                    equ 10 ; free
number_11_error:                    equ 11 ; free
number_12_error:                    equ 12 ; free
number_13_error:                    equ 13 ; free
number_14_error:                    equ 14 ; free
number_15_error:                    equ 15 ; free
compilation_only_error:             equ 17
execution_only_error:               equ 18
conditionals_not_paired_error:      equ 19
definition_not_finished_error:      equ 20
protected_dictionary_error:         equ 21
loading_only_error:                 equ 22
off_current_editing_screen_error:   equ 23
declare_vocabulary_error:           equ 24
unsupported_tape_operation_error:   equ 25
unsupported_disk_operation_error:   equ 26
source_file_needed_error:           equ 27
not_present_though_required_error:  equ 28
required_but_not_located_error:     equ 29
number_30_error:                    equ 30 ; free
number_31_error:                    equ 31 ; free

; ----------------------------------------------
; Config

  ; XXX experimental
size_optimization?              equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

fig_name_field?                 equ false
  ; true = the fig-Forth name field is used.
  ; false = the last letter of the name does not have the sign bit set.

fig_find?                       equ false
  ; true = the fig-Forth `find` is used.
  ; false = `find` works after Forth-83 and Forth-94.

fig_parsing?                    equ false
  ; true = the fig-Forth parsing words are used.
  ; false = parsing is modified after Forth-83 and Forth-94.

; ----------------------------------------------
; Character codes

caps_char:                  equ 0x06 ; toggle caps lock
edit_char:                  equ 0x07 ; edit
backspace_char:             equ 0x08
delete_char:                equ 0x0c ; delete (backspace)
form_feed_char:             equ 0x0c ; used for printing
carriage_return_char:       equ 0x0d
extended_mode_char:         equ 0x0e ; Fuse associates it to the host's Tab key
graphics_char:              equ 0x0f ; toggle graphics mode
ink_char:                   equ 0x10
paper_char:                 equ 0x11
flash_char:                 equ 0x12
bright_char:                equ 0x13
inverse_char:               equ 0x14
over_char:                  equ 0x15
at_char:                    equ 0x16
tab_char:                   equ 0x17 ; tab (screen only)
space_char:                 equ 0x20

; ----------------------------------------------
; ROM  routines

rom_beeper:                      equ 0x03B5
rom_border_0x2297:               equ 0x2297
rom_break_key:                   equ 0x1F54
rom_chan_open:                   equ 0x1601
rom_cl_all:                      equ 0x0DAF
rom_find_int1:                   equ 0x1E94
rom_key_decode:                  equ 0x0333
rom_key_scan:                    equ 0x028E
rom_key_test:                    equ 0x031E
rom_plot_0x22DF:                 equ 0x22DF
rom_point_sub_0x22CE:            equ 0x22CE
rom_s_attr_s_0x2583:             equ 0x2583
rom_s_scrn_s_0x2538:             equ 0x2538
rom_sa_all:                      equ 0x075A
rom_set_permanent_colors_0x1CAD  equ 0x1CAD
rom_stack_fetch:                 equ 0x2BF1

; ----------------------------------------------
; System variables

  ; XXX FIXME Pasmo's bug?: `sys_errnr` is used as the base offset.  When it's
  ; not the defined first, the compilation halts with error "offset out of
  ; range", though they are fine in the symbols file.

sys_errnr:         equ 0x5C3A ; IY index

sys_attr_p:        equ 0x5C8D
sys_coordx:        equ 0x5C7D
sys_coordy:        equ 0x5C7E
sys_df_cc:         equ 0x5C84
sys_df_sz:         equ 0x5C6B
sys_df_sz_offset:  equ sys_df_sz-sys_errnr
sys_flags2:        equ 0x5C6A
sys_last_k:        equ 0x5C08
sys_mode:          equ 0x5C41
sys_s_posn:        equ 0x5C88
sys_scr_ct:        equ 0x5C8C
sys_scr_ct_offset: equ sys_scr_ct-sys_errnr
sys_t_addr:        equ 0x5C74
sys_udg:           equ 0x5C7B

; ==============================================================
; Macros

; ----------------------------------------------
; Header

immediate equ 1 ; used as optional parameter
previous_nfa defl 0 ; link to previous Forth word

_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  this_nfa: defl $ ; link address for next word
  flags: defl name_bound_bit_mask
    if not nul _is_immediate
      flags: defl flags | precedence_bit_mask ; add precedence bit
    endif
  _base_label##nfa: ; name field address
    db _base_label##lfa-_base_label##nfa-1+flags ; length and flags byte
    if fig_name_field?
      db _name_but_last_letter,_last_letter+name_bound_bit_mask ; name field
    else
      db _name_but_last_letter,_last_letter ; name field
    endif
  _base_label##lfa: ; link field address
    dw previous_nfa ; link field
  _base_label: ; code field address

  previous_nfa: defl this_nfa

endm

_code_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw _base_label##pfa ; code field
  _base_label##pfa: ; parameter field address

  endm

_code_alias_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate,alias

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw alias##pfa ; code field

  endm

_colon_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_does ; code field
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_variable ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name_but_last_letter,_last_letter,_is_immediate

  _header _base_label,_name_but_last_letter,_last_letter,_is_immediate
  dw do_two_variable ; code field
  _base_label##pfa: ; parameter field address

  endm

; ----------------------------------------------
; Strings

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

; ----------------------------------------------
; Jumps

_jp_next: macro

  jp (ix)

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization?
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization?
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization?
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Error messages

_error_code: macro _error
  if _error=1
    dw one_
  else
    if _error=2
      dw two_
    else
      if _error=3
        dw three_
      else
        dw c_lit_
        db _error
      endif
    endif
  endif
  endm

_question_error: macro _error
  _error_code _error
  dw question_error_
  endm

_message: macro _error
  _error_code _error
  dw message_
  endm

; ----------------------------------------------
; Debug

_border: macro _color
  local _pause0
  push af
  push bc
  ld a,_color
  out(0xFE),a
  ld bc,0
  _pause0:
  dec bc
  ld a,b
  or c
  jr nz,_pause0
  pop bc
  pop af
  endm

_border_wait: macro _color
  local _wait
  push af
  ld a,_color
  out(0xFE),a
  xor a
  ld (sys_last_k),a
  _wait:
  ld a,(sys_last_k)
  and a
  jr z,_wait
  pop af
  endm

_XXX: macro _txt
  dw paren_dot_quote_
  _string _txt
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location: `0x00 +origin`
  jp cold_start
warm_entry:
  ; Location: `0x03 +origin`
  jp warm_start

; ==============================================================
; Parameter area

top_most_word_in_forth_voc:
  ; Location: `0x06 +origin`
  dw nfa_of_top_most_word_in_forth_voc

user_variables_pointer:
  ; Location: `0x08 +origin`
  dw user_variables

return_stack_pointer:
  ; Location: `0x0A +origin`
  dw return_stack_bottom

  ; User variables default values

  ; The first eight user variables have default values.  They are used
  ; by `cold` to overwrite the correspondent user variables.  They must
  ; be in the same order than user variables.

default_user_variables_start:

s0_init_value:
  ; Location: `0x0C +origin`
  dw data_stack_bottom
r0_init_value:
  ; Location: `0x0E +origin`
  dw return_stack_bottom
tib_init_value:
  ; Location: `0x10 +origin`
  dw terminal_input_buffer
width_init_value:
  ; Location: `0x12 +origin`
  dw max_word_length
warning_init_value:
  ; Location: `0x14 +origin`
  dw 0x0000
fence_init_value:
  ; Location: `0x16 +origin`
  dw dictionary_pointer_after_cold
dp_init_value:
  ; Location: `0x18 +origin`
  dw dictionary_pointer_after_cold
voc_link_init_value:
  ; Location: `0x1A +origin`
  dw forth_vocabulary_link

default_user_variables_end:

ip_backup: ; temporary copy of Forth IP
  dw 0

; ==============================================================
; User variables

user_variables:

s0_value: ; +0x00
  dw 0x0000
r0_value: ; +0x02
  dw 0x0000
tib_value: ; +0x04
  dw 0x0000
width_value: ; +0x06
  dw 0x0000
warning_value: ; +0x08
  dw 0x0000
fence_value: ; +0x0A
  dw 0x0000
dp_value: ; +0x0C
  dw 0x0000
voc_link_value: ; +0x0E
  dw 0x0000
blk_value: ; +0x10
  dw 0x0000
in_value: ; +0x12
  dw 0x0000
out_value: ; +0x14
  dw 0x0000
scr_value: ; +0x16
  dw 0x0000
  ; +0x18 ; not used (formerly `offset`)
  dw 0x0000
context_value: ; +0x1A ; XXX TODO use more space, for `order`
  dw 0x0000
current_value: ; +0x1C
  dw 0x0000
state_value: ; +0x1E
  dw 0x0000
base_value: ; +0x20
  dw 0x0000
dpl_value: ; +0x22
  dw 0x0000
fld_value: ; +0x24
  dw 0x0000
csp_value: ; +0x26
  dw 0x0000
r_hash_value: ; +0x28 ; XXX OLD -- used by the editor, remove
  dw 0x0000
hld_value: ; +0x2A
  dw 0x0000

  ; Unused
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000
  dw 0x0000

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffers

first_buffer:
  ds blocks_per_screen*total_bytes_per_buffer
limit:

; ==============================================================
; Misc routines

compare_de_hl_unsigned:

  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de

  ; Taken from DZX-Forth.

  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:

  ; Input:  de, hl
  ; Output: flag C if hl < de

  ; Taken from DZX-Forth.

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ==============================================================
; :Inner interpreter

push_de_hl:
  push de

push_hl:
  push hl

next:
  ; Execute the word pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ;ld (60000),bc ; XXX INFORMER
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa

next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa)
  ; de = cfa+1 = pfa-1

  ; XXX INFORMER
  ; ld a,h
  ; cp l
  ; jr nz,next3
  ; _border_wait 2
;  jp cold_start
;next3:

  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
  _colon_header s_lit_,'SLI','T'

  ; : slit  ( -- ca len )  r@ count dup 1+ r> + >r  ;

  dw r_fetch_,count_,dup_,one_plus_
  dw from_r_,plus_,to_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_s_,'(S',')'

if 0 ; XXX OLD

  ; XXX FIXME empty strings get one length, because of `word`.

  ; : (s) ( compilation: c "ccc<c>" -- ) ( run-time:  -- ca len )
  ;  state @ if    compile slit word here c@ 1+ allot
  ;          else  text  then  ;

  dw comp_question_
  dw zero_branch_,paren_s.interpreting
  ; compiling
  dw compile_,s_lit_,word_
  dw here_,c_fetch_,one_plus_,allot_
  dw semicolon_s_
paren_s.interpreting:
  dw text_
  dw semicolon_s_

else

  ; : (s) ( compilation: c "ccc<c>" -- ) ( run-time:  -- ca len )
  ;  parse comp? if    sliteral
  ;              else  tuck pad swap cmove pad swap then  ;

  dw parse_ ; ( ca len )
  dw comp_question_
  dw zero_branch_,paren_s.interpreting
  ; compiling
  dw s_literal_
  dw semicolon_s_
paren_s.interpreting:
  dw tuck_,pad_,swap_,cmove_,pad_,swap_
  dw semicolon_s_

endif

; ----------------------------------------------
  _code_header c_lit_,'CLI','T'

  ld a,(bc)
  inc bc
push_a:
  ld l,a
push_l: ; XXX TMP -- not used yet
  ld h,0
  jp push_hl

; ----------------------------------------------
  _code_header lit_,'LI','T'

  ; XXX FIXME -- crash if not compiling

  ld a,(bc)
  inc bc
  ld l,a
  ld a,(bc)
  inc bc
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header execute_,'EXECUT','E'

  pop hl
  jp next2

; ----------------------------------------------
  _colon_header forward_mark_,'>MAR','K'

  dw here_,zero_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLV','E'

  dw here_,swap_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_mark_,'<MAR','K'

  dw here_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_resolve_,'<RESOLV','E'

  dw comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header branch_,'BRANC','H'

  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  _jp_next

; ----------------------------------------------
  _code_header zero_branch_,'0BRANC','H'

  pop hl
  ld a,l
  or h
  jp z,branch_pfa
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANC','H'

  pop hl
  ld a,l
  or h
  jp nz,branch_pfa
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP',')'

  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_stack_pointer)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl
  inc d
  dec d
  ld d,a
  jp m,l5eedh
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp l5ef2h
l5eedh:
  ld a,(hl)
  sub e
  inc hl
  ld a,(hl)
  sbc a,d
l5ef2h:
  jp m,branch_pfa
  inc hl
  ld (return_stack_pointer),hl
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP',')'

  pop de
  jp paren_loop.step_in_de

; ----------------------------------------------
  _code_header paren_do_,'(DO',')'

if true ; XXX OLD

  ld hl,(return_stack_pointer)
  dec hl
  dec hl
  dec hl
  dec hl
  ld (return_stack_pointer),hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  pop de
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d

else ; XXX NEW -- from CP/M fig-Forth 1.1g

  EXX     ;/ SAVE IP
  POP DE    ;  (DE)<--INITIAL INDEX
  POP BC    ;/ (BC)<--LIMIT
  LD  HL,(RPP)  ;  (HL)<--(RP)
  DEC HL
  LD  (HL),B
  DEC HL
  LD  (HL),C    ;/ (R2)<--LIMIT
  DEC HL
  LD  (HL),D
  DEC HL
  LD  (HL),E    ;  (R1)<--INITIAL INDEX
  LD  (RPP),HL  ;  (RP)<--(RP)-4
  EXX     ;/ RESTORE IP

endif

  _jp_next

; ----------------------------------------------
  _code_alias_header i_,'','I',,r_fetch_

; ----------------------------------------------
  _code_header digit_,'DIGI','T'

  pop hl
  pop de
  ld a,e
  sub 0x30
  jp m,l5f65h
  cp 0x0A
  jp m,l5f5ah
  sub 0x07
  cp 0x0A
  jp m,l5f65h
l5f5ah:
  cp l
  jp p,l5f65h
  ld e,a
  ld hl,0x0001
  jp push_de_hl
l5f65h:
  ld l,h
  jp push_hl

; ----------------------------------------------
  _code_header paren_find_,'(FIND',')'

if fig_name_field?

; doc{
;
; (find)  ( ca nfa --- pfa b tf | ff )  \ fig-Forth
;
; Search the dictionary starting at the name field address
; _nfa_, matching to the text at _ca_. If a match is found,
; return parameter field address _pfa_, length byte of name
; field _b_ and a boolean true.  Otherwise return only a boolean
; false.
;
; }doc

  ; XXX Note: this is the original fig-Forth version.

  pop de ; nfa
paren_find.begin:
  ; (sp) = string address
  ; de = nfa
  pop hl ; string address
  push hl ; save for next iteration
  ld a,(de) ; length byte
  xor (hl) ; filter deviations
  and 0x3F ; mask msb and precedence bit
  jr nz,paren_find.skip_name_field ; lengths differ
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  xor (hl) ; filter deviations
  add a,a
  jr nz,paren_find.not_a_match ; no match
  jr nc,paren_find.compare_next_char ; match so far, loop again
  ; The string matches.
  ; de = address of the last char of the name field
  ld hl,0x0005 ; offset from lfa-1 to pfa
  add hl,de
  ex (sp),hl ; pfa to stack
paren_find.search_for_length_byte:
  dec de ; position de on nfa
  ld a,(de)
  or a ; msb=1?; if so, length byte
  jp p,paren_find.search_for_length_byte ; no, try next char
  ld e,a ; length byte
  ld d,0x00
  ld hl,true
  jp push_de_hl ; name field found, return
paren_find.not_a_match:
  ; Above name field not a match, try next one
  jr c,paren_find.name_field_skipped ; carry = end of name field
paren_find.skip_name_field:
  ; Find end of name field
  inc de
  ld a,(de)
  or a ; msb=1?
  jp p,paren_find.skip_name_field ; no, loop
paren_find.name_field_skipped:
  inc de ; lfa
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e ; end of dictionary?
  jp nz,paren_find.begin ; if not, continue
  ; No match found, return
  pop hl ; drop string address
  jp false_pfa

else

if fig_find?

; doc{
;
; (find)  ( ca nfa --- pfa b tf | ff )
;
; }doc

  ; XXX Note: this version uses the new format name field, but
  ; works the same way the fig-Forth `find`.

  ld (ip_backup),bc ; save Forth IP
  pop de ; nfa
  pop hl ; string address
  ld (paren_find.string_address),hl
paren_find.begin:
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; name field length byte
  ld c,a    ; save for later
  and max_word_length_bit_mask  ; actual length
  cp (hl)
  jr nz,paren_find.not_a_match ; lengths differ
  ; Lengths match.
  ld a,c ; name field length byte
  and max_word_length_bit_mask  ; actual length
  ld b,a
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl)
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; de = address of the last char of the name field
  ; c = name field length byte
  ld hl,5 ; offset from lfa-1 to pfa
  add hl,de
  push hl ; pfa
  ld e,c ; length byte
  ld d,0
  ld hl,true
  ld bc,(ip_backup) ; restore Forth IP
  jp push_de_hl

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  ld a,c ; length byte
  and max_word_length_bit_mask  ; actual length
  ld c,a ; actual length
  inc c ; plus the length byte
  ld b,0
  add hl,bc ; hl = lfa
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e ; end of dictionary?
  jp nz,paren_find.begin ; if not, continue

  ; No match found, return.
  ld bc,(ip_backup) ; restore Forth IP
  jp false_pfa

else

; doc{
;
; (find)  ( ca nfa --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX Note: this version uses the new format name field,
  ; and is used by the new version of `find`, written after
  ; Forth-83.

  ld (ip_backup),bc ; save Forth IP
  pop de ; nfa
  pop hl ; string address
  ld (paren_find.string_address),hl

paren_find.begin:
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; name field length byte
  ld c,a    ; save for later
  and max_word_length_bit_mask  ; actual length
  cp (hl)
  jr nz,paren_find.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  ld a,c ; name field length byte
  and max_word_length_bit_mask  ; actual length
  ld b,a
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl)
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; de = address of the last char of the name field
  ; c = name field length byte
  inc de ; de = lfa
  inc de
  inc de ; de = cfa
  ld hl,1 ; 1=immediate word
  ld a,c ; name field length byte
  ld bc,(ip_backup) ; restore Forth IP
  and precedence_bit_mask ; immediate word?
  jp nz,push_de_hl
  ; non-immediate word
  dec hl
  dec hl ; -1 = non-immediate word
  jp push_de_hl

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  ld a,c ; length byte
  and max_word_length_bit_mask  ; actual length
  ld c,a ; actual length
  inc c ; plus the length byte
  ld b,0
  add hl,bc ; hl = lfa
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld a,d
  or e ; end of dictionary?
  jp nz,paren_find.begin ; if not, continue

  ; No match found, return.
  ld bc,(ip_backup) ; restore Forth IP
  ld de,(paren_find.string_address)
  ld hl,false
  jp push_de_hl

endif

endif

; ----------------------------------------------
  _code_header scan_,'SCA','N'

if false ; XXX From DXZ-Forth, for ANS Forth parsing

; scan  ( ca1 len1 c -- ca2 len2 )

  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
scan.begin:
  ld a,c
  or b
  _jump_z scan.end
  ld a,e
  cp (hl)
  _jump_z scan.end
  inc hl
  dec bc
  jp scan.begin ; again

scan.end:
  ex (sp),hl ; hl = Forth IP ; push ca2
scan.3:
  push bc ; len2
  ld c,l
  ld b,h ; restore Forth IP
  _jp_next

endif

if 0 ; XXX TMP -- version for fig-Forth parsing

; doc{
;
; scan  ( ca1 c -- ca2 )
;
; ca1 = text address
; c = ascii delimiting character
; ca2 = start of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc


  pop de ; e = delimiter
  pop hl ; ca1
  push bc ; save Forth IP
scan.begin:
  ld a,(hl)
  or a ; null?
  _jump_z scan.end
  cp e
  _jump_z scan.end
  inc hl
  jp scan.begin ; again

scan.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

if 1 ; from the new `(parse)`

; doc{
;
; scan  ( c ca -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop de ; address
  pop hl ; delimiter
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
scan.begin:
  ld a,(de)
  or a ; unconditional null delimiter?
  jr z,scan.end
  cp c ; delimiter?
  jr z,scan.end
  inc de
  inc hl
  jp scan.begin ; repeat
scan.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

; ----------------------------------------------
  _code_header skip_,'SKI','P'

if false ; XXX From DXZ-Forth, for ANS Forth parsing

; skip  ( ca1 len1 c -- ca2 len2 )

  pop de
  ld l,c
  ld h,b
  pop bc ; len1
  ex (sp),hl ; hl=ca1 ; save Forth IP
skip.begin:
  ld a,c
  or b ; exhausted?
  jp z,scan.end
  ld a,e
  cp (hl) ; delimiter?
  jp nz,scan.end
  inc hl
  dec bc
  jp skip.begin ; again

endif

if 0 ; XXX TMP -- version for fig-Forth parsing

; skip  ( ca1 c -- ca2 )

  pop de ; e = delimiter
  pop hl ; ca1
  push bc ; save Forth IP
skip.begin:
  ld a,(hl)
  or a ; null delimiter?
  jp z,scan.end
  cp e ; delimiter?
  jp nz,scan.end
  inc hl
  jp skip.begin ; again

endif

; ----------------------------------------------
  _code_header enclose_,'ENCLOS','E'

  ; doc{
  ;
  ; enclose  ( c a -- a n1 n2 n3 )
  ;
  ; The text scanning primitive used by `word`.
  ;
  ; c = delimiting character
  ; a = text address
  ;
  ; addr1 and an ascii delimiting character c, is determined the
  ; n1 = byte offset to the first non-delimiter character n2 =
  ; byte offset to the first delimiter after the text n3 = byte
  ; offset to the first character not included
  ;
  ; This procedure will not process past an ASCII 'null',
  ; treating it as an unconditional delimiter.
  ;
  ; Note: This is not the fig-Forth `enclose`: the order of the
  ; input parameters has been changed, to save a `swap` in
  ; `word`.
  ;
  ; }doc

  ; XXX OLD -- this will be substituted by `(parse)`.

  exx ; save the Forth IP
  pop hl ; hl = address
  pop de ; e  = delimiter
  push hl
  ld a,e  ; a = delimiter
  ld bc,-1 ; init char offset counter
  dec hl

enclose.skip:
  ; Skip initial delimiters.
  ; hl = previous address
  ; a = delimiter
  ; bc = offset
  inc hl
  inc bc
  cp (hl) ; delimiter?
  jp z,enclose.skip ; yes, loop

  ; First non-delimiter found.
  push bc ; save offset
  ld a,(hl)
  and a ; is the first non-delimiter a null?
  jp nz,enclose.scan

  ; The first non-delimiter is a null.
  inc bc
  push bc ; offset to byte following null
  dec bc ; offset to null
  jp enclose.end

enclose.scan:
  ld a,e ; delimiter
  inc hl ; address of next char
  inc bc ; offset to next char
  cp (hl) ; delimiter?
  jp z,enclose.ending_delimiter
  ld a,(hl)
  and a ; null?
  jp nz,enclose.scan

  ; Final null found.
  push bc ; offset to null
  jp enclose.end

enclose.ending_delimiter:
  ; Final delimiter found.
  push bc ; offset to byte following text
  inc bc ; offset to 2 bytes after end of word

enclose.end:
  push bc
  exx ; restore the Forth IP
  _jp_next


; ----------------------------------------------
  _code_header paren_parse_,'(PARSE',')'

if 1 ; XXX NEW

; doc{
;
; (parse)  ( c ca -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop de ; address
  pop hl ; delimiter
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
paren_parse.scan:
  ld a,(de)
  or a ; unconditional null delimiter?
  jr z,paren_parse.end
  cp c ; delimiter?
  jr z,paren_parse.end
  inc de
  inc hl
  jp paren_parse.scan
paren_parse.end:
  pop bc ; restore Forth IP
  jp push_hl

endif

if 0 ; XXX NEW

; doc{
;
; (parse)  ( ca c -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.
;
; }doc

  pop hl
  pop de
  push de
  ld d,l ; delimiter
  ld hl,0 ; length
paren_parse.scan:
  ld a,(de)
  and a ; unconditional null delimiter?
  jp z,push_hl
  cp d ; delimiter?
  jp z,push_hl
  inc hl
  jp paren_parse.scan

endif


if 0 ; XXX OLD -- first try, after fig-Forth `enclose`

  ; XXX TODO -- unfinished

; doc{

; (parse)  ( c a f -- a n1 n2 n3 )

; The parsing primitive used by `word` and `parse`.
; Its code is based on fig-Forth's `enclose`.

; c = ascii delimiting character
; a = text address
; f = skip leading delimiters?
; n1 = offset to the first text character
; n2 = offset to the first delimiter after the text
; n3 = offset to the first character not included

; This word will not process past an ascii 'null',
; treating it as an unconditional delimiter.

; }doc

  ; XXX FIXME empty parsed strings return a length of one;
  ; all other cases seem to work fine

  exx ; save the Forth IP
  pop bc
  ld a,c ; a = skip leading delimiters?
  pop hl ; hl = address
  pop de ; e = delimiter
  push hl
  ld bc,0 ; init char offset

  ; XXX TMP
  and a ; skip initial delimiters?
;  jr z,paren_parse.text
  jr nz,paren_parse.skip_initial_delimiters
  ; Do not skip initial delimiters.
  jr paren_parse.text

paren_parse.skip_initial_delimiters:
  ; Skip initial delimiters.
  dec hl ; init the address for the first inc 
  dec bc ; init the offset for the first inc
  ld a,e  ; a = delimiter
paren_parse.skip_initial_delimiter:
  ; hl = previous address
  ; a = delimiter
  ; bc = offset
  inc hl
  inc bc
  cp (hl) ; delimiter?
  jp z,paren_parse.skip_initial_delimiter ; yes, loop
  ; First non-delimiter found.

paren_parse.text:
  ; Scan the text.
  push bc ; save offset
  ld a,(hl)
  and a ; is the first non-delimiter a null?
  jp nz,paren_parse.scan

  ; The first non-delimiter is a null.
  inc bc
  push bc ; offset to byte following null
  dec bc ; offset to null
  jp paren_parse.end

paren_parse.scan:
  ld a,e ; delimiter
  inc hl ; address of next char
  inc bc ; offset to next char
  cp (hl) ; delimiter?
  jp z,paren_parse.ending_delimiter
  ld a,(hl)
  and a ; null?
  jp nz,paren_parse.scan

  ; Final null found.
  push bc ; offset to null
  jp paren_parse.end

paren_parse.ending_delimiter:
  ; Final delimiter found.
  push bc ; offset to byte following text
  inc bc ; offset to 2 bytes after end of word

paren_parse.end:
  push bc
  exx ; restore the Forth IP
  _jp_next

endif

; ----------------------------------------------
  _code_header chan_,'CHA','N'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
; Copied from Spectrum Forth-83.

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _colon_header emit_,'EMI','T'

  dw paren_emit_
  dw one_,out_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header paren_emit_,'(EMIT',')'

; doc{

; (emit)  ( b -- )

; Send the character b to the current channel.
;
; Copied from `TOCH`, from Lennart Benschop's Spectrum
; Forth-83.

; }doc

  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
  _jp_next

; ----------------------------------------------
  _colon_header printer_,'PRINTE','R'

  dw three_,chan_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header display_,'DISPLA','Y'

  dw two_,chan_
  dw semicolon_s_

; ----------------------------------------------
  _code_header key_,'KE','Y'

  ; XXX TODO simplify, no Spectrum modes

  push bc
  ld a,0x02
  call rom_chan_open

  ; flash on
  ld a,flash_char
  rst 0x10
  ld a,0x01
  rst 0x10

key.new_key:
  xor a
  ld (sys_last_k),a
  ; Print cursor:
key.cursor_char: equ $+1
  ld a,'L'
  rst 0x10
  ld a,backspace_char
  rst 0x10
key.wait_for_key:
  ld a,(sys_last_k)
  and a
  jr z,key.wait_for_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,key.graphic_mode
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a

key.not_graphic_mode_cursor:
  ; a = 0 (lowercase mode)
  ;     8 (uppercase mode)
  ld hl,key.cursor_char
  bit 3,a ; cursor 'L'?
  jr nz,key.cursor_c
  ld (hl),'L'
  jr key.new_key
key.cursor_c:
  ld (hl),'C'
  jr key.new_key

key.graphic_mode:
  cp graphics_char ; change graphics mode?
  jr nz,key.left_bracket
  ; graphics
  ld a,0x02
  ld hl,sys_mode
  xor (hl)
  ld (hl),a
  and a ; now in graphics mode?
  jr nz,key.graphic_mode_cursor
  ; not in graphics mode
  ld a,(sys_flags2)
  jr key.not_graphic_mode_cursor

key.graphic_mode_cursor:
  ld a,'G'
  ld (key.cursor_char),a
  jr key.new_key

  ; Translate some chars
  ; XXX TODO use a configurable list of chars pairs
key.left_bracket:
  cp 0xC6
  jr nz,key.right_bracket
  ld a,'['
key.right_bracket:
  cp 0xC5
  jr nz,key.tilde
  ld a,']'
key.tilde:
  cp 0xE2
  jr nz,key.vertical_bar
  ld a,'~'
key.vertical_bar:
  cp 0xC3
  jr nz,key.backslash
  ld a,'|'
key.backslash:
  cp 0xCD
  jr nz,key.left_curly_bracket
  ld a,'\'
key.left_curly_bracket:
  cp 0xCC
  jr nz,key.right_curly_bracket
  ld a,'{'
key.right_curly_bracket:
  cp 0xCB
  jr nz,key.limit
  ld a,'}'

key.limit:
  cp 0xA5 ; greater than 0xA4 (the last UDG)?
  jr nc,key.new_key
  ld l,a
  ld h,0x00

  ; flash off
  ld a,flash_char
  rst 0x10
  ld a,0x00
  rst 0x10

  ; delete the cursor
  ld a,space_char
  rst 0x10
  ld a,backspace_char
  rst 0x10

  pop bc
  jp push_hl

; ----------------------------------------------
  _code_header question_terminal_,'?TERMINA','L'

  call rom_break_key
  jp nc,true_pfa
  ld a,(sys_last_k)
  cp edit_char
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _colon_header cr_,'C','R'

  dw c_lit_
  db carriage_return_char
  dw emit_
  dw out_,off_
  dw semicolon_s_

; ----------------------------------------------
  _code_header cmove_,'CMOV','E'

  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ld a,b
  or c
  jr z,cmove.end
  ldir
cmove.end:
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header u_star_,'U','*'

  pop de
  pop hl
  push bc
  ld b,h
  ld a,l
  call sub_606dh
  push hl
  ld h,a
  ld a,b
  ld b,h
  call sub_606dh
  pop de
  ld c,d
  add hl,bc
  adc a,0x00
  ld d,l
  ld l,h
  ld h,a
  pop bc
  push de
  jp push_hl
sub_606dh:
  ld hl,0x0000
  ld c,0x08
l6072h:
  add hl,hl
  rla
  jr nc,l6079h
  add hl,de
  adc a,0x00
l6079h:
  dec c
  jr nz,l6072h
  ret

; ----------------------------------------------
  _code_header u_slash_mod_,'U/MO','D'

  ld hl,0x0004
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l60a0h
  ld hl,0xFFFF
  ld de,0xFFFF
  jr l60c0h
l60a0h:
  ld a,0x10
l60a2h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l60aah
  inc de
  and a
l60aah:
  ex de,hl
  rra
  push af
  jr nc,l60b4h
  and l
  sbc hl,bc
  jr l60bbh
l60b4h:
  and a
  sbc hl,bc
  jr nc,l60bbh
  add hl,bc
  dec de
l60bbh:
  inc de
  pop af
  dec a
  jr nz,l60a2h
l60c0h:
  pop bc
  push hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header and_,'AN','D'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header or_,'O','R'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header xor_,'XO','R'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header sp_fetch_,'SP','@'

  ld hl,0x0000
  add hl,sp
  jp push_hl

; ----------------------------------------------
  _code_header sp_store_,'SP','!'

  ld hl,(user_variables_pointer)
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'R','P'

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP','@'

  ld hl,(return_stack_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header rp_store_,'RP','!'

  ld hl,(user_variables_pointer)
  inc hl
  inc hl ; hl=address of r0
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header semicolon_s_,';','S'

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header pick_,'PIC','K'

  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

; ----------------------------------------------
  _code_alias_header unloop_,'UNLOO','P',,two_r_drop_

; ----------------------------------------------
  _code_header leave_,'LEAV','E'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header to_r_,'>','R'

  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R','>'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header two_r_drop_,'2RDRO','P'

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDRO','P'

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_r_fetch_,'2R','@'

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R','@'

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header zero_equals_,'0','='

  pop hl
  ld a,l
  or h
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_not_equals_,'0<','>'

  pop hl
  ld a,l
  or h
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header zero_less_than_,'0','<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization?
    add hl,hl ; 11t, 1 byte
  else
    ; [Idea from Ace Forth.]
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_greater_than_,'0','>'

  ; [Taken from DZX-Forth.]

  pop de
  ld hl,0
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header plus_,'','+'

  pop de
  pop hl
  add hl,de
  jp push_hl

; ----------------------------------------------
  _code_header d_plus_,'D','+'

  ld hl,0x0006
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  adc hl,bc
  pop bc
  push de
  jp push_hl

; ----------------------------------------------
  _code_header negate_,'NEGAT','E'

  pop de
  ld hl,0x0000
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header dnegate_,'DNEGAT','E'

  pop hl
  pop de
  sub a
  sub e
  ld e,a
  ld a,0x00
  sbc a,d
  ld d,a
  ld a,0x00
  sbc a,l
  ld l,a
  ld a,0x00
  sbc a,h
  ld h,a
  push de
  jp push_hl

; ----------------------------------------------
  _code_header nip_,'NI','P'

  pop hl
  pop de
  jp push_hl

; ----------------------------------------------
  _code_header tuck_,'TUC','K'

  pop hl
  pop de
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header over_,'OVE','R'

  pop de
  pop hl
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header drop_,'DRO','P'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWA','P'

  pop hl
  ex (sp),hl
  jp push_hl

; ----------------------------------------------
  _code_header dup_,'DU','P'

  pop hl
  push hl
  jp push_hl

; ----------------------------------------------
  _code_header two_dup_,'2DU','P'

  pop hl
  pop de
  push de
  push hl
  jp push_de_hl

; ----------------------------------------------
  _code_header plus_store_,'+','!'

  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OF','F'

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'O','N'

  ; XXX TODO -- update when true=-1
  pop hl
  ld (hl),1
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header toggle_,'TOGGL','E'

  pop de ; e = bit pattern
  pop hl ; address
  ld a,(hl)
  xor e
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header fetch_,'','@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_,'C','@'

  pop hl
  ld l,(hl)
  ld h,0x00
  jp push_hl

; ----------------------------------------------
  _code_header two_fetch_,'2','@'

  pop hl ; address
two_fetch.hl

  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1
  ex de,hl      ; 04t  1
  jp push_de_hl ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL

; ----------------------------------------------
  _code_header two_store_,'2','!'

  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization?
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'','!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C','!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _colon_header colon_,'',':',immediate

  dw question_exec_
  dw store_csp_
  dw current_,fetch_,context_,store_ ; XXX TODO why fig-Forth does this?
  dw header_,right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
  _jp_next

; ----------------------------------------------
  _colon_header noname_,':NONAM','E',immediate

  ; Copied from the Afera library.

  dw question_exec_
  dw current_,fetch_,context_,store_ ; XXX TODO why fig-Forth does this?
  dw smudge_  ; deactivate the effect of the next `smudge` in `;`
  dw here_ ; cfa
  dw store_csp_
  dw lit_,do_colon,comma_ ; create the code field
  dw right_bracket_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_,'',';',immediate

  dw question_csp_
  dw compile_,semicolon_s_
  dw smudge_
  dw left_bracket_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header noop_,'NOO','P'

  dw semicolon_s_

; ----------------------------------------------
  _colon_header constant_,'CONSTAN','T'

  dw header_,smudge_,comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  ld e,(hl)
  inc hl
  ld d,(hl) ; de=value
  push de
  _jp_next

; ----------------------------------------------
  _colon_header label_,'LABE','L'

  dw header_,smudge_
  dw paren_semicolon_code_
do_label:
  ; XXX TODO check the execution time, compare with `do_two_variable`
  inc de  ; de=pfa
  ex de,hl
  jp push_hl

; ----------------------------------------------
  _colon_header variable_,'VARIABL','E'

  dw constant_
  dw paren_semicolon_code_
do_variable:
  inc de  ; de=pfa
  push de
  _jp_next

; ----------------------------------------------
  _colon_header user_,'USE','R'

  ; XXX TODO -- Use only one byte for storage,
  ; but defining `cconstant` only for this does not seem a good idea.
  dw constant_
  dw paren_semicolon_code_
do_user:
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00
  ld hl,(user_variables_pointer)   ; 20t
  ; XXX This is faster, but makes the access to the pointer non-standard:
;user_variables_pointer: equ $+1
; ld hl,user_variables   ; 10t
  add hl,de   ; hl= address of the user variable
  jp push_hl

; ----------------------------------------------
  _constant_header msg_scr_,'MSG-SC','R'

; doc{
; msg-scr  ( -- n )  \  Constant: Screen where the error messages start.
; }doc

; Idea taken from lina ciforth.

  dw 0x0004

; ----------------------------------------------
  _constant_header zero_,'','0'

  dw 0x0000

; ----------------------------------------------
  _constant_header one_,'','1'

  dw 0x0001

; ----------------------------------------------
  _constant_header two_,'','2'

  dw 0x0002

; ----------------------------------------------
  _constant_header three_,'','3'

  dw 0x0003

; ----------------------------------------------
  _code_header false_,'FALS','E'

  ld hl,false
  jp push_hl

; ----------------------------------------------
  _code_header true_,'TRU','E'

  ld hl,true
  jp push_hl

; ----------------------------------------------
  _constant_header b_l_,'B','L'

  dw space_char

; ----------------------------------------------
  _constant_header c_slash_l_,'C/','L'

  dw characters_per_line

; ----------------------------------------------
  _constant_header first_,'FIRS','T'

  dw first_buffer

; ----------------------------------------------
  _constant_header limit_,'LIMI','T'

  dw limit

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BU','F'

  dw data_bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_scr_,'B/SC','R'

  dw blocks_per_screen

; ----------------------------------------------
  _constant_header scr_slash_disk_,'SCR/DIS','K'

  dw screens_per_disk

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGI','N'

  dw lit_,origin
  dw plus_
  dw semicolon_s_

; ----------------------------------------------
  _user_variable_header s0_,'S','0'

  db 0x00

; ----------------------------------------------
  _user_variable_header r0_,'R','0'

  db 0x02

; ----------------------------------------------
  _user_variable_header tib_,'TI','B'

  db 0x04

; ----------------------------------------------
  _user_variable_header width_,'WIDT','H'

  db 0x06

; ----------------------------------------------
  _user_variable_header warning_,'WARNIN','G'

  db 0x08

; ----------------------------------------------
  _user_variable_header fence_,'FENC','E'

  db 0x0A

; ----------------------------------------------
  _user_variable_header dp_,'D','P'

  db 0x0C

; ----------------------------------------------
  _user_variable_header voc_link_,'VOC-LIN','K'

  db 0x0E

; ----------------------------------------------
  _user_variable_header blk_,'BL','K'

  db 0x10

; ----------------------------------------------
  _user_variable_header to_in_,'>I','N'

  db 0x12

; ----------------------------------------------
  _user_variable_header out_,'OU','T'

  db 0x14

; ----------------------------------------------
  _user_variable_header scr_,'SC','R' ; XXX OLD ? used by `list`

  db 0x16

; ----------------------------------------------
  _user_variable_header context_,'CONTEX','T'

  db 0x1A

; ----------------------------------------------
  _user_variable_header current_,'CURREN','T'

  db 0x1C

; ----------------------------------------------
  _user_variable_header state_,'STAT','E'

  db 0x1E

; ----------------------------------------------
  _user_variable_header base_,'BAS','E'

  db 0x20

; ----------------------------------------------
  _user_variable_header dpl_,'DP','L'

  db 0x22

; ----------------------------------------------
  _user_variable_header fld_,'FL','D'

  db 0x24

; ----------------------------------------------
  _user_variable_header csp_,'CS','P'

  db 0x26

; ----------------------------------------------
  _user_variable_header r_hash_,'R','#'

  db 0x28

; ----------------------------------------------
  _user_variable_header hld_,'HL','D'

  db 0x2A

; ----------------------------------------------
  _colon_header recurse_,'RECURS','E',immediate

  dw latest_,nfa_to_cfa_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header one_plus_,'1','+'

  pop hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_header two_plus_,'2','+'

  pop hl
  inc hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cell_plus_,'CELL','+',,two_plus_

; ----------------------------------------------
  _code_header one_minus_,'1','-'

  pop hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_minus_,'2','-'

  pop hl
  dec hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_star_,'2','*'

  pop hl
  add hl,hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cells_,'CELL','S',,two_star_

; ----------------------------------------------
  _constant_header cell_,'CEL','L'

  dw 0x0002

; ----------------------------------------------
  _code_header two_slash_,'2','/'

  ; From DZX-Forth.

  pop hl
  call sra_hl
  jp push_hl

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl.1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

; ----------------------------------------------
  _colon_header here_,'HER','E'

  dw dp_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header allot_,'ALLO','T'

  dw dp_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_comma_,'s',','

; doc{
; s,  ( ca len -- )
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,cmove_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comma_,'',','

  dw here_,store_,two_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_comma_,'C',','

  dw here_,c_store_,one_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _code_header minus_,'','-'

  pop de
  pop hl
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header not_equals_,'<','>'

  pop de
  pop hl
  call compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header equals_,'','='

  pop de
  pop hl
  call compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header less_than_,'','<'

if 1 ; XXX NEW -- from DZX-Forth

  pop de
  pop hl
is_de_less_than_hl:
  call compare_de_hl_signed
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

else ; XXX OLD

  pop de ; n2
  pop hl ; n1
  ld a,d
  xor h ; one of them negative?
  jp m,less_than.wich_negative ; if so, determine which
  ; no one is negative
  and a ; clear carry
  sbc hl,de

less_than.wich_negative:

  if 0 ; XXX OLD

  ; Original version from Abersoft Forth, badly optimized
  ; because of the two 'ld hl' and two `jp push_hl`.

  inc h
  dec h ; h negative?
  jp m,less_than.true
  ld hl,false
  jp push_hl
less_than.true:
  ld hl,true
  jp push_hl

  else ; XXX NEW

  ; Version from CP/M fig-Forth 1.1g,
  ; with additional improvement for speed:

  ; bit 7,h ; h negative?
  ; ld hl,false
  ; jp z,push_hl
  ; inc l ; true ; XXX TODO -- change to `dec hl` when true=-1
  ; jp push_hl

  ; Optimized for space:

  bit 7,h ; h negative?
  jp z,false_pfa
  jp true_pfa

  endif

endif

; ----------------------------------------------
  _code_header u_greater_than_,'U','>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U','<'

  pop de
  pop hl
u_less_than.de_hl:
  call compare_de_hl_unsigned
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

; ----------------------------------------------
  _code_header greater_than_,'','>'

  pop hl
  pop de
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header rot_,'RO','T'

  pop de
  pop hl
  ex (sp),hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header space_,'SPAC','E'

  dw b_l_
  dw emit_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_dup_,'?DU','P'

  dw dup_
  dw zero_branch_,question_dup.end
  dw dup_
question_dup.end:
  dw semicolon_s_

; ----------------------------------------------

if fig_name_field?

  _colon_header traverse_,'TRAVERS','E'

  ; TRAVERSE  ( a1 n --- a2 )

  ; XXX TODO -- simplify

  dw swap_ ; ( n a )
traverse.begin:
  dw over_,plus_ ; ( n a' )
  dw c_lit_
  db 0x7F ; invert of 0x80, the name bound bit mask
  dw over_,c_fetch_,less_than_
  dw zero_branch_,traverse.begin ; until
  dw swap_,drop_
  dw semicolon_s_

endif

; ----------------------------------------------

if not fig_name_field?

if 0 ; XXX OLD

  _colon_header lfa_to_nfa_,'LFA>NF','A'

lfa_to_nfa.begin:
  dw one_minus_,dup_,c_fetch_ ; ( a c )
  dw c_lit_
  db name_bound_bit_mask
  dw and_
  dw zero_branch_,lfa_to_nfa.begin ; until
  dw semicolon_s_

else ; faster alternative

  _code_header lfa_to_nfa_,'LFA>NF','A'

  pop hl
lfa_to_nfa.do:
  dec hl
  bit name_bound_bit,(hl)
  jp z,lfa_to_nfa.do
  jp push_hl

endif

endif

; ----------------------------------------------
  _colon_header latest_,'LATES','T'

  dw current_,fetch_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pfa_to_lfa_,'PFA>LF','A'

  dw c_lit_
  db 0x04
  dw minus_
  dw semicolon_s_

; ----------------------------------------------
  _code_alias_header pfa_to_cfa_,'PFA>CF','A',,two_minus_

; ----------------------------------------------
  _code_alias_header cfa_to_pfa_,'CFA>PF','A',,two_plus_

; ----------------------------------------------
  _code_alias_header cfa_to_lfa_,'CFA>LF','A',,two_minus_

; ----------------------------------------------
  _colon_header pfa_to_nfa_,'PFA>NF','A'

if fig_name_field?
  dw c_lit_
  db 0x05
  dw minus_,lit_,-1,traverse_
else
  dw pfa_to_lfa_,lfa_to_nfa_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header cfa_to_nfa_,'CFA>NF','A'

if fig_name_field?
  dw three_,minus_
  dw lit_,-1,traverse_
else
  dw cfa_to_lfa_,lfa_to_nfa_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header nfa_to_lfa_,'NFA>LF','A'

if fig_name_field?
  dw one_,traverse_,one_plus_
else
  dw dup_,c_fetch_
  dw c_lit_
  db max_word_length_bit_mask
  dw and_,plus_,one_plus_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header nfa_to_cfa_,'NFA>CF','A'

  dw nfa_to_lfa_,two_plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header nfa_to_pfa_,'NFA>PF','A'

  dw nfa_to_cfa_,cfa_to_pfa_
  dw semicolon_s_

; ----------------------------------------------
  _code_header nfa_to_string_,'NFA>STRIN','G'

; doc{
; nfa>string  ( nfa -- ca len )
; }doc

  ; From DZX-Forth.

  pop de
  ld a,(de)
  inc  de
  and max_word_length_bit_mask
  ld l,a
  ld h,0
  jp push_de_hl

; ----------------------------------------------
  _colon_header store_csp_,'!CS','P'

  dw sp_fetch_,csp_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_error_,'?ERRO','R'

  dw swap_
  dw zero_branch_,question_error.no_error
  dw error_
  dw semicolon_s_

question_error.no_error:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comp_question_,'COMP','?'

  dw state_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_comp_,'?COM','P'

  dw comp_question_,zero_equals_
  _question_error compilation_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exec_,'?EXE','C'

  dw comp_question_
  _question_error execution_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_pairs_,'?PAIR','S'

  dw not_equals_
  _question_error conditionals_not_paired_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_csp_,'?CS','P'

  dw sp_fetch_,csp_,fetch_,not_equals_
  _question_error definition_not_finished_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADIN','G'

  dw blk_,fetch_,zero_equals_
  _question_error loading_only_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header compile_,'COMPIL','E'

  dw question_comp_
  dw from_r_,dup_,two_plus_,to_r_,fetch_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header left_bracket_,'','[',immediate

  dw state_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header right_bracket_,'',']'

if fig_find?

  ; Note: Setting `state` to 0xC0 for "compiling state" will force
  ; non-immediate words to be compiled and immediate words to be executed. See
  ; note in `interpret` for more details.

  dw c_lit_
  db 0xC0
  dw state_,store_

else

  dw state_,on_

endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header smudge_,'SMUDG','E'

  dw latest_
  dw c_lit_
  db smudge_bit_mask
  dw toggle_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hex_,'HE','X'

  dw c_lit_
  db 0x10
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header decimal_,'DECIMA','L'

  dw c_lit_
  db 0x0A
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE',')'

  dw from_r_,latest_,nfa_to_cfa_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_code_,';COD','E',immediate

  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw left_bracket_,smudge_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header builds_,'<BUILD','S'

  ; XXX OLD
  ; XXX TODO remove this, and check `does>`
  ; XXX TODO adapt `vocabulary`
  dw zero_,constant_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header does_,'DOES','>'

  ; XXX TODO -- check

  dw from_r_ ; address of the first word after `does>` (the run-time routine)
  dw latest_,nfa_to_pfa_ ; pfa of the definition under construction
  dw store_ ; store the address of the run-time routine as the first parameter
  dw paren_semicolon_code_
do_does:
  ; Push the address of the next instruction on the return stack:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; XXX TODO understand
  ; Put the address of the run-time routine in IP:
  inc de      ; de=pfa
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ; W was incremented in the last instruction, pointing to the parameter field.
  ; Push the first parameter on stack:
  jp push_hl

; ----------------------------------------------
  _code_header count_,'COUN','T'

  ; Code from DZX-Forth.

  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUND','S'

  dw over_,plus_,swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header type_,'TYP','E'

  ; XXX TODO Rewrite in Z80, after the ROM routine.

  dw question_dup_
  dw zero_branch_,type.empty_string

  dw bounds_
  dw paren_do_
type.do:
  dw i_,c_fetch_,emit_
  dw paren_loop_,type.do ; loop
  dw semicolon_s_

type.empty_string:
  dw drop_
type.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header minus_trailing_,'-TRAILIN','G'


  ; XXX TODO Rewrite in Z80, if shorter.

  dw dup_,zero_
  dw paren_do_
minus_trailing.do:
  dw two_dup_,plus_
  dw one_minus_
  dw c_fetch_,b_l_,not_equals_
  dw zero_branch_,minus_trailing.space
  ; not a space
  dw leave_
  dw branch_,minus_trailing.loop
minus_trailing.space:
  dw one_minus_
minus_trailing.loop:
  dw paren_loop_,minus_trailing.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(."',')'

  dw r_fetch_,count_,dup_,one_plus_
  dw from_r_,plus_,to_r_
  dw type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_quote_,'.','"',immediate

  ; XXX TODO improve with the new string words

  dw c_lit_
  db '"'
  dw comp_question_ ; compiling?
  dw zero_branch_,dot_quote.interpreting
  ; compiling
  dw compile_,paren_dot_quote_
  dw word_ ; XXX FIXME use `parse` when available
  ; XXX but get the text at `here`
  dw here_,c_fetch_,one_plus_,allot_
  dw semicolon_s_
dot_quote.interpreting:
  dw word_,here_,count_,type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header expect_,'EXPEC','T'

  dw over_,plus_,over_ ; ( a a+len a )
  dw paren_do_
expect.do: ; ( a )
  dw key_,dup_ ; ( a c c )
  dw c_lit_
  db delete_char
  dw equals_ ; delete key?
  dw zero_branch_,expect.not_the_delete_key

  ; XXX FIXME This word has a bug in Abersoft Forth.  Sometimes, after using
  ; the delete key, the typed word is not recognized.  Maybe the `noop` the
  ; author used to patch the original bell?
  ;
  ; XXX TODO The `noop` and related `branch` were removed. Waiting for the code
  ; to fail...

  ; Delete key ( a c )
  dw drop_
  dw dup_,i_,equals_ ; cursor at the start position?
  dw dup_ ; ( a f f ) ; XXX why this?
  dw from_r_,two_minus_,plus_,to_r_
  dw question_branch_,expect.loop ; nothing to delete
  dw c_lit_
  db backspace_char
  dw branch_,expect.emit

expect.not_the_delete_key: ; ( a c )
  dw dup_
  dw c_lit_
  db carriage_return_char
  dw equals_ ; carriage return?
  dw zero_branch_,expect.ordinary_key

  ; Carriage return ( a c )
  dw leave_
  dw drop_,b_l_,zero_
  dw branch_,expect.store

expect.ordinary_key: ; ( a c )
  dw dup_

expect.store: ; ( a c c | a c 0 )
  dw i_,c_store_
  dw i_,one_plus_,off_

expect.emit: ; ( a c )
  dw emit_

expect.loop: ; ( a )
  dw paren_loop_,expect.do
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header query_,'QUER','Y'

  dw tib_,fetch_
  dw c_lit_
  db bytes_per_terminal_input_buffer
  dw expect_
  dw to_in_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header x_,'',0,immediate

; doc{

; x  ( -- )

; This is pseudonym for the "null" or dictionary entry for a
; name of one character of ascii null. It is the execution
; proceedure to terminate interpretation of a line of text from
; the terminal or within a disk buffer, as both buffers always
; have a null at the end.

; }doc

  dw blk_,fetch_ ; input stream from disk?
  dw zero_branch_,x.exit ; if not, branch
  ; From disk.
  dw one_,blk_,plus_store_ ; next disk buffer
  dw to_in_,off_ ; clear `in`, preparing parsing of input text
  ; Note: This check of the last block is specific for 2
  ; blocks per screen; the generic slower check would be `blk @
  ; b/scr 1- and`.
  dw blk_,fetch_,one_,and_ ; was it the last block of the screen?
  dw question_branch_,x.end ; if not, branch
  ; Last block of the screen.
  dw question_exec_ ; error if not executing
x.exit:

  ; The top item on the return stack is thrown away.  The interpreter
  ; will not continue to execute the `?stack` instruction that follows
  ; `execute` in `interpret`, but will return to the next higher level
  ; of nesting and execute the next word after `interpret` in the Forth
  ; loop.  This is when the familiar "ok" message is displayed on the
  ; terminal, prompting the operator for the next line of commands.

  dw r_drop_

x.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header fill_,'FIL','L'

  pop de ; e = char
fill.e:
  ld l,c
  ld h,b ; the Forth IP
  pop bc ; count
  ex (sp),hl ; save the Forth IP
fill.do
  ld a,b
  or c
  _jump_z fill.end
  ld (hl),e
  inc hl
  dec bc
  jp fill.do
fill.end:
  pop bc ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header erase_,'ERAS','E'

  ld e,0
  jp fill.e

; ----------------------------------------------
  _code_header blank_,'BLAN','K'

  ld e,space_char
  jp fill.e

; ----------------------------------------------
  _colon_header hold_,'HOL','D'

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pad_,'PA','D'

  dw here_
  dw c_lit_
  db 0x44
  dw plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header stream_,'STREA','M'

; doc{
;
; stream  ( -- ca )
;
; ca = current parsing position in the stream source
;
; }doc

  dw blk_,fetch_,question_dup_ ; from disk?
  dw zero_branch_,stream.terminal
  dw block_ ; from disk
  dw branch_,stream.end
stream.terminal:
  dw tib_,fetch_ ; from terminal
stream.end:
  dw to_in_,fetch_,plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parse_,'PARS','E'

; doc{
;
; parse  ( c "ccc<c>" -- ca len )  \ Forth-94
;
; Parse _ccc_ delimited by the delimiter char _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
; 
; If the parse area was empty, the resulting string has a zero length.
;
; }doc

  dw stream_,scan_
  dw two_dup_,two_,ink_,type_,zero_,ink_ ; XXX INFORMER
  dw dup_,one_plus_,to_in_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header word_,'WOR','D'

; doc{
;
; word  ( c  -- )  \ fig-Forth
;
; Read the next text characters from the input stream being
; interpreted, until a delimiter _c_ is found, storing the
; packed character string beginning at the dictionary buffer
; `here`.  `word` leaves the character count in the first byte,
; the characters, and ends with two or more blanks. Leading
; occurrences of c are ignored.  If `blk` is zero text is taken
; from the terminal input buffer, otherwise from the disk block
; stored in `blk`.

; }doc

  ; XXX TODO use `skip parse` instead of `enclose` and rewrite
  ; the rest.

  dw stream_,enclose_
  ;dw stream,true_,paren_parse_ ; XXX OLD -- abandoned idea

  ; XXX TODO use a factor of `s,` instead, without `allot`:
  dw here_
  dw c_lit_
  db max_word_length+3
  dw blank_
  dw to_in_,plus_store_
  dw over_,minus_,to_r_ ; length
  dw r_fetch_,here_,c_store_ ; set the length byte
  dw plus_ ; from
  dw here_,one_plus_ ; destination
  dw from_r_ ; count
  dw cmove_ ; move the word

  if 1 ; XXX INFORMER
    dw space_ ; XXX INFORMER
    ;dw depth_,dot_ ; XXX INFORMER
    ;dw paren_dot_quote_ ; XXX INFORMER
    ;_string 'blk ' ; XXX INFORMER
    ;dw blk_,fetch_,dot_ ; XXX INFORMER
    ;dw paren_dot_quote_ ; XXX INFORMER
    ;_string 'in ' ; XXX INFORMER
    ;dw in_,fetch_,dot_ ; XXX INFORMER
    dw here_,count_,one_,ink_,type_,zero_,ink_ ; XXX INFORMER
    ;dw key_,drop_ ; XXX INFORMER
  endif

  dw semicolon_s_



; ----------------------------------------------
  _colon_header paren_number_,'(NUMBER',')'

paren_number.begin: ; begin
  dw one_plus_ ; address of the next digit
  dw dup_,to_r_ ; save the address
  dw c_fetch_ ; get the digit
  dw base_,fetch_,digit_ ; convert the digit
  dw zero_branch_,paren_number.end ; while
  dw swap_ ; get the high order part of d1 to the top.
  dw base_,fetch_,u_star_ ; multiply by base value
  dw drop_ ; drop the high order part of the product
  dw rot_ ; move the low order part of d1 to top of stack
  dw base_,fetch_,u_star_ ; multiply by base value
  dw d_plus_ ; accumulate result into d1
  dw dpl_,fetch_,one_plus_ ; is DPL other than -1?
  dw zero_branch_,paren_number.decimal_point_done
  ; DPL is not -1, a decimal point was encountered
  dw one_,dpl_,plus_store_ ; increment DPL, one more digit to right of decimal point
paren_number.decimal_point_done
  dw from_r_ ; pop addr1+1 back to convert the next digit
  dw branch_,paren_number.begin ; repeat
paren_number.end:
  dw from_r_ ; address of the first non-convertable digit, a2.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header number_,'NUMBE','R'

  dw zero_,zero_,rot_ ; two zeros, initial value of the double number
  ;dw dup_,count_,swap_,dot_,dot_ ; XXX INFORMER
  dw dup_,one_plus_,c_fetch_ ; get the first digit
  dw c_lit_
  db '-'
  dw equals_ ; is it a minus sign?
  dw dup_,to_r_ ; save the flag
  ; XXX TODO add `abs` here when `true` is changed to `-1`
  dw plus_
  ; If the first digit is "-", the flag is 1,
  ; and addr+1 points to the second digit.
  ; If the first digit is not "-", the flag is
  ; 0.  addr+0 remains the same, pointing to
  ; the first digit.
  dw lit_,-1 ; initial value of `dpl`
number.begin:
  dw dpl_,store_
  dw paren_number_ ; convert one digit after another until an invalid char occurs
  dw dup_,c_fetch_ ; get the invalid digit
  dw b_l_,not_equals_ ; not a blank?
  dw zero_branch_,number.not_a_blank
  ; The invalid digit is not a blank.
  dw dup_,c_fetch_ ; get the invalid digit again
  dw c_lit_
  db '.'
  dw not_equals_ ; not a decimal point?
  _question_error not_understood_error ; error if not
  ; Decimal point found, set `dpl` to zero next time.
  dw zero_
  dw branch_,number.begin ; repeat
number.not_a_blank:
  dw drop_ ; discard address
  dw from_r_ ; pop the flag of "-" sign back
  dw zero_branch_,number.end
  ; The first digit is a "-" sign.
  dw dnegate_
number.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header upper_,'UPPE','R'

  ; uppers  ( c -- c' )

  pop hl
  ld a,l
  call upper.a
  ld l,a
  jp push_hl

upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20 ; toggle bit 5
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPER','S'

  ; uppers  ( ca len -- )

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upper.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

; ----------------------------------------------
if fig_find?

  _colon_header context_find_,'CONTEXT-FIN','D'

; doc{
;
; context-find  ( "name" -- pfa b tf | ff )
;
; Accept the next text word (delimited by blanks) in the input stream to
; `here`, and search the `context` vocabulary for a matching entry.  If found,
; leave the dictionary entry's parameter field address, its length byte, and a
; boolean true.  Otherwise, leave only a boolean false.
;
; }doc

  ; XXX TODO -- return cfa instead of pfa
  dw b_l_,word_
  dw here_,count_,uppers_
  dw here_,context_,fetch_,fetch_
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  dw paren_find_
  ;dw to_r_,to_r_,dup_,dot_,from_r_,dup_,dot_,from_r_,dup_,dot_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  dw semicolon_s_
endif

; ----------------------------------------------
if fig_find?
  _colon_header defined_question_,'DEFINED','?'

  ; XXX TODO -- not finished
  dw context_find_,dup_
  dw zero_branch_,defined_question.end
  dw two_drop_
defined_question.end:
  dw semicolon_s_
endif

; ----------------------------------------------

if fig_find?
  _colon_header undefined_question_,'UNDEFINED','?'

  ; XXX TODO -- not finished
  dw defined_question_,zero_equals_
  dw semicolon_s_
endif

; ----------------------------------------------

if fig_find?

  _colon_header find_,'FIN','D'

; doc{
;
; find  ( "name" --- pfa b tf | ff )
;
; Accept the next text word (delimited by blanks) in the input
; stream to `here`, and search the `context` and then `current`
; vocabularies for a matching entry.  If found, leave the
; dictionary entry's parameter field address, its length byte,
; and a boolean true.  Otherwise, leave only a boolean false.
;
; }doc

  ; XXX TODO -- return cfa instead of pfa
  dw context_find_,question_dup_
  ; XXX TODO -- optimize with `?exit' here instead of a branch
  dw question_branch_,find.end
  ; The word was not found in the context vocabulary,
  ; try again in the current vocabulary.
  ; XXX TODO -- remove this?
  dw here_,latest_,paren_find_
find.end:
  dw semicolon_s_


else ; XXX NEW -- modern `find`

  _colon_header find_,'FIN','D'

; doc{
;
; find  ( ca --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  dw context_,fetch_,fetch_,paren_find_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT',')'

  dw abort_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header error_number_,'ERROR#','S'

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-PO','S'

  dw 0,0

; ----------------------------------------------
  _colon_header error_,'ERRO','R'

  dw dup_,error_number_,store_ ; save the error number
  dw warning_,fetch_,zero_less_than_
  ; XXX TODO optimize: jump directly to parent_abort_
  dw zero_branch_,error.message
  dw paren_abort_

error.message:
  dw here_,count_,type_ ; last parsed word
  dw paren_dot_quote_
  _string '? '
  dw message_
  dw sp_store_
  ; XXX TODO save the output parameters?
  ; (`where` will be in the disk)
  dw blk_,fetch_,question_dup_
  dw zero_branch_,error.end
  dw to_in_,fetch_
  dw swap_
  dw error_pos_,two_store_ ; XXX NEW
error.end:
  dw quit_

; ----------------------------------------------
  _colon_header id_dot_,'ID','.'

if fig_name_field?

  dw pad_
  dw c_lit_
  db max_word_length+1
  dw c_lit_
  db 0x5F ; XXX why this char?
  dw fill_
  dw dup_,nfa_to_lfa_,over_ ; ( nfa lfa nfa )
  dw minus_ ; ( nfa len+1 )
  dw pad_,swap_,cmove_
  dw pad_,count_ ; ( pad len+name_bound_bit_mask+n )
  dw c_lit_
  db max_word_length
  dw and_ ; ( pad len )
  dw two_dup_,plus_,one_minus_ ; address of the last char ( pad len pad+len-1 )
if 0 ; XXX OLD
  dw dup_,fetch_
  dw lit_,0xFF7F,and_
  dw swap_,store_
else ; XXX NEW
  dw dup_,c_fetch_
  dw c_lit_
  db 0x7F
  dw and_,swap_,c_store_
endif
  dw type_,space_
  dw semicolon_s_

else ; XXX NEW -- name field without end bit in the last char

  dw nfa_to_string_,type_,space_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header header_,'HEADE','R'

; header  ( "name" -- )

  ; XXX NEW
  ; XXX TMP -- this is a copy of the original `create`.
  ; XXX TODO -- accept an xt as parameter?

  if fig_find?
    dw find_
    dw zero_branch_,header.continue
    ; The word is not unique.
    dw drop_,pfa_to_nfa_
  else
    dw defined_,nip_
    dw zero_branch_,header.continue
    ; The word is not unique.
    dw cfa_to_nfa_
  endif
  dw id_dot_
  _message not_unique_error
header.continue:
  dw here_
  ; XXX TODO error if name is too long (see lina)
  dw dup_,c_fetch_,width_,fetch_,min_,one_plus_,allot_ ; allocate space for name field
  dw dup_
  dw c_lit_
  db name_bound_bit_mask+smudge_bit_mask
  dw toggle_
  if fig_name_field?
    ; Toggle the name bound bit in the last character of the
    ; name, as a delimiter to the name field.
    dw here_,one_minus_
    dw c_lit_
    db name_bound_bit_mask
    dw toggle_
  endif
  dw latest_,comma_ ; compile the nfa of the last word in the link field
  dw current_,fetch_,store_ ; update contents of `latest` in the current vocabulary
  dw here_,two_plus_,comma_ ; compile the pfa into code field.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header create_,'CREAT','E'

  ; XXX TODO -- rewrite after Forth-83 and Forth-94.

  dw header_,smudge_
  dw paren_semicolon_code_
do_create:
  inc de  ; de=pfa
  ex de,hl
  jp push_hl

; ----------------------------------------------
  _does_header assembler_,'ASSEMBLE','R'

  dw do_vocabulary
assembler_vocabulary_dummy_nfa:
  dw 0xA081 ; Dummy name field.
assembler_vocabulary_latest:
  dw forth_vocabulary_dummy_nfa
assembler_vocabulary_link:
  dw forth_vocabulary_link

; ----------------------------------------------
  _colon_header code_,'COD','E'

  dw header_
  dw base_,fetch_,hex_ ; save the current `base`
  dw context_,fetch_ ; save the current `context`
  dw assembler_
  dw store_csp_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header end_code_,'END-COD','E'

  dw question_csp_
  dw context_,store_ ; restore `context`
  dw base_,store_ ; restore `base`
  dw smudge_
  dw semicolon_s_

; ----------------------------------------------
  _code_header compare_,'COMPAR','E'

  ; ANS Forth
  ; Adapted from DZX-Forth

  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  pop de      ; de = len2
  pop hl      ; hl = ca2
  ex (sp),hl  ; hl = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; cy = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; de = length of the short string
  ; hl = length of the long string
  ld l,c
  ld h,b ; hl = Forth IP
  pop bc ; bc = ca2
  ex (sp),hl ; hl = ca1 ; save Forth IP
  push af ; save carry flag
compare_.compare_strings: equ $+1 ; XXX not used yet
  call compare_strings_case_sensitive
  ;jr z,compare.match
  jr nz,compare.no_match

compare.match:
  ; The smaller string matches.
  pop af ; restore flags
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl
  dec hl ; 0
  jp z,push_hl ; string1 equals string2
  dec hl ; -1
  jp push_hl

compare_strings_case_sensitive:
  ; Copied from DZX-Forth.
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; ----------------------------------------------
  _code_header search_,'SEARC','H'

  ; search  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  ; ANS Forth

  ; Adapted from DZX-Forth.
  ;
  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  exx ; save Forth IP
  pop hl
  ld (search.string_2_len),hl
  ld a,l
  or h ; len2 is zero?
  pop bc ; ca2
  pop hl ; len1
  ld (search.string_1_len),hl
  ex de,hl ; de = len1
  pop hl ; ca1
  ld (search.string_1_addr),hl
  jp z,search.match ; if len2 is zero, match
  dec hl
  inc de
search.1:
  inc hl ; address of current char of string 1
  dec de ; remaining length of string 1
  ld a,e
  or d ; end of string 1?
  jp z,search.no_match
; XXX OLD -- already commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
search.string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings_case_sensitive
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.match:
  ld bc,true
search.end:
  push hl
  push de
  push bc
  exx ; restore Forth IP
  _jp_next

search.no_match:
  ld bc,false
search.string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
search.string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.end

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE',']',immediate

if fig_find?
  dw find_,zero_equals_
  _question_error not_found_error
  dw drop_,pfa_to_cfa_,comma_
else
  dw tick_,comma_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERA','L',immediate

  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate

  dw compile_,s_lit_,s_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_literal_,'CLITERA','L',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,c_lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header literal_,'LITERA','L',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header two_literal_,'2LITERA','L',immediate

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    ; XXX TODO -- dlit
    dw question_comp_
    dw swap_,literal_,literal_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header depth_,'DEPT','H'

  dw sp_fetch_,s0_,fetch_,minus_,lit_,-2,slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_stack_,'?STAC','K'

  dw sp_fetch_
  dw s0_,fetch_
  dw swap_,less_than_
  _question_error stack_empty_error
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_error full_stack_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header interpret_,'INTERPRE','T'

; XXX TODO -- In order to change the behaviour of `literal`, `2literal`
; and `cliteral` (make them give an error in interpretation mode),
; `interpret` must be modified.

if fig_find?

; doc{
;
; interpret  ( -- )  \ fig-Forth
;
; The outer text interpreter which sequentially executes or
; compiles text from the input stream (terminal or disk)
; depending on `state`. if the word name cannot be found after a
; search of `context` and then `current` it is converted to a
; number according to the current `base`.  That also failing, an
; error message echoing the name with a "?" will be given.
;
; }doc

interpret.begin:
  dw find_ ; found?
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  dw zero_branch_,interpret.word_not_found ; if

  ; Note:
  ;
  ; `state` holds 0xC0 when compiling.  The text interpreter
  ; compares the value stored in `state` with the value in the
  ; length byte of the definition found in the dictionary.  If
  ; the definition is an immediate word, its length byte is
  ; greater than 0xC0 because of the precedence and the sign
  ; bits are both set.  Setting `state` to 0xC0 will force
  ; non-immediate words to be compiled and immediate words to be
  ; executed.

  dw state_,fetch_,less_than_ ; compile the word?
  dw zero_branch_,interpret.execute_the_word ; if
  dw pfa_to_cfa_,comma_ ; compile the word
  dw branch_,interpret.word_done
interpret.execute_the_word: ; else
  dw pfa_to_cfa_
  dw execute_
interpret.word_done: ; then
  dw lit_,1,border_ ; XXX INFORMER
  dw question_stack_
  dw branch_,interpret.again
interpret.word_not_found: ; else
  ; word not found, try to convert the text to a number
  dw here_,number_
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number ; if
  ; decimal point detected, so it's a double, 32-bit, number
  dw two_literal_
  dw branch_,interpret.number_done
interpret.16bit_number: ; else
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
interpret.number_done: ; then
  dw lit_,2,border_ ; XXX INFORMER
  dw question_stack_

interpret.again:
  dw branch_,interpret.begin

else ; XXX NEW -- version with modern `find`

interpret.begin:

; doc{
;
; interpret  ( -- )
;
; The outer text interpreter which sequentially executes or
; compiles text from the input stream (terminal or disk)
; depending on `state`. if the word name cannot be found after a
; search of `context` it is converted to a number according to
; the current `base`.  That also failing, an error message
; echoing the name with a "?" will be given.
;
; }doc
; 
; Note: The main difference with the fig-Forth version of
; `interpret` is this version does not search the `current`
; vocabulary.

  ; XXX TODO -- finish

  dw lit_,3,border_ ; XXX INFORMER
  dw question_stack_
  dw defined_,question_dup_ ; found?
  dw zero_branch_,interpret.word_not_found

  ; Found ( cfa 1 | cfa -1 )
  ; XXX TODO -- remove `negate` when `true` will equal -1 instead of 1
  dw state_,fetch_,negate_ ; compiling?
  dw equals_ ; compiling an immediate word?
  dw zero_branch_,interpret.execute

  ; Compiling and not immediate  ( cfa )
  dw comma_ ; compile the word
  dw branch_,interpret.begin

interpret.execute:
  ; Executing or immediate ( cfa )
  dw execute_
  dw branch_,interpret.begin

interpret.word_not_found:
  ; try to convert the text to a number
  ; ( ca )
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  dw number_
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number
  ; decimal point detected, so it's a double, 32-bit, number
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw two_literal_
  dw branch_,interpret.begin

interpret.16bit_number:
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
  dw branch_,interpret.begin

endif

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIAT','E'

  dw latest_
  dw c_lit_
  db precedence_bit_mask
  dw toggle_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header vocabulary_,'VOCABULAR','Y'

  dw builds_ ; XXX TODO convert; see DZX-Forth
  dw lit_,0xA081,comma_ ; dummy name field
  dw current_,fetch_,pfa_to_cfa_,comma_
  dw here_
  dw voc_link_,fetch_,comma_
  dw voc_link_,store_
  dw does_
do_vocabulary:
  dw two_plus_,context_,store_
  dw semicolon_s_

; ----------------------------------------------
  _does_header forth_,'FORT','H'

  dw do_vocabulary
forth_vocabulary_dummy_nfa:
  dw 0xA081 ; Dummy name field.
forth_vocabulary_latest:
  dw nfa_of_top_most_word_in_forth_voc
forth_vocabulary_link:
  dw 0x0000

; ----------------------------------------------
  _colon_header definitions_,'DEFINITION','S'

  dw context_,fetch_
  dw current_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_,'','(',immediate

  dw c_lit_
  db ')'
  if 0 ; XXX OLD
    dw word_
  else
    ; XXX TODO use `skip`?
    dw parse_,two_drop_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header quit_,'QUI','T'

  dw blk_,off_
  dw left_bracket_
quit.do:
  dw rp_store_
  dw cr_,query_
  dw interpret_
  dw comp_question_
  dw question_branch_,quit.do
  dw paren_dot_quote_
  _string 'ok'
  dw branch_,quit.do

; ----------------------------------------------
  _colon_header greeting_,'GREETIN','G'

  dw paren_dot_quote_
  _string "Solo Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abort_,'ABOR','T'

  dw sp_store_
  dw decimal_
  dw lit_,4,border_ ; XXX INFORMER
  dw question_stack_
  dw page_,greeting_
  dw forth_,definitions_
boot:
  dw noop_ ; patched by `turnkey`
  dw quit_

; ----------------------------------------------
  _constant_header boot_,'BOO','T'

  dw boot

; ----------------------------------------------
  _colon_header warm_,'WAR','M'

  dw empty_buffers_
  dw abort_

warm_start:
  call common_start
warm_start_phony_:
  dw warm_

; ----------------------------------------------
  _colon_header cold_,'COL','D'

  dw empty_buffers_
  dw first_,dup_,use_,store_,prev_,store_
  dw lit_,default_user_variables_start ; from
  dw lit_,user_variables_pointer,fetch_ ; to
  dw c_lit_
  db default_user_variables_end-default_user_variables_start ; length
  dw cmove_
  dw lit_,top_most_word_in_forth_voc,fetch_
  dw lit_,forth_vocabulary_latest,store_
  dw abort_

cold_start:
  call common_start
cold_start_phony_:
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  pop bc ; get the return address, that holds the cfa of `cold` or `warm`
  xor a
  ld (iy+sys_df_sz_offset),a ; no lines at the bottom part of the screen
  ld ix,next
  ld sp,(s0_init_value)
  _jp_next

; ----------------------------------------------
  _code_header s_to_d_,'S>','D'

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_de_hl ; jump if positive
  dec hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header plus_minus_,'+','-'

  dw zero_less_than_
  dw zero_branch_,plus_minus.end
  dw negate_
plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_plus_minus_,'D+','-'

  dw zero_less_than_
  dw zero_branch_,d_plus_minus.end
  dw dnegate_
d_plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abs_,'AB','S'

  dw dup_
  dw plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dabs_,'DAB','S'

  dw dup_
  dw d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _code_header umax_,'UMA','X'

  ; umax  ( u1 u2 -- u1 | u2 )

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMI','N'

  ; umin  ( u1 u2 -- u1 | u2 )

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MI','N'

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MA','X'

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  ex de,hl
  jp push_hl

; ----------------------------------------------
  _colon_header m_star_,'M','*'

  dw two_dup_
  dw xor_,to_r_
  dw abs_
  dw swap_,abs_,u_star_
  dw from_r_,d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_,'M','/'

  dw over_
  dw to_r_
  dw to_r_
  dw dabs_
  dw r_fetch_
  dw abs_
  dw u_slash_mod_
  dw from_r_
  dw r_fetch_
  dw xor_
  dw plus_minus_
  dw swap_
  dw from_r_
  dw plus_minus_
  dw swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_,'','*'

  dw m_star_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_mod_,'/MO','D'

  dw to_r_,s_to_d_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_,'','/'

  dw slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header mod_,'MO','D'

  dw slash_mod_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MO','D'

  dw to_r_,m_star_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_,'*','/'

  dw star_slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_mod_,'M/MO','D'

  dw to_r_,zero_,r_fetch_
  dw u_slash_mod_
  dw from_r_,swap_
  dw to_r_,u_slash_mod_,from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_line_,'(LINE',')'

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_,b_slash_scr_,star_,plus_
  dw block_,plus_,c_slash_l_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_line_,'.LIN','E'

  dw paren_line_,minus_trailing_,type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header message_,'MESSAG','E'

  dw warning_,fetch_
  dw zero_branch_,message.number_only
  dw msg_scr_,dot_line_,space_
  dw semicolon_s_

message.number_only:
  dw paren_dot_quote_
  _string 'MSG # '
  ; XXX TODO force decimal base
  dw dot_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header use_,'US','E'

  dw first_buffer

; ----------------------------------------------
  _variable_header prev_,'PRE','V'

  dw first_buffer

; ----------------------------------------------
  _constant_header hash_buff_,'#BUF','F'

  dw buffers

; ----------------------------------------------
  _colon_header plus_buf_,'+BU','F'

; doc{

; +buf  ( a1 -- a2 f )  \ fig-Forth

;   Advance the disk buffer address _a1_ to the address of the next
;   buffer _a2_.  Boolean _f_ is false when _a2_ is the buffer
;   presently pointed to by the variable `prev`.

; }doc

  dw lit_,total_bytes_per_buffer,plus_ ; a2
  dw dup_,limit_,equals_ ; out of bounds?
  dw zero_branch_,plus_buf.continue
  ; a2 is out of bounds
  dw drop_,first_ ; use the first buffer instead
plus_buf.continue:
  dw dup_,prev_,fetch_,not_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header update_,'UPDAT','E'

  dw prev_,fetch_,fetch_
  dw lit_,0x8000,or_
  dw prev_,fetch_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFER','S'

  dw first_,limit_,over_,minus_,erase_
  dw limit_,first_
  dw paren_do_
empty_buffers.do:
  dw lit_,0x7FFF,i_,store_
  dw lit_,total_bytes_per_buffer
  dw paren_plus_loop_,empty_buffers.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_,'BUFFE','R'

; doc{

; : buffer  ( n -- a )

; Obtain the next block buffer and assign it to block _n_.   If the
; contents of the buffer were marked as updated, it is written to the
; disk.  The block _n_ is not read from the disk.  The address left on
; stack is the first cell in the buffer for data storage.

; }doc

  dw use_,fetch_
  dw dup_,to_r_
buffer.begin:
  ; XXX NOTE: `+buf` won't work if single buffer
  dw plus_buf_
  dw zero_branch_,buffer.begin ; until
  dw use_,store_
  dw r_fetch_,fetch_
  dw zero_less_than_ ; updated?
  dw zero_branch_,buffer.end
  ; The buffer was updated, it must be saved to disk.
  dw r_fetch_,two_plus_ ; first cell of data in the buffer
  dw r_fetch_,fetch_
  dw lit_,0x7FFF,and_ ; discard the update bit, leave the block number
  dw zero_,read_write_ ; write
buffer.end:
  dw r_fetch_,store_
  dw r_fetch_,prev_,store_
  dw from_r_,two_plus_ ; first cell of data in the buffer
  dw semicolon_s_

; ----------------------------------------------
  _colon_header block_,'BLOC','K'

  dw to_r_
  dw prev_,fetch_ ; most recently accessed buffer
  dw dup_,fetch_ ; its block number (bit 15, the update indicator, may be set)
  dw r_fetch_,minus_ ; compare to the required block
  dw two_star_ ; discard the left most bit, with is the update indicator
  dw zero_branch_,block.end
  ; Block number n is not the previously referenced.
  ; Prepare disk access.
block.begin:
  ; Scan the buffers and look for a buffer which might contain block n already.
  dw plus_buf_,zero_equals_ ; advance a buffer
  dw zero_branch_,branch_destination_0x71E5
  ; This buffer is pointed to by `prev`, all buffers scanned.
  dw drop_ ; discard the buffer address
  dw r_fetch_,buffer_ ; find the disk sector, update the sector if necessary.
  dw dup_,r_fetch_,one_,read_write_ ; read one sector from the disk
  dw two_minus_ ; backup to the buffer address of block n
branch_destination_0x71E5:
  dw dup_,fetch_ ; beginning address of the buffer, with a block number in it
  dw r_fetch_,minus_ ; compare to the block number n.
  dw two_star_ ; discard the left most bit, with is the update indicator
  dw question_branch_,block.begin ; until
  dw dup_,prev_,store_ ; store the buffer address in `prev`
block.end:
  dw r_drop_
  dw two_plus_ ; get the address where data begin
  dw semicolon_s_

; ----------------------------------------------
  _code_header c_swap_,'FLI','P'

; doc{
;
; flip  ( n1 -- n2 )
;
;   Exchange the low and high bytes within n1.
;
; }doc

; [Name taken from eForth.]

  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp push_hl

; ----------------------------------------------
  _colon_header block_to_sector_,'BLOCK>SECTO','R'

; doc{

; : block>sector  ( block -- sector )
;   \ sector (high byte) = track 0..79, +128 if side 1
;   \        (low byte)   = sector 1..10
;   dup 10 mod 1+    \ sector 1..10
;   swap dup 20 /    \ track 0..79
;   swap 10 / 1 and  \ side 0..1
;   128 * +          \ track 0..207
;   cswap or  ;

; }doc

  dw dup_
  dw c_lit_
  db 10
  dw mod_,one_plus_,swap_,dup_
  dw c_lit_
  db 20
  dw slash_,swap_
  dw c_lit_
  db 10
  dw slash_,one_,and_
  ; XXX TODO optimize with `7 lshift`?
  dw c_lit_
  db 128
  dw star_,plus_,c_swap_,or_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header read_write_,'R/','W'

  dw c_lit_
  db 0x45
  dw swap_,minus_
  dw lit_,read_write_sector_command,c_store_
  dw block_to_sector_
  dw paren_read_write_
  dw semicolon_s_

  ; Headerless word with the low level code of `R/W`.
paren_read_write_:
  dw paren_read_write_pfa
paren_read_write_pfa:
  ld a,2 ; drive ; XXX TMP
  pop de ; sector
  pop hl ; address
  push bc
  push hl
  pop ix ; address
  rst 8
read_write_sector_command:
  ; Patched by `R/W`:
  ;   0x45 = write
  ;   0x44 = read
  db 0x44
  pop bc
  ld ix,next
  _jp_next

; ----------------------------------------------
  _colon_header flush_,'FLUS','H'

  ; XXX TODO -- move to the disk?

  dw hash_buff_,one_plus_,zero_
  dw paren_do_
flush.do:
  dw zero_,buffer_,drop_
  dw paren_loop_,flush.do ; loop
  dw semicolon_s_

; ----------------------------------------------
  _colon_header continued_,'CONTINUE','D'

  dw dup_,zero_,equals_
  _question_error loading_from_screen_0_error
  dw to_in_,off_
  dw b_slash_scr_,star_,blk_,store_
  dw interpret_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header load_,'LOA','D'

  dw blk_,fetch_,to_r_
  dw to_in_,fetch_,to_r_
  dw continued_
  dw from_r_,to_in_,store_
  dw from_r_,blk_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header next_screen_,'--','>',immediate

  dw question_loading_
  dw to_in_,off_
  dw b_slash_scr_,blk_,fetch_,over_,mod_,minus_
  dw blk_,plus_store_
  dw semicolon_s_

; ----------------------------------------------

if not fig_find?

  _colon_header defined_,'DEFINE','D'

  ; XXX TODO -- adapt to the new parsing method?

  dw b_l_,word_
  dw here_,dup_,count_,uppers_,find_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINE','D'

  ; From DZX-Forth.

  dw zero_equals_
  _question_error not_found_error
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED',']',immediate

if fig_find?
  dw find_,dup_
  dw zero_branch_,bracket_defined.end
  dw nip_,nip_
bracket_defined.end:
else
  dw defined_,nip_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED',']',immediate

  dw bracket_defined_,zero_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header tick_,'',"'"

if fig_find?
  dw find_
  dw zero_equals_
  _question_error not_found_error
  ; XXX TODO -- after modifying `(find)`, `pfa>cfa` will be unnecessary
  dw drop_,pfa_to_cfa_
else
  dw defined_,question_defined_
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_tick_,"['",']',immediate

  dw tick_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header begin_,'BEGI','N',immediate

  dw question_comp_
  dw backward_mark_
  dw one_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header then_,'THE','N',immediate

  dw question_comp_
  dw two_,question_pairs_
  dw forward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header do_,'D','O',immediate

  dw compile_,paren_do_
  dw backward_mark_
  dw three_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header loop_,'LOO','P',immediate

  dw three_,question_pairs_
  dw compile_,paren_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOO','P',immediate

  dw three_
  dw question_pairs_
  dw compile_,paren_plus_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header until_,'UNTI','L',immediate

  dw one_,question_pairs_
  dw compile_,zero_branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header again_,'AGAI','N',immediate

  dw one_,question_pairs_
  dw compile_,branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header repeat_,'REPEA','T',immediate

  ; XXX TODO simplify
  ; XXX TODO optimize with 2>r and 2r>
  ; XXX TODO optimize with  `<resolve`
  dw to_r_
  dw to_r_
  dw again_
  dw from_r_
  dw from_r_
  dw two_minus_
  dw then_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header if_,'I','F',immediate

  dw compile_,zero_branch_
  dw forward_mark_
  dw two_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header unless_,'UNLES','S',immediate

  ; Equivalent to `0= if`, but faster.

  dw compile_,question_branch_
  dw forward_mark_
  dw two_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header else_,'ELS','E',immediate

  dw two_
  dw question_pairs_
  dw compile_,branch_
  dw forward_mark_
  dw swap_
  dw two_
  dw then_
  dw two_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header while_,'WHIL','E',immediate

  dw if_
  dw two_plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header spaces_,'SPACE','S'

  dw b_l_,emits_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header emits_,'EMIT','S'

  ; emits  ( u c -- )

  ; XXX TODO use `?do` when available
  dw swap_,question_dup_
  dw zero_branch_,emits_.end
  dw zero_
  dw paren_do_
emits_.do:
  dw dup_,emit_
  dw paren_loop_,emits_.do
emits_.end:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header less_hash_,'<','#'

  dw pad_
  dw hld_
  dw store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_greater_,'#','>'

  dw drop_
  dw drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header sign_,'SIG','N'

; doc{

; sign  ( n  d  ---  d ) \ fig-Forth

; Stores an ascii "-" sign just before a converted numeric
; output string in the text output buffer when _n_ is negative.
; _n_ is discarded but double number _d_ is maintained. Must be
; used between `<#` and `#>`.

; }doc

  ; XXX TODO convert to Forth-94

  dw rot_,zero_less_than_
  dw zero_branch_,sign.end
  dw c_lit_
  db '-'
  dw hold_
sign.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_,'','#'

  dw base_,fetch_,m_slash_mod_,rot_
  dw c_lit_
  db 0x09
  dw over_,less_than_
  dw zero_branch_,hash.digit
  dw c_lit_
  db 0x07
  dw plus_
hash.digit:
  dw c_lit_
  db '0'
  dw plus_,hold_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_s_,'#','S'

hash_s.begin:
  dw hash_,two_dup_,or_,zero_equals_
  dw zero_branch_,hash_s.begin ; until
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.','R'

  dw to_r_ ; save n
  ; Save the high order part of d under d,
  ; to be used by `sign` to add a "-" sign to a negative number:
  dw swap_,over_
  dw dabs_ ; convert d to its absolute value
  ; Convert the absolute value to ASCII text with proper sign:
  dw less_hash_,hash_s_,sign_,hash_greater_
  dw from_r_ ; retrieve n
  dw over_,minus_,spaces_ ; fill the output field with preceding blanks
  dw type_ ; type out the number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_r_,'.','R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_,'D','.'

  dw zero_,d_dot_r_,space_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_,'','.'

  dw s_to_d_,d_dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_,'','?'

  dw fetch_,dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header u_dot_,'U','.'

  dw zero_,d_dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header words_,'WORD','S'

  ; XXX TODO move to the disk
  dw c_lit_
  db 0x80
  dw out_,store_
  dw context_,fetch_,fetch_
words.begin:
  dw out_,fetch_
  dw c_lit_
  db 0x1F ; max word length
  dw c_lit_
  db 0x08
  dw minus_
  dw greater_than_
  dw zero_branch_,words.continue
  dw cr_,out_,off_
words.continue:
  dw dup_,id_dot_
  dw nfa_to_lfa_,fetch_
  dw dup_,zero_equals_,question_terminal_,or_
  dw zero_branch_,words.begin ; until
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header list_,'LIS','T'


  ; XXX TODO move to the disk
  dw cr_
  dw dup_,scr_,store_
  dw paren_dot_quote_
  _string 'Scr # '
  dw dot_
  dw c_lit_
  db lines_per_screen
  dw zero_
  dw paren_do_
list.do:
  dw cr_
  dw i_
  dw c_lit_
  db 0x02
  dw dot_r_
  dw space_,i_,scr_,fetch_,dot_line_
  dw question_terminal_
  dw zero_branch_,list.loop
  dw leave_
list.loop:
  dw paren_loop_,list.do ; loop
  dw cr_
  dw semicolon_s_

; ----------------------------------------------
  _code_header page_,'PAG','E'

  push bc
  ; XXX OLD -- why open the channel?
  ;ld a,0x02
  ;call rom_chan_open
  call rom_cl_all
  ; XXX OLD -- why open the channel?
  ;ld a,0x02
  ;call rom_chan_open
  ; XXX TODO check the status of the printer
  pop bc
  _jp_next

; ----------------------------------------------
  _code_header bye_,'BY','E'

  ld (iy+sys_df_sz_offset),0x02 ; restore lines of the lower screen
  rst 0x08
  db 0x08 ; "STOP" BASIC error

; ----------------------------------------------
  _colon_header text_,'TEX','T'

  ; text  ( c "ccc<c>" -- pad len )
  ; Accept following text to `pad`. _c_ is the text delimiter.

  dw here_,c_slash_l_,one_plus_,blank_ ; fill the word buffer with blanks
  dw word_ ; XXX FIXME use `parse` when available
  dw here_ ; origin
  dw pad_ ; destination
  dw c_slash_l_,one_plus_ ; count
  dw cmove_
  dw pad_,count_
  dw semicolon_s_

; ----------------------------------------------
  _code_header two_drop_,'2DRO','P'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWA','P'

  ; Copied from DZX-Forth.
  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  jp push_de_hl

; ----------------------------------------------
  _colon_header unused_,'UNUSE','D'

  ; XXX TMP
  dw zero_,here_,minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header index_,'INDE','X'

  ; XXX TODO -- remove, already copied to the disk

  dw one_plus_
  dw swap_
  dw paren_do_
index.do:
  dw cr_,i_,three_,dot_r_,space_
  dw zero_,i_,dot_line_
  dw question_terminal_
  dw zero_branch_,index.loop
  dw leave_
index.loop:
  dw paren_loop_,index.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header where_,'WHER','E'

  ; XXX TODO -- remove; already copied to the disk
  ; XXX TODO -- in disk version: return if zero

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw semicolon_s_

where.do_it:
  dw dup_,b_slash_scr_,slash_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_,dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  dw c_lit_
  db '^'
  dw emit_
  dw semicolon_s_

; ----------------------------------------------
  _constant_header next_,'NEX','T'

  dw next

; ----------------------------------------------
  _constant_header pushhl_,'PUSHH','L'

  dw push_hl

; ----------------------------------------------
  _constant_header pushde_,'PUSHD','E'

  dw push_de_hl

; ----------------------------------------------
  _colon_header at_,'A','T'

; doc{

; : at ( line col -- )

; Adapted from Lennart Benschop's Spectrum Forth-83.

; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

  dw swap_,dup_
  dw c_lit_
  db 23
  dw not_equals_ ; not the last line?
  dw zero_branch_,at_pfa.last_line
  ; not the last line
  dw lit_,22,paren_emit_,paren_emit_,paren_emit_
  dw semicolon_s_

at_pfa.last_line:
  dw one_minus_,dup_,paren_emit_,paren_emit_,zero_,paren_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  dw c_lit_
  db 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header border_,'BORDE','R'

  pop hl
  ld a,l
  out(0xFE),a
  _jp_next

; ----------------------------------------------
  _code_header gover_,'GOVE','R'

  ld a,over_char
  jp color

; ----------------------------------------------
  _code_header flash_,'FLAS','H'

  ld a,flash_char
  jp color

; ----------------------------------------------
  _code_header inverse_,'INVERS','E'

  ld a,inverse_char
  jp color

; ----------------------------------------------
  _code_header bright_,'BRIGH','T'

  ld a,bright_char
  jp color

; ----------------------------------------------
  _code_header paper_,'PAPE','R'

  ld a,paper_char
  jp color

; ----------------------------------------------
  _code_header ink_,'IN','K'

  ld a,ink_char
color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or gover).
  ; a = attribute control char
  ; (tos) = color attribute value
  rst 0x10
  pop hl
  ld a,l
  rst 0x10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _code_header j_,'','J'

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  inc hl
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTAN','T'

  dw header_,smudge_
  dw here_,two_store_
  dw c_lit_
  db 0x04
  dw allot_
  dw paren_semicolon_code_
do_two_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header two_variable_,'2VARIABL','E'

  dw two_constant_
  dw paren_semicolon_code_
do_two_variable:
  jp do_variable

; ----------------------------------------------
  _colon_header u_dot_r_,'U.','R'

  dw to_r_,zero_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _code_header two_over_,'2OVE','R'

  ld hl,4
  add hl,sp
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header exit_,'EXI','T'

  dw r_drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exit_,'?EXI','T'

  dw question_branch_,exit_pfa
  dw semicolon_s_

; ----------------------------------------------
  _colon_header case_,'CAS','E',immediate
  ; XXX TODO move to the disk?

  dw question_comp_
  dw csp_,fetch_,store_csp_
  dw c_lit_
  db 0x04
  dw semicolon_s_

; ----------------------------------------------
  _colon_header of_,'O','F',immediate

  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,over_
  dw compile_,equals_
  dw compile_,zero_branch_
  dw forward_mark_
  dw compile_,drop_
  dw c_lit_
  db 0x05
  dw semicolon_s_

; ----------------------------------------------
  _colon_header endof_,'ENDO','F',immediate

  dw c_lit_
  db 0x05
  dw question_pairs_
  dw compile_,branch_
  dw forward_mark_
  dw swap_
  dw two_
  dw then_
  dw c_lit_
  db 0x04
  dw semicolon_s_

; ----------------------------------------------
  _colon_header endcase_,'ENDCAS','E',immediate

  dw c_lit_
  db 0x04
  dw question_pairs_
  dw compile_,drop_
endcase.compile_then:
  dw sp_fetch_,csp_,fetch_,equals_
  dw question_branch_,endcase.end
  dw two_,then_
  dw branch_,endcase.compile_then
endcase.end:
  dw csp_,store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header inkey_,'INKE','Y'
  ; XXX TODO move to the disk

  push bc
  call rom_key_scan
  ld c,0x00
  jr nz,l8128h
  call rom_key_test
  jr nc,l8128h
  dec d
  ld e,a
  call rom_key_decode
l8128h:
  ld l,a
  ld h,0x00
  pop bc
  jp push_hl

; ----------------------------------------------
  _colon_header char_,'CHA','R'

  dw b_l_,word_,here_,one_plus_,c_fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_char_,'[CHAR',']',immediate

  dw char_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_quote_,'S','"',immediate

  ; : s"  ( compilation: "ccc<">" -- ) ( run-time:  -- ca len )
  ;  [char] " (s)  ; immediate

  dw c_lit_
  db '"'
  dw paren_s_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_next_screen_,'?--','>',immediate

  dw zero_branch_,question_next_screen.end
  dw next_screen_
question_next_screen.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_backslash_,'?','\',immediate

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backslash_,'','\',immediate

  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw to_in_,plus_store_
  dw semicolon_s_

nfa_of_top_most_word_in_forth_voc:

; ----------------------------------------------
  _colon_header dot_paren_,'.','(',immediate

; doc{
; : .(  ( 'ccc<paren>' -- )
;   [CHAR] ) TEXT PAD COUNT TYPE  ; IMMEDIATE
; }doc

  dw c_lit_
  db ')'
  if 0 ; XXX OLD
    dw text_,type_
  else
    dw parse_,type_
  endif
  dw semicolon_s_

dictionary_pointer_after_cold:

end cold_entry

; ==============================================================
; Debug tools

  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER

