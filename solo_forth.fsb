( Solo Forth library )

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

\ This file is the library of Solo Forth,
\ and the skeleton to build applications in Solo Forth.

\ ------------------------------------------------------------
\ Acknowledgements

\ See the file <AKNOWLEDGMENTS.adoc>.

\ ------------------------------------------------------------
\ License

\ Copying and distribution of this file, with or without
\ modification, are permitted in any medium without royalty
\ provided the copyright notice, the aknowledgments file and
\ this notice are preserved.  This file is offered as-is,
\ without any warranty.

( ) \ scr 1 -- testing load screen

3 load
require decode
require dump
decode dump

( debugging ) \ scr 2


  \ }}} =======================================================
  \ Require {{{

( require ) \ scr 3

  \ This screen must be at a fixed location.

  \ 2015-06-04: Copied and modified from lina ciforth.
  \
  \ 2015-06-23: First tries.
  \
  \ 2015-06-25: Fix. The parsed strings had to be saved in the
  \ circular string buffer.
  \ 
  \ 2015-07-21: Change: renamed `(required)` as `do-required`.
  \ New: `do-require`. 

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
  \ Does the string ca1 len1 contains the string ca2 len2?

2variable locatable  scr/disk 1 locatable 2!

: located  ( ca len -- screen | false )
  locatable 2@ do
    0 i (line) 2over contains if  2drop i unloop exit  then
  loop  2drop false  ;

: locate  ( "name" -- screen | false )
  parse-word save-string located  ;

  \ cr ." (required) <" 2dup type [char] > emit  \ XXX INFORMER
: do-required  ( ca len -- )  located dup 0= 29 ?error load  ;

: required  ( ca len -- )
  2dup undefined? if  2dup do-required  then
  \ cr ." required <" 2dup type [char] > emit  \ XXX INFORMER
  2dup undefined? if  type 28 message exit  then  2drop  ;

: require  ( "name" -- )  parse-word save-string required  ;

: do-require  ( "name" -- )
  parse-word save-string do-required  ;

  \ }}} =======================================================
  \ Error messages {{{

( Error messages 1..15 ) \ scr 4

\ Error #1: Not a word nor a number.
\ Error #2: Stack empty.
  \ #03 not used:
\ Error #3: Dictionary full.
\ Error #4: Warning: Is not unique.
\ Error #5: Word not found.
  \ #06 not used:
\ Error #6: Out of disk range
\ Error #7: Full stack.
\ Error #8:
\ Error #9: Trying to load from screen 0.
\ Error #10:
\ Error #11:
\ Error #12:
\ Error #13:
\ Error #14:
\ Error #15: Deferred word is uninitialized.

( Error messages 16..30 )  \ scr 5

\ Error #16:
\ Error #17: Compilation only, use in definition.
\ Error #18: Execution only.
\ Error #19: Conditionals not paired.
\ Error #20: Definition not finished.
\ Error #21: In protected dictionary.
\ Error #22: Use only when loading.
\ Error #23: Off current editing screen.
  \ XXX TODO better text:
\ Error #24: Declare vocabulary.
  \ XXX TMP -- not used yet:
\ Error #25: Unsupported tape operation.
  \ XXX TMP -- not used yet:
\ Error #26: Unsupported disk operation.
\ Error #27: Source file needed.
\ Error #28: Warning: Not present, though required.
\ Error #29: Required, but not located.
  \ Assembler:
\ Error #30: Branch too long.

( debug ) \ scr 6 for debugging

( code ) \ scr 7 for debugging

forth definitions  vocabulary assembler

;s

  \ XXX TODO
  \ asm code end-code next, pushhl, pushde,


  \ }}} =======================================================
  \ String operations {{{

( parse-name place +place /string )

  \ 2015-06-17: Copied from Afera.

  \ XXX OLD -- 2015-06-20: `text` modified in the kernel to do
  \ this:
  \ : parse-text  ( c "ccc<c>" -- ca len )  text pad count  ;
  \ XXX OLD -- 2015-06-23: `parse-word` in the kernel:
  \ : parse-name  ( "name" -- ca len )  bl parse-text  ;

: place  ( ca1 len1 ca2 )  2dup c! 1+ smove  ;
: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;

: /string  ( ca1 len1 n -- ca2 len2 )
  dup >r - swap r> + swap  ;

( s' )

  \ 2015-06-17: Basic string support words copied from Afera.
  \
  \ 2015-06-20: All words but `s'` are moved to the kernel.

  \ doc{
  \
  \ s'  ( compilation: "text<'>" -- ) ( run-time:  -- ca len )
  \
  \ }doc

: s'  ( compilation: "ccc<'>" -- ) ( run-time:  -- ca len )
  [char] ' (s)  ; immediate

  \ }}} =======================================================
  \ Stack manipulation {{{

( -rot )

  \ 2015-06-05: Copied from Afera.

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,     \ pop hl / pop de
  E3 c,           \ ex (sp),hl
  EB c,           \ ex de,hl
  C3 c, pushde ,  \ jp pushde

  end-code

( 2nip )

  \ 2015-06-22: Copied from Afera; original code from
  \ DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,           \ pop hl
  D1 c,           \ pop de
  F1 c,           \ pop af
  F1 c,           \ pop af
  C3 c, pushde ,  \ jp pushde

end-code

  \ }}} =======================================================
  \ Graphics {{{

( pixel )

require pixel-addr

code pixel  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel in the byte address 0..7
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, pixel-addr ,      \ call pixel-addr
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushde ,          \ jp pushde
  end-code

( pixel-add )  \ The ROM routine \ XXX OLD

code pixel-add  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..175
  \ n = position of the pixel in the byte address 0..7
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, 22AA ,            \ call pixel-add ; ROM routine
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushde ,          \ jp pushde
  end-code

( pixel-addr )

  \ 2015-06-11: Written.
  \ 2015-06-20: `label` instead of `variable` and `-2 allot`.

label pixel-addr  ( -- )  hex
  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.
  \ Input:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  decimal

( point )

  \ 2015-06-04: Copied from Afera.
  \ 2105-06-11: Modified to use the whole screen.

require pixel-addr

code point  ( xc yc -- f )
  E1 c, D1 c, C5 c,       \ pop hl / pop de / push bc
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c,   \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate
  CD c, pixel-addr ,      \ call pixel-addr
  \ hl = screen address
  \ a = pixel position in hl
  40 07 + c,              \ ld b,a
  04 c,                   \ inc b
  7E c,                   \ ld a,(hl)
  \ rotate:
  07 c,  10 c, FD c,      \ rlca / djnz rotate
  E6 c, 01 c,             \ and 1
  \ finish:
  26 c, 00 c,  68 07 + c, \ ld h,0 / ld l,a
  C1 c,                   \ pop bc
  C3 c, pushhl ,          \ jp pushhl
  \ XXX TODO adapt when true=-1
  end-code

( plot )

  \ 2015-06-05: Copied from Afera.
  \ 2015-06-11: Modified to use the whole screen.
  \ 2015-07-04: Fix. The address into PLOT-SUB was wrong.

require pixel-addr

code plot  ( xc yc -- )

  D9 c,               \ exx
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c,   \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate

  ED c, 43 c, 5C7D ,   \ ld (0x5C7D),bc ; update COORDS
  CD c, pixel-addr ,  \ call pixel-addr
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; plot-sub + 7
  D9 c,               \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  DD c, E9 c,         \ jp (ix)

  end-code

( draw )

  \ XXX TODO

  \ Version of Spectrum Forth-83:

  \ CODE DRAW
  \   H POP
  \   B POP
  \   D PUSH
  \   1 E LD#
  \   7 B BIT
  \   NZ IF
  \     C A LD
  \     NEG
  \     -1 E LD#
  \     A C LD
  \   THEN
  \   1 D LD#
  \   L B LD
  \   7 H BIT
  \   NZ IF
  \     B A LD NEG
  \     -1 D LD#
  \     A B LD
  \   THEN
  \   24BA CALL
  \   D POP
  \   JPIX ;C

( attr )

code attr ( line col -- )

  \ Improved version of the ROM routine at 0x2583

  \ pop hl ; l = col
  \ pop de ; e = line
  E1 c,  D1 c,
  50 05 + c, \ ld d,l ; d = col

  78 02 + c, \ ld a,d  ; line to a 0x00..0x17   (max 00010111)
  0F c, 0F c, 0F c, \ rrca | rrca | rrca  ; rotate bits left
  50 07 + c, \ ld d,a ; store in d as an intermediate value.

  E6 c, E0 c, \ and 0xE0 ; pick up bits 11100000 (was 00011100)
  A8 02 + c, \ xor d ; combine with column 0x00..0x1F
  68 07 + c, \ ld l,a ; low byte now correct.

  78 02 + c, \ ld a,d ; bring back intermediate result from d

  \ and 0x03 ; mask to give correct third of screen
  \ xor 0x58 ; combine with base address.
  E6 c, 03 c,  EE c, 58 c,
  60 07 + c, \ ld h,a ; high byte correct.

  \ ld l,(hl) ; pick up the colour attribute.
  \ ld h,0
  \ jp pushhl
  6E c,  26 c, 00 c,  C3 c, pushhl ,

  end-code

( screen )

  \ XXX TODO -- rewrite after the planned method for a double
  \ character set: `ascii-printed`, `udg-printed` and its
  \ combination `printed`, or similar names. Modify the charset
  \ system variable.

code screen ( row col -- f )

  \ pop hl
  \ pop de
  \ push bc
  \ ld c,e
  \ ld b,l
  \ call rom_s_scrn_s_0x2538
  \ call rom_stack_fetch
  \ ld a,(de)
  \ ld h,0x00
  \ ld l,a
  \ pop bc
  \ ; XXX TODO -- check if necessary after those ROM routines:
  \ ld ix,next ; restore
  \ jp push_hl

end-code

  \ }}} =======================================================
  \ Sound {{{

( bleep )

  \ Code modified from Abersoft Forth:

code bleep  ( n1 n2 -- )
  \ Produce a tone in the noise maker.
  \ n1 = duration
  \ n2 = pitch
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5          \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  DD c, E9 c,         \ jp (ix)
  end-code

  \ Code from v.Forth, not tested:

: bleep-calc  ( freq duration -- n1 n2 )
  \ n1 = duration
  \ n2 = pitch
  OVER 1000 */ SWAP
  4375 100 ROT */ 30 -  ;

  \ }}} =======================================================
  \ Operators {{{

( within between )

: within  ( n1|u1 n2|u2 n3|u3 -- f )
  over - >r - r> u<  ;

: between  ( n1|u1 n2|u2 n3|u3 -- flag )
  over - -rot - u< 0=  ;

( d0= d0< d< du< dmin dmax )

: d0=  ( d -- f )  or 0=  ;

: d0<  ( d -- f )  nip 0<  ;

; d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;

: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;

: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;

( lshift )

  \ XXX TODO

code lshift  ( x1 u -- x2 )

  \ [Code from DZX-Forth.]

  \ pop de
  \ pop hl
  \ inc e
\ lshift_.1:
  \ dec e
  \ jp z,push_hl
  \ add hl,hl
  \ jp lshift_.1

end-code

( rshift )

  \ XXX TODO

code rshift  ( x1 u -- x2 )

  \ [Code from DZX-Forth.]

  \ pop de
  \ pop hl
  \ inc e
\ rshift_.1:
  \ dec e
  \ jp z,push_hl
  \ or a
  \ ld a,h
  \ call sra_hl.1 ; XXX TODO this is in the kernel
  \ jp rshift_.1

end-code

( Symmetric-division operators )

  \ [From the ANS Forth documentation.]

  \ XXX TODO `sm/rem` not ready yet

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( Floored-division operators )

  \ [From the ANS Forth documentation.]

  \ XXX TODO `fm/mod` not ready yet

: /_mod  ( n1 n2 -- n3 n4)  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3)  /_mod nip  ;

: _mod  ( n1 n2 -- n3)  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5)  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip ;

  \ }}} =======================================================
  \ Conditional compilation {{{

( [if] [else] [then] )

  \ 2015-06-04: Copied from Afera.
  \ 2015-06-25: Fully adapted.

[defined] s=  ?\  : s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

: [else]  ( "..." -- )

  1 begin   parse-word 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

  \ }}} =======================================================
  \ Tools {{{

( transient[ )

  \ 2015-07-16: Start adapting the code from Afera
  \
  \ XXX TODO -- Finish.

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  \ Start transient code, reserving u bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME changing `dp` crashes the system:

  0 swap - dp !  ;

: ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.

  old-dp @ dp !  old-np @ np !  ;

: -transient  ( -- )

  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.

  old-voc-link @ voc-link !

  \ Store the nfa of the latest word created before compiling
  \ the transient code, into the lfa of the first word created
  \ after the transient code was finished by `]transient`.

  \ XXX TODO

  old-latest @ old-np @ cfap>lfa !n  ;

( [false] [true] )

  \ 2015-06-17: Copied from Afera.

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( hex. hexb. dhex. hex{ )

  \ 2015-06-20: Adapted from lina (Copyright (c) 2000-2004
  \ Albert van der Horst, The Netherlands).

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: hex{  ( -- )  base @ base' ! hex ; \ switch to hex
: }hex  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  hex{ (d.) }hex type space  ;
: dhex.    ( d -- )  8 (dhex.)  ;
: hex.     ( n -- )  s>d 4 (dhex.)  ;
: hexb.    ( n -- )  s>d 2 (dhex.)  ;

( binary bin. binb. dbin. bin{ )

  \ 2015-06-22

[defined] base'  ?\ variable base'

base @ decimal
[defined] binary  ?\ : binary  ( -- )  2 base !  ;
base !

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: bin{  ( -- )  base @ base' ! binary ; \ switch to binary
: }bin  ( -- )  base' @ base !        ; \ and binary

: (dbin.)  ( d n -- )  bin{ (d.) }bin type space  ;
: dbin.    ( d -- )  32 (dbin.)  ;
: bin.     ( n -- )  s>d 16 (dbin.)  ;
: binb.    ( n -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  \ XXX TODO use `?do` instead of `if` when available
  dup if
    bounds do
      i c@ 127 and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

( dump )

require hex.  require ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: dump  ( a len -- )
  7 + -8 and 8 / 0
  \ XXX TODO use `?do` instead of `if` when available
  2dup <> if
    do
      cr dup hex.
      8 0 do  i over + @ flip hex.  2 +loop
      \ 16 0 do  i over + c@ hexb.  loop
      dup bs 8 ascii-type
      ?terminal if  exhaust  then
    8 + loop
  else  2drop  then  drop  ;

( decode -- variables, indentation and pause control )

  \ 2015-06-05: Copied from Afera.
  \ 2015-06-19: New: `?branch`.

forth definitions decimal

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent ;

-->

( decode -- special cases )

: decode-compile  ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal  ( a1 -- a2 )  2+ dup @ .  ;

: decode-branch  ( a1 -- a2 )  2+ dup @ u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode -- special cases dispatcher )

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-dot-quote  endof
  endcase  ;

-->

( decode -- checks of the main code )

: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] ;s =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  pfa>cfa @ ['] : @ =  ;

-->

( decode -- main code )

: (decode)  ( pfa --- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>cfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp0 sp! quit  endof \ q
                      bl  of  drop          endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode -- interface )

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined if  cfa>pfa  0 decode-level !  (decode)
          else  drop  5 error  then  ;

( list )

: list  ( n -- )

  \ List screen number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    ?terminal if  exhaust  then
  loop cr  ;

( index )

: index  ( n1 n2 -- )
  1+ swap do
    cr i 3 .r space 0 i .line
    ?terminal if  exhaust  then
  loop  ;

( words )

  \ [Code adapted from Spectrum Forth-83.]

[defined] tab ?\  : tab  ( -- )  6 emit  ;

: words  ( -- )
  trail
  begin  dup 0<> ?terminal 0= and  while
    dup id. tab  nfa>lfa @n
  repeat drop ;

( words-like )

  \ [Code adapted from pForth.]

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string ca1 len1 contains the string ca2 len2?

[defined] tab
  ?\  : tab  ( -- )  6 emit  ;

  \ XXX FIXME

: words-like  ( "name" -- )
  \ Print all words containing substring.
  parse-word 2dup uppers trail  ( ca len nfa )
  begin  dup 0<> ?terminal 0= and  while
    dup >r
    nfa>string 2over 2swap contains if  r@ id. tab  then
    r> nfa>lfa @n
  repeat drop 2drop  ;

( where )

: where  ( -- )
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup b/scr / dup scr !
    ." Scr # " decimal . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s )

  \ 2015-06-22: Copied from Afera. The algorithm
  \ was taken from v.Forth.

: .s   ( -- )
  depth
  dup s>d <# [char] > hold #s [char] < hold #> type space
  if  sp@ 2- s0 @ 2- do i @ . -2 +loop  then  ;

( forget )

  \ XXX OLD -- obsolescent word

: forget  ( "name" -- )
  current @ context @ <>   \ Compare `current` with `context`.
  24 ?error                \ If not the same, issue an error.
  '                        \ Locate "name", return its cfa.
  dup fence @ u<           \ Below `fence`?
  21 ?error                \ If so, issue an error.
  dup  ( cfa cfa )
  cfa>nfa dp !             \ Update the dictionary pointer.
  cfa>lfa @ current @ !    \ Update the `current` vocabulary.
  ;

  \ }}} =======================================================
  \ XXX Misc {{{

( source )

: source  ( -- ca len )  \ ANS Forth
  \ XXX TODO
  blk @ ?dup if  block b/buf  else  tib @ #tib @  then  ;

  \ }}} =======================================================
  \ Hardware {{{

( @p )

code @p  ( u -- n )

  \ Return the value read from port _u_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 78 c,     \ in a,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  68 07 + c,      \ ld l,a
  C3 c, pushhl ,  \ jp pushhl
end-code

( !p )

code !p  ( n u -- )

  \ Present _n_ to output port _u_.

  E1 c,           \ pop hl
  D1 c,           \ pop de
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  78 03 + c,      \ ld a,e
  ED c, 79 c,     \ out (c),a
  C1 c,           \ pop bc
  DD c, E9 c,     \ jp (ix)

end-code

  \ }}} =======================================================
  \ Turnkey {{{

( extend size system turnkey )

  \ XXX WARNING -- Since name field addresses are saved in a
  \ memory bank, the best way to save a modified Forth system
  \ is to make a snapshot with the ZX Spectrum emulator;
  \ otherwise a multipart saving and loading would be needed.
  \ Anyway, these words are meant to save a Forth program, not
  \ the Forth system.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ the assembled code.

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 22  +origin !  \ `fence` init value \ XXX OLD obsolete
  here 24 +origin !   \ `dp` init value
  \ XXX TODO -- update also the names pointer
  here fence ! \ XXX OLD obsolete
  \ `voc-link` init value:
  [ ' forth cfa>pfa 8 + ] literal 26 +origin !  ;

  \ size  ( -- u )
  \
  \ Size of the system.

: size  ( -- u )  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.

: system  ( -- a len )  extend  0 +origin size 10 + ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.

: turnkey  ( cfa -- a len )  boot ! system  ;

  \ }}} =======================================================
  \ Number notation {{{

( c>hex )

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex

: c>hex  ( c -- n )
  \ Convert a character to its hexadecimal value.
  30 - dup 9 > if  7 -  then  ;

decimal

( '. ) \ character prefix

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 1 width !

: '.  ( -- n )
  \ leave ascii character; example: 'a leaves 0x41
  here 2 + c@ postpone literal  ; immediate

width ! decimal

( $.. $.... ) \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

width @  1 width !

: $..  ( -- n )
  \ leave hex number; example: $0a leaves 0x0A
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: $....  ( -- n )
  \ leave 16-bit hex number; example: $0aff leaves 0x0AFF
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( 0x.. 0x.... )  \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 2 width !

: 0x..  ( -- n )
  \ leave hex number; example: 0x0a
  here 3 + c@ c>hex 10 * here 4 + c@ c>hex +
  postpone literal  ; immediate

: 0x....  ( -- n )
  \ leave hex number; example: 0x0aff
  0 here 7 + here 3 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( #... #..... ) \ hex prefixes

  \ Inspired by code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX TODO

width @  1 width !

: #...  ( -- n )
  \ leave decimal number
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: #.....  ( -- n )
  \ leave 16-bit decimal number
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

  \ }}} =======================================================
  \ Control structures {{{

( i' )

code i'  ( -- x ) ( R: loop-sys -- loop-sys ) \ ANS Forth

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,  \ ld hl,(return_stack_pointer)
  23 c,       \ inc hl
  23 c,       \ inc hl
  C3 c, fetchhl , \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 3 cells , \ ld de,3*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( case: associative: )

  \ [Code adapted from F83.]
  \
  \ XXX TODO document

: case:  ( n -- )
  create  1+ cells , ]
  does>   dup @ + perform  ;

: associative:  ( n -- )
  constant
  does>
    dup @ -rot dup @ 0 do
      cell+ 2dup @ =
      if  2drop drop i unloop exit   then
    loop 2drop  ;

( Abersoft Forth case )

  \ This is the `case` provided by Abersoft Forth. It's too
  \ complex and not ANS Forth compliant.

  \ XXX TODO document

: case  ( x -- )
  ?comp csp @ !csp 4  ; immediate
: of  ( x -- )
  4 ?pairs
  postpone over  postpone =  postpone 0branch >mark
  postpone drop 5  ; immediate
: endof  ( -- )
  5 ?pairs
  postpone branch  >mark
  swap 2  postpone then  4  ; immediate
: endcase  ( -- )
  4 ?pairs
  postpone drop
  begin  sp@ csp @ =  while  2 postpone then  repeat
  csp !  ;  immediate


( ?dov dov loopv +loopv )

  \ [Code from vForth.]

  \ XXX TODO adapt

: dov  compile (do) csp @ !csp here 3 ;

: ?dov
  compile 2dup  compile (do)  compile <>
  postpone if
  2drop here swap 1 6  ; immediate

: (resolve)
  begin  sp@ csp @ -  while  2 postpone then  repeat  csp !  ;

: loopv
  postpone loop (resolve)  ;

: +loopv
  postpone +loop (resolve)  ;

( compile, )

  \ [Code from v.Forth.]

: compile,  ( cfa -- )  ?comp , ;

  \ }}} =======================================================
  \ Time {{{

( ms )

  \ 2015-06-10: Copied from Afera.

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( n -- )
  \ Wait n ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ XXX TODO
  \ Adapth this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  b0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2b c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3e c, 00 c,  78 05 + c,  b0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1b c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( frames@ frames! frames0 )

  \ 2015-06-10: Copied from Afera.
  \ 2015-07-17: Renamed all words.

[defined] sys-frames ?\ 23672 constant sys-frames

: frames@  ( -- d )
  sys-frames @ [ sys-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ sys-frames 2+ ] literal c! sys-frames !  ;
  \ Set the system frames counter.

: frames0  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

  \ }}} =======================================================
  \ Vocabularies {{{

( root ) \ XXX from F83

  \ XXX TODO This code from F83 seems simpler to adapt than the
  \ code from the Forth-83 Standard.

  \ 2015-07-22: Start.  Copied from F83. First changes to adapt
  \ it.

  \ XXX TMP
  \ ' forth cfa>pfa context cell+ !
  \ Put `forth` as the second vocabulary in the search order.

  \ cr .( XXX 0) .s key drop \ XXX INFORMER

  \ Get the cfa of the null word, in order to redefine it in
  \ the root vocabulary.  If not found, error (should not
  \ happen).

vocabulary root  root definitions
  \ A small vocabulary for controlling search order.

  \ XXX FIXME with `rdrop`, the compilation crashes the system.

  \ XXX FIXME without `rdrop`, everything seems fine except
  \ `forth` crashes the system.

forth
: x  ( -- ) ( compiling: cfa -- )
  \ XXX FIXME
  rdrop
  \ branch [ 1 pad ! pad find 0= 4 ?error cfa>pfa , ]
  [ 1 pad ! pad find 0= 4 ?error , ]
  ; immediate  root
  \ Define an alias of the null word with a temporary name "x".
  \ `rdrop` unnests one level, else the null word would fail.
  \ `branch` is used to jump directly to the pfa of the null
  \ word, therefore without adding a nesting level.  `pad` is
  \ used to store the name of the null word to find, as a
  \ counted string (a string with only a null char). `forth`
  \ has to be the `context` vocabulary before the `find`.
  \ `root` is restored at the end.

  \ XXX TODO `forth` is not needed in `x`, because the kernel
  \ provides `forth` as the second vocabulary in the search
  \ order.

  0 ' x cfa>nfa 1+ c!n
  \ Rename `x` to its actual name: Overwrite the "x" with a
  \ zero.

( also )

root definitions forth

: also  ( -- )
  context dup cell+ [ #vocs 2- cells ] literal cmove>  ;
  \ Duplicate the vocabulary at the top of the search order.

  \ cr .( XXX 2) .s key drop \ XXX INFORMER

( only seal previous )

root definitions forth

: -order  ( -- )  context [ #vocs cells ] literal erase  ;
  \ Erase the search order.

: only  ( -- )  -order root also  ;
  \ Erase the search order and forces the `root` vocabulary to
  \ be the first and second.

: seal  ( -- )  context @ -order context !  ;
  \ Change the search order such that only the vocabulary at
  \ the top of the search order will be searched.

: previous  ( -- )
  context dup cell+ swap [ #vocs 2- cells ] literal cmove
  context [ #vocs 2- cells ] literal + off  ;
  \ Remove the most recently referenced
  \ vocabulary from the search order.

  \ cr .( XXX 3) .s key drop \ XXX INFORMER

( forth definitions )  \ XXX from F83

  \ cr .( XXX 3a) .s key drop \ XXX INFORMER
: forth  ( -- )  forth  ;
  \ cr .( XXX 3b) .s key drop \ XXX INFORMER
: definitions  ( -- )  definitions  ;

  \ cr .( XXX 4) .s key drop \ XXX INFORMER

( order )  \ XXX from F83

: order  ( -- )
  cr ." context: "  context #vocs 0 do
                      dup @ ?dup if  pfa>nfa id.  then  cell+
                    loop drop
  cr ." current: "  current @ pfa>nfa id.  ;
  \ Display the search order currently in effect.  Also display
  \ the `current` vocabulary, which is were definitions are
  \ placed.

( vocs )  \ XXX from F83

: vocs  ( -- )
  voc-link @
  begin  dup cell - pfa>nfa id.  @ dup 0= until  drop  ;
  \ List all of the vocabularies that have been defined so
  \ far, in the order of their definition (more recent first).

  \ only forth also definitions

( Forth-83 also only )

  \ Copied from the FORTH-83 Standard, a publication of the
  \ FORTH Standars Team (1983-03)
  \
  \ Original code by William F. Ragsdale, 1982-06-12.
  \
  \ 2015-04-17: Start.

  \ 2015-07-22: This code from seems harder to adapt
  \ than the code from F83.

  \ note the systems -FIND searches 1 to 5 vocabs in CONTEXT

vocabulary only  only definitions

: also  ( -- )  context dup cell+ 6 cmove>  ;
  \ Slide transient into resident.

  \ Alter run time of ONLY from usual vocabulary.

here cell+
  ] does>  context 8 erase  dup context !  context 8 + !
           also  exit [  ' only cfa !

: x  ( -- )  exit  ;  hex a080 decimal ' x nfa !  immediate
  \ Make NULL word.

: forth        ( -- )  forth  ;
: definitions  ( -- )  definitions  ;
: forget       ( "name" -- )  forget  ;
: vocabulary   ( "name" -- )  vocabulary  ;
: only         ( -- )  only  ;
: words        ( -- ) words  ;

( Forth-83 order )

: order  ( -- )
  \ Show the search order.
  context 10 bounds
  do  i @ -dup if  id.  else  exhaust  then  2 +loop
  10 spaces  current @ id.  ;

only forth also   definitions

  \ }}} =======================================================
  \ Random number generator {{{

( seed rnd random randomize )

  \ [Code adapted from Leo Brodie's code and Gforth.]

23672 constant seed  \ address of system variable

: rnd  ( -- n )  seed @ 31421 * 6927 + dup seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

: randomize  ( n -- )  seed !  ;

  \ From vForth
  \ XXX TODO adapt and try
  \ : vrnd  ( n1 -- n2 )
  \   1+ 8195 23672 @ um* 1 0 d+
  \   16383 u/ drop dup sys-seed !
  \   swap mod ;

  \ }}} =======================================================
  \ Deferred words {{{

( defer defer@ defer! defers action-of )

  \ [Code adapted from the Afera library.]

: (defer)  ( -- )
  \ Default behaviour of an uninitialized deferred word: error.
  15 error ;

: defer  ( "name" -- )
  \ Create a deferred word.
  postpone : postpone (defer) postpone ;  ;

: defer@  ( cfa1 -- cfa2 )
  \ Return the cfa of the word currently associated with a deferred word.
  \ cfa1 = cfa of the deferred word
  \ cfa2 = cfa of the word it's associated with
  cfa>pfa @  ;

: defer!  ( cfa1 cfa2 -- )  cfa>pfa !  ;

: defers  ( "name" -- )
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  ' defer@ ,  ; immediate

: action-of  ( Interpretation: "name" -- cfa )
             ( Compilation:    "name" -- )
             ( Runtime:        -- cfa )
  \ Return the code field address of a deferred word.
  ' comp? if    postpone literal postpone defer@
          else  defer@  then  ; immediate

( <is> [is] is  )

  \ [Code adapted from the Afera library.]

: <is>  ( cfa "name" -- )  ' defer!  ;

: [is]  ( cfa "name" -- )
  ' postpone literal postpone defer!  ; immediate

: is  ( cfa "name" -- )
  comp? if  postpone [is]  else  <is>  then  ; immediate

  \ }}} =======================================================
  \ Assembler {{{

( assembler )

\ Assembler for Solo Forth

\ Copyright (C) 1988? Coos Haak
\ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).

  \ It was ported to the fig-Forth Afera library by Marcos Cruz
  \ (2015-03).

  \ -----------------------------------------------------------
  \ Differences from the original version

  \ Also the pair registers BC, DE and HL can be used.
  \ Example: both `1 B LDP#` and `1 BC LDP#` are valid.

  \ `(HL)` can be used instead of `M`.

  \ Special mnemonic `0OUTBC` is provided.

  \ The condition flag operator `NOT` is removed; the condition
  \ flag `v` is removed. The condition flags are completed,
  \ including their opposite versions.

  \ Changed names:
  \ `INC` --> `INCP`;
  \ `INR` --> `INC`;
  \ `DEC` --> `DECP`;
  \ `DER` --> `DEC`.
  \ `TST` --> `TSTP`.

  \ The set of conditional calls and returns has been completed
  \ (the original included only the generic `CALLC` and
  \ `RETC`).

  \ Added many stack comments.

  \ Case insensitive.

  \ -----------------------------------------------------------
  \ History

  \ 2015-07-04: Copied from the Afera library.
  \
  \ 2015-07-05: First changes to convert it from fig-Forth to
  \ Solo Forth.
  \
  \ 2015-07-17: First documentation of control structures.
  \ Renamed `tst` as `tstp`. Changed control structures to use
  \ `>mark`, `>resolve`, `<mark`, `<resolve` and the new words
  \ `>relmark` and `>relresolve`.
  \
  \ 2015-07-21: Fix: The hex number DE, used to define a
  \ opcode, was mistaken as the DE register. '0DE' is used
  \ instead. Fix: a `variable` definition had its init value.
  \ Check: the assembler occupies 1565 bytes.

  \ -----------------------------------------------------------

forth definitions

: 8*   ( n1 -- n2 )  2* 2* 2* ;

-->

( assembler -- Registers )

: [assembler]  ( -- )  assembler  ; immediate

assembler definitions hex

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

  \ XXX TODO -- remove ?
0 constant bc  2 constant de  4 constant hl  6 constant (hl)

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

variable xy  ix-op xy !
: %x  ( -- )  ix-op xy ! ;    : %y  ( -- )  iy-op xy ! ;

: xy,  ( -- )  xy @ c, ;

: xl  xy, l ;         : xh  xy, h ;
: ix  ix-op c, hl ;   : iy  iy-op c, hl ;

  \ Branch too long?
: ?page  ( n -- n )  dup 80 + FF swap u< 1E ?error  ;

-->

( assembler -- Words for defining the z80 instructions)

: m1  ( n "name" -- )
  \ 1-byte opcode without parameters.
  create c, does> c@ c, ;

: m2  ( n "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does> c@ + c, ;

: m3  ( n "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does> c@ swap 8* + c, ;

: m4  ( n "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does> c@ c, c, ;

: m5  ( n "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does> c@ c, , ;

: m6  ( n "name" -- )
  \ Rotation of registers.
  create c, does> CB c, c@ + c, ;

  -->

( assembler -- Words for defining the z80 instructions)

: m7  ( n "name" -- )
  \ Bit manipulation of registers.
  create c, does> CB c, c@ + swap 8* + c, ;

: m8  ( n "name" -- )
  \ 2-byte opcodes.
  create , does> @ , ;

: m9  ( n "name" -- )
  \ Relative jumps.
  create c, does> c@ c, here 1+ - ?page c, ;

: ma  ( n "name" -- )
  \ Index registers with register.
  create c, does> xy, c@ c, c, ;

: mb  ( n "name" -- )
  \ Rotation with index registers.
  create c, does> xy, CB c, c@ swap c, c, ;

: mc  ( n "name" -- )
  \ Bit manipulation with index registers.
  create c, does> xy, CB c, c@ rot rot c, 8* + c, ;

  -->

( assembler -- Opcodes )

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ldap 0B m3 decp 0F m1 rrca
10 m9 djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl
27 m1 daa 28 m9 jrz 2A m5 ldhl 2F m1 cpl 30 m9 jrnc 32 m5 sta
37 m1 scf 38 m9 jrc 3A m5 lda 3F m1 ccf 76 m1 halt 80 m2 add
88 m2 adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz
C3 m5 jp C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz
CD m5 call CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc
D6 m4 sub# D9 m1 exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc#
E2 m5 jppo E3 m1 exsp E6 m4 and# E9 m1 jphl EA m5 jppe
EB m1 exde EE m4 xor# F2 m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp
FA m5 jpm FB m1 ei FE m4 cp# 00 m6 rlc 08 m6 rrc 10 m6 rl
18 m6 rr 20 m6 sla  28 m6 sra 38 m6 srl  40 m7 bit 80 m7 res
C0 m7 set B0ED m8 ldir B8ED m8 lddr 44ED m8 neg 57ED m8 ldai
47ED m8 ldia 56ED m8 im1 5EED m8 im2 B1ED m8 cpir         -->

( assembler -- Opcodes)

: 0outbc  ED c, 71 c, ;
: jpix  ix-op c, jphl ;
: ldp#  ( 16b rp -- ) 8* 1+ c,  , ;
: ldix#  ( 16b rp -- ) 8* 1+ c,  , ; \ xxx todo
: ld#  ( 8b r -- ) 8* 06 + c, c, ;
: ld  ( r1 r2 -- ) 8* 40 + + c, ;
: sbcp  ED c, 8* 42 + c, ;
: adcp  ED c, 8* 4A + c, ;
: stp  ED c, 8* 43 + c, , ;
: ldp  ED c, 8* 4B + c, , ;

  \ Macros

: clr  0 swap ldp# ;
: mov  2dup ld 1+ swap 1+ swap ld ;

  \ zx Spectrum specific

CF m4 hook \ rst 8
D7 m1 prt  \ rst 0x16

-->

( assembler -- Index register opcodes)

86 ma )add 8E ma )adc 96 ma )sub 9E ma )sbc A6 ma )and
AE ma )xor B6 ma )or  BE ma )cp  34 ma )inc 35 ma )dec
06 mb )rlc 0E mb )rrc 16 mb )rl  1E mb )rr  26 mb )sla
2E mb )sra 3E mb )srl 46 mc )bit 86 mc )res C6 mc )set

: )ld  xy, swap 8* 46 + c, c, ;
: )st  xy, swap 70 + c, c, ;
: )ld# xy, 36 c, c, c, ;
: )ldp  over 1+ over )ld 1+ )ld ;
: )stp  over 1+ over )st 1+ )st ;

-->

( assembler -- Condition codes, conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c, ;

  \ XXX TODO -- remove?
: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, , ;

  \ XXX TODO -- remove?
: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call ;

-->

( assembler -- Control structures built with relative jumps)

  \ XXX TODO document

  \ Forward relative mark.
: >relmark  ( -- orig )  here 1- ;
: >relresolve  ( orig dest -- ) over - ?page swap c! ;
: then  ( orig cs-id -- )  0A ?pairs >relmark >relresolve ;
: if  ( op -- orig cs-id )  , >relmark 0A ;
: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A ;
: begin  (  -- dest cs-id )  <mark 0B ;
: while  (  op -- orig cs-id )  if 2+ ;
: until  (  dest cs-id op -- )
  , 0B ?pairs 1- >relmark swap >relresolve ;
: again  (  dest cs-id -- )  18 until ;
: dsz    ( dest cs-id -- )  10 until ;
: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then ;

-->

( assembler -- Control structures built with absolute jumps )

  \ XXX TODO document

: then'  (  orig cs-id -- )  08 ?pairs >resolve ;
: if'  (  op -- orig cs-id )  c, >mark 08 ;
: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08 ;
: begin'  (  -- dest cs-id )  <mark 09 ;
: while'  (  op -- orig cs-id )  if' 2+ ;
: until'  (  cs-id op -- )  c, 09 ?pairs <resolve ;
: again'  (  cs-id -- )  C3 until' ;
: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then' ;

-->

( assembler -- Last opcodes and macros)

  \ `AND`, `OR` and `XOR` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or ;

  \ Patch `asm` with `%x`:
' %x ' asm cfa>pfa !

forth definitions

  \ Macros \ xxx todo -- test it
: macro  ( "name" -- )  asm postpone :  ;
: endm  ( -- )  postpone ;  ;

decimal

  \ }}} =======================================================
  \ The address register {{{

( a-register )

  \ Address register store and fetch words.
  \
  \ Sadly, there aren't any spare registers to make this as
  \ efficient as it could be. However, it can still give a
  \ useful improvement in loops, and in many cases also results
  \ in cleaner-looking code.

  \ Original code from Z88 CamelForth by Gary Lancaster.

  \ 2015-07-20: Start. Adapted the defining words.
  \ 2015-07-21: Start. Adapted the assembler.

hex

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,                 \ pop hl
  22 c, a ,             \ ld (a),hl
  DD c, E9 c,           \ jp (ix)
end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,             \ ld hl,(a)
  C3 c, pushhl ,        \ jp pushhl
end-code  -->

( a-register )

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,                          \ pop de
  2A c, a ,                      \ ld hl,(a)
  70 03 + c,  23 c,  70 04 + c,  \ ld (hl),e  inc hl  ld (hl),d
  DD c, E9 c,                    \ jp (ix)
end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,             \ ld hl,(a)
  5E c,                 \ ld e,(hl)
  23 c,                 \ inc hl
  66 c,                 \ ld h,(hl)
  68 03 + c,            \ ld l,e
  C3 c, pushhl ,        \ jp pushhl
end-code  -->

( a-register )

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  DD c, E9 c,           \ jp (ix)
end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
end-code  -->

( a-register )

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,             \ ld (a),hl
  DD c, E9 c,           \ jp (ix)
end-code

code @a+  ( -- u )
  \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  DD c, E9 c,    \ push de  jp (ix)
end-code  -->

( a-register )

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,             \ ld (a),hl
  DD c, E9 c,           \ jp (ix)
end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,                 \ push de
  DD c, E9 c,           \ jp (ix)
end-code  decimal

  \ }}} =======================================================
  \ Common heap {{{

( heap )

  \ An implementation of the ANS Forth Memory-Allocation Word
  \ Set.

  \ Adapted from code written by Gordon Charlton, 1994:
  \
  \ XXX TODO adapt

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, ALLOCATE, FREE,
  \ and RESIZE which give the minimum functionality required to
  \ use the heap. These are given in areas 3, 4 and 5
  \ respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant HEAPSIZE. The constant HYSTERESIS
  \ controls the amount of spare space that is added to an
  \ allocation, to reduce the need for block moves during
  \ resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

forth definitions
vocabulary heap-voc
heap-voc definitions

  \ **1** General Purpose Extensions

: unique (  )  VARIABLE ;

  \ Defining word. Each child returns a different non-zero
  \ number. The standard introduces the need for unique
  \ identifiers in the form of IORs and THROW codes, but
  \ provides no means for generating them. This does the trick.

0 1 2 UM/MOD NIP 1- CONSTANT maxpos

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  ---  Constants

256 CELLS CONSTANT heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 CELLS 1- CONSTANT hysteresis

  \ Node lengths are rounded up according to the value of
  \ HYSTERESIS to reduce the number of block moves during
  \ RESIZE operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

unique allocationerror

  \ Indicates there is less contiguous heap space available
  \ than required.

3 CELLS CONSTANT headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis OR  1+ ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize CONSTANT overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  ---  Structure

CREATE sentinel  HERE CELL+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

CREATE heap  heapsize ALLOT

  \ The heap is as described in HEADSIZE.

VARIABLE nextnode  -->

  \ Searching is done using a "nextfit" algorithm. NEXTNODE
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr -- addr)  CELL+ ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr -- addr)  2 CELLS + ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )  heap DUP nextnode !
      DUP DUP !
      DUP heapsize  OVER >size !
      >prev ! ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does NEXTNODE.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  ---  List Searching

: attach ( addr)  >prev @
      DUP sentinel ROT !
      sentinel >prev ! ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (addr) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
    >R BEGIN 2@ SWAP R@ < INVERT UNTIL
    R> DROP  >prev @ ;

  \ Search the nodelist, starting at the node specified (addr),
  \ for a free node larger than or equal to the specified size.
  \ Return the address of the first node that matches, or zero
  \ for no match. The heap structure is set up to make this a
  \ near optimal search loop. The "size" field is next to the
  \ "next" field so that both can be collected in a single
  \ operation (2@). Nodes in use have negated sizes so they
  \ never match the search. The "previous" field is included to
  \ allow the search to overshoot the match by one node and
  \ then link back outside the loop, rather than remembering
  \ the address of the node just examined. The sentinel removes
  \ the need for a separate test for failure. SEARCH assumes
  \ the sentinel is in place.

: detach ( addr)  DUP >prev @ ! ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           DUP      attach
           DUP ROT  search
           SWAP     detach ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ NEXTNODE, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  ---  Head Creation

: fits ( size addr -- flag)  >size @ SWAP -  overhead  < ;

  \ Returns TRUE if the size of the node specified is the same
  \ as the specified size, or larger than it by less than the
  \ size of the smallest possible node. Returns FALSE
  \ otherwise.

: togglesize ( addr)  >size DUP @  NEGATE SWAP ! ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode ! ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)  2DUP + >R
           >size 2DUP @ SWAP -
           R@ >size !
           SWAP NEGATE SWAP !  R> ;

  \ Given a free node (addr), reduce its size to that specified
  \ and mark it as in use. Start to construct a new node within
  \ the specified node beyond its new length, by storing the
  \ length of the remainder of the node in the size field of
  \ the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)  2DUP SWAP @  2DUP  SWAP !  >prev !
              2DUP >prev !   SWAP ! ;


  \ Addr1 is an existing node. Addr2 is the address of a new
  \ node just above the existing node. Break the links from the
  \ existing node to the next node and from the next node to
  \ the existing node and join the new node to them.


  \ ANSI heap  ---  Node Construction  ALLOCATE

: newnode ( size addr)  TUCK sizes!  links! ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)  2DUP fits IF  togglesize DROP
         ELSE  newnode
         THEN ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

FORTH-WORDLIST SET-CURRENT
: ALLOCATE ( u -- addr ior)
    DUP 0< IF  allocationerror
         ELSE  adjustsize
         DUP findspace
         DUP IF  DUP next!
           TUCK makenode
           headsize +  0
           ELSE  DROP allocationerror
           THEN
         THEN ;
MEMORY-ALLOC-WORDLIST SET-CURRENT  -->

  \ Make an in-use node with a data field at least u address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and an ior equal to the
  \ constant ALLOCATIONERROR. The standard specifies that the
  \ argument to ALLOCATE is unsigned. As the implementation
  \ uses the sign bit of the size field for its own purposes
  \ any request for an amount of space greater than MAXPOS must
  \ fail. As this would be a request for half the addressable
  \ memory or more this is not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  ---  Head Destruction

: mergesizes ( addr addr)
       >size @ SWAP >size +! ;

  \ Make the size field of the node at addr1 equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at addr2 will be the one immediately above addr1.

: mergelinks ( addr addr)
       @ 2DUP SWAP !
       >prev ! ;

  \ The node at addr2 is removed from the node list. As with
  \ MERGESIZES the node at addr2 will be immediately above that
  \ at addr1. Destroy the link from node1 to node2 and relink
  \ node1 to the node above node2. Destroy the backward link
  \ from the node above node2 and relink it to node1.

: jiggle (  )
   nextnode @ @  >prev @  next! ;

  \ There is a possibility when a node is removed from the node
  \ list that NEXTNODE may point to it. This is cured by making
  \ it point to the node prior to the one removed. We do not
  \ want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically NEXTNODE is set to point
  \ to the node pointed to by the "previous" field of the node
  \ pointed to in the "next" field of the node pointed to by
  \ NEXTNODE. Ordinarily this is a no-op (ie I am my father's
  \ son) but when the node has had its links merged it sets
  \ NEXTNODE to point to the node prior to the node it pointed
  \ to (ie when I died my father adopted my son, so now my son
  \ is my father's son).

: merge ( addr)
  DUP @ 2DUP mergesizes
       mergelinks  jiggle ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  ---  Node Removal    FREE

: ?merge ( addr1 addr2)  >size @
       0> IF  DUP DUP @
        U< IF  DUP merge
           THEN
          THEN  DROP ;  -->

  \ Merge the node at addr1 with the one above it on two
  \ conditions, firstly that the node at addr2 is free, and
  \ secondly that the node pointed to by the next field in
  \ addr1 is actually above addr1 (ie that it does not wrap
  \ around because it is the topmost node). In usage addr2 will
  \ be either addr1 or the node above it. In each instance the
  \ other affected node (either the node above addr1 or addr1)
  \ is known to be free, so no test is needed for this.

( heap )

: ?mergenext ( addr)  DUP @ ?merge ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ DUP ?merge ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

FORTH-WORDLIST SET-CURRENT
: FREE ( addr -- ior)  headsize -
         DUP togglesize
         DUP ?mergenext
         ?mergeprev  0 ;
MEMORY-ALLOC-WORDLIST SET-CURRENT

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  ---  Node Repairing

VARIABLE stash

  \ The RESIZE algorithm is simplified and made faster by
  \ assuming that it will always succeed. STASH holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash ! ;

  \ Saves the contents of the >NEXT field of the node being
  \ RESIZEd in STASH (above).

: restorelink ( addr)  stash @  SWAP ! ;

  \ Converse operation to SAVELINK (above).

: fixprev ( addr)  DUP >prev @ ! ;

  \ The >NEXT field of the node prior to the node being RESIZEd
  \ should point to the node being RESIZEd. It may very well do
  \ already, but this makes sure.

: fixnext ( addr)  DUP @ >prev ! ;

  \ The >PREV field of the node after the node resized may need
  \ correcting.  This corrects it whether it needs it or not.
  \ (Its quicker just to do it than to check first.)

: fixlinks ( addr)  DUP fixprev  DUP fixnext  @ fixnext ;

  \ RESIZE may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of JIGGLE (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)  DUP >size @ 0>
       IF  DUP @  2DUP <
           IF  OVER - SWAP >size !
         ELSE 2DROP
         THEN
     ELSE  DROP
     THEN ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the >NEXT field provided that
  \ the node is free and it is not the topmost node in the heap
  \ (ie there is no wraparound). Both these conditions need to
  \ be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  DUP fixsize  >prev @ fixsize ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to RESIZE (damaged by ?MERGENEXT)
  \ and its predecessor (damaged by ?MERGEPREV).

: repair ( addr)  DUP restorelink
      DUP fixlinks  DUP fixsizes
      togglesize ;

  \ Make good the damage done by RESIZE. Restore the >next
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer NEXTNODE may
  \ have moved back one or two nodes by virtue of having been
  \ JIGGLEd about if it happened to be pointing to the wrong
  \ node. This is not serious, so I have chosen to ignore it.


  \ ANSI Heap  ---  Node Movement

: toobig? ( addr size -- flag)
    SWAP  >size @  > ;

  \ Flag is true if the node at addr is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
       OVER >size @  headsize -
       ROT  headsize + ROT ROT MOVE ;

  \ Move the contents of the data field of the node at addr1 to
  \ the data field at addr2. Assumes addr2 is large enough. It
  \ will be.

: enlarge ( addr1 size -- addr2 ior)
    OVER  ?mergeprev
    ALLOCATE DUP >R
    IF  SWAP repair
  ELSE  TUCK copynode
  THEN R> ;

  \ Make a new node of the size specified. Copy the data field
  \ of addr1 to the new node. Merge the node at addr1 with the
  \ one preceding it, if possible. This last behaviour is to
  \ finish off removing the node at addr1. The word ADJUST
  \ (below) starts removing the node. The node is removed
  \ before allocation to increase the probability of ALLOCATE
  \ succeeding. The address returned by ENLARGE is that
  \ returned by ALLOCATE, which is that of the data field, not
  \ the head. If the allocation fails repair the damage done by
  \ removing the node at addr1.


  \ ANSI Heap  ---  Node Restructuring  RESIZE

: adjust ( addr1 size1 -- addr2 size2)  adjustsize >R
              headsize -
              DUP savelink
              DUP togglesize
              DUP ?mergenext R> ;

  \ Addr1 points to the data field of a node, not the "next"
  \ field. This needs correcting. Size1 also needs adjusting as
  \ per ADJUSTSIZE. In addition it is easier to work with free
  \ nodes than live ones as the size field is correct, and, as
  \ we intend to change the nodes size we will inevitably want
  \ to muck about with the next node, if its free, so lets
  \ merge with it straight away. Sufficient information is
  \ first saved to put the heap back as it was, if necessary.
  \ Now we are ready to get down to business.

-->

( heap )

FORTH-WORDLIST SET-CURRENT

: RESIZE ( addr1 u -- addr2 ior)
  DUP 0<  IF  DROP allocationerror
          ELSE  adjust  2DUP toobig?
                IF enlarge
                ELSE  OVER makenode headsize +  0  THEN
          THEN ;

  \ Resize the node at addr1 to the specified size. Return the
  \ address of the resized node (addr2) along with an ior of
  \ zero if successful and ALLOCATIONERROR if not. Addr2 may be
  \ the same as, or different to, addr1.  If ior is non-zero
  \ then addr2 is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using MAKENODE, which
  \ has just the right functionality. In this case the ior is
  \ zero. As this is a standard word it takes an unsigned size
  \ argument, but excessive requests fail automatically, as
  \ with ALLOCATE.

  \ vim: filetype=soloforth
