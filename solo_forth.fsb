( Solo Forth library )

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

\ This file is the library of Solo Forth,
\ and the skeleton to build applications in Solo Forth.

\ ------------------------------------------------------------
\ Acknowledgements

\ See the file <AKNOWLEDGMENTS.adoc>.

\ ------------------------------------------------------------
\ License

\ Copying and distribution of this file, with or without
\ modification, are permitted in any medium without royalty
\ provided the copyright notice, the aknowledgments file and
\ this notice are preserved.  This file is offered as-is,
\ without any warranty.

( ) \ scr 1


( debugging ) \ scr 2

  \ XXX to test `error`:

: wrong 4 literal ;

( require ) \ scr 3

  \ This screen must be at a fixed location.

  \ 2015-06-04: Copied and modified from lina ciforth.
  \
  \ 2015-06-23: First tries.
  \
  \ 2015-06-25: Fix. The parsed strings had to be saved in the
  \ circular string buffer.

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
  \ Does the string ca1 len1 contains the string ca2 len2?

scr/disk 1 2variable locatable

: located  ( ca len -- screen | false )
  locatable 2@ do
    0 i (line) 2over contains if  2drop i unloop exit  then
  loop  2drop false  ;

: locate  ( "name" -- screen | false )
  parse-word save-string located  ;

: (required)  ( ca len -- )
  \ cr ." (required) <" 2dup type [char] > emit  \ XXX INFORMER
  located dup 0= 29 ?error load  ;

: required  ( ca len -- )
  2dup undefined? if  2dup (required)  then
  \ cr ." required <" 2dup type [char] > emit  \ XXX INFORMER
  2dup undefined? if  type 28 message exit  then  2drop  ;

: require  ( "name" -- )  parse-word save-string required  ;

( Error messages 1..15 ) \ scr 4

\ Error #1: Not a word nor a number.
\ Error #2: Stack empty.
  \ #03 not used:
\ Error #3: Dictionary full.
\ Error #4: Warning: Is not unique.
\ Error #5: Word not found.
  \ #06 not used:
\ Error #6: Out of disk range
\ Error #7: Full stack.
\ Error #8:
\ Error #9: Trying to load from screen 0.
\ Error #10:
\ Error #11:
\ Error #12:
\ Error #13:
\ Error #14:
\ Error #15:

( Error messages 17..31 )  \ scr 5

\ Error #17: Compilation only, use in definition.
\ Error #18: Execution only.
\ Error #19: Conditionals not paired.
\ Error #20: Definition not finished.
\ Error #21: In protected dictionary.
\ Error #22: Use only when loading.
\ Error #23: Off current editing screen.
  \ XXX TODO better text:
\ Error #24: Declare vocabulary.
  \ XXX TMP -- not used yet:
\ Error #25: Unsupported tape operation.
  \ XXX TMP -- not used yet:
\ Error #26: Unsupported disk operation.
\ Error #27: Source file needed.
\ Error #28: Warning: Not present, though required.
\ Error #29: Required, but not located.
\ Error #30:
\ Error #31:

( debug ) \ scr 6 for debugging

( debug ) \ scr 7 for debugging

( parse-name place +place /string )

  \ 2015-06-17: Copied from Afera.

  \ XXX OLD -- 2015-06-20: `text` modified in the kernel to do
  \ this:
  \ : parse-text  ( c "ccc<c>" -- ca len )  text pad count  ;
  \ XXX OLD -- 2015-06-23: `parse-word` in the kernel:
  \ : parse-name  ( "name" -- ca len )  bl parse-text  ;

  \ XXX OLD -- 2015-06-20: Moved to the kernel:
  \ : slit  ( -- ca len )  r@ count dup 1+ r> + >r  ;
  \ : s,  ( ca len -- )  swap here rot cmove 1+ allot  ;
  \ : sliteral  ( ca len -- )  compile slit s,  ; immediate

: place  ( ca1 len1 ca2 )  2dup c! 1+ smove  ;
: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;

: /string  ( ca1 len1 n -- ca2 len2 )
  dup >r - swap r> + swap  ;

( s' )

  \ 2015-06-17: Basic string support words copied from Afera.
  \
  \ 2015-06-20: All words but `s'` are moved to the kernel.

  \ doc{
  \
  \ s'  ( compilation: "text<'>" -- ) ( run-time:  -- ca len )
  \
  \ }doc

: s'  ( compilation: "ccc<'>" -- ) ( run-time:  -- ca len )
  [char] ' (s)  ; immediate

( -rot )

  \ 2015-06-05: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,     \ pop hl / pop de
  E3 c,           \ ex (sp),hl
  EB c,           \ ex de,hl
  C3 c, pushde ,  \ jp pushde

  end-code

( pixel )

require pixel-addr

code pixel  ( x y -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel in the byte address 0..7
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, pixel-addr ,      \ call pixel-addr
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushde ,          \ jp pushde
  end-code

( pixel-addr )

  \ 2015-06-11: Written.
  \ 2015-06-20: `label` instead of `variable` and `-2 allot`.

label pixel-addr  ( -- a )  hex
  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.
  \ Input:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  decimal

( point )

  \ 2015-06-04: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).
  \ 2105-06-11: Modified to use the whole screen.

  \ XXX FIXME 2015-06-25: now it always returns 0, why?

require pixel-addr

code point  ( x y -- )
  E1 c, D1 c, C5 c,       \ pop hl / pop de / push bc
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c,   \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate
  CD c, pixel-addr ,      \ call pixel-addr
  \ hl = screen address
  \ a = pixel position in hl
  40 07 + c,              \ ld b,a
  04 c,                   \ inc b
  7E c,                   \ ld a,(hl)
  \ rotate:
  07 c,  10 c, FD c,      \ rlca / djnz rotate
  E6 c, 01 c,             \ and 1
  \ finish:
  26 c, 00 c,  68 07 + c, \ ld h,0 / ld l,a
  C1 c,                   \ pop bc
  C3 c, pushhl ,          \ jp pushhl
  end-code

( plot )

  \ 2015-06-05: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).
  \ 2105-06-11: Modified to use the whole screen.

  \ XXX FIXME 2015-06-25: now it prints 8 pixels to the right,
  \ why?

require pixel-addr

code plot  ( x y -- )

  D9 c,               \ exx
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  ED c, 43 c, 5C7D ,   \ ld (0x5C7D),bc ; update COORDS
  CD c, pixel-addr ,  \ call pixel-addr
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EB ,        \ call 0x22EB ; plot-sub + 6
  D9 c,               \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  DD c, E9 c,         \ jp (ix)

  end-code

( draw )

  \ XXX TODO

  \ Version of Spectrum Forth-83:

  \ CODE DRAW
  \   H POP
  \   B POP
  \   D PUSH
  \   1 E LD#
  \   7 B BIT
  \   NZ IF
  \     C A LD
  \     NEG
  \     -1 E LD#
  \     A C LD
  \   THEN
  \   1 D LD#
  \   L B LD
  \   7 H BIT
  \   NZ IF
  \     B A LD NEG
  \     -1 D LD#
  \     A B LD
  \   THEN
  \   24BA CALL
  \   D POP
  \   JPIX ;C

( attr )

code attr ( line col -- )

  \ Version of Abersoft Forth

  \ pop hl
  \ pop de
  \ push bc
  \ push ix
  \ ld c,e
  \ ld b,l
  \ call rom_s_attr_s_0x2583
  \ call rom_find_int1
  \ ld h,0x00
  \ ld l,a
  \ pop ix
  \ pop bc

  \ Improved version of the ROM routine at 0x2583

  E1 c, \ pop hl ; l = col
  D1 c, \ pop de ; e = line
  50 05 + c, \ ld d,l ; d = col

  78 02 + c, \ ld a,d  ; line to a 0x00..0x17   (max 00010111)
  0F c, 0F c, 0F c, \ rrca | rrca | rrca  ; rotate bits left
  50 07 + c, \ ld d,a ; store in d as an intermediate value.

  E6 c, E0 c, \ and 0xE0 ; pick up bits 11100000 (was 00011100)
  A8 02 + c, \ xor d ; combine with column 0x00..0x1F
  68 07 + c, \ ld l,a ; low byte now correct.

  -->

( attr )

  78 02 + c, \ ld a,d ; bring back intermediate result from d
  E6 c, 03 c, \ and 0x03 ; mask to give correct third of screen
  EE c, 58 c, \ xor 0x58 ; combine with base address.
  60 07 + c, \ ld h,a ; high byte correct.
  6E c, \ ld l,(hl) ; pick up the colour attribute.
  26 c, 00 c, \ ld h,0

  C3 c, pushhl , \ jp pushhl

  end-code

( screen )

  \ XXX TODO -- rewrite after the planned method for a double
  \ character set: `ascii-printed`, `udg-printed` and its
  \ combination `printed`, or similar names. Modify the charset
  \ system variable.

code screen ( row col -- f )

  \ pop hl
  \ pop de
  \ push bc
  \ ld c,e
  \ ld b,l
  \ call rom_s_scrn_s_0x2538
  \ call rom_stack_fetch
  \ ld a,(de)
  \ ld h,0x00
  \ ld l,a
  \ pop bc
  \ ; XXX TODO -- check if necessary after those ROM routines:
  \ ld ix,next ; restore
  \ jp push_hl

end-code

( bleep )

  \ 2015-06-04: Abersoft Forth's `bleep`.

code bleep
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  DD c, E5 c,         \ push ix
  CD c, 03B5          \ call rom_beeper
  DD c, E1 c,         \ pop ix
  C1 c,               \ pop bc
  DD c, E9 c,         \ jp (ix)
  end-code

( within between )

: within  ( n1|u1 n2|u2 n3|u3 -- f )
  over - >r - r> u<  ;

: between  ( n1|u1 n2|u2 n3|u3 -- flag )
  over - -rot - u< 0=  ;

( d0= d0< d< du< dmin dmax )

: d0=  ( d -- f )  or 0=  ;

: d0<  ( d -- f )  swap drop 0<  ;

; d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;

: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;

: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;

( lshift )

  \ XXX TODO

code lshift  ( x1 u -- x2 )

  \ [Code from DZX-Forth.]

  \ pop de
  \ pop hl
  \ inc e
\ lshift_.1:
  \ dec e
  \ jp z,push_hl
  \ add hl,hl
  \ jp lshift_.1

end-code

( rshift )

  \ XXX TODO

code rshift  ( x1 u -- x2 )

  \ [Code from DZX-Forth.]

  \ pop de
  \ pop hl
  \ inc e
\ rshift_.1:
  \ dec e
  \ jp z,push_hl
  \ or a
  \ ld a,h
  \ call sra_hl.1 ; XXX TODO this is in the kernel
  \ jp rshift_.1

end-code

( [if] [else] [then] )

  \ 2015-06-04: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).
  \ 2015-06-25: Fully adapted.

[defined] s=  ?\  : s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

: [else]  ( "..." -- )

  1 begin   parse-word 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if [compile] [else] then  ; immediate

: [then]  ( -- )  ; immediate

( hex. hexb. dhex. hex{ )

  \ 2015-06-20: Adapted from lina (Copyright (c) 2000-2004
  \ Albert van der Horst, The Netherlands).

[defined] base'  ?\ 0 variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: hex{  ( -- )  base @ base' ! hex ; \ switch to hex
: }hex  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  hex{ (d.) }hex type space  ;
: dhex.    ( d -- )  8 (dhex.)  ;
: hex.     ( n -- )  s>d 4 (dhex.)  ;
: hexb.    ( n -- )  s>d 2 (dhex.)  ;

( binary bin. binb. dbin. bin{ )

  \ 2015-06-22

[defined] base'  ?\ 0 variable base'

base @ decimal
[defined] binary  ?\ : binary  ( -- )  2 base !  ;
base !

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: bin{  ( -- )  base @ base' ! binary ; \ switch to binary
: }bin  ( -- )  base' @ base !        ; \ and binary

: (dbin.)  ( d n -- )  bin{ (d.) }bin type space  ;
: dbin.    ( d -- )  32 (dbin.)  ;
: bin.     ( n -- )  s>d 16 (dbin.)  ;
: binb.    ( n -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  \ XXX TODO use `?do` instead of `if` when available
  dup if
    bounds do
      i c@ 127 and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

( dump )

require hex.  require ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: dump  ( a len -- )
  7 + -8 and 8 / 0
  \ XXX TODO use `?do` instead of `if` when available
  2dup - if
    do
      cr dup hex.
      8 0 do  i over + @ flip hex.  2 +loop
      \ 16 0 do  i over + c@ hexb.  loop
      dup bs 8 ascii-type
      ?terminal if  leave  then
    8 + loop
  else  2drop  then  drop  ;

( decode -- variables, indentation and pause control )

  \ 2015-06-05: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).
  \ 2015-06-19: New: `?branch`.

forth definitions decimal

0 variable decode-level    \ depth of nesting
0 variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent ;

-->

( decode -- special cases )

: decode-compile  ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal  ( a1 -- a2 )  2+ dup @ .  ;

: decode-branch  ( a1 -- a2 )  2+ dup @ u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode -- special cases dispatcher )

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-dot-quote  endof
  endcase  ;

-->

( decode -- checks of the main code )

: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] ;s =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  pfa>cfa @ ['] : @ =  ;

-->

( decode -- main code )

: (decode)  ( pfa --- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>nfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp! quit  endof \ q
                      bl  of  drop      endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode -- interface )

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

  \ XXX OLD -- for fig-Forth `find`:
\ : decode  ( "name" -- )
\   decode-usage
\   find if    drop  0 decode-level !  (decode)
\        else  5 error  then  ;

  \ XXX NEW -- for the modern `find`:
: decode  ( "name" -- )
  decode-usage
  defined if  cfa>pfa  0 decode-level !  (decode)
          else  drop  5 error  then  ;


( words )

  \ From Spectrum Forth-83.

[defined] tab ?\  : tab  ( -- )  6 emit  ;

: words  ( -- )
  context @ @
  begin
    dup ?terminal 0= and
  while  tab
    dup  u. space
    dup id. space
    nfa>lfa @
  repeat drop ;

( index )

: index  ( n1 n2 -- )
  1+ swap do
    cr i 3 .r space 0 i .line
    ?terminal if leave then
  loop  ;

( where )

: where  ( -- )
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup b/scr / dup scr !
    ." Scr # " decimal . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( p@ )

code p@  ( u -- n )

  \ Return the value read from port _u_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 78 c,     \ in a,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  68 07 + c,      \ ld l,a
  C3 c, pushhl ,  \ jp pushhl
end-code

( p! )

code p!  ( n u -- )

  \ Present _n_ to output port _u_.
 
  E1 c,           \ pop hl
  D1 c,           \ pop de
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  78 03 + c,      \ ld a,e
  ED c, 79 c,     \ out (c),a
  C1 c,           \ pop bc
  DD c, E9 c,     \ jp (ix)
end-code

( .s )

  \ 2015-06-22: Copied from Afera. The algorithm
  \ was taken from v.Forth.

: .S   ( -- )
  depth
  dup s>d <# [char] > hold #s [char] < hold #> type space
  if  sp@ 2- s0 @ 2- do i @ . -2 +loop  then  ;

( forget )

  \ XXX OLD -- obsolescent word

: forget  ( "name" -- )
  current @ context @ <>   \ Compare `current` with `context`.
  24 ?error                \ If not the same, issue an error.
  '                        \ Locate "name", return its cfa.
  dup fence @ u<           \ Below `fence`?
  21 ?error                \ If so, issue an error.
  dup  ( cfa cfa )
  cfa>nfa dp !             \ Update the dictionary pointer.
  cfa>lfa @ current @ !    \ Update the `current` vocabulary.
  ;

( extend size system turnkey )

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 22  +origin !  \ `fence` init value \ XXX OLD obsolete
  here 24 +origin !   \ `dp` init value
  \ XXX TODO -- update also the names pointer
  here fence ! \ XXX OLD obsolete
  \ `voc-link` init value:
  [ ' forth cfa>pfa 8 + ] literal 26 +origin !  ;

  \ size  ( -- u )
  \
  \ Size of the system.

: size  ( -- u )  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.

: system  ( -- a len )  extend  0 +origin size 10 + ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.

: turnkey  ( cfa -- a len )  boot ! system  ;

( c>hex )

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex

: c>hex  ( c -- n )
  \ Convert a character to its hexadecimal value.
  30 - dup 9 > if  7 -  then  ;

decimal

( '. ) \ character prefix

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 1 width !

: '.  ( -- n )
  \ leave ascii character; example: 'a leaves 0x41
  here 2 + c@ [compile] literal  ; immediate

width ! decimal

( $.. $.... ) \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

width @  1 width !

: $..  ( -- n )
  \ leave hex number; example: $0a leaves 0x0A
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  [compile] literal  ; immediate

: $....  ( -- n )
  \ leave 16-bit hex number; example: $0aff leaves 0x0AFF
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  [compile] literal  ; immediate

width ! decimal

( 0x.. 0x.... )  \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 2 width !

: 0x..  ( -- n )
  \ leave hex number; example: 0x0a
  here 3 + c@ c>hex 10 * here 4 + c@ c>hex +
  [compile] literal  ; immediate

: 0x....  ( -- n )
  \ leave hex number; example: 0x0aff
  0 here 7 + here 3 + do 10 * i c@ c>hex + loop
  [compile] literal  ; immediate

width ! decimal

( #... #..... ) \ hex prefixes

  \ Inspired by code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX TODO

width @  1 width !

: #...  ( -- n )
  \ leave decimal number
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  [compile] literal  ; immediate

: #.....  ( -- n )
  \ leave 16-bit decimal number
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  [compile] literal  ; immediate

width ! decimal

( [false] [true] )

  \ 2015-06-17: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( ms )

  \ 2015-06-10: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( n -- )
  \ Wait n ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ XXX TODO
  \ Adapth this better version from v.Forth:
  \
  \ CODE MS
  \  POP DE|
  \  BEGIN,
  \   LDI A'| 171 N,
  \   BEGIN,
  \    NOP
  \    DEC A'|
  \   -UNTIL,
  \   DECX DE|
  \   LD A'| D|
  \  ORA E|
  \  -UNTIL,
  \ NEXT C;

( time@ time! time0 )

  \ 2015-06-10: Copied from Afera
  \ (http://programandala.net/en.program.afera.html).

[defined] sys-frames ?\ 23672 constant sys-frames

: time@  ( -- d )
  \ System frames counter (incremented every 20 ms).
  sys-frames @ [ sys-frames 2+ ] literal c@  ;

: time!  ( d -- )
  \ Set the system frames counter.
  [ sys-frames 2+ ] literal c! sys-frames !  ;

: time0  ( -- )
  \ Reset the system frames counter.
  0. time!  ;

( i' )

code i'  ( R: n x -- n x ) ( -- n )

  \ Copy the last but one value from the return stack (which
  \ within a `DO`-`LOOP` is the loop limit).

  2A c, rp ,  \ ld hl,(return_stack_pointer)
  23 c,       \ inc hl
  23 c,       \ inc hl
  5E c,       \ ld e,(hl)
  23 c,       \ inc hl
  56 c,       \ ld d,(hl)
  D5 c,       \ push de
  dd c, e9 c, \ jp (ix)

  end-code

( also  only )

  \ 2015-04-17

  \ Copied from the FORTH-83 Standard,
  \ a publication of the FORTH Standars Team (1983-03)
  \
  \ Original code by William F. Ragsdale, 1982-06-12.
  \
  \
  \ XXX TODO adapt

  \ note the systems -FIND searches 1 to 5 vocabs in CONTEXT

vocabulary only    only definitions

: also  ( -- )
  \ Slide transient into resident.
  context dup 2+ 6 cmove>  ;

  \ Alter run time of ONLY from usual vocabulary.

here 2+
  ] does>  context 8 erase  dup context !  context 8 + !
           also  exit [  ' only cfa !

  \ Make NULL word.

: x  ( -- )  exit  ;  hex a080 decimal ' x nfa !  immediate

: forth        ( -- )  forth  ;
: definitions  ( -- )  definitions  ;
: forget       ( "name" -- )  forget  ;
: vocabulary   ( "name" -- )  vocabulary  ;
: only         ( -- )  only  ;
: words        ( -- ) words  ;

( order )

: order  ( -- )
  \ Show the search order.
  context 10 bounds
  do  i @ -dup if  id.  else  leave  then  2 +loop
  10 spaces  current @ id.  ;

only forth also   definitions

( 2nip )

  \ 2015-06-22: Copied from Afera; original code from
  \ DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,           \ pop hl
  D1 c,           \ pop de
  F1 c,           \ pop af
  F1 c,           \ pop af
  C3 c, pushde ,  \ jp pushde

end-code

( heap )

  \ An implementation of the ANS Forth Memory-Allocation Word
  \ Set.

  \ Adapted from code written by Gordon Charlton, 1994:
  \
  \ XXX TODO adapt

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, ALLOCATE, FREE,
  \ and RESIZE which give the minimum functionality required to
  \ use the heap. These are given in areas 3, 4 and 5
  \ respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant HEAPSIZE. The constant HYSTERESIS
  \ controls the amount of spare space that is added to an
  \ allocation, to reduce the need for block moves during
  \ resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

forth definitions
vocabulary heap-voc
heap-voc definitions

  \ **1** General Purpose Extensions

: unique (  )  VARIABLE ;

  \ Defining word. Each child returns a different non-zero
  \ number. The standard introduces the need for unique
  \ identifiers in the form of IORs and THROW codes, but
  \ provides no means for generating them. This does the trick.

0 1 2 UM/MOD NIP 1- CONSTANT maxpos

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  ---  Constants

256 CELLS CONSTANT heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 CELLS 1- CONSTANT hysteresis

  \ Node lengths are rounded up according to the value of
  \ HYSTERESIS to reduce the number of block moves during
  \ RESIZE operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

unique allocationerror

  \ Indicates there is less contiguous heap space available
  \ than required.

3 CELLS CONSTANT headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis OR  1+ ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize CONSTANT overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  ---  Structure

CREATE sentinel  HERE CELL+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

CREATE heap  heapsize ALLOT

  \ The heap is as described in HEADSIZE.

VARIABLE nextnode  -->

  \ Searching is done using a "nextfit" algorithm. NEXTNODE
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr -- addr)  CELL+ ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr -- addr)  2 CELLS + ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )  heap DUP nextnode !
      DUP DUP !
      DUP heapsize  OVER >size !
      >prev ! ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does NEXTNODE.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  ---  List Searching

: attach ( addr)  >prev @
      DUP sentinel ROT !
      sentinel >prev ! ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (addr) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
    >R BEGIN 2@ SWAP R@ < INVERT UNTIL
    R> DROP  >prev @ ;

  \ Search the nodelist, starting at the node specified (addr),
  \ for a free node larger than or equal to the specified size.
  \ Return the address of the first node that matches, or zero
  \ for no match. The heap structure is set up to make this a
  \ near optimal search loop. The "size" field is next to the
  \ "next" field so that both can be collected in a single
  \ operation (2@). Nodes in use have negated sizes so they
  \ never match the search. The "previous" field is included to
  \ allow the search to overshoot the match by one node and
  \ then link back outside the loop, rather than remembering
  \ the address of the node just examined. The sentinel removes
  \ the need for a separate test for failure. SEARCH assumes
  \ the sentinel is in place.

: detach ( addr)  DUP >prev @ ! ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           DUP      attach
           DUP ROT  search
           SWAP     detach ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ NEXTNODE, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  ---  Head Creation

: fits ( size addr -- flag)  >size @ SWAP -  overhead  < ;

  \ Returns TRUE if the size of the node specified is the same
  \ as the specified size, or larger than it by less than the
  \ size of the smallest possible node. Returns FALSE
  \ otherwise.

: togglesize ( addr)  >size DUP @  NEGATE SWAP ! ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode ! ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)  2DUP + >R
           >size 2DUP @ SWAP -
           R@ >size !
           SWAP NEGATE SWAP !  R> ;

  \ Given a free node (addr), reduce its size to that specified
  \ and mark it as in use. Start to construct a new node within
  \ the specified node beyond its new length, by storing the
  \ length of the remainder of the node in the size field of
  \ the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)  2DUP SWAP @  2DUP  SWAP !  >prev !
              2DUP >prev !   SWAP ! ;


  \ Addr1 is an existing node. Addr2 is the address of a new
  \ node just above the existing node. Break the links from the
  \ existing node to the next node and from the next node to
  \ the existing node and join the new node to them.


  \ ANSI heap  ---  Node Construction  ALLOCATE

: newnode ( size addr)  TUCK sizes!  links! ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)  2DUP fits IF  togglesize DROP
         ELSE  newnode
         THEN ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

FORTH-WORDLIST SET-CURRENT
: ALLOCATE ( u -- addr ior)
    DUP 0< IF  allocationerror
         ELSE  adjustsize
         DUP findspace
         DUP IF  DUP next!
           TUCK makenode
           headsize +  0
           ELSE  DROP allocationerror
           THEN
         THEN ;
MEMORY-ALLOC-WORDLIST SET-CURRENT  -->

  \ Make an in-use node with a data field at least u address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and an ior equal to the
  \ constant ALLOCATIONERROR. The standard specifies that the
  \ argument to ALLOCATE is unsigned. As the implementation
  \ uses the sign bit of the size field for its own purposes
  \ any request for an amount of space greater than MAXPOS must
  \ fail. As this would be a request for half the addressable
  \ memory or more this is not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  ---  Head Destruction

: mergesizes ( addr addr)
       >size @ SWAP >size +! ;

  \ Make the size field of the node at addr1 equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at addr2 will be the one immediately above addr1.

: mergelinks ( addr addr)
       @ 2DUP SWAP !
       >prev ! ;

  \ The node at addr2 is removed from the node list. As with
  \ MERGESIZES the node at addr2 will be immediately above that
  \ at addr1. Destroy the link from node1 to node2 and relink
  \ node1 to the node above node2. Destroy the backward link
  \ from the node above node2 and relink it to node1.

: jiggle (  )
   nextnode @ @  >prev @  next! ;

  \ There is a possibility when a node is removed from the node
  \ list that NEXTNODE may point to it. This is cured by making
  \ it point to the node prior to the one removed. We do not
  \ want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically NEXTNODE is set to point
  \ to the node pointed to by the "previous" field of the node
  \ pointed to in the "next" field of the node pointed to by
  \ NEXTNODE. Ordinarily this is a no-op (ie I am my father's
  \ son) but when the node has had its links merged it sets
  \ NEXTNODE to point to the node prior to the node it pointed
  \ to (ie when I died my father adopted my son, so now my son
  \ is my father's son).

: merge ( addr)
  DUP @ 2DUP mergesizes
       mergelinks  jiggle ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  ---  Node Removal    FREE

: ?merge ( addr1 addr2)  >size @
       0> IF  DUP DUP @
        U< IF  DUP merge
           THEN
          THEN  DROP ;  -->

  \ Merge the node at addr1 with the one above it on two
  \ conditions, firstly that the node at addr2 is free, and
  \ secondly that the node pointed to by the next field in
  \ addr1 is actually above addr1 (ie that it does not wrap
  \ around because it is the topmost node). In usage addr2 will
  \ be either addr1 or the node above it. In each instance the
  \ other affected node (either the node above addr1 or addr1)
  \ is known to be free, so no test is needed for this.

( heap )

: ?mergenext ( addr)  DUP @ ?merge ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ DUP ?merge ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

FORTH-WORDLIST SET-CURRENT
: FREE ( addr -- ior)  headsize -
         DUP togglesize
         DUP ?mergenext
         ?mergeprev  0 ;
MEMORY-ALLOC-WORDLIST SET-CURRENT

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  ---  Node Repairing

VARIABLE stash

  \ The RESIZE algorithm is simplified and made faster by
  \ assuming that it will always succeed. STASH holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash ! ;

  \ Saves the contents of the >NEXT field of the node being
  \ RESIZEd in STASH (above).

: restorelink ( addr)  stash @  SWAP ! ;

  \ Converse operation to SAVELINK (above).

: fixprev ( addr)  DUP >prev @ ! ;

  \ The >NEXT field of the node prior to the node being RESIZEd
  \ should point to the node being RESIZEd. It may very well do
  \ already, but this makes sure.

: fixnext ( addr)  DUP @ >prev ! ;

  \ The >PREV field of the node after the node resized may need
  \ correcting.  This corrects it whether it needs it or not.
  \ (Its quicker just to do it than to check first.)

: fixlinks ( addr)  DUP fixprev  DUP fixnext  @ fixnext ;

  \ RESIZE may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of JIGGLE (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)  DUP >size @ 0>
       IF  DUP @  2DUP <
           IF  OVER - SWAP >size !
         ELSE 2DROP
         THEN
     ELSE  DROP
     THEN ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the >NEXT field provided that
  \ the node is free and it is not the topmost node in the heap
  \ (ie there is no wraparound). Both these conditions need to
  \ be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  DUP fixsize  >prev @ fixsize ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to RESIZE (damaged by ?MERGENEXT)
  \ and its predecessor (damaged by ?MERGEPREV).

: repair ( addr)  DUP restorelink
      DUP fixlinks  DUP fixsizes
      togglesize ;

  \ Make good the damage done by RESIZE. Restore the >next
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer NEXTNODE may
  \ have moved back one or two nodes by virtue of having been
  \ JIGGLEd about if it happened to be pointing to the wrong
  \ node. This is not serious, so I have chosen to ignore it.


  \ ANSI Heap  ---  Node Movement

: toobig? ( addr size -- flag)
    SWAP  >size @  > ;

  \ Flag is true if the node at addr is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
       OVER >size @  headsize -
       ROT  headsize + ROT ROT MOVE ;

  \ Move the contents of the data field of the node at addr1 to
  \ the data field at addr2. Assumes addr2 is large enough. It
  \ will be.

: enlarge ( addr1 size -- addr2 ior)
    OVER  ?mergeprev
    ALLOCATE DUP >R
    IF  SWAP repair
  ELSE  TUCK copynode
  THEN R> ;

  \ Make a new node of the size specified. Copy the data field
  \ of addr1 to the new node. Merge the node at addr1 with the
  \ one preceding it, if possible. This last behaviour is to
  \ finish off removing the node at addr1. The word ADJUST
  \ (below) starts removing the node. The node is removed
  \ before allocation to increase the probability of ALLOCATE
  \ succeeding. The address returned by ENLARGE is that
  \ returned by ALLOCATE, which is that of the data field, not
  \ the head. If the allocation fails repair the damage done by
  \ removing the node at addr1.


  \ ANSI Heap  ---  Node Restructuring  RESIZE

: adjust ( addr1 size1 -- addr2 size2)  adjustsize >R
              headsize -
              DUP savelink
              DUP togglesize
              DUP ?mergenext R> ;

  \ Addr1 points to the data field of a node, not the "next"
  \ field. This needs correcting. Size1 also needs adjusting as
  \ per ADJUSTSIZE. In addition it is easier to work with free
  \ nodes than live ones as the size field is correct, and, as
  \ we intend to change the nodes size we will inevitably want
  \ to muck about with the next node, if its free, so lets
  \ merge with it straight away. Sufficient information is
  \ first saved to put the heap back as it was, if necessary.
  \ Now we are ready to get down to business.

-->

( heap )

FORTH-WORDLIST SET-CURRENT

: RESIZE ( addr1 u -- addr2 ior)
  DUP 0<  IF  DROP allocationerror
          ELSE  adjust  2DUP toobig?
                IF enlarge
                ELSE  OVER makenode headsize +  0  THEN
          THEN ;

  \ Resize the node at addr1 to the specified size. Return the
  \ address of the resized node (addr2) along with an ior of
  \ zero if successful and ALLOCATIONERROR if not. Addr2 may be
  \ the same as, or different to, addr1.  If ior is non-zero
  \ then addr2 is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using MAKENODE, which
  \ has just the right functionality. In this case the ior is
  \ zero. As this is a standard word it takes an unsigned size
  \ argument, but excessive requests fail automatically, as
  \ with ALLOCATE.

  \ vim: filetype=soloforth
