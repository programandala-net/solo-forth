( Solo Forth blocks file )

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

\ This file is the library of Solo Forth,
\ and the skeleton to build applications in Solo Forth.

\ ------------------------------------------------------------
\ Author and acknowledgements

\ 2015: Solo Forth
\
\ Marcos Cruz (programandala.net)
\ http://programandala.net/en.program.solo_forth.html

  \ Solo Forth started with the code of Abersoft Forth (for ZX
  \ Spectrum), that was first studied, patched and improved
  \ (http://programandala.net/en.program.afera.html) and
  \ finally fully disassembled
  \ (http://programandala.net/en.program.abersoft_forth.html).
  \
  \ 1983: Abersoft Forth
  \
  \ Abersoft Forth (for ZX Spectrum) was implemented by John
  \ Jones Steele and edited by Melbourne House in 1983. It is
  \ an implementation of Z80 fig-Forth 1.1, with ZX Spectrum
  \ specific features and some extensions beyond the fig-Forth
  \ model.
  \
  \ 1979: fig-Forth 1.1
  \
  \ All publications of the FORTH Interest Group are public
  \ domain.  They may be further distributed by the inclusion
  \ of this credit notice:

  \               This publication has been made available by:

  \               FORTH Interest Group
  \               P.O. Box 1105
  \               San Carlos, Ca. 94070

  \ Aknowledgments:

  \ Solo Forth has copied, adapted and implemented ideas, code
  \ and documentation from the following Forth systems
  \ (aknowledgment notes are properly included in the sources):

  \ Spectrum Forth-83, by Lennart Benschop (1988,2015)
  \ v.Forth, by Matteo Vitturi (1990-2015)
  \ lina ciforth, by Albert van der Horst (2000-2004)

( ) \ scr 1

  \ 2015-06-11
  \ XXX FIXME this issues error 7 (full stack) compiling test1,
  \ and execution of words freezes the system.

: test1 1 . ;

  \ XXX FIXME with this change, compilation resets the machine:

  \ : test1 ;

( debugging ) \ scr 2

  \ 2015-06-11
  \ XXX FIXME this issues error 7 (full stack) compiling test2,
  \ and execution of test1 freezes the system.

: test1 1 . ;

: test2 2 . ;

( require ) \ scr 3

  \ This screen must be at a fixed location.

  \ 2015-06-04: Copied from lina (Copyright (c) 2000-2004
  \ Albert van der Horst, The Netherlands). First changes to
  \ adapt it.

  \ XXX TODO

: CONTAINS
  0 pad !   BL pad $C+
  pad $+!   BL pad $C+   pad @ - OVER + SWAP
  do   i pad $@ cora   0= if -1 unloop exit then   loop   0 ;

: located  ( ca len -- screen | false )
  780 1 do
    0 i (line) 2over contains if  2drop i unloop exit  then
  loop  2drop false  ;

: locate  ( "name" -- screen | false )  bl word located  ;

  \ Make sure the given word is defined.

: (required)  ( ca len -- )
  located dup 0= 29 ?error load  ;

: required  ( ca len -- )
  \ XXX TODO finish
  2dup undefined? if  2dup (required)  then
  2dup undefined? if  type 24 message exit  then 2drop  ;

: require  ( "name" -- )  bl word required  ;

( Error messages 1..15 ) \ scr 4

\ Error #1: Not a word nor a number.
\ Error #2: Stack empty.
  \ #03 not used:
\ Error #3: Dictionary full.
\ Error #4: Warning: Is not unique.
\ Error #5:
  \ #06 not used:
\ Error #6: Out of disk range
\ Error #7: Full stack.
\ Error #8:
\ Error #9: Trying to load from screen 0.
\ Error #10:
\ Error #11:
\ Error #12:
\ Error #13:
\ Error #14:
\ Error #15:

( Error messages 17..31 )  \ scr 5

\ Error #17: Compilation only, use in definition.
\ Error #18: Execution only.
\ Error #19: Conditionals not paired.
\ Error #20: Definition not finished.
\ Error #21: In protected dictionary.
\ Error #22: Use only when loading.
\ Error #23: Off current editing screen.
  \ XXX TODO better text:
\ Error #24: Declare vocabulary.
  \ XXX TMP -- Copied from Afera library, not used yet:
\ Error #25: Unsupported tape operation.
\ Error #26: Unsupported disk operation.
\ Error #27: Source file needed.
\ Error #28: Warning: Not present, though required.
\ Error #29: Required, but not located.
\ Error #30:
\ Error #31:

( debug ) \ scr 6

: zx  ( -- )
  page
  begin   1
          cr depth . sp@ u.
          key drop
  again ;
  \ ?terminal until  ;

( debug ) \ scr 7 for debugging

 .( line 1 ) depth u.
 .( line 2 ) depth u.
 .( line 3 ) depth u.
 .( line 4 ) depth u.
 .( line 5 ) depth u.
 .( line 6 ) depth u.
 .( line 7 ) depth u.
 .( line 8 ) depth u.
 .( line 9 ) depth u.
 .( line 10 ) depth u.
 .( line 11 ) depth u.
 .( line 12 ) depth u.
 .( line 13 ) depth u.
 .( line 14 ) depth u.
 .( line 15 ) depth u.

( cmove> )

code cmove>  ( ca1 ca2 len -- )  \ Forth-94

  \ 2015-06-17: Copied from the Afera Library.  Originally
  \ adapted from Lennart Benschop's Spectrum Forth-83.

  \ exx / pop bc / pop de / pop hl
  d9 c,  c1 c,  d1 c,  e1 c,

  \ ld a,c / or b / jr z,end
  79 c, b0 c, 28 c, 8 c,

  09 c,         \ add hl,bc
  2b c,         \ dec hl
  eb c,         \ ex de,hl
  09 c,         \ add hl,bc
  2b c,         \ dec hl
  eb c,         \ ex de,hl
  ed c, b8 c,   \ lddr
  \ end:
  d9 c, dd c, e9 c,     \ exx / jp (ix)

  end-code

( move )

require cmove>

: move  ( a1 a2 len -- )  \ Forth-94

  \ 2015-06-17: Copied from the Afera Library.
  \ Originally copied from Phil Burk's pForth (v19).

  >r 2dup - 0< if  r> cmove>  else  r> cmove  then  ;

( parse-text parse-name s, sliteral place +place /string )

  \ 2015-06-17: Copied from the Afera Library.

require move

: parse-text  ( c "ccc<c>" -- ca len )  text pad count  ;
: parse-name  ( "name" -- ca len )  bl parse-text  ;

: slit  ( -- ca len )  r@ count dup 1+ r> + >r  ;
: s,  ( ca len -- )  swap here rot cmove 1+ allot  ;
: sliteral  ( ca len -- )  compile slit s,  ; immediate

: place  ( ca1 len1 ca2 )  2dup c! 1+ swap move  ;
: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + swap move  ;

: /string  ( ca1 len1 n -- ca2 len2 )
  dup >r - swap r> + swap  ;

( s" s' )

  \ 2015-06-17: Copied from the Afera Library.

require slit  require parse-text

: (s) ( compilation: c "ccc<c>" -- ) ( run-time:  -- ca len )
  state @ if    compile slit word here c@ 1+ allot
          else  parse-text  then  ;

: s"  ( compilation: "ccc<">" -- ) ( run-time:  -- ca len )
  [char] " (s)  ; immediate

: s'  ( compilation: "ccc<'>" -- ) ( run-time:  -- ca len )
  [char] ' (s)  ; immediate

( -rot )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,     \ pop hl / pop de
  E3 c,           \ ex (sp),hl
  EB c,           \ ex de,hl
  C3 c, pushde ,  \ jp pushde

  end-code

( pixel )

  \ 2015-06-11: Written.

hex  0 variable (pixel) -2 allot
  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.
  \ Input:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address 0..7
  3E c, BF c,  \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  decimal

code pixel  ( x y -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel in the byte address 0..7
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,      \ pop hl / pop de
  C5 c,             \ push bc
  40 05 + c,        \ ld b,l ; b=y
  48 03 + c,        \ ld c,e ; c=x
  CD c, (pixel) ,   \ call (pixel)
  C1 c,             \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushde ,    \ jp pushde
  end-code

( point )

  \ 2015-06-04: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).
  \ 2105-06-11: Modified to use the whole screen.

require pixel

code point  ( x y -- )
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c, \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate
  CD c, (pixel) ,    \ call (pixel)
  \ hl = screen address
  \ a = pixel position in hl
  40 07 + c,          \ ld b,a
  04 c,               \ inc b
  7E c,               \ ld a,(hl)
  \ rotate:
  07 c,  10 c, FD c,  \ rlca / djnz rotate
  E6 c, 01 c,         \ and 1
  \ finish:
  26 c, 00 c,  68 07 + c,  \ ld h,0 / ld l,a
  C1 c,               \ pop bc
  C3 c, pushhl ,      \ jp pushhl
  end-code

( plot )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).
  \ 2105-06-11: Modified to use the whole screen.

require pixel

code plot  ( x y -- )

  D9 c,           \ exx
  E1 c,           \ pop hl
  C1 c,           \ pop bc
  40 05 + c,      \ ld b,l
  ED c, 43 , 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel) ,    \ call (pixel)
  \ hl = screen address
  \ a = pixel position in hl
  CD c, 22EC ,    \ call 0x22ec ; plot-sub + 7
  D9 c,           \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  DD c, E9 c,     \ jp (ix)

  end-code

( draw )

  \ XXX TODO

  \ Version of Spectrum Forth-83:

  \ CODE DRAW
  \   H POP
  \   B POP
  \   D PUSH
  \   1 E LD#
  \   7 B BIT
  \   NZ IF
  \     C A LD
  \     NEG
  \     -1 E LD#
  \     A C LD
  \   THEN
  \   1 D LD#
  \   L B LD
  \   7 H BIT
  \   NZ IF
  \     B A LD NEG
  \     -1 D LD#
  \     A B LD
  \   THEN
  \   24BA CALL
  \   D POP
  \   JPIX ;C

( attr )

code attr ( line col -- )

  \ Version of Abersoft Forth

  \ pop hl
  \ pop de
  \ push bc
  \ push ix
  \ ld c,e
  \ ld b,l
  \ call rom_s_attr_s_0x2583
  \ call rom_find_int1
  \ ld h,0x00
  \ ld l,a
  \ pop ix
  \ pop bc

  \ Improved version of the ROM routine at 0x2583

  E1 c, \ pop hl ; l = col
  D1 c, \ pop de ; e = line
  50 05 + c, \ ld d,l ; d = col

  78 02 + c, \ ld a,d  ; line to a 0x00..0x17   (max 00010111)
  0F c, 0F c, 0F c, \ rrca | rrca | rrca  ; rotate bits left
  50 07 + c, \ ld d,a ; store in d as an intermediate value.

  E6 c, E0 c, \ and 0xE0 ; pick up bits 11100000 (was 00011100)
  A8 02 + c, \ xor d ; combine with column 0x00..0x1F
  68 07 + c, \ ld l,a ; low byte now correct.

  -->

( attr )

  78 02 + c, \ ld a,d ; bring back intermediate result from d
  E6 c, 03 c, \ and 0x03 ; mask to give correct third of screen
  EE c, 58 c, \ xor 0x58 ; combine with base address.
  60 07 + c, \ ld h,a ; high byte correct.
  6E c, \ ld l,(hl) ; pick up the colour attribute.
  26 c, 00 c, \ ld h,0

  C3 c, pushhl , \ jp pushhl

  end-code

( bleep )

  \ 2015-06-04: Abersoft Forth's `bleep`.

code bleep
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  DD c, E5 c,         \ push ix
  CD c, 03B5          \ call rom_beeper
  DD c, E1 c,         \ pop ix
  C1 c,               \ pop bc
  DD c, E9 c,         \ jp (ix)
  end-code

( [if] [else] [then] )

  \ 2015-06-04: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

require s=  require parse-name  require s"

: [else]  ( "..." -- )

  1 begin   parse-name 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  -dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if [compile] [else] then  ; immediate

: [then]  ( -- )  ; immediate

( bs hexa. stype )

: bs  ( -- )  8 emit  ;

: hexa.  ( n -- )
  \ Print _n_ in hexadecimal
  \ (regarded as an address, with four digits).
  base @ hex swap s>d <# # # # # #> type space base !  ;

hex

: stype  ( ca len -- )
  dup if
    bounds do
      i c@ 7f and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

decimal  -->

( dump )

require bs  require hexa.  require stype

: dump  ( a len -- )
  7 + -8 and 8 / 0
  2dup - if
    do
      cr dup hexa.
      8 0 do
        i over + @ cswap hexa.
      2 +loop
      dup bs 8 stype
      ?terminal if  leave  then
    8 + loop
  else  2drop  then  drop  ;

( decode -- variables, indentation and pause control )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

forth definitions decimal

0 variable decode-level    \ depth of nesting
0 variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent ;

-->

( decode -- special cases )

: decode-compile  ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal  ( a1 -- a2 )  2+ dup @ .  ;

: decode-branch  ( a1 -- a2 )
  decode-literal  ."  \ to " dup dup @ + u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode -- special cases dispatcher )

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-dot-quote  endof
  endcase  ;

-->

( decode -- checks of the main code )

: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] ;s =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  pfa>cfa @ ['] : @ =  ;

-->

( decode -- main code )

: (decode)  ( pfa --- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>nfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp! quit  endof \ q
                      bl  of  drop      endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode -- interface )

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  -find if    drop 0 decode-level ! (decode)
        else  ." Not found"  then  ;

( words )

  \ From Spectrum Forth-83.

  \ [defined] tab ?\  : tab  ( -- )  6 emit  ;
: tab  ( -- )  6 emit  ;

: words  ( -- )
  context @ @
  begin
    dup ?terminal 0= and
  while  tab
    dup  u. space
    dup id. space
    nfa>lfa @
  repeat drop ;

( index )

: index  ( n1 n2 -- )
  1+ swap do
    cr i 3 .r space 0 i .line
    ?terminal if leave then
  loop  ;

( forget )

: forget  ( "name" -- )
  current @ context @ <>   \ Compare `current` with `context`.
  24 ?error                \ If not the same, issue an error.
  '                        \ Locate "name", return its cfa.
  dup fence @ u<           \ Below `fence`?
  21 ?error                \ If so, issue an error.
  dup  ( cfa cfa )
  cfa>nfa dp !             \ Update the dictionary pointer.
  cfa>lfa @ current @ !    \ Update the `current` vocabulary.
  ;

( extend size system turnkey )

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 22  +origin !  \ `fence` init value
  here 24 +origin !   \ `dp` init value
  here fence !
  \ `voc-link` init value:
  [ ' forth cfa>pfa 8 + ] literal 26 +origin !  ;

: size  ( -- u )
  \ Size of the system.
  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for the
  \ tape or disk saving commands.

: system  ( -- a len )  extend  0 +origin size 10 + ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ return its start address and length, to be used as
  \ parameters for the tape or disk saving commands.

: turnkey  ( cfa -- a len )  boot ! system  ;

( c>hex )

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex

: c>hex  ( c -- n )
  \ Convert a character to its hexadecimal value.
  30 - dup 9 > if  7 -  then  ;

decimal

( '. ) \ character prefix

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 1 width !

: '.  ( -- n )
  \ leave ascii character; example: 'a leaves 0x41
  here 2 + c@ [compile] literal  ; immediate

width ! decimal

( $.. $.... ) \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

width @  1 width !

: $..  ( -- n )
  \ leave hex number; example: $0a leaves 0x0A
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  [compile] literal  ; immediate

: $....  ( -- n )
  \ leave 16-bit hex number; example: $0aff leaves 0x0AFF
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  [compile] literal  ; immediate

width ! decimal

( 0x.. 0x.... )  \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 2 width !

: 0x..  ( -- n )
  \ leave hex number; example: 0x0a
  here 3 + c@ c>hex 10 * here 4 + c@ c>hex +
  [compile] literal  ; immediate

: 0x....  ( -- n )
  \ leave hex number; example: 0x0aff
  0 here 7 + here 3 + do 10 * i c@ c>hex + loop
  [compile] literal  ; immediate

width ! decimal

( [false] [true] )

  \ 2015-06-17: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( ms )

  \ 2015-06-10: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( n -- )
  \ Wait n ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ XXX TODO
  \ Adapth this better version from v.Forth:
  \
  \ CODE MS
  \  POP DE|
  \  BEGIN,
  \   LDI A'| 171 N,
  \   BEGIN,
  \    NOP
  \    DEC A'|
  \   -UNTIL,
  \   DECX DE|
  \   LD A'| D|
  \  ORA E|
  \  -UNTIL,
  \ NEXT C;

( time@ time! time0 )

  \ 2015-06-10: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

[defined] sys-frames ?\ 23672 constant sys-frames

: time@  ( -- d )
  \ System frames counter (incremented every 20 ms).
  sys-frames @ [ sys-frames 2+ ] literal c@  ;

: time!  ( d -- )
  \ Set the system frames counter.
  [ sys-frames 2+ ] literal c! sys-frames !  ;

: time0  ( -- )
  \ Reset the system frames counter.
  0. time!  ;

( i' )

code i'  ( R: n x -- n x ) ( -- n )

  \ Copy the last but one value from the return stack (which
  \ within a `DO`-`LOOP` is the loop limit).

  2A c, rp ,  \ ld hl,(return_stack_pointer)
  23 c,       \ inc hl
  23 c,       \ inc hl
  5E c,       \ ld e,(hl)
  23 c,       \ inc hl
  56 c,       \ ld d,(hl)
  D5 c,       \ push de
  dd c, e9 c, \ jp (ix)

  end-code

  \ vim: filetype=soloforth
