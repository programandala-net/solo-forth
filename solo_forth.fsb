( Solo Forth library )

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

\ This file is the library of Solo Forth,
\ and the skeleton to build applications in Solo Forth.

\ Last modified: 201509012207

\ ------------------------------------------------------------
\ Acknowledgements

\ See <AKNOWLEDGMENTS.adoc>.

\ ------------------------------------------------------------
\ License

  \ Copying and distribution of this
  \ file, with or without modification,
  \ are permitted in any medium without
  \ royalty provided the copyright
  \ notice, the aknowledgments file and
  \ this notice are preserved.  This file
  \ is offered as-is, without any
  \ warranty.

  \ ------------------------------------------------------------
  \ History

  \ http://programandala.net/en.program.solo_forth.history.html

( ) \ scr 1 -- testing load screen

3 load
require decode
require dump
decode dump

  \ }}} =======================================================
  \ Require {{{

( require ) \ scr 2

  \ This screen must be at a fixed location.

: reload  ( -- )  scr @ load  ;

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
  \ Does the string ca1 len1 contains the string ca2 len2?

2variable locatable  scr/disk 1 locatable 2!

: located  ( ca len -- screen | false )
  locatable 2@ do
    0 i (line) 2over contains if  2drop i unloop exit  then
    \ break-key? ?exhaust
  loop  2drop false  ;

: locate  ( "name" -- screen | false )
  parse-name save-string located  ;

-->

( require ) \ scr 3

: do-required  ( ca len -- )
  located dup 0= 29 ?error load  ;

: do-require  ( "name" -- )
  parse-name save-string do-required  ;

: required  ( ca len -- )

  \ XXX FIXME usually the final check
  \ fails because the saved string has
  \ been overwritten

  \ XXX OLD
  \ 2dup undefined?
  \   if  2dup do-required  then
  \ 2dup undefined? warnings @ and
  \   if  type 28 warning exit  then  2drop  ;

  \ XXX NEW
  2dup undefined?  if  do-required  else  2drop  then  ;

: require  ( "name" -- )
  parse-name save-string required  ;

  \ }}} =======================================================
  \ Error messages {{{

( Error messages 1..15 ) \ scr 4

\ Error #01: Not a word nor a number.
\ Error #02: Stack empty.
  \ XXX not used:
\ Error #03: Dictionary full.
\ Error #04: Warning: Is not unique.
\ Error #05: Word not found.
  \ XXX not used:
\ Error #06: Out of disk range
\ Error #07: Full stack.
\ Error #08:
\ Error #09: Trying to load from screen 0.
\ Error #10:
\ Error #11:
\ Error #12:
\ Error #13:
\ Error #14:
\ Error #15: Deferred word is uninitialized.

( Error messages 16..30 )  \ scr 5

\ Error #16:
\ Error #17: Compilation only, use in definition.
\ Error #18: Execution only.
\ Error #19: Conditionals not paired.
\ Error #20: Definition not finished.
\ Error #21:
\ Error #22: Use only when loading.
\ Error #23: Off current editing screen.
\ Error #24:
  \ XXX TMP -- not used yet:
\ Error #25: Unsupported tape operation.
  \ XXX TMP -- not used yet:
\ Error #26: Unsupported disk operation.
\ Error #27: Source file needed.
\ Error #28: Warning: Not present, though required.
\ Error #29: Required, but not located.
  \ Assembler:
\ Error #30: Relative jump too long.

( Error messages 31..46 )  \ scr 6

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

  \ XXX useless:
\ G+DOS error #00: Nonsense in G+DOS
  \ XXX useless:
\ G+DOS error #01: Nonsense in GNOS
  \ XXX useless:
\ G+DOS error #02: Statement end error
  \ XXX useless:
\ G+DOS error #03: Break requested
\ G+DOS error #04: Sector error
\ G+DOS error #05: Format data lost
\ G+DOS error #06: Check disk in drive
  \ XXX useless:
\ G+DOS error #07: No +SYS file
\ G+DOS error #08: Invalid file name
  \ XXX useless:
\ G+DOS error #09: Invalid station
\ G+DOS error #10: Invalid device
  \ XXX useless:
\ G+DOS error #11: Variable not found
\ G+DOS error #12: Verify failed
\ G+DOS error #13: Wrong file type
  \ XXX useless:
\ G+DOS error #14: Merge error

( Error messages 47..62 )  \ scr 7

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ G+DOS error #15: Code error
  \ XXX useless:
\ G+DOS error #16: Pupil set
\ G+DOS error #17: Invalid code
\ G+DOS error #18: Reading a write file
\ G+DOS error #19: Writing a read file
  \ XXX useless:
\ G+DOS error #20: O.K. G+DOS
  \ XXX useless:
\ G+DOS error #21: Network off
\ G+DOS error #22: Wrong drive
\ G+DOS error #23: Disk write protected
\ G+DOS error #24: Not enough space on disk
\ G+DOS error #25: Directory full
\ G+DOS error #26: File not found
\ G+DOS error #27: End of file
\ G+DOS error #28: File name used
  \ XXX useless:
\ G+DOS error #29: No G+DOS loaded

( Error messages 63..78 )  \ scr 7

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

  \ XXX useless:
\ G+DOS error #30: STREAM used
  \ XXX useless:
\ G+DOS error #31: CHANNEL used


  \ }}} =======================================================
  \ Strings {{{

( place +place )

  \ [Code from Afera.]

: place  ( ca1 len1 ca2 )  2dup c! 1+ smove  ;

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;

( /string )

require -rot

  \ [Code from DZX-Forth.]

: /string  ( ca1 len1 n -- ca2 len2 )
  rot over + -rot -  ;
  \ dup >r - swap r> + swap  ;  \ alternative definition

  \ XXX TODO -- in Z80
  \ pop de                  ; n
  \ pop hl                  ; u1
  \ call hl_minus_de_to_hl  ; hl=u2
  \ ex (sp),hl              ; (sp)=u2 hl=ca1
  \ add hl,de               ; hl=ca2
  \ ex (sp),hl              ; (sp)=ca2 hl=u2
  \ _push_hl_jp_next

( s' )

  \ [Code from Afera.]

  \ doc{
  \
  \ s'  ( compilation: "text<'>" -- ) ( run-time:  -- ca len )
  \
  \ }doc

: s'  ( compilation: "ccc<'>" -- ) ( run-time:  -- ca len )
  [char] ' (s)  ; immediate

  \ }}} =======================================================
  \ Data stack {{{

( -rot )

  \ [Code adapted from Afera.]

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,      \ pop hl / pop de
  E3 c,            \ ex (sp),hl
  EB c,            \ ex de,hl
  C3 c, pushhlde , \ jp pushhlde

  end-code

( 2nip )

  \ [Code from Afera; original code from DZX-Forth.]

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ }}} =======================================================
  \ Return stack {{{

( n>r nr> )

  \ XXX TODO

code n>r  ( x0..xn n -- ) ( R: -- x0..xn n )

  \ exx
  \ pop bc
  \ ld (count),bc
  \ do:
  \ ld a,b
  \ or c
  \ jp z,end
  \ pop de
  \ dec hl
  \ ld (hl),d
  \ dec hl
  \ ld (hl),e
  \ jp do
  \ count: equ $+1
  \ ld hl,0
  \ ld (rp),hl
  \ end:
  \ exx
  \ jpnext

  end-code

code nr>  ( -- x0..xn n ) ( R: x0..xn n -- )

  \ exx
  \ ld hl,(rp)
  \ ld b,(hl)
  \ inc hl
  \ ld c,(hl)
  \ inc hl
  \ do:
  \ ld a,b
  \ or c
  \ jp z,end
  \ ld e,(hl)
  \ inc hl
  \ ld d,(hl)
  \ inc hl
  \ push de
  \ jp do

  end-code

  \ }}} =======================================================
  \ Graphics {{{

( emmited )

  \ ; ----------------------------------------------
  \   _code_header emitted_,'EMITTED'

  \   ; [Code adapted and modified from the ZX Spectrum ROM routine
  \   ; S-SCRN$-S at 0x2535.]

  \ ; doc{
  \ ;
  \ ; emitted  ( col row -- n | 0 )
  \ ;
  \ ; Return the ordinal number _n_ (first is 1) of the character
  \ ; printed at the given screen coordinates, or 0 if no character
  \ ; can be recognized on that position of the screen.
  \ ;
  \ ; This word must be configured by `emitted-charset` and
  \ ; `#emitted-chars`, that set the address of the first character
  \ ; and the number of characters to compare with. By default the
  \ ; printable ASCII chars of the ROM charset are used.
  \ ;
  \ ; The result _n_ is the ordinal number (first is 1) of the
  \ ; recognized char in the specified charset. Example: with the
  \ ; default configuration, a recognized space char would return 1;
  \ ; a "!" char, 2; a "A", 34...
  \ ;
  \ ; This word is meant to be used with user defined graphics.
  \ ;
  \ ; }doc

  \   ; XXX TODO improve the result
  \   ;
  \   ; XXX TODO move to the disk
  \   ;
  \   ; XXX TODO rename?: `ocr`, `recognized`, `on-xy`, `xy-char`?
  \   ; The reasen is name clash with the fig-Forth `out` counter,
  \   ; that was going to be called `emitted` or `#emitted`.

  \   pop de ; row
  \   pop hl ; col
  \   push bc ; save the Forth IP
  \   ld b,l ; column
  \   ld c,e ; row
  \   ld hl,(emitted_charset_pfa) ; address of first printable char in the charset
  \   ld a,c  ; row
  \   rrca
  \   rrca
  \   rrca ; multiply by 0x20
  \   and  %11100000
  \   xor  b ; combine with column (0x00..0x1F)
  \   ld  e,a ; low byte of top row = 0x20 * (line mod 8) + column
  \   ld  a,c  ; row is copied to a again
  \   and  0x18
  \   xor  0x40
  \   ld  d,a ; high byte of top row = 64 + 8*int (line/8)
  \   ; de = screen address
  \   ld a,(hash_emitted_chars_pfa) ; number of chars in the charset
  \   ld b,a

  \ emitted.do:
  \   push  bc  ; save the characters count
  \   push  de  ; save the screen pointer
  \   push  hl  ; save the character set pointer (bitmap start)
  \   ld  a,(de)  ; get first scan of screen character
  \   xor  (hl)  ; match with scan from character set
  \   jp z,emitted.match  ; jump if direct match found
  \   ; if inverse, a=0xFF
  \   inc  a  ; inverse? (if inverse, a=0)
  \   jp  nz,emitted.next_char  ; jump if inverse match not found
  \   ; inverse match
  \   dec  a  ; restore 0xFF
  \ emitted.match:
  \   ld  c,a  ; inverse mask (0x00 or 0xFF)
  \   ld  b,0x07  ; count 7 more character rows
  \ emitted.scans:
  \   inc  d  ; next screen scan (add 0x100)
  \   inc  hl  ; next bitmap address
  \   ld  a,(de)  ; screen scan
  \   xor  (hl)  ; will give 0x00 or 0xFF (inverse)
  \   xor  c  ; inverse mask to include the inverse status
  \   jp  nz,emitted.next_char  ; jump if no match
  \   djnz  emitted.scans  ; jump back till all scans done

  \   ; character match
  \   pop  bc  ; discard character set pointer
  \   pop  bc  ; discard screen pointer
  \   pop  bc  ; final count
  \   ld a,(hash_emitted_chars_pfa) ; number of chars in the charset
  \   sub  b ; ordinal number of the matched character (1 is the first)
  \   ld l,a
  \   jp emitted.end

  \ emitted.next_char:
  \   pop  hl  ; restore character set pointer
  \   ld  de,0x0008  ; move it on 8 bytes
  \   add  hl,de  ; to the next character in the set
  \   pop  de  ; restore the screen pointer
  \   pop  bc  ; restore the counter
  \   djnz  emitted.do  ; loop back for the 96 characters
  \   ; no match
  \   ld l,b ; zero

  \ emitted.end:
  \   pop bc ; restore the Forth IP
  \   ld h,0
  \   jp push_hl

  \ ; ----------------------------------------------
  \   _variable_header emitted_charset_,'EMITTED-CHARSET'

  \ ; doc{
  \ ;
  \ ; emitted-charset  ( -- a )
  \ ;
  \ ; Variable that holds the address of the first printable char in
  \ ; the charset used by `emitted`. By default it contains 0x3D00, the
  \ ; address of the space char in the ROM charset.
  \ ;
  \ ; }doc

  \   dw 0x3D00 ; address of the space in the ROM charset

  \ ; ----------------------------------------------
  \   _variable_header hash_emitted_chars_,'#EMITTED-CHARS'

  \ ; doc{
  \ ;
  \ ; #emitted-charset  ( -- a )
  \ ;
  \ ; Variable that holds the number of printable chars in the
  \ ; charset used by `emitted`. By default it contais 0x5F, the
  \ ; number of printable ASCII chars in the ROM charset.
  \ ;
  \ ; }doc

  \   dw 0x5F ; printable ASCII chars in the ROM charset

( pixel )

require pixel-add

  \ XXX TODO use z80-asm

code pixel  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel in the byte address 0..7
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, pixel-add ,       \ call pixel-add
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

( pixel-add )

require z80-asm

create pixel-add  ( -- a )

  \ This Z80 routine is an alternative to the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  a and  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \ clear carry (already clear) \ XXX TODO
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( pixel-add )

create pixel-add  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

( plot )

require pixel-add

code plot  ( xc yc -- )

  D9 c,               \ exx
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, pixel-add ,   \ call pixel-add
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ [Author of the original code: José Manuel Lazo.
  \ Published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg]

require pixel-add  require z80-asm

code set-pixel  ( xc yc -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  pixel-add call
  a b ld  b inc  1 a ld#
  begin  a rrc  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ [Based on code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg]

require pixel-add  require z80-asm

code reset-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  pixel-add call
  a b ld  b inc  1 a ld#
  begin  a rrc  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ [Based on code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg]

require pixel-add  require z80-asm

code toggle-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  pixel-add call
  a b ld  b inc  1 a ld#
  begin  a rrc  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( pixel? )

require pixel-add  require z80-asm

code pixel?  ( xc yc -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  pixel-add call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true cfa>pfa jpnz
  ' false cfa>pfa jp
  end-code

( pixel? )

  \ XXX OLD -- version for true=1

require pixel-add

code pixel?  ( xc yc -- f )
  \ f = 1 or 0
  E1 c, D1 c, C5 c,       \ pop hl / pop de / push bc
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c,   \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate
  CD c, pixel-add ,       \ call pixel-add
  \ hl = screen address
  \ a = pixel position in hl
  40 07 + c, 04 c, 7E c,
                          \ ld b,a
                          \ inc b
                          \ ld a,(hl)
  \ rotate:
  07 c,  10 c, FD c,      \ rlca / djnz rotate
  E6 c, 01 c,             \ and 1
  \ finish:
  26 c, 00 c,  68 07 + c, \ ld h,0 / ld l,a
  C1 c,  C3 c, pushhl ,   \ jp pushhl
                          \ pop bc
  end-code

( rdraw )

  \ [Code adapted from Spectrum Forth-83's `DRAW`.]

require z80-asm

code rdraw  ( x y -- )

  \ Draw a line relative to the current coordinates.
  \
  \ x y = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  7 b bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  7 h bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

( adraw ) \ from Abersoft Forth

  \ [Code adapted from Abersoft Forth's `DRAW`.]

require plot

2variable x1  2variable incx  2variable y1  2variable incy

  \ System variables used:
  \   23677 = COORDX
  \   23678 = COORDY

: adraw  ( x y -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  23678 c@ ( y0 ) dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )
  23677 c@ ( x0 ) dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )
  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ m/mod dnegate
  else  0 swap r@ m/mod  then
  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ m/mod dnegate
  else  0 swap r@ m/mod  then
  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

( attr )

require attr-addr

code attr ( line col -- b )

  E1 c,  D1 c,
    \ pop hl ; l = col
    \ pop de ; e = line
  50 05 + c,
    \ ld d,l ; d = col
  6E c,  26 c, 00 c,  pushhl,
    \ ld l,(hl) ; pick up the colour attribute.
    \ ld h,0
    \ jp pushhl

  end-code

( attr-addr )

create attr-addr  ( -- a )

  \ Modified version of the ROM routine at 0x2583.

  \ XXX FIXME

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  78 03 + c, \ ld a,e  ; line to a 0x00..0x17   (max 00010111)
  0F c, 0F c, 0F c, \ rrca | rrca | rrca  ; rotate bits left
  58 07 + c, \ ld e,a ; store in d as an intermediate value.

  E6 c, E0 c, \ and 0xE0 ; pick up bits 11100000 (was 00011100)
  A8 02 + c, \ xor d ; combine with column 0x00..0x1F
  68 07 + c, \ ld l,a ; low byte now correct.

  78 03 + c, \ ld a,e ; bring back intermediate result from d

  E6 c, 03 c,  EE c, 58 c,
    \ and 0x03 ; mask to give correct third of screen
    \ xor 0x58 ; combine with base address.
  60 07 + c, \ ld h,a ; high byte correct.

  C9 c,  \ ret

  end-asm

( emitted? )

  \ XXX TODO -- rewrite after the planned method for a double
  \ character set: `ascii-printed`, `udg-printed` and its
  \ combination `printed`, or similar names. Modify the charset
  \ system variable.

code emitted? ( row col -- f )

  \ pop hl
  \ pop de
  \ push bc
  \ ld c,e
  \ ld b,l
  \ call rom_s_scrn_s_0x2538
  \ call rom_stack_fetch
  \ ld a,(de)
  \ ld h,0x00
  \ ld l,a
  \ pop bc
  \ ; XXX TODO -- check if necessary after those ROM routines:
  \ ld ix,next ; restore
  \ jp push_hl

  end-code

( circle )


  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

  \ XXX TODO

require z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot cfa>pfa call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( x y radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ [Code adapted from a routine written by Pablo Ariza,
  \ published in Microhobby Especial, issue 7 (1987-12), page 46:
  \ <http://microhobby.org/mhes7.htm>.]

require z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ [Code adapted from a routine written by Javier Granadino,
  \ published in Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg]

require z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ [Code adapted from a routine written by Juan José Rivas,
  \ published in Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg]

require z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
            begin   m rrc  hl decp  6 h bit  z until
            step

  bc pop  jpnext

  end-code

( clsx )

  \ Clear the screen by rotating all bytes
  \ of the bitmap.

  \ [Code adapted from a routine written by Anselmo Moreno Lorente,
  \ published in Microhobby, issue 121 (1987-03), page 7:
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg]

require z80-asm

code clsx  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( scroll-1px-right )

  \ [Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg]

  \ XXX FIXME

require z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
          m srl  hl incp  \ first char column
          1F b ld#  \ remaining columns
          begin   m rr  hl incp  step
          c dec
          z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ [Code adapted from a routine written by Iván Sansa,
  \ published in Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg]

require z80-asm

create (scroll-1px-up)  ( -- )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  ' (scroll-1px-up) cfa>pfa call
  bc pop  jpnext  end-code

( xy-scroll )

  \ [Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published in Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg]

  \ XXX FIXME

require z80-asm

code xy-scroll  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin

      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
      z until

    step

  bc pop  end-code

( horizontal-curtain )

  \ [Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg]

require z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the top and bottom
  \ rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ [Code adapted from a routine written by Alejandro Mora,
  \ published in Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg]

require z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  \ XXX FIXME crash!

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

  \ }}} =======================================================
  \ FZX fonts {{{

  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \
  \ Converted for Solo Forth
  \ by Marcos Cruz (programandala.net)

  \ 2015-08-31: Start.

( fzx-test )

  \ XXX TMP for debugging

require fzx-emit  require <file

create font  2048 allot
1 drive!  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) cfa>pfa hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

  \ require defer!  ' fzx-emit ' emit defer!

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into this `unresolved`. This saves a definition.
  \ `dup` and `drop` are used to pass the compiler security
  \ that checks the stack is balanced at the end of the
  \ definition.

-->

( fzx-emit )

require z80-asm  require scroll-1px-up

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld
    ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change fzx-flags to expect line
    \ value next time and return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop  \ IX = font addresss

  0D cp#  \ carriage return?
  0 jpz here 2- 0 unresolved ! \ to NEWLINE

  \ CHK_CHAR:
  a dec  \ now A = char - 1
  2 ix cpx  \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc  \ now A = char - 31
  a l ld  0 h ld#
  hl de ldp
  hl addp
  de addp  \ now HL = (char - 31) * 3
  bc addp  \ now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld  \ now DE = offset
  m xor
  rlca  rlca
  a c ld  \ now C = kern
-->

( fzx-emit )

  hl push
  de addp
  hl decp  \ now HL = char definition address
  exsp  \ now HL references offset/kern in char table
  hl incp  \ now HL references shift/width in char table
  a xor
  rld  \ now A = char shift
  af push
  rld  \ now A = (width - 1)
  0 sta  here 2- 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width
-->

( fzx-emit )


  000E de ldp#  \ same as "0 c ld#"
  nc if
    234E de ldp#  \ same as "m c ld" and "hl incp"
  then
  \ NARROW_CHAR:
  0 de stp  here 2- 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  \ now HL references next char offset
  m a ld  \ now A = LSB of next char offset
  l add
  a e ld  \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#
  m a ld
  c sub  \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld

  0 fta  here 2- 3 unresolved !  \ now A = (width - 1)
    \ fetch the width at width1
  m add  \ now A = (width - 1) + column
  0 callc here 2- 4 unresolved ! \ newline callc
    \ if char width won't fit then move to new line \ XXX TODO

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX TODO -- adapt this error
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  \ XXX FIXME halt?
  retnc  \ XXX NEW

  af pop  \ now A = shift

  BF add#  \ range 0-191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call
    \ call PIXEL-ADD + 2 to calculate screen address
  exaf  \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ to CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  \ now A = zero (since there's no 3rd byte)
    exsp  \ now HL = screen address
    exaf  \ now A = (col % 8), A' = 0
    nz if
      a b ld  \ now B = (col % 8)
      exaf    \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ here >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push  ix push
  l a ld  ' (fzx-emit) cfa>pfa call
  ix pop  bc pop  jpnext

  end-code

  \ }}} =======================================================
  \ Sound 128K {{{

( !sound vol shutup noise )

  \ [Code from Spectrum Forth-83.]
  \ XXX TODO finish, document and test

require !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

require ms  vocabulary music  current @  also music definitions

  \ [Code from Spectrum Forth-83.]
  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b

-->

( music )

  \ [Code from Spectrum Forth-83.]
  \ XXX TODO finish, document and test

: l  ( n -- )  len !  ;
: o+  ( -- )  octave @ 2 * octave !  ;
: o-  ( -- )  octave @ 2 / octave !  ;
: r  ( -- )  tempo @ len @ * ms  ;
: >>  ( -- )  1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )  1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: )

  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan José Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

require !p

[defined] sound-register-port
  ?\ 65533 constant sound-register-port
[defined] sound-write-port
  ?\ 49149 constant sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

  \ XXX TODO

: sound:  ( b0 ... b13 "name" -- )
  create  here 1- 14 allot here -1 do  i c!  -1 +loop  ;

( play )

  \ Z80 version of the previous `play`.

require z80-asm

[defined] sound-register-port
?\ 65533 constant sound-register-port
[defined] sound-write-port
?\ 49149 constant sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter train )

  \ Sounds to be played with `play`.

  \ [`waves` and `shoot` are
  \ adapted from code written by Juan José Ruiz,
  \ published in Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg]

create waves  ( -- a )
  0 c,  0 c,  0 c,  0 c,  0 c,  0 c,  7 c,
  71 c,  20 c,  20 c,  20 c,  0 c,  38 c,  14 c,

create shoot  ( -- a )
  10 c,  0 c,  177 c,  0 c,  191 c,  0 c,  31 c,
  71 c,  20 c,  20 c,  20 c,  92 c,  28 c,  3 c,

  \ [`helicopter` and `train` are
  \ adapted from code written by José Ángel Martín,
  \ published in Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg]

create helicopter  ( -- a )
  200 c,  15 c,  200 c,  15 c,  200 c,  15 c,  0 c,
  7 c, 23 c,  23 c,  23 c,  255 c,  1 c,  12 c,

create train  ( -- a )
  100 c,  120 c,  48 c,  97 c,  12 c,  200 c,  55 c,
  15 c,  9 c,  11 c,  55 c,  180 c,  4 c,  8 c,

( sound effects )

  \ Sounds to be played with `play`.

  \ Data extracted a program written by Juan José Rosado Recio,
  \ published in Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

require sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop

  decimal

( rain water-drops )

  \ Sounds to be played with `play`.

  \ Data extracted from a program written by Carlos Ventura,
  \ published in Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX this effects don't sound fine, but the data is right

create rain  ( -- a )
  44 c, 24 c, 6 c, 6 c, 7 c, 3 c, 3 c,
  5 c, 44 c, 6 c, 3 c, 5 c, 3 c, 3 c,

create water-drop  ( -- a )
  20 c, 83 c, 94 c, 39 c, 0 c, 8 c, 31 c,
  71 c, 23 c, 23 c, 22 c, 90 c, 0 c, 0 c,

  \ }}} =======================================================
  \ Sound 48K {{{

( bleep )

  \ [Code modified from Abersoft Forth.]

code bleep  ( n1 n2 -- )
  \ Produce a tone in the noise maker.
  \ n1 = duration
  \ n2 = pitch
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5 ,        \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)
  end-code

( beep>bleep )

  \ [Code from v.Forth.]

  \ XXX TODO test

: beep>bleep  ( freq duration -- n1 n2 )
  \ n1 = duration
  \ n2 = pitch
  over 1000 */ swap
  4375 100 rot */ 30 -  ;

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.
  \ Author of the original code: Álvaro Corredor Lanas.
  \ Published in Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

require z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published in Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

require z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  c a ld  b or
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.
  \ Author of the original code: Líder Software.
  \ Published in Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

require z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  h a ld  l or
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Memory access {{{

( exchange )

: exchange  ( n1 a -- n2 )  dup @ rot rot !  ;

( source )

: source  ( -- a len )  \ ANS Forth
  blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

  \ }}} =======================================================
  \ Operators {{{

( under+ )

: under+  ( n1 n2 n3 -- n4 n3 )  >r + r>  ;

( within between )

  \ [Code from DZX-Forth.]

: within  ( n1|u1 n2|u2 n3|u3 -- f )
  over - >r - r> u<  ;

require -rot

: between  ( n1|u1 n2|u2 n3|u3 -- flag )
  over - -rot - u< 0=  ;

( d0= d0< d< du< dmin dmax )

  \ [Code from DZX-Forth.]

: d0=  ( d -- f )  or 0=  ;

: d0<  ( d -- f )  nip 0<  ;

; d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;

: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;

: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;

( lshift )

  \ [Code from DZX-Forth.]

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

  \ XXX TODO

code rshift  ( x1 u -- x2 )

  \ [Code from DZX-Forth.]

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  \ or a
  \ ld a,h
  \ call sra_hl.1 ; XXX TODO this is in the kernel
  C3 c, ,         \ jp begin

  end-code

( Symmetric-division operators )

  \ [From the ANS Forth documentation.]

  \ XXX TODO `sm/rem` not ready yet

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( Floored-division operators )

  \ [From the ANS Forth documentation.]

  \ XXX TODO `fm/mod` not ready yet

: /_mod  ( n1 n2 -- n3 n4)  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3)  /_mod nip  ;

: _mod  ( n1 n2 -- n3)  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5)  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( fig-Forth +- d+- )

  \ XXX TODO -- still needed in the kernel

  \ }}} =======================================================
  \ Conditional compilation {{{

( [if] [else] [then] )

[defined] s=  ?\  : s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

: [else]  ( "..." -- )

  1 begin   parse-name 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

  \ }}} =======================================================
  \ G+DOS {{{

( ufia )

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1 \ drive: 1 or 2
ufia 1+   constant fstr1 \ program number
ufia 2+   constant sstr1 \ stream number
ufia 3 +  constant device \ device: "D" or "d"
ufia 4 +  constant nstr1 \ directory description
ufia 5 +  constant nstr2 \ file name
ufia 15 + constant hd00  \ file type
ufia 16 + constant hd0b  \ file length
ufia 18 + constant hd0d  \ file start address
  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

char d device c! \ "d" or "D"
2 sstr1 c! \ stream 2
1 dstr1 c! \ drive 1

  \ These variables hold a copy of the HD0B and HD0D UFIA
  \ fields. They are used by `(<DISK)`.
variable file-length
variable file-address

( File types and directory descriptions)

  \ File types

0 constant basic-filetype  1 constant data-array-filetype
2 constant string-array-filetype  3 constant code-filetype

  \ Directory descriptions

  01 constant basic-file      02 constant data-array
  03 constant string-array    04 constant code-file
  05 constant snapshot-48k    06 constant microdrive-file
  07 constant screens$-file   08 constant special-file
  09 constant snapshot-128k   10 constant opentype-file
  11 constant execute-file

( --hook-codes-- )

hex

33 constant hxfer  34 constant ofsm  35 constant hofile
36 constant sbyte  37 constant hsvbk 38 constant cfsm
39 constant pntp   3A constant cops  3B constant hgfile
3C constant lbyte  3D constant hldbk 3E constant wsad
3F constant sad    40 constant rest  41 constant heraz
42 constant cops2  43 constant pcat  44 constant hrsad
45 constant hwsad  46 constant otfoc 47 constant patch

decimal

: --hook-codes-- ;

( ior>error ?dos-error )

: ior>error  ( ior -- f n )

  \ Convert a DOS ior to a Forth error number.

  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: ZX Spectrum error; unset: DOS error
  \ f = error?
  \ n = error number:
  \     n<0  = ZX Spectrum error number (negative)
  \     n>99 = DOS error number (plus 100)

  dup 1 and negate  \ error?
  swap 255 /        \ error code
                    \ XXX TODO `flip 255 and` instead
  dup 128 and       \ ZX Spectrum error?
  \ XXX FIXME -- BASIC errors are not properly calculated
  if  negate  else  31 +  then   ;

: ?dos-error  ( ior -- )
  \ ior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: ZX Spectrum error; unset: DOS error
  ior>error ?error  ;

( drive@ drive! )

require z80-asm  require --hook-codes--

code drive@  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  ix push  \ save the Forth registers
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  pusha jp  end-code

code drive!  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  ix push  \ save the Forth registers
  l a ld  21 hook   \ select drive in a
  ix pop  bc pop    \ restore the Forth registers
  jpnext  end-code

( -file )

require z80-asm  require ufia  require --hook-codes--

code (-file)  ( -- ior )

  \ Delete a disk file using the data hold in UFIA.

  bc push  ix push  \ save the Forth registers
  ufia ix ldp#
  heraz hook \ erase the file
  ix pop  bc pop  \ restore the Forth registers
  af push
  jpnext
  end-code

require ior>error

: -file  ( ca len -- f n )
  \ Delete a disk file.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  filename>ufia (-file) ior>error  ;

( -filename filename! >ufia filename>ufia )

require ufia  require drive@

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  drive@ dstr1 c!  ;

1 drive!  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

require z80-asm  require ufia  require --hook-codes--
require >ufia  require ior>error

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  ix push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  ix pop  bc pop  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) ior>error  ;

( <file )

require z80-asm  require ufia  require --hook-codes--
require >ufia  require ior>error

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  ix push  \ save the Forth registers

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  ix pop  bc pop  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) ior>error  ;

( file? )

require ufia  require filename!  require --hook-codes--

code (file?)  ( -- f )

  bc push  ix push  \ save the Forth registers
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  ' true cfa>pfa jpz
  ' false cfa>pfa jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

require z80-asm  require ufia  require --hook-codes--
require filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ hex 3E01 constant ufia1 decimal
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  ix push  exx
    \ Get the parameter in hl' and save the Forth registers

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  exx  l a ld  24B5 call  168E call
    \ 24B5 = CAT_RUN (input: cat type in the a register)
    \ 168E = BORD_REST (restore the border)

  E7 out  ix pop  bc pop  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( ca len -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( ca len -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr c!

( @dos )

require z80-asm  require --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  ix push  \ save the Forth registers
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

require z80-asm  require --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  ix push  \ save the Forth registers
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

require z80-asm  require --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  ix push  \ save the Forth registers
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  jpnext
  end-code

( !dos )

require z80-asm  require --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  ix push  \ save the Forth registers
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

require z80-asm  require --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  ix push  \ save the Forth registers
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

require z80-asm  require --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  ix push  \ save the Forth registers
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ ix pop  bc pop  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

require z80-asm  require --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  ix push  \ save the Forth registers
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

require z80-asm  require --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  ix push  \ save the Forth registers
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  ix pop  bc pop  \ restore the Forth registers
  jpnext
  end-code

  \ }}} =======================================================
  \ Disk blocks {{{

( update flush )

: update  ( -- )

  \ doc{
  \
  \ update  ( -- )  \ ANS-Forth
  \
  \ Mark the most recently referenced block as altered. The
  \ block will subsequently be transferred automatically to
  \ disk should its buffer be required for storage of a
  \ different block.
  \
  \ }doc

  disk-buffer @
  [ base @ hex ] 8000 [ base ! ] or
  disk-buffer !  ;

: flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )  \ ANS Forth
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ }doc

  \ }}} =======================================================
  \ Tape files {{{

  \ XXX TODO From Afera.

  \ }}} =======================================================
  \ Tools {{{

( transient[ )

  \ XXX TODO -- Finish.

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  \ Start transient code, reserving u bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - dp !  ;

: ]transient  ( -- )

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.

  old-dp @ dp !  old-np @ np !  ;

: -transient  ( -- )

  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.

  old-voc-link @ voc-link !

  \ Store the nfa of the latest word created before compiling
  \ the transient code, into the lfa of the first word created
  \ after the transient code was finished by `]transient`.

  \ XXX TODO

  old-latest @ old-np @ cfap>lfa !n  ;

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( hex. hexb. dhex. <hex hex> )

  \ [Code adapted from lina.]

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: dhex.    ( d -- )  8 (dhex.)  ;
: hex.     ( n -- )  s>d 4 (dhex.)  ;
: hexb.    ( b -- )  s>d 2 (dhex.)  ;

( binary bin. binb. dbin. <bin bin> )

[defined] base'  ?\ variable base'

base @ decimal
[defined] binary  ?\ : binary  ( -- )  2 base !  ;
base !

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  bin{ (d.) }bin type space  ;
: dbin.    ( d -- )  32 (dbin.)  ;
: bin.     ( n -- )  s>d 16 (dbin.)  ;
: binb.    ( b -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  \ XXX TODO use `?do` instead of `if` when available
  dup if
    bounds do
      i c@ 127 and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

( dump )

require break-key?  require hex.  require ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: dump  ( a len -- )
  7 + -8 and 8 / 0
  \ XXX TODO use `?do` instead of `if` when available
  2dup <> if
    do
      cr dup hex.
      8 0 do  i over + @ flip hex.  2 +loop
      \ 16 0 do  i over + c@ hexb.  loop
      dup bs 8 ascii-type
      break-key? if  exhaust  then
    8 + loop
  else  2drop  then  drop  ;

( decode )

  \ [Code adapted and improved from Afera.]

  \ Variables, indentation and pause control

forth definitions decimal

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-compile    ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal    ( a1 -- a2 )  2+ dup @ .  ;

: decode-cliteral   ( a1 -- a2 )  2+ dup c@ . 1-  ;

: decode-branch     ( a1 -- a2 )  2+ dup @ u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode )

  \ Special cases dispatcher

require case

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof
    ['] (loop)    of  decode-branch     endof
    ['] (+loop)   of  decode-branch     endof
    ['] (.")      of  decode-dot-quote  endof
  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( cfa -- f )
  \ Is the given cfa the end of a definition?
  dup  ['] ;s =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  pfa>cfa @ ['] : @ =  ;

-->

( decode )

  \ Main code

: (decode)  ( pfa --- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>cfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp0 @ sp! quit  endof \ q
                      bl  of  drop            endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined if  cfa>pfa  0 decode-level !  (decode)
          else  drop  5 error  then  ;

( list )

require break-key?

: list  ( n -- )

  \ List screen number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    break-key? if  exhaust  then
  loop cr  ;

( break-key? )

code break-key?  ( -- f )

  \ Is the Break key pressed?

  CD c, 1F54 ,              \ call rom_break_key
  D2 c, ' true cfa>pfa ,    \ jp nc,next
  C3 c, ' false cfa>pfa ,   \ jp z,next

  end-code

( index )

require break-key?

: index  ( n1 n2 -- )
  1+ swap do
    cr i 3 .r space 0 i .line
    break-key? if  exhaust  then
  loop  ;

( words )

  \ [Code adapted from Spectrum Forth-83.]

require break-key?

[defined] tab ?\  : tab  ( -- )  6 emit  ;

: words  ( -- )
  trail
  begin  dup 0<> break-key? 0= and  while
    dup id. tab  nfa>lfa @n
  repeat drop  ;

( words-like )

  \ [Code adapted from pForth.]

require break-key?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string ca1 len1 contains the string ca2 len2?

[defined] tab
  ?\  : tab  ( -- )  6 emit  ;

  \ XXX FIXME

: words-like  ( "name" -- )
  \ Print all words containing substring.
  parse-name 2dup uppers trail  ( ca len nfa )
  begin  dup 0<> break-key? 0= and  while
    dup >r
    nfa>string 2over 2swap contains if  r@ id. tab  then
    r> nfa>lfa @n
  repeat drop 2drop  ;

( where )

: where  ( -- )
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup b/scr / dup scr !
    ." Scr # " decimal . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s u.s )

  \ [Code from Afera. Original algorithm from v.Forth.]

: .depth  ( n -- )
  s>d <# [char] > hold #s [char] < hold #> type space  ;

: .s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ . -2 +loop  then  ;

: u.s   ( -- )
  depth dup .depth
  if  sp@ 2- s0 @ 2- do i @ u. -2 +loop  then  ;

( marker ) \ 2nd approach

  \ XXX TODO

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r
  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  set-order 0 do  2@ !  loop  ;

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".


( marker )

  \ XXX TODO

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nfa0..nfan | nfa )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nfa0..nfan | nfa -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nfa ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nfa1..nfan2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ dp !  ;

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

  \ }}} =======================================================
  \ XXX Misc {{{

( source )

: source  ( -- ca len )  \ ANS Forth
  \ XXX TODO
  blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

  \ }}} =======================================================
  \ Hardware {{{

( @p )

code @p  ( ca -- c )

  \ Input char _c_ from port _ca_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  C3 c, pushhl ,  \ jp pushhl
  end-code

( !p )

code !p  ( c ca -- )

  \ Output char _c_ to port _ca_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  end-code

  \ }}} =======================================================
  \ Turnkey {{{

( extend size system turnkey )

  \ XXX OLD
  \
  \ XXX WARNING -- Since name field addresses are saved in a
  \ memory bank, the best way to save a modified Forth system
  \ is to make a snapshot with the ZX Spectrum emulator;
  \ otherwise a multipart saving and loading would be needed.
  \ Anyway, these words are meant to save a Forth program, not
  \ the Forth system.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  latest 6 +origin !  \ top most word in `forth` vocabulary
  here 22 +origin !  \ `fence` init value \ XXX OLD obsolete
  here 24 +origin !   \ `dp` init value
  \ XXX TODO -- update also the names pointer
  \ `voc-link` init value:
  [ ' forth cfa>pfa 8 + ] literal 26 +origin !  ;

  \ size  ( -- u )
  \
  \ Size of the system.

: size  ( -- u )  here 0 +origin -  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.

: turnkey  ( cfa -- a len )  boot ! system  ;

  \ }}} =======================================================
  \ Double numbers {{{

( du.r u.r du. )

  \ [Code adapted from Spectrum Forth-83.]

: du.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;
\ : u.r  ( n1 n2 -- )  >r 0 r> du.r  ;
: du.  ( d -- )  0 du.r space  ;

  \ }}} =======================================================
  \ Number conversion and notation {{{

( >number )

require /string

  \ [Code from DZX-Forth.]

  \ XXX TODO -- Move to the kernel.

: >number  ( d1 ca1 len1 -- d2 ca2 len2 )
  begin   dup
  while   over c@ base @ digit
  while   >r 2swap r> swap base @ um* drop rot base @
          um* d+ 2swap 1 /string 1 dpl +!
  repeat then  ;

( number? )

  \ [Code from DZX-Forth.]

  \ XXX TODO -- adapt

  \ XXX FIXME -- it compiles (with compiler security off) but
  \ crashes

: number?  ( ca len -- d true | false )
  \ Convert a string to a double number.
  over c@ [char] - = over 0> and dup >r 1
  and /string over c@ [char] . > and 0 0
  2swap ?dup
  if
    >number dpl on dup
    if  1- over c@ [char] . - or  dpl off  then
    while
    then r> 2drop 2drop false
    else drop r> if  dnegate  then true
  then  ;

( b# d# h# )

  \ [Code adapted from eForth.]

  \ XXX TODO -- finish the conversion

: x# ( -- ) ( 'ccc' -- n | d )
  does> c@              \  new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( 'ccc' -- n | d )  2 c, x# immediate
create d# ( 'ccc' -- n | d ) 10 c, x# immediate
create h# ( 'ccc' -- n | d ) 16 c, x# immediate

( .b .d .h )

  \ [Code copied from eForth and modified.]

: base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

create bin.  ( n -- )   2 c, base.
create dec.  ( n -- )  10 c, base.
create hex.  ( n -- )  16 c, base.

( c>hex )

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex

: c>hex  ( c -- n )
  \ Convert a character to its hexadecimal value.
  30 - dup 9 > if  7 -  then  ;

decimal

( '. ) \ character prefix

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

hex  width @ 1 width !

: '.  ( -- n )
  \ leave ascii character; example: 'a leaves 0x41
  here 2 + c@ postpone literal  ; immediate

width ! decimal

( $.. $.... ) \ hex prefixes

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

require c>hex

hex width @  1 width !

: $..  ( -- n )
  \ leave hex number; example: $0a leaves 0x0A
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: $....  ( -- n )
  \ leave 16-bit hex number; example: $0aff leaves 0x0AFF
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( 0x.. 0x.... )  \ hex prefixes

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Original code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

require c>hex

hex  width @ 2 width !

: 0x..  ( -- n )
  \ leave hex number; example: 0x0a
  here 3 + c@ c>hex 10 * here 4 + c@ c>hex +
  postpone literal  ; immediate

: 0x....  ( -- n )
  \ leave hex number; example: 0x0aff
  0 here 7 + here 3 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width ! decimal

( #... #..... ) \ hex prefixes

  \ XXX FIXME it does not work anymore after the changes in the
  \ system.

  \ Inspired by code from:
  \   lina
  \   Copyright (c) 2000-2004 Albert van der Horst,
  \   The Netherlands
  \   Published under GPL

  \ XXX TODO

require c>hex

width @  1 width !

: #...  ( -- n )
  \ leave decimal number
  here 2 + c@ c>hex 10 * here 3 + c@ c>hex +
  postpone literal  ; immediate

: #.....  ( -- n )
  \ leave 16-bit decimal number
  0 here 6 + here 2 + do 10 * i c@ c>hex + loop
  postpone literal  ; immediate

width !

  \ }}} =======================================================
  \ Control structures {{{

( ?do )

  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ
  \ Draft by Rod Pemberton

  \ XXX TODO

: (do)  ( n1 n2 -- )  2>r  ;

: (?do) 2dup = if 2drop r> drop then  ;
  \ exit the calling word

: (loop) ;
  ( increments index -2nd item- on return stack)
  ( calculates flag for until )

: (+loop) ;

: do      postpone (do) postpone begin
  ; immediate

: ?do     postpone (?do) postpone (do) postpone begin
  ; immediate

: loop    postpone (loop) postpone until postpone unloop
  ; immediate

: +loop   postpone (+loop) postpone until postpone unloop
  ; immediate



  \ : unloop
  \   ( removes 2nd and 3rd return stack items )
  \   ( 1st return stack item is itc saved ip for unloop ) ;
  \ : i ( gets 2nd return stack item to data stack ) ;
  \ : j ( gets 4th ... ) ;
  \ : k ( gets 6th ... ) ;

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ Draft by Elisabeth Rather.

: do ( -- flag addr)
    postpone (do) 0  postpone begin ;  immediate

: ?do ( -- addr1 flag addr2)
    postpone (?do) postpone begin
    postpone (do) 1  postpone begin ;  immediate

  \ ...where (DO) and (?DO) are the run-time actions. (?DO)
  \ contains a forward branch which compile-time LOOP or +LOOP
  \ must resolve.   (BEGIN) leaves on the compile-time stack an
  \ address for LOOP or +LOOP to branch back to, and a flag.

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX TODO

variable ?do?

: exchange ( x1 addr -- x2 ) dup @ rot rot ! ;
: 2dup<> ( x1 x2 -- x1 x2 flag ) 2dup = 0= ;

: do
  postpone 2>r 0 ?do? exchange here
  ; immediate
: ?do
  postpone 2dup<> postpone if postpone do ?do? on
  ; immediate
: loop
  postpone (loop) , ?do? exchange if postpone then then
  ; immediate
: +loop
  postpone (+loop) , ?do? exchange if postpone then then
  ; immediate

( ?do )

  \ From:
  \ https://groups.google.com/forum/#!msg/comp.lang.forth/rtfm_yg5Kd4/pKijHsPDrIAJ

  \ XXX TODO

variable ?do?

: 2dup= ( x1 x2 -- x1 x2 flag ) 2dup = ;

: do
  ?do? @ ?do? off [compile] (do) here 0 , ; immediate

: ?do
  postpone 2dup= postpone if postpone do ?do? on
  ; immediate

: complete-?do ( x dest | x -- )
  ?do? @ if postpone then then ?do? ! ;

: loop postpone (loop) , complete-?do ; immediate

: +loop postpone (+loop) , complete-?do ; immediate

( j )

code j
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 2 cells , \ ld de,2*cell
  19 c,           \ add hl,de
  fetchhl,        \ jp fetchhl

  end-code

( k )

code k
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the third loop index.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 4 cells , \ ld de,4*cell
  19 c,           \ add hl,de
  fetchhl,        \ jp fetchhl

  end-code

( i' )

code i'  ( -- x )
         ( R: loop-sys -- loop-sys )

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,  \ ld hl,(return_stack_pointer)
  23 c,       \ inc hl
  23 c,       \ inc hl
  fetchhl,    \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 3 cells , \ ld de,3*cell
  19 c,           \ add hl,de
  fetchhl,        \ jp fetchhl

  end-code

( for step )

  \ [Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.]

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch cfa>pfa ,
    \ jp nz,branch_pfa ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( u -- )
  \
  \ Start of a `for step` loop, that will iterate _u+1_ times,
  \ starting with _u_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `i`.a
  \
  \ }doc

: step  ( -- )  postpone (step) <resolve  ; immediate

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

( case )  \ ANS Forth version

  \ [Code copied from the example provided in the ANS Forth
  \ documentation].

0 constant case immediate  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( -- )
  \ XXX TODO use `?do` when available
  postpone drop  \ discard case value
  0 do  postpone then  loop  ; immediate

( case )  \ fig-Forth version with compiler security

  \ This is the fig-Forth `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, adapted and commented.
  \
  \ Note: this version only works when the compiler security
  \ check config option is activated in the kernel.

: case
  \ Compilation: ( -- a case-id )
  \ Runtime: ( x -- )
  ?comp csp @ !csp 4  ; immediate

: of
  \ Compilation: ( case-id -- of-id )
  \ Run-time: ( x -- )
  \ Note: `postpone 0branch >mark` is used instead of `postpone
  \ if` because `if` leaves its id on the stack when compiler
  \ security is activated.
  \ XXX TODO use `if` when compiler security is removed.
  4 ?pairs
  postpone over  postpone =  postpone 0branch >mark
  postpone drop 5  ; immediate

: endof
  \ Compilation: ( of-id -- case-id )
  \ Run-time: ( -- )
  5 ?pairs  postpone branch >mark
            swap 2  postpone then  4  ; immediate

: endcase
  \ Compilation: ( a orig1..orign case-id -- 3
  \ Run-time: ( x -- )
  4 ?pairs
  postpone drop
  begin  sp@ csp @ <>  while  2 postpone then  repeat
  csp !  ;  immediate

( case )  \ fig-Forth version without compiler security

  \ This is the fig-Forth `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (no compiler
  \ security checks) and commented.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( ?dov dov loopv +loopv )

  \ [Code from vForth.]

  \ XXX TODO adapt

: dov  compile (do) csp @ !csp here 3  ;

: ?dov
  compile 2dup  compile (do)  compile <>
  postpone if
  2drop here swap 1 6  ; immediate

: (resolve)
  begin  sp@ csp @ -  while  2 postpone then  repeat  csp !  ;

: loopv
  postpone loop (resolve)  ;

: +loopv
  postpone +loop (resolve)  ;

( case: )

: case:  ( -- )
  \ Create a positional case word.
  create  ]
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;
  \ A positional case statement.  At runtime, the n-th word is
  \ executed, depending upon the value on the stack. No error
  \ checking.

( associative: )

  \ [Code adapted from F83.]

require -rot

: associative:  ( n -- )
  \ Create a table lookup word.
  \ n = number of entries in the table
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

( test-case: )

  \ XXX TMP

require case:

: zx0 ." zero"  ;
: zx1 ." one"  ;
: zx2 ." two"  ;

case: zx  ( n -- )  zx0 zx1 zx2  ;

3 associative: unzx  ( value -- n )  ' zx0 , ' zx1 , ' zx2 ,


  \ }}} =======================================================
  \ Time {{{

( ms )

[defined] sys-frames ?\ 23672 constant sys-frames

: ms  ( n -- )
  \ Wait n ms (miliseconds), with 20 ms precision.
  20 / sys-frames @ +
  begin  dup sys-frames @ u<  until drop  ;

  \ XXX TODO
  \ Adapth this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth:
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  b0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2b c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3e c, 00 c,  78 05 + c,  b0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1b c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( frames@ frames! frames0 )

[defined] sys-frames ?\ 23672 constant sys-frames

: frames@  ( -- d )
  sys-frames @ [ sys-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ sys-frames 2+ ] literal c! sys-frames !  ;
  \ Set the system frames counter.

: frames0  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

  \ }}} =======================================================
  \ Vocabularies {{{

( .context .current order vocs )

  \ [Code adapted from F83.]

: .context  ( -- )  context #vocs 0 do
                      dup @ ?dup if  pfa>nfa id.  then  cell+
                    loop drop  ;
  \ Display the search order currently in effect.

: .current  ( -- )  current @ pfa>nfa id.  ;
  \ Display the name of the `current` vocabulary.

: order  ( -- )
  cr ." context: " .context cr ." current: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

: vocs  ( -- )
  voc-link @
  begin  dup cell - pfa>nfa id.  @ dup 0= until  drop  ;
  \ List all of the vocabularies that have been defined so
  \ far, in the order of their definition (more recent first).

( get-order set-order )

  \ XXX TODO use the actual number of vocs in context, not
  \ the maximum

: (get-order)  ( n -- widn..wid1 n)
  \ Do get the search order.
  1- -1 swap do  context i cells + @  -1 +loop  ;

: get-order  ( -- 0 | widn..wid1 n)
  \ Get the search order.
  #vocs ?dup if  (get-order)  then  #vocs  ;

: (set-order)  ( widn..wid1 n -- )
  \ Do set a search order.
  0 do  context i cells + !  loop  ;

: set-order  ( -1 | 0 | widn..wid1 n -- )
  \ Set a search order.
  dup -1 =  if  drop only exit  then  -order
  ?dup if  (set-order)  then  ;


  \ doc{
  \
  \ set-order  ( -1 | 0 | widn..wid1 n -- )
  \
  \ Set the search order to the word lists identified by
  \ _widn..wid1_. Subsequently, word list _wid1_ will be
  \ searched first, and word list _widn_ searched last. If _n_
  \ is zero, empty the search order. If _n_ is minus one, set
  \ the search order to the implementation-defined minimum
  \ search order.
  \
  \ This word is defined in ANS Forth but its implementation in
  \ Solo Forth is not fully ANS Forth compliant.
  \
  \ }doc


  \ }}} =======================================================
  \ Random number generator {{{

( seed rnd random randomize )

  \ [Code adapted from Leo Brodie's code and Gforth.]

[defined] seed
?\ 23670 constant seed  \ system variable

: rnd  ( -- n )  seed @ 31421 * 6927 + dup seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

: randomize  ( n -- )  seed !  ;

  \ From vForth
  \ XXX TODO adapt and try
  \ : vrnd  ( n1 -- n2 )
  \   1+ 8195 23672 @ um* 1 0 d+
  \   16383 u/ drop dup seed !
  \   swap mod  ;

( xrnd )

  \ [Based on code written by José Manuel Lazo,
  \ published in Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg]

  \ XXX TODO try it

[defined] seed
?\ 23670 constant seed  \ system variable

code xrnd  ( -- x )

  \ Return a random number (0000..FFFF)

  seed hl ftp  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  d# 41 de ldp#  de addp
  seed hl stp
  jpnext
  end-code

( z88random )

  \ [Code adapted from Z88 CamelForth.]

[defined] seed
?\ 23670 constant seed  \ system variable

  \ XXX TODO Adapt.
: z88random  ( u1 -- u2 )
  20077 16838 seed @
  ud* 12345 0 d+ over seed !
  rot ud/mod 2drop  ;

( random-test )

require random  require set-pixel

: random-test  ( n -- )
  0 do  256 random 193 random set-pixel  loop  ;

  \ }}} =======================================================
  \ Deferred words {{{

( defer defer@ defer! defers action-of )

  \ [Code adapted from the Afera library.]

  \ XXX OLD -- moved to the kernel
  \ : (defer)  ( -- )  15 error  ;
  \   \ Default behaviour of an uninitialized deferred word: error.

  \ : defer  ( "name" -- )  create ['] (defer) , does> @ execute  ;
  \   \ Create a deferred word.

: defer@  ( cfa1 -- cfa2 )  cfa>pfa @  ;
  \ Return the cfa of the word currently associated with a
  \ deferred word.
  \ cfa1 = cfa of the deferred word
  \ cfa2 = cfa of the word it's associated with

: defer!  ( cfa1 cfa2 -- )  cfa>pfa !  ;

: defers  ( "name" -- )  ' defer@ ,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.

: action-of  ( Interpretation: "name" -- cfa )
             ( Compilation:    "name" -- )
             ( Runtime:        -- cfa )
  ' comp? if    postpone literal postpone defer@
          else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.

( <is> [is] is  )

  \ [Code adapted from the Afera library.]

: <is>  ( cfa "name" -- )  ' defer!  ;

: [is]  ( cfa "name" -- )
  ' postpone literal postpone defer!  ; immediate

: is  ( cfa "name" -- )
  comp? if  postpone [is]  else  <is>  then  ; immediate

  \ }}} =======================================================
  \ Assembler {{{

( z80-asm )

\ Z80 Assembler for Solo Forth

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).


  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< 1E ?error  ;
  \ Branch too long?

-->

( z80-asm -- words for defining the z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- words for defining the z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  create c, does>  ( bit r -- )
    ( bit r pfa ) CB c, c@ + swap 8* + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- words for defining the z80 instructions)

require -rot

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  create c, does>  ( bit rphl disp -- )
    ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;

  -->

( z80-asm -- opcodes)

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 ldhl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ zx Spectrum specific

CF m4 hook \ rst 8
D7 m1 prt  \ rst 0x16

-->

( z80-asm -- index register opcodes)

require -rot
[defined] 3dup
?\ : 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: >relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest orig -- )  1- swap >relresolve  ;
  \ Resolve a backward relative branch.

: then  ( orig cs-id -- )  0A ?pairs here >relresolve  ;

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs here <relresolve  ;
  \ , 0B ?pairs 1- here swap >relresolve  ; \ XXX OLD

: again  (  dest cs-id -- )  18 until  ;  \ compile `jr`

: step    ( dest cs-id -- )  10 until  ;  \ compile `djnz`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

-->

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

-->

( z80-asm -- last opcodes and macros)

  \ `AND`, `OR` and `XOR` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- definining words)

only forth definitions also assembler

: macro  ( "name" -- )  asm postpone :  ;
: endm  ( -- )  postpone ;  ;

decimal only forth

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

require z80-asm  require dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test cfa>pfa 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

require z80-asm  require dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test cfa>pfa dup here swap - dump

  \ }}} =======================================================
  \ The address register {{{

( a! a@ )

  \ Address register store and fetch words.

  \ [Code adapted from Z88 CamelForth.]

  \ Note by Gary Lancaster in the Z88 CamelForth source file:
  \ Sadly, there aren't any spare registers to make this as
  \ efficient as it could be. However, it can still give a
  \ useful improvement in loops, and in many cases also results
  \ in cleaner-looking code.

  \ XXX FIXME -- the requirements from the secondary pages are
  \ not right.

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,                 \ pop hl
  22 c, a ,             \ ld (a),hl
  jpnext                \ jp (ix)
  end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,             \ ld hl,(a)
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a @a )

  \ [Code adapted from Z88 CamelForth.]

do-require address-register

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,                          \ pop de
  2A c, a ,                      \ ld hl,(a)
  70 03 + c,  23 c,  70 04 + c,  \ ld (hl),e  inc hl  ld (hl),d
  jpnext                         \ jp (ix)
  end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,             \ ld hl,(a)
  5E c,                 \ ld e,(hl)
  23 c,                 \ inc hl
  66 c,                 \ ld h,(hl)
  68 03 + c,            \ ld l,e
  C3 c, pushhl ,        \ jp pushhl
  end-code

( c!a c@a )

  \ [Code adapted from Z88 CamelForth.]

do-require address-register

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  jpnext                \ jp (ix)
  end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a+ @a+ )

  \ [Code adapted from Z88 CamelForth.]

do-require address-register

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code @a+  ( -- u )      \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

( c!a+ c@a+ )

  \ [Code adapted from Z88 CamelForth.]

do-require address-register

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

  \ }}} =======================================================
  \ Common heap {{{

( heap )

  \ An implementation of the ANS Forth Memory-Allocation Word
  \ Set.

  \ Adapted from code written by Gordon Charlton, 1994:
  \
  \ XXX TODO adapt

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, ALLOCATE, FREE,
  \ and RESIZE which give the minimum functionality required to
  \ use the heap. These are given in areas 3, 4 and 5
  \ respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant HEAPSIZE. The constant HYSTERESIS
  \ controls the amount of spare space that is added to an
  \ allocation, to reduce the need for block moves during
  \ resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

forth definitions
vocabulary heap-voc
heap-voc definitions

  \ **1** General Purpose Extensions

: unique (  )  VARIABLE  ;

  \ Defining word. Each child returns a different non-zero
  \ number. The standard introduces the need for unique
  \ identifiers in the form of IORs and THROW codes, but
  \ provides no means for generating them. This does the trick.

0 1 2 UM/MOD NIP 1- CONSTANT maxpos

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  ---  Constants

256 CELLS CONSTANT heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 CELLS 1- CONSTANT hysteresis

  \ Node lengths are rounded up according to the value of
  \ HYSTERESIS to reduce the number of block moves during
  \ RESIZE operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

unique allocationerror

  \ Indicates there is less contiguous heap space available
  \ than required.

3 CELLS CONSTANT headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis OR  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize CONSTANT overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  ---  Structure

CREATE sentinel  HERE CELL+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

CREATE heap  heapsize ALLOT

  \ The heap is as described in HEADSIZE.

VARIABLE nextnode  -->

  \ Searching is done using a "nextfit" algorithm. NEXTNODE
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr -- addr)  CELL+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr -- addr)  2 CELLS +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )  heap DUP nextnode !
      DUP DUP !
      DUP heapsize  OVER >size !
      >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does NEXTNODE.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  ---  List Searching

: attach ( addr)  >prev @
      DUP sentinel ROT !
      sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (addr) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
    >R BEGIN 2@ SWAP R@ < INVERT UNTIL
    R> DROP  >prev @  ;

  \ Search the nodelist, starting at the node specified (addr),
  \ for a free node larger than or equal to the specified size.
  \ Return the address of the first node that matches, or zero
  \ for no match. The heap structure is set up to make this a
  \ near optimal search loop. The "size" field is next to the
  \ "next" field so that both can be collected in a single
  \ operation (2@). Nodes in use have negated sizes so they
  \ never match the search. The "previous" field is included to
  \ allow the search to overshoot the match by one node and
  \ then link back outside the loop, rather than remembering
  \ the address of the node just examined. The sentinel removes
  \ the need for a separate test for failure. SEARCH assumes
  \ the sentinel is in place.

: detach ( addr)  DUP >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           DUP      attach
           DUP ROT  search
           SWAP     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ NEXTNODE, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  ---  Head Creation

: fits ( size addr -- flag)  >size @ SWAP -  overhead  <  ;

  \ Returns TRUE if the size of the node specified is the same
  \ as the specified size, or larger than it by less than the
  \ size of the smallest possible node. Returns FALSE
  \ otherwise.

: togglesize ( addr)  >size DUP @  NEGATE SWAP !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)  2DUP + >R
           >size 2DUP @ SWAP -
           R@ >size !
           SWAP NEGATE SWAP !  R>  ;

  \ Given a free node (addr), reduce its size to that specified
  \ and mark it as in use. Start to construct a new node within
  \ the specified node beyond its new length, by storing the
  \ length of the remainder of the node in the size field of
  \ the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)  2DUP SWAP @  2DUP  SWAP !  >prev !
              2DUP >prev !   SWAP !  ;


  \ Addr1 is an existing node. Addr2 is the address of a new
  \ node just above the existing node. Break the links from the
  \ existing node to the next node and from the next node to
  \ the existing node and join the new node to them.


  \ ANSI heap  ---  Node Construction  ALLOCATE

: newnode ( size addr)  TUCK sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)  2DUP fits IF  togglesize DROP
         ELSE  newnode
         THEN  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

FORTH-WORDLIST SET-CURRENT
: ALLOCATE ( u -- addr ior)
    DUP 0< IF  allocationerror
         ELSE  adjustsize
         DUP findspace
         DUP IF  DUP next!
           TUCK makenode
           headsize +  0
           ELSE  DROP allocationerror
           THEN
         THEN  ;
MEMORY-ALLOC-WORDLIST SET-CURRENT  -->

  \ Make an in-use node with a data field at least u address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and an ior equal to the
  \ constant ALLOCATIONERROR. The standard specifies that the
  \ argument to ALLOCATE is unsigned. As the implementation
  \ uses the sign bit of the size field for its own purposes
  \ any request for an amount of space greater than MAXPOS must
  \ fail. As this would be a request for half the addressable
  \ memory or more this is not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  ---  Head Destruction

: mergesizes ( addr addr)
       >size @ SWAP >size +!  ;

  \ Make the size field of the node at addr1 equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at addr2 will be the one immediately above addr1.

: mergelinks ( addr addr)
       @ 2DUP SWAP !
       >prev !  ;

  \ The node at addr2 is removed from the node list. As with
  \ MERGESIZES the node at addr2 will be immediately above that
  \ at addr1. Destroy the link from node1 to node2 and relink
  \ node1 to the node above node2. Destroy the backward link
  \ from the node above node2 and relink it to node1.

: jiggle (  )
   nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that NEXTNODE may point to it. This is cured by making
  \ it point to the node prior to the one removed. We do not
  \ want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically NEXTNODE is set to point
  \ to the node pointed to by the "previous" field of the node
  \ pointed to in the "next" field of the node pointed to by
  \ NEXTNODE. Ordinarily this is a no-op (ie I am my father's
  \ son) but when the node has had its links merged it sets
  \ NEXTNODE to point to the node prior to the node it pointed
  \ to (ie when I died my father adopted my son, so now my son
  \ is my father's son).

: merge ( addr)
  DUP @ 2DUP mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  ---  Node Removal    FREE

: ?merge ( addr1 addr2)  >size @
       0> IF  DUP DUP @
        U< IF  DUP merge
           THEN
          THEN  DROP ;  -->

  \ Merge the node at addr1 with the one above it on two
  \ conditions, firstly that the node at addr2 is free, and
  \ secondly that the node pointed to by the next field in
  \ addr1 is actually above addr1 (ie that it does not wrap
  \ around because it is the topmost node). In usage addr2 will
  \ be either addr1 or the node above it. In each instance the
  \ other affected node (either the node above addr1 or addr1)
  \ is known to be free, so no test is needed for this.

( heap )

: ?mergenext ( addr)  DUP @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ DUP ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

FORTH-WORDLIST SET-CURRENT
: FREE ( addr -- ior)  headsize -
         DUP togglesize
         DUP ?mergenext
         ?mergeprev  0  ;
MEMORY-ALLOC-WORDLIST SET-CURRENT

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  ---  Node Repairing

VARIABLE stash

  \ The RESIZE algorithm is simplified and made faster by
  \ assuming that it will always succeed. STASH holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ Saves the contents of the >NEXT field of the node being
  \ RESIZEd in STASH (above).

: restorelink ( addr)  stash @  SWAP !  ;

  \ Converse operation to SAVELINK (above).

: fixprev ( addr)  DUP >prev @ !  ;

  \ The >NEXT field of the node prior to the node being RESIZEd
  \ should point to the node being RESIZEd. It may very well do
  \ already, but this makes sure.

: fixnext ( addr)  DUP @ >prev !  ;

  \ The >PREV field of the node after the node resized may need
  \ correcting.  This corrects it whether it needs it or not.
  \ (Its quicker just to do it than to check first.)

: fixlinks ( addr)  DUP fixprev  DUP fixnext  @ fixnext  ;

  \ RESIZE may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of JIGGLE (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)  DUP >size @ 0>
       IF  DUP @  2DUP <
           IF  OVER - SWAP >size !
         ELSE 2DROP
         THEN
     ELSE  DROP
     THEN  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the >NEXT field provided that
  \ the node is free and it is not the topmost node in the heap
  \ (ie there is no wraparound). Both these conditions need to
  \ be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  DUP fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to RESIZE (damaged by ?MERGENEXT)
  \ and its predecessor (damaged by ?MERGEPREV).

: repair ( addr)  DUP restorelink
      DUP fixlinks  DUP fixsizes
      togglesize  ;

  \ Make good the damage done by RESIZE. Restore the >next
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer NEXTNODE may
  \ have moved back one or two nodes by virtue of having been
  \ JIGGLEd about if it happened to be pointing to the wrong
  \ node. This is not serious, so I have chosen to ignore it.


  \ ANSI Heap  ---  Node Movement

: toobig? ( addr size -- flag)
    SWAP  >size @  >  ;

  \ Flag is true if the node at addr is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
       OVER >size @  headsize -
       ROT  headsize + ROT ROT MOVE  ;

  \ Move the contents of the data field of the node at addr1 to
  \ the data field at addr2. Assumes addr2 is large enough. It
  \ will be.

: enlarge ( addr1 size -- addr2 ior)
    OVER  ?mergeprev
    ALLOCATE DUP >R
    IF  SWAP repair
  ELSE  TUCK copynode
  THEN R>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of addr1 to the new node. Merge the node at addr1 with the
  \ one preceding it, if possible. This last behaviour is to
  \ finish off removing the node at addr1. The word ADJUST
  \ (below) starts removing the node. The node is removed
  \ before allocation to increase the probability of ALLOCATE
  \ succeeding. The address returned by ENLARGE is that
  \ returned by ALLOCATE, which is that of the data field, not
  \ the head. If the allocation fails repair the damage done by
  \ removing the node at addr1.


  \ ANSI Heap  ---  Node Restructuring  RESIZE

: adjust ( addr1 size1 -- addr2 size2)  adjustsize >R
              headsize -
              DUP savelink
              DUP togglesize
              DUP ?mergenext R>  ;

  \ Addr1 points to the data field of a node, not the "next"
  \ field. This needs correcting. Size1 also needs adjusting as
  \ per ADJUSTSIZE. In addition it is easier to work with free
  \ nodes than live ones as the size field is correct, and, as
  \ we intend to change the nodes size we will inevitably want
  \ to muck about with the next node, if its free, so lets
  \ merge with it straight away. Sufficient information is
  \ first saved to put the heap back as it was, if necessary.
  \ Now we are ready to get down to business.

-->

( heap )

FORTH-WORDLIST SET-CURRENT

: RESIZE ( addr1 u -- addr2 ior)
  DUP 0<  IF  DROP allocationerror
          ELSE  adjust  2DUP toobig?
                IF enlarge
                ELSE  OVER makenode headsize +  0  THEN
          THEN  ;

  \ Resize the node at addr1 to the specified size. Return the
  \ address of the resized node (addr2) along with an ior of
  \ zero if successful and ALLOCATIONERROR if not. Addr2 may be
  \ the same as, or different to, addr1.  If ior is non-zero
  \ then addr2 is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using MAKENODE, which
  \ has just the right functionality. In this case the ior is
  \ zero. As this is a standard word it takes an unsigned size
  \ argument, but excessive requests fail automatically, as
  \ with ALLOCATE.

  \ vim: filetype=soloforth
