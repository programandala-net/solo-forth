( Solo Forth library )

\ Copyright (C) 2015,2016 Marcos Cruz (programandala.net)

\ This file is the library of Solo Forth
\ http://programandala.net/en.program.solo_forth.html

  \ XXX UNDER DEVELOPMENT

\ This file was last modified: 201603140211

  \ ------------------------------------------------------------
  \ License

\ You may do whatever you want with this work, so long as you
\ retain all copyright notices, all credit notices, and this
\ license in all files of all redistributed copies and derived
\ works. There is no warranty.

  \ ------------------------------------------------------------
  \ History

  \ See
  \ http://programandala.net/en.program.solo_forth.history.html

( ) \ scr 1 -- testing load block

2 load
  need wipe-block  need color-block  need clear-block
  exit
  \ need list
  \ 504 load 505 load 507 load 509 load
  634 load  \ XXX TMP -- for Nuclear Invaders

  \ }}} =======================================================
  \ Need {{{

  \ This section contains `need` and all related words that

( contains delimited located )

  \ This block must be at a permanent location.

  \ XXX TMP
  \ XXX INFORMER
  \ : contains  ( ca1 len1 ca2 len2 -- f )  2dup cr type ." in"
  \ 2over -trailing cr type ." ?" cr .s key drop search nip nip ;

: contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;

  \ doc{
  \
  \ contains ( ca1 len1 ca2 len2 -- f )
  \
  \ Does the string ca1 len1 contains the string ca2 len2?
  \
  \ }doc

variable default-first-locatable  variable first-locatable
variable last-locatable  blk/disk 1- last-locatable !
  \ Variables that define the range of blocks to be searched
  \ by `located` and its descendants.

: delimited  ( ca1 len1 -- ca2 len2 )
  dup 2+ dup allocate-string swap  ( ca1 len1 ca2 len2 )
  2dup blank  2dup 2>r drop char+ smove 2r>  ;

  \ doc{
  \
  \ delimited   ( ca1 len1 -- ca2 len2 )
  \
  \ Add a leading space and trailing space to the string _ca1
  \ len1_, returning the result _ca2 len2_ in the circular
  \ string buffer.
  \
  \ }doc

: located  ( ca len -- block | false )
  delimited  last-locatable @ 1+  first-locatable @
  default-first-locatable @  first-locatable !
  do  0 i line>string 2over
      contains if  2drop i unloop exit  then
      break-key? ?leave
  loop  2drop false  ;

  \ doc{
  \
  \ located  ( ca len -- block | false )
  \
  \ Locate the first block whose header contains the string _ca
  \ len_ (but surrounded by spaces), and return its number. If
  \ not found, return _false_.  The search is case-sensitive.
  \
  \ }doc

-->

( ?located locate from reneeded reneed )

: ?located  ( block | 0 -- )  dup 0= #-268 ?throw  ;

  \ doc{
  \
  \ ?located ( f -- )
  \
  \ If f is zero, throw an exception -268.
  \
  \ }doc

: locate  ( "name" -- block | false )
  parse-name save-string located  ;

  \ doc{
  \
  \ locate  ( "name" -- block | false )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and return its number. If not
  \ found, return _false_.
  \ The search is case-sensitive.
  \
  \ }doc

: from  ( "name" -- )  locate ?located first-locatable !  ;

  \ doc{
  \
  \ from  ( "name" -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and set it the first one `located`
  \ will search from. If not found, throw an exception -268.
  \
  \ This word is intended to prevent undesired matches clashes
  \ during the execution of `need` and related words. "name" is
  \ supposed to be a conventional marker. Usage examples:

  \ ----
  \ ( x )
  \
  \ : x  ( -- )  ." Wrong x!" ;
  \
  \ ( use-x )
  \
  \ from ==data-structures== need x
  \
  \ ( y )  ==data-structures==
  \
  \ : y ." Y data structure; ;
  \
  \ ( x )
  \
  \ : x ." X data structure; ;
  \
  \ ----

  \ }doc

: reneeded  ( ca len -- )  located ?located load  ;

  \ doc{
  \
  \ reneeded  ( ca len -- )
  \
  \ Locate the first block whose header contains the string
  \ _ca len_ (surrounded by spaces), and load it. If not found,
  \ throw an exception -268.
  \
  \ }doc

: reneed  ( "name" -- )  parse-name save-string reneeded  ;

  \ doc{
  \
  \ reneed  ( ca len -- )
  \
  \ Locate the first block whose header contains "name"
  \ (surrounded by spaces), and load it.
  \
  \ }doc

-->

( needed-word [needed] [unneeded] needed need )

2variable needed-word

  \ XXX TODO -- make `[needed]` and `[unneeded]` optional.

: [needed]  ( "name" -- wf )
  parse-name needed-word 2@ 2dup or
  if  compare 0=  exit  then  2drop 2drop true   ; immediate

  \ doc{
  \
  \ [needed]  ( "name" -- wf )
  \
  \ Is "name" the needed word specified by the last execution
  \ of `need` or `needed`?
  \
  \ }doc

: [unneeded]  ( "name" -- wf )
  postpone [needed] 0=  ; immediate

  \ doc{
  \
  \ [unneeded]  ( "name" -- wf )
  \
  \ Is "name" different than the needed word specified by the
  \ last execution of `need` or `needed`?
  \
  \ }doc

: needed  ( ca len -- )

  \ XXX OLD
  \
  \ XXX FIXME usually the final check fails because the saved
  \ string has been overwritten in the circular string buffer.
  \ the only solution is to store the string apart, in an ad
  \ hoc zone.

  \ 2dup undefined?
  \   if  2dup reneeded  then
  \ 2dup undefined? warnings @ and
  \   if  type 28 warning exit  then  2drop  ;

  needed-word 2@ 2>r
  -trailing -leading save-string 2dup needed-word 2!
  2dup undefined?
  if  reneeded  else  2drop  then  2r> needed-word 2!  ;

  \ doc{
  \
  \ needed  ( ca len -- )
  \
  \ If the string _ca len_ is not the name of a word found in
  \ the current search order, locate the first block of the
  \ library where "name" is included in the block header
  \ (surrounded by spaces), and load it.
  \
  \ }doc

: need  ( "name" -- )  parse-name needed  ;

  \ doc{
  \
  \ need  ( "name" -- )
  \
  \ If "name" is not found in the current search order, locate
  \ the first block of the library where "name" is included is
  \ the block header (surrounded by spaces), and load it.
  \
  \ }doc

blk @ 1+ dup default-first-locatable !  first-locatable !

  \ }}} =======================================================
  \ Command line history {{{

( history )

  \ XXX NEW -- upwards version, with back linked strings

  \ Every entry in the command line history has the following
  \ structure:
  \
  \ +0    : length byte
  \ +1..n : string
  \ +n+1  : address of +0

variable /history
  \ Size of the history space, where all strings are hold.

variable hp0
  \ Address of the bottom of the history.

variable hp
  \ The history pointer: Address of the free space in the
  \ history.

: used-history  ( -- u )  hp0 @ hp @  -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

: allot-history  ( +n -- )  hp +!  ;
  \ Reserve _+n_ bytes in the history.

: len>history  ( len -- +n )  1+ cell+  ;
  \ Convert a string length to space required to store it into
  \ the history.

: history>link  ( ca -- a )  cell-  ;
  \ Convert a history string address to its link field.

: history<history  ( ca1 -- ca2 )  history>link @n  ;
  \ Convert a history string address to the previous one.

: history>history  ( ca1 -- ca2 )
  names-bank count default-bank  + cell+  ;
  \ Convert a history string address to the next one.

: history>string  ( ca1 -- ca2 len2 )
  names-bank count save-string default-bank  ;  -->
  \ Copy a history string to a string in the circular string
  \ buffer.

( history )

variable browsed-history
  \ Address of the history string being browsed.

: oldest-history?  ( -- f )  browsed-history @ hp0 @ =  ;
  \ Are we browsing the oldest string of history?

: browse-older-history  ( -- )
  oldest-history? ?exit
  browsed-history @ history<history browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newest-history?  ( -- )
  browsed-history @ history>history hp @ =
  browsed-history @ hp @ =  or  ;
  \ Are we browsing the newest string of history?

: browse-newer-history  ( -- )
  newest-history? ?exit
  browsed-history @ history>history browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( n -- )
  dup /history !  $FFFF swap -
  dup hp0 !  dup hp !  browsed-history !  0 hp0 @ c!n  ;

1024 init-history  -->

( history )

need s=

: history-empty?  ( -- f )  used-history 0=  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

-->

( history )

: latest-history$  ( -- ca len )
  hp @ history<history history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: duplicated-history?  ( ca len -- f )  latest-history$ s=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: longer-history?  ( len -- f )
  len>history unused-history >  ;
  \ Is _len_ too long?

: history,  ( ca len -- )
  hp @ dup >r  over >r  ( ca len ca1 ) ( R: len ca1 -- )
  names-bank place default-bank
  r> 1+ allot-history  r> hp @ !n  cell allot-history  ;
  \ Add a string to the command line history.

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
  2dup duplicated-history? if  2drop exit  then
  dup longer-history? if  dup allocate-history throw  then
  history,  hp @ browsed-history !  ;
  \ Save string _ca len_ into the command line history,
  \ provided the string is valid (not empty, not duplicated).
  \ Make room if necessary. Then update the pointer to the
  \ browsed history.

-->

( history )

: browsed-history$  ( -- ca len )
  browsed-history @ history>string  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: get-history   ( -- ca )  browsed-history$ set-accept  ;

: (history-up)    ( -- ca )
  get-history browse-older-history  ;
: (history-down)  ( -- ca )
  get-history browse-newer-history  ;

-->

( history )

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  ['] 2drop ['] >history defer!
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  ['] (>history) ['] >history defer!
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

-->

( history )

: .history  ( -- )
  hp0 @ begin  dup hp @ u<  while
          dup history>string type cr  history>history
        repeat  drop  ;

need dump

: hdump  ( ca len -- )  names-bank dump default-bank  ;

: .h  ( -- )  hp0 dup hp @ - hdump  ;

\ history-on

( history )  \ XXX OLD

  \ XXX OLD -- downwards version

  \ 2016-03-07: Start.

  \ Command line history is implemented as a list of counted
  \ string at the top of a memory bank. It's the same bank
  \ where name fields are stored. Name fields are stored
  \ upwards from the bottom of the 16-KiB space; command line
  \ history grows downwards from the top.
  \
  \ The length of the every counted string is used as a link
  \ field to the previous string.  The bottom of the list is
  \ the highest address of the bank, and it holds one byte, the
  \ length of the first string stored in the history, or zero
  \ when the history is empty.
  \
  \ There's a maximum space usable for the history. When
  \ there's no free space left to store a new string, oldest
  \ strings are removed as necessary.

  \ 2016-03-08: XXX TODO -- Rewrite, simpler: grow upwards.

variable hp
  \ Pointer to the most recent string in the history.

$FFFF constant hp0
  \ Pointer to the bottom of the history, which contains a copy
  \ of the length of the first string.

variable /history  1024 /history !
  \ Size of the history space, where all strings are hold.

: init-hp0  ( -- )  0 hp0 c!n  ;

: history-bounds  ( -- ca1 ca2 )  hp0 hp @  ;
  \ Return bottom of history _a1_ and address of the latest
  \ string _ca2:

: used-history  ( -- u )  history-bounds -  ;
  \ Used space _u_ in the history.

: unused-history  ( -- n )  /history @ used-history -  ;
  \ Unused space _n_ in the history.

-->

( history )  \ XXX OLD

variable previously-browsed-history
  \ Address of the history string previously browsed.

variable currently-browsed-history
  \ Address of the history string being browsed.

: older-history  ( -- )
  currently-browsed-history @ dup previously-browsed-history !
  names-bank count default-bank +
  currently-browsed-history !  ;
  \ Update the current history being browsed to the previous
  \ (older) one.

: newer-history  ( -- )
  currently-browsed-history @
  previously-browsed-history @ currently-browsed-history !
  currently-browsed-history !  ;
  \ Update the current history being browsed to the next
  \ (newer) one.

: init-history  ( -- )
  init-hp0  hp0 dup hp ! currently-browsed-history !  ;

init-history  -->

( history )  \ XXX OLD

need s=

: allot-history  ( +n -- )  negate hp +!  ;
  \ Reserve _+n_ bytes in the history.

: history-empty?  ( -- f )  history-bounds =  ;
  \ Is the history empty?

: allocate-history  ( len -- ior )
  1+ dup /history @ > if  drop #-274 exit  then
    \ command line history overflow?
  \ ." allocate-history" \ XXX INFORMER
  0  ; \ XXX TMP
  \ Allocate space in the history for a string _len_ bytes
  \ long.
  \ XXX TODO -- remove older strings if needed

: latest-history  ( -- ca len )
  names-bank  hp @ count  save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.
  \ XXX OLD

: browsed-history  ( -- ca len )
  currently-browsed-history @
  names-bank  count save-string  default-bank  ;
  \ Return the latest string in the command line history,
  \ copied in the circular string buffer.

: (history>)  ( -- ca len )
  browsed-history  dup 0= ?exit
                   dup 1+ negate allot-history
  history-empty? if  init-hp0  then  ;  -->
  \ Get a string from the command line history, and return it
  \ as _ca len_ in the circular string buffer.
  \ XXX TODO -- adapt the browser variables

( history )  \ XXX OLD

: duplicated-history?  ( ca len -- f )  latest-history s=  ;
  \ Is string _ca len_ identical to the latest string in
  \ the command line history?

: too-long-for-history?  ( len -- f )  1+ unused-history > ;

: (>history)  ( ca len -- )
  dup 0= if  2drop exit  then
    \ If string is empty, do nothing.
  history-empty? if  dup hp0 c!n  then
    \ If history is empty, init its bottom with the length
    \ of the string.
  2dup duplicated-history? if  2drop exit  then
  dup too-long-for-history?
  if  dup allocate-history throw  then
    \ If there's no space left, allocate it.
  dup 1+ allot-history
  hp @ dup names-bank place default-bank
           currently-browsed-history !  ;
  \ Save string _ca len_ into the command line history.

-->

( history )  \ XXX OLD

: get-history   ( -- ca )  browsed-history set-accept  ;
: (history-up)    ( -- ca )  get-history older-history  ;
: (history-down)  ( -- ca )  get-history newer-history  ;

variable history
  \ A variable holding the current status of the command line
  \ history as a flag: on (true) or off (false).

: history-off  ( -- )
  \ XXX OLD
  \ ['] 2drop ['] >history defer!
  \ ['] s""   ['] history> defer!  history off  ;
  \ XXX NEW
  ['] 0 ['] history-up   defer!
  ['] 0 ['] history-down defer!  history off  ;
  \ Turn command line history off.

: history-on  ( -- )
  \ XXX OLD
  \ ['] (>history) ['] >history defer!
  \ ['] (history>) ['] history> defer!  history on  ;
  \ XXX NEW
  ['] (history-up)   ['] history-up   defer!
  ['] (history-down) ['] history-down defer!  history on  ;
  \ Turn command line history on.

: .history  ( -- )
  hp @  begin  dup hp0 <  while
          names-bank count 2dup type cr default-bank  +
        repeat  drop  ;

\ history-on

  \ }}} =======================================================
  \ Exceptions {{{

( abort" )

  \ Credits:
  \
  \ Code adapted from DZX-Forth.

  \ XXX TODO use `error`, by modifying `throw`

[defined] abort-message ?\ 2variable abort-message

: (abort")  ( n -- )
  r> count rot if  abort-message 2! -2 throw  then + >r  ;

: abort"  ( Compilation: "ccc<quote>" -- )
  postpone (abort") ,"  ; immediate compile-only

( error>ordinal error>line )

: error>ordinal  ( -n1 -- +n2 )
  \ Convert an error code to its ordinal position in the
  \ library.
  \ -n1 =  -90..-1        \ Standard error codes
  \        -285..-256     \ Solo Forth error codes
  \        -1024..-1000   \ G+DOS error codes
  \ +n2 =  1..146

  \ XXX TODO  add OS codes

  abs
  dup 256 < ?exit
  dup 1000 < if  [ 255 091 - ] literal - exit  then
  [ 1000 286 - 255 091 - + ] literal -   ;

: error>line  ( n1 -- n2 )
  error>ordinal dup >r
  begin
    dup dup 16 / - r@ <>  while  1+
  repeat  rdrop  ;

\ msg-scr (.throw) \

need error>line  need .line

variable msg-scr
s" Standard error codes" locate msg-scr !
  \ XXX TODO rename!

  \ doc{
  \
  \ msg-scr  ( -- a )
  \
  \ Variable that holds the block that holds the error
  \ messages.
  \
  \ }doc

: (.throw)  ( n -- )
  msg-scr @
  if  error>line msg-scr @ .line space  else  .throw#  then  ;

' (.throw) ' .throw defer!

  \ doc{
  \
  \ (.throw)  ( n -- )
  \
  \ Extended behaviour of the deferred word `.throw`:
  \ Print the text of throw error _n_.  The variable `msg-scr`
  \ contains the number of the first block where messages are
  \ hold. If it contains zero, only the error number is printer.
  \
  \ }doc

( ?compiling ?executing )

[unneeded] ?compiling
?\ : ?compiling  ( -- )  compiling? 0= -14 ?throw  ;

  \ doc{
  \
  \ ?compiling  ( -- )
  \
  \ Issue an error if not compiling.
  \
  \ }doc

[unneeded] ?executing
?\ : ?executing  ( -- )  compiling? -263 ?throw  ;

  \ doc{
  \
  \ ?executing  ( -- )
  \
  \ Issue an error if not executing.
  \
  \ }doc

  \ }}} =======================================================
  \ Parsing {{{

( parse-line )  \ ==parsing==

  \ XXX OLD -- 2015-09-13: moved to kernel
  \ : source  ( -- a len )  \ Forth-94
  \   blk @ ?dup if  block b/buf  else  tib #tib @  then  ;

: parse-line  ( "text<eol>" -- ca len )
  source span @ min c/l min  >in @ span @ min /string
  dup >in +! save-string  ;

  \ doc{
  \
  \ parse-line  ( "text<eol>" -- ca len )
  \
  \ Get the text string until the end of line.  Note: this is a
  \ factor of the editor's `text`.
  \
  \ }doc

( evaluate )

  \ XXX UNDER DEVELOPMENT

  \ XXX Gforth:
: execute-parsing  ( ca len xt -- )
  >in @ >r >in off
  source >r >r ;

: evaluate  ( ca len -- )  ['] interpret execute-parsing  ;

( parse-char )

: parse-char  ( "c"  -- c )  stream drop c@ 1 parsed  ;
  \ Parse the next char in the input stream and return its
  \ code.

( word )

  \ Credits:
  \
  \ Code from Z88 CamelForth.

: word  ( c "<c...>text<c>" -- ca )
  dup  stream                 ( c c ca len )
  dup >r   rot skip           ( c ca' len' )
  over >r  rot scan           ( ca" len" )
  dup if  char-  then         \ skip trailing delimiter
  r> r> rot -   >in +!        \ update `>in`
  tuck -                      ( ca' len )
  here place  here            ( ca )
  bl over count + c!  ;       \ append trailing blank

  \  doc{
  \
  \  word  ( c "<c...>text<c>" -- ca )
  \
  \  c = delimiter char
  \
  \  Skip leading _c_ delimiters from the input stream.  Parse
  \  the next text characters from the input stream, until a
  \  delimiter _c_ is found, storing the packed character
  \  string beginning at _ca_, as a counted string (the
  \  character count in the first byte), and with one blank at
  \  the end.  byte), and with one blank at the end (not
  \  included in the count).
  \
  \  Origin: Forth-94 (CORE), Forth-2012 (CORE).
  \
  \  }doc

( defined? )

: defined?  ( ca len -- wf )  undefined? 0=  ;

  \ }}} =======================================================
  \ Data stack {{{

( -rot )  \ ==datastack==

  \ Credits:
  \
  \ Code adapted from Afera.

code -rot  ( x1 x2 x3 -- x3 x1 x2 )

  E1 c, D1 c,      \ pop hl / pop de
  E3 c,            \ ex (sp),hl
  EB c,            \ ex de,hl
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ doc{
  \
  \ -rot  ( x1 x2 x3 -- x3 x1 x2 )
  \
  \ }doc

( 2nip )

  \ Credits:
  \
  \ Code from Afera; original code from DZX-Forth.

code 2nip  ( x1 x2 x3 x4 -- x3 x4 )

  E1 c,            \ pop hl
  D1 c,            \ pop de
  F1 c,            \ pop af
  F1 c,            \ pop af
  C3 c, pushhlde , \ jp pushhlde

  end-code

  \ doc{
  \
  \ 2nip  ( x1 x2 x3 x4 -- x3 x4 )
  \
  \ }doc

( roll )

  \ doc{
  \
  \ roll  ( xu xn .. x0 u -- xn .. x0 xu )
  \
  \ }doc

  \ Credits:
  \
  \ Code adapted from DZX-Forth.

need z80-asm

code roll  ( xu xn .. x0 u -- xn .. x0 xu )

  hl pop  hl addp  hl de ldp  sp addp
    \ pop hl
    \ add hl,hl
    \ ld e,l
    \ ld d,h
    \ add hl,sp

  bc push  m c ld  hl incp  m b ld
    \ push bc
    \ ld c,(hl)
    \ inc hl
    \ ld b,(hl)

  bc push  de bc ldp  hl de ldp
    \ push bc
    \ ld b,d
    \ ld c,e
    \ ld d,h
    \ ld e,l

  bc tstp
    \ ld a,b
    \ or c

  0000 jpz |mark 0 unresolved !
    \ jp z,roll.end

  hl decp  hl decp  lddr
    \ dec hl
    \ dec hl
    \ lddr

    \ roll.end:
  0 unresolved @ >resolve
  hl pop  bc pop  exsp
    \ pop hl
    \ pop bc
    \ ex (sp),hl

  jpnext

  end-code

( 3drop 4drop )

code 3drop  ( x1 x2 x3 -- )
  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 3drop  ( x1 x2 x3 -- )
  \
  \ }doc

code 4drop  ( x1 x2 x3 x4 -- )
  E1 c,  E1 c,  E1 c,  E1 c,
    \ pop hl
    \ pop hl
    \ pop hl
    \ pop hl
  jpnext  end-code

  \ doc{
  \
  \ 4drop  ( x1 x2 x3 x4 -- )
  \
  \ }doc

( 3dup )

code 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  D9 c,
    \ exx
  C1 c,  D1 c,  E1 c,
    \ pop bc
    \ pop de
    \ pop hl
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  E5 c,  D5 c,  C5 c,
    \ push hl
    \ push de
    \ push bc
  D9 c,
    \ exx
  jpnext  end-code

  \ doc{
  \
  \ 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )
  \
  \ }doc

exit  \ slower and smaller version:

: 3dup  ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot  ;

( 2rot )

need roll

: 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  5 roll 5 roll  ;

  \ doc{
  \
  \ 2rot  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
  \
  \ }doc

( swapped )

  \ Credits:
  \
  \ Adapted from code written by Sam Suan Chen, published
  \ on Forth Dimensions (volume 6, number 6, page 9, 1985-03).

: swapped  ( i*x n1 n2 -- j*x )
  >r 1+ cells sp@ +     ( i*x a1 ) ( R: n2 )
  r> 2+ cells sp@ +     ( i*x a1 a2 )
  over @ over @         ( i*x a1 a2 x1 x2 )
  >r swap !  r> swap !  ;

  \ Usage example:
  \
  \   ( 1 2 3 4 5 )  1 4 swapped  ( 4 2 3 1 5 )

  \ Original code by Sam Suan Chen,
  \ with an equivalent usage example:

  \ : xyswap  ( i*x n -- j*x )
  \   16 /mod >r dup + sp@ + sp@ r> dup + +
  \   over @ over @
  \   >r swap !  r> swap !  ;
  \
  \   ( 1 2 3 4 5 )  $25 xyswap  ( 4 2 3 1 5 )

( nup drup dip )

code nup  ( x1 x2 -- x1 x1 x2 )
  E1 c,  D1 c,  D5 c,  C3 c, pushhlde ,
    \ pop hl
    \ pop de
    \ push de
    \ jp pushhlde
  end-code
  \ Also called `under`.

  \ doc{
  \
  \ nup  ( x1 x2 -- x1 x1 x2 )
  \
  \ }doc

code drup  ( x1 x2 -- x1 x1 )
  D1 c,  E1 c,  E5 c,  E5 c,  jpnext
    \ pop de
    \ pop hl
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ drup  ( x1 x2 -- x1 x1 )
  \
  \ }doc

code dip  ( x1 x2 -- x2 x2 )
  E1 c, D1 c, E5 c, E5 c,  jpnext
    \ pop hl
    \ pop de
    \ push hl
    \ push hl
    \ jp next
  end-code

  \ doc{
  \
  \ dip  ( x1 x2 -- x2 x2 )
  \
  \ }doc

( 0dup -dup )

code 0dup  ( x -- x | 0 0 )
  E1 c,  78 04 + c,  B0 05 + c,
    \ pop hl
    \ ld a,h
    \ or l
  C2 c, pushhl ,  E5 c,  C3 c, pushhl ,
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ 0dup  ( x -- x | 0 0 )
  \
  \ Duplicate _x_ if it's zero.
  \
  \ }doc

code -dup  ( x -- x | 0 0 )
  E1 c,  CB c, 7C c,
    \ pop hl
    \ bit 7,h ; negative?
  C2 c, pushhl ,  E5 c,  C3 c, pushhl ,
    \ jp z,push_hl
    \ push hl
    \ jp push_hl
  end-code

  \ doc{
  \
  \ -dup  ( x -- x x | x )
  \
  \ Duplicate _x_ if it's negative.
  \
  \ }doc

( ndrop )

need z80-asm

code ndrop  ( x1..xn n -- )

  hl pop  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( x1..xn n -- )
  \
  \ Drop _n_ cell items from the stack.
  \
  \ }doc

( 2ndrop )

need z80-asm

code 2ndrop  ( dx1..dxn n -- )

  hl pop  hl addp  hl addp  exde  \ DE = n cells
    \ pop hl
    \ add hl,hl
    \ add hl,hl
    \ ex de,hl
  0 hl ldp#  sp addp  \ HL = stack pointer
    \ ld hl,0
    \ add hl,sp
  de addp  ldsp  \ update SP
    \ add hl,de
    \ ld sp,hl
  jpnext
  end-code

  \ doc{
  \
  \ ndrop  ( dx1..dxn n -- )
  \
  \ Drop _n_ double cell items from the stack.
  \
  \ }doc

  \ }}} =======================================================
  \ Return stack {{{

( n>r )  \ ==returnstack==

need z80-asm

code n>r  ( x1..xn n -- ) ( R: -- x1..xn n )

  exx

  bc pop  0000 bc stp  |mark
  rp fthl
  begin  bc tstp  nz while
    de pop  hl decp  d m ld  hl decp  e m ld  bc decp
  repeat
  0000 de ldp# |resolve
  hl decp  d m ld  hl decp  e m ld

  rp sthl  exx  jpnext

  end-code

  \ doc{
  \
  \ n>r  ( x1..xn n -- ) ( R: -- x1..xn n )
  \
  \ }doc

need nr>

( nr> )

need z80-asm

code nr>  ( -- x1..xn n ) ( R: x1..xn n -- )

  exx
  rp fthl
  m c ld  hl incp  m b ld  hl incp
  0000 bc stp  |mark
  begin  bc tstp  nz while
    m e ld  hl incp  m d ld  hl incp  de push  bc decp
  repeat
  rp sthl  exx
  0000 hl ldp# |resolve
  pushhl jp
  end-code

  \ doc{
  \
  \ nr>  ( -- x1..xn n ) ( R: x1..xn n -- )
  \
  \ }doc

need n>r

( rdepth r'@ )

  \ Credits:
  \
  \ `rdepth` from Afera.

[unneeded] rdepth
?\ : rdepth  ( -- n )  rp@ rp0 @ - -2 /  ;

  \ doc{
  \
  \ rdepth  ( -- n )
  \
  \ }doc

  \ Credits:
  \
  \ `r'@` from Wil Baden.

[unneeded] r'@ dup
?\ : r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
?\   r> 2r@ drop swap >r  ;

  \ doc{
  \
  \ r'@  ( -- x1 ) ( R: x1 x2 -- x1 x2 )
  \
  \ }doc

  \ }}} =======================================================
  \ User variables {{{

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO

: uallot ( n -- )  udp @ swap udp +!  ;
  \ XXX from Gforth

: user  ( "name" -- )  create cell uallot , does> @ up @ +  ;

: user  ( "name" -- )  create cell uallot c, does> c@ up @ +  ;


  \ }}} =======================================================
  \ System variables {{{

( os-chars os-chans os-flags2 os-seed os-frames os-udg )

[unneeded] os-chars    ?\ 23606 constant os-chars
  \ 1 cell:
  \ address of character 0 of the font (actual characters 32..127)

[unneeded] os-chans    ?\ 23631 constant os-chans
  \ 1 cell:
  \ address of the channels

[unneeded] os-flags2   ?\ 23658 constant os-flags2
  \ 1 byte:
  \ several flags

[unneeded] os-seed     ?\ 23670 constant os-seed
  \ 1 cell:
  \ seed of the random number generator

[unneeded] os-frames   ?\ 23672 constant os-frames
  \ 3 bytes:
  \ 24-bit counter of frames (1 frame = 20 ms)

[unneeded] os-udg      ?\ 23675 constant os-udg
  \ 1 cell:
  \ address of the User Defined Graphics (characters 128..255)

  \ }}} =======================================================
  \ Screen modes {{{

( columns rows )  \ ==screenmodes==

need value

32 value columns  24 value rows

( mode32 )

need columns  need rows  need os-chars  need os-chans

: mode-output  ( a -- )  os-chans @ 2dup ! 2dup 5 + ! 15 + !  ;
  \ Associate the output
  \ routine at _a_ to the system channels "K", "S" and "P".

: set-mode  ( a1 a2 -- )  os-chars !  mode-output  ;
  \ Set the system font to _a1_ and associate the output
  \ routine at _a2_ to the system channels.

: mode32  ( -- )
  [ latest name> ] literal current-mode !
  2548 15360 set-mode
  32 to columns  24 to rows
  ['] (mode32-xy) ['] xy defer!
  ['] (mode32-at-xy) ['] at-xy defer!  ;
  \ Set the default printing mode: the 32 cpl ROM routine, the
  \ ROM font, and the special code for `at-xy` (required to
  \ use the whole screen).

' mode32 ' default-mode defer!

( mode42 )

  \ Credits:
  \
  \ Author of the 42 cpl printing routine: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 66 (1986-02), page 24:
  \ http://microhobby.org/numero066.htm
  \ http://microhobby.speccy.cz/mhf/066/MH066_24.jpg

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- integrate the driver

  \ XXX TODO -- check how the UDG are printed (8 pixels width?)

  \ XXX FIXME -- a pixel of the cursor is not deleted when
  \ backspace is used on the command line

need mode32  need <file-as-is

get-drive 1 set-drive
s" prnt42.bin" <file-as-is ?throw
s" ea5aky.f42" <file-as-is ?throw
set-drive
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode42-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode42  ( -- )
  [ latest name> ] literal current-mode !
  63900 [ 64600 256 - ] literal set-mode
  42 to columns  24 to rows
  ['] (mode42-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 42 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ Credits:
  \
  \ Author of the original code: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1
  \ Modified and adapted to Solo Forth by Marcos Cruz.

  \ XXX OLD temporary first version
  \ First the driver and the font were in a disk file
  \ that is loaded at 60000. Later the font was compiled
  \ into the dictionary.

need mode32  need <file-as-is  need 4x8font

get-drive 1 set-drive
s" 4x8fd.bin" <file-as-is ?throw
set-drive
  \ Load the driver and the font.

[defined] (at-xy)
?\ : (at-xy)  ( col row -- )  22 emit swap emit emit  ;

: (mode64-xy)  ( -- col row )  0 0  ;  \ XXX TODO

: mode64  ( -- )
  [ latest name> ] literal current-mode !
  60000 4x8font set-mode
  64 to columns  24 to rows
  ['] (mode64-xy) ['] xy defer!
  ['] (at-xy) ['] at-xy defer!  ;
  \ Set the 64 cpl printing mode: the driver, the font
  \ and `at-xy`.

( mode64 )

  \ XXX NEW
  \ XXX TODO -- integrate the driver

need z80-asm

  \ XXX TODO use common variables for all modes?

create mode64-at-flag 0 c,
create mode64-column 0 c,
create mode64-row 0 c,
variable mode64-chars

  \ XXX TODO (mode64-home)

code (mode64-emit)  ( -- )

  b a ld
  here 1+ 0 unresolved !  \ address of at_flag
  0 a ld#  and a
  z if
    FF a ld#
  then
  \ check_cr

  end-code

: mode64  ( -- )  (mode64-emit) mode64-chars @ set-mode
  ['] (at-xy) ['] at-xy defer!  ;

( 4x8font )

  \ Half width 4x8 font.
  \ 336 bytes.
  \ Top row is always zero and not stored.

  \ Credits:
  \
  \ Author of the font: Andrew Owen.
  \ Published on the World of Spectrum forum:
  \ http://www.worldofspectrum.org/forums/discussion/14526/redirect/p1

create 4x8font  hex

02 c, 02 c, 02 c, 02 c, 00 c, 02 c, 00 c,  \  !
52 c, 57 c, 02 c, 02 c, 07 c, 02 c, 00 c,  \ "#
25 c, 71 c, 62 c, 32 c, 74 c, 25 c, 00 c,  \ $%
22 c, 42 c, 30 c, 50 c, 50 c, 30 c, 00 c,  \ &'
14 c, 22 c, 41 c, 41 c, 41 c, 22 c, 14 c,  \ ()
20 c, 70 c, 22 c, 57 c, 02 c, 00 c, 00 c,  \ *+
00 c, 00 c, 00 c, 07 c, 00 c, 20 c, 20 c,  \ ,-
01 c, 01 c, 02 c, 02 c, 04 c, 14 c, 00 c,  \ ./
22 c, 56 c, 52 c, 52 c, 52 c, 27 c, 00 c,  \ 01
27 c, 51 c, 12 c, 21 c, 45 c, 72 c, 00 c,  \ 23
57 c, 54 c, 56 c, 71 c, 15 c, 12 c, 00 c,  \ 45
17 c, 21 c, 61 c, 52 c, 52 c, 22 c, 00 c,  \ 67
22 c, 55 c, 25 c, 53 c, 52 c, 24 c, 00 c,  \ 89
-->

( 4x8font )

00 c, 00 c, 22 c, 00 c, 00 c, 22 c, 02 c,  \ :;
00 c, 10 c, 27 c, 40 c, 27 c, 10 c, 00 c,  \ <=
02 c, 45 c, 21 c, 12 c, 20 c, 42 c, 00 c,  \ >?
23 c, 55 c, 75 c, 77 c, 45 c, 35 c, 00 c,  \ @A
63 c, 54 c, 64 c, 54 c, 54 c, 63 c, 00 c,  \ BC
67 c, 54 c, 56 c, 54 c, 54 c, 67 c, 00 c,  \ DE
73 c, 44 c, 64 c, 45 c, 45 c, 43 c, 00 c,  \ FG
57 c, 52 c, 72 c, 52 c, 52 c, 57 c, 00 c,  \ HI
35 c, 15 c, 16 c, 55 c, 55 c, 25 c, 00 c,  \ JK
45 c, 47 c, 45 c, 45 c, 45 c, 75 c, 00 c,  \ LM
62 c, 55 c, 55 c, 55 c, 55 c, 52 c, 00 c,  \ NO
62 c, 55 c, 55 c, 65 c, 45 c, 43 c, 00 c,  \ PQ
63 c, 54 c, 52 c, 61 c, 55 c, 52 c, 00 c,  \ RS
75 c, 25 c, 25 c, 25 c, 25 c, 22 c, 00 c,  \ TU
-->

( 4x8font )

55 c, 55 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ VW
55 c, 55 c, 25 c, 22 c, 52 c, 52 c, 00 c,  \ XY
73 c, 12 c, 22 c, 22 c, 42 c, 72 c, 03 c,  \ Z[
46 c, 42 c, 22 c, 22 c, 12 c, 12 c, 06 c,  \ \]
20 c, 50 c, 00 c, 00 c, 00 c, 00 c, 0F c,  \ ^_
20 c, 10 c, 03 c, 05 c, 05 c, 03 c, 00 c,  \ ?a
40 c, 40 c, 63 c, 54 c, 54 c, 63 c, 00 c,  \ bc
10 c, 10 c, 32 c, 55 c, 56 c, 33 c, 00 c,  \ de
10 c, 20 c, 73 c, 25 c, 25 c, 43 c, 06 c,  \ fg
42 c, 40 c, 66 c, 52 c, 52 c, 57 c, 00 c,  \ hi
14 c, 04 c, 35 c, 16 c, 15 c, 55 c, 20 c,  \ jk
60 c, 20 c, 25 c, 27 c, 25 c, 75 c, 00 c,  \ lm
00 c, 00 c, 62 c, 55 c, 55 c, 52 c, 00 c,  \ no
00 c, 00 c, 63 c, 55 c, 55 c, 63 c, 41 c,  \ pq
-->

( 4x8font )

00 c, 00 c, 53 c, 66 c, 43 c, 46 c, 00 c,  \ rs
00 c, 20 c, 75 c, 25 c, 25 c, 12 c, 00 c,  \ tu
00 c, 00 c, 55 c, 55 c, 27 c, 25 c, 00 c,  \ vw
00 c, 00 c, 55 c, 25 c, 25 c, 53 c, 06 c,  \ xy
01 c, 02 c, 72 c, 34 c, 62 c, 72 c, 01 c,  \ z{
24 c, 22 c, 22 c, 21 c, 22 c, 22 c, 04 c,  \ |}
56 c, A9 c, 06 c, 04 c, 06 c, 09 c, 06 c,  \ ~?

decimal

( fzx-test )

  \ XXX TMP for debugging

need fzx-emit  need <file

create font  2048 allot
1 set-drive  font 0 s" lettra.fzx" <file
font fzx-font !
: zxtype  ( ca len -- )  bounds do  i c@ fzx-emit  loop  ;

cr .( fzx-emit is ready ) cr
' (fzx-emit) >code hex
cr .( Code start:   ) dup u.
cr .( Code length:  ) ' fzx-emit swap - u.
cr

( fzx-mode )

need fzx-emit

  \ XXX TODO -- finish -- the text input words in the kernel
  \ need some changes before this mode can work fine, and the
  \ FZX driver as well.

: fzx-at-xy  ( xc yc -- )  fzx-y c! fzx-x c!  ;
: fzx-cr  ( -- )  13 fzx-emit  ;
  \ : fzx-home  ( -- )  0 fzx-x !  ;  \ XXX TODO
: fzx-home  ( -- )  0 191 fzx-at-xy  ;

: fzx-mode  ( -- )
  \ Set the FZX printing mode.
  ['] fzx-emit ['] emit defer!
  ['] fzx-at-xy ['] at-xy defer!
  ['] fzx-home ['] home defer!
  ['] fzx-cr ['] cr defer!  ;

( fzx-emit )

create fzx-font 60000 ,  \ font address

0 constant margin  \ XXX TODO -- make it a variable

  \ XXX TODO make variable limits, therefore creating windows

create fzx-variables
  here 0 c, \ fzx-flags
    \ 0 = expecting a regular character
    \ 1 = expecting the column
    \ 2 = expecting the line
  here margin c, \ fzx-x (margin)
  here 191 c,  \ fzx-y

constant fzx-y  constant fzx-x  constant fzx-flags

-->

( fzx-emit )

need z80-asm  need scroll-1px-up

  \ Credits:
  \
  \ This code is a modified version of
  \ FZX driver - Copyright (c) 2013 Einar Saukas
  \ http://www.worldofspectrum.org/infoseekid.cgi?id=0028171

  \ XXX TODO -- make the top left position 0,0 instead of 0,191

  \ XXX TODO -- implement backspace -- the width of the latest
  \ character must be stored.

create (fzx-emit)  ( -- )

  asm

  \ Input:
  \  A = character to print

  fzx-flags hl ldp#  \ initial address of local variables
  m dec  \ check fzx-flags value by decrementing it

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ GET_LIN:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ GET_COL:
    hl incp  a m ld  ret

  then'

-->

( fzx-emit )

  \ expecting a regular character
  \ CHK_AT:

  16 cp#  z if  02 m ld#  ret  then
    \ 'AT' character?  if so, change `fzx-flags` to expect a
    \ line value next time, then return

  \ CHK_CR:
  m inc  \ increment fzx-flags to restore previous value (0)
  hl incp  \ point to fzx-x XXX why?
  fzx-font bc ftp  bc push  ix pop
    \ now IX = font addresss

  0D cp#  0000 jpz |mark 0 unresolved !
    \ carriage return? if so, jump to NEWLINE

  \ CHK_CHAR:
  a dec  2 ix cpx
    \ now A = char - 1
    \ compare with lastchar of the font

-->

( fzx-emit )

  cy if  \ jr nc, UNDEF_CHAR

    1F sub#  \ now A = char - 32

    cy if  \ jr nc, PRINT_CHAR

  2swap  \ exchange the two `if`, because they are not nested

  then

  \ UNDEF_CHAR:

  char ? 20 - a ld#  \ print '?' instead of invalid character

    then

-->

( fzx-emit )

  \ PRINT_CHAR:

  a inc
    \ now A = char - 31
  a l ld  00 h ld#  hl de ldp  hl addp  de addp
    \ now HL = (char - 31) * 3
  bc addp
    \ now HL references offset/kern in char table
  m e ld  hl incp  m a ld  3F and#  a d ld
    \ now DE = offset
  m xor  rlca  rlca  a c ld
    \ now C = kern
-->

( fzx-emit )

  hl push  de addp  hl decp
    \ now HL = char definition address
  exsp
    \ now HL references offset/kern in char table
  hl incp
    \ now HL references shift/width in char table
  a xor  rld
    \ now A = char shift
  af push  rld
    \ now A = (width - 1)
  0000 sta  |mark 1 unresolved !
    \ store the width at width1

  08 cp#  \ check if char width is larger than 8 bits
  rld  \ restore char shift/width

-->

( fzx-emit )


  000E de ldp#  nc if  234E de ldp#  then
    \ if cy, DE holds the instruction `0 c ld#`
    \ if nc, DE holds the instructions `m c ld` and `hl incp`
  \ NARROW_CHAR:
  0000 de stp  |mark 2 unresolved !
    \ modify the code at SMC to handle narrow/large chars;
    \ save the address of the patched address,
    \ to be resolved later at SMC

  hl incp  m a ld
    \ now HL references next char offset
    \ now A = LSB of next char offset
  l add  a e ld
    \ now E = LSB of next char definition address
-->

( fzx-emit )


  fzx-x hl ldp#  m a ld  c sub
    \ move left number of pixels specified by kern
  cy if  a xor  then
    \ stop moving if it would fall outside screen
  \ ON_SCREEN:
  a m ld  0000 fta  |mark 3 unresolved !
    \ now A = (width - 1)
    \ fetch the width at width1
  m add
    \ now A = (width - 1) + column
  0000 callc |mark 4 unresolved !  \ newline callc
    \ if char width won't fit then move to new line

-->

( fzx-emit )

  fzx-x bc ftp
  01 a ld#
  00 ix subx  \ now A = 1 - height
  b add  \ now A = fzx-y - height + 1

  \ XXX OLD
  \ 0C86 jpnc  \ call routine REPORT-5 ("Out of screen")
  nc if  \ end of screen
    \ XXX OLD
    hl pop  hl pop  ret  \ restore the stack and exit
    \ XXX NEW
    \ 0 ix b ftx  \ height of the font
    \ begin  (scroll-1px-up) call  step
  then

  af pop  BF add#
    \ now A = shift
    \ now A = range 0..191

  \ XXX TODO -- adapt this call to the Forth word
  22AA 2+ call  exaf
    \ call (PIXEL-ADDr) + 2 to calculate screen address
    \ now A' = (col % 8)
  here jr >relmark 5 unresolved !  \ jr CHK_LOOP

-->

( fzx-emit )

  \ MAIN_LOOP:

  begin  \ main loop

    m d ld  \ now D = 1st byte from char definition grid
    hl incp  \ next character definition
    \ SMC:
    2 unresolved @ >resolve
      \ resolve the command that patches here
    m c ld  hl incp
      \ either `0 c ld#` or `m c ld  hl incp`;
      \ now C = 2nd byte from char definition or zero

    a xor  exsp  exaf
      \ now A = zero (since there's no 3rd byte)
      \ now HL = screen address
      \ now A = (col % 8), A' = 0
    nz if
      a b ld  exaf
        \ now B = (col % 8)
        \ now A = 0, A' = (col % 8)
  \ ROTATE_PIXELS:
      begin  d srl  c rr  rra  step
        \ rotate pixels
        \ rotate right char definition grid in D,C,A
    then

-->

( fzx-emit )

  \ NO_ROTATE:

    l inc  l inc   m or  a m ld  \ put A on screen
    l dec  c a ld  m or  a m ld  \ put C on screen
    l dec  d a ld  m or  a m ld  \ put D on screen
    h inc  \ move screen address by 1 pixel down

    h a ld  07 and#
    z if  l a ld  20 add#  a l ld
      nc if  h a ld  08 sub#  a h ld  then
    then \ CHK_LOOP:

    5 unresolved @ >relresolve
-->

( fzx-emit )

  \ CHK_LOOP:

    exsp  \ now HL = char definition address
    l a ld
    e cp  \ check if reached next char definition address
  z until  \ loop otherwise (to MAIN_LOOP)

  hl pop  \ discard screen address from stack
  fzx-x hl ldp#
  m a ld  \ now A = column
\ WIDTH1:
  here 1+ dup 1 unresolved @ ! 3 unresolved @ !
    \ resolve the commands that store and fetch the width
  00 add#  \ now A = column + (width - 1)
  scf
  01 ix adcx  \ now A = column + width + tracking
-->

( fzx-emit )

  cy if
    \ outside the screen

  \ NEWLINE:
    0 unresolved @ >resolve  4 unresolved @ >resolve
      \ resolve the jumps here
    margin m ld#  \ move to initial column at left margin
    hl incp
    m a ld  \ now A = line
    00 ix subx  \ now A = line - height
  then

  \ EXIT:
  a m ld  \ move down a few pixels specified by height
  ret

  end-asm

-->

( fzx-emit )

code fzx-emit  ( c -- )

  hl pop  bc push
  l a ld  ' (fzx-emit) >code call
  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Strings {{{

( s= )  \ ==strings==

: s=  ( ca1 len1 ca2 len2 )  compare 0=  ;

( sconstant )

: sconstant  ( ca len "name" -- )
  here >r s, r> count 2constant  ;

( csliteral c" )

: csliteral  ( Compilation: ca len -- )
             ( Run-time: -- ca )
  2>r postpone ahead here 2r> s, >r postpone then
  r> postpone literal  ; immediate compile-only
  \ doc{
  \
  \ csliteral  ( Compilation: "text<quote>" -- ) ( Run-time: -- ca )
  \
  \ Compile a string _ca len_ which at run-time will
  \ be returned as a counted string.
  \
  \ }doc
  \
  \ Credits:
  \ Code from Gforth's `CLiteral`.

: c"  ( Compilation: "text<quote>" -- )
      ( Run-time: -- ca )
  [char] " parse postpone csliteral  ; immediate compile-only

  \ doc{
  \
  \ c"  ( Compilation: "text<quote>" -- ) ( Run-time: -- ca )
  \
  \ Parse a string delimited by double quotes and
  \ compile it into the current definition.
  \ At run-time the string will be returned as a
  \ counted string _ca_.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

( s\" )

only forth definitions
need wid-of  need parse-char
vocabulary escaped-voc
wid-of escaped-voc constant escaped-wordlist
also escaped-voc definitions

  \ The `escaped-voc` vocabulary contains the words whose names
  \ are characters that must be escaped after a backslash.
  \ Their execution returns the new character(s) on the stack
  \ (the first one at the top) and the count.
  \
  \ Most of the escaped chars are translated to one char, so
  \ they are defined as double constants.

7 1 2constant a  8 1 2constant b  27 1 2constant e
  \ \a = backspace
  \ \b = alert
  \ \e = escape
12 1 2constant f  10 1 2constant l  13 1 2constant n
  \ \f = form feed
  \ \l = line feed
  \ \n = new line (implementation dependent)
char " 1 2constant q  13 1 2constant r  9 1 2constant t
  \ \q = double quote
  \ \r = carriage return
  \ \t = horizontal tab
11 1 2constant v  0 1 2constant z
  \ \v = vertical tab
  \ \z = null character
char " 1 2constant "  char \ 1 2constant \
  \ \" = double quote
  \ \\ = backslash

: m  ( -- c1 c2 2 )  10 13 2  ;
  \ \m = carriage return and line feed

: (x)  ( "c" -- n )
  parse-char upper 16 digit? 0= #-260 ?throw  ;
  \ Parse an hex digit and convert it to a number.

: x  ( "cc" -- c 1 )  (x) 16 * (x) + 1  ;
  \ \x = hex character code
  \ Parse the 8-bit hex number of a character code.

-->

( s\" )

only forth definitions  need char>string   need search-wordlist
                        need chars>string  need s+

: unescape-char  ( c -- c1..cn n )
  dup char>string escaped-wordlist search-wordlist
  if  nip execute  else  [char] \ 2  then  ;
  \ Translate a escaped char to a number of chars and their
  \ count.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

: parse-escaped-string  ( "text<quote>"  -- ca len )
  0 0  \ dummy empty string to start with
  begin  parse-char dup [char] " <>  while  \ not finished?
    dup [char] \ =  \ possibly escaped char?
    if    drop parse-char unescape-char
    else  1  then  chars>string s+
  repeat  drop  ;
  \ Parse a text string delimited by a double quote, using the
  \ translation rules described by Forth-2012's `s\"`, and
  \ returning the string _ca len_ in the circular string
  \ buffer.

-->

( s\" )

  \ XXX TODO -- need parse-escaped-string

: s\"  ( Interpretation: "text<quote>" -- ca len )
       ( Compilation: "text<quote>" -- )
       ( Run-time: -- ca len )
  parse-escaped-string compiling? if  postpone sliteral  then
  ; immediate

  \ XXX TODO documentation
  \ doc{
  \
  \ s\"  ( "text<quote>"  - ca len )
  \
  \ }doc

( .\" )

need s\"
  \ XXX TMP
  \ XXX TODO -- need parse-escaped-string

: .\"  ( Compilation: "text<quote>" -- )
       ( Run-time: -- ca len )
  compile (.")  parse-escaped-string s,
  ; immediate compile-only

( char>string chars>string )

: char>string  ( c -- ca len )  1 allocate-string tuck c! 1  ;
  \ Convert the char _c_ to a string _ca len_ in the circular
  \ string buffer.

: chars>string  ( c1..cn n -- ca len )
  dup if
    dup allocate-string swap 2dup 2>r  ( c1..cn ca n )
    bounds do  i c!  loop  2r>
  else  pad swap  then  ;
  \ Convert _n_ chars to a string _ca len_ in the circular
  \ string buffer.
  \ c1..cn = chars to make the string with
  \          (_c1_ is the last one)
  \ n = number of chars

( +place )

  \ Credits:
  \
  \ Code from Afera.

: +place  ( ca1 len1 ca2 )
  2dup c@ + over c!  dup c@ 1+ + smove  ;
  \ Add the string _ca1 len1_ to the end of the counted string
  \ _ca2_.

( s+ )

  \ Credits:
  \
  \ Code adapted from Afera.

[defined] lengths
?\ : lengths   2over nip over  ;
   ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )

: s+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  lengths + >r           ( ca1 len2 ca2 len2 ) ( r: len3 )
  r@ allocate-string >r  ( r: len3 ca3 )
  2 pick r@ +            ( ca1 len1 ca2 len2 len1+ca3 )
  smove                  ( ca1 len1 )  \ 2nd string to buffer
  r@ smove               \  1st string to buffer
  r> r>  ;
  \ Append the string _ca2 len2_ to the end of string _ca1
  \ len1_ returning the string _ca3 len3_ in the circular
  \ string buffer.

( s' )

  \ Credits:
  \
  \ Code from Afera.

  \ doc{
  \
  \ s'  ( Compilation: "text<'>" -- ) ( Run-time:  -- ca len )
  \
  \ }doc

: s'  ( Compilation: "ccc<'>" -- ) ( Run-time:  -- ca len )
  [char] ' parse-string  ; immediate

( begin-stringtable end-stringtable )

  \ Credits:
  \
  \ Code adapted from Forth Foundation Library (stt module).
  \ XXX TODO Published under LGPL ?

: begin-stringtable  ( "name" -- stringtable-sys )
  \ Start a named stringtable definition.
  create  here ( a1 ) cell allot here  ( a1 a2 )
    \ stringtable-sys:
    \   a1 = pointer (address of address) to the strings index
    \   a2 = address of the compiled strings
  does> ( n -- ca len )
    \ Return the nth string.
    ( n pfa )  @ swap cells + @ count  ;

: end-stringtable  ( stringtable-sys -- )
  \ End the stringtable definition.
  \ stringtable-sys:
  \   a1 = pointer (address of address) to the strings index
  \   a2 = address of the compiled strings
  ( a1 a2 )
  here rot !   \ set the index
  here swap  ( a3 a2 )
  begin  2dup <>  while
    dup ,   \ store the start of the string in the index
    count chars +  \ move to the next string
  repeat  2drop  ;

  \ Usage example:
  \
  \ begin-stringtable esperanto-number
  \   s" nulo" s,  s" unu" s,  s" du" s,  s" tri" s,
  \ end-stringtable
  \ 0 esperanto-number type
  \ 3 esperanto-number type

( csliteral cslit )

  \ XXX TODO test

: cslit  ( -- ca len )  r@ dup c@ 1+ r> + >r  ;

: csliteral  ( ca -- )
  compile cslit s,  ; immediate compile-only

( hunt )

  \ Credits:
  \
  \ Code from Wil Baden's Charscan library (2003-02-17),
  \ public domain.

: hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )
  search 0= if  chars + 0  then  ;

  \ doc{
  \
  \ hunt  ( ca1 len1 ca2 len2 -- ca3 len3 )

  \ Search a string _ca1 len1_ for a substring _ca2 len2_.
  \ Return the part of _ca1 len1_ that starts with the first
  \ occurence of _ca2 len2_.
  \
  \ ca1 len1 = string
  \ ca2 len2 = substring
  \ ca3 len3 = ca1+i len1-i
  \
  \ }doc

( #spaces )

need under+

: #spaces  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Count spaces in a string.

  \ Credits:
  \
  \ Code improved from:
  \ http://forth.sourceforge.net/mirror/comus/index.html

( #chars )

  \ XXX UNDER DEVELOPMENT

: #chars  ( ca len c -- +n )
  0 2swap 0 do
    ( c count ca ) count over = under+  loop  2drop abs  ;
  \ Count spaces in a string.

( /name first-name trim last-name )

  \ Credits:
  \
  \ Code from Galope.

: /name  ( ca1 len1 -- ca2 len2 ca3 len3 )
  \ ca1 len1 = Text.
  \ ca2 len2 = Same text, from the start of its first name.
  \ ca3 len3 = Same text, from the char after its first name.
  bl skip 2dup bl scan  ;

: first-name  ( ca1 len1 -- ca2 len2 )  /name nip -  ;
  \ Get the first name from a string.
  \ A name is a substring separated by spaces.

: trim ( ca1 len1 -- ca2 len2 )  -leading -trailing  ;
  \ Remove leading and trailing spaces from a string.

: last-name  ( ca1 len1 -- ca2 len2 )
  trim
  begin  2dup bl scan bl skip dup
  while  2nip  repeat  2drop  ;
  \ Get the last name from a string.
  \ A name is a substring separated by spaces.

( prefix? suffix? )

need s=  need [if]

  \ Credits:
  \
  \ Code adapted from Galope (module
  \ string-prefix-question.fs).

[needed] prefix? [if]
: prefix?  ( ca1 len1 ca2 len2 -- f ) tuck 2>r min 2r> s=  ;
[then]

  \ Credits:
  \
  \ Code from Galope (module string-suffix-question.fs).

[needed] suffix? [if]
: suffix? ( ca1 len1 ca2 len2 -- wf )
  \ Is string _ca2 len2_ the end of string _ca1 len1_?
  2swap dup 3 pick - /string s=  ;
[then]

( -prefix )

  \ Credits:
  \
  \ Code from Galope (module minus-prefix.fs).

need string-prefix?

: -prefix  ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a prefix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-prefix?
  if  swap r@ + swap r> -  else  rdrop  then  ;

( -suffix )

  \ Credits:
  \
  \ Code from Galope (module minus-suffix.fs).

need string-suffix?

: -suffix ( ca1 len1 ca2 len2 -- ca1 len1 | ca3 len3 )
  \ Remove a suffix _ca2 len2_ from a string _ca1 len1_.
  dup >r 2over 2swap string-suffix?
  if  r> -  else  rdrop  then  ;

( ud>str d>str chop )

  \ Credits:
  \
  \ Code from Galope (module ud-to-str.fs).

: ud>str  ( ud -- ca len )  <# #s #>  ;

  \ Credits:
  \
  \ Code from Galope (module d-to-str.fs).

: d>str  ( ud -- ca len )  tuck dabs <# #s rot sign #>  ;

  \ Credits:
  \
  \ Code from Galope (module chop.fs).

: chop  ( ca len -- ca' len' )  1- swap char+ swap  ;
  \ Remove the last character from string _ca len_.

( save-counted-string )

: save-counted-string  ( ca1 len1 -- ca2 )
  dup 1+ allocate-string dup >r place r>  ;

  \ doc{

  \ save-counted-string  ( ca1 len1 -- ca2 )

  \ Save the string _ca1 len1_ in the circular string buffer as
  \ a counted string and return its new address _ca2_.

  \ }doc

( replaces )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \
  \ Code adapted from the Forth-2012 documentation.

s" /counted-string" environment? 0= [if] 256 [then]
chars constant string-max

vocabulary replaces-voc
wid-of replaces-voc constant wid-subst
  \ wordlist id of the wordlist used to hold substitution names and replacement text.

[defined] vfxforth [if] \ vfx forth
  : makesubst \ c-addr len -- c-addr
    get-current >r wid-subst set-current
    ($create)  \ like create but takes c-addr/len
    r> set-current
    here string-max allot 0 over c! \ create buffer space
    ;
  \ given a name string create a substution and storage space.
  \ return the address of the buffer for the substitution text.
  \ this word requires system specific knowledge of the host forth.
  \ some systems may need to perform case conversion here.
[then]

( replaces )

[defined] (wid-create) [if] \ swiftforth
: makesubst \ c-addr len -- c-addr
  wid-subst (wid-create)
  \ like create but takes c-addr/len/wid
  last @ >create !
  here string-max allot 0 over c! \ create buffer space
  ;
[then]

-->

( replaces )

: findsubst  ( ca len -- xt f | 0 )
  wid-subst search-wordlist  ;
  \ Given a name string, find the substitution.
  \ Return _xt_ and _f_ if found, or just zero if not found.

: replaces \ text tlen name nlen --
  2dup findsubst if
    nip nip execute    \ get buffer address
  else
     makesubst
  then
  place  ;

  \ doc{
  \
  \ replaces  ( ca1 len1 ca2 len2 -- )

  \ Set the string _ca1 len1_ as the text to substitute for
  \ the substitution named by _ca2 len2_. If the substitution
  \ does not exist it is created. The  program may then reuse
  \ the buffer _ca1 len1_ without affecting the definition  of
  \ the substitution.

  \ Ambiguous conditions occur as follows:

  \   * The substitution cannot be created;
  \   * The name of a substitution contains the "%" delimiter character.

  \ `replaces` may allot  data space and  create a definition.
  \ This breaks  the contiguity of  the current region  and is
  \ not allowed during compilation of a colon definition
  \
  \ }doc



  \ }}} =======================================================
  \ Printing {{{

( tabulate tab-stop )

need column

  \ 2015-12-14
  \ XXX FIXME

variable tab-stop  8 tab-stop !

: tabulate  ( -- )  column 1+ tab-stop @ tuck mod - spaces  ;

( 'cr' 'tab' 'bs' crs tab tabs backspace backspaces )

 6 constant 'tab'
 8 constant 'bs'
13 constant 'cr'

: tab          ( -- )  'tab' emit  ;
: backspace    ( -- )  'bs'  emit  ;

: crs           ( n -- )  'cr'  emits  ;
: tabs          ( n -- )  'tab' emits  ;
: backspaces    ( n -- )  'bs'  emits  ;

( column last-column row last-row at-x at-y )

: column  ( -- col )  xy drop  ;
  \ Current column (x coordinate).

: last-column  ( -- row  )  column 1-  ;
  \ Last column (x coordinate).

: row  ( -- row )  xy nip  ;
  \ Current row (y coordinate).

: last-row  ( -- row  )  row 1-  ;
  \ Last row (y coordinate).

: at-x  ( col -- )  row at-xy  ;
  \ Set the cursor
  \ at the given column (x coordinate)
  \ and the current row (y coordinate).

: at-y  ( row -- )  column swap at-xy  ;
  \ Set the cursor
  \ at the current column (x coordinate)
  \ and the given row (y coordinate).

( ud.r ud. )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

: ud.r  ( d n -- )  >r <# #s #> r> over - 0 max spaces type  ;

  \ : u.r  ( n1 n2 -- )  >r 0 r> ud.r  ;

: ud.  ( d -- )  0 ud.r space  ;

( print )

  \ XXX UNDER DEVELOPMENT
  \ Adapted from Galope <print.fs>.

need last-row  need /name

  \ export

variable #printed   \ Printed chars in the current line.
variable #indented   \ Indented chars in the current line.
: printed+  ( u -- )  #printed +!  ;
: indented+  ( u -- )  #indented +!  ;
: (.word) ( ca len -- )  dup printed+ type  ;
: .char  ( c -- )  emit 1 printed+  ;
: not-at-home?  ( -- f )  xy +  ;

  \ export

: no-printed  ( -- )  #printed off #indented off  ;
: print-home  ( -- )  home no-printed  ;
: print-page  ( -- )  page print-home  ;

-->

( print )

: print-start-of-line  ( -- )
  #printed @ trm+move-cursor-left no-printed  ;

  \ : print-cr  ( -- )  not-at-home? if  cr  then  no-printed  ;
  \ XXX OLD first version

  \ hide

: at-last-start-of-line?  ( -- wf )
  xy last-row = swap 0= and  ;
: not-at-start-of-line?  ( -- wf )  column 0<>  ;
: print-cr?  ( -- wf )
  not-at-home? not-at-start-of-line? and
  \ xxx fixme 2012-09-30 what this was for?:
  \ at-last-start-of-line? 0= or
  ;

  \ export

defer (print-cr) ' (print-cr) ' cr defer!

: print-cr print-cr? ?? (print-cr) no-printed ;

variable print-width

-->

( print )

  \ hide

: previous-word?  ( -- wf )  #printed @ #indented @ >  ;
: ?space  ( -- ) previous-word? if  bl .char  then  ;
: current-print-width  ( -- u )
  print-width @ ?dup 0= ?? cols  ;
: too-long?  ( u -- wf )
  1+ #printed @ + current-print-width >  ;
: .word  ( ca len -- )
  dup too-long? if  print-cr  else  ?space  then  (.word)  ;

-->

( print )

: (print-indentation)  ( u -- )
  dup trm+move-cursor-right dup indented+ printed+  ;

  \ export

: print-indentation  ( u -- )  ?dup ?? (print-indentation)  ;

  \ hide

: >word  ( ca1 len1 ca2 len2 -- ca2 len2 ca1 len4 )
  \ ca1 len1 = Text, from the start of its first word.
  \ ca2 len2 = Same text, from the char after its first word.
  \ ca1 len4 = First word of the text.
  tuck 2>r -  2r> 2swap  ;

: first-word  ( ca1 len1 -- ca2 len2 ca3 len3 )  /name >word  ;

: (print)  ( ca1 len1 -- ca2 len2 )  first-word .word  ;

-->

( print )

  \ export

: print  ( ca len --)
  begin  dup   while  (print)  repeat  2drop  ;

  \ Suggested usage in the application:

  \ 4 value indentation
  \ : paragraph  ( ca len -- )
  \   print-cr indentation print-indentation print  ;


  \ }}} =======================================================
  \ Decompressor {{{

( zx7 )

  \ XXX TODO  -- adapt

  \ }}} =======================================================
  \ Graphics {{{

( udg! udg: )  \ ==graphics==

need os-udg

: udg!  ( b0..b7 c -- )
  128 - 8 * os-udg @ + dup 7 + do  i c!  -1 +loop  ;
  \ doc{
  \
  \ udg!  ( b0..b7 c -- )
  \
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

: udg:  ( b0..b7 c "name" -- )  dup constant  udg!  ;
  \ doc{
  \
  \ udg:  ( b0..b7 c "name" -- )
  \
  \ Create a constant called "name" for the UDG char _c_.
  \ Store the given 8 bytes into the UDG char _c_.
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 128..255
  \
  \ }doc

( hires-emit-udg )

need z80-asm  need (hires-emit)

code hires-emit-udg  ( xc yc b -- )

  \ Display the user graphic character _b_ (0..255) at graphic
  \ coordinates _x y_. The system variable "UDG" is supossed to
  \ hold the address of a graphic charset (the address of the
  \ char 0 bitmap).
  \
  \ The UDG character will be printed with overwritting
  \ (equivalent to `1 overwrite`).

  \ XXX FIXME  -- crash?

  hl pop  l a ld
  de pop  hl pop  bc push  e b ld  l c ld
  5C7B de ftp  \ system variable UDG
  (hires-emit) call
  bc pop  next ix ldp#  jpnext
  end-code

\ (hires-emit) \

need z80-asm  need (pixel-addr)

  \ Credits:
  \
  \ Code Adapted from "SMOOTH MOVE",
  \ written by Simon N.  Goodwin,
  \ published on Todospectrum, issue 2 (1984-10), page 16.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

create (hires-emit)  ( -- )

  \ Print a 8x8 bits char at high resolution coordinates.

  \ Input:
  \   DE = address of the first char (0) bitmap in a charset
  \   A = char code (0..255)
  \   B = y coordinate
  \   C = x coordinate
  \ Modifies:
  \   AF BC HL IX DE

  \ XXX FIXME  -- crash?

  asm

  0 h ld#  a l ld  hl addp  hl addp  hl addp  de addp
  hl push  ix pop  bc hl ldp  hl push  8 c ld#

  begin

    hl pop  h dec  hl push  h inc
      \ next line

    bc push  hl bc ldp  (pixel-addr) call  bc pop
      \ convert the coords H (x) and L (y) to an address in HL
      \ and a bit in A

    a b ld  a xor  b or  0 ix a ftx
    nz if   exde  0 h ld#  a l ld  8 a ld#  b sub  a b ld
            begin  hl addp  step  exde
            m a ld  d xor  a m ld
            hl incp  e a ld  then

    m xor  a m ld  ix incp  c dec
      \ next char scan, one screen line less

  z until  hl pop  ret  end-asm

( ocr )

  \ Credits:
  \
  \ Adapted from anonymous code published on Todospectrum,
  \ issue 19 (1986-03), page 65.
  \ http://microhobby.speccy.cz/zxsf/revistas-ts.htm

need z80-asm  need ocr-chars

code ocr  ( col line -- n )

  \ Try to recognize the char printed at the given cursor
  \ coordinates, using the charset whose first printable char
  \ is pointed by the variable `ocr-charset`. The variable
  \ `ocr-chars` holds the number of chars in the charset,
  \ and `ocr-first` holds the code of the first char in the
  \ charset.  If succesful, return the char number _n_
  \ according to the said variables.  If no char is recognized,
  \ return 0. Inverse characters are not recognized.

  de pop  hl pop  bc push
    \ get row, get col, save the Forth IP
  l b ld  e c ld  ocr-charset fthl
    \ b=colum, c=row, hl=udg

  c a ld  rrca  rrca  rrca  E0 and#  b xor  a e ld
  c a ld  18 and#  40 xor#  a d ld
    \ de = screen address
  0 de stp |mark 0 unresolved !
    \ modify the code to get the screen address later

  ocr-chars fta  a b ld
    \ number of chars in the charset
  begin
    \ b=remaining chars
    \ hl = address of scan 0 of the current char
    bc push  hl push
    0 de ldp#  \ restore the screen address
    |mark 0 unresolved @ !
      \ compilation: resolve the address of the screen address
    \ de = screen address

-->

( ocr )

    08 b ld# \ scans
    begin
      de ftap  m xor  \ scan match?
      here jrnz >relmark 1 unresolved !
        \ if not, goto next_char
      d inc  hl incp  \ update the pointers
    step  \ next scan

    \ all eight scans match: udg found

    bc pop  bc pop
      \ discard the saved pointer
      \ b = chars left
    ocr-chars fta  b sub  a b ld
    ocr-first fta  b add  a b ld
      \ b = char number
    here jr >relmark 2 unresolved !
      \ go to end

    \ next_char:
    1 unresolved @ >relresolve
    hl pop  0008 de ldp#  de addp  bc pop
  step
  \ b = 0 (no char matches)

  \ end:
  2 unresolved @ >relresolve  0 h ld#  b l ld
  bc pop  pushhl jp  end-code

( ocr-charset ocr-first ocr-chars ascii-ocr udg-ocr )

variable ocr-charset

  \ doc{
  \
  \ ocr-charset  ( -- a )
  \
  \ Variable that holds the address of the first printable char
  \ in the charset used by `ocr`. By default it contains
  \ 0x3D00, the address of the space char in the ROM charset.
  \
  \ }doc

variable ocr-first

  \ doc{
  \
  \ ocr-first  ( -- a )
  \
  \ Variable that holds the code of the first printable char in
  \ the charset used by `ocr`. By default it contais 0x80, the
  \ first UDG.
  \
  \ }doc

variable ocr-chars

  \ doc{
  \
  \ ocr-chars  ( -- a )
  \
  \ Variable that holds the number of chars used by `ocr`, from
  \ the address pointed by `ocr-charset`. By default it contais
  \ 0x5F, the number of printable ASCII chars in the ROM
  \ charset.
  \
  \ }doc

need os-chars  need os-udg

: ascii-ocr  ( -- )
  \ Set `ocr` to work with the ASCII charset pointed by the
  \ system variable CHARS.
  os-chars @ 256 + ocr-charset !
  32 ocr-first !
  95 ocr-chars !  ;

: udg-ocr  ( n -- )
  \ Set `ocr` to work with the first _n_ chars of the UDG
  \ set pointed by the system variable UDG.
  os-udg @ ocr-charset !
  128 ocr-first !
  ocr-chars !  ;

19 udg-ocr  \ default

( pixel-addr )

need (pixel-addr)

  \ XXX TODO use z80-asm

code pixel-addr  ( xc yc -- n a )
  \ Address of a pixel in the screen.
  \ x = 0..255
  \ y = 0..191
  \ n = position of the pixel (0..7) in its screen address
  \ a = address of the pixel byte in the screen bitmap
  E1 c,  D1 c,            \ pop hl / pop de
  C5 c,                   \ push bc
  40 05 + c,              \ ld b,l ; b=y
  48 03 + c,              \ ld c,e ; c=x
  CD c, (pixel-addr) ,       \ call (pixel-addr)
  C1 c,                   \ pop bc
  16 c, 0 c,  58 07 + c,  \ ld d,0 / ld e,a
  C3 c, pushhlde ,        \ jp pushhlde
  end-code

\ (pixel-addr) \

create (pixel-addr)  ( -- a )

  \ This Z80 routine is an alternative entry point to the
  \ "pixel-add" ROM routine (0x22AA), to let the range of the y
  \ coordinate to be 0..191 instead of 0..175.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm
  3E c, BF c,   \ ld a,191 ; max Y coordinate
  90 00 + c,    \ sub b
  C3 c, 22B0 ,  \ jp 0x22B0 ; and return
  end-asm

\ (pixel-addr) \

need z80-asm

create (pixel-addr)  ( -- a )

  \ This Z80 routine is a modified copy of the "pixel-add" ROM
  \ routine (0x22AA), to let the range of the y coordinate to
  \ be 0..191 instead of 0..175. Calling this code is a bit
  \ faster than calling the version that uses the ROM, because
  \ the necessary jump is saved and a useless `and a` has been
  \ removed.

  \ a = address of the routine

  \ Input registers:
  \   c = x cordinate (0..255)
  \   b = y coordinate (0..191)
  \ Output registers:
  \   hl = address of the pixel byte in the screen bitmap
  \   a = position of the pixel in the byte address (0..7),
  \       note: position 0=bit 7, position 7=bit 0.

  asm

  BF a ld#  b sub
    \ b= adjusted Y coordinate (0..191)

  a b ld  rra  scf  rra  a and  rra
    \ the line number from top of screen to B
    \                     0xxxxxxx
    \ set carry flag
    \                     10xxxxxx
    \ clear carry flag
    \                     010xxxxx

  b xor  F8 and#  b xor  a h ld
    \
    \ keep the top 5 bits 11111000
    \                     010xxbbb
    \ transfer high byte to H

  c a ld
    \ the x value 0..255

  rlca rlca rlca  b xor  C7 and#
    \ the y value
    \ apply mask             11000111

  b xor  rlca  rlca
    \ restore unmasked bits  xxyyyxxx
    \ rotate to              xyyyxxxx
    \ required position      yyyxxxxx

  a l ld
    \ low byte to L

  c a ld  07 and#
    \ form the pixel position in A

  ret

  end-asm

( plot )

need (pixel-addr)

code plot  ( xc yc -- )

  D9 c,               \ exx ; save Forth IP
  E1 c,               \ pop hl
  C1 c,               \ pop bc
  40 05 + c,          \ ld b,l
  \ b = y coordinate
  \ c = x coordinate
  ED c, 43 c, 5C7D ,  \ ld (0x5C7D),bc ; update COORDS
  CD c, (pixel-addr) ,   \ call (pixel-addr)
  \ hl = screen address
  \ a = pixel position in hl (0..7)
  CD c, 22EC ,        \ call 0x22EB ; ROM PLOT-SUB + 7
  D9 c,               \ exx ; restore Forth IP
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)

  end-code

( set-pixel )

  \ Set a pixel without changing the color attributes.

  \ Credits:
  \
  \ Author of the original code: Jos Manuel Lazo.
  \ Published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code set-pixel  ( xc yc -- )

  \ XXX FIXME system halt?

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m or  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( reset-pixel )

  \ Reset a pixel without changing the color attributes.

  \ Credits:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code reset-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  cpl  m and  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( toggle-pixel )

  \ Toggle a pixel without changing the color attributes.

  \ Credits:
  \
  \ Based on code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need (pixel-addr)  need z80-asm

code toggle-pixel  ( xc yc -- )

  hl pop  de pop  bc push
  l b ld  e c ld  (pixel-addr) call
  a b ld  b inc  1 a ld#
  begin  rrca  step
  m xor  a m ld  \ combine pixel with byte in the screen
  bc pop  jpnext

  end-code

( test-pixel )

need (pixel-addr)  need z80-asm

code test-pixel  ( xc yc -- f )
  hl pop  de pop  bc push
  \ l = y coordinate
  \ e = x coordinate
  l b ld  e c ld
  \ b = y coordinate
  \ c = x coordinate
  (pixel-addr) call
  \ hl = screen address
  \ a = pixel position in hl
  a b ld  b inc  m a ld
  begin  rlca  step \ rotate to bit 0
  bc pop  \ restore the Forth IP
  1 and#  \ pixel?
  ' true >code jpnz
  ' false >code jp
  end-code

( rdraw )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83's `DRAW`.

need z80-asm

code rdraw  ( xc yc -- )

  \ Draw a line relative to the current coordinates.
  \
  \ xc yc = relative coordinates from the current ones

  \ XXX FIXME -- use the whole screen

  hl pop  de pop  bc push
  de bc ldp

  \ hl = y
  \ bc = x
  1 e ld#
  b 7 bit  \ negative x?
  nz if  c a ld  neg  -1 e ld#  a c ld  then  \ negative x

  l b ld   \ y
  1 d ld#
  h 7 bit  \ negative y?
  nz if  b a ld  neg  -1 d ld#  a b ld  then  \ negative y

  24BA call \ alternative entry to the DRAW-LINE ROM routine

  bc pop

  jpnext end-code

\ (rdraw) \

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- finish adapting the DRAW-LINE ROM routine

need z80-asm

create (rdraw)
asm


  \  ld      a,c
  \  cp      b
  \  jr      nc,dl_x_ge_y
  \
  \  ld      l,c
  \  push    de
  \  xor     a
  \  ld      e,a
  \  jr      dl_larger
  \
  \ dl_x_ge_y:
  \  or      c
  \  ret     z
  \
  \  ld      l,b
  \  ld      b,c
  \  push    de
  \  ld      d,$00
  \
  \ dl_larger:
  \  ld      h,b
  \  ld      a,b
  \  rra
  \
  \ d_l_loop:
  \  add     a,l
  \  jr      c,d_l_diag
  \
  \  cp      h
  \  jr      c,d_l_hr_vt
  \
  \ d_l_diag:
  \  sub     h
  \  ld      c,a
  \  exx
  \  pop     bc
  \  push    bc
  \  jr      d_l_step
  \
  \ d_l_hr_vt:
  \  ld      c,a
  \  push    de
  \  exx
  \  pop     bc
  \
  \ d_l_step:
  \  ld      hl,($5c7d) ; coords
  \  ld      a,b
  \  add     a,h
  \  ld      b,a
  \  ld      a,c
  \  inc     a
  \  add     a,l
  \  jr      c,d_l_range
  \  jr      z,report_bc ; XXX TODO -- adapt, integer out of range
  \
  \ d_l_plot:
  \  dec     a
  \  ld      c,a
  \  call    l22e5      ; routine plot-sub \ XXX TODO
  \ XXX TODO -- replace `call PLOT-SUB` with `call PLOT-SUB+7`
  \  exx
  \  ld      a,c
  \  djnz    d_l_loop
  \
  \  pop     de
  \  ret
  \
  \ d_l_range:
  \  jr      z,d_l_plot

end-asm

( adraw ) \ from Abersoft Forth

  \ Credits:
  \
  \ Code adapted from Abersoft Forth's `DRAW`.

need plot

2variable x1  2variable incx  2variable y1  2variable incy

  \ System variables used:
  \   23677 = COORDX
  \   23678 = COORDY

: adraw  ( xc yc -- )

  \ Draw a line from the current coordinates to the given
  \ absolute coordinates.

  23678 c@ ( y0 ) dup 0 swap y1 2! - dup abs rot
  \ ( +-ydiff ydiff x )
  23677 c@ ( x0 ) dup 0 swap x1 2! - dup abs rot
  \ ( +-ydiff +-xdiff xdiff ydiff )
  max >r dup 0<  \ negative xdiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incx 2! drop dup 0<  \ negative ydiff?
  if    abs 0 swap r@ ud/mod dnegate
  else  0 swap r@ ud/mod  then
  incy 2! drop r> 1+ 0
  do  x1 @ y1 @ plot
      x1 2@ incx 2@ d+ x1 2!
      y1 2@ incy 2@ d+ y1 2!  loop  ;

( attr )

need z80-asm need (attr-addr)

code attr ( col line -- b )

  \ Return the color attribute of the given cursor coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  m l ld  0 h ld#
    \ hl = attribute
  pushhl jp

  end-code

( attr-addr )

need z80-asm need (attr-addr)

code attr-addr ( col line -- a )

  \ Return the color attribute address of the given cursor
  \ coordinates.

  de pop  hl pop  l d ld
    \ d = col
    \ e = line
  (attr-addr) call
    \ hl = attribute address
  pushhl jp

  end-code

\ (attr-addr) \

need z80-asm

create (attr-addr)  ( -- a )

  \ Address of a Z80 routine that calculates the color
  \ attribute address of a cursor position.  This is a modified
  \ version of the ROM routine at 0x2583.

  \ Input:
  \   d = column (0..31)
  \   e = line (0..23)
  \ Output:
  \   hl = address of the attribute in the screen

  asm

  e a ld  \ line to a 0x00..0x17 (max 00010111)
  rrca rrca rrca  \ rotate bits left
  a e ld  \ store in d as an intermediate value
  E0 and#  \ pick up bits 11100000 (was 00011100)
  d xor  \ combine with column 0x00..0x1F
  a l ld  \ low byte now correct
  e a ld  \ bring back intermediate result from d
  03 and#  58 xor#
    \ mask to give correct third of screen
    \ combine with base address
  a h ld  \ high byte correct
  ret

  end-asm

( circle )

  \ XXX UNDER DEVELOPMENT

  \ Code adapted from:
  \ http://worldofspectrum.org/forums/discussion/22058/bresenhams-circle-algorithm/

  \ x^2+y^2=r^2 represents the real variable equation of a
  \ circle which is to be plotted using a grid of discrete
  \ pixels where each pixel has integer coordinates.

  \ Note. original ROM circles are slightly displaced to the
  \ right as noticed.

need z80-asm

create circle-plot  ( -- a )
  asm
  hl push  bc push  de push
  ' plot >code call  \ XXX TODO
  de pop  bc pop  hl pop  ret
  end-asm

code circle  ( xc yc radius -- )

  \ d=x0
  \ e=y0
  \ a=radious

    \ pop hl
    \ po

  \ ;*************************************
  \ ;*******Setup of parameters***********
  \ ;*************************************

    \ ld h,0  \ H is x -- init to 0
    \ ld l,a  \ L is y -- init to radius
  0 h ld#  l a ld
  exx  cpl  a c ld  FF b ld#
  bc incp  \ bc' is -radius

    \ exx
    \ cpl
    \ ld c,a
    \ ld b,$ff
    \ inc bc     ;bc' is -radius
    \ ld hl,1
    \ add hl,bc
    \ ex de,hl   ;de' is f=1-radius ; f error control
    \ ;and a
    \ rl c
    \ rl b       ;-2*radius
    \ ld hl,5
    \ add hl,bc  ;hl'  is ddfy =5-2*r
    \ ld bc,3    ;bc' is  ddfx =3
    \ exx

  \ ;*************************************
  \ ;*******Main circle procedure*********
  \ ;*************************************

  \ Loop:

  \ ;*******Set 8 pixels, one for each circle's octant*********
    \ ld A,D ;Point #1
    \ add A,H
    \ ld c,A
    \ ld A,E
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #2
    \ sub L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #4
    \ sub H
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #3
    \ add A,L
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #5
    \ add A,L
    \ ld c,A
    \ ld A,E
    \ add A,H
    \ ld b,A
    \ call plotpixel

    \ ld A,E ;Point #6
    \ sub H
    \ ld b,A
    \ call plotpixel

    \ ld A,D ;Point #8
    \ sub L
    \ ld c,A
    \ call plotpixel

    \ ld A,E ;Point #7
    \ add A,H
    \ ld b,A
    \ call plotpixel

  \ ;********Main logic***********
  \ Control:
    \ ld a,h  ;H is x
    \ cp l    ;L is y
    \ jr nc,end_circle   ;While  (y > x)

    \ exx
    \ bit 7,d  ;if f>0
    \ ;exx
    \ jr nz,fneg

  \ fpos:
    \ ;exx

    \ ex de,hl
    \ add hl,de
    \ ex de,hl

    \ inc hl  ;hl' is ddfy
    \ inc hl
    \ exx

    \ dec l
    \ jr fneg2

    \ ;end if
  \ fneg:
    \ ;exx

    \ ex de,hl
    \ add hl,bc
    \ ex de,hl
    \ exx

  \ fneg2:
    \ exx
    \ inc bc   ;bc' is ddfx
    \ inc bc

    \ inc hl
    \ inc hl
    \ exx

    \ inc h           ;H is x

    \ jr Loop     ;end While
  \ end_circle:
    \ exx
    \ ld hl,$2758 ;HL' must contain $2758 on return to the Zx OS
    \ exx
    \ ret


  end-code

( fade )

  \ Do a screen fade to black, by
  \ decrementing the values of paper and
  \ ink in a loop.

  \ Credits:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 46: <http://microhobby.org/mhes7.htm>.

need z80-asm

code fade  ( -- )
  bc push
  8 b ld#
  \ do:
  begin  5AFF hl ldp#  halt  halt
    begin
      m a ld  a d ld  07 and#  nz if  a dec  then
      a e ld  a d ld  38 and#  nz if  8 sub#  then
      e or  d xor  3F and#  d xor
      a m ld  hl decp  h a ld
      58 cp#
    cy until
  step
  bc pop  jpnext
  end-code

( inverted )

  \ Invert the pixels of the whole screen.

  \ Credits:
  \
  \ Code adapted from a routine written by Javier Granadino,
  \ published on Microhobby, issue 133 (1987-06), page 7:
  \ http://microhobby.org/numero133.htm
  \ http://microhobby.speccy.cz/mhf/133/MH133_07.jpg

need z80-asm

code inverted  ( -- )

  4000 hl ldp#
  begin   m a ld  cpl  a m ld
          hl incp  h a ld  58 cp#
          jrnz
  jpnext
  end-code

( water )

  \ Modify the screen bitmap with a water
  \ effect and then restore the original.

  \ Credits:
  \
  \ Code adapted from a routine written by Juan Jos Rivas,
  \ published on Microhobby, issue 150 (1987-06), page 9:
  \ http://microhobby.org/numero150.htm
  \ http://microhobby.speccy.cz/mhf/150/MH133_09.jpg

need z80-asm

code water  ( -- )

  bc push
  20 b ld#
  begin    57FF hl ldp#
            begin   m rrc  hl decp  h 6 bit  z until
            step

  bc pop  jpnext

  end-code

( scroll-1px-right )

  \ Credits:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code scroll-1px-right  ( -- )

  bc push

  4000 hl ldp#  \ screen bitmap address
  C0 c ld#  \ pixel rows
  begin
    m srl  hl incp  \ first char column
    1F b ld#  \ remaining columns
    begin   m rr  hl incp  step
    c dec
  z until

  bc pop jpnext

  end-code

( scroll-1px-up )

  \ Credits:
  \
  \ Code adapted from a routine written by Ivn Sansa,
  \ published on Microhobby, issue 122 (1987-03), page 7:
  \ http://microhobby.org/numero122.htm
  \ http://microhobby.speccy.cz/mhf/122/MH122_07.jpg

need z80-asm

create (scroll-1px-up)  ( -- a )

  \ Scroll the whole screen one pixel up.
  \ This is the Z80 routine that can be called from code words.

  asm

  4000 hl ldp#  BF b ld#

  begin
    bc push  hl de ldp  h inc  h a ld  F8 and#  h cp
    z if    8 b ld#  b sub  rra  rra  rra  a h ld  0020 bc ldp#
            bc addp  h a ld  rla  rla  rla  a h ld
    then    hl push  0020 bc ldp#  ldir  hl pop  bc pop
  step

  end-asm

code scroll-1px-up  ( -- )

  \ Scroll the whole screen one pixel up.

  bc push  \ Forth IP
  (scroll-1px-up) call
  bc pop  jpnext  end-code

( cls-chars0 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credits:
  \
  \ Code adapted from a routine written by Anselmo Moreno
  \ Lorente, published on Microhobby, issue 121 (1987-03), page
  \ 7:
  \
  \ http://microhobby.org/numero121.htm
  \ http://microhobby.speccy.cz/mhf/121/MH121_07.jpg

need z80-asm

code cls-chars0  ( -- )

  bc push

  6 b ld#
  begin   bc push  57FF hl ldp#
          begin   20 c ld#  a and
                  begin   nop  m sla
                          nop  m rlc
                          nop  m sla
                          nop  hl decp  c dec  z until
                  3F a ld#  h cp  z until
          bc pop  step

  bc pop  jpnext

  end-code

( cls-chars1 )

  \ Clear the screen by rotating all bytes of the bitmap.

  \ Credits:
  \
  \ Code adapted from a routine written by Antonio Adolfo Sanz,
  \ published on Microhobby, issue 197 (1990-03), page 24:
  \
  \ http://microhobby.org/numero197.htm
  \ http://microhobby.speccy.cz/mhf/197/MH197_24.jpg

need z80-asm

code cls-chars1  ( -- )

  bc push

  08 b ld#
  begin

    4000 hl ldp#  \ screen bitmap address
    begin
      m srl  hl incp
      m sla  hl incp
      58 a ld#  h cp
    z until

  step

  bc pop  jpnext  end-code

( horizontal-curtain )

  \ Credits:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code horizontal-curtain  ( b -- )

  \ Wash the screen with the given color attribute _b_ from the
  \ top and bottom rows to the middle.

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#
  0C b ld#
  begin   bc push  20 b ld#
          begin   a m ld  de stap
                  bc push  02 b ld#
                  begin bc push  FF b ld#  begin  step
                        bc pop  step
                  bc pop  de incp  hl decp  step
          bc pop  step

  bc pop  jpnext

  end-code

( vertical-curtain )

  \ Credits:
  \
  \ Code adapted from a routine written by Alejandro Mora,
  \ published on Microhobby, issue 128 (1987-05), page 7:
  \ http://microhobby.org/numero128.htm
  \ http://microhobby.speccy.cz/mhf/128/MH128_07.jpg

need z80-asm

code vertical-curtain  ( b -- )

  \ Wash the screen with the given color
  \ attribute _b_ from the left and right
  \ columns to the middle.

  \ b = color attribute

  de pop  bc push

  e a ld  5800 de ldp#  5AFF hl ldp#  10 b ld#
  begin   bc push  18 b ld#  de push  hl push
          begin   a m ld  de stap  bc push  02 b ld#
                  begin   bc push  FF b ld#  begin  step
                          bc pop  step
                  20 b ld#
                  begin  de incp  hl decp  step
                  bc pop  step

          hl pop  de pop  bc pop  de incp  hl decp  step

  bc pop  jpnext  end-code

( pixels )

  \ Credits:
  \
  \ Original code written by Juan Antonio Paz,
  \ published on Microhobby, issue 170 (1988-05), page 21:
  \ http://microhobby.org/numero170.htm
  \ http://microhobby.speccy.cz/mhf/170/MH170_21.jpg

need z80-asm

code pixels  ( -- u )

  \ Return the number of pixels set on the screen.

  exx
  4000 hl ldp#  l b ld  l c ld
  begin  \ byte
    08 d ld#
    begin  \ bit
      m rrc  cy if  bc incp  then  d dec
    z until
    hl incp  h a ld  58 cp#
  z until
  bc push
  exx
  jpnext
  end-code

  \ Original code:
  \
  \ ld hl,16384
  \ ld b,l
  \ ld c,l
  \   byte:
  \ ld d,8
  \   bit:
  \ rrc (hl)
  \ jr nc,next_bit
  \ inc bc
  \   next_bit:
  \ dec d
  \ jr nz,bit
  \ inc hl
  \ ld a,h
  \ cp 88
  \ jr nz,byte
  \ ret

( clear-block )

  \ Credits:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code clear-block  ( column row width height -- )

  \ doc{
  \
  \ clear-block  ( column row width height -- )
  \
  \ Clear a screen block at the given character coordinates and
  \ of the given size in characters.  Only the bitmap is
  \ cleared. The color attributes remain unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+6 = column
    \ ; ix+4 = row
    \ ; ix+2 = width
    \ ; ix+0 = height

  #4 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #6 ix orx
    \ ld a,(ix+4) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+6) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a
  #2 ix c ftx  #0 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+2) ; width
    \ ld a,(ix+0) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  0 hl ldp#  sp addp  #4 cells de ldp#  de addp  ldsp
    \ djnz delete_bitmap
    \ ; Drop the parameters:
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( color-block )

  \ Credits:
  \
  \ Code extracted and adapted from a routine written by Pablo
  \ Ariza, published on Microhobby Especial, issue 7 (1987-12),
  \ page 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code color-block  ( column row width height color -- )

  \ doc{
  \
  \ color-block  ( column row width height color -- )
  \
  \ Color a screen block at the given character coordinates and
  \ of the given size in characters.  Only the color attributes
  \ are changed; the bitmap remains unchanged.
  \
  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
  #2 ix b ftx  #4 ix c ftx
    \ ld b,(ix+2) ; height
    \ ld c,(ix+4) ; width
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#  jpnext  end-code
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
    \ jp next

( wipe-block )

  \ Credits:
  \
  \ Code adapted from a routine written by Pablo Ariza,
  \ published on Microhobby Especial, issue 7 (1987-12), page
  \ 50: <http://microhobby.org/mhes7.htm>.

need z80-asm

code wipe-block  ( column row width height color -- )

  \ doc{
  \
  \ wipe-block  ( column row width height color -- )
  \
  \ Wipe a screen block at the given character coordinates and
  \ of the given size in characters.  The bitmap is erased and
  \ the color attributes are changed with the given color.
  \
  \ This word is written in assembler and it combines the
  \ functions of `clear-block` and `color-block`. It may be
  \ defined also this way (with slower but much smaller code):

  \ ----
  \ : wipe-block  ( column row width height color -- )
  \   >r 2over 2over clear-block r> color-block  ;
  \ ----

  \ }doc

  exx  0 ix ldp#  sp addix
    \ exx ; save the Forth IP
    \ ld ix,0
    \ add ix,sp ; ix = address of TOS
    \
    \ ; ix+8 = column
    \ ; ix+6 = row
    \ ; ix+4 = width
    \ ; ix+2 = height
    \ ; ix+0 = color

  #6 ix a ftx  a d ld  rrca rrca rrca  #224 and#  #8 ix orx
    \ ld a,(ix+6) ; row
    \ ld d,a
    \ rrca
    \ rrca
    \ rrca
    \ and 224
    \ or (ix+8) ; column
  a e ld  d a ld  #24 and#  #64 or#  a d ld
    \ ld e,a
    \ ld a,d ; column
    \ and 24
    \ or 64
    \ ld d,a ; DE = top left address of the block
  #4 ix c ftx  #2 ix a ftx  a add  a add  a add  a b ld
    \ ld c,(ix+4) ; width
    \ ld a,(ix+2) ; height
    \ add a,a
    \ add a,a
    \ add a,a
    \ ld b,a ; width*8

  begin
    \ delete_bitmap:
    de push  de hl ldp  de incp  0 m ld#  bc push  c dec
      \ push de     ; save the address of the block scan
      \ ld l,e
      \ ld h,d      ; HL = origin, start of the scan
      \ inc de      ; DE = destination
      \ ld (hl),0   ; delete the first byte
      \ push bc     ; save the counts
      \ dec c       ; is width greater than 1?
    nz if  0 b ld#  ldir  then
      \ jr z,label1
      \   ld b,0    ; BC = width
      \   ldir      ; erase the rest of the scan
      \ label1:
    bc pop  de pop  d inc  d a ld  7 and#
      \ pop bc      ; restore counts
      \ pop de      ; restore address of scan
      \ inc d
      \ ld a,d
      \ and 7
    z if  #32 a ld#  e add  a e ld
      nc if  d a ld  8 sub#  a d ld  then
    then
      \ jr nz,inc_char
      \ ld a,32
      \ add a,e
      \ ld e,a
      \ jr c,inc_char
      \ ld a,d
      \ sub 8
      \ ld d,a
      \ inc_char:
  step  -->
    \ djnz delete_bitmap

( wipe-block )

  #6 ix a ftx  #22 d ld#  a add  a add  a add  a add
    \ ld a,(ix+6) ; row
    \ ld d,22
    \ add a
    \ add a
    \ add a
    \ add a ; row*8
  d rl  a add  d rl  #8 ix orx  a e ld  #2 ix b ftx
    \ rl d
    \ add a
    \ rl d
    \ or (ix+8) ; column
    \ ld e,a
    \ ld b,(ix+2) ; height
  begin
    \ delete_attributes:
    de push  de hl ldp  de incp  bc push  #0 b ld#
      \ push de
      \ ld h,d
      \ ld l,e
      \ inc de
      \ push bc
      \ ld b,0
    0 ix a ftx  a m ld  c dec
      \ ld a,(ix+0) ; color
      \ ld (hl),a
      \ dec c
    nz if  ldir  then
      \ jr z,no_more_attributes
      \ ldir
      \ no_more_attributes:
    bc pop  hl pop  #32 de ldp#  de addp  exde
      \ pop bc
      \ pop hl
      \ ld de,32
      \ add hl,de
      \ ex de,hl
  step
    \ djnz delete_attributes

  \ Drop the parameters:
  0 hl ldp#  sp addp  #5 cells de ldp#  de addp  ldsp
    \ ld hl,0
    \ add hl,sp
    \ ld de,5*cells
    \ add hl,de
    \ ld sp,hl

  exx  next ix ldp#
    \ exx         ; restore the Forth IP
    \ ld ix,next  ; restore IX
  jpnext  end-code

  \ }}} =======================================================
  \ Sound 128 {{{

( sound-register-port sound-write-port )  \ ==sound128==

65533 constant sound-register-port
49149 constant sound-write-port

( !sound vol shutup noise )

  \ Credits:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

need !p  need sound-register-port  need sound-write-port

: !sound  ( b1 b2 -- )
  \ b1 = sound datum
  \ b2 = sound register number (0..13)
  sound-register-port !p sound-write-port !p  ;

: vol  ( n1 n2 -- )  8 + !sound  ;
: shutup  ( -- )  -1 7 !sound  ;  \ XXX FIXME
: noise  ( -- )  7 7 !sound  ;

( music )

need ms  vocabulary music  current @  also music definitions
need roll

  \ Credits:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: freq
  2* 109.375 3 roll  um/mod nip 256 /mod 2 pick
  1+ !sound  swap !sound  ;

variable len  variable tempo  variable octave  variable volume
2 len !  200 tempo !  8 octave !  15 volume ! 1 15 vol

: tones  ( -- )  56 7 !sound  ;

: note  ( n "name" -- )
  create  ,
  does>   @ octave @ * 16 /  1 freq tones
          tempo @ len @ * ms shutup  ;

523 note c  554 note c# 583 note d  622 note d#
659 note e  698 note f  740 note f# 784 note g
831 note g# 880 note a  932 note a# 988 note b  -->

( music )

  \ Credits:
  \
  \ Code from Spectrum Forth-83.

  \ XXX TODO finish, document and test

: l   ( n -- )  len !  ;
: o+  ( -- )    octave @ 2 * octave !  ;
: o-  ( -- )    octave @ 2 / octave !  ;
: r   ( -- )    tempo @ len @ * ms  ;
: >>  ( -- )    1 volume @ 1+ vol 1 volume +!  ;
: <<  ( -- )    1 volume @ 1- vol -1 volume +!  ;

current ! previous

( play sound: sound, )

  \ Credits:
  \
  \ Code inspired by the article
  \ "Las posibilidades sonoras del 128 K",
  \ written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need !p  need sound-register-port  need sound-write-port

14 constant /sound

: play  ( a -- )
  \ a = address of a table with 14 bytes
  /sound 0 do
    i sound-register-port !p  dup c@ sound-write-port !p 1+
  loop  drop  ;

: sound,  ( b0 ... b13 -- )
  here /sound allot here 1- do  i c!  -1 +loop  ;

: sound:  ( b0 ... b13 "name" -- )  create  sound,  ;

( play sound: sound, )

  \ XXX TODO -- alternative:

need roll

: sound:  ( b0 ... b13 "name" -- )
  create  14 0 do  14 i - roll ,  loop  ;

: sound,  ( b0 ... b13 -- a )
  here >r 14 0 do  14 i - roll ,  loop  r>  ;

( play )

  \ Faster version of the previous `play`, using `c@+`,
  \ which requires the assembler.

need !p  need c@+
need sound-register-port  need sound-write-port

: play  ( a -- )
  \ a = address of a table with 14 bytes
  14 0 do
    i sound-register-port !p  c@+ sound-write-port !p
  loop  drop  ;

( play )

  \ Z80 version of the previous `play`.

need z80-asm

need sound-register-port  need sound-write-port

code play  ( a -- )

  \ a = address of a table with 14 bytes

  \ XXX FIXME

  hl pop  bc push

  0E b ld#  00 e ld#
    \ b = loop counter
    \ e = register number
  begin   bc push
          e a ld  sound-register-port bc ldp#  a outbc
            \ select the register
          m a ld  sound-write-port bc ldp#  a outbc
            \ store the datum
          hl incp  e inc  bc pop  \ next
  step

  bc pop  jpnext
  end-code

( waves shoot helicopter1 train )

  \ Sounds to be played with `play`.

need sound:

  \ Credits:
  \
  \ `waves` and `shoot` are
  \ adapted from code written by Juan Jos Ruiz,
  \ published on Microhobby, issue 139 (1987-07), page 7:
  \ http://microhobby.org/numero139.htm
  \ http://microhobby.speccy.cz/mhf/139/MH139_07.jpg

0  0  0  0  0  0  7 71  20  20  20  0  38  14
sound: waves

10  0  177  0  191  0  31 71  20  20  20  92  28  3
sound: shoot

  \ Credits:
  \
  \ `helicopter` and `train` are
  \ adapted from code written by Jos ngel Martn,
  \ published on Microhobby, issue 172 (1988-09), page 22:
  \ http://microhobby.org/numero172.htm
  \ http://microhobby.speccy.cz/mhf/172/MH172_22.jpg

200  15  200  15  200  15  0 7 23  23  23  255  1  12
sound: helicopter1

100  120  48  97  12  200  55 15  9  11  55  180  4  8
sound: train

( bomber whip metalic rain2 lightning1 lighting2 )

  \ Sounds to be played with `play`.

  \ Credits:
  \
  \ Adapted from data written by Francisco Majn,
  \ published on Microhobby, issue 194 (1989-12), page 26:
  \ http://microhobby.org/numero194.htm
  \ http://microhobby.speccy.cz/mhf/194/MH194_26.jpg

need sound:

73 82 62 165 90 138 159 140 102 77 100 162 87 201 sound: bomber

5 18 8 6 19 11 5 11 0 19 3 24 21 1 sound: whip

149 64 104 236 210 180 0 32 0 194 146 73 81 177 sound: metalic

16 17 25 10 19 9 4 31 245 1 6 30 2 sound: rain2

1 4 0 16 36 67 8 4 31 245 1 6 30 2 sound: lighting1

0 0 0 0 0 255 7 4 255 25 0 60 60 3 sound: lighting2

( Sound effects )

  \ Sounds to be played with `play`.

  \ Credits:
  \
  \ Data extracted a program written by Juan Jos Rosado Recio,
  \ published on Microhobby, issue 147 (1987-10), page 24:
  \ http://microhobby.org/numero147.htm
  \ http://microhobby.speccy.cz/mhf/147/MH147_24.jpg

need sound:  hex

00 00 00 00 00 00 1E 40 0F 10 0F 00 07 18 sound: aplausse
1B 00 09 00 00 00 1F C8 10 10 10 00 6B 10 sound: hammer
AB 03 2A 02 0C 01 00 F8 10 10 10 00 71 10 sound: bell1
66 00 4B 00 45 00 00 F8 10 10 10 00 22 10 sound: bell2
FC 06 DE 03 C3 04 00 F8 10 10 10 00 FF 10 sound: bell3
0C 1F 00 00 00 1F 07 E8 0F 10 0F 9A 00 18 sound: airplane
09 00 00 06 0C 00 0B C0 10 0E 10 3A 02 1C sound: helicopter2
03 05 FC 04 0C 05 00 F8 10 10 10 FF FF 0E sound: background
00 00 00 00 00 00 06 C0 10 10 10 00 05 18 sound: rap
00 06 00 00 00 05 11 E8 10 10 10 00 0A 10 sound: drum
09 00 00 00 00 00 00 C0 10 10 10 03 09 10 sound: cymbal
00 00 00 00 00 00 0F C0 0B 10 10 FF 50 0E sound: beach
24 00 12 00 16 00 00 F8 10 10 10 00 10 18 sound: waterdrop2

decimal

( rain1 waterdrop1 )

  \ Sounds to be played with `play`.

need sound:

  \ Credits:
  \
  \ Data extracted from a program written by Carlos Ventura,
  \ published on Microhobby, issue 198 (1990-05), page 16:
  \ http://microhobby.org/numero198.htm
  \ http://microhobby.speccy.cz/mhf/198/MH198_16.jpg

  \ XXX FIXME -- this effects don't sound fine, though the data
  \ are correct

44 24 6 6 7 3 3 5 44 6 3 5 3 3 sound: rain1

20 83 94 39 0 8 31 71 23 23 22 90 0 0 sound: waterdrop1

  \ }}} =======================================================
  \ Sound 48 {{{

( bleep )  \ ==sound48==

  \ Credits:
  \
  \ Code modified from Abersoft Forth.

code bleep  ( duration pitch -- )
  E1 c, D1 c, C5 c,   \ pop hl / pop de / push bc
  CD c, 03B5 ,        \ call rom_beeper
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next ; restore ix
  jpnext              \ jp (ix)
  end-code
  \ Produce a tone in the noise maker.

( beep>bleep )

  \ Credits:
  \
  \ Code from v.Forth.

  \ XXX TODO test

: beep>bleep  ( frequency duration1 -- duration2 pitch )
  over 1000 */ swap
  4375 100 rot */ 30 -  ;
  \ Convert the parameters of the original ZX Spectrum's `beep`
  \ command _frequency duration_ to those required by Solo
  \ Forth's `bleep`.

( laser-gun )

  \ Laser gun sound for ZX Spectrum 48K.

  \ Credits:
  \
  \ Author of the original code: lvaro Corredor Lanas.
  \ Published on Microhobby, issue 126 (1987), page 7:
  \ http://microhobby.org/numero126.htm
  \ http://microhobby.speccy.cz/mhf/126/MH126_07.jpg

need z80-asm

code laser-gun  ( -- )
  bc push
  5 b ld#
  0500 hl ldp#
  begin   0001 de ldp#
          hl push  03B5 call  hl pop  \ ROM beeper
          0010 de ldp#  de subp
          jrnz
  bc pop  next ix ldp#  jpnext
  end-code

( white-noise )

  \ White noise for ZX Spectrum 48K.

  \ Credits:
  \
  \ Author of the original code: Ricardo Serral Wigge.
  \ Published on Microhobby, issue 125 (1987), page 26:
  \ http://microhobby.org/numero125.htm
  \ http://microhobby.speccy.cz/mhf/125/MH125_26.jpg

  \ The original code was called "explosion" and had a fixed
  \ duration of 768 sample bytes, thus equivalent to `768
  \ white-noise`.

need z80-asm

code white-noise  ( u -- )

  \ u = duration in number of sample bytes

  de pop
  bc push  \ save the Forth IP
  de bc ldp  0000 hl ldp#  \ bc=duration, hl=start of ROM

  5C48 fta  a sra  a sra  a sra  07 and#  a d ld
    \ d = border color (in bits 0-2)

  begin   m e ld  hl incp  bc decp  bc push
          08 b ld#  \ bit counter
          begin   e a ld  10 and#  e rl  d or  FE out  \ beep
                  step
          bc pop  bc tstp
          jrnz

  bc pop  jpnext \ restore the Forth IP and go next

  end-code

( ambulance )

  \ Ambulance sound for ZX Spectrum 48K.

  \ Credits:
  \
  \ Author of the original code: Lder Software.
  \ Published on Microhobby, issue 142 (1987-09), page 7:
  \ http://microhobby.org/numero142.htm
  \ http://microhobby.speccy.cz/mhf/142/MH142_07.jpg

need z80-asm

code ambulance  ( n -- )

  \ n = times

  de pop  bc push  e b ld

  begin   bc push  0320 hl ldp#  000A de ldp#
          <mark   hl push
                  03B5 call  \ ROM beeper
                  hl pop  hl decp
                  hl tstp
                  jrnz
          bc pop
          step

  bc pop  next ix ldp#  jpnext

  end-code

  \ }}} =======================================================
  \ Memory access {{{

( exchange )  \  ==memoryaccess==

[unneeded] exchange
?\ : exchange  ( n1 a -- n2 )  dup @ rot rot !  ;


( c+! c@+ )

need z80-asm

[unneeded] c+! dup
?\  code c+!  ( b ca -- )
?\    hl pop  de pop  e a ld  m a add  a m ld  jpnext  end-code

  \ doc{
  \
  \ code c+!  ( b ca - )
  \
  \ Add _b_ to the 8-bit number at _ca_
  \
  \ }doc

[unneeded] c@+ dup
?\ code c@+  ( ca - ca+1 c )

  \ Credits:
  \
  \ Code adapted from Pygmy Forth.

  \ First version
  \ de pop  de ftap  de incp  0 h ld# a l ld  pushhlde jp

  \ Second version
?\  hl pop  m a ld  hl incp  hl push  pusha jp  end-code

  \ doc{
  \
  \ code c@+  ( ca - ca+1 c )
  \
  \ Fetch the byte at _ca_ a and increments the address.
  \ This is handy for stepping through byte arrays.
  \
  \ }doc

( 1+! 1-! )

need z80-asm  need [if]

[needed] 1+! [if]
code 1+!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de incp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1+!  ( a - )
  \
  \ Increment the cell number at _a_.
  \
  \ }doc

[needed] 1-! [if]
code 1-!  ( a -- )
  hl pop  m e ld  hl incp  m d ld  de decp
  d m ld  hl decp  e m ld  jpnext
end-code
[then]

  \ doc{
  \
  \ 1-!  ( a - )
  \
  \ Decrement the cell number at _a_.
  \
  \ }doc

( c1+! c1-! )

need z80-asm

[unneeded] c1+!
?\  code c1+!  ( ca -- )  hl pop  m inc  jpnext  end-code

  \ doc{
  \
  \ c1+!  ( ca - )
  \
  \ Increment the 8-bit number at _ca_.
  \
  \ }doc

[unneeded] c1-!
?\  code c1-!  ( ca -- )  hl pop  m dec  jpnext  end-code

  \ doc{
  \
  \ c1-!  ( ca - )
  \
  \ Decrement the 8-bit number at _ca_.
  \
  \ }doc

( c@+ c!+ -c@ -c! )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credits:
  \
  \ Words from the TED editor.
  \ http://dxforth.netbay.com.au/ted.html

  \ Note: these words are too specific for the TED editor.

need 1+!  need 1-!

: c@+  ( ca -- c )  dup @ c@ swap 1+!  ;
: c!+  ( c ca -- )  tuck @ c! 1+!  ;
: -c@  ( ca -- c )  dup 1-! @ c@  ;
: -c!  ( c ca -- )  dup 1-! @ c!  ;

( @+ @- !+ !- c@+ c@- c!+ c!- )

  \ XXX UNDER DEVELOPMENT -- 2015-10-25

  \ Credits:
  \
  \ Words written after cmForth.

  \ XXX Note: the original descriptions didn't include stack
  \ notations. Some of them are not clear.

  \ @+  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is incremented by n.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ XXX TODO alternative found -- which one is cmForth?
  : @+ ( a inc -- value a+inc )  + dup @ swap  ;

  \ @-  ( n a -- x n a' )
  \
  \ Fetch data from memory pointed to by the top item on the
  \ stack.  Data obtained is pushed below the top item.  The
  \ top address is decremented by n.  Repeating this
  \ instruction pushes an array of data on the data stack below
  \ the address on top.

  \ !+  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then incremented by n.

  \ XXX TODO alternative found -- which one is cmForth?
  : !+  ( value a inc -- a+inc )  + tuck !  ;

  \ !-  ( n x a -- a' )
  \
  \ Pop the second item on the data stack and store it in the
  \ memory pointed to by the address on top of the stack.  The
  \ address is then decremented by n.

  \ c@+  ( ca n -- b ca' )
  \
  \ Fetch a byte from memory and increment the address by n.

  \ c@-  ( ca n -- b ca' )
  \
  \ Fetch a byte from memory and decrement the address by n.

  \ c!+  ( b ca n -- ca' )
  \
  \ Store a byte to memory and increment the address by n.

  \ c!-  ( b ca n -- ca' )
  \
  \ Store a byte to memory and decrement the address by n.

( bit? set-bit reset-bit )

need lshift

: bit>mask  ( n -- b )  1 swap lshift  ;
  \ Convert bit number _n_ to a bitmask _b_ with bit _n_ set.

: bit? ( b n -- f )  bit>mask and 0<> ;
  \ Is bit _n_ of _b_ set?

: set-bit ( b1 n -- b2 )  bit>mask or ;
  \ Set bit _n_ of _b1_, returning the result _b2_.

: reset-bit ( b1 n -- b2 )  bit>mask invert and ;
  \ Reset bit _n_ of _b1_, returning the result _b2_.

( c@test-bits c!toggle-bits )

  \ XXX TODO possible names:
  \ c@test-bits     cand@    c@and   c@mask?    c@test?  c@set?
  \ c!set-bits      cor!     c!or    c!mask     c!set
  \ c!reset-bits                     c!unmask   c!reset
  \ c!toggle-bits   cxor!    c!xor   c!toggle   c!toggle

  \ Credits:
  \
  \ Words inspired by MPE PowerForth for TiniARM.

need z80-asm  need [if]

  \ XXX OLD -- `c@test-bits?` is in the kernel
  \ [needed] c@test-bits? [if]
  \ code c@test-bits?  ( b ca -- wf )
  \   hl pop  de pop  e a ld  m and
  \   ' true >code jpnz  ' false >code jp  end-code  exit  [then]
  \   \ Test the bits at _ca_ specified by the bitmask _b_.  Return
  \   \ _true_ if the result is non-zero or _false_ if the result
  \   \ is zero.

  \ XXX FIXME

  \ XXX INFORMER
  \ cr needed-word 2@ .s char < emit type char > emit cr

[needed] c@test-bits [if]
code c@test-bits  ( b1 ca -- b2 )
  hl pop  de pop  e a ld  m and  pusha jp
  end-code  exit  [then]
  \ Test the bits at _ca_ specified by the bitmask _b1_.
  \ Return the result _b2_. The bits sets in _b2_ are those
  \ set in both _b1_ and the contents of _ca_.

  \ XXX OLD -- `c!set-bits` is in the kernel
  \ [needed] c!set-bits [if]
  \ code c!set-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  m or  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Set the bits at _ca_ specified by the bitmask _b_.

  \ XXX OLD -- `c!reset-bits` is in the kernel
  \ [needed] c!reset-bits [if]
  \ code c!reset-bits  ( b ca -- )
  \   hl pop  de pop  e a ld  cpl  m and  a m ld  jpnext
  \   end-code  exit  [then]
  \   \ Reset the bits at _ca_ specified by the bitmask _b_.

[needed] c!toggle-bits [if]
code c!toggle-bits  ( b ca -- )
  hl pop  de pop  m a ld  e xor  a m ld  jpnext
  end-code  exit  [then]
  \ Invert the bits at _ca_ specified by the bitmask _b_.

( reserve alloted )

: reserve  ( n -- a )  here tuck over erase allot  ;
  \ Reserve a zone of _n_ bytes in the dictionary, erase it
  \ and return its address _a_.

: allotted  ( n -- a )  here swap allot ;
  \ Reserve a zone of _n_ bytes in the dictionary
  \ and return its address _a_.

  \ }}} =======================================================
  \ Single-cell operators {{{

( under+ )  \ ==operators==

code under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  D9 c,           \ exx
  D1 c,           \ pop de
  C1 c,           \ pop bc
  E1 c,           \ pop hl
  19 c,           \ add hl,de
  E5 c,           \ push hl
  C5 c,           \ push bc
  D9 c,           \ exx
  jpnext  end-code

  \ doc{
  \
  \ under+  ( n1|u1 x n2|u2 -- n3|u3 x )
  \
  \ Add _n2|u2_ to _n1|u2_, giving the sum _n3|u3_.
  \
  \ Origin: Comus.
  \
  \ ----
  \ : under+  ( n1|u1 x n2|u2 -- n3|u3 x )  rot + swap  ;
  \ ----
  \
  \ }doc

  \ XXX TODO -- variants:

  \ : +under  ( n1 n2 x -- n1+n2 x )  >r + r>  ;
  \
  \ : +under  ( n1 n2 -- n1+n2 n2 )  tuck + swap  ;
  \ After PFE's `(under+)`

( within between )

  \ Credits:
  \
  \ Code from DZX-Forth.

[unneeded] within
?\ : within  ( n1|u1 n2|u2 n3|u3 -- f )  over - >r - r> u<  ;

  \ doc{
  \
  \ within  ( n1|u1 n2|u2 n3|u3 -- f )
  \
  \ Perform a comparison of a test value n1|u1 with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.
  \
  \ Origin: Forth-94 (CORE EXT), Forth-2012 (CORE EXT).
  \
  \ }doc

[unneeded] between ?exit
need -rot
: between  ( n1|u1 n2|u2 n3|u3 -- f )  over - -rot - u< 0=  ;

  \ doc{
  \
  \ between  ( n1|u1 n2|u2 n3|u3 -- f )

  \ Perform a comparison of a test value _n1|u1_ with a lower
  \ limit _n2|u2_ and an upper limit _n3|u3_, returning _true_
  \ if either (n2|u2 <= n3|u3 and (n2|u2 <= n1|u1 and n1|u1 <=
  \ n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 < n1|u1 or n1|u1 <
  \ n3|u3)) is true, returning _false_ otherwise. An ambiguous
  \ condition exists if _n1|u1_, _n2|u2_, and _n3|u3_ are not
  \ all the same type.

  \ name  ( -- )
  \
  \ }doc

  \ Credits:
  \
  \ http://dxforth.netbay.com.au/between.html

( polarity )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

code polarity  ( n -- -1 | 0 | 1 )
  D1 c, 78 02 + c,  B0 03 + c,  CA c, ' false >code ,
    \ pop de
    \ ld a,d
    \ or e
    \ jp z,false_code

  CB c, 10 03 + c,  ED c, 62 c,
    \ rl d ; set carry if DE -ve
    \ sbc hl,hl ; HL=0 if DE +ve, or -1 if DE -ve

  78 05 + c,  F6 c, 01 c,  68 07 + c,  C3 c, pushhl ,
    \ ld a,l
    \ or 1
    \ ld l,a ; HL=1 or -1
    \ jp push_hl
  end-code

( u<= u>= <= >= 0>= 0<= )

[unneeded] u<=  ?\ : u<=  ( u1 u2 -- f )  u> 0=  ;  exit
[unneeded] u>=  ?\ : u>=  ( u1 u2 -- f )  u< 0=  ;  exit
[unneeded] <=   ?\ : <=   ( n1 n2 -- f )  > 0=   ;  exit
[unneeded] >=   ?\ : >=   ( n1 n2 -- f )  < 0=   ;  exit
[unneeded] 0>=  ?\ : 0>=  ( n1 n2 -- f )  0< 0=  ;  exit
[unneeded] 0<=  ?\ : 0<=  ( n1 n2 -- f )  0> 0=  ;

( lshift )

need z80-asm

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

  \ 16 bytes used

code lshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!
  b inc  ahead 0 unresolved !
  begin  hl addp  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( lshift )

  \ Credits:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (13 bytes used) but slower (169%
  \ the execution time of version adapted from Z88 CamelForth).

code lshift  ( x1 u -- x2 )

  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  29 c,           \ add hl,hl
  C3 c, ,         \ jp begin

  end-code

( rshift )

need z80-asm

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

  \ 19 bytes used

code rshift  ( x1 u -- x2 )

  exx
  bc pop  \ C = loop counter
  c b ld
  hl pop  \ hi 8 bits ignored!

  b inc  ahead 0 unresolved !

  begin  h srl  l rr  0 unresolved @ >relresolve  step
  hl push
  exx
  jpnext

  end-code

( rshift )

  \ Credits:
  \
  \ Code adapted from DZX-Forth.

  \ This version is smaller (16 bytes used) but slower (133%
  \ the execution time of the version adapted from Z88 CamelForth).

code rshift  ( x1 u -- x2 )
  D1 c,           \ pop de
  E1 c,           \ pop hl
  1C c,           \ inc e
  here            \ begin:
  1D c,           \ dec e
  CA c, pushhl ,  \ jp z,push_hl
  CB c, 3C c,     \ srl h
  CB c, 1D c,     \ rr l
  C3 c, ,         \ jp begin
  end-code

( 2/ )

  \ Credits:
  \
  \ Code from Spectrum Forth-83.
  \ Documentation partly based on lina.

code 2/  ( x1 -- x2 )
  E1 c,           \ pop hl
  CB c, 2C c,     \ sra h
  CB c, 1D c,     \ rr l
  C3 c, pushhl ,  \ jp pushhl
  end-code

  \ doc{
  \
  \ 2/  ( x1 -- x2 )
  \
  \ _x2_ is the result of shifting _x1_ one bit toward the
  \ least-significant bit, leaving the most-significant bit
  \ unchanged.
  \
  \ This is the same as `s>d 2 fm/mod swap drop`. It is not the
  \ same as `2 /`, nor is it the same as `1 rshift`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (CORE),
  \ Forth-2012 (CORE).
  \
  \ }doc

( sqrt )

  \ Credits:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ (volume 18, number 5, page 27, 1997-01).

need d2*  need 2/

[defined] cell-bits ?\ 16 constant cell-bits

: (sqrt)  ( radicand -- remainder root )
  0 0                           ( radicand remainder root )
  [ cell-bits 2/ ] literal 0 do
    >r d2* d2* r>               \ shift remainder left 2 bits
    2*                          \ shift root left 1 bit
    2dup 2* u> if               \ check for next bit of root
      >r r@ 2* - 1- r>          \ reduce remainder
      1+                        \ add a bit to root
    then
  loop  cr .s rot drop  ;

: sqrt  ( radicand -- root )  (sqrt) nip  ;

( sqrt )

  \ Integer square root by Newton's method

  \ Credits:
  \
  \ Adapted from Sinclair QL's Computer One Forth.

: sqrt  ( n1 -- n2 )
  dup 0< -24 ?throw  \ invalid numeric argument
  dup
  if  dup 2/  20 0
      do      2dup / + 2/
      loop    swap drop
  then  ;

( sm/rem )

  \ Credits:
  \
  \ Code from Z88 CamelForth.

: sm/rem  ( d1 n1 -- n2 n3 )
  \ symmetric signed division
  2dup xor >r  \  sign of quotient
  over >r      \  sign of remainder
  abs >r dabs r> um/mod
  swap r> ?negate
  swap r> ?negate  ;

  \ doc{
  \
  \ sm/rem  ( d1 n1 -- n2 n3 )

  \ Divide d1 by n1, giving the symmetric quotient n3 and the
  \ remainder n2. Input and output stack arguments are signed.
  \ An ambiguous condition exists if n1 is zero or if the
  \ quotient lies outside the range of a single-cell signed
  \ integer.

  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Symmetric Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|       -3  >|       -1
  \ >|       10  >|     -7  >|        3  >|       -1
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===

  \ }doc

( /-rem /- -rem */-rem */- )

  \ Symmetric-division operators

  \ Credits:
  \
  \ Forth-94 documentation.

: /-rem  ( n1 n2 -- n3 n4 )  >r  s>d  r> sm/rem  ;

: /-  (  n1 n2 -- n3 )  /-rem nip  ;

: -rem  ( n1 n2 -- n3 )  /-rem drop  ;

: */-rem  (  n1 n2 n3 -- n4 n5 )  >r  m*  r> sm/rem  ;

: */-  ( n1 n2 n3 -- n4 )  */-rem nip  ;

( fm/mod )

  \ Credits:
  \
  \ Code from Z88 CamelForth.

: fm/mod  ( d1 n1 -- n2 n3 )
  \ floored signed division
  dup >r                \ save divisor
  sm/rem
  over 0<> over 0< and  \ quotient<0 and remainder<>0?
  if
    swap r> +           \ add divisor to remainder
    swap 1-             \ decrement quotient
  else r> drop then  ;

  \ doc{
  \
  \ fm/mod  ( d1 n1 -- n2 n3 )
  \
  \ Floored division:
  \
  \ ----
  \   d1 = n3*n1+n2
  \   n1>n2>=0 or 0>=n2>n1
  \ ----
  \
  \ Divide _d1_ by _n1_, giving the floored quotient _n3_ and
  \ the remainder _n2_. Input and output stack arguments are
  \ signed.
  \
  \ Origin: Forth-94 (CORE), Forth-2012 (CORE).

  \ [caption="Floored Division Example"]
  \
  \ |===
  \ | Dividend  | Divisor | Remainder | Quotient

  \ >|       10  >|      7  >|        3  >|        1
  \ >|      -10  >|      7  >|        4  >|       -2
  \ >|       10  >|     -7  >|       -4  >|       -2
  \ >|      -10  >|     -7  >|       -3  >|        1
  \ |===
  \
  \ }doc

( /_mod /_ _mod */_mod */_ )

  \ Floored-division operators

need fm/mod

  \ Credits:
  \
  \ Forth-94 documentation.

: /_mod  ( n1 n2 -- n3 n4 )  >r s>d r> fm/mod  ;

: /_  ( n1 n2 -- n3 )  /_mod nip  ;

: _mod  ( n1 n2 -- n3 )  /_mod drop  ;

: */_mod  ( n1 n2 n3 -- n4 n5 )  >r m* r> fm/mod  ;

: */_  ( n1 n2 n3 -- n4 )   */_mod nip  ;

( any? )

  \ Credits:
  \
  \ Code from F83.

need roll

variable (any?)

: any?  ( x0 x1..xn n -- f )
  dup 1+ roll (any?) !
  0 swap 0 do  swap (any?) @ = or  loop  ;
  \ Is any _x1..xn_ equal to _x0_?

( % u% )

: %  ( n1 n2 -- n3 )  100 swap */  ;
  \ _n1_ is percentage _n3_ of _n2_

: u%  ( u1 u2 -- u3 )  >r 100 um* r> um/mod nip  ;
  \ _u1_ is percentage _u3_ of _u2_

  \ }}} =======================================================
  \ Double-cell operators {{{

( ud* )

  \ Credits:
  \
  \ Code from Z88 CamelForth.

: ud*  ( ud1 u2 -- ud3 )  dup >r um* drop  swap r> um* rot +  ;

( d* )

  \
  \ Credits:
  \
  \ Code from DX-Forth 4.13.

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0000

: d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;

  \ --------------------------------------------
  \ Alternative implementation.
  \
  \ Credits:
  \
  \ Adapted from code written by Robert L. Smith,
  \ published on Forth Dimensions (volume 4, number 1, page 3,
  \ 1982-05).
  \
  \ This implementation uses 36 bytes.
  \ Relative speed: 1.0582
  \
  \ : d*  ( d1 d2 -- d3 )
  \  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ --------------------------------------------
  \ Alternative implementation.

  \ Credits:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 33, 1998-04).

  \ This implementation uses 30 bytes.
  \ Relative speed: 1.0008

  \ : d*  ( d1 d2 -- d3 )
  \   >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  \   2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  \   r> * swap r> * + +  ; ( d1*d2 ) ( R: )

( du/mod )

  \ Credits:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

need tum*  need t+  need t-  need tum/  need d2*  need lshift

: normalize-divisor  ( d1 -- d1' shift )
  0 >r begin  dup 0< while  d2*  r> 1+ >r  repeat  r>  ;

  \ XXX TODO rename as `ud/mod`?
  \ XXX TODO stack comments

: du/mod  ( ud1 ud2 -- ud3 ud4 )

  ?dup 0= if
    \ there is a leading zero "digit" in divisor
    >r  0 r@ um/mod  r> swap >r  um/mod  0 swap r>  exit
  then

  normalize-divisor dup >r rot rot 2>r
  1 swap lshift tum*
    \ normalize divisor and dividend

  dup  r@ = if   -1  else  2dup  r@ um/mod nip  then
    \ guess leading "digit" of quotient

  2r@  rot dup >r  tum*  t-
    \ multiply divisor by trial quot and substract from
    \ dividend

  dup 0< if  r> 1-  2r@  rot >r  0 t+
    \ if negative, decrement quot and add to dividend

    dup 0< if  r> 1-  2r@  rot >r  0 t+  then
    \ if still negative, do it one more time

  then

  r> 2r> 2drop  1 r>  rot >r  lshift tum/  r> 0  ;
    \ undo nurmalization of dividend to get remainder

  \ Double unsigned divide with remainder.  Given a dividend
  \ _ud1_ and a divisor _ud2_, return remainder _ud3_ and
  \ quotient _ud4_.

( d0= d0< d< du< )

  \ Credits:
  \
  \ Code from DZX-Forth.

[unneeded] d0= ?\ : d0=  ( d -- f )  or 0=  ;  exit

[unneeded] d0< ?\ : d0<  ( d -- f )  nip 0<  ; exit

need [if]

[needed] d< [if]

need 2nip

: d<  ( d1 d2 -- f )
  rot 2dup = if  2drop u< exit  then  2nip >  ;  exit

[then]

[needed] du< [if]

  \ XXX TODO rewrite in Z80

: du<  ( ud1 ud2 -- f )
  rot swap 2dup
  u<  if  2drop 2drop -1 exit  then
  -   if  2drop 0 exit  then  u<  ;  exit

[then]

( dmin dmax )

  \ Credits:
  \
  \ Code from DZX-Forth.

need [if]

[needed] dmin [if]
: dmin  ( d1 d2 -- d1 | d2 )
  2over 2over d< 0= if  2swap  then  2drop  ;  exit  [then]

[needed] dmax [if]
: dmax  ( d1 d2 -- d1 | d2 )
  2over 2over d< if  2swap  then  2drop  ;  [then]

( d= d<> )

  \ XXX TODO -- rewrite in Z80

: d<>  ( d1 d2 -- f )  rot <> if  2drop true exit  then  <>  ;

: d=  ( d1 d2 -- f )  d<> 0=  ;

  \ XXX OLD
  \ XXX TODO benchmark
  \ : d=  ( d1 d2 -- f ) rot = >r = r> and  ;
  \ : d<>  ( d1 d2 -- f )  d= 0=  ;

( d- )

need z80-asm

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

code d-  ( d1|ud1 d2|ud2 -- d3|ud3 )

  de pop          \ DE=d2hi
  exx
  de pop          \ DE'=d2lo
  exx
  hl pop          \ HL=d1hi,DE=d2hi
  exx
  hl pop          \ HL'=d1lo
  de subp
  hl push         \ 2OS=d1lo-d2lo
  exx
  de sbcp         \ HL=d1hi-d2hi-cy
  pushhl jp
  end-code

( d2* d2/ )

  \ Credits:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  D1 c, E1 c,
    \ pop de / pop hl
  29 c,  CB c, 13 c,  CB c, 12 c,
    \ add hl,hl
    \ rl e
    \ rl d
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  E1 c, D1 c,
    \ pop hl / pop de
  CB c, 2C c,  CB c, 1C c,  CB c, 1D c,
    \ sra h  /  rr h /  rr l
  CB c, 1A c,  CB c, 1B c,
    \ rr d /  rr e
  EB c, C3 c, pushhlde ,
    \ ex de,hl jp pushhlde

  end-code  [then]

( d2* d2/ )

  \ Credits:
  \
  \ Code converted to Z80 from the 8080 version
  \ of DZX-Forth.

need [if]  need z80-asm

[needed] d2* [if]  code d2*  ( xd1 -- xd2 )

  de pop  hl pop
  hl addp  e rl  d rl
                              \ alternatives:
  exde  pushhlde jp           \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

[needed] d2/ [if]  code d2/  ( xd1 -- xd2 )

  hl pop  de pop
  h sra  l rr  d rr  e rr

                              \ alternatives:
  pushhlde jp                 \ smaller but slower
  \ hl push  de push  jpnext  \ faster but bigger

  end-code  [then]

( dxor dor dand )

  \ Credits:
  \
  \ Code written by Everett F. Carter, published on Forth
  \ Dimensions (volume 16, number 2, page 17, 1994-08).

need -rot

[unneeded] dxor
?\ : dxor  ( d1 d2 -- d3 )  rot xor -rot xor swap  ;

[unneeded] dor
?\ : dor  ( d1 d2 -- d3 )  rot or -rot or swap  ;

[unneeded] dand
?\ : dand  ( d1 d2 -- d3 )  rot and -rot and swap  ;

( m* )

  \ Credits:
  \
  \ Code by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

  \ XXX TODO benchmark with the version in the kernel

need d*

: m*  ( n1 n2 -- d )
  >r s>d r> s>d d* ;

( m+ )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need z80-asm

code m+  ( d1 n -- d2 )
  exx     \ save Forth IP
  bc pop  \ n
  de pop  \ d1 hi cell
  hl pop  \ d1 lo cell
  bc addp  hl push
  cy if  de inc  then  de push
  exx      \ restore Forth IP
  jpnext
  end-code

  \ doc{
  \
  \ m+  ( d1|ud1 n -- d2|ud2 )
  \
  \ Add _n_ to _d1|ud1_, giving the sum _d2|ud2_.
  \
  \ Origin: Forth-94 (DOUBLE) Forth-2012 (DOUBLE).
  \
  \ }doc

( m*/ )

  \ Credits:
  \
  \ Code from Gforth 0.7.3.

need -rot

: m*/  ( d1 n1 +n2 -- d2 )

  >r s>d >r abs -rot s>d r> xor r> swap >r >r dabs
  rot tuck um* 2swap um* swap
  >r 0 d+ r> -rot i um/mod -rot r> um/mod -rot r>
  if     if     1 0 d+
         then
         dnegate
  else   drop
  then  ;

  \ XXX TODO document, see difference Gforth - Forth-94

( dsqrt )

  \ Credits:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need q2*  need d2*  need d<  need m+  need d- need 2rot
need 2nip  [defined] cell-bits ?\ 16 constant cell-bits

  \ XXX FIXME wrong results
  \
  \ It worked fine, but something got wrong
  \ Perhaps because of some wrong dependency?
  \ maybe `d<`?
  \
  \ It works in Gforth

: (dsqrt)  ( radicand . -- remainder . root . )
  0. 0.             ( radicand . remainder . root . )
  cell-bits 0 do    ( radicand . remainder . root . )
    cr .s  key drop  \ XXX INFORMER
    2>r q2* q2* 2r>  d2*
    2over 2over d2* 2swap
      cr .s ." d< ?"  \ XXX INFORMER
      d< if
      cr .s ." d<"  \ XXX INFORMER
      2dup 2>r d2* d- -1 m+ 2r>  1 m+
    then
  loop  cr .s 2rot 2drop  ;

: dsqrt  ( radicand . -- root . )  (dsqrt) 2nip  ;

  \ }}} =======================================================
  \ Triple-cell operators {{{

( tum* tum/ t+ t- )

  \ Credits:
  \
  \ Code by Wil Baden, published on Forth Dimensions (volume
  \ 19, number 6, page 34, 1998-04).

  \ XXX TODO -- test

need d-

: +carry  ( n1 n2 -- n1+n2 carry )  0 tuck d+  ;

: -borrow  ( n1 n2 -- n1-n2 borrow )  0 tuck d-  ;

: tum*  ( d n -- t )  2>r  r@ um*  0 2r>  um* d+  ;
  \ Triple unsigned mixed multiply.

: tum/  ( t n -- d )  dup >r um/mod r> swap >r um/mod nip r>  ;
  \ Triple unsigned mixed division.

: t+  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r +carry  0 r> r> +carry d+ r> r> + +  ;
  \ Triple add.

: t-  ( t1 t2 -- t3 )
  >r rot >r  >r swap >r -borrow
  s>d r> r> -borrow d+ r> r> - +  ;
  \ Triple substract.

  \ }}} =======================================================
  \ Quadruple-cell operators {{{

( q2* )

  \ Credits:
  \
  \ Original code by Wil Baden, published on Forth Dimensions
  \ 18/5 p. 29 (1997-01).

need d2*

: q2*  ( n . . . -- 2n . . . )
  d2* >r >r
  dup 0< if     d2* r> 1+ r>
         else   d2* r> r>
         then  ;


  \ }}} =======================================================
  \ Compilation {{{

( [if] [else] [then] )  \ ==compilation==

need s=

: [else]  ( "..." -- )

  \ 1 begin   parse-name 2dup swap c@ and \ XXX OLD
  1 begin   parse-name dup
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  ?dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if postpone [else] then  ; immediate

: [then]  ( -- )  ; immediate

( body>name name>body link>name name>link >>link name<name )

[unneeded] body>name
?\ : body>name  ( pfa -- nt ) body> >name  ;

[unneeded] name>body
?\ : name>body  ( nt -- pfa ) name> >body  ;

[unneeded] link>name dup  ?\ need alias
?\ ' cell+ alias link>name  ( nt -- pfa )

[unneeded] name>link dup  ?\ need alias
?\ ' cell- alias name>link  ( nt -- pfa )

[unneeded] >>link dup  ?\ need alias
?\ ' cell+ alias >>link  ( xtp -- lfa )

[unneeded] name<name dup  ?\ need name>link
?\ : name<name  ( nt1 -- nt2 )  name>link @n  ;
  \ Get the previous _nt2_ from _nt1_.

( name>interpret name>compile )

  \ XXX UNDER DEVELOPMENT

: name>interpret  ( nt -- xt | 0 )
  ;

  \ doc{
  \
  \ name>interpret  ( nt -- xt | 0 )
  \
  \ Return a _xt_ that represents the interpretation semantics
  \ of the word _nt_. If _nt_ has no interpretation
  \ semantics, return zero.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

: name>compile  ( nt -- x xt )
  ;

  \ doc{
  \
  \ name>compile  ( nt -- x xt )
  \
  \ Return _x xt_ that represents the compilation semantics
  \ of the word _nt_. The  returned _xt_ has the stack
  \ effect ( i*x  x -- j*x  ).  Executing _xt_ consumes
  \ _x_ and performs the compilation semantics of the word
  \ represented by _nt_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

( smudge smudged )

need c!toggle-bits

: smudged  ( nt -- )
  smudge-mask swap names-bank c!toggle-bits default-bank  ;

  \ doc{
  \
  \ smudged  ( nt -- )
  \
  \ Toggle the "smudge bit" of the given _nt_.
  \
  \ This word is obsolete. `hided` and `revealed` are used
  \ instead.
  \
  \ }doc

 : smudge  ( -- )  latest smudged  ;

  \ doc{
  \
  \ smudge  ( -- )
  \
  \ Toggle the "smudge bit" of the latest definition's name
  \ field.  This prevents an uncompleted definition from being
  \ found during dictionary searches, until compiling is
  \ completed without error.
  \
  \ This word is obsolete. `hide` and `reveal` are used
  \ instead.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

( ?pairs )

: ?pairs  ( x1 x2 -- )  <> #-22 ?throw  ;
  \ If _x1_ not equals _x2_ throw an error -22 (control
  \ structure mismatch).

( privatize )

  \ Usage example:
  \
  \ ----
  \ private{
  \
  \ : hello  ( -- )  ." hello"  ;
  \
  \ }private
  \
  \ : salute  ( -- )  hello  ;
  \
  \ privatize
  \
  \ salute  \ ok!
  \ hello   \ error!
  \ ----

  \ Credits:
  \
  \ The idea for this code was taken from an article by Deway
  \ Val Schorre, _Structured programming by adding modules to
  \ FORTH_, published on Forth Dimensions 2/5 page 132
  \ (1981-01). The following original code is for fig-Forth.
  \ I added stack effects and comments:

  \ : INTERNAL  ( -- nt )  CURRENT @ @  ;
  \   \ Start the definition of internal words of the module.
  \   \ Return the nt of the latest word created in the
  \   \ `current` vocabulary.
  \
  \ : EXTERNAL  ( -- nt )  HERE  ;
  \   \ Start the definition of external words of the module.
  \   \ Return the nt of the next word to be defined.
  \
  \ : MODULE  ( nt1 nt2 -- )  PFA LFA !  ;
  \   \ End the module.
  \   \ Link the first external word to the word before the
  \   \ first internal word, thus making the internal words
  \   \ invisible.

  \ The names have been changed after an analogous code from
  \ pForth, for clarity.

need >>link

: private{  ( -- nt )  latest  ;
  \ Start private definitions.
  \ Return the nt of the latest word created in the
  \ `current` vocabulary.

: }private  ( -- xtp )  np@  ;
  \ End private definitions.
  \ Return the xtp (execution token pointer) of the first
  \ word to be defined as public, that is, the current value
  \ of the names pointer.

: privatize  ( nt xtp -- )  >>link !n  ;
  \ Hide all words between `private{` and `}private`:
  \ Link the first public word to the word before the
  \ first private word, thus making the private words
  \ invisible.

( privatize )

  \ Credits:
  \
  \ Code adapted from pForth.

  \ ____
  \
  \ @(#) private.fth 98/01/26 1.2
  \ PRIVATIZE
  \
  \ Privatize words that are only needed within the file
  \ and do not need to be exported.

  \ Usage example:
  \
  \    private{
  \    \ everything between private{ and }private
  \    \ will become private.
  \    : foo ;
  \    : moo ;
  \    }private
  \    : goo   foo moo ;  \ can use foo and moo
  \    privatize          \ hide foo and moo
  \    ' foo              \ will fail

  \ Copyright 1996 Phil Burk
  \ ____

need name<name  need abort"

variable private-start  variable private-stop

: private{  ( -- )
  latest private-start !  private-stop off  ;
  \ Start private definitions.

: }private  ( -- )
  private-stop @ abort" Extra }private"
  latest private-stop !  ;
  \ End private definitions.

: privatize  ( -- )
  private-start @ 0= abort" Missing private{"
  private-stop @ dup 0= abort" Missing }private"
  begin   dup private-start @ u>
  while   dup hide name<name
  repeat  drop  private-start off  private-stop off  ;
  \ Hide all words between `private{` and `}private`.

( begin-module: begin-module public private end-module )

  \ Credits:
  \
  \ Code adapted and modified from Galope.

need get-order  need wordlist

  \ Inner words

get-order get-current

wordlist dup set-current  >order

variable current-wid  variable module-wid

: (module)  ( -- wid )
  get-current current-wid !
  wordlist dup module-wid ! dup >order  ;

set-current

  \ Interface words

: public  ( -- )  current-wid @ set-current  ;
  \ Public definitions follow.

: private  ( -- )  module-wid @ set-current  ;
  \ Private definitions follow.

: begin-module:  ( "name" -- )  (module) constant private  ;
  \ Start a named module.
  \ Private definitions follow.

: begin-module  ( -- )  (module) drop private  ;
  \ Start an anonymous module.
  \ Private definitions follow.

: end-module  ( -- )  public previous  ;
  \ End a module.

set-order

  \ Description and usage.

  \ Modules hide the internal implementation and leave visible the
  \ words of the outer interface. Example:

  \ begin-module: my_module
  \   \ Inner/helper words.
  \ public
  \   \ Interface words,
  \   \ compiled in the outer vocabulary,
  \   \ thus seen from the extern.
  \ private
  \   \ Inner/helper words again.
  \ public
  \   \ Interface words again. And so on.
  \ end-module

  \ As an alternative, the word 'begin-module' starts an unnamed module.

  \ }}} =======================================================
  \ G+DOS {{{

( ufia )  \ ==g+dos==

24 constant /ufia  create ufia  /ufia allot  ufia /ufia erase

  \ Note: The original field names are used, except `device`,
  \ whose original name is "lstr1".

ufia      constant dstr1   \ drive: 1 or 2
ufia 1+   constant fstr1   \ program number
ufia 2+   constant sstr1   \ stream number
ufia 3 +  constant device  \ device: "D" or "d"
ufia 4 +  constant nstr1   \ directory description
ufia 5 +  constant nstr2   \ file name
ufia 15 + constant hd00    \ file type
ufia 16 + constant hd0b    \ file length
ufia 18 + constant hd0d    \ file start address

  \ XXX OLD -- not needed
  \ ufia 20 + constant hd0f  \ BASIC length without variables
  \ ufia 22 + constant hd11  \ BASIC autorun line

char d device c! \ "d" or "D"
2 sstr1 c!  \ stream 2
1 dstr1 c!  \ drive 1

variable file-length   \ copy of `hd0b` used by `(<file)`
variable file-address  \ copy of `hd0d` used by `(<file)`

( --file-types-- --directory-descriptions-- )

  \ File types

0 constant basic-filetype
1 constant data-array-filetype
2 constant string-array-filetype
3 constant code-filetype

: --file-types--  ;

  \ Directory descriptions

01 constant basic-file-dir      02 constant data-array-dir
03 constant string-array-dir    04 constant code-file-dir
05 constant snapshot-48k-dir    06 constant microdrive-file-dir
07 constant screens$-file-dir   08 constant special-file-dir
09 constant snapshot-128k-dir   10 constant opentype-file-dir
11 constant execute-file-dir

: --directory-descriptions--  ;

( --hook-codes-- )

hex

33 constant hxfer  34 constant ofsm  35 constant hofile
36 constant sbyte  37 constant hsvbk 38 constant cfsm
39 constant pntp   3A constant cops  3B constant hgfile
3C constant lbyte  3D constant hldbk 3E constant wsad
3F constant sad    40 constant rest  41 constant heraz
42 constant cops2  43 constant pcat  44 constant hrsad
45 constant hwsad  46 constant otfoc 47 constant patch

decimal

: --hook-codes--  ;

( ior>error ?dos-error dosior>ior )

: ior>error  ( ior -- f n )
  dup 1 and negate swap   \ calculate f
  flip %11111111 and      \ upper 8 bits of ior
  1000 + negate  ;
  \ Convert a DOS ior to a Forth error number.
  \ ior = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ f = error?
  \ n = error number:
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26

: ?dos-error  ( ior -- )
  \ ior = the AF register returned by a DOS command:
  \   bit 0     = set: error
  \   bits 8-14 = error code
  \   bit 15    = set: OS error; unset: DOS error
  ior>error ?throw  ;

: dosior>ior  ( ior1 -- ior2 )
  dup 1 and negate          \ error?
  swap flip %11111111 and   \ get upper 8 bits of ior
  1000 + negate and  ;
  \ Convert a DOS ior to a Forth ior.
  \ ior1 = the AF register returned by a DOS command:
  \     bit 0     = set: error
  \     bits 8-14 = error code
  \     bit 15    = set: OS error; unset: DOS error
  \ ior2 = error number:
  \     0: no error
  \     -1000..-1031: G+DOS error number 0..31
  \     -1128..-1154: OS error number 0..26

( get-drive set-drive )

need z80-asm  need --hook-codes--

code get-drive  ( -- n )
  \ Get the current drive (1 or 2).
  bc push  \ save the Forth IP
  patch hook
  3ACE fta  \ XXX NEW
  \ XXX TODO check this method:
  \ bit 0 of 3DD1
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp  end-code

code set-drive  ( n -- )
  \ Set the current drive (1 or 2).
  hl pop
  bc push  \ save the Forth IP
  l a ld  21 hook   \ select drive in a
  bc pop   next ix ldp#  \ restore the Forth registers
  jpnext  end-code

( delete-file )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia  need ior>error  need dos>error

code (delete-file)  ( -- ior )
  bc push  \ save the Forth registers
  ufia ix ldp#
  heraz hook  \ erase the file
  bc pop  next ix ldp#  \ restore the Forth registers
  af push
  jpnext
  end-code
  \ Delete a disk file using the data hold in UFIA.
  \ Return a G+DOS _ior_.

: delete-file  ( ca len -- ior )
  filename>ufia (delete-file) dosior>ior  ;
  \ Delete a disk file _ca len_ and return I/O result code
  \ _ior_.

( -filename filename! >ufia filename>ufia )

need ufia  need get-drive

10 constant /filename  \ max filename length

: -filename  ( -- )  nstr2 /filename blank  ;
  \ Blank the filename in UFIA.

: filename!  ( ca len -- )
  \ Store a filename into UFIA.
  \ ca len = filename
  -filename /filename min nstr2 swap cmove  ;
  \ XXX TODO -- rename to `set-filename`?

: >ufia  ( a1 len1 ca2 len2 -- )
  \ Set the UFIA.
  \ a1 len1   = memory region to save or load
  \ ca2 len2  = filename
  3 hd00 c!  4 nstr1 c!  \ code filetype and dir description
  filename!
  dup hd0b !  file-length !
  dup hd0d !  file-address !
  get-drive dstr1 c!  ;

1 set-drive  \ default

: filename>ufia  ( ca len -- )  0 0 2swap >ufia  ;

( >file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (>file)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  bc push  \ save the Forth registers
  ufia ix ldp#
  hofile hook \ open the file and create its header
  nc if \ no error?
    hd0d de ftp  hd0b bc ftp  \ de=start, bc=length
    hsvbk hook \ save to file
    nc if  cfsm hook  then  \ close the file if no error
  then  bc pop  next ix ldp#  \ restore the Forth registers
  af push  \ ior
  jpnext end-code

: >file  ( a1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (>file) ior>error  ;

( <file )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    file-address de ftp  file-length bc ftp
      \ The start address and length specified
      \ in the command are used by default instead
      \ of those stored in the file header.

  \ XXX TODO make the file address optional
  \ XXX TODO make the file length optional

    bc tstp z if  hd0b bc ftp  then  hldbk hook
      \ If the length is zero, use the
      \ length of the file header
      \ instead.  Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code

: <file  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (<file) ior>error  ;

( file>screen )

  \ XXX UNDER DEVELOPMENT
  \ Experimental code to read lines from a file

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (file>screen)  ( -- ior )

  \ Print a file on the screen, line by line, using the data
  \ hold in UFIA.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    patch hook  4000 de ldp#  128 bc ldp#
      \ page +D in
      \ destination and count

    d h ld
    begin   lbyte hook  de stap
            a l ld  de push  bc push  1744 call  bc pop  de pop
              \ print HL
            de incp  bc decp  b a ld  c or
    z until  E7 out  \ page +D out
    \ begin
    \   lbyte hook  af push  10 hook  af pop  13 cp
    \ z until

  then  bc pop  next ix ldp#  af push
        \ restore the Forth registers and save the ior
  jpnext  end-code -->

( file>screen )

: file>screen  ( ca2 len2 -- f n )
  \ Copy a file to the screen, line by line.
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >ufia (file>screen) ior>error  ;

( .000 )

  \ XXX TMP -- for debugging

code .100  ( u -- )
  hl pop
  bc push
  hl push
  patch hook
  hl pop
  1744 call
  E7 out  \ page +D out
  bc pop  next ix ldp#  jpnext
  end-code

( <file-as-is )

need z80-asm  need ufia  need --hook-codes--
need >ufia  need ior>error

code (<file-as-is)  ( -- ior )

  \ Load a file from disk, using the data hold in UFIA, the
  \ file header and the parameters specified by the high level
  \ command.

  bc push  \ save the Forth IP

  ufia ix ldp#  hgfile hook \ get the file
  nc if \ no error?  -- load the file header:

    hd00 de ldp#  9 b ld# \ destination and count
    begin  lbyte hook  de stap  de incp  step
      \ Load the file header.

    hd0d de ftp  hd0b bc ftp  hldbk hook
      \ Use the address and length from the header.
      \ Then load the file data.

  then  bc pop  next ix ldp#  af push
        \ Restore the Forth registers and save the ior.

  jpnext  end-code

: <file-as-is  ( ca len -- f n )
  \ Load a file from disk.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2swap >ufia (<file-as-is) ior>error  ;

( file? )

need ufia  need filename!  need --hook-codes--

code (file?)  ( -- f )

  bc push  \ save the Forth IP
  patch hook
  nstr2 ix ldp#
  1146 call  \ FIND_FILE
  168E call  \ BORD_REST = restore the border
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  ' true >code jpz
  ' false >code jp
  end-code

: file?  ( ca len -- f )  filename! (file?)  ;

( cat acat wcat wacat )

need z80-asm  need ufia  need --hook-codes--
need filename>ufia

  \ G+DOS addresses (in its own paged memory).
[defined] ufia1  ?\ $3E01 constant ufia1
  \ 3E1A constant ufia2

code (cat)  ( n -- )

  \ n = cat type: 2=compact; 4=detailed

  hl pop  bc push  exx
    \ Get the parameter in hl' and save the Forth IP

  patch hook

  ufia hl ldp#  ufia1 de ldp#  /ufia bc ldp#  ldir
    \ Copy Forth UFIA to G+DOS UFIA1.

  \ exx  l a ld  24B5 call  168E call \ XXX OLD
    \ 24B5 = CAT_RUN (input: cat type in the A register)
    \ 168E = BORD_REST (restore the border)

  exx  l a ld  09A5 call \ XXX NEW
    \ 09A5 = SCAN_CAT  (input: cat or search type in the A register)

  E7 out  bc pop  next ix ldp#  jpnext  end-code
    \ page +D out
    \ restore the Forth registers and exit

: wcat  ( ca len -- )  filename>ufia  4 (cat)  ;
  \ Show a disk catologue using the given wild-card filename.
  \ See the +D manual for wild-card syntax.

: wacat  ( ca len -- )  filename>ufia  2 (cat)  ;  decimal
  \ A variant of `wcat` that shows an abbreviated catalogue.
  \ See the +D manual for wild-card syntax.

: cat  ( -- )  s" *" wcat  ;
  \ Show a complete disk catologue.

: acat  ( -- )  s" *" wacat ;  decimal
  \ A variant of `cat` that shows an abbreviated catalogue.

  \ The disk catalogues can be printed out on a printer by
  \ storing the number 3 into SSTR1 (a field of UFIA that holds
  \ the stream number to use) before doing `CAT`. The default
  \ value is 2 (screen) and should be restored. Example:
  \
  \   3 sstr1 c! s" forth?.*" wcat 2 sstr1 c!

( @dos )

need z80-asm  need --hook-codes--

code @dos  ( a -- n )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dos )

need z80-asm  need --hook-codes--

code c@dos  ( a -- b )
  \ Fetch the content of +D memory address.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp
  end-code

( c!dos )

need z80-asm  need --hook-codes--

code c!dos  ( b a -- )
  \ Store b into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  de pop  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( !dos )

need z80-asm  need --hook-codes--

code !dos  ( n a -- )
  \ Store n into the +D memory address a.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  de pop  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( @dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code @dosvar  ( n1 -- n2 )
  \ Fetch the content of G+DOS variable n1.
  hl pop
  bc push  \ save the Forth IP
    \ XXX TODO use exx instead?
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp
  m e ld  hl incp  m d ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  de push
  jpnext
  end-code

( c@dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c@dosvar  ( n -- b )
  \ Fetch the content of G+DOS variable n.
  hl pop
  bc push  \ save the Forth IP
  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp

  \ XXX OLD
  \ m a ld 0 d ld#  a e ld
  \ E7 out  \ page +D out
  \ bc pop  next ix ldp#  \ restore the Forth registers
  \ de push
  \ jpnext

  \ XXX NEW
  m a ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  pusha jp

  end-code

( !dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code !dosvar  ( n1 n2 -- )
  \ Store n1 into the G+DOS variable n2.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push  hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld  hl incp  d m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

( c!dosvar )

need z80-asm  need --hook-codes--

[defined] dos-vars ?\ 8192 constant dos-vars
  \ Address of the G+DOS vars in its own memory.

code c!dosvar  ( b n -- )
  \ Store b into the G+DOS variable n.
  hl pop  de pop
  bc push  \ save the Forth IP
  de push hl push
  patch hook
  hl pop  dos-vars de ldp#  de addp  de pop
  e m ld
  E7 out  \ page +D out
  bc pop  next ix ldp#  \ restore the Forth registers
  jpnext
  end-code

  \ }}} =======================================================
  \ Disk blocks {{{

( ?--> )  \ ==diskblocks==

: ?-->  ( f -- )  if  postpone -->  then  ; immediate

  \ doc{
  \
  \ ?-->  ( f -- )
  \
  \ If _f_ is not false, continue interpretation on the next
  \ sequential block.  parse area. This word is used for
  \ conditional compilation.
  \
  \ }doc


  \ XXX TMP -- `?\` is still in the kernel

  \ : ?\  ( f "text<eol>" -- )  if  postpone \  then  ; immediate

  \ doc{
  \
  \ ?\  ( f "ccc" -- )
  \
  \ If _f_ is not false, parse and discard the rest of the
  \ parse area. This word is used for conditional compilation.
  \
  \ }doc

( update flush thru )

[unneeded] update
?\ : update  ( -- )  disk-buffer @ $8000 or disk-buffer !  ;

  \ doc{
  \
  \ update  ( -- )
  \
  \ Mark the current block buffer as modified.  The block will
  \ subsequently be transferred automatically to disk should
  \ its buffer be required for storage of a different block, or
  \ upon execution of `flush` or `save-buffers`.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] flush
?\ : flush  ( -- )  save-buffers empty-buffers  ;

  \ doc{
  \
  \ flush  ( -- )
  \
  \ Perform the function of `save-buffers`, then unassign all
  \ block buffers.
  \
  \ Origin: Forth-83 (Required Word Set), Forth-94 (BLOCK),
  \ Forth-2012 (BLOCK).
  \
  \ }doc

[unneeded] thru
?\ : thru  ( block1 block2 -- )  1+ swap ?do  i load  loop  ;
  \ XXX FIXME -- when block1>block2

  \ doc{
  \
  \ thru ( block1 block2 -- )
  \
  \ Load consecutively the blocks from _block1_ through
  \ _block2_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83
  \ (Controlled Reference Words), Forth-94 (BLOCK EXT),
  \ Forth-2012 (BLOCK EXT).
  \
  \ }doc

( continued ?load reload loads +load +thru loader )

[unneeded] continued
?\ : continued  ( u -- )  ?loading (load)  ;

  \ doc{
  \
  \ continued  ( u -- )
  \
  \ Continue interpretation at block _u_.
  \
  \ Origin: Forth-79 (Reference Word Set), Forth-83 (Appendix
  \ B. Uncontrolled Reference Words).
  \
  \ }doc

[unneeded] ?load
?\ : ?load  ( block f -- )  if  dup load  then  drop  ;

  \ Credits:
  \
  \ Code from Pygmy Forth.
  \
  \ doc{
  \
  \ ?load  ( block f -- )
  \
  \ Load block _block_ if flag _f_ is true, else do nothing.
  \
  \ }doc

[unneeded] reload
?\ : reload  ( -- )  empty-buffers  scr @ load  ;

  \ doc{
  \
  \ reload  ( -- )
  \
  \ Load the most recently loader or listed block.
  \
  \ }doc

[unneeded] loads
?\ : loads  ( block n -- )  bounds ?do  i load  loop  ;

  \ Credits:
  \
  \ Word from MMSFORTH.

  \ doc{
  \
  \ loads  ( block n -- )
  \
  \ Load _n_ blocks starting from block _block_.
  \
  \ }doc

[unneeded] +load  [unneeded] +thru  and
?\ : +load  ( n -- )  blk @ + load  ;

[unneeded] +thru
?\ : +thru  ( n1 n2 -- )  1+ swap do  i +load  loop  ;


[unneeded] loader ?exit

: loader  ( block "name" -- )
  create ,  does>  ( pfa )  @ load  ;

  \ doc{
  \
  \ loader  ( block "name" -- )
  \
  \ Define a word "name" which, when executed, will  load block
  \ _block_.
  \
  \ Origin: `loads`, found on Forth-79 (Reference Word Set) and
  \ Forth-83 (Appendix B. Uncontrolled Reference Words).
  \
  \ }doc

( .line )

  \ XXX TODO -- `line>string` is in the kernel because
  \ `located` uses it.
  \
  \ : line>string  ( n1 n2 -- ca len )
  \   >r  c/l b/buf */mod  r> +
  \   block + c/l  ;

  \ doc{
  \
  \ line>string  ( n1 n2 -- ca len )
  \
  \ Convert the line number _n1_ and the block number _n2_ to
  \ a string in the disk buffer containing the data.
  \
  \ }doc

: .line  ( n1 n2 -- )  line>string -trailing type  ;

  \ doc{
  \
  \ .line  ( n1 n2 -- )
  \
  \ Print line _n1_ from block _n2_, without trailing spaces.
  \
  \ Origin: fig-Forth.
  \
  \ }doc

  \ }}} =======================================================
  \ Tape files {{{

( write-tape-file read-tape-file )

  \ XXX UNDER DEVELOPMENT -- second approach:
  \ save header and data apart

  \ Credits:
  \
  \ Code adapted from Afera.

  \ -----------------------------------------------------------
  \ Development documentation

  \ Credits:
  \
  \ Information retrieved from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119).

  \ The load tape header is pointed by IX before calling the ROM
  \ routine. Its structure is the following:

  \ +00 : byte, filetype (3 for code files)
  \ +01 : 10-char filename, padded with spaces
  \ +11 : cell, length
  \ +13 : cell, start address
  \ +15 : cell, not used for code files

  \ The save (=old) tape header is right after the load (=new)
  \ header.

  \   Arrangement of two headers in workspace.
  \
  \   Originally IX addresses the load (=old) header, which is
  \   the only one header required when saving.

  \   OLD     NEW         PROG   DATA  DATA  CODE
  \   HEADER  HEADER             num   chr          NOTES.
  \   ------  ------      ----   ----  ----  ----   -----------------------------
  \   IX-$11  IX+$00      0      1     2     3      Type.
  \   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
  \   IX-$0F  IX+$02      x      x     x     x      i
  \   IX-$0E  IX+$03      x      x     x     x      l
  \   IX-$0D  IX+$04      x      x     x     x      e
  \   IX-$0C  IX+$05      x      x     x     x      n
  \   IX-$0B  IX+$06      x      x     x     x      a
  \   IX-$0A  IX+$07      x      x     x     x      m
  \   IX-$09  IX+$08      x      x     x     x      e
  \   IX-$08  IX+$09      x      x     x     x      .
  \   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
  \   IX-$06  IX+$0B      lo     lo    lo    lo     Total
  \   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
  \   IX-$04  IX+$0D      Auto   -     -     Start  Various
  \   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
  \   IX-$02  IX+$0F      lo     -     -     -      Length of Program
  \   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.

17 constant /tape-header
  \ bytes per tape header

  \ After the book by Don Thomasson:
create tape-header  /tape-header 2 * allot
  \ load (=new) and save (=old) headers

  \ After the ROM disassembly:
  \
  \ /tape-header allot  \ old header
  \ create tape-header  /tape-header allot  \ new header

10 constant /tape-filename \ filename max length

: tape-filetype  ( -- ca )  tape-header  ;
: tape-filename  ( -- ca )  tape-header 1+  ;
: tape-length    ( -- a )   tape-header 11 +  ;
: tape-start     ( -- a )   tape-header 13 +  ;

3 tape-filetype c!  \ "code" filetype by default

code (tape)  ( n -- )
  E1 c,  C5 c,  78 05 + c,
    \ pop hl
    \ push bc ; save Forth IP
    \ ld a,l ; 1=load, 0=save
  DD c, 21 c, tape-header ,  2A c, tape-length ,
    \ ld ix,tape_header
    \ ld hl,(tape_length)
  32 c, 5C74 ,  CD c, 075A ,
    \ ld (5C74),A ; T_ADDR system variable
    \ call 075A ; SA_ALL ROM routine ; XXX FIXME crash!
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore the address of Forth next
  jpnext  end-code
  \ Tape primitive that uses the data stored at
  \ `tape-header` to load (n=1) or save (n=0)
  \ a tape file.

-->

( write-tape-file read-tape-file )

: -tape-filename  ( -- )  tape-filename /tape-filename blank ;
  \ Blank the filename of the load header.

: set-tape-filename  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-filename swap cmove  ;
  \ Store a filename into the load header.

: any-tape-filename  ( -- )  255 tape-filename c!  ;
  \ Configure the load header to load any filename.

: transfer-tape-file  ( ca len n -- )
  >r tape-length ! tape-start !
  tape-header dup /tape-header + /tape-header move  \ XXX TMP
  \ save-mode default-mode
  2 23659 c!
    \ system variable DF_SZ (lines in the lower screen)
  r> (tape)
  0 23659 c!
    \ system variable DF_SZ (lines in the lower screen)
  \ restore-mode
    ;
  \ Read or write the tape file whose filename and filetype
  \ have been already set in the tape header.  _n_ is 0 for
  \ writing or 1 for reading; _ca len_ is the memory zone.

-->

( write-tape-file read-tape-file )

: read-tape-file  ( ca1 len1 ca2 len2 -- )
  dup if    set-tape-filename
      else  2drop any-tape-filename
      then  1 transfer-tape-file  ;
  \ Read a tape file into a memory region.
  \ ca1 len1 = memory zone (len1 is zero if unspecified)
  \ ca2 len2 = filename (len2 is zero if unspecified)

: write-tape-file  ( ca1 len1 ca2 len2 -- )
  set-tape-filename 0 transfer-tape-file  ;
  \ Write a memory region into a tape file.
  \ ca1 len1 = memory zone
  \ ca2 len2 = filename

( write-tape-file read-tape-file )

  \ XXX UNDER DEVELOPMENT -- first approach
  \ XXX FIXME

  \ Credits:
  \
  \ Code adapted from Afera.

  \ -----------------------------------------------------------
  \ Development documentation

  \ Credits:
  \
  \ Information retrieved from from Don Thomasson's book
  \ _Advanced Spectrum Forth_ (page 119).

  \ The load tape header is pointed by IX before calling the ROM
  \ routine. Its structure is the following:

  \ +00 : byte, filetype (3 for code files)
  \ +01 : 10-char filename, padded with spaces
  \ +11 : cell, length
  \ +13 : cell, start address
  \ +15 : cell, not used for code files

  \ XXX FIXME This information from the ZX Spectrum ROM
  \ disassembly is contradictory:

  \ The save tape header is right after the save header.

  \   Arrangement of two headers in workspace.
  \   Originally IX addresses first location and only one header is required
  \   when saving.
  \
  \   OLD     NEW         PROG   DATA  DATA  CODE
  \   HEADER  HEADER             num   chr          NOTES.
  \   ------  ------      ----   ----  ----  ----   -----------------------------
  \   IX-$11  IX+$00      0      1     2     3      Type.
  \   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
  \   IX-$0F  IX+$02      x      x     x     x      i
  \   IX-$0E  IX+$03      x      x     x     x      l
  \   IX-$0D  IX+$04      x      x     x     x      e
  \   IX-$0C  IX+$05      x      x     x     x      n
  \   IX-$0B  IX+$06      x      x     x     x      a
  \   IX-$0A  IX+$07      x      x     x     x      m
  \   IX-$09  IX+$08      x      x     x     x      e
  \   IX-$08  IX+$09      x      x     x     x      .
  \   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
  \   IX-$06  IX+$0B      lo     lo    lo    lo     Total
  \   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
  \   IX-$04  IX+$0D      Auto   -     -     Start  Various
  \   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
  \   IX-$02  IX+$0F      lo     -     -     -      Length of Program
  \   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.

17 constant /tape-header
  \ bytes per tape header

  \ After the book by Don Thomasson:
create tape-header  /tape-header 2 * allot
  \ load (=new) and save (=old) headers

  \ After the ROM disassembly:
  \
  \ /tape-header allot  \ old header
  \ create tape-header  /tape-header allot  \ new header

10 constant /tape-filename \ filename max length

: tape-filetype  ( -- ca )  tape-header  ;
: tape-filename  ( -- ca )  tape-header 1+  ;
: tape-length    ( -- a )   tape-header 11 +  ;
: tape-start     ( -- a )   tape-header 13 +  ;

3 tape-filetype c!  \ "code" filetype by default

code (tape)  ( n -- )
  E1 c,  C5 c,  78 05 + c,
    \ pop hl
    \ push bc ; save Forth IP
    \ ld a,l ; 1=load, 0=save
  DD c, 21 c, tape-header ,  2A c, tape-length ,
    \ ld ix,tape_header
    \ ld hl,(tape_length)
  32 c, 5C74 ,  CD c, 075A ,
    \ ld (5C74),A ; T_ADDR system variable
    \ call 075A ; SA_ALL ROM routine
  C1 c,  DD c, 21 c, next ,
    \ pop bc ; restore Forth IP
    \ ld ix,next ; restore the address of Forth next
  jpnext  end-code
  \ Tape primitive that uses the data stored at
  \ `tape-header` to load (n=1) or save (n=0)
  \ a tape file.

-->

( write-tape-file read-tape-file )

: -tape-filename  ( -- )  tape-filename /tape-filename blank ;
  \ Blank the filename of the load header.

: set-tape-filename  ( ca len -- )
  -tape-filename  /tape-filename min
  tape-filename swap cmove  ;
  \ Store a filename into the load header.

: any-tape-filename  ( -- )  255 tape-filename c!  ;
  \ Configure the load header to load any filename.

: transfer-tape-file  ( ca len n -- )
  >r tape-length ! tape-start !  r> (tape)  ;
  \ Read or write the tape file whose filename and filetype
  \ have been already set in the tape header.  _n_ is 0 for
  \ writing or 1 for reading; _ca len_ is the memory zone.

: read-tape-file  ( ca1 len1 ca2 len2 -- )
  dup if    set-tape-filename
      else  2drop any-tape-filename
      then  1 transfer-tape-file  ;
  \ Read a tape file into a memory region.
  \ ca1 len1 = memory zone (len1 is zero if unspecified)
  \ ca2 len2 = filename (len2 is zero if unspecified)

: write-tape-file  ( ca1 len1 ca2 len2 -- )
  set-tape-filename 0 transfer-tape-file  ;
  \ Write a memory region into a tape file.
  \ ca1 len1 = memory zone
  \ ca2 len2 = filename

  \ }}} =======================================================
  \ Tools {{{

( transient[ )  \ ==tools==

  \ XXX TODO -- Finish.

need >>link

variable old-dp
variable old-np
variable old-latest
variable old-voc-link

: transient[  ( u -- )

  \ Start transient code, reserving u bytes for it (including
  \ dictionary space and data stack).
  \
  \ This word must be used before compiling the transient code.
  \ the compiled size of the transient code must be known in
  \ advance.

  here        old-dp !
  np@         old-np !
  latest      old-latest !
  voc-link @  old-voc-link !

  \ XXX FIXME -- after changing `dp` the interpreter does not
  \ recognize any input, just issues error #1, "not
  \ understood".

  0 swap - dp !  ;

: ]transient  ( -- )  old-dp @ dp !  old-np @ np !  ;

  \ End the transient code.
  \
  \ This word must be used after compiling the transient code.

: -transient  ( -- )

  \ Remove the transient code, unlinking the dictionary space
  \ that was reserved for it.
  \
  \ This word must be used when the transient code is not going
  \ to be used any more.

  old-voc-link @ voc-link !

  \ Store the nt of the latest word created before compiling
  \ the transient code, into the lfa of the first word created
  \ after the transient code was finished by `]transient`.

  \ XXX TODO

  old-latest @ old-np @ >>link !n  ;

( [false] [true] )

         0 constant [false] immediate
[false] 0= constant [true]  immediate

( bin. dec. hex. )

  \ Credits:
  \
  \ Code modified from eForth.

[defined] base.
?\ : base.  ( -- )  does> c@ base @ >r base ! u. r> base !  ;

[unneeded] bin.  ?\ create bin.  ( n -- )   2 c, base.
[unneeded] hex.  ?\ create hex.  ( n -- )  16 c, base.

[unneeded] dec.  [defined] dec.  or
  \ XXX TMP -- `dec.` is in the kernel
  ?\  create dec.  ( n -- )  10 c, base.

( 8hex. 16hex. 32hex. <hex hex> )

  \ Credits:
  \
  \ Code adapted from lina.

[defined] base'  ?\ variable base'

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <hex  ( -- )  base @ base' ! hex ; \ switch to hex
: hex>  ( -- )  base' @ base !     ; \ and back

: (dhex.)  ( d n -- )  <hex (d.) hex> type space  ;
: 32hex.    ( d -- )  8 (dhex.)  ;
: 16hex.     ( n -- )  s>d 4 (dhex.)  ;
: 8hex.    ( b -- )  s>d 2 (dhex.)  ;

( binary 8bin. 16bin. 32bin. <bin bin> )

  \ Credits:
  \
  \ Code inspired by lina.

[defined] base'  ?\ variable base'

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

[defined] (d.)
?\ : (d.)  ( d n -- ca len )  <# 0 do  #  loop  #>  ;

: <bin  ( -- )  base @ base' ! binary ; \ switch to binary
: bin>  ( -- )  base' @ base !        ; \ and back

: (dbin.)  ( d n -- )  <bin (d.) bin> type space  ;
: 32bin.    ( d -- )  32 (dbin.)  ;
: 16bin.     ( n -- )  s>d 16 (dbin.)  ;
: 8bin.    ( b -- )  s>d 8 (dbin.)  ;

( ascii-type )

: ascii-type  ( ca len -- )
  bounds ?do
    i c@ 127 and dup bl < if  drop [char] .  then  emit
  loop  ;

( dump )

need 16hex.  need ascii-type

[defined] bs ?\ : bs  ( -- )  8 emit  ;

  \ XXX FIXME -- when len=0 a row is shown; `wdump` does
  \ nothing.

: dump  ( ca len -- )
  8 2dup mod - + 8 / 0
  ?do
    cr dup 16hex.
    8 0 do  i over + @ flip 16hex.  cell +loop
    \ 16 0 do  i over + c@ hexb.  loop  \ XXX OLD
    dup bs 8 ascii-type
    break-key? ?leave
  8 + loop  drop  ;
  \ Show the contents of _n_ bytes starting from _ca_.

( wdump )

need 16hex.

[defined] bs ?\ : bs  ( -- )  8 emit  ;

: wdump  ( a n -- )
  \ Show the contents of _n_ cells starting from _a_.
  0
  ?do
    i 4 mod 0= if  cr dup 16hex. space  then  \ show address
    dup @ 16hex. cell+
    break-key? ?leave
  loop  drop  ;

( decode )


  \ XXX UNDER DEVELOPMENT -- DTC version
  \ 2015-12-24: Start adapting to DTC.

  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

  \ Credits:
  \
  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions IV,#2 p28 (1982-07).

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )
  cell+ dup @ cell+ body>name .name  ;

-->

( decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof

    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof  [then]

    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof

    ['] (.")      of  decode-sliteral   endof

  endcase  ;  -->

( decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  dup  ['] exit =  swap ['] (;code) =  or  ;
  \ Is the given xt the end of a definition?

: colon-cfa?  ( cfa -- f )
  dup c@ $CD <> if  drop false exit  then
  1+ @  [ ' : 1+ ] literal =  ;
  \ Is _cfa_ a colon cfa?
  \ First, its first byte must be $CD (the Z80 call opcode);
  \ second, its jump address must be the same of `:`.

: colon-pfa?  ( pfa -- f )  body> colon-cfa?  ;
  \ Is the given pfa a colon definition?

-->

( decode )

  \ Main code

  \ XXX TODO -- pause with `nuf?`

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n xt xt ) decode-end? 0=
            \ ( pfa+n xt f )
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      3 + ( pfa+n pfa' ) dup indent+  body>name .name
      key case  [char] q  of  sp0 @ sp! quit  endof \ q
                      bl  of  drop            endof \ space
                                 swap recurse \ default
          endcase  decode-special
      cell+  -1 decode-level +!
    repeat  indent cell+ body>name .name \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  defined  ( nt | 0 )  dup 0= -13 ?throw
  name>body  0 decode-level !  (decode)  ;

( itc-decode )

  \ XXX OLD -- ITC version

  \ This file is part of Solo Forth
  \ http://programandala.net/en.program.solo_forth.html

  \ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ You may do whatever you want with this work, so long as you
  \ retain all copyright notices, all credit notices, and this
  \ license in all files of all redistributed copies and derived
  \ works. There is no warranty.

  \ Credits:
  \
  \ This code was adapted and improved from Afera (2015), by
  \ the same author.  The Afera version was adapted and deeply
  \ modified from: Z80 CP/M fig-Forth 1.1g (adaptative version
  \ by EHR), modified by Dennis L. Wilson.  The original code
  \ was written by Robert Dudley Ackerman, published on Forth
  \ Dimensions IV,#2 p28 (1982-07).

  \ Variables, indentation and pause control

forth definitions decimal

need body>name  need name>body  need case  need [if]

variable decode-level  decode-level off \ depth of nesting
variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent  ;

-->

( itc-decode )

  \ Special cases

: decode-branch    ( a1 -- a2 )  cell+ dup @ u.  ;

: decode-literal   ( a1 -- a2 )  cell+ dup @ .  ;

: decode-cliteral  ( a1 -- a2 )  cell+ dup c@ . 1-  ;

: decode-sliteral  ( a1 -- a2 )
  cell+ dup count type  dup c@ + 1-  ;

: decode-compile   ( a1 -- a2 )
  cell+ dup @ cell+ body>name .name  ;

-->

( itc-decode )

  \ Special cases dispatcher

: decode-special  ( a1 -- a1 | a2 )

  dup @ case

    ['] compile   of  decode-compile    endof
    ['] lit       of  decode-literal    endof
    ['] clit      of  decode-cliteral   endof
    ['] slit      of  decode-sliteral   endof
    ['] branch    of  decode-branch     endof
    ['] 0branch   of  decode-branch     endof
    ['] ?branch   of  decode-branch     endof

    [defined] -branch [if]
      ['] -branch   of  decode-branch     endof  [then]

    \ XXX OLD -- for fig-Forth `do loop`:
    \ ['] (loop)    of  decode-branch     endof
    \ ['] (+loop)   of  decode-branch     endof

    \ XXX NEW -- for Forth-83 `do loop`:
    ['] (do)      of  decode-branch     endof
    ['] (?do)     of  decode-branch     endof

    ['] (.")      of  decode-sliteral   endof

  endcase  ;  -->

( itc-decode )

  \ Checks of the main code

: decode-end?  ( xt -- f )
  \ Is the given xt the end of a definition?
  dup  ['] exit =  swap ['] (;code) =  or  ;

: colon-pfa?  ( pfa -- f )
  \ Is the given pfa a colon definition?
  body> @ ['] : @ =  ;

-->

( itc-decode )

  \ Main code

: (decode)  ( pfa -- )

  \ Decode the definition at the given pfa.

  dup colon-pfa? if
    dup body> decode-address ! indent
    ." : " dup body>name .name
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n xt xt ) decode-end? 0=
            \ ( pfa+n xt f )
    while  \ high level & not end of colon definition
      \ ( pfa+n xt )
      cell+ ( pfa+n pfa' ) dup indent+  body>name .name
      key case  [char] q  of  sp0 @ sp! quit  endof \ q
                      bl  of  drop            endof \ space
                                 swap recurse \ default
          endcase  decode-special
      cell+  -1 decode-level +!
    repeat  indent cell+ body>name .name \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( itc-decode )

  \ Interface

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  defined dup 0= -13 ?throw
  decode-usage
  name>body  0 decode-level !  (decode)  ;

( list )

need .line  need nuf?

: list  ( n -- )

  \ List block number _n_.

  dup scr !
  cr ." Scr # " .
  l/scr 0 do
    cr i 2 .r space i scr @ .line
    nuf? ?leave
  loop cr  ;

( index .index )

need .line  need nuf?

: .index  ( n -- )  cr dup 3 .r space 0 swap .line  ;
  \ Print the first line of the block _n_.

: index  ( n1 n2 -- )

  \ doc{
  \
  \ index  ( n1 n2 -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_.
  \
  \ }doc

  1+ swap do
    cr i 3 .r space 0 i .line  nuf? ?leave
  loop  ;

( index-like )

need .index  need nuf?

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-like  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-like  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-sensitive.
  \
  \ }doc

  parse-name 2swap
  1+ swap do
    0 i line>string 2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

( index-ilike )

need .index

[defined] contains
  ?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
     \ Does the string _ca1 len1_ contains the string _ca2
     \ len2?_

: index-ilike  ( n1 n2 "name" -- )

  \ doc{
  \
  \ index-ilike  ( n1 n2 "name" -- )
  \
  \ Print the first line of each block over the range from
  \ _n1_ to _n2_, as long as the string "name" is included in
  \ the line. The string comparison is case-insensitive.
  \
  \ }doc

  parse-name save-string 2dup uppers
  2swap 1+ swap do
    save-string  0 i line>string save-string 2dup uppers
    2over contains if  i .index  then
    nuf? ?leave
  loop  2drop  ;

  \ Note: The parsed string is re-saved to the circular string
  \ buffer in every iteration in order to prevent it from being
  \ overwritten by the strings of the index lines, because the
  \ circular string buffer is small.



( words wordlist-words )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

need trail  need name>link  need tab  need nuf?

[defined] more-words?
?\ : more-words?  ( -- f )  dup 0<>  nuf? 0= and  ;
     \ A common factor of `words` and `words-like`.

: words  ( -- )
  trail
  begin  more-words?  while
    dup .name tab  name>link @n
  repeat drop  ;

[unneeded] wordlist-words ?exit

: wordlist-words  ( wid -- )  >order  words  previous  ;

( words-like )

  \ Credits:
  \
  \ Code adapted from pForth.

need trail  need name>link  need tab  need nuf?

[defined] more-words?
?\ : more-words?  ( -- f )  dup 0<>  nuf? 0= and  ;
     \ A common factor of `words` and `words-like`.

[defined] contains
?\ : contains  ( ca1 len1 ca2 len2 -- f )  search nip nip  ;
   \ Does the string _ca1 len1_ contains the string _ca2
   \ len2?_

: words-like  ( "name" -- )
  \ Print all words (from the `context` vocabulary) containing a substring.
  parse-name 2dup uppers trail  ( ca len nt )
  begin  more-words?  while
    dup >r
    name>string 2over contains if  r@ .name tab  then
    r> name>link @n
  repeat drop 2drop  ;

( where )

  \ XXX FIXME -- terminal input errors are not managed;
  \ the block of the last error is shown insted

need [if]

: where  ( -- )
  \ Print block and line numbers and a picture of where the
  \ last error occurred.
  error-pos 2@  ( n1 n2 )
  \ n1 = value of `>in` when the error happened
  \ n2 = value of `blk` when the error happened
  dup if
    dup scr !
    ." Scr # " decimal dup . cr
    swap c/l /mod c/l * rot block + c/l type cr
    here c@ - spaces [char] ^ emit
  else  2drop  then  ;

( .s u.s )

  \ Credits:
  \
  \ Code from Afera. Original algorithm from v.Forth.

  \ 2015-11-13: Modified `.depth` to print a signed number,
  \ better for debugging.

: .depth  ( n -- )  [char] < emit 0 .r [char] > space  ;

: .s   ( -- )
  depth dup .depth if
    sp@ s0 @ cell- do i @ .  [ cell negate ] literal +loop
  then  ;

: u.s   ( -- )
  depth dup .depth if
    sp@ s0 @ cell- do i @ u.  [ cell negate ] literal +loop
  then  ;

( possibly anew )

need marker

  \ Credits:
  \
  \ Code adapted from Wil Baden.

  \ XXX TODO test

: possibly  ( "name" -- )
  defined ?dup if  name> execute  then  ;

: anew  ( "name" -- )  >in @  possibly  >in !  marker  ;

( marker ) \ second approach

  \ XXX UNDER DEVELOPMENT

: marker,  ( -- a )
  here  voc-link @ dup ,
  begin
    dup cell- @  ( a nt ) swap @
  dup 0= until  drop
  np@ ,  ;
  \ Compile the data required by a a marker and return its
  \ address.

: unmarker  ( a -- )
  ;
  \ Restore the data preserved at _a_ by a marker word.

: marker  ( "name" -- )
  marker, create ,  does>  ( -- ) ( pfa )  @ unmarker  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT

  \ 2016-01-01: example taken from m3forth
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: MARKER ( "name" -- )
  here
  get-current ,
  get-order dup , 0 ?do dup , @ , loop
  create ,
  does> @ dup \ only
  dup @ set-current cell+
  dup @ >r r@ cells 2* + 1 cells - r@ 0
  ?do dup dup @ swap cell+ @ over ! swap 2 cells - loop
  drop r> set-order
  dp !
  ;

( marker )  \ first approach

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO -- add user variables pointer
  \ XXX TODO -- add order
  \ XXX TODO -- add latest of all vocs

: get-every-latest  ( -- nt0..ntn | nt )
  \ Get the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: set-every-latest  ( nt0..ntn | nt -- )
  \ Set the latest definition of every vocabulary.
  voc-link @ begin
    dup cell - @  ( a nt ) swap @
  dup 0= until  drop  ;

: marker@  ( -- x1..xn1 n1 nt1..ntn2 n2 )
  \ Get the data a marker word must preserve.
  \ n = number of data cells on the stack
  depth >r  here np@ voc-link @
  depth r> - get-every-latest  ;

: marker!  ( a -- )
  \ Restore the data preserved by a marker word.
  dup @ dup voc-link !  cell+ dup @ np!  cell+ @ dp !  ;

-->

( marker )

: n,  ( x1..xn n -- )  0 do  ,  loop  ;
  \ Compile _n_ cells.

: marker  ( "name" -- )
  marker@ create n,  does>  ( -- ) ( pfa )  marker!  ;
  \ Create a definition for "name" that will remove itself and
  \ everything defined after it, restoring all dictionary
  \ allocation and search order pointers to the state they had
  \ just prior to the definition of "name".

( marker )

  \ XXX UNDER DEVELOPMENT
  \ Code from eForth, for reference.

 \ : _MARKER ( -- ) ( R: dfa -- ) \ ???
 \   R> 2@ ( * ) DUP @ FOLLOWER !  DUP CONTEXT
 \   BEGIN >R CELL+ DUP @ DUP R@ ! WHILE R> CELL+ REPEAT ( search order )
 \   CELL+ DUP 2@ CURRENT 2!  CELL+ DUP @ ( cur wid & head )
 \   BEGIN >R  CELL+ DUP @ R@ !  R> CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   R> 2DROP ( * ) DP 2! ; COMPILE-ONLY

 \ : MARKER ( "name" -- ) \ ???
 \   ALIGN DP 2@ ( * ) FOLLOWER @ ,  CONTEXT
 \   BEGIN DUP @ DUP , WHILE CELL+ REPEAT  DROP ( search order )
 \   CURRENT 2@ , DUP , ( cur wid & head )
 \   BEGIN DUP @ , CELL+ @ ?DUP 0= UNTIL ( wid last na's )
 \   ['] _MARKER : REVEAL COMPILE, ( * ) , , ;

( ~~ )


  \ 2016-02-18: First version.

need :noname  need defer  need is

variable ~~?    ~~? on      \ active?
variable ~~x    ~~x off     \ x coordinate
variable ~~y    ~~y off     \ y coordinate
variable ~~key  ~~key off   \ quit key, or zero if no pause

: ~~show  ( nt line block -- )
  ~~x @ ~~y @ at-xy ." Block " . ." Line " . .name .s   ;
  \ Show the debugging info.

: ~~control  ( -- )
  ~~key @ ?dup 0= ?exit  key = if  quit  then  ;
  \ If `~~key` is non-zero, wait for a key and quit if it
  \ equals the contents of `~~key`.

2variable ~~backup-xy

defer ~~save  ( -- )  defer ~~restore  ( -- )

:noname  ( -- )  xy ~~backup-xy 2!        ; is ~~save
:noname  ( -- )     ~~backup-xy 2@ at-xy  ; is ~~restore
  \ Save and restore the current coordinates.

-->

( ~~ )

: (~~)  ( nt line block -- )
  ~~? @
  if    ~~save ~~show ~~control ~~restore
  else  2drop drop  then  ;
  \ Execute the debugging code, if debugging is active.

: ~~  ( -- )
  latest      postpone literal
  >in @ c/l / postpone literal
  blk @       postpone literal
  postpone (~~)  ; immediate compile-only
  \ Compile debugging code.
  \ This word was inspired by Gforth's `~~`.

( assert assert= )

  \ Credits:
  \
  \ Taken from Brad Nelson's code:
  \ http://bradn123.github.io/literateforth/out/events.fs

: assert   ( n -- )    0= if  abort  then  ;
: assert=  ( a b -- )  = assert  ;

( assert( )

  \ Credits:
  \
  \ Code and documentation from Gforth.

  \ It is a good idea to make your programs self-checking, in
  \ particular, if you use an assumption (e.g., that a certain
  \ field of a data structure is never zero) that may become
  \ wrong during maintenance.  Gforth supports assertions for
  \ this purpose. They are used like this:

  \      assert( FLAG )

  \ The code between `assert(' and `)' should compute a flag,
  \ that should be true if everything is alright and false
  \ otherwise. It should not change anything else on the stack.
  \ The overall stack effect of the assertion is `( -- )'. E.g.

  \   assert( 1 1 + 2 = ) \ what we learn in school
  \   assert( dup 0<> ) \ the top of stack should not be zero
  \   assert( false ) \ this code should not be reached

  \ The need for assertions is different at different times.
  \ During debugging, we want more checking, in production we
  \ sometimes care more for speed. Therefore, assertions can be
  \ turned off, i.e., the assertion becomes a comment.
  \ Depending on the importance of an assertion and the time it
  \ takes to check it, you may want to turn off some assertions
  \ and keep others turned on. Gforth provides several levels
  \ of assertions for this purpose:

  \ Note that the `assert-level' is evaluated at compile-time,
  \ not at run-time. I.e., you cannot turn assertions on or off
  \ at run-time, you have to set the `assert-level'
  \ appropriately before compiling a piece of code. You can
  \ compile several pieces of code at several `assert-level's
  \ (e.g., a trusted library at level 1 and newly written code
  \ at level 3).

variable assert-level ( -- a )
  \ specifies the highest assertions that are turned on

1 assert-level !
  \ by default all assertions above 1 are turned off

: assertn ( n -- )  assert-level @ > if  postpone (  then  ;

: assert0( ( -- )  0 assertn  ; immediate
    \ important assertions that should always be turned on

: assert1( ( -- )  1 assertn  ; immediate
    \ normal assertions; turned on by default

: assert2( ( -- )  2 assertn  ; immediate
    \ debugging assertions

: assert3( ( -- )  3 assertn  ; immediate
    \ slow assertions that you may not want to turn on in
    \ normal debugging; you would turn them on mainly for
    \ thorough checking

: assert( ( -- )  postpone assert1( ; immediate

: (endassert) ( f -- )  0= #-262 ?throw ;

: ) ( -- )  postpone (endassert) ; immediate
    \ end an assertion

( save-input restore-input )

  \ XXX UNDER DEVELOPMENT
  \
  \ 2016-01-01: Code copied from m3Forth:
  \ https://github.com/oco2000/m3forth/blob/master/lib/include/core-ext.f

: save-input ( -- xn ... x1 n )
  source-id 0>
  if tib #tib @ 2dup c/l 2 + allocate throw dup >r swap cmove
     r> to tib  >in @
     source-id file-position throw
     5
  else blk @ >in @ 2 then
  ;

-->
( save-input restore-input )

: restore-input ( xn ... x1 n -- f )
  source-id 0>
  if dup 5 <> if 0 ?do drop loop -1 exit then
     drop source-id reposition-file ?dup
     if >r 2drop drop r> exit then
     >in ! #tib ! to tib false
  else dup 2 <> if 0 ?do drop loop -1 exit then
     drop >in ! blk ! false
  then
  ;
( extend size system turnkey )

  \ XXX WARNING -- Since name fields are saved in a memory
  \ bank, the best way to save a modified Forth system is to
  \ make a snapshot with the ZX Spectrum emulator; otherwise a
  \ multipart saving and loading would be needed.  Anyway,
  \ these words are meant to save a Forth program that does not
  \ need to search the dictionary.
  \
  \ XXX TODO -- Study how to save and load the names bank, even
  \ after assembling the kernel.

: extend  ( -- )
  latest $08 +origin !  \ top most word in `forth` vocabulary
  here $1F +origin !   \ `dp` init value
  np@ $26 +origin !   \ `np` init value
  voc-link @ $0C +origin !  ;  \ `voc-link` init value

  \ doc{
  \
  \ extend  ( -- )
  \
  \ }doc
  \
  \ Change the `cold` start parameters to extend the system to
  \ its current state.

: size  ( -- u )  here 0 +origin -  ;

  \ doc{
  \
  \ size  ( -- u )
  \
  \ Size of the system.
  \
  \ }doc

: system  ( -- a len )  extend  0 +origin size 10 +  ;

  \ doc{
  \
  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for
  \ saving the system to disk.
  \
  \ }doc

: turnkey  ( xt -- a len )  boot defer! system  ;

  \ doc{
  \
  \ turnkey  ( xt -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given xt after the ordinary boot process.
  \ Return its start address and length, to be used as
  \ parameters for saving the system to disk.
  \
  \ }doc

  \ }}} =======================================================
  \ Control structures {{{

( 0if 0while 0until )  \ ==controlstructures==

  \ XXX TODO Compilation stack notation.

: 0if  ( f -- )
  postpone ?branch >mark  ; immediate compile-only

  \ doc{
  \
  \ 0if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= if`.
  \
  \ }doc


: 0while  ( f -- )
  postpone 0if  postpone swap  ; immediate compile-only
  \ XXX TODO use cs-swap

  \ doc{
  \
  \ 0while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= while`.
  \
  \ }doc

: 0until  ( f -- )
  postpone ?branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ 0until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0= until`.
  \
  \ }doc

( -branch )

code -branch  ( f -- )

  E1 c,
    \ pop hl
  CB c, 7C c,
    \ bit 7,h ; negative?
  CA c, ' branch >code ,
    \ jp z,branch_code ; if not, branch
  03 c, 03 c,
    \ inc bc
    \ inc bc ; skip the inline branch address
  jpnext
  end-code

  \ doc{
  \
  \ -branch  ( f -- )
  \
  \ A run-time procedure to branch conditionally. If  _f_ on
  \ stack is negative, the following in-line address is copied
  \ to IP to branch forward or  backward.
  \
  \ Compiled by `-if`, `-while` and `-until`.
  \
  \ }doc

( -if -while -until )

  \ XXX TODO Compilation stack notation.

need -branch  need cs-swap

: -if  ( f -- )
  postpone -branch >mark  ; immediate compile-only

  \ doc{
  \
  \ -if  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< if`.
  \
  \ }doc

: -while  ( f -- )
  postpone -if  postpone cs-swap  ; immediate compile-only

  \ doc{
  \
  \ -while  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< while`.
  \
  \ }doc

: -until  ( f -- )
  postpone -branch <resolve  ; immediate compile-only

  \ doc{
  \
  \ -until  ( f -- )
  \
  \ Faster and smaller alternative to the idiom `0< until`.
  \
  \ }doc

( 0exit )

code 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                 \ pop hl
  78 04 + c,            \ ld a,h
  B0 05 + c,            \ or l
  CA c, ' exit >code ,  \ jp z,exit_code
  jpnext                \ jp next

  end-code

  \ doc{
  \
  \ 0exit  ( f -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _f_ is zero, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `0exit` is not intended to be used within a do-loop. Use
  \ `0= if unloop exit then` instead.
  \
  \ In Solo Forth `0exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

code -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )

  E1 c,                   \ pop hl
  CB c, 7C c,             \ bit 7,h ; negative?
  C2 c, ' exit >code ,    \ jp nz,exit_code
  jpnext                  \ jp next

  end-code

  \ doc{
  \
  \ -exit  ( n -- ) ( R: nest-sys | -- nest-sys | )
  \
  \ If _n_ is negative, return control to the calling definition,
  \ specified by _nest-sys_.
  \
  \ `-exit` is not intended to be used within a do-loop. Use
  \ `0< if unloop exit then` instead.
  \
  \ In Solo Forth `-exit` can be used in interpretation mode to
  \ stop the interpretation of a block.
  \
  \ }doc

( retry ?retry )

  \ Credits:
  \
  \ Code of `retry` from an article by Richard Astle in Forth
  \ Dimensions (volume 17, number 4, page 36, 1995-11).

need name>body

: retry  ( -- )
  latest name>body postpone again
  ; immediate compile-only

: ?retry  ( run-time: f -- )
  postpone if  postpone retry  postpone then
  ; immediate compile-only

( base-execute )

  \ Credits:
  \
  \ Word from Gforth.

: base-execute  ( xt n -- )  base @ >r execute r> base !  ;
  \ Execute _xt_ with the content of `base` being _n_
  \ and restoring the original `base` afterwards.

( cs-pick cs-roll cs-swap cs-drop )

need alias need pick  need roll

' pick alias cs-pick
' roll alias cs-roll
' swap alias cs-swap
' drop alias cs-drop

( cs-pick cs-roll cs-drop cs-mark cs-test cs-push cs-pop )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

  \ Control-flow stack extension words. Sample implementation.
  \ Assumes control flow is on the data stack and control flow
  \ items are one cell wide.

  \ XXX NOTE: This words are defined also in the kernel of
  \ DZX-Forth.

  variable cf0

  \ initialize control flow stack base
  : !cfs ( -- )  sp@ cf0 ! ;  !cfs

  : #cs ( -- n )
    sp@ cf0 @ - negate [ 1 cells ] literal / 1-
    0 max ( handle empty stack) ;

  : cs-pick  pick ( +bal) ;
  : cs-roll  roll ;
  : cs-drop  drop ( -bal) ;
  : cs-mark  0 ( +bal) ;
  : cs-test  dup 0<> ;
  : cs-push  #cs -roll ;
  : cs-pop   #cs roll ;

  \ cs-drop ( C: x -- )

  \ Remove the top item from the control-flow stack.

  \ cs-mark ( C: -- x )

  \ Place a marker on the control-flow stack. A marker occupies
  \ the same width as an orig|dest but is distinguishable using
  \ `cs-test`.

  \ cs-test ( C: x -- x ) ( S: -- flag )

  \ Return a true flag if _x_ is an orig|dest, or false if a
  \ marker. _x_ is not altered or removed. If the control-flow
  \ stack is implemented using the data stack, flag shall be
  \ the topmost item on the data stack.

  \ cs-push ( C: xu..x1 x0 -- x0 xu..x1 )

  \ Rotate items on the control-flow stack such that the top
  \ item becomes the bottom.  An ambiguous condition exists if
  \ the control-flow stack is empty before `cs-push` is executed.

  \ cs-pop ( C: xu xu-1..x0 -- xu-1..x0 xu )

  \ Rotate items on the control-flow stack such that the bottom
  \ item becomes the top.  An ambiguous condition exists if the
  \ control-flow stack is empty before `cs-pop` is executed.

  \ XXX TODO implement this in the kernel:

  : : ( "name" -- ) ... ( !csp bal off) !cfs ;
  : :noname ( -- xt ) ... ( xt ) ( !csp bal off) !cfs ;

  \ start Forth with control flow base set to a safe value
  : cold ( -- ) ... !cfs ;

( cs-pick cs-roll )

  \ XXX UNDER DEVELOPMENT
  \
  \ Credits:
  \
  \ Code from hForth.

  \ cs-pick
  \
  \    Execution: ( C: destu ... orig0|dest0 -- destu ... orig0|dest0 destu )
  \    ( S: u -- )
  \  Interpretation: Interpretation semantics for this word are undefined.

  \    Remove u.  Copy destu to the top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-PICK is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-pick
  ( destu ... orig0|dest0 u -- destu ... orig0|dest0 destu )
  dup 2* 1+ pick    \ check destu; dest type is 0
  if -22 throw then    \ control structure mismatch
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r> 2* 1+ pick 0
  bal 1+ to bal ; compile-only

  \ cs-roll
  \    Execution: ( C: origu|destu origu-1|destu-1 ... orig0|dest0 --
  \        origu-1|destu-1 ... orig0|dest0 origu|destu )
  \    ( S: u -- )

  \  Interpretation: Interpretation semantics for this word are
  \  undefined.
  \
  \    Remove u.  Rotate u+1 elements on top of the control-flow
  \    stack so that origu|destu is on top of the control-flow
  \    stack.  An ambiguous condition exists if there are less
  \    than u+1 items, each of which shall be an orig or dest,
  \    on the control-flow stack before CS-ROLL is executed.
  \
  \    If the control-flow stack is implemented using the data
  \    stack, u shall be the topmost item on the data stack.

: cs-roll
  \ ( origu|destu origu-1|destu-1 ... orig0|dest0 u
  \    -- origu-1|destu-1 ... orig0|dest0 origu|destu )
  dup >r  0 swap    \ destu ... orig0|dest0 0 u  r: u
  1+ 0 do i 2* 1+ pick or loop
    \ dest type is 0; orig type is 1
  1 invert and if -22 throw then  \ ored types should be 0
  r@ 2* 1+ roll
  r> 2* 1+ roll ; compile-only

( begincase )

  \ XXX UNDER DEVELOPMENT 2015-10-26

  \ Credits:
  \
  \ http://dxforth.netbay.com.au/cfsext.html

need cs-push  need cs-pop

: begincase
  postpone case  postpone begin  cs-push  ; immediate

: (nextcase)
  cs-pop  postpone again  postpone endcase  ; immediate

: nextcase
  postpone drop  postpone (nextcase)  ; immediate

: test
  begincase
    cr ." press a key ('2' '4' '9' exits) : " key
    [char] 2 of  ." ... 2 "  endof
    [char] 4 of  ." ... 4 "  endof
    [char] 9 of  ." ... 9 "  endof
      dup emit ."  try again"
  nextcase  ;

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX first version

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

  \ XXX TODO
  \ code (times)  ( n -- )
  \   \ ld h,b
  \   \ ld l,c
  \   \ ld e,(hl)
  \   \ inc hl
  \   \ ld d,(hl) ; de = xt to execute
  \   end-code

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times) postpone [']  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX second version
  \ Immediate words are not allowed.

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f )  -271 ?throw  compile,
  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( times )

  \ XXX UNDER DEVELOPMENT
  \ XXX third version
  \ No check is done during compilation.

  \ Credits:
  \
  \ `(times)` was inspired by cmForth's `repeats`.

: (times)  ( n -- )
  rp@ @ dup cell+ rp@ ! @ swap
  0 ?do  dup execute  loop  drop  ;

: times  ( Compilation: "name" -- ) ( Run-time: n -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, pop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( dtimes )

  \ XXX UNDER DEVELOPMENT

need dfor

: (dtimes)  ( d -- )
  rp@ @ dup cell+ rp@ ! @ swap
  dfor  dup execute  dstep  drop  ;
  \ XXX TODO ?do

: dtimes  ( Compilation: "name" -- ) ( Run-time: d -- )
  postpone (times)  ; immediate compile-only

  \ Repeat the next instruction if the count _d_ on top of the
  \ stack is not zero.  The count is also decremented.  If
  \ count is zero, drop it and continue executing the following
  \ instruction.

  \ `times` is useful to implement complicated math operations,
  \ like shifts, multiply, divide and square root, from
  \ appropriate math step instructions.  It is also useful in
  \ repeating auto-indexing memory instructions.

( ?? )

  \ Credits:
  \
  \ Original code by Neil Bawd, presented at FORML 1986.

  \ The original code was written two ways:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   s" if" evaluate  bl word count evaluate  s" then" evaluate
  \   ;  immediate

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if bl word count evaluate  postpone then
  \   ;  immediate

  \ XXX OLD -- This first version used `postpone` and `compile,`
  \ instead of `evaluate`.

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \   postpone if
  \   parse-name find-name 0= -13 ?throw compile,
  \   postpone then
  \   ;  immediate

  \ XXX OLD -- simpler:

  \ : ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  \  postpone if  ' compile,  postpone then
  \  ;  immediate

  \ XXX OLD -- even simpler:

  \ : ??  ( f -- )  0= if  r> cell+ >r  then  ; compile-only

  \ Complete version, after a comment by Anton Ertl in
  \ comp.lang.forth, 2015-10-19.

: ??  ( Compilation: "name" -- ) ( Runtime: f -- )
  postpone if
  defined ( nt | 0 ) ?dup 0= -13 ?throw
  name>immediate? ( xt f ) if  execute  else  compile,  then
  postpone then
  ;  immediate compile-only

( don't )

: don't  ( n1 n2 -- | n1 n2 )
  2dup = if  2drop unnest unnest  then  ; compile-only

  \ doc{
  \
  \ don't  ( n1 n2 -- | n1 n2 )
  \
  \ If _n1_ equals _n2_, remove them and exit the definition
  \ that called `don't`, else leave the _n1_ and _n2_ on the
  \ stack.
  \
  \ This word is intended to be used before `do`, as an
  \ alternative to `?do`, when the do-loop structure is
  \ factored in its own word.
  \
  \ }doc

( j )

code j
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop index.

  2A c, rp ,            \ ld hl,(return_stack_pointer)
  11 c, 3 cells ,       \ ld de,3*cell
  19 c,                 \ add hl,de
  C3 c, ' i >code 3 + , \ jp i_code+3

  end-code

( k )

code k
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the third loop index.

  2A c, rp ,            \ ld hl,(return_stack_pointer)
  11 c, 6 cells ,       \ ld de,6*cell
  19 c,                 \ add hl,de
  C3 c, ' i >code 3 + , \ jp i_code+3

  end-code

( i' )

code i'  ( -- x )
         ( R: loop-sys -- loop-sys )

  \ Return a copy of the current (innermost) loop limit.

  2A c, rp ,        \ ld hl,(return_stack_pointer)
  11 c, 2 cells ,   \ ld de,2*cell
  19 c,             \ add hl,de
  C3 c, fetchhl ,   \ jp fetchhl

  end-code

( j' )

code j'  ( -- x )
         ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )

  \ Return a copy of the next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 5 cells , \ ld de,5*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( k' )

code k'
  \ ( -- x )
  \ ( R: loop-sys1 loop-sys2 loop-sys3 -- loop-sys1 loop-sys2 loop-sys3 )

  \ Return a copy of the second next-outer loop limit.

  2A c, rp ,      \ ld hl,(return_stack_pointer)
  11 c, 8 cells , \ ld de,8*cell
  19 c,           \ add hl,de
  C3 c, fetchhl , \ jp fetchhl

  end-code

( for step )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth. Modified to do the check
  \ before decrementing the index.

code (step)  ( R: n -- n' )

  \ doc{
  \
  \ (step)
  \
  \ The run-time procedure compiled by `step`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

  2A c, rp ,
    \ ld hl,(return_stack_pointer)
  5E c, 23 c, 56 c,
    \ ld e,(hl)
    \ inc hl
    \ ld d,(hl) ; de = loop index
  7A c, B3 c,
    \ ld a,d
    \ or e ; z=already zero?
  1B c, 72 c, 2B c, 73 c,
    \ dec de
    \ ld (hl),d
    \ dec hl
    \ ld (hl),e ; update the loop index
  C2 c, ' branch >code ,
    \ jp nz,branch_code ; loop again if not zero
    \ ; done, discard loop index:
  23 c, 23 c, 22 c, rp ,
    \ inc hl
    \ inc hl
    \ ld (return_stack_pointer),hl
    \ ; skip branch offset and jump to next
  03 c, 03 c, jpnext
    \ inc bc
    \ inc bc
    \ jp next

  end-code

: for  ( n -- )  postpone >r <mark  ; immediate compile-only

  \ doc{
  \
  \ for  Compilation: ( R: -- dest ) Run-time:    ( u -- )
  \
  \ Start of a `for step` loop, that will iterate _u+1_ times,
  \ starting with _u_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `r@`.
  \
  \ }doc

: step  ( -- )
  postpone (step) <resolve  ; immediate compile-only

  \ doc{
  \
  \ step
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `for`.
  \
  \ Run-time:    ( R: u -- u' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

( dfor dstep di )

: (dstep)  ( R: x ud -- x ud' )

  \ doc{
  \
  \ (dstep)  ( R: x ud -- x ud' | x )
  \
  \ The run-time procedure compiled by `dstep`.
  \
  \ If the loop index _ud_ is zero, discard it and continue
  \ execution after the loop. Otherwise decrement the loop
  \ index and continue execution at the beginning of the loop.
  \
  \ }doc

  r>  \ save the return address
  2r> 2dup or  \ is the index zero?
  if    -1. d+ 2>r
    \ decrement the index
  else  2drop  [ 2 cells ] literal +
    \ discard the index and skip the branch offset
  then  >r  ;
    \ restore the return address

: dfor  ( ud -- )  postpone 2>r <mark  ; immediate compile-only

  \ doc{
  \
  \ dfor
  \
  \ Compilation: ( R: -- dest )
  \ Run-time: ( ud -- )
  \
  \ Start of a `dfor dstep` loop, that will iterate _ud+1_
  \ times, starting with _du_ and ending with 0.
  \
  \ The current value of the index can be retrieved with `di`.
  \
  \ }doc

: dstep  ( -- )
  postpone (dstep) postpone branch <resolve
  ; immediate compile-only

  \ doc{
  \
  \ dstep
  \
  \ Compilation: ( dest -- )
  \
  \ Append the run-time semantics given below to the current
  \ definition. Resolve the destination of `dfor`.
  \
  \ Run-time:    ( R: ud -- ud' )
  \
  \ If the loop index is zero, discard the loop parameters and
  \ continue execution after the loop. Otherwise decrement the
  \ loop index and continue execution at the beginning of the
  \ loop.
  \
  \ }doc

: di  ( -- ud )  ( R: x ud -- x ud )
  r> 2r@ rot >r  ;

  \ XXX TODO -- rename `dfor-i`?

  \ doc{
  \
  \ di  ( -- ud )  ( R: x ud -- x ud )
  \
  \ Return the current index _ud_ of a `dfor` loop.
  \
  \ }doc

( case )

  \ Credits:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 48 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop  begin  ?dup  while  [compile] then  repeat
  ; immediate compile-only

( case )  \ baden-case )

  \ An alternative `case` structure that makes any
  \ calculation easier.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted and modified from code written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).

  \ XXX TODO rename, avoid standard names: `case`, `of`,
  \ `endof`.

defer case  ( n -- n n )  ' dup ' case defer!
defer othercase  ( n -- )  ' drop ' othercase defer!

: of  ( n f -- )
  postpone if  postpone drop  ; immediate compile-only

: endof  ( n f -- )
  postpone exit  postpone then  ; immediate compile-only  exit

  \ Usage example

  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;
  \ : say-other ." alia"  ;

  \ : test  ( n -- )
  \   case 0 = of  say0  endof
  \   case 1 = of  say1  endof
  \   case 2 = of  say2  endof
  \            othercase say-other  ;
  \ ----

( case )  \ eforth-case )

  \ Credits:
  \
  \ Code adapted and modified from eForth.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only

: of
  \ Compilation: ( -- orig )
  \ Run-time: ( x1 x2 -- )
  postpone over postpone = postpone if  postpone drop
  ; immediate compile-only

: endof  ( orig1 -- orig2 )
  postpone else  ; immediate compile-only

: (endcase) ( 0 orig1..orign -- )
  begin  ?dup  while  [compile] then  repeat  ;

: endcase
  ( Compilation: 0 orig1..orign -- )
  ( Run-time: x -- )
  postpone drop (endcase)  ; immediate compile-only

( case )  \ 94-doc-case )

  \ Credits:
  \
  \ Code copied from the example provided in the Forth-94
  \ documentation.

  \ This version uses 54 bytes.

0 constant case  immediate compile-only
  \ init count of ofs

: of
  \ Compilation: ( #of -- orig #of+1 )
  \ Run-time: ( x1 x2 -- )
  1+ >r
  postpone over  postpone =   \ copy and test case value
  postpone if                 \ add orig to control flow stack
  postpone drop               \ discards case value if =
  r>  ; immediate compile-only

: endof
  \ Compilation: ( orig1 #of -- orig2 #of )
  \ Run-time: ( -- )
  >r  postpone else  r>  ; immediate compile-only

: endcase
  \ Compilation:  ( orig1..orign #of -- )
  \ Run-time: ( x -- )
  postpone drop  \ discard case value
  0 ?do  postpone then  loop  ; immediate compile-only

( case )  \ abersoft-case )

  \ Credits:
  \
  \ This is the `case` provided by Abersoft Forth,
  \ translated from the Z80 disassembly, modified (compiler
  \ security has been removed) and commented.

  \ This version uses 64 bytes.

: case
  \ Compilation: ( -- a )
  \ Runtime: ( x -- )
  csp @ !csp  ; immediate compile-only

: of
  \ Compilation: ( -- )
  \ Run-time: ( x -- )
  postpone over  postpone =  postpone if  postpone drop
  ; immediate compile-only

: endof
  \ Compilation: ( -- )
  \ Run-time: ( -- )
  postpone else  ; immediate compile-only

: endcase
  \ Compilation: ( a orig1..orign -- )
  \ Run-time: ( x -- )
  postpone drop
  begin  sp@ csp @ <>  while  postpone then  repeat
  csp !  ;  immediate

( between-of )

  \ Credits:
  \
  \ Code from Galope.

need between

: (between-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> between 0= if  invert  then  ;

: between-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 x3 -- | x1 )
  postpone (between-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 between-of  ." between two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( less-of )

  \ Credits:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (less-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup >= if  invert  then  ;

: less-of  ( Compilation: -- of-sys )
           ( Run-time: x1 x2 -- | x1 )
  postpone (less-of) postpone of  ;  immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 less-of  ." less than 15"  endof
  \     ." greater than 14"
  \   endcase  ;

( greater-of )

  \ Credits:
  \
  \ Code from Galope.

[defined] nup ?\ : nup  ( x1 x2 -- x1 x1 x2 )  over swap  ;

: (greater-of)  ( x1 x2 -- x1 x1 | x1 x1' )
  nup nup <= if  invert  then  ;

: greater-of  ( Compilation: -- of-sys )
              ( Run-time: x1 x2 -- | x1 )
  postpone (greater-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     10 of  ." ten!"  endof
  \     15 greater-of  ." greater than 15"  endof
  \     ." less than 10 or 11..15"
  \   endcase  ;

( within-of )

  \ Credits:
  \
  \ Code from Galope.

need within

: (within-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup 2r> within 0= if  invert  then  ;

: within-of  ( Compilation: -- of-sys )
             ( Run-time: x1 x2 x3 -- | x1 )
  postpone (within-of) postpone of  ; immediate compile-only

  \ XXX TODO confirm the ranges in the example:

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 5 within-of  ." within two and five"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( any-of )

need any?

: (any-of)  ( x0 x1..xn n -- x0 x0 | x0 0 )
  dup 1+ pick >r any? r> tuck and  ;

: any-of  ( Compilation: -- of-sys )
          ( Run-time: x0 x1..xn n -- | x0 )
  postpone (any-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( n -- )
  \   case
  \     1 of  ." one"  endof
  \     2 7 10 3 any-of  ." two, seven or ten"  endof
  \     6 of  ." six"  endof
  \   endcase  ;

( default-of )

  \ Credits:
  \
  \ Code from Galope.  Originally based on code by Mark Willis
  \ posted to <lang.comp.forth>:
  \ Message-ID:
  \ <64b90787-344c-4ee0-a0e4-4e2c12b3dec3@googlegroups.com>
  \ Date: Fri, 24 Jan 2014 02:08:22 -0800 (PST)

: default-of  ( -- )
  postpone dup postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 of  ." two"  endof
  \     default-of  ." other"  endof
  \   endcase  ;

( or-of )

  \ Credits:
  \
  \ Code from Galope.

: (or-of)  ( x1 x2 x3 -- x1 x1 | x1 x1' )
  2>r dup dup dup r> = swap r> = or 0= if  invert  then  ;

: or-of  ( Compilation: -- of-sys )
         ( Run-time: x1 x2 x3 -- | x1 )
  postpone (or-of) postpone of  ; immediate compile-only

  \ Usage example:

  \ : test  ( x -- )
  \   case
  \     1 of  ." one"  endof
  \     2 3 or-of  ." two or three"  endof
  \     4 of  ." four"  endof
  \   endcase  ;

( select )

  \ XXX UNDER DEVELOPMENT

  \ XXX FIXME `when` causes
  \ #-22 control structure mismatch

  \ Credits:
  \
  \ Code adapted from Galope.
  \ Original code from:
  \ http://dxforth.netbay.com.au/miser.html

  \ Syntax

  \ select  ( x0 )
  \    cond  <tests>  when    ... else
  \          <test>   if drop ... else
  \    ...   ( default )
  \ endselect

  \ All clauses are optional.

  \ <tests> may consist of one or more of the following:

  \  x1    equal  ( test if x0 and x1 are equal )
  \  x1 x2 range  ( test if x0 is in the range x1..x2 )

  \ <test> can be any code that leaves x0 and a flag (0|<>0).
  \ 'if drop ... else' is for expansion, allowing user-defined
  \ tests.

  \ 'continue' may be placed anywhere within:

  \ when ... else
  \ if ( drop ) ... else

  \ 'continue' redirects program flow from previously matched
  \ clauses that would otherwise pass to 'endselect'. It
  \ provides "fall-through" capability akin to C's switch
  \ statement.

need -rot

0 constant select immediate
0 constant cond immediate

  \ XXX NOTE: A version of `thens` is in the kernel of
  \ DZX-Forth.

: thens  ( 0 a'1 ... a'n -- )
  begin  ?dup while  postpone then  repeat  ;
  \ Compile the pending `then`.

: endselect
  \ ( Compilation: 0 a'1 ... a'n -- ) ( Run-time: x0 -- )
  postpone drop  thens  ; immediate

: when
  \ ( Compilation: 0 orig1..orign -- )
  \ ( Run-time: xxx )
  postpone else  >r >r >r  thens  r> r> r>  postpone drop
  ; immediate
  \ XXX TODO stack

-->

( select )

: continue
  \ ( Compilation: xxx )
  \ ( Run-time: xxx )
  >r >r >r thens  0  r> r> r>  ; immediate
  \ XXX TODO stack

: equal
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 -- )
  postpone over  postpone -  postpone if  ; immediate

: (range)  ( x0 x1 x2 -- x0 wf )
  2>r dup 2r> over - -rot - u<  ;

: range
  \ ( Compilation: -- orig )
  \ ( Run-time: x0 x1 x2 -- x0 wf )
  postpone (range)  postpone if  ; immediate

( select-test )

  \ Usage example

: select-test ( n -- )
  space
  select
    cond  $00 $1F range
          $7F     equal  when  ." Control char "       else
    cond  $20 $2F range
          $3A $40 range
          $5B $60 range
          $7B $7E range  when  ." Punctuation "        else
    cond  $30 $39 range  when  ." Digit "              else
    cond  $41 $5A range  when  ." Upper case letter "  else
    cond  $61 $7A range  when  ." Lower case letter "  else
    ." Not a character "
  endselect  ;  -->

( select-test )

cr cr .( Running 'select' test...)

cr  char a  .(   ) dup emit  select-test
cr  char ,  .(   ) dup emit  select-test
cr  char 8  .(   ) dup emit  select-test
cr  char ?  .(   ) dup emit  select-test
cr  char K  .(   ) dup emit  select-test
cr  0              dup 3 .r  select-test
cr  127            dup 3 .r  select-test
cr  128            dup 3 .r  select-test

( create: )

: create:  ( "name" -- )  create hide ]  ;
  \ Create a word that will return the address of its pfa.

  \ Credits:
  \
  \ The idea for this word was borrowed from CP/M-volksForth
  \ 3.80a.

( positional-case: )

  \ Credits:
  \
  \ Code adapted from F83's `case:`.

need create:

: positional-case:  ( "name" -- )
  create:
  does>   ( n -- )
          \ Execute the n-th word compiled.
          ( n pfa ) swap cells + perform  ;
  \ Create a positional case word "name"
  \ At runtime, the n-th word is
  \ executed, depending upon the value on the stack. No
  \ range checking.

  \ Usage example:
  \
  \ ----
  \ : say0 ." nul"  ;
  \ : say1 ." unu"  ;
  \ : say2 ." du"  ;

  \ positional-case: say  ( n -- )  say0 say1 say2  ;

  \ 0 say cr 1 say cr 2 say cr
  \ ----

( associative-case: )

  \ Credits:
  \
  \ Code adapted from Pygmy Forth's `case:`

need create:

: associative-case: ( "name" -- )
  create:
  does> ( n -- ) ( n pfa ) cell+  \ move past `lit`
  begin   2dup @ dup 0= >r  ( n a n n')
          =  r> or  0= ( n a f )
  while   ( n a )  [ 3 cells ] literal +  \ no match
  repeat  nip cell+ perform  ;

  \ doc{

  \ associative-case: ( "name" -- )
  \
  \ Create an associative case definition "name":
  \ `name  ( i*x n -- j*x )`.

  \ Usage example:

  \ ----
  \ : red       ." red"  ;
  \ : blue      ." blue"  ;
  \ : orange    ." orange"  ;
  \ : pink      ." pink"  ;
  \ : black     ." black"  ;
  \
  \ associative-case: color  ( n -- )
  \   7 red  12 blue  472 orange  15 pink  0 black  ;
  \
  \ 7 color cr  472 color cr  3000 color cr
  \ ----

  \ _n_ for default must be 0 and the default pair must be
  \ last.  Numbers can be in any order except 0 must be last.
  \ An actual zero or a no match causes the default to be
  \ executed.  Numbers can't be constants.

  \ }doc

( cases: )

  \ `cases:` structure, alternative to the standard `case`.
  \ It saves space, but is slower.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted, renamed and commented from code written by Dan
  \ Lerner, published on Forth Dimensions (volume 3, number 6,
  \ page 189, 1982-03).

  \ 109 bytes used

: cases:  ( "name" -- orig 0 )
  create >mark 0
  does>  ( selector -- ) ( selector pfa )
    true rot rot dup  ( true selector pfa pfa )
    cell+ swap @   ( true selector pfa+2 options )
    0 do  ( true selector a )
      2dup @ =  ( true selector a f )
      if    dup cell+ perform
            2>r 0= 2r>  ( false selector a )  leave
      else  cell+ cell+  then
   loop  ( true selector a | false selector a )
   rot if  perform  else  drop  then  drop  ;

  \ doc{
  \
  \ cases:  ( "name" -- orig 0 )
  \
  \ Define a `cases:` structure "name", built as an array of
  \ pairs (value and associated vector).
  \

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ cases: say  ( n -- )
  \     10 case>  say10
  \    100 case>  say100
  \   1000 case>  say1000
  \        other> say-other
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: case>  ( orig counter selector "name" -- orig counter' )
  , ' compile, 1+  ;

  \ doc{
  \
  \ case>  ( orig counter selector "name" -- orig counter' )
  \
  \ Compile an option into a `cases:` structure. The given
  \ _selector_ will cause the word "name" to be executed.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

: other>  ( orig counter "name" -- )  ' compile, swap !  ;

  \ XXX TODO -- rename? `anycase>`, `othercase>`...

  \ doc{
  \
  \ other>  ( orig counter "name" -- )
  \
  \ Compile the default option of a `cases:` to be the word
  \ "name" . This must be the last option of the structure and
  \ is mandatory.  When no default action is required, `other>
  \ noop` can be used.
  \
  \ See `cases:` for an usage example.
  \
  \ }doc

( options[ )

  \ Credits:
  \
  \ `options[` is a port of IsForth's `case:`.

  \ Note: in the original IsForth code the word `(options`)
  \ (called `docase` in IsForth) is written in x86 assembler. I
  \ rewrote it from scratch, without investigating the
  \ assembler code.

  \ XXX TODO -- alternative version `coptions[`

  \ 166 bytes used.

variable (default-option)
  \ default option xt

variable #options
  \ number of compiled options

: default-option ( "name" -- )  ' (default-option) !  ;
  \ Set the default option.
  \ It can go anywhere inside a the options statement.

: (options)  ( i*x x -- j*x )

  \ x = option to search for

  false swap  ( false x ) \ default flag returned by the loop
  r> dup @ >r   \ set the new exit point
  cell+ dup >r  \ save the address of the default option xt
  dup cell+ @  ( false x a n )
  \ a = address of the first compiled option minus two cells
  \ n = number of compiled options

  0 do
    [ 2 cells ] literal + 2dup @ =  ( false x a' f )  \ match?
    \ a' = address of the current compiled option
    if  nip nip cell+ perform  true 0 0  leave then
  loop  ( f x1 x2 )  2drop

  if    rdrop       \ match, so discard the default option
  else  r> perform  \ no match, so execute the default option
  then  ;   -->

( options[ )

: options[  ( -- a1 a2 a3 )

  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options

  (default-option) off        \ assume no default option
  #options off                \ number of options is 0 so far
  compile (options)           \ compile run time handler
  >mark >mark >mark  ( a1 a2 a3 )
  postpone [  ; immediate compile-only

  \ doc{
  \
  \ options[  ( -- )
  \
  \ Start an `options[` structure.

  \ Usage example:
  \
  \ ----
  \ : say10     ." dek"  ;
  \ : say100    ." cent" ;
  \ : say1000   ." mil"  ;
  \ : say-other  ." alia" ;
  \
  \ : say  ( n )
  \   options[
  \     10 option  say10
  \    100 option  say100
  \   1000 option  say1000
  \        default-option say-other
  \   ]options  ;
  \
  \ 10 say  100 say  1000 say  1001 say
  \ ----
  \
  \ }doc

: option  ( x "name" -- )
  \ Compile an option _x_ and the xt of its action "name".
  ,  ' ,  1 #options +!  ;

: ]options  ( a1 a2 a3 -- )
  \ a1 = address of exit point
  \ a2 = address of default option xt
  \ a3 = address of number of options
  #options @ swap !           \ store number of options
  (default-option) @ swap !   \ store default option xt
  >resolve                    \ store exit point
  ]  ;

( executions )

  \ Credits:
  \
  \ Code from Galope (module times.fs).

: executions  ( xt n -- )
  \ Execute _xt_ _n_ times.
  2>r
  begin   2r@
  while   2r> 1- 2>r execute
  repeat  drop 2rdrop  ;

( {if if} if> |if| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming". Originally published
  \ on Forth Dimensions (volume 18, number 4, pp 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-roll

: {if  ( -- 0 )  0  ; immediate compile-only
  \ start a conditional
  \ put counter on stack

: if>
  \ ( count -- count+1 )
  \ ( c: -- orig1 )
  1+ >r postpone if  r> ; immediate compile-only
  \ right-arrow for {if ... if}

: |if|
  \ ( count -- count )
  \ ( c: orig ... orig1 -- orig ... orig2 )
  >r postpone ahead \ new orig
  1 cs-roll postpone then \ resolve old orig
  r>  ; immediate compile-only
  \ bar for {if ... if}

: if} \ end of conditional
  \ ( count -- )
  \ ( c: orig1 ... orign -- )
  >r  postpone ahead
  1 cs-roll postpone then \ resolve old orig
  -22 postpone literal postpone throw
    \ 'control structure mismatch'
  r> 0 ?do  postpone then  loop  ; immediate compile-only
  \ end a conditional

( {do do} do> |do| )

  \ Dijkstra Guarded Command Control Structures

  \ Credits:
  \
  \ Adapted from: Dijkstra Guarded Command Control Structures
  \ M. Edward Borasky, 1996-08-03. Listing in "Towards a
  \ Discipline of ANS Forth Programming" Originally published
  \ on Forth Dimensions (number 18, number 4, pages 5-14).
  \ Adapted to hForth v0.9.9 by Wonyong Koh

need cs-pick  need cs-roll

: {do  ( c: -- dest )  postpone begin  ; immediate compile-only
  \ start a loop

: do>  ( c: dest -- orig1 dest )
  postpone if  1 cs-roll  ; immediate compile-only
  \ right arrow for {do ... od}

: |do|  ( c: orig1 dest -- dest )
  0 cs-pick postpone again \ resolve a copy of dest
  1 cs-roll postpone then \ resolve old orig
  ; immediate compile-only
  \ bar for {do ... do}

: do}  ( c: orig dest -- )
  \ end of loop
  postpone again \ resolve dest
  postpone then \ resolve orig
  ; immediate compile-only
  \ end a loop

  \ }}} =======================================================
  \ Keyboard {{{

( capslock )  \ ==keyboard==

need os-flags2
need c!toggle-bits  need c@test-bits
need c!reset-bits   need c!reset-bits

%1000 os-flags2 2constant capslock
  \ Bit and system variable that control the capslock.

: toggle-capslock  ( -- )    capslock c!toggle-bits  ;
: set-capslock     ( -- )    capslock c!set-bits  ;
: unset-capslock   ( -- )    capslock c!reset-bits  ;
: capslock?        ( -- f )  capslock c@test-bits 0<>  ;

( at-accept clear-accept set-accept )

  \ XXX UNDER DEVELOPMENT
  \ Common code for several versions of `accept`
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

2variable accept-xy       \ coordinates of the edited string
  \ doc{
  \
  \ accept-xy  ( -- a )
  \
  \ A double variable that holds the cursor position at the
  \ start of the most recent `accept`.
  \
  \ }doc

variable accept-buffer    \ address of the edited string
  \ doc{
  \
  \ accept-buffer  ( -- a )
  \
  \ A variable that holds the buffer address used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable /accept          \ max length of the edited string
  \ doc{
  \
  \ /accept  ( -- a )
  \
  \ A variable that holds the buffer max length used by
  \ the latest execution of `accept`.
  \
  \ }doc

variable >accept          \ offset to the cursor position
  \ doc{
  \
  \ >accept  ( -- a )
  \
  \ A variable that holds the offset of the cursor in the
  \ string being edited by `accept`.
  \
  \ }doc

: at-accept  ( -- )  accept-xy 2@ at-xy  ;
  \ doc{
  \
  \ at-accept  ( -- )
  \
  \ Set the cursor position at the start of the most recent
  \ `accept`.
  \
  \ }doc

: clear-accept  ( -- )
  at-accept span @ spaces at-accept  span off  ;
  \ doc{
  \
  \ clear-accept ( -- )
  \
  \ Clear the string currently edited by `accept`.
  \
  \ }doc

: set-accept  ( ca1 len1 -- ca1' )
  clear-accept /accept @ min  ( ca1 len1' )
  dup span ! 2dup names-bank type default-bank
  dup >r
  accept-buffer @  ( ca1 len1' ca2 )
  smove accept-buffer @  ( ca2 )
  r> +  ( ca1' )  ;
  \ doc{
  \
  \ set-accept  ( ca1 len1 -- ca1' )
  \
  \ Set string _ca len_ as the string being edited by `accept`.
  \ Return the address _ca1'_ after its last character.
  \
  \ }doc

( acceptx )

  \ XXX UNDER DEVELOPMENT
  \
  \ Alternative version of `accept` with more editing features
  \
  \ 2016-03-13: copied from the kernel, in
  \ order to make it optional in the future.

need at-accept  need set-accept

: .acceptx  ( -- )

  accept-buffer @ >accept @ at-accept type
    \ Print the start of the string, before the cursor.

  1 inverse  >accept @ span @ <
  if accept-buffer @ >accept @ + c@ emit  else  space  then
  0 inverse
    \ Print the cursor.

  accept-buffer @ span @ >accept @ 1+ min /string type
    \ Print the end of the string, after the cursor.
  ;

-->

( acceptx )

need toggle-capslock

: accept-edit  ( -- )  clear-accept init-accept  ;
: accept-left  ( -- )  ;
: accept-right  ( -- )  ;
: accept-up  ( -- )  ;
: accept-down  ( -- )  ;
: accept-delete  ( -- )  ;

create accept-commands ] noop noop noop noop noop noop
toogle-capslock accept-edit accept-left accept-right
accept-down accept-up accept-delete noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop [

: >accept-command  ( c -- a )  cells accept-commands +  ;
: accept-command  ( c -- )  >accept-command perform  ;

-->

( acceptx )

: init-acceptx  ( ca len -- )
  /accept !  accept-buffer !  >accept off  xy accept-xy 2!  ;

: (acceptx) ( ca len -- len' )  2dup init-accept

  over + over ( bot eot cur )
  begin  key dup 13 <> \ not carriage return?
  while
    dup 12 =  \ delete?
    if    drop  >r over r@ < dup  \ any chars?
          if  8 dup emit  bl emit  emit  then  r> +
    else  \ printable
          >r  2dup <>  \ more?
          if r@ over c!  char+  r@ emit
          then r> drop
    then
  repeat  drop nip swap -  ;  -->

( acceptx )

: acceptx ( ca len -- len' )
  span off  ?dup 0= if  drop 0  else  (acceptx)  then  ;


  \ XXX TMP -- for debugging

: ax  ( -- )  ['] acceptx ['] accept defer!  ;
: a0  ( -- )  ['] default-accept ['] accept defer!  ;

( inkey )

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed, leave 0.
  \
  \ This word works only when an interrupts routine reads the
  \ keyboard and updates the related system variables.

  \ XXX FIXME -- Some times this word returns zero when the key
  \ is pressed; the version on the previous block works fine.
  \ Anyway this version is smaller and can be useful.

  a xor
  01 iy 5 bitx  \ a new key pressed?
  nz if
    5C08 hl ldp#  \ LAST-K system variable
    m a ld
    \ 0 m ld# \ XXX OLD
    01 iy 5 resx
  then
  pusha jp

  end-code

( nuf? )

  \ Credits:
  \
  \ Code adapted from lpForth and Forth Dimensions (volume 10,
  \ number 1, page 29, 1988-05).

need aborted?

[defined] 'cr' ?\ 13 constant 'cr' \ code of carriage return

: nuf?  ( -- f )  'cr' aborted?  ;

  \ XXX OLD -- Classic definition:
  \
  \ : nuf?  ( -- f )  key? dup if  key 2drop key 'cr' = then  ;

  \ doc{
  \
  \ nuf?  ( -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's a carriage return, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla " nuf?  until  ." Aborted"  ;
  \
  \ }doc

( aborted? )

: aborted?  ( c -- f )
  key? dup  if    key 2drop key =
            else  nip  then  ;

  \ doc{
  \
  \ aborted?  ( c -- f )
  \
  \ If no key is pressed return _false_.  If a key is pressed,
  \ discard it and wait for a second key. Then return _true_ if
  \ it's _c_, else return _false_.

  \ Usage example:
  \
  \ : listing  ( -- )
  \   begin  ." bla "  bl aborted?  until  ." Aborted"  ;
  \
  \ }doc


( break? )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO try

: break?  ( -- f )
  key? dup if  key 2drop break-key?  then  ;

( inkey )

  \ Credits:
  \
  \ Code adapted and modified from Abersoft Forth's `inkey`.

need z80-asm

code inkey  ( -- c | 0 )

  \ Leave the value of the key being pressed. If no key being
  \ pressed leave zero.
  \
  \ This word reads the keyboard, so it works even when the
  \ keyboard is not read by an interrupts routine.

  bc push
  028E call \ KEY-SCAN ROM routine
  \ 1 or 2 keys in DE, most significant shift first if any
  \ key values 0..39 else 255
  z if  \ is key press valid?
    031E call \ KEY-TEST ROM routine
    cy if  \ is key code valid?
      \ A = main key
      \ D = ?
      00 c ld#  \ XXX Spectrum Forth-83 does this
      d dec  a e ld
      0333 call \ KEY-DECODE ROM routine
      \ A = key code
    then
  then
  FF cp#  z if  a xor  then  \ convert FF to 00
  \ XXX TODO jump to `key` to decode
  bc pop  pusha jp  end-code

( key?? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Variant with relative jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  here jrnz  >relmark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  here jrnc  >relmark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true >code jp

  \ return_false:
  0 unresolved @ >relresolve
  1 unresolved @ >relresolve
  bc pop  ' false >code jp

  end-code

( key?? )

  \ An alternative to `key?`. It works also when the system
  \ interrupts are off. Faster variant with absolute jumps.

need z80-asm

code key??  ( -- f )

  bc push
  028E call  \ ROM KEY_SCAN
  0000 jpnz  |mark 0 unresolved ! \ to return_false
  031E call  \ ROM KEY_TEST
  0000 jpnc  |mark 1 unresolved ! \ to return_false

  \ return_true:
  bc pop  ' true >code jp

  \ return_false:
  0 unresolved @ >resolve
  1 unresolved @ >resolve
  bc pop  ' false >code jp

  end-code

( y/n? y/n yes? no? )

  \ Credits:
  \
  \ Code adapted from Afera.

need value

char Y value "y"  char N value "n"
  \ Default (uppercase) letters for "yes" and "no".

: y/n?  ( c -- f )  dup "y" = swap "n" = or  ;
  \ Is the given (uppercase) char _c_
  \ a valid answer for a "y/n" question?

: y/n  ( -- c )
  begin  key upper dup y/n? 0=  while  drop  repeat  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return its code.

: no?  ( -- f )  y/n "n" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "no",
  \ else return _false_.

: yes?  ( -- f )  y/n "y" =  ;
  \ Wait for a valid key press for a "y/n" question
  \ and return _true_ if it's the current letter for "yes",
  \ else return _false_.

( Keyboard rows ports)

  \ Adapted from Afera.
  \ XXX UNDER DEVELOPMENT

  \ -----------------------------------------------------------
  \ Description

  \ Some tools to manage key presses. An improved and detailed
  \ implementation can be found in the Tron 0xF game
  \ (http://programandala.net/en.program.tron_0xf.html).
  \
  \ "kk" stands for "keyboard key". This notation was chosen
  \ first in order to prevent future name clashes with standard
  \ words which uses the "k-" prefix, and second because these
  \ words manage only physical keys of the keyboard, not key
  \ combinations.
  \
  \ -----------------------------------------------------------


( kk-ports kk, kk@ )

  \ There are two versions of `kk,` and `kk@`. They depend on the
  \ value of `/kk`, a constant that holds the bytes ocuppied by
  \ every key in `kk-ports`, 3 or 4.
  \
  \ The application must define `/kk` before loading this
  \ block.

  \ ............................................
  \ Method 1: smaller but slower

  \ Every key identifier occupies 3 bytes in the table (total
  \ size is 120 bytes)

/kk 3 <> dup

?\ : kk,  ( bitmask port -- ) , c,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port ) dup c@ swap 1+ @ ;
  \ Fech a key definition from an element of the keys table.

  \ XXX TODO wrote `kk@` in Z80.

  \ ............................................
  \ Method 2: bigger but faster

  \ Every key identifier occupies 4 bytes in the table (total
  \ size is 160 bytes)

/kk 4 <> dup

?\ : kk,  ( d -- )  2,  ;
  \ Store a key definition into the keys table.

?\ : kk@  ( a -- bitmask port )  2@  ;
  \ Fech a key definition from an element of the keys table.

-->

( kk-ports )

  \ Key constants are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant kk-1  $02 $F7FE 2constant kk-2
$04 $F7FE 2constant kk-3  $08 $F7FE 2constant kk-4
$10 $F7FE 2constant kk-5

$01 $FBFE 2constant kk-q  $02 $FBFE 2constant kk-w
$04 $FBFE 2constant kk-e  $08 $FBFE 2constant kk-r
$10 $FBFE 2constant kk-t

$01 $FDFE 2constant kk-a  $02 $FDFE 2constant kk-s
$04 $FDFE 2constant kk-d  $08 $FDFE 2constant kk-f
$10 $FDFE 2constant kk-g

$01 $FDFE 2constant kk-cs  $02 $FDFE 2constant kk-z
$04 $FDFE 2constant kk-x   $08 $FDFE 2constant kk-c
$10 $FDFE 2constant kk-v

-->

( kk-ports )

$01 $EFFE 2constant kk-0  $02 $EFFE 2constant kk-9
$04 $EFFE 2constant kk-8  $08 $EFFE 2constant kk-7
$10 $EFFE 2constant kk-6

$01 $DFFE 2constant kk-p  $02 $DFFE 2constant kk-o
$04 $DFFE 2constant kk-i  $08 $DFFE 2constant kk-u
$10 $DFFE 2constant kk-y

$01 $BFFE 2constant kk-en  $02 $BFFE 2constant kk-l
$04 $BFFE 2constant kk-k   $08 $BFFE 2constant kk-j
$10 $BFFE 2constant kk-h

$01 $7FFE 2constant kk-sp $02 $7FFE 2constant kk-ss
$04 $7FFE 2constant kk-m  $08 $7FFE 2constant kk-n
$10 $7FFE 2constant kk-b

-->

( kk-ports )

  \ This table contains the key double constants (port and
  \ bitmak) of all keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

need kk,

40 constant keys

create kk-ports

kk-1  kk,  kk-2  kk,  kk-3 kk,  kk-4 kk,  kk-5 kk,
kk-q  kk,  kk-w  kk,  kk-e kk,  kk-r kk,  kk-t kk,
kk-a  kk,  kk-s  kk,  kk-d kk,  kk-f kk,  kk-g kk,
kk-cs kk,  kk-z  kk,  kk-x kk,  kk-c kk,  kk-v kk,
kk-0  kk,  kk-9  kk,  kk-8 kk,  kk-7 kk,  kk-6 kk,
kk-p  kk,  kk-o  kk,  kk-i kk,  kk-u kk,  kk-y kk,
kk-en kk,  kk-l  kk,  kk-k kk,  kk-j kk,  kk-h kk,
kk-sp kk,  kk-ss kk,  kk-m kk,  kk-n kk,  kk-b kk,

( kk-1# )

  \ Key number constants, to be used as indexes of the key
  \ tables.

need enum

0
enum kk-1#  enum kk-2#  enum kk-3# enum kk-4# enum kk-5#
enum kk-q#  enum kk-w#  enum kk-e# enum kk-r# enum kk-t#
enum kk-a#  enum kk-s#  enum kk-d# enum kk-f# enum kk-g#
enum kk-cs# enum kk-z#  enum kk-x# enum kk-c# enum kk-v#
enum kk-0#  enum kk-9#  enum kk-8# enum kk-7# enum kk-6#
enum kk-p#  enum kk-o#  enum kk-i# enum kk-u# enum kk-y#
enum kk-en# enum kk-l#  enum kk-k# enum kk-j# enum kk-h#
enum kk-sp# enum kk-ss# enum kk-m# enum kk-n# enum kk-b#
drop

( kk-chars )

  \ This table contains the chars used as names of the keys.

  \ This table contains 40 items, one per physical key, and
  \ it's organized by keyboard rows.

  \ By default, the first 4 UDG are used for keys whose names
  \ are not a printable char:
  \
  \ 128 = Caps Shift
  \ 129 = Enter
  \ 130 = Space
  \ 131 = Symbol Shift

create kk-chars

char 1 c,  char 2 c,  char 3 c,  char 4 c,  char 5 c,
char q c,  char w c,  char e c,  char r c,  char t c,
char a c,  char s c,  char d c,  char f c,  char g c,
128    c,  char z c,  char x c,  char c c,  char v c,
char 0 c,  char 9 c,  char 8 c,  char 7 c,  char 6 c,
char p c,  char o c,  char i c,  char u c,  char y c,
129    c,  char l c,  char k c,  char j c,  char h c,
130    c,  131    c,  char m c,  char n c,  char b c,

( pressed pressed? )

need [if]

[needed] pressed? [needed] pressed or [if]

need @p

: pressed? ( n1 n2 -- f )  @p and 0=  ;
  \ Is a key pressed?
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

[needed] pressed [if]

need pressed?  need kk-ports

: pressed  ( -- false | n1 n2 true )
  0 \ false by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed? if  drop i kk@ 1 leave  then  /kk +loop  ;
  \ Return the key identifier of the first key
  \ from the keys table that happens to be pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

[then]

( only-one-pressed )

  \ XXX UNDER DEVELOPMENT

  \ The application must define the `/k` constant.

need kk-ports

0. 2variable kk-pressed

: only-one-pressed  ( -- false | n1 n2 true )

  \ XXX TODO finish

  0. kk-pressed 2! \ none by default
  [ kk-ports keys /kk * bounds swap ] literal literal
  do  i kk@ pressed?
  if  kk-pressed 2@ + if
  then
  /kk +loop
  kk-pressed 2@ 2dup + if  1  else  2drop 0  then  ;

  \ Return the key identifier of the key pressed,
  \ if there's only one key pressed.
  \ n1 = key bitmask
  \ n2 = keyboard row port

  \ }}} =======================================================
  \ Hardware {{{

( @p )  \ ==hardware==

code @p  ( ca -- c )

  \ Input char _c_ from port _ca_.

  E1 c,           \ pop hl
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 68 c,     \ in l,(c)
  C1 c,           \ pop bc
  26 c, 00 c,     \ ld h,0x00
  C3 c, pushhl ,  \ jp pushhl
  end-code

( !p )

code !p  ( c ca -- )

  \ Output char _c_ to port _ca_.

  E1 c,           \ pop hl
  D1 c,           \ pop de ; char in e
  C5 c,           \ push bc
  48 05 + c,      \ ld c,l
  40 04 + c,      \ ld b,h
  ED c, 59 c,     \ out (c),e
  C1 c,           \ pop bc
  jpnext          \ jp (ix)

  end-code

  \ }}} =======================================================
  \ Number conversion and notation {{{

( b# d# h# )  ==numberconversion==

  \ Credits:
  \
  \ Code adapted from eForth.

  \ XXX TODO -- finish the conversion
  \
  \ XXX TODO -- there's an alternative in Forth Dimensions 20-3
  \ p. 27, by Wil Baden.

: x# ( -- ) ( "ccc" -- n | d )
  does> c@              \ new radix
  base @ >r  base !     \ save and set radix
  parse-name            \ get string
  ['] evaluate catch    \ convert to number, set trap
  r> base !  throw  ;   \ restore radix before error control

create b# ( "name" -- n | d )  2 c, x# immediate
create d# ( "name" -- n | d ) 10 c, x# immediate
create h# ( "name" -- n | d ) 16 c, x# immediate

( c# )

  \ Credits:
  \
  \ Code inspired by eForth.

: c#  ( "name" -- c )
  parse-name drop c@
  compiling? if  postpone literal  then  ; immediate
  \ Parse a name and return the code of the its first
  \ character. This is an alternative to `char` and `[char]`.

  \ }}} =======================================================
  \ Data structures {{{

( associative: )  \ ==datastructures==

  \ Credits:
  \
  \ Code adapted from F83.

need -rot

: associative:  ( n -- )
  \ Create a table lookup word.
  \ n = number of entries in the table
  constant
  does>  ( x -- index )
    ( x pfa )
    dup @ ( x pfa n ) -rot dup @ 0 ( n x pfa n 0 )
    do ( n x pfa )
      cell+ 2dup @ = ( n x pfa' flag )
      if  2drop drop i unloop exit  then
    loop 2drop ( n )  ;
  \ An associative memory word.  It must be followed by a set
  \ of values to be looked up.  At runtime, the values stored
  \ in the parameter field are searched for a match.  If one if
  \ found, the index to that value is returned.  If no match is
  \ made, then the number of entries, ie max index + 1 is
  \ returned.  This is the inverse of an array.

  \ Usage example:

  \ ----
  \
  \ 1000 constant zx1  200 constant zx2  30 constant zx3
  \
  \ 3 associative: unzx  ( value -- n )  zx1 , zx2 , zx3 ,
  \
  \ 1000 unzx .  \ prints 0
  \ 200 unzx .   \ prints 1
  \ 30 unzx .    \ prints 2
  \ ----

( associative-list )

  \ Credits:
  \
  \ Based on code written by Wil Baden, published on: Forth
  \ Dimensions (volume 17, number 4, page 11, 1995-11).

  \ XXX UNDER DEVELOPMENT

need words  need abort"

: associative-list  ( "name" -- )  wordlist constant  ;

: entry  ( ca len wid "name" -- )
  current @ >r current !  create  s,  r> current !
  does>  ( -- ca len )  ( pfa ) count  ;

: item?  ( ca len -- 0 | xt )
  search-wordlist dup if  drop  then  ;

: item  ( ca1 len1 wid -- ca2 len2 )
  item? dup 0= abort" Not an item." execute  ;

: items  ( wid -- )  >order words previous  ;

( begin-structure +field field: 2field: cfield: )

  \ Forth-2012.

: begin-structure  ( "name" -- struct-sys 0 )
  create  >mark 0
  does>   ( -- n )  ( pfa ) @   ;

: +field  ( n1 n2 "name" -- n3 )
  create  over , +
  does>   ( a -- a' )  ( a pfa ) @ +  ;

: field:    ( n1 "name" -- n2 )  cell +field  ;
: 2field:   ( n1 "name" -- n2 )  [ 2 cells ] literal +field  ;
: cfield:   ( n1 "name" -- n2 )  [ 1 chars ] literal +field  ;

: end-structure  ( struct-sys n -- )  swap !  ;

( buffer: cvariable enum )

[unneeded] buffer:
?\ : buffer:  ( u "name" -- )  create allot  ;

[unneeded] cvariable
?\ : cvariable  ( "name"  -- )  create 1 allot  ;

[unneeded] enum
?\ : enum  (  n "name" -- n+1 )  dup constant 1+  ;

( value to )

  \ Origin: Forth-94.

: value  ( n "name"  -- )  constant  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone !
                     else  !  then  ; immediate

( 2value 2to )

  \ Implementation of `2value` (from Forth-2012) but with
  \ the non-standard word `2to`

: 2value  ( d "name"  -- )  2constant  ;

: 2to  ( Interpretation: d "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone 2!
                     else  2!  then  ; immediate

( cvalue cto )

: cvalue  ( b "name"  -- )  cconstant  ;

: cto  ( Interpretation: b "name" -- )
       ( Compilation: "name" -- )
  ' >body compiling? if    postpone literal postpone c!
                       else  c!  then  ; immediate

( value 2value to )

  \ Origin: Forth-2012.

  \ This Forth-2012 implementation of `to` is provided as an
  \ alternative, but it's bigger and slower than the Forth-94
  \ `to` and the non-standard `2to`.

: value  ( n "name"  -- )  create  0 c, ,  does> 1+ @  ;
: 2value  ( n "name"  -- )  create  1 c, , ,  does> 1+ 2@  ;

: to  ( Interpretation: n "name" -- )
      ( Compilation: "name" -- )
  ' >body dup 1+ swap c@
  compiling? if  swap postpone literal
                 if  postpone 2!  else  postpone !  then  exit
             then
  if  2!  else  !  then
  ; immediate

( value to )

  \ Non-standard implementation of `value` with non-parsing
  \ `to`. This could be useful in special cases.

  \ Credits:
  \
  \ Code inspired by lina.

variable (value)  ['] @ (value) !
: to    ( -- )  ['] ! (value) !  ;
: value  ( n "name" -- )
  create ,  does>   (value) perform  ['] @ (value) !  ;

( set )

: set  ( x a "name" -- )
  create  swap , ,
  does>   ( pfa )  dup @ swap cell+ @ !  ;

  \ doc{
  \
  \ set  ( x a "name" -- )
  \
  \ Define a word "name" which, when executed, will  cause  the
  \ value _x_  to be stored at _a_.
  \
  \ Origin: Forth-79 (Reference Word Set); Forth-83 (Appendix
  \ B.  Uncontrolled Reference Words).
  \
  \ }doc

( link@ link, )

  \ 2015-11-15

  \ Credits:
  \
  \ Code written after the description by Rick VanNorman,
  \ published on Forth Dimensions (volume 20, number 3, pages
  \ 19-22, 1998-09).

defer link@  ( node1 -- node2 )
  ' @ ' link@ defer!
  \ Fetch the linked list node _node_ is pointing to.

: link,  ( node -- )  here over @ , swap !  ;
  \ Create a new linked list node, pointing to _node_.

( [switch switch] )

  \ 2015-11-15

  \ Credits:
  \
  \ Original code by Rick VanNorman, published on Forth
  \ Dimensions (volume 20, number 3, pages 19..22, 1998-09).

need link@  need link,

: switcher  ( i*x n head -- j*x )
  dup cell+ @ >r  \ save default xt
  begin  link@ ?dup while  ( n a )
    2dup cell+ @ = if   \ match
      nip cell+ cell+ perform  r> drop exit
    then
  repeat  r> execute  ;
  \ Search the linked list from its _head_ for a match to the
  \ value _n_. If a match is found, discard _n_ and execute the
  \ associated matched xt. If no match is found, leave _n_ on
  \ the stack and execute the default xt.

: :switch  ( xt "name" -- a )
  create  >mark swap ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Create a code switch whose default behaviour is given by
  \ _xt_. Leave the address of the head of its list on the
  \ stack.

: <switch  ( head xt n -- head )
  2 pick link,  , ,  ;
  \ Define a new clause to execute _xt_ when the key _n_
  \ is matched.

-->

( [switch switch] )

: [switch  ( "name1" "name2" -- head )
  create  >mark ' ,
  does>  ( n -- )  ( n pfa ) switcher  ;
  \ Define a new switch "name1" with its default behaviour
  \ "name2". The head of the switch is left on the stack for
  \ defining clauses.

: [+switch  ( "name" -- head )  ' >body  ;
  \ Leave the head of the given switch "name", for clauses to
  \ append to.

: switch]  ( head -- )  drop  ;
  \ Discard the switch head from the stack.
  \ Used after defining clauses.

: runs  ( head n "name" -- )  ' swap <switch  ;
  \ Associate the xt of "name" to clause _n_ of switch _head_.

exit

  \ XXX TODO -- `run:`

: run:  ( head n "text<;>" -- )
  :noname [char] ; parse evaluate postpone ; ( xt )
  swap >switch  ;

( [switch-test ) \ without syntactic sugar

: one    ( -- )  ." unu " ;
: two    ( -- )  ." du "  ;
: three  ( -- )  ." tri "  ;
: many   ( n -- )  . ." is too much! "  ;

' many :switch numbers
  \ `many` is the default behaviour of the new switch `numbers`

  ' one   1 <switch
  ' two   2 <switch
  ' three 3 <switch  drop

cr 1 numbers 2 numbers 3 numbers 4 numbers

' numbers >body  :noname  ." kvar "  ; 4 <switch drop
  \ add a new clause for the number 4

cr 1 numbers 2 numbers 3 numbers 4 numbers

-->

( [switch-test ) \ with syntactic sugar

[switch sugar-numbers many
  1 runs one
  2 runs two
  3 runs three
switch]

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

: four  ." kvar "  ;

[+switch sugar-numbers
  4 runs four
switch]
  \ add a new clause for the number 4

cr 1 sugar-numbers 2 sugar-numbers
   3 sugar-numbers 4 sugar-numbers

( switch )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-16: Start.

: n>code-string  ( n -- ca len )  2 pad ! pad 1+ ! pad   ;
  \ Convert _n_ to a code string of two bytes.

: switch:  ( "name" -- )  wordlist constant  ;
  \ Create a new switch "name".

: switch  ( n switch -- )
  swap n>code-string rot search-wordlist if  execute  then  ;
  \ Execute the switch _switch_ for the key _n_.

  \ XXX FIXME -- runtime: screen garbage and stack underflow!
: :clause  ( n switch -- )
  get-current >r set-current
  n>code-string next-name 2! :
  r> set-current  ;
  \ Start the definition of a switch clause _n_ for switch
  \ _switch_.

( user )

  \ XXX UNDER DEVELOPMENT -- improved version, which uses the
  \ first free offset.

  \ doc{
  \
  \ user  ( +n "name" -- )
  \
  \ Create a user variable _name_.  _+n_ is the offset within
  \ the user area where the value for _name_ is stored.
  \ Execution of _name_ leaves its absolute user area storage
  \ address.
  \
  \ Origin: Forth-79, Forth-83.
  \
  \ }doc

: user  ( n "name -- )
  create c,  does>  c@ up @ +  ;

exit

: user  ( n "name -- )
  cconstant
  ;code asm
  de incp  \ de=pfa
  exde
  m e ld
  00 d ld#  \ de = index of the user variable
  up fthl \ ld hl,(user_variables_pointer) \ XXX FIXME
  de addp  \ hl= address of the user variable
  pushhl jp end-asm

( 1array ) \ noble-arrays

  \ Toolset for one- and two-dimensional arrays by Julian V.
  \ Noble

  \ 2015-11-15

  \ ---------------------------------------------------
  \ (c) Copyright 2001 Julian V. Noble. \
  \ Permission is granted by the author to \
  \ use this software for any application pro- \
  \ vided this copyright notice is preserved. \
  \ ---------------------------------------------------

  \ ...........................................................
  \ References:
  \
  \ http://forth.sourceforge.net/techniques/arrays-jvn/index-v.txt
  \ http://forth.sourceforge.net/techniques/
  \ http://www.phys.virginia.edu/classes/551.jvn.fall01/arrays.f

  \ ...........................................................
  \ Description:

  \ Well, as I am sure everyone knows to the point of hurling
  \ (regurgitating) by now, I chose a format that looks
  \ somewhat like Fortran. I could not use the right
  \ parenthesis, ) , because it was taken as the closure for a
  \ parenthesized comment. Could not use the [ ]'s because they
  \ also have a definite meaning (turn compiler off and on by
  \ switching STATE).  So I was left with what I could do using
  \ curly braces { and }.

  \ Now why did I want an array notation that looks like
  \ Fortran? There were several reasons:

  \ 1. I wanted (at that time) to sell Forth to the Fortran
  \ community.  (Silly me! But I was young then.)

  \ 2. I wanted a notation that unequivocally said "I am an
  \ array!" I had already written a number of linear equations
  \ and other matrix ops programs and kept running into the
  \ problems of

  \  a. different constructors for each data type;
  \
  \  b. reading the program when it was done.

  \ 3. I wanted something that would be completely transparent,
  \ would permit address arithmetic, and would not require tons
  \ of comments to be maintainable.

  \ Eventually I hit on the Forthish solution of defining an
  \ array with a header that contained its size and its data
  \ size. Then I wrote a de-referencing operator that would dig
  \ into the header and calculate the address of the datum
  \ being indexed. The notation for this was

  \ v{ I } ( -- adr of v[I] )

  \ The left curly brace in an array's name was simply
  \ syntactic sugar.  But at some point I realized that by
  \ naming 2-dimensional arrays something like M{{ (2 curly
  \ braces) I could have the name say "I am a 2-dimensional
  \ array." Then one dereferences such by saying

  \ m{{ i j }}

  \ --that is, the 2-dim dereferencing operator expects a base
  \ address and two indices and produces the correct address of
  \ the I,Jth element.

  \ For those who want it, go to my home page (under
  \ construction) then to the link "Computational Methods in
  \ the Physical Sciences", and thence to "Forth system and
  \ example programs". There you can find the file arrays.f
  \ that does all of this stuff. I have bounds checking in that
  \ version because it was intended for student use.  Experts
  \ can delete that stuff.

  \ ...........................................................
  \ Implementation:

  \ words for 1-dimensional arrays

need <=

: long ; immediate

: 1array ( len #bytes/datum --) \ ( #b len data ...)
  create 2dup , , * allot ;

: _len ( base_addr -- len)  cell+ @ ;
  \ determine length of an array

: } ( base_adr indx -- adr[indx] )
  over _len over <= over 0< or #-272 ?throw
    \ #-272 = array index out of range
  over @ * + cell+ cell+ ;

( 2array ) \ noble-arrays

  \ words for 2-dimensional arrays

need 1array

: wide ; immediate

: 2array ( hgt wid data_size --) \ ( wid #b len data ...)
  create >r tuck , ( wid hgt)
  r@ , * dup , r> * allot ;

: }} ( base_adr m n -- adr[m,n] ) \ data stored row-wise
  2>r cell+ dup cell- @
  r> * r> + ( base_adr+cell m+n*w)
  } ;

  \ ...........................................................
  \ Usage examples:

  \ 20 long 2 floats 1array a{
  \   \ complex vector
  \
  \ 20 long 20 wide 1 floats 2array m{{
  \   \ real matrix
  \
  \ 20 long 1 cells 1array irow{
  \   \ single-length, integer-valued vector
  \
  \ m{{ i j }} ( -- adr[m_ij] )
  \   \ to dereference

( array ato ) \ wong-arrays )

  \ One-dimensional arrays by Leo Wong

  \ 2015-11-15

  \ ...........................................................
  \ References:

  \ http://forth.sourceforge.net/techniques/arrays-lw/index-v.txt
  \ http://forth.sourceforge.net/techniques/

  \ ...........................................................
  \ Description:

  \ This approach is unique in having no proponents. It is part
  \ of Flight, a Forth scripting language. Several Flight
  \ programs can be found by Googling comp.lang.forth. In
  \ conformance with the design goals of Flight, bounds
  \ checking is included.

  \ ...........................................................
  \ Main idea:

  \ Treat arrays like values.

    \ \ Example of use:
    \ 4 array bar
    \ 10 0 ato bar 20 1 ato bar 30 2 ato bar 40 3 ato bar

    \ 3 bar .
    \ 0 bar .
    \ 123 3 ato bar
    \ 3 bar .
    \ 1 3 +ato bar
    \ 3 bar .

  \ Note that as in most Forth numerical arguments go before:

    \ 1 3 +ato bar NOT: 1 +ato 3 bar

  \ This approach can be extended to different-sized data
  \ (including strings) and 2 or more dimensions by having
  \ their own versions of array array> ato +ato. A Flight
  \ scripter would not be expected to implement these words.

  \ ...........................................................
  \ Sample implementation:

need within

: array>  ( n 'array -- a )
  2dup @ 0 swap within 0= #-272 ?throw
    \ #-272 = array index out of range
  cell+ swap cells +  ;
  \ if in range, return element address, else abort

: array  ( n "name" -- )
  create dup , cells allot
  does> ( n -- x ) ( n pfa ) array> @  ;
  \ define array

: (ato)  ( x n array -- )  >body array> !  ;
  \ store to array

: ato  ( x n "name" -- )
  compiling?  if    postpone ['] postpone (ato)
              else  ' (ato)  then ; immediate
  \ store to array
  \ usage: x n ato <name>

: (+ato)  ( x n array -- )  >body array> +!  ;
  \ add to array

: +ato  ( n "name" -- )
  compiling? if    postpone ['] postpone (+ato)
             else  ' (+ato)  then  ; immediate
  \ add to array

( xstack )

  \ Credits:
  \
  \ Code adapted from Galope (xstack module).

  \ Creation and core manipulation of xstacks

need value  need allocate  need free

0 value xsize  0 value xp  0 value xp0
  \ Values of the current xstack:
  \ xsize = size in address units (constant)
  \ xp = address of the xstack pointer (variable)
  \ xp0 = initial value of the xstack pointer (constant)

: xstack  ( n "name" -- )
  \ Create a new xstack of _n_ cells.
  create  cells dup allocate throw  cell - dup
    , , ,
    \ +0 = xp0
    \ +2 = xp
    \ +4 = xsize
  does> ( -- )
    \ Make an xstack the current one.
    ( pfa ) dup @ to xp0  cell+ dup to xp  cell+ @ to xsize  ;

: xp@  ( -- a )  xp @  ;

: xp!  ( a -- )  xp !  ;

: xp+!  ( n -- )  xp +!  ;

: xclear  ( -- )  xp0 xp!  ;

: xfree  ( -- )  xp0 free throw  ;

( >x x@ xdrop x> xdup xpick )

  \ xstack single-number operations

need xstack

: >x  ( x -- ) ( X: -- x )  cell xp+!  xp@ !   ;

: x@  ( -- x ) ( X: x -- x )  xp@ @  ;

: xdrop  ( X: x -- )  [ cell negate ] literal xp+!  ;

: x>  ( -- x ) ( X: x -- )  x@ xdrop  ;

: xdup  ( X: x -- x x )  x@ >x  ;

: xpick  ( n -- x'n ) ( X: x'n ... x'0 -- x'n ... x'0 )
  xp@ swap cells - @  ;

: xover  ( X: x1 x2 -- x1 x2 x1 )  1 xpick >x  ;

( 2x@ 2>x 2x> 2xdrop 2xdup )

  \ xstack double-number operations

need xstack  need x@  need >x  need xpick  need xover

: 2x@  ( -- x1 x2 ) ( X: x1 x2 -- x1 x2 )  x@ 1 xpick swap  ;

: 2>x  ( x1 x2 -- ) ( X: -- x1 x2 )  swap >x >x  ;

: 2x>  ( -- x1 x2 ) ( X: x1 x2 -- )  x> x> swap  ;

: 2xdrop  ( X: x1 x2 -- )  [ -2 cells ] literal xp+!  ;

: 2xdup  ( X: x1 x2 -- x1 x2 x1 x2 )  xover xover  ;

( xdepth .x )

  \ xstack tools

need xstack

: xlen  ( -- n )  xp@ xp0 -  ;
  \ Length of the current xstack, in address units.

: xdepth  ( -- n )  xlen cell /  ;
  \ Depth of the current xstack.

: xdepth.  ( -- )  ." <"  s>d <# #s #> type  ." > "  ;

: (.x)  ( -- )  xp0 cell+ xlen bounds ?do  i @ . cell +loop  ;
  \ Display a list of the items in the xstack; TOS is the right-most item.
: .x  ( -- )  xdepth dup xdepth. if  (.x)  then  ;
  \ Display the number of items on the current xstack,
  \ followed by a list of the items, if any; TOS is the right-most item.

  \ }}} =======================================================
  \ Environmental queries {{{

( environment? )

need wid-of

vocabulary environment ( -- )
wid-of environment constant environment-wordlist ( -- wid )
  \ Wordlist that is searched by environmental queries.

: environment? ( ca len -- false | i*x true )
  environment-wordlist search-wordlist
  if  execute true  else  false  then  ;

also environment definitions

8 constant address-unit-bits ( -- n )
  \ Size of one address unit, in bits.

255 constant max-char ( -- u )
  \ Maximum value of any character in the character set.

255 constant /counted-string ( -- n )
  \ Maximum size of a counted string, in characters.

  \ XXX TODO
address-unit-bits cells 2* 2+ constant /hold ( -- n )
  \ Size of the pictured numeric string output buffer, in
  \ characters.

  \ XXX TODO calculate
84 constant /pad ( -- n )
  \ Size of the scratch area pointed to by `pad`, in
  \ characters.

1 -3 mod 0< constant floored ( -- f )
  \ True if `/` etc. perform floored division

-->

( environment? )

32767 constant max-n ( -- n )
  \ Largest usable signed integer.

-1 constant max-u ( -- u )
  \ Largest usable unsigned integer.

-1 max-n 2constant max-d ( -- d )
  \ Largest usable signed double.

-1. 2constant max-ud ( -- ud )
  \ Largest usable unsigned double.

  \ XXX TODO -- calculate
$50 constant return-stack-cells ( -- n )
  \ : return-stack-cells ( -- n )
    \ [ forthstart 6 cells + ] literal @ cell / ;
    \ Maximum size of the return stack, in cells.

  \ XXX TODO -- calculate
$50 constant stack-cells ( -- n )
  \ : stack-cells ( -- n )
    \ [ forthstart 4 cells + ] literal @ cell / ;
    \ Maximum size of the data stack, in cells.

  \ XXX TODO -- add "#locals" when needed

forth definitions  previous

  \ }}} =======================================================
  \ Multitask {{{

( jiffy! jiffy@ -jiffy )

  \ Note: This code is specific for G+DOS.

  \ Credits:
  \
  \ Idea inspired by an article by Paul King, published on
  \ Format (volume 2, number 3, 1988-10).
  \
  \ XXX TODO link to the WoS archive ftp, when available

need !dosvar  need @dosvar

: jiffy!  ( a -- )  16 !dosvar  ;
  \ Set the Z80 routine to be called by G+DOS after the OS
  \ interrupts routine, every 50th of a second.

: jiffy@  ( -- a )  16 @dosvar  ;
  \ Get the current Z80 routine that is called by G+DOS after
  \ the OS interrupts routine, every 50th of a second.

: -jiffy  ( -- )  8335 jiffy!  ;
  \ Deactivate the jiffy call, setting its default value
  \ (a noop routine in the RAM of the +D interface).



  \ }}} =======================================================
  \ Locals {{{

( local restore-local )

  \ A simple solution to use an ordinary variable as local,
  \ saving its current value on the return stack and restoring
  \ it at the end.

  \ 2015-11-14

  \ Credits:
  \
  \ Original code by Henning Hanseng, published on Forth
  \ Dimensions 9/5 p. 6 (1988-01).

: restore-local  ( -- )  ( R: a x -- )  2r> swap !  ;
  \ a = address of a variable
  \ x = its original value
  \ Restore variable address and value.

: local  ( a0 -- )  ( R: a1 -- a0 x pfa a1 )
  \ a0 = address of a variable
  \ x = its current value
  \ a1 = return address
  \ pfa = pfa of `restore-local`
  r> swap                     \ save top return address
  dup @ 2>r                   \ save variable address and value
  ['] restore-local >body >r  \ force exit via `restore-local`
  >r  ;                       \ restore top return address

  \ Usage example:
  \
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value

( local restore-local )

  \ A simple solution to use an ordinary variable or value as
  \ local, saving its current value on the return stack and
  \ restoring it at the end.

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-14: Start.

  \ Credits:
  \
  \ Original code by Michael Barr, published on Forth
  \ Dimensions 10/1 p. 6 (1988-05).

code (restore-local)
  \ XXX TODO
  jpnext
  end-code

: restore-local
  (restore-local)  ;

code (local)  ( a0 -- )  ( R: a1 -- a0 x pfa a1 )
  \ a0 = address of a variable
  \ x = its current value
  \ a1 = return address
  \ pfa = pfa of `restore-local`
  \ XXX TODO
  jpnext
  end-code

: local  ( "name" -- )
  ' >body postpone literal postpone (local)
  ; immediate compile-only

  \ Usage example:
  \
  \ variable v
  \ 1 v !  v ?  \ default value
  \ : test  ( -- )
  \   v local
  \   v ?  1887 v !  v ?  ;
  \ v ?  \ default value

( arguments results )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-14: Start.

  \ Credits:
  \
  \ Original code by Marc Perkel, published on Forth Dimensions
  \ (volume 3, number 6, page 6, 1982-03).

need 2/

variable >args
  \ address of the current arguments in the data stack
variable arg-action
  \ id of the argument action (fetch, store or add)

: arg:  ( n "name" -- )
  create  ,
  does>  ( a -- x ) ( x a -- )
    \ ( a pfa | x a pfa )
    @ >args @ swap -
    arg-action @ ?dup if    0< if  +!  else  !  then
                      else  @
                      then  arg-action off  ;
  \ create a new argument

$00 arg: s0 $02 arg: s1 $04 arg: s2 $06 arg: s3 $08 arg: s4
$0A arg: s5 $0C arg: s6 $0E arg: s7 $0A arg: s8 $0C arg: s9

: to  ( -- )  1 arg-action !  ;
  \ set the store action

: +to  ( -- )  -1 arg-action !  ;
  \ set the add action

-->

( arguments results )

  \ XXX OLD -- original
  \ : arguments  ( n -- )
  \   r> >args @ >r >r  \ save the contents of `>args`
  \   cells sp@ + dup >args ! 12 - sp@ swap -
  \   2/ 0 do  0  loop  arg-action !  ;

  : arguments  ( n -- )
  r> >args @ >r >r        \ save `>args`
  cells sp@ + dup >args ! 12 - sp@ swap -
  2/ 0 do  0  loop  arg-action !  ;

: results  ( n -- )
  cells >args @ swap - sp@ -
  2/ 0 do drop loop
  r> r> >args ! >r  ;     \ restore `>args`

-->

( arguments results )

  \ test

: test  ( n1 n2 n3 -- )
  cr ." check 1" .s \ XXX INFORMER
  3 arguments
  cr ." check 2" .s \ XXX INFORMER
  s0 s1 s2 * * to s4
  s0 s1 s2 + + to s5
  s5 to s2
  s4 to s1
  cr ." check 3" .s \ XXX INFORMER
  2 results
  cr ." check 4" .s \ XXX INFORMER
  ;

( create-anon anon +anon n>anon )

  \ Anonymous variables.

  \ 2015-11-14

  \ Credits:
  \
  \ Adapted, modified, improved and commented from original
  \ code written by Leonard Morgenstern, published on Forth
  \ Dimensions 6/1 p. 33 (1984-05).

variable (anon)  ( -- a )
  \ xt of the latest anonymous variable.

: create-anon  ( -- )
  here (anon) !
  [ (anon) body> @ ] literal compile, 0 ,  ;
  \ Create a new anonymous variable.  `(anon)` is used to get
  \ and compile the xt executed by all variables.

: anon  ( Compilation: -- ) ( Run-time: -- a )
  (anon) @
  compiling? if  compile,  else  execute  then  ; immediate
  \ Current anonymous variable (first cell),
  \ equivalent to `0 +anon`.

: +anon  ( Compilation:  n -- ) ( Run-time: -- )
  cells (anon) @ execute +
  compiling? if  postpone literal  then ; immediate
  \ Current anonymous variable (cell _n_, first is 0).

: n>anon  ( x1..xn n -- )
  cells postpone anon swap bounds do  i !  cell +loop  ;
  \ Store the given _n_ cells into the current anonymous
  \ variable.

  \ Usage example:

  \ create-anon 5 cells allot
  \
  \ : test
  \   400 300 200 100 000  5 n>anon
  \   anon ?          \ prints 0
  \   123 anon !
  \   anon ?          \ prints 123
  \   [ 2 ] +anon ?   \ prints 200
  \   555 [ 2 ] +anon !
  \   [ 2 ] +anon ?   \ prints 555
  \   ;

( { } )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO -- this depends on `(local)` and `refill`

  \ XXX TODO -- an alternative implementation with string
  \ comparisons is in the Forth-2012 documentation, but a
  \ dictionary search seems a better option.

  \ Credits:
  \
  \ Code adapted from pForth.

  \ ____
  \
  \ @(#) $M$ 98/01/26 1.2 standard { v0 v1 ... vn | l0 l1 .. lm
  \ -- } syntax based on ANSI basis words (LOCAL) and TO
  \
  \ Author: Phil Burk Copyright 1994 3DO, Phil Burk, Larry
  \ Polansky, Devid Rosenboom
  \
  \ The pForth software code is dedicated to the public domain,
  \ and any third party may reproduce, distribute and modify
  \ the pForth software code or any derivative works thereof
  \ without any compensation or license.  The pForth software
  \ code is provided on an "as is" basis without any warranty
  \ of any kind, including, without limitation, the implied
  \ warranties of merchantability and fitness for a particular
  \ purpose and their equivalents under the laws of any
  \ jurisdiction.
  \
  \ MOD: PLB 2/11/00 Allow EOL and \ between { }.  ____

need privatize

private{
variable loc-temp-mode
  \ if true, declaring temporary variables
variable loc-comment-mode
  \ if true, in comment section
variable loc-done
}private

-->

( { } )

: {  ( <local-declaration}> -- )
  loc-done off  loc-temp-mode off  loc-comment-mode off
  begin
    parse-name dup 0>  \ not at the end of a line?
    if
      over c@ case
        \ handle special characters

        [char] }  of  loc-done on          2drop  endof
        [char] |  of  loc-temp-mode on     2drop  endof
        [char] -  of  loc-comment-mode on  2drop  endof
        [char] )  of  ." { ... ) imbalance!" cr abort  endof
        [char] \  of  postpone \
                      2drop endof

        -->

( { } )

        \ process name
        >r  \ save char
        ( addr len ) loc-comment-mode @
        if  2drop else  loc-temp-mode @ if  compile false  then
          \ if in temporary mode, assign local var = 0
          \ otherwise take value from stack
          (local)
        then  r>

      endcase

    else  2drop refill 0=
          abort" end of input while defining local variables!"

    then  loc-done @

  until  0 0 (local)  ; immediate  privatize

( {}-tests )

  \ tests

: tlv1  { n -- }  n  dup n *  dup n *  ;

: tlv2 { v1 v2 | l1 l2 -- }
  v1 . v2 . cr
  v1 v2 + -> l1
  l1 . l2 . cr
  ;

  \ }}} =======================================================
  \ Time {{{

( ms )  \ ==time==

need os-frames

: ms  ( u -- )
  \ Wait _u_ ms (miliseconds), with 20 ms precision.
  20 / os-frames @ +
  begin  dup os-frames @ u<  until drop  ;

  \ doc{
  \
  \ ms  ( u -- )
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-202 (FACILITY
  \ EXT).
  \
  \ }doc

  \ XXX TODO
  \ Adapt this better version from v.Forth:
  \
  \ code ms
  \  pop de
  \  begin,
  \   ld a,171
  \   begin,
  \    nop
  \    dec a
  \   -until,
  \   dec de
  \   ld a,d
  \  ora e
  \  -until,
  \  jp (ix)

  \ Version from Spectrum Forth-83:
  \ : ms  ( u -- )  20 /mod pause 0 ?do 10 0
  \   do loop loop  ;

  \ Version from DZX-Forth (for 8080):
  \ code ms  ( u -- )  hex
  \   d1 c,         \ pop de
  \   here          \ ms1:
  \   78 03 + c,  B0 02 + c,
  \                 \ ld a,e
  \                 \ or d
  \   ca c, next ,  \ jp z,next
  \   21 c, 0004 ,  \ ld hl,4 ; mhz
  \   29 c,  29 c,  29 c,
  \                 \ add hl,hl
  \                 \ add hl,hl
  \                 \ add hl,hl
  \   here          \ ms2:
  \   e3 c,  e3 c,  e3 c,  e3 c,
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \                 \ ex (sp),hl        ; 19t
  \   e5 c,  e1 c,  2B c,
  \                 \ push hl           ; 11t
  \                 \ pop hl            ; 10t
  \                 \ dec hl            ;  6t
  \   3E c, 00 c,  78 05 + c,  B0 04 + c,
  \                 \ ld a,0            ;  7t
  \                 \ ld a,l            ;  4t
  \                 \ or h              ;  4t
  \   c2 c, ,       \ jp nz,ms2         ; 10t
  \   1B c,         \ dec de
  \   c3 c, ,       \ jp ms1
  \ end-code

( ms88 )

  \ XXX TODO
  \ XXX version of `ms` adapted from Z88 CamelForth
  \ XXX UNDER DEVELOPMENT

  \ Original:
  \
    \ defw PAUSE  ; allow other tasks to run
  \ .stMS:
    \ defw stMS+2
    \ ld l,10    ; only run other tasks every 10ms
  \ .reMS:
    \ ld a,b
    \ or c
    \ jr z,endMS
    \ push bc
    \ ld bc,133
  \ .reMS2:
    \ dec bc
    \ ld a,b
    \ or c
    \ jr nz,reMS2
    \ pop bc
    \ dec bc
    \ dec l
    \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS  pop bc          ; get new TOS
    \ jp EXIT

need z80-asm
code ms88  ( u -- )
  de pop
    \ ld l,10    ; only run other tasks every 10ms
  begin \ .reMS:

  d a ld
  e or nz if

    de push \ push bc
    #133 de ldp#
    begin  \ .reMS2:
      dec decp  d a ld  e or
    z until \ jr nz,reMS2
    de pop \ pop bc
    de decp  l dec
 z until \ jr nz,reMS
    \ ld de,stMS
    \ jp PAUSE  ; allow other tasks to run
  \ .endMS
  then  jpnext  end-code

( frames@ frames! reset-frames )

need os-frames

: frames@  ( -- d )
  os-frames @ [ os-frames 2+ ] literal c@  ;
  \ System frames counter (incremented every 20 ms).

: frames!  ( d -- )
  [ os-frames 2+ ] literal c! os-frames !  ;
  \ Set the system frames counter.

: reset-frames  ( -- )  0. frames!  ;
  \ Reset the system frames counter.

( pause )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, and it's executed
  \ to get its current adress.

need z80-asm  need call-xt  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    \ XXX FIXME -- crash -- why this does not work?:
    ' (wait) call-xt  hl pop  execute-hl
      \ execute the xt hold in the user variable `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a deferred word.

need z80-asm  need call-xt

defer (wait)  ' noop ' (wait) defer!

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) call-xt
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

  \ Variant: `(wait)` is a user variable, but its current
  \ address is compiled, what is wrong.

need z80-asm  need execute-hl

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    (wait) fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable.

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm  need execute-hl

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push
    ' (wait) >body fthl  execute-hl
      \ call the xt hold in `(wait)`
    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( pause )

  \ XXX OLD

  \ Variant: `(wait)` is a variable and the calling is not
  \ factored.

need z80-asm

variable (wait)  ' noop (wait) !

code pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    de push

    \ Call the xt hold in `(wait)`:

    ' (wait) >body fthl
    here 6 + bc ldp# \ point IP to phony_compiled_word
    next2 jp  \ execute the xt in `(wait)`
    \ phony_compiled_word:
    here cell+ ,  \ point to the phony xt following
    here cell+ ,  \ phony xt, point to the code following

    de pop  halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `pause` has to be modified.

( just-pause )

  \ Credits:
  \
  \ Code adapted from Spectrum Forth-83.

need z80-asm

code just-pause ( u -- )
  \ u = number of ticks
  de pop  bc push
  begin
    halt  de decp  de tstp  \ finished?
  z until
  bc pop  jpnext
  end-code

( leapy-year? )

  \ 2015-11-15

  \ Credits:
  \
  \ Code written by Wil Baden, published on Forth Dimensions
  \ (volume 8, number 5, page 31, 1987-01).

: leapy-year?  ( n -- f )
  dup 400 mod 0= if  drop true   exit  then
  dup 100 mod 0= if  drop false  exit  then
        4 mod 0= if       false  exit  then
  false  ;

exit

  \ Alternative.

need baden-case

: leapy-year?  ( n -- f )
  case 400 mod 0= of  true   endof
  case 100 mod 0= of  false  endof
  case   4 mod 0= of  true   endof
  othercase false  ;

( set-date get-date )

create (date)  1 c,  1 c,  2016 ,
  \ day, month, year

: get-date  ( -- day month year )
  (date) c@
  [ (date) 1+ ] literal c@
  [ (date) 2+ ] literal @  ;

  \ doc{
  \
  \ get-date  ( -- day month year )
  \
  \ Get the current date. The default date is 2016-01-01. It
  \ can be changed with `set-date`. The date is not updated by
  \ the system.
  \
  \ }doc

: set-date  ( day month year -- )
  [ (date) 2+ ] literal !
  [ (date) 1+ ] literal c!
  (date) !  ;

  \ doc{
  \
  \ set-date  ( day month year -- )
  \
  \ Set the current date. The default date is 2016-01-01. It
  \ can be fetch with `get-date`. The date is not updated by
  \ the system.
  \
  \ }doc

( set-time get-time reset-time )

need frames@  need frames!  need m+  need alias  need ud*

: get-time  ( -- second minute hour )
  frames@ 50 um/mod nip s>d   ( sec . )
          60 um/mod s>d       ( sec min . )
          60 um/mod           ( sec min hour )  ;

  \ doc{
  \
  \ get-time  ( -- second minute hour )
  \
  \ Return the current time.
  \
  \ The system doesn't have an actual clock. The system frames
  \ counter is used instead. It is increased by the interrupts
  \ routine every 20th ms. The counter is a 24-bit value, so
  \ its maximum is $FFF ticks of 20 ms (5592 minutes, 93
  \ hours), then it starts again from zero.
  \
  \ }doc

: set-time  ( second minute hour -- )
  3600 um*  rot 60 * m+  rot m+  ( seconds )
  50. ud* frames!  ;

  \ doc{
  \
  \ set-time  ( second minute hour -- )
  \
  \ Set the current time. See `get-time`.
  \
  \ }doc

' reset-frames alias reset-time  ( -- )

  \ doc{
  \
  \ reset-time  ( -- )
  \
  \ Reset the current time to 00:00:00. See `get-time`.
  \
  \ }doc

( .time .system-time .date .system-date .time&date time&date )

  \ XXX TODO document

need get-time  need get-date

: .00  ( n -- )  s>d <# # # #> type  ;
: .0000  ( n -- )  s>d <# # # # # #> type  ;

: .time  ( second minute hour -- )
  .00 ':' emit .00 ':' emit .00  ;

: .system-time  ( -- )  get-time .time  ;

: .date  ( day month year -- )
  .0000 '-' emit .00 '-' emit .00  ;

: .system-date  ( -- )  get-date  .date  ;

: .time&date  ( second minute hour day month year -- )
  .date 'T' emit .time  ;

: time&date  ( -- second minute hour day month year )
  get-time get-date  ;

  \ doc{
  \
  \ time&date  ( -- second minute hour day month year )
  \
  \ Return the current time and date: second (0..59), minute
  \ (0..59), hour (0..23), day (1..31), month (1..12) and year
  \ (e.g., 2016).
  \
  \ See: `get-time`, `get-date`, `set-time`, `set-date`.
  \
  \ Origin: Forth-94 (FACILITY EXT), Forth-201 (FACILITY
  \ EXT).
  \
  \ }doc

  \ }}} =======================================================
  \ Vocabularies {{{

( .context .current order vocs )  \ ==vocabularies==

  \ XXX OLD 2015-12-26 -- this will be replaced with a new
  \ version, based on eForth

  \ Credits:
  \
  \ Code adapted from F83.

need body>name

  \ XXX FIXME -- this fails with wordlists, because they don't
  \ have a name
: .context  ( -- )
  context #vocs 0 do
    dup @ ?dup if  body>name .name  then  cell+
  loop  drop  ;
  \ Display the search order currently in effect.
  \
  \ XXX TODO -- from eForth:
  \ GET-ORDER BEGIN ?DUP WHILE SWAP .WID 1 - REPEAT

: .current  ( -- )  get-current body>name .name  ;
  \ Display the name of the `current` vocabulary.
  \ XXX TODO -- from eForth:
  \ GET-CURRENT .WID ;

: order  ( -- )
  cr ." context: " .context cr ." current: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

: vocs  ( -- )
  voc-link @
  begin  dup cell - body>name .name  @ dup 0= until  drop  ;
  \ List all of the vocabularies that have been defined so
  \ far, in the order of their definition (more recent first).

( order wordlists )

  \ 2015-12-26
  \ XXX UNDER DEVELOPMENT -- new version after eForth

  \ XXX TODO -- Structure of a wordlist, after eForth:
  \
  \ nt, of last definition, linked )
  \ wid|0, next or last wordlist in chain
  \ nt, wordlist name pointer

: wid>chain  ( wid -- a )  cell+ ;

: wid>name  ( wid -- a )  [ 2 cells ] literal + ;

: .wid ( wid -- )
  space dup wid>name @ ?dup if  .name drop exit  then  0 u.r ;

: .current  ( -- )  get-current .wid  ;

: .context  ( -- )
  get-order begin  ?dup  while  swap .wid 1-  repeat  ;

: order  ( -- )
  cr ." Search: " .context cr ." Define: " .current  ;
  \ Display the search order currently in effect and the name
  \ of the `current` vocabulary.

 : wordlists  ( -- )
   voc-link
   begin  @ ?dup  while  dup .wid wid>chain  repeat  ;
   \ List all wordlists.
   \ XXX TODO -- finish the conversion

( vocabulary )

  \ 2015-12-26
  \ XXX UNDER DEVELOPMENT -- new version after eForth

: !wid  ( wid -- ) wid>name latest swap ! ;
  \ Associate the lastest name to _wid_.
  \ XXX TODO better name

: create-vocabulary  ( wid "name" -- )
  create dup , !wid
  does>  ( -- )  ( pfa ) @ context !  ;

: wid-of ( "vocabulary" -- wid )  ' >body @  ;
  \ Return the _wid_ of "vocabulary".

: vocabulary ( "name" -- ) wordlist create-vocabulary ;

( get-order )

  \ XXX TODO use the actual number of vocs in context, not
  \ the maximum

: (get-order)  ( n -- widn..wid1 n)
  1- -1 swap do  context i cells + @  -1 +loop  ;
  \ Do get the search order.

: get-order  ( -- 0 | widn..wid1 n)
  #vocs ?dup if  (get-order)  then  #vocs  ;
  \ Get the search order.
  \ XXX FIXME `#vocs` can not be zero

( get-order order@ )

  \ 2015-12-26
  \ XXX UNDER DEVELOPMENT
  \
  \ From eForth:

: order@  ( a -- u*wid u )
  dup @ dup if    >r cell+  recurse  r> swap 1+ exit
            then  nip  ;
  \ XXX TODO use the actual number of vocs in context,
  \ not a trailing zero

: get-order  ( -- u*wid u )  context order@ ;

( wid-of wid> >wid )

  \ Credits:
  \
  \ Code of `wid-of` adapted from eForth's `widof`.

: wid>  ( wid -- xt )  body>  ;
  \ Convert a _wid_ to the _xt_ of its vocabulary.
  \ XXX TODO -- use `alias`

: >wid  ( xt -- wid )  >body  ;
  \ Convert the _xt_ of a vocabulary to its _wid_.
  \ XXX TODO -- use `alias`

: wid-of  ( "name" -- wid )  ' >wid  ;

( swap-current trail )

[unneeded] trail
?\ : trail  ( -- nt )  context @ @  ;

  \ doc{
  \
  \ trail ( -- nt )
  \
  \ Leave the _nt_ of the topmost word in the
  \ `context` vocabulary.
  \
  \ }doc

[unneeded] swap-current ?\ exit
: swap-current  ( wid1 -- wid2 )
  get-current swap set-current  ;

  \ Credits:
  \
  \ Idea from lpForth.

( vocabulary )

  \ XXX UNDER DEVELOPMENT 2015-12-26
  \
  \ XXX Note: Already in the kernel, but may be moved here.

  \ From Gforth:

: vocabulary ( "name" -- )
  wordlist create ,
  does> ( -- )
    \ Replace the wordlist on the top of the search list with
    \ the vocabulary's wordlist.
    ( pfa ) @ >r
    get-order dup 0= -50 and throw \ search-order underflow
    nip r> swap  set-order ;

  \ From Z88 CamelForth:

: vocabulary ( "name" -- )
  wordlist create ,
  does> ( -- )
    ( pfa ) @ >r get-order nip r> swap set-order  ;

( find-name-in find )

: find-name-in  ( ca len wid -- nt | 0 )  @ find-name-from  ;

  \ doc{
  \
  \ find-name-in  ( ca len wid -- nt | 0 )
  \
  \ Find the definition named in the string at _ca len_, in word
  \ list _wid_. If the definition is found, return its _nt_,
  \ else return zero.
  \
  \ The search is case-sensitive.
  \
  \ }doc

: find  ( ca -- ca 0 | xt 1 | xt -1 )
  dup count find-name dup
  if  nip name>immediate? 1 or negate  then  ;

  \ doc{
  \
  \ find  ( ca -- ca 0 | xt 1 | xt -1 )
  \
  \ Find the definition named in the counted  string at _ca_.
  \ If the definition is  not found, return _ca_ and zero. If
  \ the definition is found, return its execution token _xt_.
  \ If the definition  is immediate,  also  return one  (1),
  \ otherwise  also  return minus-one (-1).
  \
  \ Origin: Forth-83 (Required word set), Forth-94 (CORE,
  \ SEARCH), Forth-2012 (CORE, SEARCH).
  \
  \ }doc

  \ }}} =======================================================
  \ Random number generators {{{

( randomize randomize0 )  \ ==rng==

need os-seed

[needed] randomize0 ?\ : randomize  ( n -- )  os-seed !  ;
  \ Set the seed of the random number generator.

need os-frames

: randomize0  ( n -- )
  ?dup 0=  if  os-frames @  then  os-seed !  ;
  \ Set the seed of the random number generator;
  \ if _n_ is zero use the system frames counter instead.

( rnd random )  \ ==rng==

  \ Credits:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: rnd  ( -- n )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: random  ( n -- 0..n-1 )  rnd um* nip  ;

( random-range )

need random

: random-range ( n1 n2 -- n3 ) over - 1+ random +  ;
  \ Return a random number from _n1_ (min) to _n2_ (max).

( rng-benchmark )

  \ Random number generator benchmark

need set-pixel  need bench{  need pixels  need u%  need 3dup

256 192 * constant #pixels
  \ number of pixels of the screen

defer rng  ( n -- 0..n-1 )

: pixels%.  ( u -- )  #pixels u% 0.r ." %"  ;
  \ Print _u_ pixels as a percentage of the maximum
  \ number of pixels.

: .pixels  ( u -- )  dup u. ." pixels (" pixels%. ." )"  ;
  \ Print _u_ as the number of pixels.

: .title  ( ca len -- )  ." Code: " type  ;

variable cycles

defer .cycles  ( -- )

: (.cycles)  ( -- )
  cycles ?  s" cycles" cycles @ 1 = + type  ;
  \ Print the number of cycles.

: .time  ( d -- )  bench. ." per cycle" cr  ;

: .result  ( ca len d -- )
  2>r pixels >r  .title cr  r> .pixels cr
  2r> .time .cycles   ;
  \ Calculate and print the result of the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

-->

( rng-benchmark )

defer random-coords  ( -- xc yc )
  \ Random graphic coordinates. Configurable depending on the
  \ type of `random` to benchmark.

: (random-coords)  ( -- xc yc )  256 rng 193 rng  ;
  \ Default behaviour of `random-coords`.

: fill-screen  ( -- )
  #pixels 0 do  random-coords set-pixel  loop  ;
  \ Fill the screen with random pixels.

: signal  ( -- )  cycles @ %111 and border  ;
  \ Change the border color according to the current count
  \ of cycles, just to show that the benchmark is running.

: (rng-benchmark)  ( -- d )
  1 cycles +!  signal  bench{ fill-screen }bench  ;
  \ Do the RNG benchmark of ony cycle and return its result.

: wait  ( -- )  key drop  ;

: finish  ( ca len d -- )  0 border  .result  wait  ;
  \ Finish the benchmark.
  \ _d_ is the time in frames; _ca len_ is the title.

: init  ( xt1 xt2 x3 -- )
  ['] random-coords defer!  ['] .cycles defer!  ['] rng defer!
  page  -1 cycles !  ;

defer finish?  ( i*x -- j*x f )
  \ Finish the benchmark?

: new-pixels?  ( n1 -- n2 f )  pixels tuck =  ;
  \ Are there new pixels on the screen, comparing the previous
  \ count _n1_ with the new count _n2_?

' new-pixels? ' finish? defer!  -->

( rng-benchmark )

defer rng-benchmark  ( ca len xt -- )
  \ Do a RNG benchmark for the `random` word _xt_ with title
  \ _ca len_.

: (rng-benchmark2)  ( ca len -- )
  0 begin   (rng-benchmark) 2>r
            finish? dup 0= if  2rdrop  then
  until     drop 2r> finish  ;
  \ Do a double RNG benchmark with title _ca len_: The time
  \ required to complete one cycle (49152 random pixels), plus
  \ the number of cycles required until the number of pixels
  \ doesn't change.

: rng-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] (random-coords) init  (rng-benchmark2)  ;
  \ Do a double RNG benchmark for the `random` word _xt_ with
  \ title _ca len_: The time required to complete one cycle
  \ (49152 random pixels), plus the number of cycles required
  \ until the number of pixels doesn't change.

  \ The best `random` words need several cycles. In such cases
  \ it's useful a simpler test to show only the pixels set at
  \ the end of the first cycle:

' rng-benchmark2 ' rng-benchmark defer!  \ default benchmark

: (.cycle)  ( -- )  ." First cycle only"  ;

: (rng-benchmark1)  ( ca len -- )
  (rng-benchmark) .result wait  ;
  \ Do a one-cycle RNG benchmark with title _ca len_: Only the
  \ time required to complete one cycle (49152 random pixels).

: rng-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] (random-coords) init  (rng-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for `random` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

-->

( rng-benchmark )

  \ Versions for 8-bit `rnd`.

: crnd-coords  ( -- xc yc )  rng rng 192 min  ;
  \ Random graphic coordinates for 8-bit `rnd`.

: rng8-benchmark2  ( ca len xt -- )
  ['] (.cycles) ['] crnd-coords init  (rng-benchmark2)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

: rng8-benchmark1  ( ca len xt -- )
  ['] (.cycle) ['] crnd-coords init  (rng-benchmark1)  ;
  \ Do a one-cycle RNG benchmark for 8-bit `rnd` word _xt_ with
  \ title _ca len_: Only the time required to complete one
  \ cycle (49152 random pixels).

( all-rng-benchmarks )

  \ Execute all 16-bit RNG benchmarks

need rng-benchmark  need +thru  1 13 +thru

ace-rng-benchmark   dx-rng-benchmark
gf-rng-benchmark    jer-rng-benchmark
jml-rng-benchmark   lb-rng-benchmark
lina-rng-benchmark  mb-rng-benchmark
sf83-rng-benchmark  tt-rng-benchmark
vf-rng-benchmark    z88-rng-benchmark
zh-rng-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' rng-benchmark1 ' rng-benchmark defer!

dx-rng-benchmark  vf-rng-benchmark

( ace-random )

  \ Credits:
  \
  \ Adapted from ACE Forth, after the Jupiter ACE manual.
  \ Also used by Abersoft Forth in its bundled game
  \ "Bertie".

need os-seed

: ace-rnd  ( -- n )
  os-seed @ 75 um* 75. d+ 2dup u< - - 1- dup os-seed !  ;

: ace-random  ( n1 -- n2 )  ace-rnd um* nip  ;

need rng-benchmark

: ace-rng-benchmark  ( -- )
  s" Jupiter ACE manual" ['] ace-random rng-benchmark  ;

( dx-random )

  \ Credits:
  \
  \ Code from DX-Forth 4.13.

2variable dx-seed  1. dx-seed 2!

need d*

: dx-rnd ( -- u )
  dx-seed 2@ $15A4E35. d* 1. d+ tuck dx-seed 2!  ;
  \ Get random number

: dx-random ( u -- 0..u-1 )  dx-rnd um* nip  ;
  \ Get random number between 0 and u-1

need rng-benchmark

: dx-rng-benchmark  ( -- )
  s" DX-Forth" ['] dx-random rng-benchmark  ;

( gf-random )

  \ Credits:
  \
  \ Adapted from Gforth.

need os-seed  need ud*

: gf-rnd  ( -- n )
  272958469. os-seed @ ud* d>s 1+ dup os-seed !  ;

: gf-random  ( n1 -- n2 )  gf-rnd um* nip  ;

need rng-benchmark

: gf-rng-benchmark  ( -- )
  s" Gforth" ['] gf-random rng-benchmark  ;

( jer-random )

  \ Credits:
  \
  \ Random number generator by J. E. Rickenbacker, published on
  \ Forth Dimensions (volume 2, number 2, page 34, 1980-07).

need os-seed

: jer-rnd  ( -- n )
  os-seed @ 259 * 3 + 32767 and dup os-seed !  ;

: jer-random ( n1 -- n2 )
  jer-rnd 32767 */  ;
  \ Return a random number _n2_ (0 <= n2 < n1).

  \ XXX Note: patterns

need rng-benchmark

: jer-rng-benchmark  ( -- )
  s" J. E. Rickenbacker" ['] jer-random rng-benchmark  ;

( jml-random )

  \ Credits:
  \
  \ Adapted from code written by Jos Manuel Lazo,
  \ published on Microhobby, issue 85 (1986-07), page 24:
  \ http://microhobby.org/numero085.htm
  \ http://microhobby.speccy.cz/mhf/085/MH085_24.jpg

need z80-asm  need os-seed

code jml-rnd  ( -- u )

  os-seed fthl  hl push
  hl addp  hl addp  hl addp  hl addp  hl addp  hl addp
  de pop  de addp  0029 de ldp#  de addp
  os-seed sthl
  pushhl jp
  end-code

: jml-random  ( n -- 0..n-1 )  jml-rnd um* nip  ;

need rng-benchmark

: jml-rng-benchmark  ( -- )
  s" J.M. Lazo" ['] jml-random rng-benchmark  ;

( lb-random )

  \ Credits:
  \
  \ Code adapted from Leo Brodie's _Starting Forth_.

need os-seed

: lb-rnd  ( -- n )  os-seed @ 31421 * 6927 + dup os-seed !  ;

: lb-random  ( n -- 0..n-1 )  lb-rnd um* nip  ;

need rng-benchmark

: lb-rng-benchmark  ( -- )
  s" Leo Brodie" ['] lb-random rng-benchmark  ;

( lina-random )

need os-seed

: lina-rnd  ( -- n )
  os-seed @ 107465 * 234567 + dup os-seed !  ;

: lina-random  ( n1 -- n2 )  lina-rnd um* nip ;

need rng-benchmark

: lina-rng-benchmark  ( -- )
  s" lina" ['] lina-random rng-benchmark  ;

( mb-random )

  \ Credits:
  \
  \ Adapted from code published by Milos Bazelides:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

need z80-asm  need os-seed

code mb-rnd  ( -- n )
  os-seed de ftp
  d a ld  e h ld  #253 l ld#
  a or  de sbcp
  0 sbc#  de sbcp
  0 d ld#  d sbc  a e ld
  de sbcp
  cy if  hl incp  then
  os-seed sthl
  pushhl jp  end-code

: mb-random  ( n1 -- n2 )  mb-rnd um* nip  ;

  \ Original code:

  \ ----
  \ ; Input: none
  \ ; Output: HL = pseudo-random number, period 65536

  \ Rand16:
  \  ld  de,Seed    ; Seed is usually 0
  \  ld  a,d
  \  ld  h,e
  \  ld  l,253
  \  or  a
  \  sbc  hl,de
  \  sbc  a,0
  \  sbc  hl,de
  \  ld  d,0
  \  sbc  a,d
  \  ld  e,a
  \  sbc  hl,de
  \  jr  nc,Rand
  \  inc  hl
  \ Rand:
  \  ld  (Rand16+1),hl
  \  ret
  \ ----

need rng-benchmark

: mb-rng-benchmark  ( -- )
  s" Milos Bazelides" ['] mb-random rng-benchmark  ;

( sf83-random )

  \ Credits:
  \
  \ Code from Spectrum Forth-83.

need os-seed  3 os-seed !

: sf83-random  ( n -- 0..n-1 )
  os-seed @ 743 * 43 + dup os-seed ! um* swap drop  ;

need rng-benchmark

: sf83-rng-benchmark  ( -- )
  s" Spectrum Forth-83" ['] sf83-random rng-benchmark  ;

( tt-random )

  \ Credits:
  \
  \ Code from tt.pfe, Tetris for terminals, redone in
  \ ANSI-Forth.  Written 1994-04-05 by Dirk Uwe Zoller.

need os-seed

: tt-random   ( n -- 0..n-1 )
    os-seed @ 13 * $7FFF and
    dup os-seed !  swap mod ;

need rng-benchmark

: tt-rng-benchmark  ( -- )
  s" Tetris for terminals" ['] tt-random rng-benchmark  ;

( vf-random )

  \ Credits:
  \
  \ Code from vForth.

need os-frames

: vf-random  ( n1 -- n2 )
  1+ 8195 os-frames @ um* 1. d+
  16383 um/mod drop
  \ dup os-seed !
  swap mod  ;

need rng-benchmark

: vf-rng-benchmark  ( -- )
  s" vForth" ['] vf-random rng-benchmark  ;

( z88-random )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need ud*  need os-seed

: z88-random  ( u1 -- u2 )
  1103515245. \ 20077 16838
  os-seed @ ud* 12345. d+ over os-seed !
  rot ud/mod 2drop  ;

need rng-benchmark

: z88-rng-benchmark  ( -- )
  s" Z88 CamelForth" ['] z88-random rng-benchmark  ;

( zh-random )

  \ Credits:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

need z80-asm  need os-seed

code zh-rnd  ( -- n )

  os-seed fthl
    \ ld hl,(seed)
  hl de ldp
    \ ld c,l
    \ ld b,h
  hl addp  de addp  hl addp  de addp  hl addp
  de addp  hl addp  hl addp  hl addp  hl addp  de addp
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,de
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,hl
    \ add hl,de
  h inc  hl incp
    \ inc h
    \ inc hl
  os-seed sthl
    \ ld (seed),hl
  pushhl jp  end-code

: zh-random  ( n1 -- n2 )  zh-rnd um* nip  ;

  \ Original code:

  \ ----
  \ PseudoRandWord:
  \
  \ ; this generates a sequence of pseudo-random values
  \ ; that has a cycle of 65536 (so it will hit every
  \ ; single number):
  \
  \ ;f(n+1)=241f(n)+257   ;65536
  \ ;181 cycles, add 17 if called
  \
  \ ;Outputs:
  \ ;     BC was the previous pseudorandom value
  \ ;     HL is the next pseudorandom value
  \ ;Notes:
  \ ;     You can also use B,C,H,L as pseudorandom 8-bit values
  \ ;     this will generate all 8-bit values
  \      .db 21h    ;start of ld hl,**
  \ randSeed:
  \      .dw 0
  \      ld c,l
  \      ld b,h
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,bc
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,hl
  \      add hl,bc
  \      inc h
  \      inc hl
  \      ld (randSeed),hl
  \      ret
  \ ----

need rng-benchmark

: zh-rng-benchmark  ( -- )
  s" Z80 Heaven" ['] zh-random rng-benchmark  ;

( random-byte )

code random-byte  ( -- b )
  ED c, 5F c,     \ ld a,r
  C3 c, pusha ,   \ jp pusha
  end-code

need bench{

: random-byte-test  ( -- )
  ['] random-byte ['] rng defer!  cls  bench{ pixels
  do  rng rng 192 min set-pixel  loop  }bench.
  ." Z80 R register" cr key drop ;

( lcm-random )

  \ XXX UNDER DEVELOPMENT

  \ Credits:
  \
  \ Adapted from code written by Everett F. Carter, published
  \ on Forth Dimensions (volume 16, number 2, page 17,
  \ 1994-08).

need d*  need du/mod  need 2nip

2variable 2seed

2147483647. 2constant max32

  \ Linear Congruential Method, the "minimal standard
  \ generator", Park & Miller, 1988, Comm of the ACM, 31(10),
  \ pp. 1192-1201
: lcm-rnd  ( -- d )
  \ XXX FIXME -- it always returns 0
  2seed 2@ 16807. d*
  max32 du/mod  2nip
  2dup 2seed 2!  ;

  \ \ Original code:
  \ : lcm-rnd  ( -- d )
  \   2seed 2@ 16807. umd*
  \   max32 umd/mod
  \   2drop 2seed 2!  ;

: lcm-random  ( n1 -- n2 )  lcm-rnd d>s um* nip  ;

need rng-benchmark

: lcm-rng-benchmark  ( -- )
  s" LCM" ['] lcm-random rng-benchmark  ;

( all-rng-benchmarks )

  \ Execute all 8-bit RNG benchmarks

need rng-benchmark  need +thru  1 4 +thru

' rng8-benchmark2 ' rng-benchmark defer!

jw-rng-benchmark
mb1-rng-benchmark
mb2-rng-benchmark
zh-rng-benchmark

  \ Execute single-cycle benchmarks of RNG that need more than
  \ one cycle to finish:

' rng8-benchmark1 ' rng-benchmark defer!

jw-rng-benchmark

( jw-crnd )

  \ 2015-12-25

  \ Credits:
  \
  \ http://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
  \ Joe Wingbermuehle

need os-seed

code jw-crnd  ( -- b )

  os-seed fthl
    \ ld      hl,(randData)
  ED c, 5F c,  a d ld  m e ld
    \ ld      a,r
    \ ld      d,a
    \ ld      e,(hl)
  de addp  l add  h xor
    \ add     hl,de
    \ add     a,l
    \ xor     h
  os-seed sthl
    \ ld      (randData),hl
  pusha jp
    \ jp push_a
  end-code

need rng-benchmark

: jw-rng-benchmark  ( -- )
  s" Joe Wingbermuehle" ['] jw-crnd rng-benchmark  ;

  \ Original code:

  \ ----
  \ ; ouput a=answer 0<=a<=255
  \ ; all registers are preserved except: af
  \ random:
  \         push    hl
  \         push    de
  \         ld      hl,(randData)
  \         ld      a,r
  \         ld      d,a
  \         ld      e,(hl)
  \         add     hl,de
  \         add     a,l
  \         xor     h
  \         ld      (randData),hl
  \         pop     de
  \         pop     hl
  \         ret
  \ ----

( mb1-crandom )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credits:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb1-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  a inc  os-seed sta
    \  inc  a    ; another possibility is ADD A,7
    \  ld  (seed),a
  pusha jp
  end-code

: mb1-crandom  ( n1 -- n2 )  mb1-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need rng-benchmark

  \ : mb1-rng-benchmark  ( -- )
  \   s" Milos Bazelides 1" ['] mb1-crandom rng-benchmark  ;

: mb1-rng-benchmark  ( -- )
  s" Milos Bazelides 1" ['] mb1-crnd rng-benchmark  ;

( mb2-crandom )

  \ XXX UNDER DEVELOPMENT

  \ 2015-12-25

  \ Credits:
  \ http://web.archive.org/web/20150225121110/http://baze.au.com/misc/z80bits.html#4

   \ This is a very simple linear congruential generator. The
   \ formula is x[i + 1] = (5 * x[i] + 1) mod 256. Its only
   \ advantage is small size and simplicity. Due to nature of
   \ such generators only a couple of higher bits should be
   \ considered random.

  \ Input: none
  \ Output: A = pseudo-random number, period 256

need z80-asm  need os-seed

code mb2-crnd  ( -- b )

  os-seed fta
    \ ld  a,(seed) ; Seed is usually 0
  a d ld  a add  a add  d add
    \  ld  d,a
    \  add  a,a
    \  add  a,a
    \  add  a,d
  07 add#  os-seed sta
    \  add a,7
    \  ld  (seed),a
  pusha jp  end-code

: mb2-crandom  ( n1 -- n2 )  mb2-crnd um* nip  ;
  \ XXX FIXME -- it always return zero

need rng-benchmark

  \ : mb2-rng-benchmark  ( -- )
  \   s" Milos Bazelides 2" ['] mb2-crandom rng-benchmark  ;

: mb2-rng-benchmark  ( -- )
  s" Milos Bazelides 2" ['] mb2-crnd rng-benchmark  ;

( zh-crnd )

  \ 2015-12-25

  \ Credits:
  \
  \ Code adapted from:
  \ http://z80-heaven.wikidot.com/math#toc40

code zh-crnd  ( -- b )

  os-seed fta  a e ld
  a add  e add  a add  a add  e add  #83 add#
  os-seed sta
  pusha jp

  end-code

need rng-benchmark

: zh-rng-benchmark  ( -- )
  s" Z80 Heaven (8 bit)" ['] zh-crnd rng-benchmark  ;

  \ This is one of many variations of PRNGs. This routine is
  \ not particularly useful for many games, but is fairly
  \ useful for shuffling a deck of cards. It uses SMC, but that
  \ can be fixed by defining randSeed elsewhere and using ld
  \ a,(randSeed) at the beginning.

  \ PseudoRandByte:
  \ ;f(n+1)=13f(n)+83
  \ ;97 cycles
  \      .db 3Eh     ;start of ld a,*
  \ randSeed:
  \      .db 0
  \      ld c,a
  \      add a,a
  \      add a,c
  \      add a,a
  \      add a,a
  \      add a,c
  \      add a,83
  \      ld (randSeed),a
  \      ret

  \ }}} =======================================================
  \ Deferred words {{{

( defers action-of )  \ ==deferredwords==

  \ Credits:
  \
  \ Code adapted from the Afera library.

: defers  ( "name" -- )  ' defer@ compile,  ; immediate
  \ Compile the present contents of the deferred word "name"
  \ into the current definition. I.e. this produces static
  \ binding as if "name" was not deferred.
  \
  \ Origin: Gforth.

: action-of  ( Interpretation: "name" -- xt )
             ( Compilation:    "name" -- )
             ( Runtime:        -- xt )
  ' compiling? if    postpone literal postpone defer@
               else  defer@  then  ; immediate
  \ Return the code field address of a deferred word.
  \
  \ Origin: Forth-2012 (CORE EXT).

( <is> [is] is  )

  \ Credits:
  \
  \ Code adapted from the Afera library.

: <is>  ( xt "name" -- )  ' defer!  ;

: [is]  ( xt "name" -- )
  postpone ['] postpone defer!  ; immediate compile-only

: is  ( xt "name" -- )
  compiling? if  postpone [is]  else  <is>  then  ; immediate

( alias )

  \ XXX NEW -- DTC

: alias  ( xt "name" -- )  defer latest name> defer!  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.
  \
  \ }doc

exit

  \ XXX OLD

: deferred?  ( xt -- wf )  c@ $C3 =  ;
  \ Is _xt_ a deferred word?
  \ The code of a deferred word starts with a Z80 jump ($C3)
  \ to the word it's associated to.

( code? code-alias? defer-alias code-alias alias )

  \ XXX OLD -- ITC

: code?  ( xt -- wf )  dup >body swap @ =  ;
  \ Is _xt_ a word created by `code`?

: code-alias?  ( xt -- wf )  @ dup body> @ =  ;
  \ Is _xt_ a word created by `code-alias` or `code`?

: defer-alias  ( xt "name" -- )
  defer latest name> defer!  ;
  \ Create a deferred word _name_ that executes _xt_.

: code-alias  ( xt "name" -- )
  @ header reveal latest name> !  ;
  \ Create a code word that executes the code pointed by _xt_.

: alias  ( xt "name" -- )
  dup code-alias? if  code-alias exit  then  defer-alias  ;

  \ doc{
  \
  \ alias  ( xt "name" -- )
  \
  \ Create an alias _name_ that will execute _xt_.  If _xt_
  \ is a primitive word, the address hold in _name_'s own xt
  \ will be the same than the address hold in _xt_. Otherwise
  \ _name_ will be a deferred word executing _xt_.
  \
  \ }doc

( synonym )

need alias

: synonym  ( "newname" "oldname" -- )
  parse-name nextname ' dup >r alias
  r> >name dup immediate?     if  immediate     then
               compile-only?  if  compile-only  then  ;

  \ doc{
  \
  \ synonym  ( "newname" "oldname" -- )
  \
  \ Create a definition for _newname_ with the the semantics
  \ defined below. _newname_ may be the same as _oldname_; when
  \ looking up _oldname_, _newname_ shall not be found.

  \ newname ( Interpretation: i*x -- j*x )
  \         Perform the interpretation semantics of _oldname_.
  \
  \ newname ( Compilation: i*x -- j*x )
  \         Perform the compilation semantics of _oldname_.
  \
  \ Origin: Forth-2012 (TOOLS EXT).
  \
  \ }doc

exit

  \ XXX OLD -- first version
  \ XXX FIXME -- `' newname` would not work fine

  \ Credits:
  \
  \ This code of `synonym` is adapted from the example provided
  \ in the Forth-2012 documentation, and improved with
  \ `compile-only?`.

: synonym  ( "newname" "oldname" -- )
  create immediate
    hide ' , reveal
  does>  ( -- )
   ( pfa ) @ ( xt ) dup >name dup ( xt nt nt )
   compile-only? executing? and -14 ?throw
   immediate? executing? or
   if  execute  else  compile,  then  ;

  \ }}} =======================================================
  \ Assembler {{{

( call )

code call  ( a -- )
  \ Call a machine code subroutine.

  E1 c,               \ pop hl
  C5 c,               \ push bc
  CD c, >mark         \ call call_hl
  C1 c,               \ pop bc
  DD c, 21 c, next ,  \ ld ix,next
  jpnext              \ jp next

  >resolve            \ call_hl:
  E9 c,               \ jp (hl)
  end-code

( z80-asm, )

  \ XXX UNDER DEVELOPMENT -- Fork of `z80-asm`, with modified
  \ syntax.
  \
  \ 2015-12-25 First changes:
  \
  \ 1. "," suffixes in Z80 instructions;
  \ 2. one single set of conditions;
  \ 3. "a" and "r" prefixes in control structures;
  \ 4. condition "m" renamed to "ne".

  \ XXX TODO
  \
  \ - combine changes 2..4 with the previous version.
  \ - rename `|mark` and `|resolve`
  \ - remove all "retCOND" and "callCOND" and "jpCOND"
  \   (or make them optional
  \ - make absolute-jump control structures optional.
  \

  \ Z80 assembler for Solo Forth

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).

  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need -rot  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm,  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm, -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm, -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  create c, does>  ( -- )  ( pfa ) c@ c,  ;
  \ 1-byte opcode without parameters.

: m2  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;
  \ 1-byte opcode with register encoded in bits 0-3.

: m3  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;
  \ 1-byte opcode with register encoded in bits 3-5.

: m4  ( 8b "name" -- )
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;
  \ 1-byte opcode with 1-byte parameter.

: m5  ( 8b "name" -- )
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;
  \ 1-byte opcode with 2-byte parameter.

: m6  ( 8b "name" -- )
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;
  \ Rotation of registers.

  -->

( z80-asm, -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;
  \ Bit manipulation of registers.

: m8  ( 16b "name" -- )
  create , does>  ( -- )  ( pfa ) @ ,  ;
  \ 2-byte opcodes.

: m9  ( 8b "name" -- )
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;
  \ Relative jumps.

-->

( z80-asm, -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;
  \ Index registers with register.

: mb  ( 8b "name" -- )
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;
  \ Rotation with index registers.

: mc  ( 8b "name" -- )
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;
  \ Bit manipulation with index registers.

-->

( z80-asm, -- opcodes)

  \ XXX FIXME ftap

00 m1 nop, 02 m3 stap, 03 m3 incp, 04 m3 inc, 05 m3 dec, 07 m1
rlca, 08 m1 exaf, 09 m3 addp, 0A m3 ftap, 0B m3 decp, 0F m1
rrca, 10 m9 djnz, 17 m1 rla, 18 m9 jr,  1F m1 rra, 20 m9 jrnz,
22 m5 sthl, 27 m1 daa, 28 m9 jrz, 2A m5 fthl, 2F m1 cpl, 30 m9
jrnc, 32 m5 sta, 37 m1 scf, 38 m9 jrc, 3A m5 fta, 3F m1 ccf, 76
m1 halt, 80 m2 add, 88 m2 adc, 90 m2 sub, 98 m2 sbc, B8 m2 cp,
C1 m3 pop, C2 m5 jpnz, C3 m5 jp, C5 m3 push, C6 m4 add#, C7 m2
rst, C9 m1 ret, CA m5 jpz, CD m5 call, CE m4 adc#, D2

-->

( z80-asm, -- opcodes)

m5 jpnc, D3 m4 out, 41 m3 outbc, D6 m4 sub#, D9 m1 exx, DA m5
jpc, DB m4 in, 40 m3 inbc, 0DE m4 sbc#, E2 m5 jppo, E3 m1
exsp, E6 m4 and#, E9 m1 jphl, EA m5 jppe, EB m1 exde, EE m4
xor#, F2 m5 jpp, F3 m1 di,  F6 m4 or#, F9 m1 ldsp, FA m5 jpm,
FB m1 ei, FE m4 cp#, 00 m6 rlc, 08 m6 rrc, 10 m6 rl, 18 m6
rr, 20 m6 sla,  28 m6 sra, 38 m6 srl,  40 m7 bit, 80 m7 res, C0
m7 set, B0ED m8 ldir, B8ED m8 lddr, 44ED m8 neg, 57ED m8 ldai,
47ED m8 ldia, 56ED m8 im1 5EED m8 im2 B1ED m8 cpir, 6FED m8
rld,

-->

( z80-asm, -- opcodes)

: jpix,  ( -- )  ix-op c, jphl,  ;
: ldp#,  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#,  ( 8b r -- )  8* 06 + c, c,  ;
: ld,  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp,  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp,  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp,  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp,  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix,  ( rp -- )  ix-op c, addp,  ;
: addiy,  ( rp -- )  iy-op c, addp,  ;

  \ Macros

: clr,  ( rp -- )  0 swap ldp#,  ;
: ldp,  ( rp1 rp2 -- )  2dup ld, 1+ swap 1+ swap ld,  ;

  \ ZX Spectrum specific

CF m4 hook, \ rst 0x08
D7 m1 prt,  \ rst 0x16

-->

( z80-asm, -- index register opcodes)

86 ma addx, 8E ma adcx, 96 ma subx, 9E ma sbcx, A6 ma andx,
AE ma xorx, B6 ma orx,  BE ma cpx,  34 ma incx, 35 ma decx,
06 mb rlcx, 0E mb rrcx, 16 mb rlx,  1E mb rrx,  26 mb slax,
2E mb srax, 3E mb srlx, 46 mc bitx, 86 mc resx, C6 mc setx,

: ftx,   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx,   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x,  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx,  ( disp rpi rp -- )  3dup 1+ ftx, rot 1+ -rot ftx,  ;
: stpx,  ( disp rpi rp -- )  3dup 1+ stx, rot 1+ -rot stx,  ;

-->

( z80-asm, -- conditions)

  \ Conditions are Z80 opcodes for the required jump
  \ instruction.
  \
  \ Example: `z aif` compiles a `jp nz`, so `z` is the code for
  \ `jp nz`.
  \
  \ Control structures that compile relative jumps modify the
  \ opcode accordingly. Example: `z rif` compiles a `jr nz `

C2 constant z  CA constant nz D2 constant cy DA constant nc
E2 constant pe EA constant po F2 constant ne  FA constant p

  \ XXX FIXME condition `m` has been renamed to `ne` because of
  \ the register `m`; but maybe all registers should be
  \ renamed.
  \ XXX TODO ne->ns and p->ps

: jp>jr  ( op1 -- op2 )  dup nc > #-273 ?throw  A2 -  ;
  \ Convert an absolute-jump condition to a relative-jump
  \ condition.  Throw error #-273 if the condition is
  \ invalid.

-->

( z80-asm, -- conditional ret and call)

  \ Conditional ret

: ?ret,  ( op -- )  8 xor 2- c,  ;

: retc,  ( -- )  cy ?ret,  ;    : retnc,  ( -- )  nc ?ret,  ;
: retz,  ( -- )  z ?ret,  ;     : retnz,  ( -- )  nz ?ret,  ;
: retm,  ( -- )  ne ?ret,  ;     : retp,  ( -- )  p ?ret,  ;
: retpe,  ( -- )  pe ?ret,  ;   : retpo,  ( -- )  po ?ret,  ;

  \ Conditional call

: ?call,  ( a op -- )  8 xor 2+ c, ,  ;

: callc,  ( -- )  cy ?call, ;
: callnc,  ( -- )  nc ?call,  ;
: callz,  ( -- )  z ?call, ;
: callnz,  ( -- )  nz ?call,  ;
: callm,  ( -- )  ne ?call, ;
: callp,  ( -- )  p ?call,  ;
: callpe,  ( -- )  pe ?call, ;
: callpo, ( -- )  po ?call,  ;

-->

( z80-asm, -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

-->

( z80-asm, -- control structures with relative jumps)

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: rif  ( op -- orig cs-id )  jp>jr , >relmark 0A  ;

: rthen  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: relse  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 rif rot swap rthen 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: rbegin  (  -- dest cs-id )  <mark 0B  ;

: rwhile  (  op -- orig cs-id )  jp>jr rif 2+  ;

: runtil  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: ragain  (  dest cs-id -- )  18 runtil  ;
  \ compile `jr`

: rrepeat  (  dest cs-id1 orig cs-id2 )
  2swap ragain 2- rthen  ;

: rstep    ( dest cs-id -- )  10 runtil  ;  -->
  \ compile `djnz`

( z80-asm, -- control structures with absolute jumps)

  \ XXX TODO document

: aif  (  op -- orig cs-id )  c, >mark 08  ;

: athen  (  orig cs-id -- )  08 ?pairs >resolve  ;

: aelse  (  cs-id -- cs-id )
  08 ?pairs C3 aif rot swap athen 08  ;
  \ C3 = opcode of `jp`

: abegin  (  -- dest cs-id )  <mark 09  ;

: awhile  (  op -- orig cs-id )  aif 2+  ;

: auntil  (  cs-id op -- )  c, 09 ?pairs <resolve  ;
  \ Compile an absolute conditional jump.

: aagain  (  cs-id -- )  C3 auntil  ;
  \ Compile an absolute jump.

: arepeat  (  dest cs-id1 orig cs-id2 )
  2swap aagain 2- athen  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm, -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and,  B0 m2 or,  A8 m2 xor,

  \ Macro, 16-bit subtract:
: subp,  ( rp -- )  a and sbcp,  ;

  \ Macro to test 16-bit register for zero:
: tstp,  ( rp -- )  dup a ld, 1+ or,  ;

-->

( z80-asm, -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( z80-asm )

\ Z80 assembler for Solo Forth

  \ XXX NOTE: first version

  \ This is a modified version of an assembler designed by Coos
  \ Haak for his own Forth, and used by Lennart Benschop with
  \ his Spectrum Forth-83 (1988).


  \ XXX TODO `get-order` here and `set-order` at the end.

only forth definitions

need ?pairs  need -rot  need 3dup

: 8*   ( n1 -- n2 )  2* 2* 2*  ;

: z80-asm  ( -- )  assembler  ;

also assembler definitions hex

-->

( z80-asm -- registers )

0 constant b   1 constant c   2 constant d   3 constant e
4 constant h   5 constant l   6 constant m   7 constant a

0 constant bc  2 constant de  4 constant hl

6 constant sp  6 constant af

DD constant ix-op  FD constant iy-op

: ix  ( -- rphl )  ix-op c, hl  ;
: iy  ( -- rphl )  iy-op c, hl  ;

: ?page  ( n -- n )  dup 80 + FF swap u< #-269 ?throw  ;
  \ Branch too long?

-->

( z80-asm -- defining words for z80 instructions)

: m1  ( 8b "name" -- )
  \ 1-byte opcode without parameters.
  create c, does>  ( -- )  ( pfa ) c@ c,  ;

: m2  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 0-3.
  create c, does>  ( r -- )  ( r pfa ) c@ + c,  ;

: m3  ( 8b "name" -- )
  \ 1-byte opcode with register encoded in bits 3-5.
  create c, does>  ( r -- )  ( r pfa ) c@ swap 8* + c,  ;

: m4  ( 8b "name" -- )
  \ 1-byte opcode with 1-byte parameter.
  create c, does>  ( 8b -- )  ( 8b pfa ) c@ c, c,  ;

: m5  ( 8b "name" -- )
  \ 1-byte opcode with 2-byte parameter.
  create c, does>  ( 16b -- )  ( 16b pfa ) c@ c, ,  ;

: m6  ( 8b "name" -- )
  \ Rotation of registers.
  create c, does>  ( r -- )  ( r pfa ) CB c, c@ + c,  ;

  -->

( z80-asm -- defining words for z80 instructions)

: m7  ( 8b "name" -- )
  \ Bit manipulation of registers.
  \ XXX OLD
  \ create c, does>  ( bit r -- )
  \  ( bit r pfa ) CB c, c@ + swap 8* + c,  ;
  \ XXX NEW
  create c, does>  ( r bit -- )
    ( r bit pfa ) CB c, c@ swap 8* + + c,  ;

: m8  ( 16b "name" -- )
  \ 2-byte opcodes.
  create , does>  ( -- )  ( pfa ) @ ,  ;

: m9  ( 8b "name" -- )
  \ Relative jumps.
  create c, does>  ( a -- )
    ( a pfa )  c@ c, here 1+ - ?page c,  ;

-->

( z80-asm -- defining words for z80 instructions)

: ma  ( 8b "name" -- )
  \ Index registers with register.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) c@ c, drop c,  ;

: mb  ( 8b "name" -- )
  \ Rotation with index registers.
  create c, does>  ( disp rphl -- )
    ( disp rphl pfa ) CB c, c@ c, drop c,  ;

: mc  ( 8b "name" -- )
  \ Bit manipulation with index registers.
  \ XXX OLD
  \  create c, does>  ( bit rphl disp -- )
  \   ( bit rphl disp pfa ) CB c, rot drop c@ -rot c, 8* + c,  ;
  \ XXX NEW
  create c, does>  ( disp rphl bit -- )
    ( disp rphl bit pfa )
    CB c, c@ rot drop rot c, swap 8* + c,  ;

-->

( z80-asm -- opcodes)

  \ XXX FIXME ftap

00 m1 nop 02 m3 stap 03 m3 incp 04 m3 inc 05 m3 dec 07 m1 rlca
08 m1 exaf 09 m3 addp 0A m3 ftap 0B m3 decp 0F m1 rrca 10 m9
djnz 17 m1 rla 18 m9 jr  1F m1 rra 20 m9 jrnz 22 m5 sthl 27 m1
daa 28 m9 jrz 2A m5 fthl 2F m1 cpl 30 m9 jrnc 32 m5 sta 37 m1
scf 38 m9 jrc 3A m5 fta 3F m1 ccf 76 m1 halt 80 m2 add 88 m2
adc 90 m2 sub 98 m2 sbc B8 m2 cp C1 m3 pop C2 m5 jpnz C3 m5 jp
C5 m3 push C6 m4 add# C7 m2 rst C9 m1 ret CA m5 jpz CD m5 call
CE m4 adc# D2 m5 jpnc D3 m4 out 41 m3 outbc D6 m4 sub# D9 m1
exx DA m5 jpc DB m4 in 40 m3 inbc 0DE m4 sbc# E2 m5 jppo E3 m1
exsp E6 m4 and# E9 m1 jphl EA m5 jppe EB m1 exde EE m4 xor# F2
m5 jpp F3 m1 di  F6 m4 or# F9 m1 ldsp FA m5 jpm FB m1 ei FE m4
cp# 00 m6 rlc 08 m6 rrc 10 m6 rl 18 m6 rr 20 m6 sla  28 m6 sra
38 m6 srl  40 m7 bit 80 m7 res C0 m7 set B0ED m8 ldir B8ED m8
lddr 44ED m8 neg 57ED m8 ldai 47ED m8 ldia 56ED m8 im1 5EED m8
im2 B1ED m8 cpir 6FED m8 rld -->

( z80-asm -- opcodes)

: 0outbc  ( -- )  ED c, 71 c,  ;
: jpix  ( -- )  ix-op c, jphl  ;
: ldp#  ( 16b rp -- )  8* 1+ c, ,  ;
: ld#  ( 8b r -- )  8* 06 + c, c,  ;
: ld  ( r1 r2 -- )  8* 40 + + c,  ;
: sbcp  ( rp -- )  ED c, 8* 42 + c,  ;
: adcp  ( rp1 rp2 -- )  ED c, 8* 4A + c,  ;
: stp  ( a rp -- )  ED c, 8* 43 + c, ,  ;
: ftp  ( a rp -- )  ED c, 8* 4B + c, ,  ;

: addix  ( rp -- )  ix-op c, addp  ;
: addiy  ( rp -- )  iy-op c, addp  ;

  \ Macros

: clr  ( rp -- )  0 swap ldp#  ;
: ldp  ( rp1 rp2 -- )  2dup ld 1+ swap 1+ swap ld  ;

  \ ZX Spectrum specific

CF m4 hook       \ rst 0x08
D7 m1 prt  -->   \ rst 0x16

( z80-asm -- index register opcodes)

86 ma addx 8E ma adcx 96 ma subx 9E ma sbcx A6 ma andx
AE ma xorx B6 ma orx  BE ma cpx  34 ma incx 35 ma decx
06 mb rlcx 0E mb rrcx 16 mb rlx  1E mb rrx  26 mb slax
2E mb srax 3E mb srlx 46 mc bitx 86 mc resx C6 mc setx

: ftx   ( disp rpi r -- )   nip 8* 46 + c, c,  ;
: stx   ( r disp rphl -- )  drop swap 70 + c, c,  ;
: st#x  ( 8b disp rpi -- )  drop 36 c, swap c, c,  ;
: ftpx  ( disp rpi rp -- )  3dup 1+ ftx rot 1+ -rot ftx  ;
: stpx  ( disp rpi rp -- )  3dup 1+ stx rot 1+ -rot stx  ;

-->

( z80-asm -- conditional ret and call)

  \ Condition codes for relative jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z if` compiles a `jr nz`, so `z` is the code for
  \ `jr nz`.

20 constant z  28 constant nz  30 constant cy  38 constant nc

  \ Condition codes for absolute jumps

  \ They are Z80 opcodes for the required instructions.
  \ Example `z' if` compiles a `jp nz`, so `z'` is the code for
  \ `jp nz`.

C2 constant z'  CA constant nz' D2 constant cy' DA constant nc'
E2 constant pe' EA constant po' F2 constant m'  FA constant p'

  \ Conditional ret

: ?ret  ( op -- )  8 xor 2- c,  ;

: retc  ( -- )  cy' ?ret ;    : retnc  ( -- )  nc' ?ret  ;
: retz  ( -- )  z' ?ret ;     : retnz  ( -- )  nz' ?ret  ;
: retm  ( -- )  m' ?ret ;     : retp  ( -- )  p' ?ret  ;
: retpe  ( -- )  pe' ?ret ;   : retpo  ( -- )  po' ?ret  ;

  \ Conditional call

: ?call  ( a op -- )  8 xor 2+ c, ,  ;

: callc  ( -- )  cy' ?call ;    : callnc  ( -- )  nc' ?call  ;
: callz  ( -- )  z' ?call ;     : callnz  ( -- )  nz' ?call  ;
: callm  ( -- )  m' ?call ;     : callp  ( -- )  p' ?call  ;
: callpe  ( -- )  pe' ?call ;   : callpo ( -- )  po' ?call  ;

-->

( z80-asm -- control structures with relative jumps)

  \ XXX TODO document

: >relmark  ( -- orig )  here 1-  ;
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.

: relresolve  ( orig dest -- )  1- over - ?page swap c!  ;
  \ Resolve a relative branch.

: >relresolve  ( orig -- )  here relresolve  ;
  \ Resolve a forward relative branch.

: <relresolve  ( dest -- )  here 1- swap relresolve  ;
  \ Resolve a backward relative branch.

: ahead  ( -- orig  )  18 , >relmark  ;
  \ Create a relative branch forward.
  \ Leave the origin address of a forward relative branch
  \ just compiled, to be resolved by `>relresolve`.
  \ Note: 0x18 is the Z80 opcode for `jr`.

: if  ( op -- orig cs-id )  , >relmark 0A  ;

: then  ( orig cs-id -- )  0A ?pairs >relresolve  ;

: else  ( orig cs-id -- cs-id ) \ XXX TODO document
  0A ?pairs 18 if rot swap then 0A  ;
  \ Note 0x18 is the opcode of `jr`.

: begin  (  -- dest cs-id )  <mark 0B  ;

: while  (  op -- orig cs-id )  if 2+  ;

: until  (  dest cs-id op -- )  , 0B ?pairs <relresolve  ;
  \ compile a relative conditional jump

: again  (  dest cs-id -- )  18 until  ;
  \ compile `jr`

: repeat  (  dest cs-id1 orig cs-id2 )  2swap again 2- then  ;

: step    ( dest cs-id -- )  10 until  ;  -->
  \ compile `djnz`

( z80-asm -- control structures with absolute jumps)

  \ XXX TODO document

: if'  (  op -- orig cs-id )  c, >mark 08  ;

: then'  (  orig cs-id -- )  08 ?pairs >resolve  ;

: else'  (  cs-id -- cs-id )
  08 ?pairs C3 if' rot swap then' 08  ;
  \ C3 = opcode of `jp`

: begin'  (  -- dest cs-id )  <mark 09  ;

: while'  (  op -- orig cs-id )  if' 2+  ;

: until'  (  cs-id op -- )  c, 09 ?pairs <resolve  ;

: again'  (  cs-id -- )  C3 until'  ;

: repeat'  (  dest cs-id1 orig cs-id2 )
  2swap again' 2- then'  ;

: |mark  ( -- a )  here 2-  ;
  \ Leave the address of an absolute forward reference.

: |resolve  ( a -- )  |mark swap !  ;
  \ Resolve an absolute forward reference.

-->

( z80-asm -- last opcodes and macros)

  \ `and`, `or` and `xor` are defined at the end, in order to
  \ avoid name clashes with the Forth words that have the same
  \ name:

A0 m2 and  B0 m2 or  A8 m2 xor

  \ Macro, 16-bit subtract:
: subp  ( rp -- )  a and sbcp  ;

  \ Macro to test 16-bit register for zero:
: tstp  ( rp -- )  dup a ld 1+ or  ;

  \ ; jpnext ( -- )  jpix  ; \ XXX OLD

-->

( z80-asm -- unresolved macro endm )

6 cells allocate-string
  \ Temporary space to store unresolved addresses during
  \ compilation. `pad` can not be used because it's transient
  \ and changes during the compilation. The circular string
  \ buffer is used.
  \
  \ XXX TODO -- use the heap instead, when implemented

: unresolved  ( n -- a )  cells [ dup ] literal +  ;  drop
  \ Return the address of the _n_ unresolved address.  Note:
  \ The address returned by `allocate-string` is directly
  \ compiled into `unresolved`. This saves a definition.  `dup`
  \ and `drop` are used to pass the stack check at the end of
  \ the definition.

only forth definitions also assembler

: macro  ( "name" -- )  : asm  ;
: endm  ( -- )  end-asm postpone ;  ;  immediate

decimal only forth

( calc end-calc )

need z80-asm

  \ current @  also assembler definitions
  \ XXX OLD
  \ XXX TODO

macro calc  ( -- )  exx EF c,  endm
  \ 0xEF = `rst 0x28`, call the ROM calculator

macro end-calc  ( -- )  38 c, exx  next ix ldp  endm
  \ 0x38 = ROM calculator `end-calc` command
  \
  \ XXX TODO It seems IX is not used by the calculator,
  \ so this code will work:
  \ macro end-calc  ( -- )  38 c, exx  endm

  \ current !  previous
  \ XXX OLD
  \ XXX TODO

( << >> )

  \ For dumping assembled code to screen.

  \ Credits:
  \
  \ Code adapted from Pygmy Forth.

  \ XXX TODO finish adapt

need @c+  need for

: <<  ( -- a depth )  here depth  ;
: >>  ( a depth -- )
  depth 1- - #-258 ?throw cr base @ >r hex
  dup 4 u.r space  here over - for  c@+ 3 u.r  step drop
  r> base !  space   ;

( execute-hl call-xt )

  \ Assembler macros to call any Forth word from code words.

  \ Credits:
  \
  \ Code inspired by Spectrum Forth-83, where similar code is
  \ embedded in `KEY` and `PAUSE` to call a xt hold in a
  \ variable. The code has been converted from DTC to ITC and
  \ factored to two assembler macros in order to make it
  \ reusable.

macro execute-hl  ( -- )
  \ Compile an `execute` with the xt hold in HL.
  here 6 + bc ldp# \ point IP to phony_compiled_word
  next2 jp  \ execute the xt in HL
  \ phony_compiled_word:
  here cell+ ,  \ point to the phony xt following
  here cell+ ,  \ phony xt, point to the code following
  endm

  \ XXX NOTE -- If ever the system is converted from ITC to
  \ DTC, `execute-hl` has to be modified.

macro call-xt  ( xt -- )
  \ Compile a call to _xt_.
  \ This is the low-level equivalent of `execute`.
  hl ldp#  execute-hl
  endm

  \ }}} =======================================================
  \ Address register {{{

( a! a@ )  \ ==addressregister==

  \ Address register store and fetch words.

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

  \ Note by Gary Lancaster in the Z88 CamelForth source file:
  \ Sadly, there aren't any spare registers to make this as
  \ efficient as it could be. However, it can still give a
  \ useful improvement in loops, and in many cases also results
  \ in cleaner-looking code.

variable a

code a!  ( a -- )
  \ Set the address register.
  E1 c,  22 c, a ,  jpnext
    \ pop hl
    \ ld (a),hl
    \ jp (ix)
  end-code

code a@  ( -- a )
  \ Get the address register.
  2A c, a ,  C3 c, pushhl ,
    \ ld hl,(a)
    \ jp pushhl
  end-code

( !a @a )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need a!

code !a  ( u -- )
  \ Store cell at `a`.
  D1 c,  2A c, a ,  70 03 + c,  23 c,  70 04 + c,  jpnext
    \ pop de
    \ ld hl,(a)
    \ ld (hl),e
    \ inc hl
    \ ld (hl),d
    \ jp (ix)
  end-code

code @a  ( -- u )
  \ Fetch cell at `a`.
  2A c, a ,  5E c,  23 c,  66 c,  68 03 + c,  C3 c, pushhl ,
    \ ld hl,(a)
    \ ld e,(hl)
    \ inc hl
    \ ld h,(hl)
    \ ld l,e
    \ jp pushhl
  end-code

( c!a c@a )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need a!

code c!a  ( c -- )
  \ Store char at `a`.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,            \ ld (hl),e
  jpnext                \ jp (ix)
  end-code

code c@a  ( -- c )
  \ Fetch char at `a`.
  2A c, a ,             \ ld hl,(a)
  6E c,                 \ ld l,(hl)
  26 c, 00 c,           \ ld h,0
  C3 c, pushhl ,        \ jp pushhl
  end-code

( !a+ @a+ )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need a!

code !a+  ( u -- )
  \ Store cell at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  70 04 + c,  23 c,     \ ld (hl),d  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code @a+  ( -- u )      \ Fetch cell at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  56 c,  23 c,          \ ld d,(hl)  inc hl
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

( c!a+ c@a+ )

  \ Credits:
  \
  \ Code adapted from Z88 CamelForth.

need a!

code c!a+  ( c -- )
  \ Store char at `a` with increment.
  D1 c,                 \ pop de
  2A c, a ,             \ ld hl,(a)
  70 03 + c,  23 c,     \ ld (hl),e  inc hl
  22 c, a ,  jpnext     \ ld (a),hl  jp (ix)
  end-code

code c@a+  ( -- c )
  \ Fetch char at `a` with increment.
  2A c, a ,             \ ld hl,(a)
  5E c,  23 c,          \ ld e,(hl)  inc hl
  06 c, 00 c,           \ ld d,0
  22 c, a ,             \ ld (a),hl
  D5 c,  jpnext         \ push de  jp (ix)
  end-code

  \ }}} =======================================================
  \ Common heap {{{

( heap )

  \ An implementation of the Forth-94 Memory-Allocation Word
  \ Set.

  \ XXX Note: 1614 bytes used!

  \ XXX TODO use top of memory instead of dictionary space?
  \ problem: memory banks could not be used at the same time.
  \
  \ XXX TODO use a memory bank instead of dictionary space?
  \ problem: only words below 0xC000 could manipulate the heap.

  \ Credits:
  \
  \ Adapted from code written by Gordon Charlton, 1994:

  \ This is freeware, copyright Gordon Charlton, 12th of
  \ September 1994.  Copy and distribute it. Use it. Don't mess
  \ with this file. Acknowledge its use. I make no guarentees
  \ as to its fitness for any purpose. Tell me about any bugs.
  \ Tell me how much you like it.

  \ <gordon at charlton dot demon dot co dot uk>

  \ There are five broad areas that the program covers;

  \      1, General purpose extensions to the Forth system.

  \      2, Creation of the heap and associated use of the data
  \      space.

  \      3, Allocation of space from the heap.

  \      4, Releasing space back to the heap.

  \      5, Altering the size of allocated heap space.

  \ The ANS word set consists of three words, `allocate`,
  \ `free`, and `resize` which give the minimum functionality
  \ required to use the heap. These are given in areas 3, 4 and
  \ 5 respectively.

  \ The heap is maintained as a doubly linked ordered circular
  \ list of nodes with an additional field noting the size of
  \ each node and whether it is in use. The size of the heap is
  \ specified by the constant `heapsize`. the constant
  \ `hysteresis` controls the amount of spare space that is
  \ added to an allocation, to reduce the need for block moves
  \ during resizing.

  \ Initially there is only one node, the size of the heap.
  \ Aditional nodes are created by dividing an existing node
  \ into two parts. Nodes are removed by marking as free, and
  \ merging with adjoining free nodes. Nodes are altered in
  \ size by merging with a following free node, if possible,
  \ and a node being created above the new size of the node, if
  \ needed, or by allocating a new node and block moving the
  \ data field if necessary.

  \ Finding an available node is done by sequential search and
  \ comparison. The first node to be found that is large enough
  \ is used for allocation. Each search starts from the node
  \ most recently allocated, making this a "nextfit" algorithm.
  \ The redundancy in the head fields is required to optimise
  \ the search loop, as is the use of a sentinel to terminate
  \ the search once every node has been looked at, by always
  \ succeeding. A final refinement is the use of the sign bit
  \ of the size field to mark "in-use" nodes so that they are
  \ disregarded without a separate test.

also forth definitions
need wid-of
vocabulary heap-voc  wid-of heap-voc constant heap-wordlist
also heap-voc definitions

  \ XXX TODO -- alternative
  \ forth-wordlist set-current
  \ wordlist heap-wordlist

  \ **1** General Purpose Extensions

0 1 2 um/mod nip 1- constant maxpos
  \ XXX TODO use `environment?` instead when available

  \ The largest positive single length integer.

  \ **2** Heap Creation

  \ ANSI Heap  --  Constants

256 cells constant heapsize

  \ Number of address units of data space that the heap
  \ occupies.

4 cells 1- constant hysteresis

  \ Node lengths are rounded up according to the value of
  \ `hysteresis` to reduce the number of block moves during
  \ `resize` operations. The value of this constant must be one
  \ less than a power of two and at least equal to one less
  \ than the size of a cell.

3 cells constant headsize

  \ A node on the heap consists of a three cell head followed
  \ by a variable length data space. The first cell in the head
  \ points to the next node in the heap. The second cell
  \ indicates the size of the node, and the third points to the
  \ previous node. The second cell is negated to indicate the
  \ node is in use. The heap consists of a doubly linked
  \ circular list. There is no special notation to indicate an
  \ empty list, as this situation cannot occur.

: adjustsize ( n -- n)  headsize +  hysteresis or  1+  ;

  \ The amount of space that is requested for a node needs
  \ adjusting to include the length of the head, and to
  \ incorporate the hysteresis.

0 adjustsize constant overhead

  \ The size of the smallest possible node.

  \ ANSI Heap  --  Structure

create sentinel  here cell+ ,  maxpos ,  0 ,  0 ,

  \ A dummy node used to speed up searching the heap. The
  \ search, which is for a node larger than or equal to the
  \ specified size will always succeed.  The cell that points
  \ to the next node is set up so that the there is a zero
  \ three cells ahead of where it points, where the pointer to
  \ the previous node (ie the sentinel) should be. This is a
  \ special value that indicates the search has failed.

create heap  heapsize allot

  \ The heap is as described in `headsize`.

variable nextnode  -->

  \ Searching is done using a "nextfit" algorithm. `nextnode`
  \ points to the most recently allocated node to indicate
  \ where the next search is to start from.

( heap )

: >size ( addr1 -- addr2)  cell+  ;

  \ Move from the "next" cell in the node head to the "size"
  \ cell. Within the word set nodes are referred to by the
  \ address of the "next" cell.  Externally they are referred
  \ to by the address of the start of the data field.

: >prev ( addr1 -- addr2)  [ 2 cells ] literal +  ;

  \ Move from the "next" cell to the "previous" cell.

: init-heap (  )
  heap dup nextnode !
  dup dup !
  dup heapsize  over >size !
  >prev !  ;

  \ Initially the heap contains only one node, which is the
  \ same size as the heap. Both the "next" cell and the
  \ "previous" cell point to the "next" cell, as does
  \ `nextnode`.

init-heap

  \ **3** Heap Allocation

  \ ANSI Heap  --  List Searching

: attach ( addr)
  >prev @  dup sentinel rot !  sentinel >prev !  ;

  \ The sentinel is joined into the nodelist. The "next" field
  \ of the node preceding the one specified (_addr_) is set to
  \ point to the sentinel, and the "prev" field of the sentinel
  \ to point to the node that points to the sentinel.

: search  ( addr size -- addr|0)
  >r begin 2@ swap R@ < invert until
  r> drop  >prev @  ;

  \ Search the nodelist, starting at the node specified
  \ (_addr_), for a free node larger than or equal to the
  \ specified _size_.  Return the address of the first node
  \ that matches, or zero for no match. The heap structure is
  \ set up to make this a near optimal search loop. The "size"
  \ field is next to the "next" field so that both can be
  \ collected in a single operation (2@). Nodes in use have
  \ negated sizes so they never match the search. The
  \ "previous" field is included to allow the search to
  \ overshoot the match by one node and then link back outside
  \ the loop, rather than remembering the address of the node
  \ just examined. The sentinel removes the need for a separate
  \ test for failure. `search` assumes the sentinel is in
  \ place.

: detach ( addr)  dup >prev @ !  ;

  \ Remake the link from the node prior to the one specified to
  \ the one specified. This will remove the sentinel if it is
  \ attached here. (It will be.)

-->

( heap )

: findspace ( size -- addr|0)  nextnode @
           dup      attach
           dup rot  search
           swap     detach  ;

  \ Search the nodelist for a node larger or equal to that
  \ specified. Return the address of a suitable node, or zero
  \ if none found. The search starts at the node pointed to by
  \ `nextnode`, the sentinal temporarily attached, the search
  \ proceeded with and the sentinel detached.


  \ ANSI Heap  --  Head Creation

: fits ( size addr -- flag)  >size @ swap -  overhead  <  ;

  \ Returns _true_ if the size of the node specified is the
  \ same as the specified size, or larger than it by less than
  \ the size of the smallest possible node. Returns _false_
  \ otherwise.

: togglesize ( addr)  >size dup @  negate swap !  ;

  \ Negate the contents of the "size" field of the specified
  \ node. If the node was available it is marked as in use, and
  \ vice versa.

: next! ( addr)  nextnode !  ;

  \ Make the specified node the starting node for future
  \ searches of the node list.

: sizes! ( size addr -- addr)
  2dup + >r  >size 2dup @ swap -
  R@ >size !   swap negate swap !  r>  ;

  \ Given a free node (_addr_), reduce its size to that
  \ specified and mark it as in use. Start to construct a new
  \ node within the specified node beyond its new length, by
  \ storing the length of the remainder of the node in the size
  \ field of the new node. Return the address of the partially
  \ constructed node.

: links! ( addr1 addr2)
  2dup swap @  2dup  swap !  >prev !
  2dup >prev !   swap !  ;


  \ _Addr1_ is an existing node. _Addr2_ is the address of a
  \ new node just above the existing node. Break the links from
  \ the existing node to the next node and from the next node
  \ to the existing node and join the new node to them.


  \ ANSI heap  --  Node Construction  ALLOCATE

: newnode ( size addr)  tuck sizes!  links!  ;

  \ Given a free node at addr split it into an in-use node of
  \ the specified size and a new free node above the in-use
  \ node.

-->

( heap )

: makenode ( size addr)
  2dup fits if  togglesize drop  else  newnode  then  ;

  \ Given a free node at addr make an in-use node of the
  \ specified size and free the remainder, if there is any
  \ usable space left.

forth-wordlist set-current

: allocate ( u -- addr ior)
  dup 0< if  -59  \ `allocate` error code
       else  adjustsize
       dup findspace
       dup if  dup next!
         tuck makenode
         headsize +  0
         else  drop -59  \ `allocate` error code
         then
       then  ;

heap-wordlist set-current  -->

  \ Make an in-use node with a data field at least _u_ address
  \ units long.  Return the address of the data field and an
  \ ior of 0 to indicate success.  If the space is not
  \ available return any old number and the standard ior.  The
  \ standard specifies that the argument to `allocate` is
  \ unsigned. As the implementation uses the sign bit of the
  \ size field for its own purposes any request for an amount
  \ of space greater than `maxpos` must fail. As this would be
  \ a request for half the addressable memory or more this is
  \ not unreasonable.

( heap )

  \ **4** Releasing Space

  \ ANSI heap  --  Head Destruction

: mergesizes ( addr1 addr2)
  >size @ swap >size +!  ;

  \ Make the size field of the node at _addr1_ equal to the sum
  \ of the sizes of the two specified nodes. In usage the node
  \ at _addr2_ will be the one immediately above _addr1_.

: mergelinks ( addr1 addr2)
  @ 2dup swap !  >prev !  ;

  \ The node at _addr2_ is removed from the node list. As with
  \ `mergesizes` the node at _addr2_ will be immediately above
  \ that at _addr1_. Destroy the link from node1 to node2 and
  \ relink node1 to the node above node2. Destroy the backward
  \ link from the node above node2 and relink it to node1.

: jiggle (  )
  nextnode @ @  >prev @  next!  ;

  \ There is a possibility when a node is removed from the node
  \ list that `nextnode` may point to it. This is cured by
  \ making it point to the node prior to the one removed. We do
  \ not want to alter the pointer if it does not point to the
  \ removed node as that could be detrimental to the efficiency
  \ of the nextfit search algorithm. Rather than testing for
  \ this condition we jiggle the pointer about a bit to settle
  \ it into a linked node. This is done for reasons of
  \ programmer amusement. Specifically `nextnode` is set to
  \ point to the node pointed to by the "previous" field of the
  \ node pointed to in the "next" field of the node pointed to
  \ by `nextnode`. Ordinarily this is a no-op (ie I am my
  \ father's son) but when the node has had its links merged it
  \ sets `nextnode` to point to the node prior to the node it
  \ pointed to (ie when I died my father adopted my son, so now
  \ my son is my father's son).

: merge ( addr)
  dup @ 2dup mergesizes
       mergelinks  jiggle  ;

  \ Combine the node specified with the node above it. Merge
  \ the sizes, merge the lengths and jiggle.


  \ ANSI Heap  --  Node Removal

: ?merge ( addr1 addr2)
  >size @ 0> if
    dup dup @
    u< if  dup merge  then
  then  drop  ;  -->

  \ Merge the node at _addr1_ with the one above it on two
  \ conditions, firstly that the node at _addr2_ is free, and
  \ secondly that the node pointed to by the next field in
  \ _addr1_ is actually above _addr1_ (ie that it does not wrap
  \ around because it is the topmost node). In usage _addr2_
  \ will be either _addr1_ or the node above it. In each
  \ instance the other affected node (either the node above
  \ _addr1_ or _addr1_) is known to be free, so no test is
  \ needed for this.

( heap )

: ?mergenext ( addr)  dup @ ?merge  ;

  \ Merge the node following the specified node with the
  \ specified node, if following node is free.

: ?mergeprev ( addr)  >prev @ dup ?merge  ;

  \ Merge the specified node with the one preceding it, if the
  \ preceding node is free.

forth-wordlist set-current

: free ( addr -- ior)
  headsize -  dup togglesize  dup ?mergenext  ?mergeprev  0  ;

heap-wordlist set-current

  \ Mark the specified in-use word as free, and merge with any
  \ adjacent free space. As this is a standard word addr is the
  \ address of the data field rather than the "next" field. As
  \ there is no compelling reason for this to fail the ior is
  \ zero.


  \ **5** Resizing Allocated Space

  \ ANSI Heap  --  Node Repairing

variable stash

  \ the `resize` algorithm is simplified and made faster by
  \ assuming that it will always succeed. `stash` holds the
  \ minimum information required to make good when it fails.

: savelink ( addr)  @ stash !  ;

  \ saves the contents of the `>next` field of the node being
  \ `resize`d in `stash` (above).

: restorelink ( addr)  stash @  swap !  ;

  \ Converse operation to `savelink` (above).

: fixprev ( addr)  dup >prev @ !  ;

  \ The `>next` field of the node prior to the node being
  \ `resize`d should point to the node being `resize`d. it may
  \ very well do already, but this makes sure.

: fixnext ( addr)  dup @ >prev !  ;

  \ The `>prev` field of the node after the node resized may
  \ need correcting.  This corrects it whether it needs it or
  \ not.  (Its quicker just to do it than to check first.)

: fixlinks ( addr)  dup fixprev  dup fixnext  @ fixnext  ;

  \ `resize` may very well merge its argument node with the
  \ previous one. It may very well merge that with the next
  \ one. This means we need to fix the previous one, the next
  \ one and the one after next. To extend the metaphor started
  \ in the description of `jiggle` (above), not only did I die,
  \ but my father did too. This brings my grandfather into the
  \ picture as guardian of my son. Now to confound things we
  \ have all come back to life. I still remember who my son is,
  \ and my father remembers who his father is. Once I know who
  \ my father is I can tell my son that I am his father, I can
  \ tell my father that I am his son and my grandfather who his
  \ son is. Thankfully we are only concerned about the male
  \ lineage here! (In fact nodes reproduce by division, like
  \ amoebae, which is where the metaphor breaks down -- (1)
  \ they are sexless and (2) which half is parent and which
  \ child?)

-->

( heap )

: fixsize ( addr)
  dup >size @ 0>
  if  dup @  2dup <
      if    over - swap >size !  else  2drop  then
  else  drop  then  ;

  \ Reconstruct the size field of a node from the address of
  \ the head and the contents of the `>next` field provided
  \ that the node is free and it is not the topmost node in the
  \ heap (ie there is no wraparound). Both these conditions
  \ need to be true for the node to have been merged with its
  \ successor.

: fixsizes ( addr)  dup fixsize  >prev @ fixsize  ;

  \ The two nodes whose size fields may need repairing are the
  \ one passed as an argument to `resize` (damaged by
  \ `?mergenext`) and its predecessor (damaged by `?mergeprev`).

: repair ( addr)
  dup restorelink
  dup fixlinks  dup fixsizes
  togglesize  ;

  \ Make good the damage done by `resize`. Restore the `>next`
  \ field, fix the links, fix the size fields and mark the node
  \ as in-use. Note that this may not restore the system to
  \ exactly how it was. In particular the pointer `nextnode`
  \ may have moved back one or two nodes by virtue of having
  \ been `jiggle`d about if it happened to be pointing to the
  \ wrong node. This is not serious, so I have chosen to ignore
  \ it.


  \ ANSI Heap  --  Node Movement

: toobig? ( addr size -- flag)
  swap  >size @  >  ;

  \ _Flag_ is true if the node at _addr_ is smaller than the
  \ specified size.

-->

( heap )

: copynode ( addr1 addr2)
  over >size @  headsize -
  rot  headsize + rot rot move  ;

  \ Move the contents of the data field of the node at _addr1_
  \ to the data field at _addr2_. Assumes _addr2_ is large
  \ enough. It will be.

: enlarge ( addr1 size -- addr2 ior)
  over  ?mergeprev
  allocate dup >r
  if  swap repair  else  tuck copynode  then  r>  ;

  \ Make a new node of the size specified. Copy the data field
  \ of _addr1_ to the new node. Merge the node at addr1 with
  \ the one preceding it, if possible. This last behaviour is
  \ to finish off removing the node at _addr1_. The word
  \ `adjust` (below) starts removing the node. The node is
  \ removed before allocation to increase the probability of
  \ `allocate` succeeding. The address returned by `enlarge` is
  \ that returned by `allocate`, which is that of the data
  \ field, not the head. If the allocation fails repair the
  \ damage done by removing the node at _addr1_.


  \ ANSI Heap  --  Node Restructuring

: adjust ( addr1 size1 -- addr2 size2)
  adjustsize >r
  headsize -
  dup savelink
  dup togglesize
  dup ?mergenext r>  ;

  \ _Addr1_ points to the data field of a node, not the "next"
  \ field. This needs correcting. _Size1_ also needs adjusting
  \ as per `adjustsize`. In addition it is easier to work with
  \ free nodes than live ones as the size field is correct,
  \ and, as we intend to change the nodes size we will
  \ inevitably want to muck about with the next node, if its
  \ free, so lets merge with it straight away. Sufficient
  \ information is first saved to put the heap back as it was,
  \ if necessary.  Now we are ready to get down to business.

-->

( heap )

forth-wordlist set-current

: resize ( addr1 u -- addr2 ior)
  dup 0<  if  drop -61  \ `resize` error code
          else  adjust  2dup toobig?
                if enlarge
                else  over makenode headsize +  0  then
          then  ;

  \ Resize the node at _addr1_ to the specified size. Return
  \ the address of the resized node _addr2_ along with an _ior_
  \ of zero if successful and -61 if not. _Addr2_ may be the
  \ same as, or different to, _addr1_.  If _ior_ is non-zero
  \ then _addr2_ is not meaningful. Being a standard word the
  \ arguments need adjusting to the internal representation on
  \ entry, and back again on exit. If after the first merge the
  \ requested size is still too large to reuse the specified
  \ node then it is moved to a larger node and the specified
  \ node released. If, on the other hand the request is not too
  \ big for the node, then we remake the node at the right
  \ length, and free any space at the top using `makenode`,
  \ which has just the right functionality.  In this case the
  \ ior is zero. As this is a standard word it takes an
  \ unsigned size argument, but excessive requests fail
  \ automatically, as with `allocate`.

( create-heap )

  \ XXX UNDER DEVELOPMENT

  \ Inspired by:
  \
  \ Gestor de memoria dinmica (version 1)
  \ By Javier Gil
  \ From his book _Introduccin a Forth_ (2007-01)

  \ 2015-11-18: Start.
  \ 2015-11-21: Changes.

need value  need set-bit  need reset-bit  need bit?
need reserve  need alias

0 value heap  ( -- a )
  \ Address of the current heap.

8 constant address-unit-bits
16 value /chunk \ bytes per chunk

: groups ( n1 n2 -- n3 )  /mod swap 0<> abs +  ;
  \ Return the number _n3_ of groups of _n2_ elements, needed
  \ to hold _n1_ elements.

: bytes>chunks ( n1 -- n2 )  /chunk groups  ;
  \ Return the chunks _n2_ required to allocate _n1_ bytes.

: chunks>bytes ( n1 -- n2 )  address-unit-bits groups  ;
  \ Return the bytes _n2_ required for a bitmap of _n1_ chunks.

' heap alias heap-chunks  ( -- a )
  \ Address that holds the number of chunks of the current
  \ heap.

: heap-unused-chunks  ( -- a )  heap-chunks cell+  ;
  \ Address that holds the number of unused chunks of the
  \ current heap.

: heap-map  ( -- a )  heap-unused-chunks cell+  ;
  \ Address of the current heap's map.

: /heap-map  ( -- n )  heap-chunks @ chunks>bytes  ;
  \ Number of bytes of the current heap's map.

: heap-data  ( -- a ) heap-map /heap-map +  ;  -->
  \ Address of the current heap's data space.

( create-heap )

: (mapbit)  ( n1 -- n2 ca )
  address-unit-bits /mod heap-map +  ;
  \ n1 = number of bit in the bitmap
  \ n2 = number of bit in the byte at _a2_
  \ ca = address of the bitmap that holds bit _n2_

: mapbit ( n1 -- a2 b n2 )  (mapbit) dup @ rot  ;
  \ n1 = number of bit in the bitmap
  \ a2 = address of the correspondent byte
  \ b =  correspondent byte
  \ n2 = number of bit in _b_

: used-chunk? ( n -- f )  (mapbit) @ swap bit?  ;
  \ Is chunk _n_ used?

: use-chunk ( n -- )  mapbit set-bit swap !  ;
  \ Mark chunk _n_ as used.

: free-chunk ( n -- )  mapbit reset-bit swap !  ;
  \ Mark chunk _n_ as free.

: allocated>chunks  ( a -- n )  cell- @  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its number of chunks.

: allocated>index  ( a -- n )  heap-data - /chunk /  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n_ in the map of the heap
  \ chunks.

: allocated>map  ( a -- n1 n2 )
  dup allocated>index swap allocated>chunks  ;
  \ Convert the address _a_ of an allocated space in the
  \ current heap to its index _n1_ in the map of heap chunks
  \ and the number _n2_ of ocuppied chunks.

-->

( create-heap )

: locate-chunks  ( n1 -- n1 n2 0 | ior )
  0 tuck  ( n2 n1 count )
  heap-chunks @ 0 do  ( n2 n1 count )
    i used-chunk? if  drop >r i 1+ r> 0  else  1+  then
    2dup = if  drop swap 0 unloop exit  then
  loop  2drop drop -59  ;
  \ Locate _n1_ consecutive free chunks in the current heap.
  \ If succesful, _n2_ is the first chunk of the group;
  \ else return _ior_ -59, the error code for `allocate`.

: chunk>address  ( n1 -- a )  /chunk * heap-data +  ;

: (allocate)  ( n1 n2 -- a )
  dup chunk>address >r
  swap bounds do  i use-chunk  loop
  r>  ;
  \ Allocate _n1_ chunks of the current heap, starting from
  \ chunk _n2_; return the address _a_ of the allocated space.

-->

( create-heap )

  \ User interface

: create-heap ( n "name" -- )
  create  bytes>chunks dup ,  0 ,
            \ max chunks and free chunks
          dup chunks>bytes reserve drop
            \ bitmap
          /chunk * allot  ;
            \ data space
  \ Create a new heap "name" to hold _n_ bytes.

: allocate  ( n -- a ior )
  bytes>chunks locate-chunks ?dup ?exit  (allocate) 0  ;

: free  ( a -- ior )
  allocated>map dup >r
  bounds do  i free-chunk  loop
  r> heap-unused-chunks +! 0  ;

  \ XXX TODO -- update with `resize`
  \ doc{
  \
  \ free  ( a -- ior )
  \
  \ Return the contiguous region of data space indicated by _a_
  \ to the system for later allocation. _a_ shall indicate a
  \ region of data space that was previously obtained by
  \ `allocate`.
  \
  \ If the operation succeeds, _ior_ is zero. If the operation
  \ fails, _ior_ is -60.
  \
  \ Origin: Forth-94 (MEMORY), Forth-2012 (MEMORY).
  \
  \ }doc


: empty-heap  ( -- )  heap-chunks @ 0 do  i free-chunk  loop  ;
  \ Empty the current heap, setting all chunks free.

: .heap ( -- )
  heap-chunks @ 0 do
    i used-chunk? if  [char] x  else  [char] -  then  emit
  loop  ;

  \ Print the map of the current heap. Occupied chunks are
  \ marked with a "x"; free chunks are marked with a "-".

  \ }}} =======================================================
  \ Leo Brodie's DOER ... MAKE construct {{{

( doer )

  \ Credits:
  \
  \ Code adapted from PFE.
  \ Original code by Leo Brodie, 1983,
  \ published on _Thinking Forth_, Appendix A. Public domain.

: doer-noop ;

: doer  ( "name" -- )
  \ Define a word whose behaviour is vectorable.
  create  ['] doer-noop >body ,
  does>  ( pfa ) @ >r ;

: (make)
  \ Stuff the address of further code into the parameter field
  \ of a doer word.
  r> dup cell+ dup cell+
    ( a1 a2 a2 )
    \ a1 = address of an optional continuation after `;and`,
    \      or zero
    \ a2 = address of the doer word
    \ a3 = address of the code to associate the doer word with
  swap @ >body !
    \ Get the pfa of the doer word and store the code address
    \ into it.
  @ ?dup if  >r  then ;
    \ Manage the optional continuation after `;and`.

variable >;and
  \ Hold the address of optional continuation pointer.

: make
  \ Used interpretively:
  \   make doer-name forth-code ;
  \ Or inside a definition:
  \   : definition  make doer-name forth-code  ;
  compiling? if     postpone (make)  here >;and ! 0 ,
             else   here ' >body ! ]  then  ; immediate

: ;and  ( -- )  postpone exit  here >;and @ !  ; immediate
  \ Allow continuation of the "making" definition.

: undo  ( "name" -- )  ['] doer-noop >body  ' >body ! ;
  \ Make the doer word "name" safe to execute.

( doer-test )

need doer

doer test
  .( Test 1: ) test
make test  cr ." test 2" ;
  .( Test 2: ) test
: change    make test ." test 3" ;and  test ;
change
  .( Test 3: ) test
undo test
  .( Test 4: ) test

  \ }}} =======================================================
  \ Floating point after Spectrum Forth-83 {{{

  \ XXX TODO

  \ }}} =======================================================
  \ Floating point using the ROM calculator {{{

  \ XXX UNDER DEVELOPMENT

  \ The ROM calculator is used for implementing most words of
  \ the Forth-2012 FLOATING and FLOATING EXT word sets, and
  \ some words not provided by Forth-2012.

  \ XXX FIXME -- The ROM calculator calls the BASIC error
  \ routines, what crashes the system.

( fp-load )

need +thru
1 9 +thru

( float float+ floats s>f f>s )

5 constant float

: float+  ( n1 -- n2 )  float +  ;
: floats  ( n1 -- n2 )  float *  ;

need z80-asm  need calc

code s>f  ( n -- ) ( F: -- r )
  exx  bc pop  2D2B call  exx  jpnext  end-code

code f>s  ( -- n ) ( F: r -- )
  exx  2DA2 call  bc push  exx  jpnext  end-code

  \ code f>d  ( -- d ) ( F: r -- )
  \  end-code
  \  \ XXX TODO

( fvariable )

: fvariable  ( "name" -- )  create  float allot  ;

: f!  ( a -- ) ( F: r -- )  ;
  \ XXX TODO

: f,  ( -- )  here float allot f!  ;

: fconstant  ( "name" -- )  ( F: f -- )  create  f,  does>  ;
  \ XXX TODO

( f** f+ f- f/ )

  \ Operators

need z80-asm  need calc

code f**  ( F: r1 -- r2 )
  calc 06 c, end-calc jpnext  end-code
code f+  ( F: r1 r2 -- r3 )
  calc 0F c, end-calc jpnext  end-code
code f-  ( F: r1 r2 -- r3 )
  calc 03 c, end-calc jpnext  end-code
code f/  ( F: r1 r2 -- r3 )
  calc 05 c, end-calc jpnext  end-code

  \ XXX TODO
  \ code fmax  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code
  \ code fmin  ( F: r1 r2 -- r1|r2 ) calc end-calc jpnext  end-code

code fsign  ( F: r1 -- r2 )
  calc 29 c, end-calc jpnext  end-code

( fabs fexp fln fmod fnegate fsqrt )

  \ Operators

need z80-asm  need calc

code fabs  ( F: r1 -- r2 )
  calc 2A c, end-calc jpnext  end-code
code fexp  ( F: r1 -- r2 )
  calc 26 c, end-calc jpnext  end-code
code fmod  ( F: r1 -- r2 )
  calc 32 c, end-calc jpnext  end-code
code fnegate  ( F: r1 -- r2 )
  calc 1B c, end-calc jpnext  end-code

code fln  ( F: r1 -- r2 )
  calc 25 c, end-calc jpnext  end-code
code fsqrt  ( F: r1 -- r2 )
  calc 28 c, end-calc jpnext  end-code

code fround  ( F: r1 -- r2 )
  calc 3A c, end-calc jpnext  end-code

( f0 f1 fhalf fpi2/ f10 )

  \ Constants

need z80-asm  need calc

code f0  ( F: -- r1 )
  calc A0 c, end-calc jpnext  end-code
code f1  ( F: -- r1 )
  calc A1 c, end-calc jpnext  end-code
code fhalf  ( F: -- r1 )
  calc A2 c, end-calc jpnext  end-code
code fpi2/  ( F: -- r1 )
  calc A3 c, end-calc jpnext  end-code
code f10  ( F: -- r1 )
  calc A4 c, end-calc jpnext  end-code

( jp-f>s )

need z80-asm  need f>s

  \ XXX TODO -- optimize; `f>s` has another pair of `exx`. A
  \ specific word will be faster and smaller, instead of
  \ `end-calc jp-f>s`.

  \ XXX FIXME -- `macro` is not recognized here.

macro jp-f>s  ( -- )
  ['] f>s call-xt
  endm

( f0< f0= f< f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm  need calc  need jp-f>s

code f0<  ( F: r1 -- rwf )
  calc 36 c, 1B c, end-calc jp-f>s  end-code

code f0=  ( F: r1 -- rwf )
  calc 30 c, 1B c, end-calc jp-f>s  end-code

code f0<>  ( F: r1 -- rwf )
  calc 30 c, 30 c, 1B c, end-calc jp-f>s  end-code

code f<  ( F: r1 r2 -- rwf )
  calc 0D c, 1B c, end-calc jp-f>s  end-code

  \ code f~ \ XXX TODO

( f<= f<> f= f> f>= )

  \ Comparisons

  \ XXX FIXME -- the flag must be returned on the data stack

need z80-asm

code f<=  ( F: r1 r2 -- rwf )
  calc 09 c, 1B c, end-calc jp-f>s  end-code

code f<>  ( F: r1 r2 -- rwf )
  calc 0B c, 1B c, end-calc jp-f>s  end-code

code f=  ( F: r1 r2 -- rwf )
  calc 0E c, 1B c, end-calc jp-f>s  end-code

code f>  ( F: r1 r2 -- rwf )
  calc 0C c, 1B c, end-calc jp-f>s  end-code

code f>=  ( F: r1 r2 -- rwf )
  calc 0A c, 1B c, end-calc jp-f>s  end-code

( fdrop fdup fswap fover frot )

  \ Stack

need z80-asm  need float  need calc

23651 constant fp0  23653 constant fp  : fp@  ( -- a )  fp @  ;
  \ 23651 = STKBOT system variable
  \ 23653 = STKEND system variable

: fdepth  ( -- n )  fp@ fp0 @ - float /  ;

code fdrop  ( F: r1 -- )
  calc 02 c, end-calc jpnext  end-code

code fdup  ( F: r1 -- r1 r1 )
  calc 31 c, end-calc jpnext  end-code

code fswap  ( F: r1 r2 -- r2 r1 )
  calc 01 c, end-calc jpnext  end-code

code fover  ( F: r1 r2 -- r1 r2 r1 )
  calc C2 c, C1 c, E1 c, E2 c, E1 c, end-calc jpnext  end-code

code frot  ( F: r1 r2 r3 -- r2 r3 r1 )
  calc C3 c, C2 c, C1 c, E2 c, E3 c, E1 c, end-calc
  jpnext  end-code

( facos fasin fatan fcos fsin ftan )

  \ Trigonometrical functions

need z80-asm  need calc

code facos  ( F: r1 -- r2 )
  calc 23 c, end-calc jpnext  end-code
code fasin  ( F: r1 -- r2 )
  calc 22 c, end-calc jpnext  end-code
code fatan  ( F: r1 -- r2 )
  calc 24 c, end-calc jpnext  end-code
code fcos  ( F: r1 -- r2 )
  calc 20 c, end-calc jpnext  end-code
code fsin  ( F: r1 -- r2 )
  calc 1F c, end-calc jpnext  end-code
code ftan  ( F: r1 -- r2 )
  calc 21 c, end-calc jpnext  end-code

  \ }}} =======================================================
  \ Editor {{{

( editor )

  \ This is the editor included with Specforth (also known as
  \ Artic Forth), a fig-Forth for ZX Spectrum. It has been
  \ adapted to Solo Forth.
  \
  \ Descriptions and stack comments have been added after the
  \ Specforth manual, the Abersoft Forth manual and the book
  \ _Systems Guide to fig-Forth_. The word `copy` has been
  \ adapted from Abersoft Forth. The word `text` has been
  \ rewritten.

  \ Credits:
  \
  \ Specforth Editor V1.1
  \ Copyright 1983 by Artic Computing Ltd.
  \ Written by Chris A. Thornton, 1983
  \ Modified by Marcos Cruz (programandala.net), 2015

only forth definitions

need list  need update  need flush  need parse-line

vocabulary editor  also editor definitions  hex

  \ XXX OLD
  \ XXX FIXME `1 text`, used by two words, corrupts the system.
  \ How to get the text till the end of the line?
  \ : text  ( c "text<c>" -- )
  \  here c/l 1+ blank word pad c/l 1+ cmove  ;
  \ Parse a text string delimited by character _c_ and store it
  \ into `pad`, blank-filling the remainder of `pad` to `c/l`
  \ characters.

: text  ( "text<eol>" -- )
  pad c/l 1+ blank  parse-line  pad place  ;
  \ Get the text string until end of line and store it
  \ into `pad` as a counted string, blank-filling the remainder
  \ of `pad` to `c/l` characters.

: line  ( n -- a )
  dup FFF0 and #-266 ?throw scr @ line>string drop  ;
  \ Leave address _a_ of the beginning of line _n_ in the
  \ current block buffer.  The block number is in `scr`.
  \ Read the disk block from  disk if it is not already in the
  \ disk buffer.

variable r#
  \ Location of the editing cursor.

: #locate  ( -- n1 n2 )  r# @ c/l /mod  ;
  \ From the cursor pointer `r#` compute the line number _n2_
  \ and the character offset _n1_ in line number _n2_.

: #lead  ( -- a n )  #locate line swap  ;
  \ From the cursor pointer `r#` compute the line address _a_
  \ in the block buffer and the offset from _a_ to the cursor
  \ location _n_.

: #lag  ( -- a n )  #lead dup >r + c/l r> -  ;
  \ a = cursor address
  \ n = count after cursor till end of line

: -move  ( a n -- )  line c/l cmove update  ;
  \ Move a line of text from _a_ to line _n_ of current block.

: h  ( n -- )  line pad 1+ c/l dup pad c! cmove  ;
  \ Hold line _n_ at `pad` (used by system more often than by
  \ user).

-->

( editor )

: e  ( n -- )  line c/l blank update  ;
  \ Erase line _n_ with blanks.

: s  ( n -- )  dup 1 - 0E do i line i 1+ -move -1 +loop e  ;
  \ Spread at line _n_. Line _n_ and following lines are are
  \ moved down one line. Line _n_ becomes blank. Line 15 is
  \ lost.

: d  ( n -- )  dup h 0F dup rot do i 1+ line i -move loop e  ;
  \ Delete line _n_ but hold it in `pad`. Line 15 becomes free
  \ as all statements move up one line.

: m  ( n -- )
  r# +! cr space #lead type [char] _ emit
  #lag type #locate . drop  ;
  \ Move the cursor by _n_ characters. The position of the
  \ cursor on its line is shown by a "_" (underline).

: t  ( n -- )  dup c/l * r# ! dup h 0 m  ;
  \ Type line _n_ and save in `pad`.

: l  ( n -- )  scr @ list 0 m  ;
  \ List the current block.

: r  ( n -- )  pad 1+ swap -move  ;
  \ Replace line _n_ with text in `pad`.

: p  ( n "text<eol>"  -- )  text r  ;
  \ Put "text" on line _n_.

: i  ( n -- )  dup s r  ;
  \ Insert text from `pad` at line _n_, moving the old line _n_
  \ down. Line 15 is lost.

: top  ( -- )  0 r# !  ;
  \ Position the cursor at the start of the block.

-->

( editor )

: clear  ( n -- )
  scr !  10 0 do [ also forth ] i [ previous ] e loop  ;
  \ Clear block _n_ with blanks and select for editing.

  \ XXX TODO -- rewrite with `search`
: -text  ( a1 len1 a2 -- f )
  swap ?dup if
    over + swap do
      dup c@ [ also forth ] i [ previous ] c@ -
      if  0= leave  else 1+  then
    loop  else  drop 0=  then  ;
  \ Return a non-zero _f_ if string _a1 len1_ exactly
  \ match string _a2 len1_, else return a false flag.

-->

( editor )

also forth
: match  ( a1 len1 a2 len2 -- true n3 | false n4 )
  >r >r 2dup r> r> 2swap over + swap
  do
    2dup i -text
    if  >r 2drop r> - i swap - 0 swap 0 0 leave  then
  loop
  2drop swap 0= swap ;  previous
  \ Match the string _a len2_ with all strings contained in the
  \ string _a1 len1_. If found leave _n3_ bytes until the end
  \ of the matching string, else leave _n4_ bytes to end of
  \ line.

: 1line  ( -- f )  #lag pad count match r# +!  ;
  \ Scan the cursor line for a match to `pad` text. Return flag
  \ and update the cursor `r#` to the end of matching text, or
  \ to the start of the next line if no match is found.

: find  ( -- )
  begin
    03FF r# @ <
    \ XXX FIXME -- `00 error` ?
    if  top pad here c/l 1+ cmove #-270 throw  then  1line
  until  ;
  \ Search for a match to the string at `pad`, from the cursor
  \ position until the end of block.  If no match found issue
  \ an error message and reposition the cursor at the top of
  \ the block.

-->

( editor )

: delete  ( n -- )
  >r #lag + r@ - #lag r@ negate r# +! #lead + swap cmove
  r> blank  ;
  \ Delete _n_ characters prior to the cursor.

: n  ( -- )  find 0 m  ;
  \ Find the next occurrence of the string found by an `f`
  \ command.

: f  ( "text<eol>" -- )  text n  ;
  \ Search forward from the current cursor position until
  \ string "text" is found. The cursor is left at the end of
  \ the string and the cursor line is printed. If the string is
  \ not found and error message is given and the cursor
  \ repositioned to the top of the block.

: b  ( -- )  pad c@ negate m  ;
  \ Used after `f` to backup the cursor by the length of the
  \ most recent text.

: x  ( "text<eol>" -- )  text find pad c@ delete 0 m  ;
  \ Find and delete the next occurrence of the string "text".

: till  ( "text<eol>" -- )
  #lead + text 1line 0= #-270 ?throw
  #lead + swap - delete 0 m  ;
  \ Delete on the cursor line from the cursor till the end of
  \ string "text".

-->

( editor )

: (c)  ( ca len -- )
  #lag rot over min >r r@ r# +! r@ - >r
  dup here r@ cmove here #lead + r> cmove r> cmove 0 m
  update  ;
  \ Copy the string _ca len_ to the cursor line at the cursor
  \ position.

: c  ( "text<eol>" -- )
  text pad count dup if  (c)  else  2drop  then  ;
  \ Copy in "text" to the cursor line at the cursor position.

also forth

: copy  ( n1 n2 -- )
  swap block cell- ! update save-buffers  ;
  \ Copy block _n1_ to block _n2_.

only forth definitions decimal

  \ }}} =======================================================
  \ Sample game: Siderator 2 {{{

( siderator )

  \ XXX UNDER DEVELOPMENT
  \ XXX TODO -- less stars!

\ Siderator
\ A game for the ZX Spectrum

\ Copyright (C) 2009,2010,2013,2015 Marcos Cruz
\ (programandala.net)

  \ History

  \ 2015-09-02: Start, with the code of the Jupiter ACE
  \ version: http://programandala.net/en.program.siderator.html

  \ Known bugs (or special features)

  \ The craft's autodestruction creates a new star.

only forth definitions  decimal

need random  need randomize  need udg:  need inkey
need between  need ocr  need frames@
need j  need between  need rows  need last-column
need last-row

vocabulary siderator
also siderator definitions

-->

( siderator )

  \ Game variables and constants:

variable x          variable speed
variable parsecs    variable record  record off

999 constant max-speed
'5' constant left-key  '8' constant right-key

  \ System variables and addresses:

8192 constant 'screen \ XXX OLD

  \ Common words:

: pause  ( -- )  begin  inkey  until  ;  -->

( siderator )

  \ Graphics

15360 constant charset  \ ROM charset

: char>a  ( c -- a )  8 * charset +  ;

: udg>a  ( c -- a )  128 - 8 * os-udg @ +  ;

: char>udg  ( c0 c1 -- )  swap char>a swap udg>a 8 cmove  ;

128 constant star0-udg  '*' star0-udg char>udg

%00011000
%00001000
%00011000
%00010000
%00011000
%00001000
%00011000
%00010000 129 udg: star1-udg  -->

( siderator )

130 constant star2-udg
char | star2-udg char>udg

%00001000
%00000000
%00001000
%00000000
%00001000
%00000000
%00001000
%00000000 131 udg: star3-udg  -->

( siderator )

%10000001
%10000001
%11000011
%11100111
%11111111
%01100110
%00111100
%00011000 132 udg: craft-udg  -->

( siderator )

  \ Keyboard

0 constant first-column

: pressed?  ( c -- f )  inkey =  ;

: left  ( col -- col' )
  left-key pressed? + first-column max  ;

: right  ( col -- col' )
  right-key pressed? - last-column min  ;

: rudder  ( -- )  x @ right left x !  ;

-->

( siderator )

  \ Stars

4 constant #stars

: star-coords  ( -- xc yc )  last-column last-row  ;

: .star  ( c -- )
  [ last-column 1+ ] literal random last-row at-xy
  1 bright emit 0 bright  ;

: stars/speed  ( -- n )  speed @ #stars 1- max-speed */ 1+  ;

: scroll  ( -- )  star-coords at-xy cr cr  ;

: .stars  ( -- )
  stars/speed dup [ star0-udg 1- ] literal + swap 0
  do  dup .star  loop  drop  ;

: star=  ( c -- f )  star0-udg star3-udg between  ;

: star<>  ( c -- f )  star= 0=  ;

-->

( siderator )

  \ Craft

rows 2 / constant craft-y

: craft-coords  ( -- y x )  x @ craft-y  ;

: at-craft  ( -- )  craft-coords at-xy  ;

: -craft  ( -- )  at-craft space  ;

: .craft  ( -- )  at-craft craft-udg 5 ink emit 7 ink  ;

-->

( siderator )

  \ Speed, parsecs, record

: .datum  ( u -- )  s>d <# # # # #> type space  ;

: delay  ( -- )  max-speed speed @ - 2 / 0  do  loop  ;

: .speed  ( -- )  ." Speed:" speed @ .datum  ;

: +speed  ( u1 -- u2 )
  dup 10 / 1 max  parsecs @ 4 mod 0= abs *  + max-speed min  ;

: faster  ( -- )  speed @ +speed speed !  ;

: .parsecs  ( -- )  ." Parsecs:" parsecs @ .datum  ;

: farther  ( -- )  1 parsecs +!  ;

: .record  ( -- )  ." Record:" record @ .datum  ;

: .info  ( -- )  home .speed .parsecs .record  ;

-->

( siderator )

  \ End

: blast-delay  ( -- )  32 0  do  loop  ;

: (blast)  ( -- )
  .craft blast-delay at-craft star0-udg emit blast-delay  ;

: blast  ( -- )  256 0  do  (blast)  loop  ;

: halt  ( -- )
  32 0  do  24 0 do
    i j ocr star= if  i j at-xy  star0-udg emit  then
  loop  loop  ;
  \ XXX TODO

-->

( siderator )

: safe?  ( -- f )  craft-coords swap ocr star<>  ;

: continue?  ( -- f )  safe? break-key? 0= and  ;

: new-record  ( -- )
  parsecs @ record @ >  if  parsecs @ record !  then  ;

: game-over  ( -- )
  blast halt  11 dup at-xy ." GAME OVER"
  new-record .info first-column last-row at-xy
  default-colors  ;

-->

( siderator )

\ Instructions

: about  ( -- )
  cr ." Siderator 2: Jugdement Day"  cr
  cr ." Copyright (C) Marcos Cruz"
  cr ." (programandala.net)"
  cr ." Version: 0.1.0+20151218"  ;

: objective  ( -- )
  cr ." Your objective is to travel as"
  cr ." much parsecs as possible"
  cr ." while dodging the stars."
  cr ." Anyway you're supposed to die"
  cr ." before the 1000th parsec"
  cr ." because four digits would ruin"
  cr ." the score panel."  ;

-->

( siderator )

\ Instructions

: keys  ( -- )
  cr ." Rudder keys: "
  left-key emit space right-key emit
  cr ." Autodestruction key: Break"  ;

: instructions  ( -- )  objective cr keys  ;

: wait  ( -- )  cr cr ." Press any key to start." pause  ;

-->

( siderator )

  \ Init

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 0 border  ;

: init-screen  ( -- )
  init-colors cls about cr instructions wait cls  ;

: 4+-  ( n1 -- n2 )  9 random 4 - +  ;

: init  ( -- )
  frames@ s>d randomize  udg-ocr
  init-screen  15 4+- x ! parsecs off  speed off  ;

-->

( siderator )

  \ Main

: run ( -- )
  init
  begin   -craft scroll  faster farther .info  continue?
  while   rudder .craft .stars  delay
  repeat  game-over  ;

  \ }}} =======================================================
  \ Sample game: tt (Tetris for terminals) {{{

.( tt ) blk @ .

  \ tt (Tetris for terminals) is an improved port of a game
  \ written in Forth-94 by Dirk Uwe Zoller in 1994.

  \ Credits:

  \ ----------------------------------------------------------
  \ tt.pfe  Tetris for terminals, redone in ANSI-Forth.
  \
  \ Written 05Apr94 by Dirk Uwe Zoller, e-mail duz AT roxi DOT
  \ rz DOT fht-mannheim DOT de.
  \
  \ Look&feel stolen from Mike Taylor's "TETRIS FOR TERMINALS".
  \
  \ Please copy and share this program, modify it for your
  \ system and improve it as you like. But don't remove this
  \ notice.
  \
  \ Thank you.
  \ ----------------------------------------------------------

only forth also definitions

  [undefined] forget-tt ?\ forget-tt
  \ XXX TODO
  \ marker forget-tt

need random  need j  need >=  need <=  need 2/  need value
need d<>  need d=  need case  need ms  need frames@  need yes?
need begin-stringtable  need positional-case:  need tab

vocabulary tt  also tt definitions  decimal

bl bl 2constant empty
  \ An empty position of the pit.

variable wiping
  \ If true, wipe brick, else draw brick.

2 constant col0  0 constant row0
  \ Position of the pit, not including the frame.

14 constant wide  22 constant deep
  \ Size of pit, not including the frame.
  \ Wide in stones; deep in rows.

-->

.( tt ) blk @ .

  \ c1 = left key
  \ c2 = right key
  \ c3 = rotate key
  \ c4 = drop key
  \ c5 = pause key
  \ c6 = quit key

7 constant edit-char

: actual-cursor-keys  ( -- c1 c2 c3 c4 c5 c6 )
  8 9 11 10 bl edit-char  ;
  \ Actual cursor keys, useful for PC keyboards with cursor
  \ keys

: spanish-dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] H [char] . [char] A bl edit-char  ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: dvorak-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] C [char] R [char] ' [char] A bl edit-char  ;

: qwerty-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] O [char] P [char] Q [char] A bl edit-char ;
  \ QWERTY layout, as found in many ZX Spectrum games.

: cursor-digits-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 5 [char] 8 [char] 7 [char] 6 bl edit-char  ;
  \ Cursor keys, actually the digits keys they are associated with.

: sinclair1-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 1 [char] 2 [char] 3 [char] 4  bl edit-char  ;
  \ Sinclair 1 joystick.

: sinclair2-keys  ( -- c1 c2 c3 c4 c5 c6 )
  [char] 6 [char] 7 [char] 8 [char] 9  bl edit-char  ;  -->
  \ Sinclair 2 joystick.

.( tt ) blk @ .

6 constant max-keyset
  \ Maximum number of the keyset (first is zero).

variable keyset
  \ Number of the current keyset.

positional-case: keyset>keys  ( n -- c1 c2 c3 c4 c5 c6 )
  actual-cursor-keys
  dvorak-keys
  spanish-dvorak-keys
  sinclair1-keys
  sinclair2-keys
  cursor-digits-keys
  qwerty-keys  ;

-->

.( tt ) blk @ .

begin-stringtable keyset>name  ( n -- ca len )
  s" Cursor        " s,
  s" Dvorak        " s,
  s" Spanish Dvorak" s,
  s" Sinclair 1    " s,
  s" Sinclair 2    " s,
  s" Cursor digits " s,
  s" QWERTY        " s,
end-stringtable

: keyset-name  ( -- ca len )  keyset @ keyset>name  ;

-->

.( tt ) blk @ .

0 value quit-key  0 value pause-key  0 value drop-key
0 value rot-key   0 value right-key  0 value left-key

: keys!  ( c1 c2 c3 c4 c5 c6 -- )
  to quit-key to pause-key to drop-key
  to rot-key to right-key to left-key   ;

: set-keyset   ( n -- )  dup keyset ! keyset>keys keys!  ;
  \ Set the keyset layout number _n_.

: next-keyset  ( -- n )  keyset @ 1+ dup max-keyset > 0= and  ;
  \ Calculate the next keyset.

: change-keyset  ( -- )  next-keyset set-keyset  ;
  \ Set the next keyset.

0 set-keyset  \ default

-->

.( tt ) blk @ .

variable score
variable pieces
variable levels
variable delay  \ in ms

variable brick-row  variable brick-col
  \ Position of the current brick.

: 2c@  ( a -- c1 c2 )  dup 1+ c@ swap c@  ;
  \ Fetch a pair of characters.

: 2c!  ( c1 c2 a -- )  dup >r c! r> 1+ c!  ;
  \ Store a pair of characters.

: 2emit  ( c1 c2 -- )   emit emit  ;

: position  ( row col -- )
  2* col0 + swap row0 + at-xy  ;
  \ Cursor to the position in the pit.

: stone  ( c1 c2 -- )
  wiping @ if  2drop 2 spaces  else  2emit  then  ;
  \ Draw or undraw these two characters.

-->

.( tt ) blk @ .

wide deep * 2 * constant /pit
  \ Size of the pit in memory.

create 'pit /pit allot
  \ The pit.

: pit  ( col row -- a )  'pit rot wide * rot + 2* +  ;
  \ Convert pit coords to the correspondent address.

: empty-pit  ( -- )  'pit /pit blank  ;
  \ Empty the pit.

: draw-bottom  ( -- )
  deep -1 position  [char] + dup stone
  wide 0 do  [char] = dup stone  loop
  [char] + dup stone  ;
  \ Draw the bottom of the pit.

: draw-frame  ( -- )
  deep 0 do   i -1   position [char] | dup stone
              i wide position [char] | dup stone
  loop  draw-bottom  ;  -->
  \ Draw the frame of the pit.

.( tt ) blk @ .

: bottom-msg  ( addr cnt -- )
  deep over 2/ wide swap - 2/ position 1 flash type 0 flash  ;
  \ Output a message at the bottom of the pit.

: draw-line  ( line -- )
  dup 0 position  wide 0 do  dup i pit 2c@ 2emit  loop  drop  ;
  \ Draw the contents of a pit line.

: draw-pit  ( -- )  deep 0 do  i draw-line  loop  ;
  \ Draw the contents of the pit.

begin-stringtable c>name  ( c -- ca len )
  s" Edit" s, s" Left" s, s" Right" s, s" Down" s, s" Up" s,
end-stringtable
  \ Names of the control chars 7..11.

: control-char-name  ( c -- ca len )  7 - c>name  ;
  \ Name of a control char (7..11).

: show-key  ( c -- )
  2 spaces  dup bl = if  drop ." Space"  else
            dup bl < if    control-char-name type
                     else  emit  then
            then  tab  ;
  \ Display the name of char _c_.
  \ Control chars are not supported except cursor keys and edit.

-->

.( tt ) blk @ .

: show-keys  ( -- )
  \ display the game keys
  \  <------------------------------>
  ." Keys: " keyset-name type cr cr
  left-key     show-key ."  Move left" cr
  right-key    show-key ."  Move right" cr
  rot-key      show-key ."  Rotate" cr
  drop-key     show-key ."  Drop" cr
  pause-key    show-key ."  Pause" cr
  quit-key     show-key ."  Quit"  ;
  \  <------------------------------>

-->

.( tt ) blk @ .

: (show-help)  ( -- )
  0 0 at-xy
  \  <------------------------------>
  ." TT (Tetris for Terminals)" cr cr
  ." Original ANS Forth code written" cr
  ." by Dirk Uwe Zoller, 1994." cr
  ." Ported to Solo Forth" cr
  ." by Marcos Cruz, 2015." cr cr
  show-keys  ;
  \ Display some explanations.

: show-help  ( -- )
  page
  begin  (show-help) cr cr
          \  <------------------------------>
         ." Press Space to change the keys" cr
         ." or any other key to start."
         key bl =
  while  change-keyset  repeat  ;  -->
  \ Display some explanations and change the keyset.

.( tt ) blk @ .

23 constant score-row

: at-score  ( col -- )  score-row at-xy  ;
  \ Set cursor at column _col_ of the score row.

: score-labels ( -- )
   0 at-score ." Score:"
  10 at-score ." Pieces:"
  21 at-score ." Levels:"  ;
  \ Display the labels of the score.

: .score  ( a col -- )  at-score @ 3 .r  ;
  \ Display the contents of the score variable _a_ at column
  \ _col_.

: update-score  ( -- )
  score 6 .score  pieces 17 .score  levels 28 .score  ;
  \ Display the current score.

: arena  ( --)
  draw-frame draw-pit score-labels update-score  ;
  \ Redraw everything on screen.

-->

.( tt ) blk @ . key drop

.s key drop

: brick:  ( ca1 len1 ca2 len2 ca3 len3 ca4 len4 "name" -- )
  create  4 0 do
            0 ?do  dup i chars + c@ c,  loop drop
          loop
  does>  ( x1 x2 -- a ) ( pfa )  rot 4 * rot + 2* +  ;
  \ Define the shape of a brick.
  \ Every brick has 4 rows, defined by 4 strings.
  \ XXX TODO stack notation of `does>`

s"         " 2constant empty-brick-row .s key drop

  \ XXX FIXME -- crash! -- never reaches the next `key drop`

empty-brick-row
s"   ##    "
s" ######  "  empty-brick-row  brick: brick1  .s key drop

empty-brick-row 2dup
s" <><><><>"  empty-brick-row  brick: brick2  .s key drop

empty-brick-row
s"   {}    "
s"   {}{}{}"  empty-brick-row  brick: brick3  .s key drop -->

.( tt ) blk @ . key drop

empty-brick-row
s"     ()  "
s" ()()()  "  empty-brick-row brick: brick4

empty-brick-row
s"   [][]  "
s"   [][]  "  empty-brick-row brick: brick5

empty-brick-row
s"   @@@@  "
s" @@@@    "  empty-brick-row brick: brick6

empty-brick-row
s" %%%%    "
s"   %%%%  "  empty-brick-row brick: brick7

empty-brick-row 2dup 2dup 2dup brick: brick
  \ brick actually in use

empty-brick-row 2dup 2dup 2dup brick: scratch  -->

.( tt ) blk @ . key drop

create bricks  ' brick1 ,  ' brick2 ,  ' brick3 ,  ' brick4 ,
               ' brick5 ,  ' brick6 ,  ' brick7 ,

create brick-value 1 c, 2 c, 3 c, 3 c, 4 c, 5 c, 5 c,

32 constant /brick
  \ Bytes per brick shape.

: is-brick  ( brick -- )
  >body [ ' brick >body ] literal /brick cmove  ;
  \ Activate a shape of brick.

: new-brick  ( -- )
  1 pieces +!  7 random
  bricks over cells + @ is-brick
  brick-value swap chars + c@ score +!  ;
  \ Select a new brick by random, count it.

: rotate-left  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  3 i - j scratch 2c!
  loop loop
  ['] scratch is-brick  ;  -->
  \ Rotate the current brick left.

.( tt ) blk @ . key drop


: rotate-right  ( -- )
  4 0 do 4 0 do
    j i brick 2c@  i 3 j - scratch 2c!
  loop loop
  ['] scratch is-brick  ;
  \ Rotate the current brick right.

: draw-brick  ( row col -- )
  4 0 do 4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i +  position
        j i brick 2c@  stone
    then
  loop loop  2drop  ;
  \ Draw the current brick at the given coords.

: show-brick  ( row col -- )  wiping off draw-brick  ;

: hide-brick  ( row col -- )  wiping on  draw-brick  ;

-->

.( tt ) blk @ . key drop

: put-brick  ( row col -- )
  4 0 do 4 0 do
      j i brick 2c@  empty d<>
      if  over j +  over i +  pit
          j i brick 2c@  rot 2c!
      then
  loop loop  2drop  ;
  \ Put the brick into the pit.

: remove-brick  ( row col -- )
  4 0 do  4 0 do
    j i brick 2c@  empty d<>
    if  over j + over i + pit empty rot 2c!  then
  loop  loop  2drop  ;
  \ Remove the brick from that position.

-->

.( tt ) blk @ . key drop

: test-brick  ( row col -- f )
  4 0 do 4 0 do
    j i brick 2c@ empty d<>
    if  over j +  over i +
        over dup 0< swap deep >= or
        over dup 0< swap wide >= or
        2swap pit 2c@  empty d<>
        or or if  unloop unloop 2drop false  exit  then
    then
  loop loop  2drop true  ;
  \ Could the brick be there?

-->

.( tt ) blk @ . key drop


: move-brick  ( rows cols -- f )
  brick-row @ brick-col @ remove-brick
  swap brick-row @ + swap brick-col @ + 2dup test-brick
  if    brick-row @ brick-col @ hide-brick
        2dup brick-col ! brick-row !
        2dup show-brick put-brick  true
  else  2drop brick-row @ brick-col @ put-brick  false
  then  ;
  \ Try to move the brick.

-->

.( tt ) blk @ . key drop

: rotate-brick  ( f1 -- f2 )
  \ f1 = rotate right?, else rotate left
  \ f2 = success
  brick-row @ brick-col @ remove-brick
  dup if  rotate-right  else  rotate-left  then
  brick-row @ brick-col @ test-brick
  over if  rotate-left  else  rotate-right  then
  if  brick-row @ brick-col @ hide-brick
      if  rotate-right  else  rotate-left  then
      brick-row @ brick-col @ put-brick
      brick-row @ brick-col @ show-brick  true
  else  drop false  then  ;
  \ Rotate the current brick.

-->

.( tt ) blk @ . key drop

: insert-brick  ( row col -- f )
  2dup test-brick
  if  2dup brick-col ! brick-row !
      2dup put-brick  draw-brick  true
  else  false  then  ;
  \ Introduce a new brick.

: drop-brick  ( -- )  begin  1 0 move-brick 0=  until  ;
  \ Move brick down fast.

: move-line  ( from to -- )
    over 0 pit  over 0 pit  wide 2*  cmove  draw-line
    dup 0 pit  wide 2*  blank  draw-line  ;

: line-full?  ( line-no -- f )
    true  wide 0
    do  over i pit 2c@ empty d=
        if  drop false  leave  then
    loop nip  ;

-->

.( tt ) blk @ . key drop

: adjust-delay  ( -- )
  levels @
  dup  50 < if  100 over -  else
  dup 100 < if   62 over 4 / -  else
  dup 500 < if   31 over 16 / -  else  0  then then then
  delay !  drop  ;
  \ Make it faster with increasing level.

-->

.( tt ) blk @ . key drop

: new-level  ( -- )  1 levels +!  10 score +!  adjust-delay  ;

: remove-lines  ( -- )
  deep deep
  begin
    swap
    begin
      1- dup 0< if  2drop exit  then  dup line-full?
    while
      new-level
    repeat
    swap 1- 2dup <> if  2dup move-line  then
  again  ;

-->

.( tt ) blk @ . key drop

: interaction  ( -- f )
  case  key upper
    left-key      of  0 -1 move-brick drop  endof
    right-key     of  0  1 move-brick drop  endof
    rot-key       of  0 rotate-brick drop  endof
    drop-key      of  drop-brick  endof
    pause-key     of  S"  Paused " bottom-msg  key drop
                      draw-bottom  endof
    quit-key      of  false exit  endof
  endcase  true  ;

: initialize  ( -- )
  frames@ d>s randomize
  score off  pieces off  levels off  adjust-delay
  empty-pit page arena  ;
  \ Prepare for playing.

-->

.( tt ) blk @ . key drop

: play-game  ( -- )
  begin
    new-brick  -1 3 insert-brick
  while
    begin
      4 0 do
        delay @ ms key?
        if  interaction 0= if  unloop exit  then  then
      loop
      1 0 move-brick 0=
    until
    remove-lines  update-score  adjust-delay
  repeat  ;
  \ Play one tt game.

-->

.( tt ) blk @ . key drop

also forth definitions

: again?  ( -- f )  s"  Again? (Y/N) " bottom-msg yes?  ;

: start-message  ( -- )  ." Type RUN to start tt" cr  ;

: end-message  ( -- )  0 23 at-xy cr start-message  ;

: run  ( -- )
  show-help
  begin  initialize play-game again? 0=  until
  draw-bottom end-message  ;
  \ Play the tt game.

cr start-message

only forth definitions

  \ }}} =======================================================
  \ Sample game: Towers of Hanoi {{{

( hanoi )

  \ XXX UNDER DEVELOPMENT

  \ Credits:
  \
  \ Code converted from hForth

  \ -----------------------------------------------------------
  \ hanoi.4th
  \
  \ Towers of Hanoi puzzle
  \
  \ From a posting to comp.lang.forth, 30 May 2002, by Marcel
  \ Hendrix and Brad Eckert. According  to Marcel Hendrix, the
  \ code for the HANOI algorithm was originally posted to clf
  \ by Raul Deluth Miller in 1994.
  \
  \ -----------------------------------------------------------
  \ kForth includes and defs  (2002-05-30  K. Myneni)
  \ -----------------------------------------------------------

  \ include strings
  \ include ansi

  \ -----------------------------------------------------------

only forth definitions

need don't  need ms  need mode64  need alloted

vocabulary hanoi  also hanoi definitions

variable slowness  1000 slowness !
  \ ms delay between screen updates

3 constant pegs

create PegSPS  pegs cells allot
  \ pointers for three disk stacks

: PegSP     ( peg -- addr ) cells PegSPS + ;
: PUSH      ( c peg -- )    PegSP tuck @ c!  1 chars swap +! ;
: POP       ( peg -- c )    PegSP -1 chars over +!  @ c@ ;

create PegStacks  30 chars allot
  \ stack area for up to 10 disks

: PegStack  ( peg -- addr )   10 * PegStacks + ;

: clear-peg    ( peg -- )  dup PegStack  swap PegSP ! ;
: clear-pegs  ( -- )  pegs 0 do  i clear-peg  loop  ;

  \ : PegDepth  ( peg -- depth )  dup PegSP @  swap PegStack - ;
  \ XXX OLD not needed

-->

( hanoi )

: show-disk  ( level diameter peg -- )
  22 * 10 + over -  rot 10 swap - at-xy
  2* [char] * emits ;

: show-peg   ( peg -- )
  dup >r PegStack
  BEGIN   r@ PegSP @ over <>
  WHILE   dup r@ PegStack - over c@  ( addr level diameter )
          r@ show-disk  char+
  REPEAT  drop r> drop ;

-->

( hanoi )

: maketab  ( n1..nn n -- XXX ) \ XXX TODO stack effect
  create
    dup alloted over 1- + swap 0
    2dup <> if    do  dup >r c! r> 1-  loop
            else  2drop
            then  drop
  does>  + c@ ;

#3 base !
00 02 01 12 00 10 21 20  #8 maketab TO!
00 21 12 20 00 02 10 01  #8 maketab FRO!
decimal

-->

( hanoi )

: finished  ( -- )  key drop 0 11 at-xy ." Stopped" cr abort  ;

: show-pegs  ( -- )
  page  pegs 0 do  i show-peg  loop  slowness @ ms
  key? if  finished  then ;

: move-ring  ( ring -- ring )
  dup to! 3 / pop  over fro! 3 mod push show-pegs ;

: tower ( depth direction -- depth direction )
  swap 1- swap over
  IF    to!  recurse  to! move-ring fro! recurse  fro!
  ELSE  move-ring
  THEN  swap 1+ swap ;

-->

( hanoi )

: run  ( depth -- )

  clear-pegs

  dup BEGIN ?dup WHILE 1- dup 0 push REPEAT
    \ stack up some disks

  show-pegs 1 tower 2drop
    \ move them

  0 11 at-xy ;

mode64 page
  \  <-------------------------->
  .( Towers of Hanoi) cr
  .( Type 'n run' to play where) cr
  .( 'n' is the number of disks.) cr
  \  <-------------------------->

  \ }}} =======================================================
  \ Sample game: Life {{{

( life )

  \ XXX UNDER DEVELOPMENT
  \
  \ XXX -- works in Gforth, but freezes here.

  \ Credits:
  \
  \ Code adapted from kForth. Original Credits:

  \ ____
  \
  \ Conway's Game of Life, or Occam's Razor Dulled
  \
  \ The original ANS Forth version by Leo Wong (see bottom) has
  \ been modified slightly to allow it to run under kForth.
  \ Also, delays have been changed from 1000 ms to 100 ms for
  \ faster update --- K. Myneni, 12-26-2001
  \
  \ 950724 + 970703 +
  \ Copyright 1995 Leo Wong
  \ hello at albany dot net
  \ http://www.albany.net/~hello/
  \ ____

need ms  need c+!  need 2/

1 CHARS CONSTANT /Char

  \ the universal pattern
32 CONSTANT How-Deep  24 CONSTANT How-Wide

How-Wide How-Deep *
  \  1-  \ 1- prevents scrolling on my screen \ XXX OLD
   CONSTANT Homes

  \ world wrap
: World  ( "name" -- )
  CREATE  Homes CHARS ALLOT
  DOES>  ( u -- c-addr )
    ( u pfa ) SWAP Homes +  Homes MOD  CHARS + ;

World old  World new

-->

( life )

  \ biostatistics

  \ begin hexadecimal numbering
  \ hex xy : x holds life , y holds neighbors count

$10 CONSTANT Alive  \ 0y = not alive

  \ Conway's rules:
  \ a life depends on the number of its next-door neighbors

  \ it dies if it has fewer than 2 neighbors
: Lonely  ( char -- flag )  $12 < ;

  \ it dies if it has more than 3 neighbors
: Crowded  ( char -- flag )  $13 > ;

: -Sustaining  ( char -- flag )  DUP Lonely  SWAP Crowded  OR ;

  \ it is born if it has exactly 3 neighbors
: Quickening  ( char -- flag )  $03 = ;

-->

( life )

  \ compass points
: N  ( i -- j )  How-Wide - ;
: S  ( i -- j )  How-Wide + ;
: E  ( i -- j )  1+ ;
: W  ( i -- j )  1- ;

  \ census
: Home+!  ( -1|1 i -- )  >R  Alive *  R> new C+! ;

: Neighbors+!  ( -1|0|1 i -- )
  2DUP N W new C+!  2DUP N new C+!  2DUP N E new C+!
  2DUP   W new C+!  (     i      )  2DUP   E new C+!
  2DUP S W new C+!  2DUP S new C+!       S E new C+! ;

: Bureau-of-Vital-Statistics ( -1|1 i -- )
  2DUP Home+!  Neighbors+! ;

  \ mortal coils
CHAR ? CONSTANT Soul  BL CONSTANT Body

-->

( life )

: Home  ( char i -- )  How-Wide /MOD AT-XY  EMIT ;

: Is-Born  ( i -- )
  Soul OVER Home  1 SWAP Bureau-of-Vital-Statistics ;

: Dies  ( i -- )
  Body OVER Home  -1 SWAP Bureau-of-Vital-Statistics ;

: One  ( c-addr -- i )  0 old -  /Char / ;

-->

( life )

: there  ( -- )  How-Wide 1- 0 AT-XY ;

: Everything  ( -- )
  0 old  Homes
  BEGIN  DUP
  WHILE  OVER C@  DUP Alive AND
     IF   -Sustaining IF  OVER One Dies     THEN
     ELSE  Quickening IF  OVER One Is-Born  THEN THEN
     1 /STRING
  REPEAT  2DROP
  there  ;

-->

( life )

  \ in the beginning
: Void  ( -- )  0 old  Homes BLANK ;

  \ spirit
: Voice  ( -- c-addr u )
  PAGE ." Say: "  0 new  DUP Homes ACCEPT ;

  \ subtlety
: Serpent  ( -- )
  0 2 AT-XY  ." Press a key for knowledge."  KEY DROP
  0 2 AT-XY  ." Press space to re-start, Esc to escape life." ;

  \ the primal state
: Innocence  ( -- )
  Homes 0 DO  I new C@  Alive /  I Neighbors+!  LOOP ;

  \ children become parents
: Passes  ( -- )  0 new  0 old  Homes  CMOVE ;

-->

( life )

  \ a garden
: Paradise  ( c-addr u -- )
  >R  How-Deep How-Wide *  How-Deep 2 MOD 0=  How-Wide AND -
  R@  -  2/  old
  R>  CMOVE
  0 old  Homes 0
  DO  COUNT BL <>
      DUP IF  Soul I Home  THEN
      Alive AND  I new C!
  LOOP  DROP
  Serpent
  Innocence Passes ;

-->

( life )

: Creation  ( -- )  Void Voice Paradise ;

  \ the human element

100 CONSTANT Ideas
: Dreams  ( -- )  Ideas MS ;

100 CONSTANT Images
: Meditation  ( -- )  Images MS ;

  \ free will
: Action  ( -- char )
  KEY? DUP
  IF  DROP KEY  DUP BL = IF  Creation  THEN
  THEN ;

  \ environmental dependence
7 CONSTANT Escape

  \ history
: Goes-On  ( -- )
  BEGIN  Everything Passes  Dreams Action Meditation
         Escape = UNTIL ;

  \ a vision
: Life  ( -- )  Creation Goes-On ;

  \ Life


  \ }}} =======================================================
  \ Sample game: Toe {{{

( toe )

  \ XXX UNDER DEVELOPMENT

  \ 2015-11-24: Changes.

  \ Credits:
  \
  \ Based on code from Leo Brodie's _Starting Forth_, ANSized
  \ by Benjamin Hoyt in 1997.

9 constant squares

1 constant player-x  2 constant player-o

create board  squares allot

: clear  ( -- )  board squares erase  ;  clear

: >square  ( square -- ca )  board +  ;
: square@  ( square -- c )  >square c@  ;
: square!  ( c square -- )  >square c!  ;

: bar  ( -- )  ." | "  ;
: dashes  ( -- )  cr  9 0 do  '-' emit  loop cr  ;

: .player-mark  ( player -- )
  player-x = if ." x " else ." o " then  ;

: .box-contents  ( n -- )
  ?dup if  .player-mark  else  2 spaces  then  ;

: .box  ( square -- )  square@  .box-contents  ;

-->

( toe )

: display  ( -- )
  home
  squares 0 do
    i if    i 3 mod  0= if  dashes  else  bar  then
      then  i .box
  loop  cr  ;

: limited  ( square -- square' )  0 max squares min  ;

: play  ( square player -- )  swap 1- limited square! ;

: x  ( square -- )  player-x play  display ;
: o  ( square -- )  player-o play  display ;

  \ }}} =======================================================
  \ Sample game: Pong {{{

( pong )

  \ XXX UNDER DEVELOPMENT

  \ XXX TODO slow the rackets

  \ Credits:
  \
  \ Code adapted from IsForth (version 1.23v).

  \ ____
  \
  \ pong.f
  \ Written june 2002 by Robert Oestling
  \ <robost at telia dot com>
  \ Tested with IsForth, http://isforth.clss.net/
  \ ____

need columns  need rows  need udg:  need rnd  need ??
3 constant /kk  need pressed?
need cvariable  need 2/  need pixel-addr
need hires-emit-udg  need c!toggle-bits

0 cconstant black  7 cconstant white

  \ XXX OLD
  \ 500 constant initial-speed
  \ variable speed
  \ Delay in milliseconds.

8 cconstant ball-delay0
  \ Counter: Times the ball is not moved in the main loop.
variable ball-delay
  \ XXX NEW

4 cconstant racket-size

: brighty  ( n1 -- n2 )  %1000000 or  ;
: paper-color  ( n1 -- n2 )  8 *  ;

white paper-color brighty cconstant racket-color

22528 constant top-line-attr
  \ address of the top left screen attribute
23264 constant bottom-line-attr
  \ address of the bottom left screen attribute

code sync  ( -- )  78 c,  jpnext  end-code
  \ Z80 halt

-->

( pong )

  \ Key constant are defined with double constants this way:
  \ high part = bitmask
  \ low part = port of the keyboard row

$01 $F7FE 2constant left1-key   char 1 cconstant left1-char
$02 $F7FE 2constant right1-key  char 2 cconstant right1-char
  \ Player 1 keys.

$10 $EFFE 2constant left2-key   char 6 cconstant left2-char
$08 $EFFE 2constant right2-key  char 7 cconstant right2-char
  \ Player 2 keys.

variable x  variable y
  \ Coordinates of the ball.

cvariable direction
  \ Direction of ball.
  \ Bit 0: 1 = down, 0 = up.
  \ Bit 1: 1 = right, 0 = left.

variable points1  variable points2
  \ Player points.

variable racket1-x  columns racket-size - 2/  racket1-x !
  \ Top racket x coordinate.

variable racket2-x  racket1-x @ racket2-x !
  \ Bottom racket x coordinate.

0 cconstant racket1-y
  \ Top racket y coordinate.

rows 1- cconstant racket2-y
  \ Bottom racket y coordinate.

-->

( pong )

%00111100
%01111110
%11111111
%11111111
%11111111
%11111111
%01111110
%00111100 128 udg: (ball)  0 cconstant ball \ XXX TMP

  \ XXX TODO -- frames

  \ %00111100
  \ %01111110
  \ %11111011
  \ %11111101
  \ %11111111
  \ %11111111
  \ %01111110
  \ %00111100 128 udg: ball0

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111101
  \ %11111101
  \ %11111111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111101
  \ %11111011
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11100111
  \ %01111110
  \ %00111100 130 udg: ball1

  \ %00111100
  \ %01111110
  \ %11111111
  \ %11111111
  \ %11111111
  \ %11110011
  \ %01111110
  \ %00111100 130 udg: ball1

-->

( pong )

: restore-screen  ( -- )  default-colors page  ;

: init-screen  ( -- )  restore-screen white ink  ;

: ball-xy  ( -- x y )  x @ y @  ;

: show-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: erase-ball  ( -- )  ball-xy ball sync hires-emit-udg  ;

: (border)  ( a -- )
  columns [ white paper-color ] literal sync fill  ;

: top-border  ( -- )  top-line-attr (border)  ;

: bottom-border  ( -- )  bottom-line-attr (border)  ;

-->

( pong )

: show-racket  ( a -- )  racket-size racket-color sync fill  ;

: show-racket1  ( -- )
  top-line-attr dup (border) racket1-x @ + show-racket  ;

: show-racket2  ( -- )
  bottom-line-attr dup (border) racket2-x @ + show-racket  ;

: show-rackets  ( -- )  show-racket1 show-racket2  ;

: racket-initial-x  ( -- n )
  columns 2/ [ racket-size 2/ ] literal -  ;

: reset-rackets  ( -- )
  racket-initial-x dup racket1-x ! racket2-x !  ;

-->

( pong )

: erase-racket  ( a1 a2 -- )  @ + racket-size erase  ;
  \ Erase a racket.
  \ a1 = address of the first screen attribute on the row
  \ a2 = variable that holds the racket x coordinate

: erase-racket1  ( -- )
  top-line-attr racket1-x erase-racket  ;
  \ Erase racket of player 1.

: erase-racket2  ( -- )
  bottom-line-attr racket2-x erase-racket  ;
  \ Erase racket of player 2.

-->

( pong )

: (print-points)  ( n y -- )
  0 swap at-xy s>d <# # # # #>
  black ink sync type white ink  ;
  \ Print the points of a player.

: print-points1  ( -- )
  points1 @ racket1-y (print-points) show-racket1  ;
  \ Print the points of player 1.

: print-points2  ( -- )
  points2 @ racket2-y (print-points) show-racket2  ;
  \ Print the points of player 2.

: print-points  ( -- )  print-points1 print-points2  ;
  \ Print the points of both players.

: change-x  ( -- )  %10 direction c!toggle-bits  ;
  \ Change the x direction of the ball.

: change-y  ( -- )  %01 direction c!toggle-bits  ;
  \ Change the y direction of the ball.

: faster  ( -- )
  exit  ;  \ XXX OLD
  \ speed @ 40 > if  speed @ dup 20 / - speed !   then  ;
  \ If the delay is more than 40 ms, reduce it with 5%.

-->

( pong )

: ball-moving-right?  ( -- f )  direction c@ %10 and  ;
: ball-moving-down?  ( -- f )  direction c@ %01 and  ;
  \ : ball-at-right?  ( -- wf )  x @ columns 1- =  ;
: ball-at-right?  ( -- wf )  x @ 247 >  ;
: ball-at-left?  ( -- wf )  x @ 1 <  ;
  \ : ball-at-bottom?  ( -- wf )  y @ rows 2- =  ;
: ball-at-bottom?  ( -- wf )  y @ 16 <  ;
  \ : ball-at-top?  ( -- wf )  y @ 1 =  ;
: ball-at-top?  ( -- wf )  y @ 182 >  ;

: move-ball-x  ( -- )
  ball-moving-right?
  if
    \ 0 2 at-xy ." right" \ XXX INFORMER
    ball-at-right?  if  change-x  then  1
  else
    \ 0 2 at-xy ." left " \ XXX INFORMER
    ball-at-left?   if  change-x  then  -1
  then  x +!  ;

-->

( pong )

: reset-ball  ( -- )
  128 x !  95 y !  rnd %11 and direction c!  ;
  \ Reset the ball position and direction.

: ready  ( -- )  reset-rackets reset-ball  ;

: score-player1  ( -- )  1 points1 +! print-points1  ;
  \ Increase player 1's points by one.

: score-player2  ( -- )  1 points2 +! print-points2  ;
  \ Increase player 2's points by one.

[defined] 8* ?\ : 8*  ( n1 -- n2 )  2* 2* 2*  ;

: hit-racket1?  ( -- wf )
  x @ racket1-x @ 8* 1- >
  x @ racket1-x @ 8* racket-size 8* + <  and  ;
  \ Is racket1 hit by the ball?
  \ Is racket1-x <= x < racket1-x + racket-size?

: hit-racket2?  ( -- wf )
  x @ racket2-x @ 8* 1- >
  x @ racket2-x @ 8* racket-size 8* + <  and  ;
  \ Is racket2 hit by the ball?
  \ Is racket2-x <= x < racket2-x + racket-size?

  \ : hit-racket?  ( a -- wf )
  \   \ XXX NEW -- alternative
  \   \ XXX TODO try
  \   \ a = address that holds the x coordinate of a racket
  \   @ 8* x @ swap  ( ball-x pad-x )
  \   2dup 1- > >r
  \   racket-size 8* + <  r> and  ;

-->

( pong )

: possible-top-hit  ( -- )
  hit-racket2? if change-y  else  score-player1 ready  then  ;

: move-ball-down  ( -- )
  ball-at-bottom? if  possible-top-hit  else  -1 y +!  then  ;

: possible-bottom-hit  ( -- )
  hit-racket1? if  change-y  else  score-player2 ready  then  ;

: move-ball-up  ( -- )
  ball-at-top? if  possible-bottom-hit  else  1 y +!  then  ;

: move-ball-y  ( -- )
  ball-moving-down?
  if  move-ball-down  else  move-ball-up  then  ;

8 cconstant racket-delay0
  \ Counter: Times the rackets are not moved in the main loop.
variable racket1-delay
variable racket2-delay

-->

( pong )

: ?move-ball  ( -- )
  -1 ball-delay +!  ball-delay @ if  unnest  exit  then
  ball-delay0 ball-delay !  ;

: move-ball  ( -- )
  ?move-ball
  erase-ball move-ball-x move-ball-y show-ball  ;

: frame  ( -- )  white border  top-border bottom-border  ;

: arena-line  ( -- )
  [ 0 96 pixel-addr nip ] literal columns %10101010 fill
  [ 0 95 pixel-addr nip ] literal columns %01010101 fill  ;

: arena  ( -- )
  cls  frame arena-line show-rackets print-points show-ball  ;

-->

( pong )

: ?move-racket1  ( -- )
  -1 racket1-delay +!  racket1-delay @ if  unnest exit  then
  racket-delay0 racket1-delay !  ;

: (move-racket1)  ( 1|-1 -- )  racket1-x +!  show-racket1  ;

: move-racket1-left  ( -- )
  ?move-racket1
  racket1-x @ 0= ?exit
  -1 (move-racket1)  ;

: move-racket1-right  ( -- )
  ?move-racket1
  racket1-x @ racket-size + columns = ?exit
  1 (move-racket1)  ;

-->

( pong )

: ?move-racket2  ( -- )
  -1 racket2-delay +!  racket2-delay @ if  unnest exit  then
  racket-delay0 racket2-delay !  ;

: (move-racket2)  ( 1|-1 -- )  racket2-x +!  show-racket2  ;

: move-racket2-left  ( -- )
  ?move-racket2
  racket2-x @ 0= ?exit
  -1 (move-racket2)  ;

: move-racket2-right  ( -- )
  ?move-racket2
  racket2-x @ racket-size + columns = ?exit
  1 (move-racket2)  ;

-->

( pong )

: reset-points  ( -- )  points1 off  points2 off  ;

: init-game  ( -- )
  init-screen reset-points
  racket-delay0  dup racket1-delay !  racket2-delay !
  ball-delay0 ball-delay ! ready  ;

: quit-game  ( -- )
  restore-screen  ." Player 1 score: " points1 ? cr
                  ." Player 2 score: " points2 ?  quit  ;

  : keypress  ( key -- )
    left1-key     pressed? ?? move-racket1-left
    right1-key    pressed? ?? move-racket1-right
    left2-key     pressed? ?? move-racket2-left
    right2-key    pressed? ?? move-racket2-right
                break-key? ?? quit-game  ;  -->

( pong )

: show-player-key  ( c ca len -- )
  space rot emit ."  = " type cr  ;

: show-player-keys  ( c1 c2 -- )
  s" left" show-player-key  s" right" show-player-key  ;

: show-game-keys  ( -- )
  ." Player 1:" cr right1-char left1-char show-player-keys
  ." Player 2:" cr right2-char left2-char show-player-keys
  ." Break (Shift+Space) = quit"  ;

-->

( pong )

: show-credits  ( -- )

  \  <------------------------------>
  ." Forth Pong" cr cr
  ." Original code by:" cr
  ."   Robert Oestling, 2002" cr
  ." Ported to IsForth by:" cr
  ."   Mark Manning, 2012" cr
  ." Rewritten for Solo Forth by:" cr
  ."   Marcos Cruz" cr
  ."   (programandala.net), 2015" cr  ;
  \  <------------------------------>

: press-any-key  ( -- )
  \  <------------------------------>
  ." Press any key to start the game." key drop  ;

: welcome  ( -- )
  page show-credits cr show-game-keys cr cr press-any-key  ;

-->

( pong )

: pong  ( -- )
  init-game welcome page arena
  begin  move-ball
  \ begin key? until key drop  \ XXX TMP -- for debugging
  keypress  again  ;

  \ }}} =======================================================
  \ Benchmarks {{{

  \ This section contains generic benchmarks and benchmarking
  \ tools.
  \
  \ Specific benchmarks written during the development of Solo
  \ Forth, in order to choose between different implementation
  \ options, are in "Development benchamarks" section.

( bench{ }bench }bench. bench. benched )

  \ Credits:
  \
  \ Code adapted from Forth Dimensions (volume 17, number 4
  \ page 11, 1995-11).

  \ System-dependent timing routines.

need reset-frames  need frames@

: bench{  ( -- )  reset-frames  ;
  \ start timing

: }bench  ( -- d )  frames@ ;
  \ stop timing

: bench.  ( d -- )
  2dup d. ." frames (" 50 m/ nip . ." s) "  ;
  \ print the result _d_

: }bench.  ( -- )  frames@ bench.  ;
  \ stop timing and print the result

  \ XXX OLD
  \ : sec.  ( n -- )  s>d <# # # [char] . hold #s #> type  ;

: benched  ( xt n -- d )
  bench{ 0 do  dup execute  loop  }bench rot drop  ;

: benched.  ( xt n -- )
  bench{ 0 do  dup execute  loop  }bench. drop  ;

exit

  \ System-dependent timing routines.
  \ XXX UNDER DEVELOPMENT

  \ Original code.

  \ This is the ForthCMP/ZEN/ANS version.
  \ Output doubles are seconds since midnight.

: t>b  ( sec min hour -- d )  60 * +  60 um*  rot s>d d+  ;

: bench{  ( -- d )  cr get-time t>b 2dup d.  ;
  \ start timing

: }bench  ( d -- )  get-time t>b 2dup d. d- dnegate d.   ;
  \ stop timing

( do-prime )

  \ Eratosthenes Sieve Prime Number program in Forth
  \ by Jim Gilbreath, BYTE Magazine, 1981-09, page 190.

forth definitions decimal

8190 constant size  variable flags  size allot

: do-prime  ( -- )
  flags size 1 fill
  0 size 0
  do flags i + c@
     if i dup + 3 + dup i +
          begin   dup size <
          while   0 over flags + c! over +
          repeat  drop drop 1+
     then
  loop  .  ." primes "  ;

( byte-magazine-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).
  \
  \ 2015-12-24. Removed the Modified: no printing.

need bench{

8190 constant size  variable bflags size allot

: c<- ( a b -- ) swap c!  ;

: do-prime  ( -- )
  bflags size 1 fill  0
  size 0 do   bflags i + c@ if
                i 2* 3 + dup i + bflags +
                begin   dup size bflags +  u<
                while   dup 0 c<- over +
                repeat  drop drop 1+
              then
  loop
  \ u. ." PRIMES" cr  \ XXX OLD
  drop  \ XXX NEW
  ;  -->

( byte-magazine-benchmark )

: byte-magazine-benchmark  ( n -- )
  cr dup u. ." iterations..." cr
  bench{ 0 ?do  do-prime  loop }bench.  ;

  cr
  \  <------------------------------>
  .( To run the BYTE Magazine) cr
  .( benchmark type:) cr
  .(   n byte-magazine-benchmark) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 1000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       -----         -----
  \ 00010  6397          5216
  \ 00100 63970 (1.00)  52159 (0.81)

( interface-age-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ Interface Age Benchmark, 1985-11-16.  This is the Interface
  \ Age benchmark program described in Appendix D of the
  \ forthCMP Manual.

  \ 2015-12-24. Modified: no printing.

need bench{  need 2/

: (interface-age-benchmark)  ( n -- )
  dup 2/ 1+ swap cr
  1 ?do
    dup i 1 rot 2 do
      drop dup 0 i um/mod dup
      0=  if  drop drop 1 leave  then
      1 = if    drop 1
          else  dup 0= if  drop 0 leave  then
                0< 0= if  1  then
          then
    loop
    \ if  .  else  drop  then  \ XXX OLD
    2drop  \ XXX NEW
  loop  drop  ;  -->

( interface-age-benchmark )

: interface-age-benchmark  ( n -- )
  bench{ (interface-age-benchmark) }bench.  ;

  cr
  \  <------------------------------>
  .( To run the interface age) cr
  .( benchmark type:) cr
  .(   n interface-age-benchmark  ) cr
  .( where _n_ is the number of) cr
  .( iterations. The original code) cr
  .( used 5000 iterations.) cr

  \ 2015-12-24
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       ITC           DTC
  \       ------------  ------------
  \ 05000 80091 (1.00)  72445 (0.90)

( vector-loop-benchmark )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

  \ M. Edward Borasky, 1995-07-30

  \ Uses BEGIN ... UNTIL loops; all tested Forth have them
  \ Some small Forth are missing DO ... LOOP or FOR ... NEXT

need bench{

1000 constant vsize  \ vector size

: vector  ( n -- )
  \ make an array
  \ compiling, reserve memory
  create  cells allot
  \ executing, compute address
  does>  ( index -- address )  ( index pfa ) swap cells +  ;

vsize vector vec1  vsize vector vec2  vsize vector vec3

: vecload  ( -- )  \ put some stuff into the vectors
  0 begin
     dup vec1 dup !               \ vec1 gets its own address
     dup vec2 dup negate swap !   \ vec2 gets negated address
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop0  ( -- )  \ null loop
  0 begin  1+ dup vsize =  until  drop  ;

: loop1  ( -- )  \ vector add
  0 begin
     dup vec1 @ over vec2 @ + over vec3 !
     1+ dup vsize =
  until  drop  ;

: loop2 ( -- )  \ vector multiply
  \ XXX FIXME crash!
  0 begin
     dup vec1 @ over vec2 @ * over vec3 !
     1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

: loop3 ( -- ) \ vector divide
  0 begin
    dup vec1 @ over vec2 @ / over vec3 !
    1+ dup vsize =
  until  drop  ;

: loop4 ( -- )  \ vector scale
  0 begin
     dup vec1 @ 10000 10000 */ over vec2 !  1+ dup vsize =
  until  drop  ;

-->

( vector-loop-benchmark )

1000 constant reps  \ repetitions

: bench0  ( -- )  \ benchmark loop0
  bench{ 0 begin  loop0 1+ dup reps =  until  drop }bench.
  ." Vector No-Op" cr  ;

: bench1 ( -- ) \ benchmark loop1
  bench{ 0 begin  loop1 1+ dup reps =  until  drop }bench.
  ." Vector +    " cr  ;

: bench2 ( -- ) \ benchmark loop2 )
  \ XXX FIXME crash!
  bench{ 0 begin  loop2 1+ dup reps =  until  drop }bench.
  ." Vector *    " cr  ;

-->

( vector-loop-benchmark )

: bench3 ( -- )  \ benchmark loop3
  bench{ 0 begin  loop3 1+ dup reps =  until  drop }bench.
  ." Vector /    " cr  ;

: bench4 ( -- ) \ benchmark loop4
  bench{ 0 begin  loop4 1+ dup reps =  until  drop }bench.
  ." Vector */   " cr  ;

: vector-loop-benchmarks  ( -- )
  vecload  cr bench0 bench1 bench2 bench3 bench4  ;

  cr
  \  <------------------------------>
  .( To run the vector loop) cr
  .( benchmarks type:) cr
  .(   vector-loop-benchmarks ) cr

  \ 2015-12-24
  \
  \ Benchmark     Frames (1 frame = 50th of second)
  \ ---------     -----------------------------------
  \               ITC           DTC
  \               ------        -------------
  \ Vector noop    10919 (1.0)    9033 (0.82)
  \ Vector +       58650 (1.0)   47462 (0.80)
  \ Vector *      107770 (1.0)   91611 (0.85)
  \ Vector /      149002 (1.0)  127495 (0.85)
  \ Vector */     178854 (1.0)  154480 (0.86)

( all-benchmarks )

  \ Code adapted from: Forth Dimensions (volume 17, number 4,
  \ page 11, 1995-11).

exit

need byte-magazine-benchmark
need interface-age-benchmark
need vector-loop-benchmark

: all-benchmarks  ( n1 n2 -- )
  byte-magazine-benchmark
  interface-age-benchmark
  vector-loop-benchmark  ;

  \  <------------------------------>
  .( To run all benchmarks type:) cr
  .(   n1 n2 all-benchmarks) cr

( Interface Age Benchmark program )

  \ XXX TODO -- test

  \ Forth Dimensions (volume 2, number 4, page 112)

: bench  ( -- )
  dup 2 / 1+ swap ." Starting " cr
  1 do dup i 1 rot
    2 do drop dup i /mod
      dup 0= if  drop drop 1 leave
      else  1 = if drop 1
            else  dup 0 > if  drop 1
                  else  0= if  0 leave  then
                  then
            then
      then
    loop
    if  4 .r  else  drop  then
  loop  drop cr ." Finished " ;

  \ }}} =======================================================
  \ Development benchmarks {{{

  \ This section contains specific benchmarks written during
  \ the development of Solo Forth in order to decide between
  \ different implementation options.
  \
  \ Generic benchmarks are in the "Benchmarks" section.

( number-base-bench )

: number-base-1  ( ca len -- ca' len' n )
  \ This is the current version defined in the kernel.
  over c@ [char] $ = if  1 /string 16  exit  then
  over c@ [char] % = if  1 /string  2  exit  then
  over c@ [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-2  ( ca len -- ca' len' n )
  over c@ >r
  r@ [char] $ = if  1 /string 16  rdrop exit  then
  r@ [char] % = if  1 /string  2  rdrop exit  then
  r> [char] # = if  1 /string 10  exit  then  base @  ;

: number-base-3  ( ca len -- ca' len' n )
  over c@
  dup >r [char] $ = if  1 /string 16  rdrop exit  then
      r@ [char] % = if  1 /string  2  rdrop exit  then
      r> [char] # = if  1 /string 10  exit  then  base @  ;

-->

( number-base-bench )

: number-base-4  ( ca len -- ca' len' n )
  over c@
  dup [char] $ = if  drop 1 /string 16  exit  then
  dup [char] % = if  drop 1 /string  2  exit  then
      [char] # = if  1 /string 10  exit  then  base @  ;

need frames@  need reset-frames  defer (number-base)

: (number-base-bench)  ( n xt -- )
  ['] (number-base) defer!
  reset-frames  0 do  s" 000" (number-base) drop 2drop  loop
  frames@ d. cr  ;

: number-base-bench  ( n -- )
  dup ['] number-base-1 (number-base-bench)
  dup ['] number-base-2 (number-base-bench)
  dup ['] number-base-3 (number-base-bench)
      ['] number-base-4 (number-base-bench) ;

  \ 2015-10-09
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          1    2    3    4
  \       ---- ---- ---- ----
  \ 01000   73   75   74   69
  \ 10000  732  744  736  686
  \ 32000 2343 2382 2367 2194

( fill-bench )

  \ 2015-09-25: Benchmark three implementations of `fill`:
  \
  \ `fill` is the original implementation from Abersoft Forth
  \ `fill2` is a modified version
  \ `fill88` is the code adapted from Z88 CamelForth

need frames@  need reset-frames  need rnd

defer (fill)

: (fill-bench)  ( n xt -- )
  ['] (fill) defer!
  reset-frames  0
  do  16384 6144 rnd (fill)  loop
  \ do  16384 1 rnd (fill)  loop
  \ do  16384 0 rnd (fill)  loop
  \ do  16384 2048 rnd (fill)  loop
  frames@ cr d.
  key drop  ;

: fill-bench  ( n -- )
  dup ['] fill (fill-bench)
  dup ['] fill2 (fill-bench)
      ['] fill88 (fill-bench)  ;

  \ Kernel code: `16384 6144 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010   10    10      5
  \ 00100  491   522    252
  \ 01000 4909  5218   2524

  \ Kernel code: `16384 1 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    9     8      8
  \ 01000   85    84     84
  \ 05000  425   423    422
  \ 10000  850   846    845

  \ Kernel code: `16384 0 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill fill2 fill88
  \       ---- ----- ------
  \ 00010    1     0      0
  \ 00100    8     8      8
  \ 01000   84    83     84
  \ 05000  421   418    421
  \ 10000  842   837    842

  \ Kernel code: `16384 2048 rnd (fill)`
  \
  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       fill  fill2 fill88
  \       ----- ----- ------
  \ 00010    17    18      9
  \ 00100   169   180     89
  \ 01000  1693  1795    898
  \ 30000 50770 53863  26933

( value-bench )

need frames@  need reset-frames

0 value v1

: value-bench  ( n -- )
  reset-frames  0 do  v1 drop  loop  frames@ cr d.  ;

( 2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2value-bench  ( n -- )
  reset-frames  0 do  v2 2drop  loop  frames@ cr d.  ;

( to-value-bench )

need frames@  need reset-frames

0 value v1

: to-value-bench  ( n -- )
  reset-frames  0
  do  0 to v1   loop
  frames@ cr d.  ;

( to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: to-2value-bench  ( n -- )
  reset-frames  0
  do  0. to v2   loop
  frames@ cr d.  ;

( 2to-2value-bench )

need frames@  need reset-frames

0. 2value v2

: 2to-2value-bench  ( n -- )
  reset-frames  0
  do  0. 2to v2   loop
  frames@ cr d.  ;

( rshift-bench lshift-bench )

need frames@  need reset-frames

: rshift-bench  ( n -- )
  reset-frames  0
  do  128 255 rshift drop   loop
  frames@ cr d.  ;

: lshift-bench  ( n -- )
  reset-frames  0
  do  128 255 lshift drop   loop
  frames@ cr d.  ;

  \ 2015-11-01

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       rshift         lshift
  \       -------------- --------------
  \        Z88  DZX    %  Z88  DZX    %
  \       ---- ---- ---- ---- ---- ----
  \ 10000 1203 1609 133% 1016 1723 169%
  \ 30000 3607 4826 133% 3048 5170 169%

  \ Z88 = code adapted from Z88 CamelForth
  \ DZX = code adapted from DZX-Forth

( /-bench )

  \ 2015-09-22: This bench compares the execution speed of
  \ Abersoft Forth's `m/` and Z88 CamelForth's `sm/rem`. Both
  \ words are equivalent.  Abersoft Forth's `m/` is much
  \ faster.

need frames@  need reset-frames  need rnd

: drnd  ( -- d )  rnd rnd  ;

[defined] (/)  ?\ defer (/)

: (/-bench)  ( n -- )
  reset-frames
  1+ 1 do  drnd i (/) 2drop  loop  frames@ cr d.  ;

: /-bench  ( n -- )
  dup ['] m/ ['] (/) defer! (/-bench)
      ['] sm/rem ['] (/) defer! (/-bench)  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       m/    sm/rem
  \       ----- ------
  \ 00010     3      4
  \ 00100    33     44
  \ 01000   326    442

  \ m/     = word from Abersoft Forth
  \ sm/rem = word from Z88 Camel Forth

( um*-bench )

need frames@  need reset-frames

: um*-bench  ( n -- )
  reset-frames  0 do  i i um* 2drop  loop  frames@ d.  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       DZX   hForth R hForth A Z88 R Z88 A
  \       ----- -------- -------- ----- -----
  \ 00100     3        3        3     3     3
  \ 01000    29       32       31    32    31
  \ 10000   297      328      319   323   316
  \ 20000   598      659      643   647   633
  \ 32000   961     1060     1037  1037  1016

  \            Bytes free Code from
  \            ---------- ---------
  \ DZX      = 33783      DZX-Forth
  \ hForth R = 33787      hForth, with relative jumps
  \ hForth A = 33784      hForth, with absolute jumps
  \ Z88 R    = 33786      Z88 CamelForth, with relative jumps
  \ Z88 A    = 33784      Z88 CamelForth, with absolute jumps

( um/mod-bench )

  \ 2015-11-24

need bench{

: um/mod-bench  ( n -- )
  bench{  0 do  i s>d i um/mod 2drop  loop  }bench.  ;

: um/mod-bench88  ( n -- )
  bench{  0 do  i s>d i um/mod88 2drop  loop  }bench.  ;

: um/mod-bench  ( n -- )
  dup cr ." Abersoft Forth  U/MOD ..." um/mod-bench
      cr ." Z88 CamelForth UM/MOD ..." um/mod-bench88  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \          AF      Z88
  \       ----- --------------
  \ 00100     6        5
  \ 01000    59       42 (71%)
  \ 10000   587      428 (72%)
  \ 20000  1157      875 (75%)
  \ 32000  1881     1372 (72%)

  \            Bytes free Code from
  \            ---------- ---------
  \ AF         32689      Abersoft Forth
  \ Z88        32707      Z88 CamelForth

( ud/mod-bench )

  \ 2015-12-21

need bench{

: a-m/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod drop 2drop  loop  }bench.  ;

: z1-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod881 drop 2drop  loop  }bench.  ;

: z2-ud/mod  ( n -- )
  bench{  0 do  i s>d i ud/mod882 drop 2drop  loop  }bench.  ;

: run  ( n -- )
  dup cr ." Abersoft Forth  M/MOD ..." a-m/mod
  dup cr ." Z88 CamelForth UD/MOD 1..." z1-ud/mod
      cr ." Z88 CamelForth UD/MOD 2..." z2-ud/mod  ;

  \ 10000 run  20000  run 65535 run

  \ Times   Frames (1 frame = 50th of second)
  \ -----   -----------------------------------
  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ 10000     964    967      944
  \ 20000    1928   1934     1888
  \ 65535    6300   6316     6161

  \            AF    Z88 (1) Z88 (2)
  \         ----- ---------- -------
  \ B used:    22         22      20 (3)

  \ (1) Z88 CamelForth code
  \ (2) Z88 CamelForth code, with `-rot` instead of `rot rot`
  \ (3) Not including the size of `-rot`

( number? )

  \ XXX UNDER DEVELOPMENT
  \ Improved alternative to `number?`.

: solo-number?   ( ca len -- 0 | n 1 | d 2 )
  dup 0= if  2drop 0 exit  then
  base @ >r number-base base !
  skip-sign? >r
  0 0 2swap  dpl on
  begin
    >number dup
  while
    over c@ [char] . <>  \ not a decimal point?
    dpl @ 0< 0=  or  \ or not the first decimal point?
    if  2drop 2rdrop 0 exit  then
    dup 1- dpl !  1 /string
  repeat  2drop  dpl @ 0<
  if    d>s r> ?negate  1
  else  r> ?dnegate  2  then  r> base !  ;

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 12345" num?   s" 12345." num?
    s" -12345" num?  s" -12345." num?  empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

                                    \ Version of `number?`
  \    ' number? ' num? defer! benchs  \ pForth
  \  ' c.number? ' num? defer! benchs  \ CamelForth
  \ ' dzx-number? ' num? defer! benchs  \ DZX-Forth
   ' solo-number? ' num? defer! benchs  \ Solo Forth

  \ Note: The CamelForth code is for single numbers only.
  \       The DZX-Forth code is a bit obfuscated.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \       pForth CamelForth DZX-Forth Solo Forth
  \       ------ ---------- --------- ----------
  \ 00100    256        257       259        266
  \ 01000   2559       2565      2594       2658
  \ 10000  25591      25652     25933      26581

( number?-bench )

  \ 2015-10-14

need frames@  need reset-frames

: empty-stack  ( -- )  sp0 @ sp!  ;

defer num?

: number?-bench  ( n -- )
  reset-frames  0 do
    s" " num?  s" 123x45." num?   s" 12345.999x" num?
    s" -12345.x" num?  s" -12345.999x" num?
    s" -12345.000.000" num?
    empty-stack
  loop  frames@ cr d.  ;

: benchs  ( -- )
  100 number?-bench 1000 number?-bench 10000 number?-bench  ;

' solo-number? ' num? defer! benchs

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \ 00100   416
  \ 01000  4165
  \ 10000 41649

( dummy-needed )

( buffer-benchmark-1 )

  2 load need reset-frames
  reset-frames

  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed need dummy-needed need dummy-needed
  need dummy-needed

  frames@ cr .( Frames ) d. cr

  \ 2015-11-04

  \ Benchmark: Locate and load 16 times empty block #457.

  \ Times Frames (1 frame = 50th of second)
  \ ----- -----------------------------------
  \        512-byte buffer 1024-byte buffer
  \       ---------------- ----------------
  \    16             6323       8621 (136%)

( buffer-benchmark-2 )

  2 load  need reset-frames  warnings off  reset-frames

  need list  need dump  need wdump  need decode
  need life  need hanoi  need tt need siderator  need pong
  need doer  need a!  need defer  need value  need editor
  need case  need times  need dtimes  need for

  frames@ cr .( Frames ) d. cr

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-04 512-byte buffer       33742        20960 (1.00)
  \            1024-byte buffer      33277 (-465) 24310 (1.15)
  \                                               24042 (1.14)

  \ This is not good for benchmarking the headers, because most
  \ of the time is wasted locating the blocks. That's why
  \ both methods are equally fast:

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

  \ XXX UNDER DEVELOPMENT

need bench{ warnings off bench{ : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ;
: w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; : w ; }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        490 (9 s)
  \            `next-name` (4)       32791        494 (9 s)
  \            `nextname` (2)        32781        491 (9 s)
  \            `nextname` (3)        32765        494 (9 s)

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.
  \
  \ (3) Same as (2) but with zero-length name check.
  \
  \ (4) Same as (1) but with zero-length name check.

( header-benchmark )

  \ XXX UNDER DEVELOPMENT

need bench{ warnings off blk @ 1+ constant b bench{ b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load b load
b load b load b load b load b load b load b load b load }bench.

  \ Benchmark: interpretation of many source blocks from disk.

  \ ------------------------------------------------------------
  \ Date       Condition             Bytes free   Frames (=20ms)
  \ ---------- --------------------- ------------ --------------
  \ 2015-11-17 `next-name` (1)       32807        40530
  \                                               40485
  \                                               40526
  \            `nextname` (2)        32781        40555
  \                                               40510
  \                                               40554

  \ (1) First method: `next-name` is a double variable that may
  \ hold a string to be used as name by the next defining word.
  \ `header` always checks this string and, if it's not empty,
  \ uses it instead of parsing and then emptis it.
  \
  \ (2) Second method (written after Gforth): `nextname` stores
  \ a string into the double variable `nextname-string`, and
  \ sets the deferred word `header` to `nextname-header`, which
  \ creates the header with the string name and restores the
  \ default action of `header`: `input-stream-header`. This
  \ method is more versatile and, beside, words with emtpy
  \ names can be created.

( header-benchmark )

: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;
: foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ; : foo ;

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sp0 @ sp!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

  frames@ cr .( Frames ) d. cr  sp0 @ sp!

  \ 2015-11-12
  \
  \ How `interpret`
  \ interprets numbers   Bytes free  Frames
  \ ------------------   ----------  -------------
  \ branches (1)              32766     500 (1.00)
  \ execution table (1)       32770     497 (0.99)
  \ execution table (2)       32761     498 (0.99)

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

: foo  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  ;

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ compiles numbers    Bytes free  Frames
  \ ----------------    ----------  ------------
  \ branches (1)             32766     510 (1.00)
  \ execution table (1)      32770     507 (0.99)
  \ execution table (2)      32761     508 (0.99)

  \ (1): before implementing an execution table for words
  \ (2): shared with the words, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ interprets words               Bytes free  Frames
  \ ------------------             ----------  -------------
  \ branches (0)                        32770     192 (1.00)
  \ independent table (1)               32746     190 (0.98)
  \ combined table (2)                  32747     190 (0.98)
  \ combined table (3)                  32753     192 (1.00)
  \ combined table (4)                  32761     190 (0.98)

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor

  \ 1 frame = 50th of second

( interpret-benchmark )

  \ Compare two versions of `interpret`.

  2 load  need reset-frames  reset-frames

: foo noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop
noop noop noop noop noop noop noop noop noop noop noop noop ;

  frames@ cr .( Frames ) d. cr

  \ 2015-11-12
  \
  \ How `interpret`
  \ compiles words                 Bytes free  Frames
  \ ------------------             ----------  -------------
  \ branches (0)                        32770     199 (1.00)
  \ independent table (1)               32746     198 (0.98)
  \ combined table (2)                  32747     198 (0.99)
  \ combined table (3)                  32753     200 (1.00)
  \ combined table (4)                  32761     198 (0.98)

  \ (0): after implementing an execution table for numbers
  \ (1): separate from the numbers table
  \ (2): shared with the numbers
  \ (3): shared with the numbers, using a common factor
  \ (4): shared with the numbers, integrating the common factor

  \ 1 frame = 50th of second

( constant-bench )

  \ 2016-02-16: New version.

need bench{ need }bench.

3 constant const1

: bench1  ( n -- )
  bench{ 0 do  const1 drop  loop }bench.  ;

: bench2  ( n -- )
  bench{ 0 do  3 drop  loop }bench.  ;

: constant-bench  ( n -- )  dup cr bench1 cr bench2  ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \  1000                      6      5
  \ 52000                    307    284
  \ 65535                    386    358

( constant-bench )

need reset-frames  need frames@

0 constant const1

: bench1  ( n -- )
  reset-frames 0 do  const1 drop  loop
  frames@ d. cr ;

: const2  ( -- x )  const1 cell+  ;

: bench2  ( n -- )
  reset-frames 0 do  const2 drop  loop
  frames@ d. cr ;

( literal-bench )

need reset-frames  need frames@

: bench1  ( n -- )
  reset-frames 0 do  cell negate drop  loop
  frames@ d. cr ;

: bench2  ( n -- )
  reset-frames 0 do  [ cell negate ] literal drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                       bench1 bench2
  \                       ------ ------
  \ 32000                    320    249

( 0-bench false-bench )

need reset-frames  need frames@

  \ This bench compares `0` (implemented as a `cconstant`) and
  \ `false` (written in assembler).

: 0-bench  ( n -- )
  reset-frames 0 do  0 drop  loop
  frames@ d. cr ;

: false-bench  ( n -- )
  reset-frames 0 do  false drop  loop
  frames@ d. cr ;

  \ Times Frames (1 frame = 50th of second)
  \ ----- ---------------------------------
  \                           0       false
  \                       ----- -----------
  \ 32000                   251   236 (94%)

( d*-bench )

  \ `d*` by Wil Baden, published on Forth Dimensions
  \ (volume 19, number 6, page 33, 1998-04).

: baden-d*  ( d1 d2 -- d3 )
  >r swap >r            ( d1lo d2lo ) ( R: d2hi d1hi )
  2dup um* 2swap        ( d1lo*d2lo d1lo d2lo )
  r> * swap r> * + +  ; ( d1*d2 ) ( R: )

  \ `d*` by Robert L. Smith, published on Forth Dimensions
  \ (volume 4, number 1, page 3, 1982-05).

need pick  need roll

: smith-d*  ( d1 d2 -- d3 )
  over 4 pick um*  5 roll 3 roll * +  2swap * +  ;

  \ `d*` from DX-Forth 4.13

unused
: dx-d* ( d|ud1 d|ud2 -- d|ud3 )
  >r swap >r 2dup um* rot r> * + rot r> * + ;
unused - . cr key drop

-->

( d*-bench )

need bench{

: baden-d*-bench  ( n -- )  0 do  1. 2. baden-d* 2drop  loop  ;
: smith-d*-bench  ( n -- )  0 do  1. 2. smith-d* 2drop  loop  ;
: dx-d*-bench  ( n -- )  0 do  1. 2. dx-d* 2drop  loop  ;

: d*-benchs  ( -- )
  page
  32767 dup bench{ baden-d*-bench }bench.
        dup bench{ smith-d*-bench }bench.
            bench{ dx-d*-bench }bench.  ;

  \ 2015-11-09: baden-d*, smith-d*

  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4920 (98 seconds)  1.00
  \ smith-d*  5189 (103 seconds) 1.05

  \ 2015-12-22:
  \
  \ Bench     Frames for 32767 iterations
  \ -----     ---------------------------
  \ baden-d*  4860 (97 seconds)   1.0008
  \ smith-d*  5139 (102 seconds)  1.0582
  \ dx-d*     4856 (97 seconds)   1.0000

( case-benchs )

  \ Comparison of case-like structures.
  \
  \ 2015-11-14: `case` (4 versions), `case:`, `options[` and
  \ `cases:`.
  \ 2015-12-14: Updated the comments: `case:` has been renamed
  \ to `positional-case:`.

need bench{

warnings off

: .used  ( u -- )  unused - cr u. ." B used " ;

32767 constant iterations

defer (case-bench)  ( -- )

: case-bench  ( n xt -- )
  cr ." ..."
  ['] (case-bench) defer!
  bench{
  iterations 0 do  i %11 and (case-bench)  loop
  }bench.  ;

-->

( case-benchs )

cr .( case)
unused need case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( eForth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

cr .( case from the Forth-94 docs)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

cr .( Abersoft Forth case)
unused need eforth-case .used  unused
: case-example  ( n -- )
  case
  0 of  noop  endof  1 of  noop  endof  2 of  noop  endof
  noop endcase  ;
.used .( by its example)  ' case-example case-bench

-->

( case-benchs )

  \ Note: the `positional-case:` structure is more specific
  \ than the other structures: it lacks a default option and
  \ its argument is positional.

cr .( positional-case:)
unused need positional-case: .used  unused
positional-case:  positional-case:-example  ( n -- )
  noop  noop  noop  noop ;
.used .( by its example)  ' positional-case:-example case-bench

cr .( options[)
unused need options[ .used  unused
: options[-example  ( n -- )
  options[
    0 option noop  1 option noop  2 option noop
      default-option noop
  ]options  ;
.used .( by its example)  ' options[-example case-bench

-->

( case-benchs )

cr .( cases:)
unused need cases: .used  unused
cases: cases:-example  ( n -- )
  0 case> noop  1 case> noop  2 case> noop  other> noop
.used .( by its example)  ' cases:-example case-bench

cr .( baden-case)
unused need baden-case .used  unused
: baden-case-example  ( n -- )
  case 0 = of  noop  endof
  case 1 = of  noop  endof
  case 2 = of  noop  endof
           othercase noop  ;
.used .( by its example)  ' baden-case-example case-bench

-->

( case-benchs )

cr .( baden-case-like)
unused .used  unused
: baden-case-like-example  ( n -- )
  dup 0 = if drop  noop  exit then
  dup 1 = if drop  noop  exit then
      2 = if       noop  exit then
  noop  ;
.used .( by its example)  ' baden-case-like-example case-bench

cr .( vannorman-switch)
unused need [switch .used  unused
[switch vannorman-switch-example drop
  0 runs noop  1 runs noop  2 runs noop
switch]
.used .( by its example)  ' vannorman-switch-example case-bench


  \                        Bytes used            Speed (3)
  \                        --------------------- --------------
  \ Structure              Code (1)  Example (2) Frames Seconds
  \ ---------              --------- ----------- ------ -------
  \ case (7)                 48       62          1365   27
  \ eforth-case (8)          54       62          1366   27
  \ 94-doc-case (6)          54       62          1365   27
  \ abersoft-case (5)        64       62          1365   27
  \ positional-case: (4)     21       12           823   16
  \ options[ (9)            166       24          3627   72
  \ cases: (10)             109       18          3155   63
  \ baden-case (11)          18       56          1472   29
  \ baden-case (12)          36       56          1472   29
  \ baden-case (13)           0       50          1353   27
  \ vannorman-switch (14)   124       24          3573   71

  \ (1) Bytes used by the compilation of the structure's code.
  \
  \ (2) Bytes used by the tested example: a structure with
  \ three options plus default, that execute a `noop`.
  \
  \ (3) For 32767 iterations with parameter 0..3. One system
  \ frame is 20 ms.

  \ (4) A port of F83's `case:`. It is more specific than the
  \ other structures: it lacks a default option and its
  \ argument is positional.
  \
  \ (5) Eaker/Forth-94 `case` of Abersoft Forth, but with
  \ compiler security removed.
  \
  \ (6) Eaker/Forth-94 `case` copied from the Forth-94
  \ documentation.
  \
  \ (7) Eaker/Forth-94 `case` of eForth, with a little
  \ simplification. This is the default `case` used in Solo
  \ Forth.
  \
  \ (8) Eaker/Forth-94 `case` of eForth.
  \
  \ (9) A port of IsForth's `case:`.
  \
  \ (10) A port of a structure written by Dan Lerner, published
  \ on Forth Dimensions (volume 3, number 6, page 189,
  \ 1982-03).
  \
  \ (11) "Ultimate CASE Statement", written by Wil Baden,
  \ published on Forth Dimensions (volume 8, number 5, page 29,
  \ 1987-01).
  \
  \ (12) The same "Ultimate CASE Statement", by Wil Baden, with
  \ two syntactic sugar words added: `endof` and `othercase`.
  \
  \ (13) The same "Ultimate CASE Statement", by Wil Baden,
  \ emulated with standard words. This is a bit faster because,
  \ without the syntactic sugar definitions, one `dup` and two
  \ `drop` are saved.
  \
  \ (14) Code by Rick VanNorman, published on Forth Dimensions
  \ (volume 20, number 3, pages 19..22, 1998-09).

( misc-benchs )

  \ Some misc speed benchs.

need bench{  need 0if

: bench1  ( n -- )
  begin  ?dup if  1 - else exit then  again  ;

: bench1a  ( n -- )
  begin  ?dup if  1- else exit then  again  ;

: bench2  ( n -- )
  begin  dup 0= if  drop exit then 1-  again  ;

: bench2a  ( n -- )
  begin  dup 0if  drop exit then 1-  again  ;

: bench3  ( n -- )
  begin  ?dup 0if  exit then 1-  again  ;


: misc-benchs  ( -- )
  32767 dup bench{ bench1 }bench.
        dup bench{ bench2 }bench.
            bench{ bench3 }bench.  ;

  \ Bench    Frames for 32767 iterations
  \ -----   ---------------------------
  \ bench1   655 (`1 -`)
  \ bench1a  576 (`1-`)
  \ bench2   320 (`0= if`: 100%)
  \ bench2a  245 (`0if`:    76%)
  \ bench3   528

( 2swap-bench )

  \ 2015-11-24

need bench{

: 2swap-bench  ( -- )
  32767 0 bench{ 2dup do  2swap  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From DZX-Forth                271 (5 s) (1.00)
  \ Adapted from Z88 CamelForth   243 (4 s) (0.89)

( dnegate-bench )

  \ 2015-11-24

need bench{

: dnegate-bench  ( -- )
  32767 0 bench{ 2dup do  dnegate  loop  }bench. 2drop  ;

: dnegate-bench2  ( -- )
  32767 0 bench{ 2dup do  dnegate2  loop  }bench. 2drop  ;

  \ Code                          Frames for 32767 iterations
  \ -----                         ---------------------------
  \ From Abersoft Forth           243 (4 s) (1.00)
  \ From Spectrum Forth-83        253 (5 s) (1.04)

( ?dup-bench )

  \ 2016-01-01

need bench{  variable times  40000 times !

: iterations  ( -- n1 n2 )  times @ 0  ;

: forth-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup drop  loop  }bench.  ;

: z80-0-?dup-bench  ( -- )
  bench{ iterations do  0 ?dup80 drop  loop  }bench.  ;

: forth-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup 2drop  loop  }bench.  ;

: z80-1-?dup-bench  ( -- )
  bench{ iterations do  1 ?dup80 2drop  loop  }bench.  ;

: ?dup-bench  ( -- )
  cr ." Forth version:" cr ." 0 ?dup :" forth-0-?dup-bench cr
                           ." 1 ?dup :" forth-1-?dup-bench cr
     ." Z80 version:"   cr ." 0 ?dup :" z80-0-?dup-bench cr
                           ." 1 ?dup :" z80-1-?dup-bench cr  ;

  \ Code        Frames for 40000 iterations
  \ -----       ---------------------------
  \             Forth  Z80
  \             -----  ----
  \ `0 ?dup`    532    288
  \ `1 ?dup`    585    312

( #spaces-bench )

need under+

: #spaces1  ( ca len -- +n )
  0 rot rot  0 do  count bl = 1 and under+  loop  drop ;
  \ From:
  \ http://forth.sourceforge.net/mirror/comus/index.html

: #spaces2  ( ca len -- +n )
  0 rot rot  bounds do  i c@ bl = +  loop  abs  ;
  \ First variant.

: #spaces3  ( ca len -- +n )
  0 rot rot  0 do  count bl = under+  loop  drop abs  ;
  \ Second variant, the fastest one.

need bench{

defer #spaces

: #spaces-bench  ( n -- )
  cr bench{  0 do  0 32767 #spaces drop  loop  }bench.  ;

: run  ( n -- )
  dup ['] #spaces1 ['] #spaces defer! ." 1..." #spaces-bench
  dup ['] #spaces2 ['] #spaces defer! ." 2..." #spaces-bench
      ['] #spaces3 ['] #spaces defer! ." 3..." #spaces-bench  ;

  \         Frames by iterations
  \         --------------------
  \ Version 10 iterations 100 iterations
  \ ------- ------------- --------------
  \ 1                 123           1231
  \ 2                 103           1036
  \ 3                  95            951

  \ Note: 1 frame = 50th of second

( do-bench )

  \ 2015-12-17

need bench{

32767 0 2constant range

: forth-83-do  ( -- )  bench{  range do83  loop83  }bench.  ;

: forth-79-do  ( -- )  bench{  range do  loop  }bench.  ;

: forth-83-i  ( -- )
  bench{  range do83  i83 drop  loop83  }bench.  ;

: forth-79-i  ( -- )
  bench{  range do  i drop  loop  }bench.  ;

: forth-83-+loop  ( -- )
  bench{  range do83  2 +loop83  }bench.  ;

: forth-79-+loop  ( -- )  bench{  range do  2 +loop  }bench.  ;

: do-bench  ( -- )
  forth-83-do forth-79-do
  forth-83-i forth-79-i
  forth-83-+loop forth-79-+loop  ;

  \           Frames by 32767 iterations
  \           --------------------------
  \ Bench     Forth-79  Forth-83
  \ --------  --------  --------
  \ loop           143       109
  \ i              264       258
  \ +loop          108        97

  \ Note: 1 frame = 50th of second

( emit-udg-bench )

  \ 2015-12-18

need bench{

: e  ( n -- )
  bench{ 0 ?do  home 128 emit  loop  }bench.  ;
: eu  ( n -- )
  bench{ 0 ?do  home 128 emit-udg  loop  }bench.  ;

  \             Frames (20 ms)
  \             -----------------------
  \ Iterations  emit        emit-udg
  \ ----------  ----------- -----------
  \ 32000       1904 (1.00) 1856 (0.97)

  \ }}} =======================================================
  \ Development tests {{{

( alias-test synonym-test )

  \ 2015-11-24

need alias need synonym

' literal alias literal-a
' border alias border-a
' if alias if-a

synonym border-s border
synonym literal-s literal
synonym if-s if

  \ XXX TMP -- alternative `synonym` that uses `alias`
synonym2 border-s2 border
synonym2 literal-s2 literal
synonym2 if-s2 if

  \ : ifa if-a ." yes" then ;   \ "then" error #-4
  \ : ifs if-s ." yes" then ;   \ ok
  \ : ifs2 if-s2 ." yes" then ;   \ "then" error #-4
  \
  \ 1 literal     \ error -14 \ ok
  \ 1 literal-a   \ no error
  \ 1 literal-s   \ error -14 \ ok
  \ 1 literal-s2  \ no error
  \
  \ : zx [ 1 ] literal ;      \ ok
  \ : zx [ 1 ] literal-a ;    \ error #-264
  \ : zx [ 1 ] literal-s ;    \ no error \ ok
  \ : zx [ 1 ] literal-s2 ;   \ error #-264

( until-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code until-test  ( -- )
  begin
    nop
  z until  jpnext
  end-code

' until-test >body 5 dump

( if'-test )

  \ XXX TMP for debugging
  \ XXX OLD

need z80-asm  need dump

code if'-test  ( -- )

  .( here is ) here u.

  p' if'  \ not expecting a regular character

    nz if  \ not expecting the column
      \ expecting the line
      \ get_lin:
      cpl  C0 add#  \ now A = 191 - char
      hl incp
    then
    \ get_col:
    hl incp  a m ld
    ret

  then'  end-code

' if'-test >body dup here swap - dump

( {if-test {do-test )

  \ 2015-11-11

: test2  ( n -- )
  {do   dup 5 <   do> ." <5" cr 1+
  |do|  dup 10 <  do> ." <10" cr 1+
  do} drop  ;

: test1  ( n1 n2 -- )
  {if   2dup > if> ." >" cr
  |if|  2dup < if> ." <" cr
  if}  ;

( options[-test )

: o1 ." option 1" ;  : o2 ." option 2" ;  : o3 ." option 3" ;

: test  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
  ]options  ." end of test" cr   ;

: retest  ( -- )  [char] a test ." end of retest" cr  ;

: o0 ." default" ;

: testd  ( c -- )
  options[
    char a option o1  char b option o2  char c option o3
    default-option o0
  ]options  ;

( /-test )

  \ 2015-09-22: This test shows that Abersoft Forth's `m/` does
  \ a symmetric division, and so it's equivalent to Forth-94's
  \ `sm/rem`.

  \ From the Forth-94 documentation:

     \ Table 3.4 - Symmetric Division Example

     \ Dividend        Divisor Remainder       Quotient
     \ --------        ------- ---------       --------
     \ 10                 7       3                1
     \ -10                7      -3               -1
     \ 10                -7       3               -1
     \ -10               -7      -3                1

[defined] (/)  ?\ defer (/)

: ((/-test))  ( dividend divisor -- )
  >r s>d r> (/) swap . . space  ;

: (/-test)  ( -- )
  cr  10  7 ((/-test)) -10  7 ((/-test))
      10 -7 ((/-test)) -10 -7 ((/-test))  ;

: /-test  ( -- )
  dup ['] m/     ['] (/) defer! (/-test)
      ['] sm/rem ['] (/) defer! (/-test)  ;

( exception-test )

  \ Credits:
  \
  \ Code from MPE Forth for TiniARM User Manual.

: could-fail  ( -- c )
  key dup [char] q =
  if  -1 throw  then  ;

: do-it  ( a b -- c )
  2drop could-fail  ;

: try-it  ( -- )
  1 2 ['] do-it catch
  if    ( x1 x2 )  2drop ." There was an exception" cr
  else  ." The character was " emit cr then  ;

: retry-it  ( -- )
  begin   1 2 ['] do-it catch
  while   ( x1 x2 ) 2drop ." Exception, keep trying" cr
  repeat  ( c )
  ." The character was " emit cr  ;

( err>ord )

  \ XXX TMP -- `err>ord` tests `error>ordinal`

: err>ord  ( -- )
  91 1 do  i . i error>ordinal ."  -> " . cr  loop
  286 256 do  i . i error>ordinal ."  -> " . cr  loop
  1025 1000 do  i . i error>ordinal ."  -> " . cr  loop ;

.( block x line 0 ) cr
  .( block x line 1 ) cr
  .( block x line 2 ) cr
  .( block x line 3 ) cr
  .( block x line 4 ) cr
  .( block x line 5 ) cr
  .( block x line 6 ) cr
  .( block x line 7 ) cr
  .( block x line 8 ) cr
  .( block x line 9 ) cr
  .( block x line 10 ) cr
  .( block x line 11 ) cr
  .( block x line 12 ) cr
  .( block x line 13 ) cr
  .( block x line 14 ) cr
  .( block x line 15 ) cr
.( block x+1 line 0 ) cr
  .( block x+1 line 1 ) cr
  .( block x+1 line 2 ) cr
  .( block x+1 line 3 ) cr
  .( block x+1 line 4 ) cr
  .( block x+1 line 5 ) cr
  .( block x+1 line 6 ) cr
  .( block x+1 line 7 ) cr
  .( block x+1 line 8 ) cr
  .( block x+1 line 9 ) cr
  .( block x+1 line 10 ) cr
  .( block x+1 line 11 ) cr
  .( block x+1 line 12 ) cr
  .( block x+1 line 13 ) cr
  .( block x+1 line 14 ) cr
  .( block x+1 line 15 ) cr

  \ }}} =======================================================
  \ Error codes {{{

( Standard error codes #-01..#-15 )

\ #-01 ABORT
\ #-02 ABORT"
\ #-03 stack overflow
\ #-04 stack underflow
\ #-05 return stack overflow
\ #-06 return stack underflow
\ #-07 do-loops nested too deeply during execution
\ #-08 dictionary overflow
\ #-09 invalid memory address
\ #-10 division by zero
\ #-11 result out of range
\ #-12 argument type mismatch
\ #-13 undefined word
\ #-14 interpreting a compile-only word
\ #-15 invalid FORGET

( Standard error codes #-16..#-30 )

\ #-16 attempt to use zero-length string as a name
\ #-17 pictured numeric output string overflow
\ #-18 parsed string overflow
\ #-19 definition name too long
\ #-20 write to a read-only location
\ #-21 unsupported operation
\ #-22 control structure mismatch
\ #-23 address alignment exception
\ #-24 invalid numeric argument
\ #-25 return stack imbalance
\ #-26 loop parameters unavailable
\ #-27 invalid recursion
\ #-28 user interrupt
\ #-29 compiler nesting
\ #-30 obsolescent feature

( Standard error codes #-31..#-45 )

\ #-31 >BODY used on non-CREATEd definition
\ #-32 invalid name argument
\ #-33 block read exception
\ #-34 block write exception
\ #-35 invalid block number
\ #-36 invalid file position
\ #-37 file I/O exception
\ #-38 non-existent file
\ #-39 unexpected end of file
\ #-40 invalid BASE for floating point conversion
\ #-41 loss of precision
\ #-42 floating-point divide by zero
\ #-43 floating-point result out of range
\ #-44 floating-point stack overflow
\ #-45 floating-point stack underflow

( Standard error codes #-46..#-60 )

\ #-46 floating-point invalid argument
\ #-47 compilation word list deleted
\ #-48 invalid POSTPONE
\ #-49 search-order overflow
\ #-50 search-order underflow
\ #-51 compilation word list changed
\ #-52 control-flow stack overflow
\ #-53 exception stack overflow
\ #-54 floating-point underflow
\ #-55 floating-point unidentified fault
\ #-56 QUIT
\ #-57 exception in sending or receiving a character
\ #-58 [IF], [ELSE], or [THEN] exception
\ #-59 ALLOCATE
\ #-60 FREE

( Standard error codes #-61..#-75 )

\ #-61 RESIZE
\ #-62 CLOSE-FILE
\ #-63 CREATE-FILE
\ #-64 DELETE-FILE
\ #-65 FILE-POSITION
\ #-66 FILE-SIZE
\ #-67 FILE-STATUS
\ #-68 FLUSH-FILE
\ #-69 OPEN-FILE
\ #-70 READ-FILE
\ #-71 READ-LINE
\ #-72 RENAME-FILE
\ #-73 REPOSITION-FILE
\ #-74 RESIZE-FILE
\ #-75 WRITE-FILE

( Standard error codes #-76..#-79 )

\ #-76 WRITE-LINE
\ #-77 malformed xchar
\ #-78 SUBSTITUTE
\ #-79 REPLACES
\ #-80
\ #-81
\ #-82
\ #-83
\ #-84
\ #-85
\ #-86
\ #-87
\ #-88
\ #-89
\ #-90

( System error codes #-256..#-270 )

\ #-256 not a word nor a number
\ #-257 warning: is not unique
\ #-258 stack imbalance
\ #-259 trying to load from block 0
\ #-260 wrong digit
\ #-261 deferred word is uninitialized
\ #-262 assertion failed
\ #-263 execution only
\ #-264 definition not finished
\ #-265 loading only
\ #-266 off current editing block
\ #-267 warning: not present, though required
\ #-268 required, but not located
\ #-269 relative jump too long
\ #-270 text not found

( System error codes #-271..#-285 )

\ #-271 immediate word not allowed in this structure
\ #-272 array index out of range
\ #-273 invalid assembler condition
\ #-274 command line history overflow
\ #-275
\ #-276
\ #-277
\ #-278
\ #-279
\ #-280
\ #-281
\ #-282
\ #-283
\ #-284
\ #-285

( XXX TMP -- block for temporary tries )

need thru
blk @ 1+ blk @ 2+ thru

( XXX TMP -- block for temporary tries )

: hello  ( -- )

( XXX TMP -- block for temporary tries )

  ." hello"

  ;


  \ vim: filetype=soloforth
( Nuclear Invaders )

  \ XXX UNDER DEVELOPMENT

\ Version 0.0.0+201602252144

\ Description

\ This game is a ZX Spectrum port (for Solo Forth:
\ http://programandala.net/en.program.solo_forth.html) of a
\ game written by Dancresp in 2013 for Jupiter ACE
\ (http://www.zonadepruebas.com/viewtopic.php?t=4231).

  \ This version:
\ Copyright (C) 2016 Marcos Cruz (programandala.net)

  \ Original version:
\ Copyright (C) 2013 Scainet Soft

\ License

\ You may do whatever you want with this work, so long as you
\ retain the copyright/authorship/acknowledgment/credit
\ notice(s) and this license in all redistributed copies and
\ derived works.  There is no warranty.

  \ History: see at the end of the file.

-->

( Requirements)

only forth definitions

  \ From the library of Solo Forth

need roll      need inkey   need bleep        need beep>bleep
need os-chars  need os-udg  need 2/           need abort"
need value     need case    need random       need columns
need rows      need ocr     need ms           need s+
need 2value    need row     need char>string  need s\"
need alias     need plot    need adraw

4 constant /kk
need kk-ports  need kk-1#   need pressed?     need kk-chars

[defined] binary  ?\ : binary  ( -- )  2 base !  ;

need defer
need :noname  need benched    need ~~   13 ~~key !
  \ XXX TMP -- during the development

-->

( Debug tools)

defer (debug-point)  ' noop ' (debug-point) defer!

: debug-point  ( -- )
  (debug-point)
  \ latest .name
  depth abort" Stack is not empty"
  \ ." blk " blk @ .
  \ key drop
  ;
  \ Abort if the stack is not empty.
  \ XXX TMP -- for debugging

-->

( Screen) debug-point

16384 constant sys-screen  6912 constant /sys-screen
                           6144 constant /sys-screen-bitmap
  \ Address and size of the screen.
  \ XXX TODO -- not used yet

22528 constant attributes  768 constant /attributes
  \ Address and size of the screen attributes.
  \ XXX TODO -- not used yet

 2 constant arena-top-y
21 constant arena-bottom-y
22 constant status-bar-y
  \ XXX TMP --
  \ XXX TODO --

-->

( Colors) debug-point

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery   ( color -- paper-attribute )           8 *  ;
: brighty  ( attribute -- brighty-attribute )   64 or  ;
: flashy   ( attribute -- flashy-attribute )   128 or  ;

-->

( Colors) debug-point

: set-color  ( b -- )  23695 c!  ;
  \ Set the attribute _b_ as the current color, by modifying
  \ the system variable ATTR T (temporary attributes).

: color  ( b "name" -- )
  create c,  does> ( -- )  ( pfa ) c@ set-color  ;
  \ Create a word "name" that will set attribute _b_ as the
  \ current color.

-->

( Colors) debug-point

              white color text-color
              black color arena-color
 white papery red + color brick-color
       blue brighty color tank-color
               blue color life-color
              green color invader-color
     yellow brighty color container-color
             yellow color projectile-color
            magenta color ufo-color

: init-colors  ( -- )
  0 paper 7 ink 0 flash 0 bright 0 inverse 1 border  ;
  \ XXX TMP --

-->

( Variables) debug-point

variable tank-x        \ column
variable projectile-x  \ column
variable projectile-y  \ row, 0 if no shoot
variable ufo-x         \ column
variable lifes         \ counter (0..3)
variable level         \ counter (1..5)
variable score         \ counter
variable record        \ max score
variable invaders      \ counter (all units of every type)
variable invader-type  \ element of table  (0..9)
variable catastrophe   \ flag (game end condition)

record off

-->

( Keyboard) debug-point

13 constant enter-key

0 value kk-left#    0 value kk-right#    0 value kk-fire#
0. 2value kk-left   0. 2value kk-right   0. 2value kk-fire

: wait  ( -- )  begin  inkey  until  ;
  \ Wait until any key is pressed.

: enter-key?  ( -- f )  inkey enter-key =  ;
  \ Is the Enter key pressed?

: wait-for-enter  ( -- )  begin  enter-key?  until  ;
  \ Wait until the Enter key is pressed.

-->

( kk#>c kk#>string )

: kk#>c  ( n -- c )  kk-chars + c@  ;
  \ Convert key number _n_ to its char _c_.

  \ : .kk#  ( n -- )
  \   case  kk-en# of  ." Enter"         endof
  \         kk-sp# of  ." Space"         endof
  \   \      kk-cs# of  ." Caps Shift"    endof  \ XXX OLD
  \   \      kk-ss# of  ." Symbol Shift"  endof  \ XXX OLD
  \         dup kk#>c upper emit  \ default
  \   endcase  ;
  \ Print the name of key number _n_.
  \ XXX OLD

: kk#>string  ( n -- ca len )
  case  kk-en# of  s" Enter"         endof
        kk-sp# of  s" Space"         endof
  \      kk-cs# of  s" Caps Shift"    endof  \ XXX OLD
  \      kk-ss# of  s" Symbol Shift"  endof  \ XXX OLD
        dup kk#>c upper char>string rot  \ default
  endcase  ;

-->

( controls )

3 constant /controls
  \ Bytes per item in the `controls` table.

create controls  here
  \ left      right     fire
    kk-5# c,  kk-8# c,  kk-en# c,   \ cursor with Enter
    kk-r# c,  kk-t# c,  kk-en# c,   \ Spanish Dvorak keyboard
    kk-z# c,  kk-x# c,  kk-en# c,   \ from the original game
    kk-5# c,  kk-8# c,  kk-0#  c,   \ cursor joystick
    kk-5# c,  kk-8# c,  kk-sp# c,   \ cursor with Space
    kk-1# c,  kk-2# c,  kk-5#  c,   \ Sinclair joystick 1
    kk-6# c,  kk-7# c,  kk-0#  c,   \ Sinclair joystick 2
    kk-o# c,  kk-p# c,  kk-q#  c,   \ QWERTY
    kk-n# c,  kk-m# c,  kk-q#  c,   \ QWERTY
    kk-q# c,  kk-w# c,  kk-p#  c,   \ QWERTY
    kk-z# c,  kk-x# c,  kk-p#  c,   \ QWERTY

here swap - /controls / constant max-controls
  \ Number of controls stored in `controls`.

-->

( next-controls )

: >controls  ( n -- a )  /controls * controls +  ;
  \ Convert controls number _n_ to their address _a_.

: #>kk  ( n -- d )  /kk * kk-ports + kk@  ;
  \ Convert keyboard key number _n_ to its data _d_ (bitmap and
  \ port).

: set-controls  ( n -- )
  >controls     dup c@  dup to kk-left#   #>kk 2to kk-left
             1+ dup c@  dup to kk-right#  #>kk 2to kk-right
             1+     c@  dup to kk-fire#   #>kk 2to kk-fire  ;
  \ Make controls number _n_ (item of the `controls` table) the
  \ current controls.

variable current-controls
  \ Index of the current controls in `controls` table.

current-controls off
current-controls @ set-controls
  \ Default controls.

: next-controls  ( -- )
  current-controls @ 1+  dup max-controls > 0= abs *
  dup current-controls !  set-controls  ;
  \ Change the current controls.

-->

( beep ) debug-point

: beep  ( n1 n2 -- )  beep>bleep bleep  ;
  \ XXX TMP -- compatibility layer for the original code
  \ XXX TODO -- adapt the original beeps

-->

( udg-set udg>bitmap >scan scan! ) debug-point

        128 constant udgs       \ number of UDGs \ XXX TMP --
          8 constant /udg       \ bytes per UDG
udgs /udg * constant /udg-set   \ size of the UDG set in bytes

create udg-set /udg-set allot

udg-set os-udg !
  \ Point system UDG to the game UDG set.
  \ Solo Forth will use this set for chars 128..255.

: udg>bitmap  ( c -- a )  $80 - /udg * udg-set +  ;
  \ Convert UDG char _c_ to the address _a_ of its bitmap.
  \ $80 is the code of the first UDG in Solo Forth.

: >scan  ( n c -- a )  udg>bitmap +  ;
  \ Convert scan number _n_ of UDG char _c_ to its address _a_.

: scan!  ( c b n -- c )  rot >scan c!  ;
  \ Store scan _b_ into scan number _n_ of char _c_,
  \ and return _c_ back for further processing.

variable used-udgs  used-udgs off
  \ Counter of UDGs defined.

: ?free-udg  ( n -- )
  used-udgs +!  used-udgs @ udgs > abort" Too many UDGs"  ;
  \ Abort if there is not free space for _n_ UDGs?
  \ This is a check done during the interpretation of the
  \ source file.

-->

( font! font@ rom-font ) debug-point

: font!  ( a -- )  os-chars !  ;
  \ Set the current charset to address _a_
  \ (the bitmap of char 0).
  \ XXX OLD

: font@  ( -- a )  os-chars @  ;
  \ Fetch the address _a_ of the current charset
  \ (the bitmap of char 0).
  \ XXX OLD

variable ocr-first-udg
variable ocr-last-udg
  \ Char codes of the first and last UDG to be examined
  \ by `ocr`.

: init-ocr  ( -- )
  ocr-first-udg @ udg>bitmap ocr-charset !
    \ Set address of the first char bitmap to be examined.
  ocr-first-udg @ ocr-first !
    \ Its char code in the UDG set.
  ocr-last-udg @ ocr-first-udg @ - 1+ ocr-chars !  ;  \ chars
  \ Set the UDGs `ocr` will examine te detect collisions.
  \ Set the address of the first char bitmap to be
  \ examined, its char code and the number of examined chars.
  \ XXX TODO -- range: only chars that may be detected: brick
  \ and invaders.

: rom-font  ( -- )  15360 font!  ;
  \ Set ROM font for chars 0..127
  \ (in Solo Forth chars 128..255 are UDG).
  \ XXX OLD

-->

( ~~ )

  \ Configure the debugging tool `~~`, in order to activate the
  \ ROM font before printing the debug information, and restore
  \ the previous font at the end.

warnings @  warnings off

variable ~~base

: ~~(  ( -- )  base @ ~~base ! decimal  ;

: ~~)  ( -- )  ~~base @ base !  ;

: ~~  ( -- )
  postpone ~~( postpone ~~  postpone ~~)  ; immediate

~~? off

warnings !

: XXX  ( -- )
  ~~? on
  base @ >r decimal latest .name .s r> base !
  key drop ;

-->

( .score .record update-score  ) debug-point

 1 constant score-y
14 constant record-x

variable players  1 players !  \ XXX TODO -- not used yet
variable player   1 player !   \ XXX TODO -- not used yet

: score-x  ( -- x )  3 player @ 1- 22 * +  ;
  \ Column of the score of the current player.

: (.score)  ( n x y -- )
  at-xy s>d <# # # # # #> text-color type  ;
  \ Print score _n_ at coordinates _x y_.

: score-xy  ( -- x y )  score-x score-y  ;
  \ Coordinates of the score.

: at-score  ( -- )  score-xy at-xy  ;
  \ Set the cursor position at the score.

: .score  ( -- )  score @ score-xy (.score)  ;
  \ Print the score.

: .record  ( -- )  record @ record-x score-y (.score)  ;
  \ Print the record.

: update-score  ( n -- )  score +! .score  ;

-->

( latest-sprite-width latest-sprite-height )

$80 constant first-udg
$FF constant last-udg
    variable >udg  first-udg >udg !  \ next free UDG

variable latest-sprite-width
variable latest-sprite-height
variable latest-sprite-udg

: ?udg  ( c -- )  last-udg > abort" Too many UDGs"  ;
  \ Abort if UDG _n_ is too high.
  \ XXX TMP -- during the development

: free-udg  ( n -- c )
  >udg @ dup latest-sprite-udg !
  tuck +  dup >udg !  1- ?udg  ;
  \ Free _n_ consecutive UDGs and return the first one _c_.

: latest-sprite-size!  ( width height -- )
  latest-sprite-height !  latest-sprite-width !  ;
  \ Update the size of the latest sprited defined.

-->

( sprite-string )

: ?sprite-height  ( -- )
  latest-sprite-height @ 1 >
  abort" Sprite height not supported for sprite strings"  ;

: sprite-string  ( "name" -- )
  ?sprite-height
  here latest-sprite-udg @  latest-sprite-width @ dup >r
  0 ?do  dup c, 1+  loop  drop  r> 2constant  ;
  \ Create a definition "name" that will return a string
  \ containing all UDGs of the lastest sprite defined.
  \ XXX TODO --

-->

( 1x1sprite! 1x1sprite )

: (1x1sprite!)  ( b0..b7 c -- )
  1 ?free-udg  1 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - roll i scan!
  loop  drop  ;
  \ Store a 1x1 UDG sprite into UDG _c_.

: 1x1sprite!  ( b0..b7 -- )
  1 free-udg (1x1sprite!)  ;
  \ Store a 1x1 UDG sprite into the next available UDG.

: 1x1sprite  ( n0..n7 "name" -- )
  1 free-udg dup constant (1x1sprite!)  ;

 ' emit alias .1x1sprite   ( c -- )
' emits alias .1x1sprites  ( c n -- )

-->

( 2x1sprite! 2x1sprite )

: (2x1sprite!)  ( n0..n7 c -- )
  2 ?free-udg  2 1 latest-sprite-size!
  /udg 0 do
    dup /udg 1+ i - pick flip i scan! 1+  \ first UDG
    dup /udg 1+ i - roll      i scan! 1-  \ second UDG
  loop  drop  ;
  \ Store a 2x1 UDG sprite into chars _c_ and _c_+1.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_,
  \ and low part is _c_+1.

: 2x1sprite!  ( n0..n7 -- )
  2 free-udg (2x1sprite!)  ;
  \ Store a 2x1 UDG sprite into the next two available UDGs.
  \ Scans _n0..n7_ are 16-bit: high part is char _c_, and low
  \ part is _c_+1.

: 2x1sprite  ( n0..n7 "name" -- )
  2 free-udg dup constant (2x1sprite!)  ;

: .2x1sprite  ( c -- )  dup emit 1+ emit  ;

-->

( invader-1 invader-1$ ) debug-point

2 constant udg/invader

>udg @ ocr-first-udg !
  \ The first UDG examined by `ocr` must be the first one of
  \ the next sprite.

binary

  \ invader 1, frame 1
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000011001100000
0000110110110000
0011000000001100

2x1sprite invader-1
sprite-string invader-1$  ( -- ca len )

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 2
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0001100000011000

2x1sprite!

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 3
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0000110000110000

2x1sprite!

decimal  -->

( invader-1 ) debug-point

binary

  \ invader 1, frame 4
0000001111000000
0001111111111000
0011111111111100
0011100110011100
0011111111111100
0000111001110000
0001100110011000
0001100000011000

2x1sprite!

decimal  -->

( invader-2 invader-2$ ) debug-point

binary

  \ invader 2, frame 1
0000100000100000
0000010001000000
0000111111100000
0001101110110000
0011111111111000
0011111111111000
0010100000101000
0000011011000000

2x1sprite invader-2
sprite-string invader-2$  ( -- ca len )

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 2
0000100000100000
0000010001000000
0000111111100000
1111101110111110
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 3
0000100000100000
0010010001001000
0010111111101000
0011101110111000
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-2 ) debug-point

binary

  \ invader 2 , frame 4
0000100000100000
0000010001000000
0000111111100000
1111101110111110
0011111111111000
0001111111110000
0000100000100000
0001000000010000

2x1sprite!

decimal  -->

( invader-3 invader-3$ ) debug-point

binary

  \ invader 3, frame 1
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000001001000000
0000010110100000
0000101001010000

2x1sprite invader-3
sprite-string invader-3$  ( -- ca len )

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000100000010000

2x1sprite!

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 3
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000010000100000

2x1sprite!

decimal  -->

( invader-3 ) debug-point

binary

  \ invader 3, frame 2
0000000110000000
0000001111000000
0000011111100000
0000110110110000
0000111111110000
0000010110100000
0000100000010000
0000100000010000

2x1sprite!

decimal  -->

( ufo ufo$ ) debug-point

binary

  \ ufo, frame 1
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0110110110110110
1111111111111111
0011100110011100
0001000000001000

2x1sprite ufo
sprite-string ufo$  ( -- ca len )

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 2
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0011011011011010
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 3
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0101101101101100
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( ufo ) debug-point

binary

  \ ufo, frame 4
0000000000000000
0000011111100000
0001111111111000
0011111111111100
0010110110110110
1111111111111111
0011100110011100
0001000000001000

2x1sprite!

decimal  -->

( brick ) debug-point

binary

11111011
11111011
11111011
00000000
11011111
11011111
11011111
00000000

1x1sprite brick

>udg @ 1- ocr-last-udg !
  \ The last UDG examined by `ocr` must be the last one
  \ of the latest sprite.

decimal  -->

( broken-top-brick ) debug-point

  \ This UDG is used with reversed colors, depending on

binary

11111111
11111111
11111000
11111100
11100100
10000000
00000000
00000000

1x1sprite broken-top-brick

decimal  -->

( broken-bottom-brick ) debug-point

binary

00000000
10000000
10100000
11100100
11111100
11111000
11111101
11111111

1x1sprite broken-bottom-brick

decimal  -->

( tank$ ) debug-point

2 constant udg/tank

binary

  \ XXX TODO -- second frame

0000000100000000
0000001110000000
0000001110000000
0111111111111100
1111111111111110
1111111111111110
1111111111111110
1111111111111110

2x1sprite!
sprite-string tank$  ( -- ca len )

decimal  -->

( invader-explosion$ ) debug-point

binary

0000010001000000
0010001010001000
0001000000010000
0000100000100000
0110000000001100
0000010000100000
0001001010010000
0010010001001000

2x1sprite!
sprite-string invader-explosion$  ( -- ca len )

decimal  -->

( projectile ) debug-point

binary

00000000
00000001
00000001
00000001
00000001
00000001
00000000
00000000

1x1sprite projectile

decimal  -->

( ufo-explosion$ ) debug-point

binary

0000000000000010
0010000001100100
0100011111110000
0000111111111010
0001111011011001
0100110011110000
1000011111000100
0010001100010010

2x1sprite!
sprite-string ufo-explosion$  ( -- ca len )

decimal  -->

( ruler ) debug-point

binary

  \ horizontal ruler
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000

1x1sprite ruler

decimal  -->

( container-top ) debug-point

binary

0000001111100000
0001110000011100
0010001111100010
0010000000000010
0010000111000010
0010001111100010
0010000111000010
0010000010000010

2x1sprite container-top

decimal  -->

( broken-top-left-container ) debug-point

binary

00000000
00011100
00100010
00100010
00100010
00100001
00100001
00100001

1x1sprite broken-top-left-container

decimal  -->

( broken-top-right-container) debug-point

binary

00000000
00011100
00100010
00100010
01000010
01000010
01000010
10000010

1x1sprite broken-top-right-container

decimal  -->

( container-bottom ) debug-point

binary

0010010101010010
0010111101111010
0010111000111010
0010011000110010
0010000000000010
0001110000011100
0000001111100000
0000000000000000

2x1sprite container-bottom

decimal  -->

( broken-bottom-left-container) debug-point

binary

00000001
00000111
00011110
00100110
00100000
00011100
00000011
00000000

1x1sprite broken-bottom-left-container

decimal  -->

( broken-bottom-right-container) debug-point

binary

11000000
01110000
00111100
00110010
00000010
00011100
11100000
00000000

1x1sprite broken-bottom-right-container

decimal  -->

( graphic-bl graphic-space ) debug-point

-->  \ XXX OLD

binary

  \ blank
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

1x1sprite graphic-bl
: graphic-space  ( -- )  graphic-bl .1x1sprite  ;

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0000000000001000
0000000000001100
0000111111111110
0000111111111111
0000111111111110
0000000000001100
0000000000001000

2x1sprite right-arrow
sprite-string right-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000000000000000
0001000000000000
0011000000000000
0111111111110000
1111111111110000
0111111111110000
0011000000000000
0001000000000000

2x1sprite left-arrow
sprite-string left-arrow$  ( -- ca len )

decimal  -->

( sprites ) debug-point

  \ XXX OLD

binary
0000111111110000
0011000000001100
0011000000001100
0010111111110100
0010000000000100
0010000000000100
0010000000000100
1111111111111111

2x1sprite fire-button
sprite-string fire-button$  ( -- ca len )

decimal  -->

( centered center-type )  debug-point

: centered  ( len -- column )  columns swap - 2/  ;
  \ Convert a string length to the column required
  \ to print the string centered.

: centered-at  ( row len -- )  centered swap at-xy  ;
  \ Set the cursor position to print string _ca len_ centered
  \ on the given row.

: center-type  ( ca len row -- )  over centered-at type  ;
  \ Print string _ca len_ centered on the given row.

: type-blank  ( ca len -- )  nip spaces  ;

: center-type-blank  ( ca len row -- )
  over centered-at type-blank ;
  \ Overwrite string _ca len_ with blanks, centered on the given row.

17 constant message-y  \ row for game messages

: message  ( ca len -- )
  2dup message-y text-color center-type  1500 ms
       message-y center-type-blank  ;
  \ Print a game message _ca len_.

-->

( instructions ) debug-point

: title  ( -- )  s" NUCLEAR INVADERS" 0 center-type  ;

: (c)  ( -- )  127 emit  ;
  \ Print the copyright symbol.

: .copyright  ( -- )
  row
  1 over    at-xy (c) ."  2013 Scainet Soft"
  1 over 1+ at-xy (c) ."  2016 Marcos Cruz"
  8 swap 2+ at-xy           ." (programandala.net)"  ;
  \ Print the copyright notice at the current row.

-->

( instructions ) debug-point

  \ XXX OLD
  \ : .control  ( n -- )  ."  = " .kk# 4 spaces  ;
  \ : .controls  ( -- )
  \   row dup s" [Space] to change controls:" rot center-type
  \   9 over 2+  at-xy ." Left " kk-left#  .control
  \   9 over 3 + at-xy ." Right" kk-right# .control
  \   9 swap 4 + at-xy ." Fire " kk-fire#  .control  ;
  \   \ Print controls at the current row.

: left-key$   ( -- ca len )  kk-left# kk#>string  ;
: right-key$  ( -- ca len )  kk-right# kk#>string  ;
: fire-key$   ( -- ca len )  kk-fire# kk#>string  ;

: controls$  ( -- ca len )
  left-arrow$ left-key$ s+
  s"   " s+ fire-key$ s+ s"   " s+
  right-key$ s+ right-arrow$ s+  ;
  \ String containing the description of the current controls.
  \ XXX TMP --
  \ XXX TODO -- rewrite

: .controls  ( -- )
  s" [Space] to change controls:" row dup >r center-type
  fire-button$ r@ 2+ center-type
  0 r@ 3 + at-xy columns spaces
  controls$ r> 3 + center-type  ;
  \ Print controls at the current row.
  \ XXX TMP --
  \ XXX FIXME -- these UDG become corrupted after the game

-->

( instructions ) debug-point

: .score-table-item  ( ca1 len1 ca2 len2 -- )
  type text-color ."  = " type  ;
  \ Print an item of the score table, with sprite string _ca2
  \ len2_ and description _ca1 len1_
9 constant score-table-x

: .score-table  ( -- )
  score-table-x row
  2dup     at-xy s" 10 points"
           invader-color invader-1$ .score-table-item
  2dup 2+  at-xy s" 20 points"
           invader-color invader-2$ .score-table-item
  2dup 4 + at-xy s" 30 points"
           invader-color invader-3$ .score-table-item
       6 + at-xy s" bonus"
           ufo-color ufo$ .score-table-item  ;
   \ Print the score table at the current row.

-->

( instructions ) debug-point

: show-controls  ( -- )  0 12 at-xy .controls  ;

: menu  ( -- )
  begin
    break-key? if  quit  then  \ XXX TMP
    key
    dup enter-key = if  drop exit  then
               bl = if  next-controls show-controls  then
  again  ;

-->

( instructions ) debug-point

: instructions  ( -- )
  text-color  cls  title
  0 3 at-xy .score-table
  show-controls
  s" [Enter] to start" 18 center-type
  0 21 at-xy .copyright
  menu  ;

-->

( game-screen ) debug-point

arena-bottom-y arena-top-y - 1+ columns * constant /arena
  \ Number of characters and attributes of the arena.
arena-top-y columns * attributes + constant arena-top-attribute
  \ Address of the first attribute of the arena.

: black-arena  ( -- )  arena-top-attribute /arena erase  ;
  \ Make the arena black.

: wipe-arena  ( -- )  0 arena-top-y at-xy /arena spaces  ;
  \ Clear the arena (the whole screen except the status bars).
  \ XXX TODO -- wipe attributes first

: -arena  ( -- )  black-arena wipe-arena  ;
  \ XXX FIXME -- this deletes the bar

: score-bar$  ( -- ca len )
  text-color s"  SCORE<1>    RECORD    SCORE<2>"  ;

: score-bar  ( -- )
  home score-bar$ type .score .record  ;
  \ XXX TODO -- support player 2

: show-player  ( -- )
  10 0 do  at-score 4 spaces 64 ms  .score 64 ms  loop  ;
  \ Show the current player by making its score blink.

-->

( game-screen ) debug-point

: row>pixel  ( n1 -- n2 )  8 * 191 -  ;
  \ Convert a row (0..23) to a pixel y coordinate (0..191).

: bar-ruler  ( -- )
  text-color 0 status-bar-y row>pixel plot 255 0 adraw  ;
  \ Draw the ruler of the status bar.

: .life-icons  ( -- )
  life-color
  lifes @ 0 ?do  tank$ type  loop  ."   "  ;
  \ Print one icon for each remaining life.

: .lifes  ( -- )
  2 status-bar-y at-xy lifes text-color ? .life-icons  ;
  \ Print number of lifes and life icons.

: status-bar  ( -- )  bar-ruler .lifes  ;

: game-screen  ( -- )  init-colors cls score-bar status-bar  ;

-->

( udg/invader invaders-min-x invaders-max-x ) debug-point

                    0 constant invaders-min-x
columns udg/invader - constant invaders-max-x

-->

( invaders-data ) debug-point

  \ Invaders data is stored in a table.
  \ which has the following structure:
  \
  \ +0 = units (0..3)
  \ +2 = active? (0..1)
  \ +4 = y row
  \ +6 = x coordinate (column)
  \ +8 = main graphic (character)

  \ The `invader` variable points to the data of the current
  \ invader in the table.

     10 constant invader-types
6 cells constant /invader-type

create default-invaders-data
  \ Default invaders data table.
  \ This is used to restore the actual data table
  \ before a new game.

here

  \ units   active? y    x                 sprite       x inc
    3 ,     0 ,      5 , invaders-min-x ,  invader-3 ,   1 ,
    3 ,     0 ,      7 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,      9 , invaders-min-x ,  invader-2 ,   1 ,
    3 ,     0 ,     11 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,     13 , invaders-min-x ,  invader-1 ,   1 ,
    3 ,     0 ,      5 , invaders-max-x ,  invader-3 ,  -1 ,
    3 ,     0 ,      7 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,      9 , invaders-max-x ,  invader-2 ,  -1 ,
    3 ,     0 ,     11 , invaders-max-x ,  invader-1 ,  -1 ,
    3 ,     0 ,     13 , invaders-max-x ,  invader-1 ,  -1 ,

here swap - constant /invaders-data  -->
  \ Space occupied by the invaders data.

  \ XXX TODO -- convert tables to standard structures

( invaders-data ) debug-point

create invaders-data  /invaders-data allot
  \ Current invaders data.

: >invader   ( -- n )  invader-type @ /invader-type *  ;
  \ Pointer of current invader type in a data table.

: 'invader   ( -- a )  >invader invaders-data +  ;
  \ Data address _a_ of the current invader type.

: 'default-invader   ( -- a )
  >invader default-invaders-data +  ;
  \ Default data address _a_ of the current invader type.

: invader-units   ( -- a )  'invader            ;
: invader-active  ( -- a )  'invader cell+      ;
: invader-y       ( -- a )  'invader [ 2 cells ] literal +  ;
: invader-x       ( -- a )  'invader [ 3 cells ] literal +  ;

: invader-xy@    ( -- x y )  invader-y 2@  ;
: invader-char@  ( -- c )  'invader [ 4 cells ] literal + @  ;

: invader-x-inc@  ( -- n )  'invader [ 5 cells ] literal + @  ;

: invader-default-x@    ( -- x y )
  'default-invader [ 3 cells ] literal + @  ;

-->

( set-building-size ) debug-point

 4 constant building-top-y
15 constant building-bottom-y

variable building-width

variable building-left-x     variable building-right-x
variable containers-left-x   variable containers-right-x

: set-building-size  ( -- )
  level @ 2* 2+  building-width !
  [ columns 2/ 1- ] literal \ half of the screen
  level @ \ half width of all containers
  2dup 1- - containers-left-x !
  2dup    - building-left-x !
  2dup    + containers-right-x !
       1+ + building-right-x !  ;
  \ Set the size of the building after the current level.

-->

( increase-level update-level init-level ) debug-point

5 constant max-level

: increase-level  ( -- )  level @ 1+ max-level min level !  ;
  \ Increase the level number.

: update-level  ( -- )  increase-level set-building-size  ;

: init-level  ( -- )  level off  update-level  ;
  \ Init the level number and the related variables
  \ (the size of the bulding).

-->

( building ) debug-point

: floor  ( y -- )
  building-left-x @ swap at-xy
  brick-color brick building-width @ .1x1sprites  ;
  \ Draw a floor of the building at row _y_.

: building-top  ( -- )  building-top-y floor  ;
  \ Draw the top of the building.

: building-bottom  ( -- )  building-bottom-y  floor  ;
  \ Draw the bottom of the building.

  \ XXX OLD
  \ here 1+ s\" \x95\x97\x98\x97\x98\x97\x98\x97\x98\x97\x98" s,
  \ constant containers-top
  \ here 1+ s\" \x95\x99\x9A\x99\x9A\x99\x9A\x99\x9A\x99\x9A" s,
  \ constant containers-bottom
  \ Compile strings which hold a brick followed by nuclear
  \ containers (top and bottom parts) and save the addresses of
  \ their first char.

: containers-bottom  ( n -- )
  container-color
  0 ?do  container-bottom .2x1sprite  loop  ;
  \ Draw a row of _n_ bottom parts of containers.

: containers-top  ( n -- )
  container-color
  0 ?do  container-top .2x1sprite  loop  ;
  \ Draw a row of _n_ top parts of containers.

-->

( building ) debug-point

: .brick  ( -- )  brick-color brick .1x1sprite  ;
  \ Draw a brick.

: building  ( -- )
  building-bottom
  level @  building-left-x @
  building-top-y [ building-bottom-y 2- ] literal
  do
    2dup i 1+ at-xy .brick containers-bottom .brick
    2dup i    at-xy .brick containers-top    .brick
  -2 +loop  2drop  building-top  ;
  \ Draw the building and the nuclear containers.

-->

( drive ) debug-point

  \ XXX TODO -- try

                   20 constant tank-y
                    1 constant tank-min-x
columns udg/tank - 1- constant tank-max-x
  \ Mininum and maximin columns of the tank.

: tank-range  ( column -- column' )
  tank-max-x min tank-min-x max  ;
  \ Adjust the given column to the limits of the tank.

: ?space   ( -- )  column if  text-color space  then  ;
  \ Print a space, if current column is not zero.

  \ : drive  ( -- )
  \   tank-x @ kk-left  pressed? +
  \            kk-right pressed? abs +
  \   tank-range dup tank-x !  tank-y
  \   at-xy tank-color ?space tank$ type ?space  ;
  \ Move the tank depending on the key pressed.
  \ XXX OLD
  \ XXX FIXME -- trails

  \ : drive-left  ( -- )
  \   tank-x @ if  -1 tank-@
  \   ;
  \ : drive-right  ( -- )  ;
  \   tank-range dup tank-x !  1- tank-y
  \   at-xy tank-color ?space tank$ type ?space

  \ : drive  ( -- )
  \   kk-left  pressed? if  drive-left  exit then
  \   kk-right pressed? if  drive-right      then  ;
  \   \ Move the tank depending on the key pressed.

: moving-tank?  ( -- -1|0|1 )
  kk-left pressed? kk-right pressed? abs +  ;
  \ Does the tank move? Return its x increment.

: .tank  ( -- )  tank-color tank$ type  ;
  \ Print the tank at the current cursor position.
  \ XXX FIXME -- spaces depend on the direction,
  \ thus this can't work in x range 0..31.

-->

( drive ) debug-point

  \ XXX TODO -- try

: at-tank  ( -- )  tank-x @ tank-y at-xy  ;
: tank-ready  ( -- )  at-tank .tank  ;
: -tank  ( -- )  at-tank text-color 2 spaces  ;

: move-tank  ( -1|1 -- )
  tank-x @ + tank-range dup tank-x ! tank-y at-xy  ;
  \ Set the cursor position to the coordinates of the tank,
  \ after incrementing its column with the given value.

: drive  ( -- )
  moving-tank? ?dup 0= ?exit  -tank move-tank .tank  ;
  \ XXX FIXME -- don't delete the whole tank

-->

( init ) debug-point

: init-game  ( -- )
  init-ocr  3 lifes !  init-level  score off  game-screen  ;

: init-invaders-data  ( -- )
  default-invaders-data invaders-data /invaders-data move  ;

: init-ufo  ( -- )  -200 ufo-x !  ;

: total-invaders  ( -- n )
  0   invader-types 0 do
        i invader-type ! invader-units @ +
      loop  ;
  \ Total number of invaders (sum of units of all invader
  \ types).

: init-invaders  ( -- )
  init-invaders-data  invader-type off
  total-invaders invaders !  ;

: init-tank  ( -- )
  columns udg/tank - 2/ tank-x !  \ middle of the screen
  projectile-y off  ;  -->

( init ) debug-point

: parade  ( -- )
  invader-color
  invader-1 dup invader-2 dup invader-3
  building-bottom-y [ building-top-y 1+ ] literal
  do
    invaders-min-x i at-xy dup .2x1sprite
    invaders-max-x i at-xy     .2x1sprite
  2 +loop  ;
  \ Show the invaders at their initial positions.

: init-arena  ( -- )   -arena building tank-ready parade  ;

: level-message  ( -- ca len )
  text-color s" LEVEL " level @ s>d <# # #> s+  ;

: show-level  ( -- ) level-message message  ;

: init-combat  ( -- )
  catastrophe off init-invaders init-ufo init-tank init-arena
  show-level show-player  ;  -->

( invasion ) debug-point

: at-invader  ( -- )  invader-xy@ at-xy  ;
  \ Set the cursor position at the coordinates of the invader.

4 constant frames/invader

: sprite>frame  ( c1 x -- c2 )
  frames/invader mod udg/invader * +  ;
  \ Frame _c2_ of sprite _c1_, calculated from its column _x_.

: invader-frame  ( -- c )
  invader-char@ invader-x @ sprite>frame  ;
  \ Frame of the invader, calculated from its column _x_.

: .invader  ( -- )  invader-color invader-frame .2x1sprite  ;
  \ Print the current invader.

-->

( invasion )

variable broken-wall-x
  \ Column of the wall broken by the current alien.

: flying-to-the-right?  ( -- f )  invader-x-inc@ 0>  ;
  \ Is the current invader flying to the right?

red papery c,  here  red c,  constant broken-brick-colors
  \ Address of the broken brick color used for the right
  \ side of the building; the address before contains
  \ the color used for the left side of the building.
  \ This is faster than pointing to a list of two colors,
  \ because a flag (0|-1) can be used as index.

: broken-wall-color  ( -- )
  broken-brick-colors flying-to-the-right? + c@ set-color  ;
  \ Set the color of the broken wall.  It depends on the side
  \ of the building, because the same two UDGs are used for
  \ both sides, with inverted colors.

: broken-bricks-coordinates  ( -- x1 y1 x2 y2 )
  broken-wall-x @ invader-y @ 1+  2dup 2-  ;
  \ Coordinates of the broken brick above the invader, _x2 y2_,
  \ and below it, _x1 y1_.

: broken-left-wall  ( -- )
  broken-bricks-coordinates
  at-xy broken-bottom-brick .1x1sprite
  at-xy broken-top-brick  .1x1sprite  ;

: broken-right-wall  ( -- )
  broken-bricks-coordinates
  at-xy broken-top-brick .1x1sprite
  at-xy broken-bottom-brick .1x1sprite  ;  -->

  \ XXX TODO -- detect if the wall is already broken, and
  \ change the graphic accordingly.

( invasion )

: broken-wall  ( -- )
  broken-wall-color flying-to-the-right?
  if  broken-left-wall  else  broken-right-wall  then  ;
  \ Show the broken wall of the building, hit by the current invader.

: broken-wall?  ( -- f )
  invader-x @ flying-to-the-right?
  if    1+ building-left-x
  else  building-right-x
  then  @ dup broken-wall-x ! =  ;
  \ Has the current invader broken the wall of the building?

-->

( invasion )

: broken-left-container  ( -- )
  invader-x @ 2+ invader-y @ at-xy
  broken-top-right-container .1x1sprite
  invader-x @ 1+ invader-y @ 1+ at-xy
  broken-bottom-left-container .1x1sprite  ;
  \ Broke the container on its left side.

: broken-right-container  ( -- )
  invader-x @ 1- invader-y @ at-xy
  broken-top-left-container .1x1sprite
  invader-x @ invader-y @ 1+ at-xy
  broken-bottom-right-container .1x1sprite  ;
  \ Broke the container on its right side.

-->

( invasion )

: broken-container  ( -- )
  container-color
  flying-to-the-right?  if    broken-left-container
                        else  broken-right-container  then  ;
  \ Broke the container.

: broken-container?  ( -- f )
  invader-x @ flying-to-the-right?
  if    1+ containers-left-x
  else     containers-right-x  then  @ =  ;
  \ Has the current invader broken a container?

-->

( invasion )

: damages  ( -- )
  broken-wall? if  broken-wall exit  then
  broken-container? dup if    broken-container
                        then  catastrophe !  ;
  \ Manage the possible damages caused by the current invader.
  \ XXX TODO -- change the graphic of the container

: flying-invader  ( -- )
  invader-x-inc@ dup 0>  \ flying to the right?
  if    at-invader text-color space .invader invader-x +!
  else  invader-x +! at-invader .invader ?space  then  ;
  \ Note: `text-color` is needed because the paper color
  \ may have changed.

-->

( invasion ) debug-point

: activate-invader  ( -- )
  32 random  26 invaders @ 5 < 16 * -  > invader-active !  ;
  \ Activate the current invader, depending on a random
  \ calculation: If there are less than 5 invaders left, the
  \ chances of activation are 22/32, else 6/32.
  \ XXX TODO -- Simpler and faster? Proportional to the
  \ number of invaders?

: last-invader-type?  ( -- f )
  invader-type @ [ invader-types 1- ] literal =  ;
  \ Is the current invader type the last one?

: next-invader  ( -- )
  last-invader-type?
  if  invader-type off  else  1 invader-type +!  then  ;
  \ Update the invader type to the next one.

variable delay  50 delay !  \ ms

: move-invader  ( -- )
  delay @ ms  \ XXX TMP --
  invader-active @
  if  flying-invader damages  else  activate-invader  then  ;
  \ Move the current invader if it's active, else
  \ just try to activate it.

: invasion  ( -- )
  invader-units @ if  move-invader  then  next-invader  ;
  \ Move the current invader, if there are units left of it,
  \ and then choose the next one.

-->

( ufo ) debug-point

 3 constant ufo-y       \ row
27 constant ufo-max-x   \ column

: ufo-invisible?  ( -- f )  ufo-x @ 0<  ;
  \ Is the UFO invisible?

: at-ufo  ( -- )  ufo-x @ ufo-y at-xy  ;
  \ Set the cursor position at the coordinates of the UFO.

: -ufo  ( -- )  at-ufo 3 spaces init-ufo  ;
  \ Delete and init the UFO.

: ufo-lost?  ( -- f )  ufo-x @ ufo-max-x >  ;
  \ Is the UFO lost?

: ufo-frame  ( -- c )  ufo ufo-x @ sprite>frame  ;

: flying-ufo  ( -- )
  1 ufo-x +! at-ufo ufo-color space ufo-frame .2x1sprite  ;
  \ Update the position of the UFO and show it.

: (move-ufo)  ( -- )
  ufo-lost?  if  -ufo  else  flying-ufo  then  ;
  \ Manage the UFO.

: move-ufo  ( -- )
  ufo-invisible? if  1 ufo-x +!  else  (move-ufo)  then  ;
  \ Manage the UFO, if it's visible.

-->

( ufo-impacted ) debug-point

: ufo-bang  ( -- )  18 12 do  i 15 beep  loop  ;
  \ XXX TODO -- explosion sound

: ufo-on-fire  ( -- )
  ufo-x @ 1+ ufo-y at-xy ufo-explosion$ type  ;

: ufo-explosion  ( -- )  ufo-on-fire ufo-bang  ;

: ufo-points  ( -- n )  32 random 12 / 1+ 50 *  ;
  \ Random points for impacting the UFO.

: ufo-bonus  ( -- )
  ufo-points dup ufo-x @ 1+ ufo-y at-xy .  update-score  ;
  \ Update the score with the UFO bonus.

: ufo-impacted  ( -- )  ufo-explosion ufo-bonus 200 ms -ufo  ;

-->

( invader-impacted ) debug-point

: invader-points  ( -- n )
  projectile-y @ 3 - 2/          \ depending on the row
  \ projectile-x @ 15 > abs 5 * +  \ add 5 when x>15  -- XXX why?
  projectile-y @
  dup 5 = if  drop 30
          else  10 > 10 * 20 +  then  ;
  \ Points for impacting an invader.
  \ XXX TODO -- simplify

: invader-bonus  ( -- )  invader-points  update-score  ;
  \ Update the score with the invader bonus.

: invader-bang  ( -- ca len )  10 100 beep  ;
  \ XXX TODO -- explosion sound

: invader-on-fire  ( -- )
  at-invader invader-explosion$ type  ;

: -invader  ( -- )  at-invader 2 spaces  ;
  \ Delete the current invader.

: invader-explosion  ( -- )
  invader-on-fire invader-bang -invader  ;

-->

( invader-impacted ) debug-point

: impacted-invader  ( -- n )
  projectile-y @ [ building-top-y 1+ ] literal - 2/
  projectile-x @ [ columns 2/ ] literal > abs 5 * +  ;
  \ Invader type impacted calculated from the projectile
  \ coordinates: Invader types 0 and 5 are at the top, one row
  \ below the top of the building, types 1 and 6 are two lines
  \ below and so on. Types 0..4 are at the left of the
  \ screen; types 5..9 are at the right.

: replace-invader  ( -- )
  invader-active off
  invader-default-x@ invader-x !  at-invader
  invader-color invader-char@ .2x1sprite  ;
  \ Replace the current invader with its next unit.
  \ Set it inactive at its start position.

: current-invader-impacted  ( -- )
  invader-bonus invader-explosion
  -1 invaders +!  -1 invader-units +!
  invader-units @ if  replace-invader  then  ;
  \ The current invader has been impacted by the projectile.

: invader-impacted  ( -- )
  invader-type @ >r  impacted-invader invader-type !
  current-invader-impacted  r> invader-type !  ;  -->
  \ A invader has been impacted by the projectile.
  \ Calculate its type, set it the current one and manage it.

( impact ) debug-point

: (impact)  ( -- )
  projectile-y @ ufo-y = if  ufo-impacted exit  then
  invader-impacted  ;
  \ Manage the impact.

: impact  ( -- )
  projectile-y @ building-bottom-y <
  if  (impact)  then  projectile-y off  ;
  \ Manage the impact, if the projectil is high enough.

: projectile-xy  ( -- x y )  projectile-x @ projectile-y @  ;
  \ Coordinates of the projectile.

: hit?  ( -- f )  projectile-xy ocr 0<>  ;
  \ Did the projectile hit the target?

: impact?  ( -- f )  hit? dup if  impact  then  ;
  \ Did the projectil impacted?
  \ If so, do manage the impact.

-->

( shoot ) debug-point

: at-projectile  ( -- )  projectile-xy at-xy  ;
  \ Set the cursor position at the coordinates of the
  \ projectile.

: .projectile  ( -- )
  projectile-color at-projectile projectile .1x1sprite  ;
  \ Show the projectile.

: fire-sound  ( -- )  ;
  \ XXX TODO --

: fire  ( -- )
  tank-x @ projectile-x !
  [ tank-y 1- ] literal projectile-y !  fire-sound  ;
  \ The tank fires.
  \ XXX TODO -- several projectiles at the same time;
  \ pixels instead of characters

: -projectile  ( -- )  at-projectile text-color space  ;
  \ Delete the projectile.

: projectile-lost?  ( -- f )
  projectile-y @ building-top-y <  ;
  \ Is the projectile lost?

-->

( shoot ) debug-point

: shooted  ( -- )
  -projectile  projectile-lost? if  projectile-y off exit  then
  -1 projectile-y +! impact? ?exit
  .projectile  ;
  \ Manage the projectile.

: shooted?  ( -- f )  projectile-y @ 0<>  ;
  \ Has the tank already shooted?

: fire?  ( -- f )  kk-fire pressed?  ;
  \ Is the fire key pressed?

: shoot  ( -- )
  shooted? if  shooted exit  then  fire? if  fire  then  ;
  \ Manage the shoot.

-->

( new-record? new-record check-record ) debug-point

: new-record?   ( -- f )  score @ record @ >  ;
  \ Is there a new record?

: new-record    ( -- f )  score @ record !  ;
  \ Set the new record.

: check-record  ( -- )  new-record? if  new-record  then  ;
  \ Check if there's a new record, and set it.

-->

( alive game-over next-level ) debug-point

: .game-over  ( -- )  s" GAME OVER" message  ;

: game-over  ( -- )  .game-over check-record  ;

: next-level  ( -- )  update-level show-level  ;

: dead  ( -- )  -1 lifes +!  .lifes  ;
  \ One life lost.

: defeat-tune  ( -- )  100 200 do  i 20 beep  -5 +loop  ;

: defeat  ( -- )  defeat-tune  300 ms  dead  ;

-->

( run ) debug-point

: victory?  ( -- f )  invaders @ 0=  ;

: (combat)  ( -- )
  begin   victory? if  next-level init-combat  then
          break-key? if  quit  then  \ XXX TMP
          drive shoot move-ufo invasion  catastrophe @
  until   defeat  ;

: combat  ( -- )  init-combat (combat)  ;

: defeat?  ( f )  lifes @ 0=  ;

: game  ( -- )
  init-game  begin  combat defeat?  until  game-over  ;

: run  ( -- )  begin  instructions game  again  ;

-->

( Debugging tools)

  \ Words for testing and debugging the game.

: .udgs  ( -- )  cr udgs 0 do  i 128 + emit  loop  ;
  \ Print all game UDGs.

: ni  ( -- )      next-invader  ;
: m   ( -- )      move-invader broken-container? home .  ;
: in  ( -- )      init-game init-combat  ;

-->

( Debugging tools)

: bc  ( -- )
  cls
  \ top:
  space broken-top-right-container .1x1sprite
  container-top .2x1sprite
  broken-top-left-container .1x1sprite space cr
  \ bottom:
  container-bottom .2x1sprite 8 emit 8 emit
  broken-bottom-left-container .1x1sprite
  xy swap 1+ swap at-xy
  container-bottom .2x1sprite 
  container-bottom .2x1sprite 8 emit
  broken-bottom-right-container .1x1sprite cr  ;
  \ Show the graphics of the broken containers.

init-level

  \ ==========================================================
  \ History

  \ This is mainly a compilation of the git commit comments.

  \ 2016-02-14:
  \
  \ Started changing the layout of the original
  \ source code.
  \
  \ 2016-02-15:
  \
  \ - Convert the source to lowercase.
  \ - Rename Spanish words to English.
  \ - Rename variables using meaningful names.
  \ - Indent the word definitions and the control structures.
  \ - Split lines at 63 columns.
  \ - Add block titles.
  \
  \ 2016-02-16:
  \
  \ - Convert the graphics to binary numbers.
  \ - Implement words to define the graphics.
  \ - Adapt the invaders' data.
  \ - Factorize some words.
  \ - Adapt ACE Forth's `pick`.
  \ - Optimize some code idioms.
  \
  \ 2016-02-17:
  \
  \ - Factor the shoot manager.
  \ - Factor the invaders' manager.
  \ - Make the printing of containers faster.
  \ - Improve the invaders' data manipulation.
  \ - Convert the last `at-yx` to `at-xy`.
  \ - Add first words to support color.
  \ - Factor, modify and combine the presentation and
  \   instructions screens.
  \ - Name the main sprites.
  \ - Improve the logic of the game round loop.
  \ - Factor the arena screen.
  \ - Factor the printing of lifes.
  \
  \ 2016-02-18:
  \
  \ - Fix record init.
  \ - Fix access to invaders' data.
  \ - Factor status bar.
  \ - Simplify printing of lifes (number and icons).
  \ - Simplify selecting the font.
  \ - Fix the phase incrementer.
  \
  \ 2016-02-19:
  \
  \ - Factor the calculation of the last invader type.
  \ - Factor the calculation of the invaders' direction.
  \ - Factor and fix the ending condition in the combat loop.
  \ - Fix the invaders' data.
  \ - Fix the reading of movement keys.
  \ - Fix and improve the phase update.
  \ - Fix the initial position of the building and the
  \   invaders.
  \ - Standardize the pauses.
  \ - Add the invaders' direction to the data table.
  \ - Fix the movement of invaders.
  \ - Improve access to both coordinates of current invader.
  \
  \ 2016-02-20:
  \
  \ - Improve the keyboard reading.
  \ - Make the keyboard controls configurable.
  \ - Fix the storage of invaders' coordinates as a double
  \ number.
  \ - Fix and improve the calculation of the building size.
  \ - Fix the increasing of the level.
  \ - Fix the printing of lifes.
  \ - Fix the OCR init.
  \ - Add level 1.
  \
  \ 2016-02-21:
  \
  \ - Fix the printing of score.
  \ - Fix shooting and impacting.
  \
  \ 2016-02-22:
  \
  \ - Change the graphic codes.
  \ - Change the layout of controls' menu.
  \
  \ 2016-02-23:
  \
  \ - Factor the explosion of invaders.
  \ - Make the usage of UDG codes automatic.
  \
  \ 2016-02-24:
  \
  \ - Add color.
  \ - Fix calculation of maximum number of controls.
  \ - Add broken walls effect.
  \ - Use 4 frames per invader instead of 2.
  \ - Set initial position of invaders at the margins of the
  \ screen.
  \ - Set initial position of the tank at the center of its
  \ row.
  \ - Add broken container effect.
  \ - Fix the color of the number of lifes.
  \
  \ XXX -- commited here

  \ vim: filetype=soloforth
( G+DOS error codes #-1000..#-1014 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1000 G+DOS: Nonsense in G+DOS
\ #-1001 G+DOS: Nonsense in GNOS
\ #-1002 G+DOS: Statement end error
\ #-1003 G+DOS: Break requested
\ #-1004 G+DOS: Sector error
\ #-1005 G+DOS: Format data lost
\ #-1006 G+DOS: Check disk in drive
\ #-1007 G+DOS: No +SYS file
\ #-1008 G+DOS: Invalid file name
\ #-1009 G+DOS: Invalid station
\ #-1010 G+DOS: Invalid device
\ #-1011 G+DOS: Variable not found
\ #-1012 G+DOS: Verify failed
\ #-1013 G+DOS: Wrong file type
\ #-1014 G+DOS: Merge error

( G+DOS error codes #-1015..#-1029 )

  \ G+DOS Error codes and messages.
  \ Some of them are useless for this implementation.

\ #-1015 G+DOS: Code error
\ #-1016 G+DOS: Pupil set
\ #-1017 G+DOS: Invalid code
\ #-1018 G+DOS: Reading a write file
\ #-1019 G+DOS: Writing a read file
\ #-1020 G+DOS: O.K. G+DOS
\ #-1021 G+DOS: Network off
\ #-1022 G+DOS: Wrong drive
\ #-1023 G+DOS: Disk write protected
\ #-1024 G+DOS: Not enough space on disk
\ #-1025 G+DOS: Directory full
\ #-1026 G+DOS: File not found
\ #-1027 G+DOS: End of file
\ #-1028 G+DOS: File name used
\ #-1029 G+DOS: No G+DOS loaded

( G+DOS error codes #-1030..#-1031 )

\ #-1030 G+DOS: STREAM used
\ #-1031 G+DOS: CHANNEL used

  \ vim: filetype=soloforth
( OS error codes #-1128..#-1142 )

  \ XXX TODO -- it seems OS error codes (there are 28 of them)
  \ may be returned by G+DOS.  they are detected and converted
  \ by `ior>error`.

\ #-1128 OS:
\ #-1129 OS:
\ #-1130 OS:
\ #-1131 OS:
\ #-1132 OS:
\ #-1133 OS:
\ #-1134 OS:
\ #-1135 OS:
\ #-1136 OS:
\ #-1137 OS:
\ #-1138 OS:
\ #-1139 OS:
\ #-1140 OS:
\ #-1141 OS:
\ #-1142 OS:

( OS error codes #-1143..#-1154 )

\ #-1143 OS:
\ #-1144 OS:
\ #-1145 OS:
\ #-1146 OS:
\ #-1147 OS:
\ #-1148 OS:
\ #-1149 OS:
\ #-1150 OS:
\ #-1151 OS:
\ #-1151 OS:
\ #-1152 OS:
\ #-1153 OS:
\ #-1154 OS:

  \ vim: filetype=soloforth
