( F+D Forth blocks file )

\ This file is the library of F+D Forth,
\ and the skeleton to build applications in F+D Forth.

( ) \ scr 1

( ) \ scr 2

( require ) \ scr 3

  \ This screen must be at a fixed location.

  \ 2015-06-04: Copied from lina (Copyright (c) 2000-2004
  \ Albert van der Horst, The Netherlands). First changes to
  \ adapt it.

  \ XXX TODO

: located  ( ca len -- screen | false)
  780 6 do
    0 i (line) 2over contains if  2drop i unloop exit  then
  loop  2drop false  ;
: locate  ( "name" -- screen | false )  bl word located  ;

  \ Make sure the given word is defined.
: (required)  ( ca len -- )
  located dup 0= x ?error load  ;
: required  ( ca len -- )
  \ XXX TODO finish
  2dup undefined? if  2dup (required)  then
  2dup undefined? if  etype 24 message exit  then 2drop  ;
: require  ( "name" -- )  bl word required  ;

( Errors 1..15 ) \ scr 4

\ Error #01: Word not found.
\ Error #02: Stack empty.
  \ #03 not used:
\ Error #03: Dictionary full.
\ Error #04: Is not unique.
\ Error #05:
  \ #06 not used:
\ Error #06: Out of disk range
\ Error #07: Full stack.
\ Error #08:
\ Error #09: Trying to load from screen 0.
\ Error #10:
\ Error #11:
\ Error #12:
\ Error #13:
\ Error #14:
\ Error #15:

( Errors 17..31 )  \ scr 5

\ Error #17: Compilation only, use in a definition.
\ Error #18: Execution only.
\ Error #19: Conditionals not paired.
\ Error #20: Definition not finished.
\ Error #21: In protected dictionary.
\ Error #22: Use only when loading.
\ Error #23: Off current editing screen.
\ Error #24: Declare vocabulary.
\ Error #25:
\ Error #26:
\ Error #27:
\ Error #28:
\ Error #29:
\ Error #30:
\ Error #31:

( debug ) \ scr 6

: zx  ( -- )
  cls
  begin   1
          cr depth . sp@ u.
          key drop
  again ;
  \ ?terminal until  ;

( -rot )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

create -rot  ( x1 x2 x3 -- x3 x1 x2 )

  hex
  e1 c, d1 c,     \ pop hl / pop de
  e3 c,           \ ex (sp),hl
  eb c,           \ ex de,hl
  c3 c, pushde ,  \ jp pushde

  smudge decimal

( point )

  \ 2015-06-04: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

create point  ( x y -- )
  hex
  e1 c, d1 c, c5 c,   \ pop hl / pop de / push bc
  \ l = y coordinate
  \ e = x coordinate
  40 05 + c, 48 03 + c, \ ld b,l / ld c,e
  \ b = y coordinate
  \ c = x coordinate
  cd c, 22aa 6 + ,    \ call pixeladd ; +6 to skip BASIC error
  \ hl = screen address
  \ a = pixel position in hl
  40 07 + c,          \ ld b,a
  04 c,               \ inc b
  7e c,               \ ld a,(hl)
  \ rotate:
  07 c,  10 c, fd c,  \ rlca / djnz rotate
  e6 c, 01 c,         \ and 1
  \ finish:
  26 c, 00 c,  68 07 + c,  \ ld h,0 / ld l,a
  c1 c,               \ pop bc
  c3 c, pushhl ,      \ jp pushhl
  smudge decimal

( plot )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

create plot  ( x y -- )

  hex

  d9 c,           \ exx
  e1 c,           \ pop hl
  c1 c,           \ pop bc
  40 05 + c,      \ ld b,l
  dd c, e5 c,     \ push ix
  cd c, 22e5 ,    \ call 0x22e5 ; plot-sub
  dd c, e1 c,     \ pop ix
  d9 c,           \ exx
  c3 c, next ,    \ jp next

  smudge decimal

( bleep )

  \ 2015-06-04: Abersoft Forth's `bleep`.

create bleep
  hex
  e1 c, d1 c, c5 c,   \ pop hl / pop de / push bc
  dd c, e5 c,         \ push ix
  cd c, 03b5          \ call rom_beeper
  dd c, e1 c,         \ pop ix
  c1 c,               \ pop bc
  c3 c, next ,        \ jp next
  smudge decimal

( [if] [else] [then] )

  \ 2015-06-04: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

  require s=  require parse-name  require s"

: [else]  ( "..." -- )

  1 begin   parse-name 2dup swap c@ and
    while   2dup s" [if]" s=
            if    2drop 1+
            else  2dup s" [else]" s=
                  if    2drop 1- dup if  1+  then
                  else  s" [then]" s= if  1-  then
                  then
            then  -dup 0= if  exit  then
  repeat  2drop drop  ; immediate

: [if]  ( "..." -- )  0= if [compile] [else] then  ; immediate

: [then]  ( -- )  ; immediate

( bs h. stype )

: bs  ( -- )  8 emit  ;

: h.  ( n -- )
  \ Print n in hexadecimal with four digits.
  base @ hex swap s>d <# # # # # #> type space base !  ;

hex

: stype  ( ca len -- )
  dup if
    bounds do
      i c@ 7f and dup bl < if  drop [char] .  then  emit
    loop
  else  2drop  then  ;

decimal  -->

( dump )

: dump  ( a len -- )
  7 + -8 and 8 / 0
  2dup - if
    do
      cr dup h.
      8 0 do
        i over + @ cswap h.
      2 +loop
      dup bs 8 stype
      ?terminal if  leave  then
    8 + loop
  else  2drop  then  drop  ;

( decode -- variables, indentation and pause control )

  \ 2015-06-05: Copied from the Afera library
  \ (http://programandala.net/en.program.afera.html).

forth definitions decimal

0 variable decode-level    \ depth of nesting
0 variable decode-address  \ in the word being decoded

: indent  ( -- )
  cr decode-address @ u. decode-level @ 2 * spaces  ;

: indent+  ( -- )  1 decode-level +! indent ;

-->

( decode -- special cases )

: decode-compile  ( a1 -- a2 )  2+ dup @ 2+ pfa>nfa id.  ;

: decode-literal  ( a1 -- a2 )  2+ dup @ .  ;

: decode-branch  ( a1 -- a2 )
  decode-literal  ."  \ to " dup dup @ + u.  ;

: decode-dot-quote  ( a1 -- a2 )
  2+ dup count type  dup c@ + 1 -  ;

-->

( decode -- special cases dispatcher )

: decode-special  ( a1 -- a1 | a2 )
  dup @
  case
    [ ' compile pfa>cfa ] literal of  decode-compile    endof
    [ ' lit     pfa>cfa ] literal of  decode-literal    endof
    [ ' branch  pfa>cfa ] literal of  decode-branch     endof
    [ ' 0branch pfa>cfa ] literal of  decode-branch     endof
    [ ' (loop)  pfa>cfa ] literal of  decode-branch     endof
    [ ' (+loop) pfa>cfa ] literal of  decode-branch     endof
    [ ' (.")    pfa>cfa ] literal of  decode-dot-quote  endof
  endcase  ; 

-->

( decode -- checks of the main code )

: decode-end?  ( cfa -- f )
  \ is the given cfa the end of a definition?
  dup  ' ;s pfa>cfa =  swap ' (;code) pfa>cfa =  or  ;

: colon-pfa?  ( pfa -- f )
  \ is the given pfa a colon definition?
  pfa>cfa @ ' : pfa>cfa @ =  ;

-->

( decode -- main code )

: (decode)  ( pfa --- )

  \ decode the definition at the given pfa.

  dup colon-pfa? if
    dup pfa>nfa decode-address ! indent  ." : " dup pfa>nfa id.
    begin   ( pfa+n ) dup decode-address !
            dup @ dup ( pfa+n cfa cfa ) decode-end? 0=
            \ ( pfa+n cfa f )
    while  \ high level & not end of colon definition
      \ ( pfa+n cfa )
      ( pfa+n cfa ) 2+ ( pfa+n pfa' ) dup indent+  pfa>nfa id.
      key case  [char] q  of  sp! quit  endof \ q
                      bl  of  drop      endof \ space
                                 swap recurse \ default
          endcase  decode-special
      2+  -1 decode-level +!
    repeat  indent 2+ pfa>nfa id. \ show the last word
  else  ." Not a colon definition."  then  drop  ;  -->

( decode -- interface )

: decode-usage  ( -- )
     \  <------------------------------>
  cr ." Keys: space=more, q=quit, other=deeper." cr  ;

: decode  ( "name" -- )
  decode-usage
  -find if    drop 0 decode-level ! (decode)
        else  ." Not found"  then  ;

( index )

: index  ( n1 n2 -- )
  1+ swap do
    cr i 3 .r space 0 i .line
    ?terminal if leave then
  loop  ;

( extend system )

: extend  ( -- )

  \ Change the `cold` start parameters to extend the system to
  \ its current state.

  \ This word should be used especially when system words have
  \ been patched with new words.  otherwise `cold` would delete
  \ the new words and the system would crash when their space
  \ would be overwritten.

  latest 12 +origin !  here 28 +origin !  here 30 +origin !
  here fence !  ' forth 8 + 32 +origin !  ;

  \ system  ( -- a len )
  \
  \ Prepare the system in order to save a copy.  Return its
  \ start address and length, to be used as parameters for the
  \ tape or disk saving commands.

: system  ( -- a len )  extend  0 +origin size 10 + ;

  \ turnkey  ( cfa -- a len )
  \
  \ Prepare the system in order to save a copy that will
  \ execute the given cfa after the ordinary boot process.
  \ return its start address and length, to be used as
  \ parameters for the tape or disk saving commands.

: turnkey  ( cfa -- a len )  boot ! system  ;

  \ vim: filetype=fplusdforth
