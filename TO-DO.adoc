= Solo Forth TO-DO

.2015-06-04:

Move the most used words to the top of the `forth` vocabulary: `:`,
`;`, stack words, control structures, etc.  This should speed up the
compilation of sources.

.2015-06-05:

Fix `exit`, `?exit`, `rdrop`...

Fix: `begin` structures produce compilation errors in screens, but not
in the terminal!

Still strange problems with the stacks:

The problem seems to be, `?stack` is used only by `interpret`, but not
during the execution of a word. When a word stacks several numbers,
they can corrupt the zone below the stack before `?stack` detects the
overflow.

Often the stack gets full during compilation of screens.


.2015-06-06:

Save the error code, in case `warning` is -1.

Make `where` to use values saved somewhere, not on the stack?


DZX-Forth implements `exit` simple as `compile (exit)`, and
`exit` is the word called by `;`. Compare both implementations.

Define `rp`, like in Afera:

  HEX  5E68 CONSTANT RP  DECIMAL

.2015-06-07:

Write a version of `screen` that recognizes the UDG.

Fix: `load` corrupts the system, even with empty screens.

Change: move key to the blocks, as `mode-key` or similar, and use a
simpler `key` (`akey` from Afera).

.2015-06-08:

Fix: `load` corrupts the system, even with empty screens. The reason is spaces are interpreted as
number 0. But `interpret`, `enclose`, `number` and `(number)` seems right.
The problem must be the hidden effect of a recent change.

This behaviour is correct, but maybe it's a clue:

----
bl text 123 pad number ok
2dup ok
. . 0 123 ok
d. 123 ok
bl text  pad number NUMBER? MSG # 1
----

I save two TAP files with the Forth binary.
A binary diff with vbindiff does not show important diffs, only the
stacks and two user variables.  Everything seems normal.

I save a corrupted BIN file with the Forth binary, after doing `60 load` and getting error "stack full",
and compare it to the good binary.

Interesting:

- Only the first buffer has been loaded.
- The value of `use` is 0x61F0, pointing to the second buffer.
- RP holds an addres 6 bytes smaller (3 more elements on the return
  stack):

  0x5EFC 0x5F4C

