; Solo Forth

; *******************************************************
; XXX WARNING

; This file source is for the Pasmo assembler.
; As of now this is file used for the project,
; but <solo_forth.for_binutils.z80s> is updated.

; *******************************************************

; XXX TODO
version_status:   equ 'A'
version_branch:   equ 00
version_release:  equ 201508201924

; XXX TMP -- for debugging
;vr_div: equ version_release/65535
;vr_mod: equ version_release mod 65535
;vr_mod2: equ version_release - vr_div

; A Forth system for ZX Spectrum 128K and G+DOS.
; http://programandala.net/en.program.solo_forth.html

; Copyright (C) 2015 Marcos Cruz (programandala.net)

; Copying and distribution of this file, with or without
; modification, are permitted in any medium without royalty
; provided the copyright notice, the aknowledgments file and
; this notice are preserved.  This file is offered as-is,
; without any warranty.

; ==============================================================
; Acknowledgments

; See the file <ACKNOWLEDGMENTS.adoc>.

; ==============================================================
; History

; See
; http://programandala.net/en.program.solo_forth.history.html

; ==============================================================
; System description

; ----------------------------------------------
; Forth Registers

; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer.
;            Should be preserved across Forth words.
; SP    SP   Data stack pointer.
;            Should be used only as data stack across Forth words.
;            May be used within Forth words if restored before exit.
;       DE   Input only when pushhlde called. ; XXX TODO
;       HL   Input only when pushhl called. ; XXX TODO
;       IX   Address of `next`.
;            May be used within Forth words if restored before exit.
;       IY   Address of the ERRNR ZX Spectrum system variable.
;            May be used within Forth words if restored before exit.

; ----------------------------------------------
; Header structure

; The name and link fields are created in a memory bank:

; cfap: dw cfa             ; Pointer to cfa in main memory.
; lfa:  dw nfa of the previous word
; nfa:  db length+flags    ; Bits:      76543210
                           ; Bit names: .PSLLLLL
                           ; Legend:
                           ;   P: Precedence bit.
                           ;      0 = non-immediate word
                           ;      1 = immediate word
                           ;   S: Smudge bit:
                           ;      0 = definition completed
                           ;      1 = definition not completed
                           ;   LLLLL: name length (0..31).
;       ds length          ; name

; The code and parameter fields are created in the dictionary:

; cfa: dw code_address
; pfa:    ...              ; data or code

; ==============================================================
; Glossary

; The description of Forth words is included in this source.
; The markers `doc{` and `}doc` delimitate the comments that
; form the glossary.

; ----------------------------------------------
; Stack notation

; XXX TODO
; XXX TODO update when true=-1

; a        = address
; ca       = character-aligned address

; f        = flag (false is 0; true is any other value)
; tf       = true flag (1)
; ff       = false flag (0)
; wf       = well-formed flag (false is 0; true is 1)

; b        = 8-bit byte
; c        = 7-bit or 8-bit character
; u        = 16-bit unsigned number
; len      = 16-bit unsigned number, length of memory zone or string
; ca len   = string
; n        = 16-bit signed number
; x        = 16-bit signed or unsigned number
; d        = 32-bit signed double number
; ud       = 32-bit unsigned double number
; xd       = 32-bit signed or unsigned number

; xc       = 8-bit graphic x coordinate (0..255)
; yc       = 8-bit graphic y coordinate (0..191)
; line     = 8-bit cursor line (0..23)
; col      = 8-bit cursor column (0..31)

; cfa      = code field address
; lfa      = link field address
; nfa      = name field address
; pfa      = parameter field address
; cfap     = code field address pointer

; orig     = address of an unresolved forward branch
; dest     = address of a backward branch target

; cs-id    = control structure identifier

; op       = Z80 8-bit opcode, generally a jump
; r        = Z80 8-bit register identifier
; rp       = Z80 16-bit register pair identifier

; ----------------------------------------------
; Parsed text notation

; XXX TODO

; <char>          the delimiting character marking the end of the
;                 string being parsed
; <chars>         zero or more consecutive occurrences of the
;                 character char
; <space>         a delimiting space character
; <spaces>        zero or more consecutive occurrences of the
;                 character space
; <quote>         a delimiting double quote
; <paren>         a delimiting right parenthesis
; <eol>           an implied delimiter marking the end of a line
; ccc             a parsed sequence of arbitrary characters,
;                 excluding the delimiter character
; text            same as ccc
; name            a token delimited by space, equivalent to
;                 ccc<space> or ccc<eol>

; ----------------------------------------------
; Word attributes

; XXX TODO -- finish

; The capital letters on the right show definition characteristics:

; C      May only be used within a colon definition. A digit indicates number
;        of memory addresses used, if other than one. A plus sign indicates
;        a variable number of memory addresses used.
; E      Intended for execution only.
; I      Immediate. Has precedence bit set. Will execute even when compiling.
; U      A user variable.


; ==============================================================
; Configuration

  ; XXX FIXME Pasmo gives strange errors (symbols not found)
  ; when some config flags are used in nested `if`. A literal
  ; flag (0/1) is used instead, with the flag name in a comment;
  ; it is changed with a text substitution.  Some Vim mappings
  ; are created to turn them on on an off.

  ; XXX experimental
size_optimization: equ false
  ; true = some code pieces are more compact but slower.
  ; false = normal, faster code.

  ; XXX TODO -- not used yet
fig_parsing: equ false
  ; true = the fig-Forth parsing method is used.
  ; false = parsing is modified after Forth-83 and ANS Forth.

  ; XXX TODO
;latin1_charset_in_bank: equ false
  ; true = a 224-char Latin 1 charset is stored in the memory bank.
  ; false = the default charset is used.

ans_forth_block_size: equ false
  ; true = one 1024-byte block per screen ; XXX TODO
  ; false = two 512-byte blocks per screen

  ; XXX TODO
; fig_exit: equ true
  ; true = fig-Forth `;s` is used
  ; false = Forth-83 and ANS Forth `exit` is used ; XXX FIXME

  ; XXX TODO try false
  ; XXX FIXME still there are problems when compiler security is off
  ; XXX TMP 2015-08-16 Note: using 1 intead  of the label doesn't make a
  ; difference in the crash bug
;fig_compiler_security: equ true
  ; true = fig-Forth `?pairs' is used
  ; false = no checking during compilation of control
  ;   structures: smaller and faster code.

  ; XXX TODO
show_version: equ false

; ==============================================================
; Symbols

; ----------------------------------------------
; Forth

origin:                           equ 0x5E00

false:                            equ 0
true:                             equ -1
if true=(-1)
  ; XXX FIXME
  ; There were problems when true=-1, but it seems they have
  ; disappeared after switching to the one buffer method.
  .warning TRUE is -1
endif

cell:                             equ 2

cells_per_data_stack:             equ 0x50
cells_per_return_stack:           equ 0x50

bytes_per_terminal_input_buffer:  equ 0x50

buffers:                          equ 0x01

if ans_forth_block_size

data_bytes_per_buffer:            equ 0x0400
blocks_per_screen:                equ 0x01

else

data_bytes_per_buffer:            equ 0x0200
blocks_per_screen:                equ 0x02

endif

total_bytes_per_buffer:           equ 2+data_bytes_per_buffer+3

screens_per_disk:                 equ 0x030C ; 780 KiB per disk in G+DOS
characters_per_line:              equ 0x40
lines_per_screen:                 equ 0x10
max_search_order:                 equ 0x08 ; maximum number of vocabularies in the search order
bytes_per_user_variables:         equ 0x40

smudge_bit:       equ 5
smudge_mask:      equ 1 << smudge_bit
precedence_bit:   equ 6
precedence_mask:  equ 1 << precedence_bit

max_word_length:            equ 0x1F
max_word_length_mask:       equ max_word_length

csb_size:                       equ 256 ; size of the circular string buffer

; Memory banks

default_bank: equ 0
names_bank:   equ 1

names_bank_address: equ 0xC000 ; names pointers

; Charset

charset_size:     equ 224*8 ; 224 chars (0x20..0xFF) * 8 bitmap rows
charset_address:  equ 0xFFFF-charset_size+1

; Control structure check numbers

; XXX TODO -- not used yet
;begin_structure_check_number:   equ 1
;if_structure_check_number:      equ 2
;do_structure_check_number:      equ 3
;case_structure_check_number:    equ 4
;of_structure_check_number:      equ 5
;for_structure_check_number:     equ 6

; Error messages are in the disk, starting from the screen
; number hold in the `msg-scr` constant.  Error codes 0, 16, 32
; etc are not used, because they coincide with the first line of
; screens.

; XXX TODO change the order

error.not_understood:               equ 01
error.stack_empty:                  equ 02
error.dictionary_full:              equ 03 ; not used
error.not_unique:                   equ 04
error.not_found:                    equ 05
error.out_of_disk_range:            equ 06
error.full_stack:                   equ 07
error.number_08:                    equ 08 ; free
error.loading_from_screen_0:        equ 09
error.number_10:                    equ 10 ; free
error.number_11:                    equ 11 ; free
error.number_12:                    equ 12 ; free
error.number_13:                    equ 13 ; free
error.number_14:                    equ 14 ; free
error.deferred_word_uninitialized:  equ 15
error.compilation_only:             equ 17
error.execution_only:               equ 18
error.conditionals_not_paired:      equ 19
error.definition_not_finished:      equ 20
error.protected_dictionary:         equ 21
error.loading_only:                 equ 22
error.off_current_editing_screen:   equ 23
error.declare_vocabulary:           equ 24
error.unsupported_tape_operation:   equ 25
error.unsupported_disk_operation:   equ 26
error.source_file_needed:           equ 27
error.not_present_though_required:  equ 28
error.required_but_not_located:     equ 29
error.branch_too_long:              equ 30
error.number_31:                    equ 31 ; free
error.number_33:                    equ 32 ; free

; ----------------------------------------------
; ZX Spectrum

include inc/zx_spectrum_char_codes.z80s

include inc/zx_spectrum_rom_routines.z80s

include inc/zx_spectrum_system_variables.z80s

sys_screen:                 equ 0x4000
sys_screen_size:            equ 0x1B00
sys_screen_bitmap_size:     equ 0x1800
sys_screen_attributes:      equ 0x5800
sys_screen_attributes_size: equ 0x0300

bank1_port:   equ 0x7FFD
border_port:  equ 0xFE

; ==============================================================
; Macros

; ----------------------------------------------
; Header

immediate: equ 1 ; used as optional parameter

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa \ XXX OLD

_header: macro _base_label,_name,_is_immediate

  ; In dictionary:

  _base_label: ; code field address
  local _dp_backup
  local _name_address
  local _address_after_name
  _dp_backup: equ $

  ; In memory bank:

  org np
  _base_label##cfap:
    dw _base_label ; code field address pointer
  _base_label##lfa: ; link field address
    dw nfa_of_the_previous_word ; link field
  _base_label##nfa: ; name field address

  ; Length byte with optional precedence bit:
  if nul _is_immediate
    db _address_after_name-_name_address
  else
    db _address_after_name-_name_address+precedence_mask
  endif

  _name_address: equ $
    db _name ; name field
  _address_after_name: equ $

  np: defl $ ; new value of the names pointer

  ; Update the names pointer:
  org names_pointer
  dw np ; overwrite names_pointer
  dw np ; overwrite names_pointer_init_value

  ; In dictionary:
  org _dp_backup

  nfa_of_the_previous_word: defl _base_label##nfa

  endm

_code_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw _base_label##pfa ; code field
  _base_label##pfa: ; parameter field address

  endm

_code_alias_header: macro _base_label,_name,_is_immediate,_alias

  _header _base_label,_name,_is_immediate
  dw _alias##pfa ; code field

  endm

_colon_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_colon ; code field
  _base_label##pfa: ; parameter field address

  endm

_user_variable_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_user ; code field
  _base_label##pfa: ; parameter field address

  endm

_does_header: macro _base_label,_name,_is_immediate,_runtime_routine

  _header _base_label,_name,_is_immediate

  dw _runtime_routine ; code field
  _base_label##pfa: ; parameter field address

  endm

_constant_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_constant ; code field
  _base_label##pfa: ; parameter field address

  endm

_variable_header: macro _base_label,_name,_is_immediate

  _header _base_label,_name,_is_immediate
  dw do_create ; code field
  _base_label##pfa: ; parameter field address

  endm

_two_variable_header: macro _base_label,_name,_is_immediate

  _variable_header _base_label,_name,_is_immediate

  endm

; ----------------------------------------------
; Literals

_string: macro text

  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first ; length byte
  _first: db text
  _next:

endm

_literal: macro _n

  ; Note: parenthesis are needed to prevent a strange problem of
  ; Pasmo with signs.

  if (_n)=0
    dw zero_
  else
    if (_n)=1
      dw one_
    else
      if (_n)=2
        dw two_
      else
        if (_n)>=0 && (_n)<=255
          dw c_lit_
          db _n
        else
          dw lit_
          dw _n
        endif
      endif
    endif
  endif
  endm

; ----------------------------------------------
; Jumps

_jp_next: macro

  jp (ix)

  endm

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization
    jr z,_address
  else
    jp z,_address
  endif
  endm

; ----------------------------------------------
; Bank

_bank: macro _n
  _literal _n
  dw bank_
  endm

_names_bank: macro
  _bank names_bank
  endm

_default_bank: macro
  _bank default_bank
  endm

; ----------------------------------------------
; Error messages

_question_error: macro _error
  _literal _error
  dw question_error_
  endm

_message: macro _error
  _literal _error
  dw message_
  endm

; ----------------------------------------------
; Debug

_z80_border: macro _color
  local _pause0
  push af
  push bc
  ld a,_color
  out(0xFE),a
  ld bc,0
  _pause0:
  dec bc
  ld a,b
  or c
  jr nz,_pause0
  pop bc
  pop af
  endm

_z80_border_wait: macro _color
  local _wait
  push af
  ld a,_color
  out(0xFE),a
  xor a
  ld (sys_last_k),a
  _wait:
  ld a,(sys_last_k)
  and a
  jr z,_wait
  pop af
  endm

_echo: macro _txt
  dw cr_,paren_dot_quote_
  _string _txt
  endm

; ==============================================================
; Entry points

  org origin

cold_entry:
  ; Location (of the destination address): `0x01 +origin`
  jp cold_start
warm_entry:
  ; Location (of the destination address): `0x04 +origin`
  jp warm_start

; ==============================================================
; Parameter area

  ; XXX TODO document the `+origin` index

latest_nfa_in_root_voc.init_value:
  dw latest_nfa_in_root_voc

latest_nfa_in_forth_voc.init_value:
  dw latest_nfa_in_forth_voc

latest_nfa_in_assembler_voc.init_value:
  dw latest_nfa_in_assembler_voc

voc_link.init_value:
  dw assembler_vocabulary_link ; link to the latest vocabulary defined

user_variables_pointer:
  dw user_variables

return_stack_pointer:
  dw return_stack_bottom

default_color_attribute:
  dw 4 ; low byte: green paper, black ink; high byte: no mask

  ; XXX TODO
if show_version
version_status_variable:
  dw version_status
version_branch_variable:
  dw version_branch
version_release_variable:
  dw version_release mod 0xFFFF
  dw version_release / 0xFFFF
endif

  ; User variables default values

  ; The first eight user variables have default values.  They are used
  ; by `cold` to overwrite the correspondent user variables.  They must
  ; be in the same order than user variables.

default_user_variables_start:

s0_init_value:
  dw data_stack_bottom
r0_init_value:
  dw return_stack_bottom
  dw 0x0000 ; XXX OLD -- tib
width_init_value:
  dw max_word_length
warning_init_value:
  dw 0x0000
  dw 0x0000 ; XXX OLD -- fence
  dw 0x0000 ; XXX OLD -- dp

  ; XXX TODO move
  dw 0x0000 ; XXX free

  ; XXX TODO this four user variables do not need init and this
  ; space could be saved; they are included here because `#tib`
  ; must be init; it should be moved to user variable +0x10.

blk_init_value:
  dw 0x0000
in_init_value:
  dw 0x0000
out_init_value:
  dw 0x0000
scr_init_value:
  dw 0x0000

; XXX OLD
;number_tib_init_value:
;  dw bytes_per_terminal_input_buffer

default_user_variables_end:

ip_backup: ; temporary copy of Forth IP
  dw 0

np: defl names_bank_address+1

names_pointer:
  ; First free address in the names bank,  restored by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np

names_pointer_init_value:
  ; Init value of the names pointer, used by `cold`.
  ; The value is updated during the assembling,
  ; by the `_header` macro.
  dw np


; ==============================================================
; User variables

user_variables:

  ; Note: the first eight user variables are initialized with
  ; default values by `cold`.  They must be in the same order
  ; than their default variables.

s0_value: ; +0x00
  dw data_stack_bottom
r0_value: ; +0x02
  dw return_stack_bottom
  ; +0x04
  dw 0x0000 ; XXX OLD -- tib
width_value: ; +0x06
  dw max_word_length
warning_value: ; +0x08
  dw 0x0000
  ; +0x0A
  dw 0x0000 ; XXX OLD -- fence
  dw 0x0000 ; XXX OLD -- dp

  ; XXX TODO move
  dw 0x0000 ; +0x0E free

blk_value: ; +0x10
  dw 0x0000
in_value: ; +0x12
  dw 0x0000
out_value: ; +0x14
  dw 0x0000
scr_value: ; +0x16
  dw 0x0000
number_tib_value: ; +0x18
  dw 0x0000
hld_value: ; +0x1A
  dw 0x0000
current_value: ; +0x1C
  dw 0x0000
state_value: ; +0x1E
  dw 0x0000
base_value: ; +0x20
  dw 0x000A
dpl_value: ; +0x22
  dw 0x0000
fld_value: ; +0x24
  dw 0x0000
csp_value: ; +0x26
  dw 0x0000
r_hash_value: ; +0x28 ; XXX OLD -- used by the editor, remove
  dw 0x0000

context_value: ; +0x2A..+0x38

  dw forth_pfa
  dw root_pfa
  ds (max_search_order-2)*cell
  dw 0x0000 ; end of search order, required by `find` \ XXX TODO improve and remove

  ; Unused
  dw 0x0000
  dw 0x0000

if ($-user_variables) != bytes_per_user_variables
  .error "The space reserved for user variables is wrong."
endif

; ==============================================================
; Stacks and buffers

; ----------------------------------------------
; Circular string buffer

csb:
unused_csb:
  dw csb_size ; unused space in the buffer
csb0:
  ds csb_size
csb_total_size: equ $-csb

; ----------------------------------------------
; Data stack

data_stack_limit: equ $+cell
  ds cells_per_data_stack*cell
data_stack_bottom:

; ----------------------------------------------
; Terminal input buffer

terminal_input_buffer:
  ds bytes_per_terminal_input_buffer
  ds 3 ; for the null word

; ----------------------------------------------
; Return stack

return_stack_limit: equ $+cell
  ds cells_per_return_stack*cell
return_stack_bottom:

; ----------------------------------------------
; Disk buffer

buffer_block_id_mask: equ 0x7FFF

; A block id is the number of the associated block, with the
; sign bit indicating, when it's set, that the buffer has been
; modified.

disk_buffer:

dw buffer_block_id_mask     ; Block id used when the  buffer
                            ; is not associated with a block.
ds data_bytes_per_buffer    ; Actual content of the block,
                            ; a disk sector.
db space_char,0,space_char  ; Null word, required by the parsing words.

; ==============================================================
; Misc routines

; [Code from DZX-Forth.]

; ----------------------------------------------
; Compare de and hl

compare_de_hl_unsigned:

  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de

  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:

  ; Input:  de, hl
  ; Output: flag C if hl < de

  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ----------------------------------------------
; Move block

move_block:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy the contents of bc consecutive address
  ; units at hl to the bc consecutive address units at de. After the move
  ; completes, the bc consecutive address units at de contain exactly what the
  ; bc consecutive address units at hl contained before the move.

  call compare_de_hl_unsigned
  jp c,move_block_downwards

; ----------------------------------------------
; Move block upwards

move_block_upwards:

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from lower addresses to higher addresses.

  ld a,c
  or b
  ret z
  ldir
  ret

; ----------------------------------------------
; Move block downwards

  ; Input:
  ; hl = source
  ; de = destination
  ; bc = count

  ; If bc is greater than zero, copy bc consecutive characters from the data
  ; space starting at hl to that starting at de, proceeding
  ; character-by-character from higher addresses to lower addresses.

move_block_downwards:

  ld a,c
  or b
  ret z
  add hl,bc
  dec hl
  ex de,hl
  add hl,bc
  dec hl
  ex de,hl
  lddr
  ret

; ----------------------------------------------
; Multiplication primitives

; AHL <- A * DE

a_multiplied_by_de_to_ahl:
  ld hl,0
  ld c,8
a_multiplied_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_multiplied_by_de_to_ahl.2
  add hl,de
  adc a,0
a_multiplied_by_de_to_ahl.2:
  dec c
  jp nz,a_multiplied_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32-bit result

; HLDE <- HL * DE

hl_multiplied_by_de_to_hlde_unsigned:
  push bc ; save Forth IP
  ld b,h
  ld a,l
  call a_multiplied_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_multiplied_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc ; restore Forth IP
  ret

; ==============================================================
; :Inner interpreter

push_hlde:
  push de

push_hl:
  push hl

next:
  ; Execute the word whose cfa is in the address pointed by the bc register.
  ; Forth: W  <-- (IP)
  ; Z80:   hl <-- (bc)
  ld a,(bc)
  ld l,a
  inc bc ; inc IP
  ld a,(bc)
  ld h,a
  inc bc ; inc IP
  ; bc = address of the next cfa
  ; hl = cfa

next2:
  ; Execute the word whose cfa is in the hl register.
  ; Forth: PC <-- (W)
  ; Z80:   pc <-- (hl)
  ld e,(hl)
  inc hl
  ld d,(hl)
  ex de,hl
  ; hl = (cfa) = address of the code
  ; de = cfa+1 = pfa-1

next2_end: ; XXX TMP for debugging
  jp (hl)

; ==============================================================
; Dictionary

; ----------------------------------------------
; Start compiling in the `root` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl root_pfa

; ----------------------------------------------
  _code_header root_x_,0,immediate

; doc{

; x  ( -- )

; This is a pseudonym for an alias of the "null" word that is
; defined in the `forth` vocabulary.

; }doc

  ld hl,x_ ; cfa of the actual null word
  jp next2 ; execute it

; ----------------------------------------------
  _colon_header root_forth_,'FORTH'

  dw forth_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header root_definitions_,'DEFINITIONS'

  dw definitions_
  dw semicolon_s_

latest_nfa_in_root_voc: equ root_definitions_nfa

; ----------------------------------------------
; Start compiling in the `assembler` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa

; ----------------------------------------------
  _variable_header abase_,'ABASE'

; doc{
;
; abase  ( -- a )
;
; A variable used to save the current value of `base` in
; assembler definitions.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header asm_,'ASM'

; doc{
;
; asm  ( -- )
;
; Enter the assembler mode.
;
; }doc

  ; [Idea taken from Coos Haak's Z80 Forth assembler.]

  dw noop_ ; to be patched by the assembler
  dw base_,fetch_,abase_,store_ ; save the current base
  dw hex_
  dw also_,assembler_ ; XXX TODO better
  dw semicolon_s_

; ----------------------------------------------
  _colon_header end_asm_,'END-ASM'

; doc{
;
; end-asm  ( -- )
;
; Exit the assembler mode.
;
; }doc

  dw previous_ ; restore the search order ; XXX TODO better
  dw abase_,fetch_,base_,store_ ; restore `base`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header end_code_,'END-CODE'

  dw question_csp_,end_asm_,smudge_
  dw semicolon_s_

; ----------------------------------------------
  _constant_header next_,'NEXT'

  dw next

; ----------------------------------------------
  ; _constant_header next_,'NEXT2'

  ; ; XXX OLD -- added for the second version of `defer`, but
  ; ; not needed
  
  ; dw next2

; ----------------------------------------------
  _constant_header pushhl_,'PUSHHL'

  dw push_hl

; ----------------------------------------------
  _constant_header pushhlde_,'PUSHHLDE'

  dw push_hlde

; ----------------------------------------------
  _constant_header fetchhl_,'FETCHHL'

  dw fetch.hl

; ----------------------------------------------
  _colon_header next_comma_,'NEXT,'

; doc{
;
; next,  ( -- )
; 
; Compile a Z80 jump to `next`.
;
; }doc

  dw lit_,0xE9DD ; opcode `jp (ix)`
  dw comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pushhl_comma_,'PUSHHL,'

; doc{
;
; pushhl,  ( -- )
; 
; Compile a Z80 jump to `pushhl`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,push_hl,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pushhlde_comma_,'PUSHHLDE,'

; doc{
;
; pushhlde,  ( -- )
; 
; Compile a Z80 jump to `pushhlde`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,push_hlde,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header fetchhl_comma_,'FETCHHL,'

; doc{
;
; fetchhl,  ( -- )
; 
; Compile a Z80 jump to `fetchhl`.
;
; }doc

  _literal 0xC3 ; opcode `jp`
  dw c_comma_
  dw lit_,fetch.hl,comma_
  dw semicolon_s_

latest_nfa_in_assembler_voc: equ fetchhl_comma_nfa

; ----------------------------------------------
; Start compiling in the `forth` vocabulary

nfa_of_the_previous_word: defl 0 ; link to previous Forth word
; current_vocabulary: defl forth_pfa


; ----------------------------------------------
  _colon_header label_,'LABEL'

  dw create_,asm_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header also_,'ALSO'

; doc{
;
; also  ( -- )
;
; Duplicate the vocabulary at the top of the search order.
;
; }doc

; [Code adapted from F83.]

; : also  ( -- )
;   context dup cell+ [ #vocs 2- cells ] literal cmove>  ;

  dw context_,dup_,cell_plus_
  dw lit_,(max_search_order-cell)*cell
  dw cmove_up_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header minus_order_,'-ORDER'

; : -order  ( -- )  context [ #vocs cells ] literal erase  ;

  dw context_,lit_,max_search_order*cell,erase_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header only_,'ONLY'

; doc{
;
; only  ( -- )
;
; Erase the search order and forces the `root` vocabulary to
; be the first and second.
;
; }doc

; [Code adapted from F83.]

; : only  ( -- )  -order root also  ;

  dw minus_order_,root_,also_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header previous_,'PREVIOUS'

; doc{
;
; previous  ( -- )
;
; Remove the most recently referenced vocabulary from the search
; order.
;
; }doc

; [Code adapted from F83.]

; : previous  ( -- )
;   context dup cell+ swap [ #vocs 2- cells dup ] literal cmove
;   context literal + off  ;

  dw context_,dup_,cell_plus_,swap_
  dw lit_,(max_search_order-cell)*cell,cmove_
  dw context_,lit_,(max_search_order-cell)*cell,plus_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header seal_,'SEAL'

; doc{
;
; seal  ( -- )
;
; Change the search order such that only the vocabulary at the
; top of the search order will be searched.
;
; }doc

; [Code adapted from F83.]

; : seal  ( -- )  context @ -order context !  ;

  dw context_,fetch_,minus_order_,context_,store_
  dw semicolon_s_

; ----------------------------------------------

  _does_header root_,'ROOT',,do_vocabulary

  dw latest_nfa_in_root_voc

root_vocabulary_link:
  dw 0x0000

; ----------------------------------------------

  _does_header forth_,'FORTH',,do_vocabulary

  dw latest_nfa_in_forth_voc ; nfa of the latest word defined in this vocabulary

forth_vocabulary_link:
  dw root_vocabulary_link

; ----------------------------------------------
  _does_header assembler_,'ASSEMBLER',,do_vocabulary

; XXX TODO move `assembler` and everthing related
; to the library disk?

  dw latest_nfa_in_assembler_voc
assembler_vocabulary_link:
  dw forth_vocabulary_link

; ----------------------------------------------
  _colon_header s_lit_,'SLIT'

  ; : slit  ( -- ca len )  r@ count dup 1+ r> + >r  ;

  dw r_fetch_,count_,dup_,one_plus_
  dw from_r_,plus_,to_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_s_,'(S)'

; doc{
;
; (s) ( compilation: c "text<c>" -- ) ( run-time:  -- ca len )
;
; }doc

  dw parse_ ; ( ca len )
  dw comp_question_
  dw zero_branch_,paren_s.interpreting
  ; compiling
  dw s_literal_
  dw semicolon_s_ ; XXX TODO exit_
paren_s.interpreting:
  dw save_string_
  dw semicolon_s_

; ----------------------------------------------
  _code_header c_lit_,'CLIT'

  ld a,(bc)
  inc bc
  ; XXX TODO include these entry points in the `assembler` vocabulary?
push_a:
  ld l,a
push_l: ; XXX TMP -- not used yet
  ld h,0
  jp push_hl

; ----------------------------------------------
  _code_header lit_,'LIT'

  ; XXX FIXME -- crash if not compiling
  ; XXX TODO -- implement compile-only flag?

  ld a,(bc)
  inc bc
  ld l,a
  ld a,(bc)
  inc bc
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header bank_,'BANK'

; doc{
;
; bank  ( n -- )
;
; Page memory bank _n_ (0..7) at 0xC000..0xFFFF.
;
; }doc

  pop de ; e = bank
  call bank.e
  _jp_next

bank.default:
  ; XXX TODO ?
bank.names:
  ; XXX TODO ?
bank.e:
  ; ret ; XXX TMP for debugging
  ld a,(sys_bankm) ; get the saved status of BANKM
  and 0xF8 ; erase bits 0-2
  or e ; modify bits 0-2
  di
  ld (sys_bankm),a ; update BANKM
  out (bank1_port),a ; page the bank
  ei
  ret

; ----------------------------------------------
  _code_header unused_csb_,'UNUSED-CSB'

; doc{
;
; csb-unused  ( -- len )
;
; }doc

  ld hl,(unused_csb)
  jp push_hl

; ----------------------------------------------
  _constant_header csb0_,'CSB0'

; doc{
;
; csb0  ( -- a )
;
; }doc

  dw csb0

; ----------------------------------------------
  _colon_header question_csb_,'?CSB'

; doc{
;
; ?csb  ( len -- )
;
; Make sure there's room for the given characters.
;
; }doc

  dw dup_,lit_,unused_csb,fetch_,greater_than_
  dw zero_branch_,question_csb_.enough
  ; not enough space; reset the pointer
  _literal csb_size
  dw lit_,unused_csb,store_

question_csb_.enough:
  dw negate_,lit_,unused_csb,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header allocate_string_,'ALLOCATE-STRING'

; doc{
;
; string-allocate  ( len -- ca )
;
; }doc

  dw question_csb_
  dw csb0_,unused_csb_,plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header save_string_,'SAVE-STRING'

; doc{
;
; save-string  ( ca1 len1 -- ca2 len1 )
;
; }doc

  dw dup_,allocate_string_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header save_counted_string_,'SAVE-COUNTED-STRING'

; doc{
;
; save-counted-string  ( ca1 len1 -- ca2 )
;
; }doc

; dup 1+ string-allocate dup >r $! r>

  dw dup_,one_plus_,allocate_string_
  dw dup_,to_r_,dollar_store_,from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header empty_csb_,'EMPTY-CSB'

; doc{
;
; empty-csb  ( -- )
;
; }doc

  dw lit_,csb
  _literal csb_total_size
  dw erase_
  dw semicolon_s_

; ----------------------------------------------
  _code_header execute_,'EXECUTE'

; doc{
;
; execute  ( cfa  -- )
;
; }doc

  pop hl
  jp next2

; ----------------------------------------------
  _code_header perform_,'PERFORM'

; doc{
;
; perform  ( a  -- )
;
; Execute the word whose cfa is stored in _a_.  Do nothing if
; the content of _a_ is zero.
;
; }doc

  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp nz,next2
  _jp_next

; ----------------------------------------------
  _colon_header forward_mark_,'>MARK'

; doc{
;
; >mark  ( -- orig )  \ Forth-83, C, "forward-mark"
;
; Compile space in the dictionary for a branch address which
; will later be resolved by `>resolve`.
;
; Used at the source of a forward branch.  Typically used after
; either `branch`, `0branch` or `?branch`.
;
; }doc

  dw here_,zero_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header forward_resolve_,'>RESOLVE'

; doc{
;
; >resolve  ( orig -- )  \ Forth-83, C, "forward-resolve"
;
; Resolve a forward branch by placing the address of the current
; dictionary pointer into the space compiled by `>mark`.
;
; }doc

  dw here_,swap_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_mark_,'<MARK'

; doc{
;
; <mark  ( -- dest )  \ Forth-83, C, "backward-mark"
;
; Leave the address of the current dictionary pointer, as the
; the destination of a backward branch.  _dest_ is typically
; only used by `<resolve` to compile a branch address.
;
; }doc

  dw here_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backward_resolve_,'<RESOLVE'

; doc{
;
; <resolve  ( dest -- )  \ Forth-83, C, "backward-resolve"
;
; Resolve a backward branch.  Compile a branch address using
; _dest_, the address left by `<mark`,  as the destination
; address.  Used at the source of a backward branch after either
; `branch` or `?branch` or `0branch`.
;
; }doc

  dw comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header branch_,'BRANCH'

; doc{
;
; branch  ( -- )  \ ANS Forth
;
; The run-time procedure to branch unconditionally. An in-line
; offset is copied to the interpretive pointer IP to branch
; forward or backward.
;
; }doc

  ld h,b
  ld l,c ; hl = Forth IP, containing the address to jump to
  ld c,(hl)
  inc hl
  ld b,(hl) ; bc = New Forth IP
  _jp_next

; ----------------------------------------------
  _code_header zero_branch_,'0BRANCH'

; doc{
;
; 0branch  ( f -- )  \ fig-Forth
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is false (zero), the following in-line address is copied to IP
; to branch forward or  backward.
;
; }doc

  pop hl
  ld a,l
  or h
  jp z,branch_pfa ; branch if zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header question_branch_,'?BRANCH'

; doc{
;
; ?branch  ( f -- )
;
; A run-time procedure to branch conditionally. If  _f_ on stack
; is not zero, the following in-line address is copied to IP to
; branch forward or backward.
;
; Note: This is not Forth-83's `?branch`: Forth-83's `?branch`
; does the same than fig-Forth's `0branch`: the branch is done
; when the flag is zero. Solo Forth includes fig-Forth's
; `0branch` and also `?branch`, that branches when the flag is
; not zero.
;
; }doc

  pop hl
  ld a,l
  or h
  jp nz,branch_pfa ; branch if not zero
  inc bc
  inc bc ; skip the inline branch address
  _jp_next

; ----------------------------------------------
  _code_header paren_loop_,'(LOOP)'

  ; XXX NOTE:
  ;
  ; This code is from Abersoft Fort.  It's the same code used in
  ; `(+loop)` in fig-Forth 1.1g.  The author of Abersoft Forth
  ; used it to write `(loop)` and wrote `(+loop)` with a simple
  ; call to it, what saves code.
  ;
  ; XXX TODO -- The `(loop)` of DZX-Forth is much faster, but
  ; requires and additional parameter on the return stack.

  ld de,0x0001
paren_loop.step_in_de:
  ld hl,(return_stack_pointer)
  ld a,(hl)
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl ; (hl) = limit
  inc d
  dec d
  ld d,a ; de = new index
  jp m,paren_loop.negative_step

  ; increment>0
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)
  jp paren_loop.end

paren_loop.negative_step:
  ; increment<0
  ld a,(hl) ; limit-index
  sub e
  inc hl
  ld a,(hl)
  sbc a,d ; a<0?

paren_loop.end:
  jp m,branch_pfa ; loop again if a<0
  ; done, discard loop parameters
  inc hl
  ld (return_stack_pointer),hl
  ; skip branch offset
  inc bc
  inc bc
  _jp_next

; ----------------------------------------------
  _code_header paren_plus_loop_,'(+LOOP)'

  pop de
  jp paren_loop.step_in_de

; ----------------------------------------------

if 0

  _colon_header paren_question_do_,'(?DO)'

  ; XXX TODO -- first draft, just copied from DZX-Forth

  ; XXX FIXME -- crash in both cases

  dw two_dup_,equals_
  dw question_branch_,paren_question.end
  dw paren_do_
  dw semicolon_s_ ; XXX TODO exit_
paren_question.end:
  dw two_drop_
  dw from_r_,fetch_,to_r_
  dw semicolon_s_

endif

; ----------------------------------------------
  _code_header paren_do_,'(DO)'

  ; [Code from CP/M fig-Forth 1.1g.]

  exx                           ; 04t 01b
  pop de                        ; 10t 01b
  pop bc                        ; 10t 01b
  ld hl,(return_stack_pointer)  ; 20t 03b
  dec hl                        ; 06t 01b
  ld (hl),b                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),c                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),d                     ; 07t 01b
  dec hl                        ; 06t 01b
  ld (hl),e                     ; 07t 01b
  ld (return_stack_pointer),hl  ; 16t 03b
  exx                           ; 04t 01b
                                ;116t 18b TOTAL
  _jp_next

; ----------------------------------------------
; XXX TODO experimental do-loop structures adapted from Spectrum Forth-83
; and F83.

; A do-loop pushes three items on the return stack:
;
; 0) Limit
; 1) Reverse branch address (jump to here if loop repeats).
; 2) Current index represented as `(index-limit) xor 0x8000`.
;    This is at the top.
;    The current index is represented this way so it is easier
;    to check whether index has crossed the boundary between
;    limit-1 and limit, acoording to
;    the rules of Forth-83, even with negative increment in +LOOP.

  _code_header paren_do83_,'(DO83)'

  pop hl ; initial value
  pop de ; limit
paren_do83.de_hl
  ; de = limit
  ; hl = initial value
  push hl ; initial value  ( initial )
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e ; push limit value on return stack ( R: initial )
  inc bc
  inc bc ; increment the Forth IP, skip branch address
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c ; push current instruction pointer on return stack
  ex (sp),hl ; initial value now in HL, return stack pointer on stack
  and a ; reset the carry flag
  sbc hl,de ; B SBCP        \ Subtract limit value.
  ld a,h ; H A LD
  xor 0x80 ; 80 XOR#       \ Flip most significant bit.
  ld d,a ; A B LD
  ld e,l ; L C LD        \ Move result to DE.
  pop hl ; H POP        \ Get return stack pointer from stack,
  dec hl ; H DEC
  ld (hl),d ; B M LD
  dec hl ; H DEC
  ld (hl),e ; C M LD        \ Push (initial - limit) XOR 0x8000 onto return stack.
  ld (return_stack_pointer),hl ; RPTR STHL       \ Save return stack pointer.
  _jp_next ; JPIX ;C

  _code_header paren_question_do83_,'(?DO83)'

  pop hl ; initial value
  pop de ; limit
  and a ; reset the carry flag
  sbc hl,de ; compare
  jr z,question_do.equals
  ; not equals
  ; XXX TODO move add after sbc and save one jump
  add hl,de ; reverse the subtraction
  jp paren_do83.de_hl ; perform regular `do`
question_do.equals:
  jp branch_pfa ; XXX TODO ?

  _colon_header question_do83_,'?DO83',immediate

  dw compile_,paren_question_do83_
  dw forward_mark_
if 1 ; fig_compiler_security
  _literal 3
endif
  dw semicolon_s_

  _colon_header do83_,'DO83',immediate

  dw compile_,paren_do83_
  dw forward_mark_
if 1 ; fig_compiler_security
  _literal 3
endif
  dw semicolon_s_

  _colon_header loop83_,'LOOP83',immediate

if 1 ; fig_compiler_security
  _literal 3
  dw question_pairs_
endif
  dw compile_,paren_loop83_
  dw forward_resolve_
  dw semicolon_s_

  ; _colon_header plus_loop83_,'+LOOP83',immediate

  ; dw c_lit_
  ; db 3
  ; dw question_pairs_
  ; dw compile_,paren_plus_loop83_
  ; dw forward_resolve_
  ; dw semicolon_s_

  _colon_header paren_loop83_,'(LOOP83)'

  ld hl,(return_stack_pointer)
  ld e,(hl) ; M C LD
  inc hl    ; H INC
  ld d,(hl) ; M B LD         \ Read current index value.
  inc de    ; B INC         \ Increment it.
  ld a,d    ; B A LD
  xor 0x80  ; 80 XOR#
  or e      ;  C OR         \ Was it equal to 0x8000 ?
  jp nz,paren_loop83.loop ; jump if not

  ; The real index has reached limit, terminate loop.
  ; Increment ret stack pointer by 5 (1 increment already done).
  ld de,5   ; 5 B LDP#
  add hl,de ; B ADDP
  ld (return_stack_pointer),hl ; RPTR STHL
  _jp_next

paren_loop83.loop:

  ld (hl),d ;  B M LD
  dec hl    ; H DEC
  ld (hl),e ; C M LD    \ Store updated index.
  inc hl    ; H INC
  inc hl    ; H INC
  ld c,(hl) ; M E LD
  inc hl    ; H INC
  ld c,(hl) ; M D LD   \ Read loop start address into instruction pointer, repeat loop.
  _jp_next

if 0 ; XXX TODO adapt

; CODE (+LOOP83) ( w --- )
;  RPTR LDHL     \ Read return stack pointer into HL.
;    M C LD
;     H INC
;    M B LD      \ Read Current index.
;      EXSP      \ HL now contains w, the increment value.
;     A AND
;    B ADCP      \ Add increment to index.
;    v if
;                \ If overflow, then boundary between limit-1 and limit is
;                \ crossed, terminate loop.
;      H POP     \ Get return stack pointer.
;   5 B LDP#
;     B ADDP
;  RPTR STHL     \ Increment ret stack pointer by 5 (1 increment already done)
;                \ and store updated ret stack pointer back.
;    else
;     H B LD
;     L C LD     \ Move updated index to BC.
;      H POP     \ Get return stack pointer.
;     B M LD
;      H DEC
;     C M LD     \ Store updated index.
;      H INC
;      H INC
;     M E LD
;      H INC
;     M D LD     \ Read loop start address into instruction pointer, repeat loop.
;    then
;  JPIX ;C

; CODE LEAVE83
;  RPTR LDHL     \ Read return stack pointer into HL.
;     H INC
;     H INC
;    M E LD
;     H INC
;    M D LD      \ Get start address into DE.
;     H INC
;     H INC
;     H INC
; RPTR STHL      \ Write updated return stack pointer (6 was added).
;     D DEC
;     D DEC      \ DE (instruction pointer) now points to forward branch address
;   'BRANCH @ JP ;C \ continue into BRANCH.

; CODE I83  ( --- w)
; RPTR LDHL        \ Read return stack pointer into HL.
;   \ J jumps here.
;   M C LD
;    H INC
;   M B LD         \ Read current index. (which is (index-limit) xor 0x8000.
;    H INC
;    H INC
;    H INC
;   M A LD         \ Read limit and add to index
;    C ADD
;   A C LD
;    H INC
;   M A LD
;    B ADC
;  80 XOR#         \ and flip most significant bit, getting true index value.
;   A B LD
;   B PUSH         \ Push result.
; JPIX ;C

; CODE J83 ( --- w)
;   RPTR LDHL      \ Read return stack pointer into HL
;   6 B LDP#
;     B ADDP       \ Add 6 to it, to get to next inner loop parameters.
;  'I @ 3 + JR ;C  \ Continue into I.

; CODE I'83 ( --- w)
;   RPTR LDHL      \ Read return stack pointer into HL
;      H INC
;      H INC
;      H INC
;      H INC
;     M C LD
;      H INC
;     M B LD       \ Read limit value.
;     B PUSH       \ Push result
;     JPIX ;C

endif

; ----------------------------------------------
  _code_alias_header i_,'I',,r_fetch_

; doc{
;
; i  ( -- x ) ( R: loop-sys -- loop-sys ) \ ANS Forth
;
; Return a copy of the current (innermost) loop index.
;
; }doc

; ----------------------------------------------
  _code_header digit_,'DIGIT'

; doc{
;
; digit  ( c n1 --- n2 tf | ff )  \ fig-Forth
;
; Convert the ascii character _c_ (using base _n1_) to its
; binary equivalent n2, accompanied by a true flag. If the
; conversion is invalid, leave only a false flag.
;
; }doc

  pop hl  ; l=base
  pop de  ; e=character
  ld a,e  ; character
  sub '0' ; >="0"
  jp c,false_pfa ; <"0" is invalid
  cp 0x0A ; >"9"?
  jp m,digit.test_value ; no, test value
  sub 0x07 ; gap between "9" & "A", now "A"=0x0A
  cp 0x0A ; >="A"?
  jp c,false_pfa ; characters between "9" & "A" are invalid
digit.test_value:
  cp l ; <base?
  jp nc,false_pfa ; no, invalid
  ld e,a ; converted digit
  push de
  jp true_pfa

; ----------------------------------------------
  _code_header paren_find_,'(FIND)'

; doc{
;
; (find)  ( ca nfa --- ca 0 | cfa 1 | cfa -1 )
;
; Find the definition named in the counted string at _ca_,
; starting at _nfa_. If the definition is not found, return _ca_
; and zero.  If the definition is found, return its _cfa_. If
; the definition is immediate, also return one (1); otherwise
; also return minus-one (-1).
;
; }doc

  ld e,names_bank
  call bank.e ; page the memory bank

  pop de ; nfa
  pop hl ; string address
  push bc ; save the Forth IP
  ld (paren_find.string_address),hl

  ; XXX FIXME the string searched for must be in the string
  ; buffer, below 0xC000! This is not a problem now, during the
  ; development, because the dictionary is small.

paren_find.begin:
  ;_z80_border 2 ; XXX INFORMER
  ;_z80_border 7 ; XXX INFORMER
  ; Compare the string with a new word.
  ; de = nfa
  ld (paren_find.nfa_backup),de ; save the nfa for later
paren_find.string_address: equ $+1
  ld hl,0 ; string address
  ld a,(de) ; length byte of the name field
  ld c,a    ; save for later
  and max_word_length_mask  ; length
  cp (hl) ; same length?
  jr nz,paren_find.not_a_match ; lengths differ

  ; Lengths match, compare the characters.
  ld b,a ; length
paren_find.compare_next_char:
  inc hl ; next character in string
  inc de ; next character in name field
  ld a,(de)
  cp (hl) ; match?
  jr nz,paren_find.not_a_match ; no match
  djnz paren_find.compare_next_char ; match so far, loop again

  ; The string matches.
  ; c = name field length byte
  ld hl,(paren_find.nfa_backup)
;  ld (0xfffa),hl ; XXX INFORMER ; nfa, ok
  dec hl
  dec hl ; lfa
  dec hl ; high part of the pointer to cfa
  ld d,(hl)
  dec hl ; low part of the pointer to cfa
  ld e,(hl) ; de = cfa

;  ld (0xfffc),de ; XXX INFORMER ; cfa, ok

  ld hl,1 ; 1=immediate word
  ld a,c ; name field length byte
  and precedence_mask ; immediate word?
  jp nz,paren_find.end
  ; non-immediate word
  dec hl
  dec hl ; -1 = non-immediate word

paren_find.end:
  ; If match found:
  ;   de = cfa
  ;   hl = -1 | 1
  ; If no match found:
  ;   de = ca
  ;   hl = 0
  exx
  ld e,default_bank
  call bank.e ; page the default memory bank
  exx
  pop bc ; restore the Forth IP
  ; _z80_border 4 ; XXX INFORMER
  jp push_hlde

paren_find.not_a_match:
  ; Not a match, try next one.
paren_find.nfa_backup: equ $+1
  ld hl,0 ; nfa
  dec hl ; high address of lfa
  ld d,(hl) ; high part of the next nfa
  dec hl ; low address of lfa
  ld e,(hl) ; low part of the next nfa
  ld a,d
  or e ; end of dictionary? (next nfa=0)
  jp nz,paren_find.begin ; if not, continue
  ; End of dictionary, no match found, return.
  ld de,(paren_find.string_address)
  ld hl,0
  jp paren_find.end

; ----------------------------------------------
  _code_header scan_,'SCAN'

; doc{
;
; scan  ( ca c -- ca len )
;
; c = ascii delimiting character
; ca = text address
; len = length of the parsed text
;
; }doc

  pop hl ; delimiter
  pop de ; address
  push de
  push bc ; save Forth IP
  ld c,l ; delimiter
  ld hl,0 ; length
  dec hl
  dec de
scan.begin:
  inc hl
  inc de
  ld a,(de)
  cp c ; delimiter?
  jr nz,scan.begin
  ; delimiter found
  pop bc ; restore Forth IP
  jp push_hl

; ----------------------------------------------
  _code_header skip_,'SKIP'

; doc{
;
; skip  ( ca1 c -- ca2 )
;
; }doc

  pop de ; e = delimiter
  pop hl ; ca1
skip.begin:
  ld a,(hl)
  cp e ; delimiter?
  jp nz,push_hl
  inc hl
  jp skip.begin ; again

; ----------------------------------------------
  _code_header chan_,'CHAN'

; doc{
;
; chan  ( n -- )  \ Open channel n for output.
;
; }doc
;
; [Code from Spectrum Forth-83.]

  pop hl
  push bc
  ld a,l
  call rom_chan_open
  pop bc
  _jp_next

; ----------------------------------------------
  _colon_header emit_,'EMIT'

; XXX TODO -- Add multitasker's `pause` when available.
; XXX TODO -- defer

  dw paren_emit_
  dw one_,out_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header paren_emit_,'(EMIT)'

; doc{
;
; (emit)  ( b -- )
;
; Send the character b to the current channel.
;
; }doc

; [Code from Spectrum Forth-83's `TOCH`.]

if 0 ; latin1_charset_in_bank
  ld e,names_bank
  call bank.e ; the charset is in the memory bank
endif
  pop hl
  ld a,l
  ld (iy+sys_scr_ct_offset),0xFF ; no scroll message
  rst 0x10
if 0 ; latin1_charset_in_bank
  ld e,default_bank
  call bank.e
endif
  _jp_next

; ----------------------------------------------
  _colon_header printer_,'PRINTER'

  _literal 3
  dw chan_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header display_,'DISPLAY'

  dw two_
  dw chan_
  dw semicolon_s_

; ----------------------------------------------
  _code_header key_question_,'KEY?'

; doc{
;
; key?  ( -- f )  \ ANS Forth
;
; }doc

  ld a,(sys_last_k)
  and a
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _variable_header decode_table_,'DECODE-TABLE'

  dw 0 ; no chained table ; XXX TODO
              ; Symbol Shift + Letter --> new char
  db 0xC6,'[' ; "Y" 198 (0xC6) "AND"  --> 091 (0x5B) "["
  db 0xC5,']' ; "U" 197 (0xC5) "OR"   --> 093 (0x5D) "]"
  db 0xE2,'~' ; "A" 226 (0xE2) "STOP" --> 126 (0x7E) "~"
  db 0xC3,'|' ; "S" 195 (0xC3) "NOT"  --> 124 (0x7C) "|"
  db 0xCD,'\' ; "D" 205 (0xCD) "STEP" --> 092 (0x5C) "\"
  db 0xCC,'{' ; "F" 204 (0xCC) "TO"   --> 123 (0x7B) "{"
  db 0xCB,'}' ; "G" 203 (0xCB) "THEN" --> 125 (0x7D) "}"
  db 0 ; end of data

  ; "I" 172 (0xAC) "AT"   --> 127 (0x7F) "(C)" ; XXX TODO

; ----------------------------------------------
  _code_header decode_char_,'DECODE-CHAR'
  
; doc{
;
; decode-char  ( c1 -- c2 )
;
; }doc

  ; XXX TODO

  pop de
  ld hl,decode_table_+2 ; XXX TMP
decode_char.begin:
  ld a,(hl)
  and a
  ld a,e

; ----------------------------------------------
  _code_header paren_key_,'(KEY)'

  ld a,(sys_last_k)
  ld (previous_key),a
paren_key_.begin:
  ; call pause ; XXX TODO
  ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ld a,(sys_last_k)
previous_key: equ $+1
  cp 0 ; a different key?
  jp z,paren_key_.begin
  ld h,0
  ld l,a
  xor a
  ld (sys_last_k),a ; delete the last key
  push hl
  jp decode_char_

; ----------------------------------------------
  _code_header key_,'KEY'

; doc{
;
; key  ( -- c )  \ ANS Forth
;
; }doc

; XXX -- This version works also when the system interrupts are off.
; XXX TODO -- Add multitasker's `pause` when available.

  push bc
key.begin:
  call rom_key_scan
  jr nz,key.begin
  call rom_key_test
  jr nc,key.begin
  dec d
  ld e,a
  call rom_key_decode
key.end:
  ld hl,sys_last_k
  ld (hl),0
  pop bc
  jp push_a

; ----------------------------------------------
  _code_header xkey_,'XKEY'

; XXX OLD -- this is the original code from Abersoft Forth.
; Too complex. A mode-less version will be coded.

; doc{
;
; xkey  ( -- c )
;
; Leave the ASCII value of the next terminal key struck.
;
; }doc

  ; XXX TODO simplify, no Spectrum modes

  push bc

  ; XXX OLD
  ; inverse video on
  ; ld a,inverse_char
  ; rst 0x10
  ; ld a,0x01
  ; rst 0x10

xkey.new_key:
  xor a
  ld (sys_last_k),a

  ; Print cursor:
  ld a,0x88 ; cursor
  rst 0x10
  ld a,backspace_char
  rst 0x10

xkey.wait_for_key:
  ld a,(sys_last_k)
  and a
  jr z,xkey.wait_for_key
  ; a = pressed key code

  cp caps_char ; toggle caps lock?
  jr nz,xkey.translate
  ; toggle caps lock
  ld hl,sys_flags2
  ld a,0x08
  xor (hl)
  ld (hl),a
  jr xkey.new_key

  ; Translate some chars
  ; XXX TODO use a configurable list of chars pairs

xkey.translate:
xkey.left_bracket:
  cp 0xC6
  jr nz,xkey.right_bracket
  ld a,'['
xkey.right_bracket:
  cp 0xC5
  jr nz,xkey.tilde
  ld a,']'
xkey.tilde:
  cp 0xE2
  jr nz,xkey.vertical_bar
  ld a,'~'
xkey.vertical_bar:
  cp 0xC3
  jr nz,xkey.backslash
  ld a,'|'
xkey.backslash:
  cp 0xCD
  jr nz,xkey.left_curly_bracket
  ld a,'\'
xkey.left_curly_bracket:
  cp 0xCC
  jr nz,xkey.right_curly_bracket
  ld a,'{'
xkey.right_curly_bracket:
  cp 0xCB
  jr nz,xkey.end
  ld a,'}'

xkey.end:
  ld l,a
  ld h,0x00

  ; XXX OLD
  ; inverse video off
  ; ld a,inverse_char
  ; rst 0x10
  ; ld a,0x00
  ; rst 0x10

  ; delete the cursor
  ld a,space_char
  rst 0x10
  ld a,backspace_char
  rst 0x10

  pop bc
  jp push_hl

; ----------------------------------------------
  _colon_header cr_,'CR'

; doc{
;
; cr  ( -- )
;
; Transmit a carriage return to the selected output device.
;
; }doc

  _literal carriage_return_char
  dw emit_,out_,off_
  dw semicolon_s_

; ----------------------------------------------
  _code_header cmove_up_,'CMOVE>'

  exx
  pop bc
  pop de
  pop hl
  call move_block_downwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header cmove_,'CMOVE'

  exx
  pop bc
  pop de
  pop hl
  call move_block_upwards
  exx
  _jp_next

; ----------------------------------------------
  _code_header move_,'MOVE'

; doc{
;
; move  ( a1 a2 len -- )
;
; }doc

  exx
  pop bc
  pop de
move.do:
  pop hl
  call move_block
  exx
  _jp_next

; ----------------------------------------------
  _code_header smove_,'SMOVE'

; doc{
;
; smove  ( a1 len a2 -- )
; 
; Move the string _a1 len_ to _a2_. _a2_ will contain the first
; char of the string.
;
; }doc

; swap move

  exx
  pop de
  pop bc
  jp move.do

; ----------------------------------------------
  _code_header u_m_star_,'UM*'

; doc{
;
; um*  ( u1 u2 -- ud )  \ ANS Forth
;
; Multiply _u1_ by _u2_, giving the unsigned double-cell product
; _ud_.  All values and arithmetic are unsigned.
;
; }doc

  ; [Code from DZX-Forth.]

  pop de
  pop hl
  call hl_multiplied_by_de_to_hlde_unsigned
  jp push_hlde

; ----------------------------------------------
  _code_header u_slash_mod_,'U/MOD' ; XXX OLD

; doc{
;
; u/mod ( ud u1 -- u2 u3 )
;
; Divide _ud_ by _u1_, giving the quotient _u3_ and the
; remainder _u2_.  All values and arithmetic are unsigned. An
; ambiguous condition exists if u1 is zero or if the quotient
; lies outside the range of a single-cell unsigned integer.
;
; }doc

; XXX FIXME -- This word, whose code is taken from Abersoft
; forth, has a bug that affects `(line)`, used by `message`, and
; other words that use it: `*/mod`, `mod` and `/mod`, with
; certain negative values, return different values in Abersoft
; Forth and other Forth systems that have been tested (some of
; them are fig-Forth).

  ld hl,0x0004
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  ld a,l
  sub c
  ld a,h
  sbc a,b
  jr c,l60a0h
  ld hl,0xFFFF
  ld de,0xFFFF
  jr l60c0h
l60a0h:
  ld a,0x10
l60a2h:
  add hl,hl
  rla
  ex de,hl
  add hl,hl
  jr nc,l60aah
  inc de
  and a
l60aah:
  ex de,hl
  rra
  push af
  jr nc,l60b4h
  and l
  sbc hl,bc
  jr l60bbh
l60b4h:
  and a
  sbc hl,bc
  jr nc,l60bbh
  add hl,bc
  dec de
l60bbh:
  inc de
  pop af
  dec a
  jr nz,l60a2h
l60c0h:
  pop bc
  push hl
  push de
  _jp_next

if 0 ; XXX TODO

; ----------------------------------------------
  _code_header s_m_slash_rem_,'SM/REM'

; doc{
;
; sm/rem  ( d1 n1 -- n2 n3 )  \ ANS Forth,  "s-m-slash-rem"
;
; Symmetric division:
;
;   d1 = n3*n1+n2, sign(n2)=sign(d1) or 0.
;
; Divide _d1_ by _n1_, giving the symmetric quotient _n3_ and
; the remainder _n2_. Input and output stack arguments are
; signed.
;
; }doc

; XXX TODO check: An ambiguous condition exists if n1 is zero or
; if the quotient lies outside the range of a single-cell signed
; integer.

; [Code from DZX-Forth.]

  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
s_m_slash_rem_.1:
  call msm
  jp msm.2

; ----------------------------------------------
  _code_header fm_slash_mod_,'FM/MOD'

; doc{
;
; fm/mod  ( d1 n1 -- n2 n3 )  \ ANS Forth,  "f-m-slash-mod"
;
; Floored division:
;
;   d1 = n3*n1+n2, n1>n2>=0 or 0>=n2>n1.
;
; Divide _d1_ by _n1_, giving the floored quotient _n3_ and
; the remainder _n2_. Input and output stack arguments are
; signed.
;
; }doc

; XXX TODO check: An ambiguous condition exists if n1 is zero or
; if the quotient lies outside the range of a single-cell signed
; integer.

; [Code from DZX-Forth.]

  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
fm_slash_mod.1:
  call msm
  ld a,d
  or e
  jp z,msm.2    ; skip if remainder = 0
  dec hl    ; floor
  push hl
  ex de,hl
  add hl,bc
  ex de,hl
  pop hl
  jp msm.2

endif

; ----------------------------------------------
  _code_header and_,'AND'

  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header or_,'OR'

  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _code_header xor_,'XOR'

  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp push_hl

; ----------------------------------------------
  _constant_header np_,'NP'

  dw names_pointer

; ----------------------------------------------
  _constant_header np0_,'NP0'

  dw names_bank_address

; ----------------------------------------------
  _code_header np_fetch_,'NP@'

  ld hl,(names_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header np_store_,'NP!'

  pop hl
  ld (names_pointer),hl
  _jp_next

; ----------------------------------------------

  _colon_header comma_np_,',NP'

; doc{
;
; ,np  ( x -- )
;
; Store _x_ into the next available names memory cell, advancing
; the names pointer.
;
; Note: The names memory is supposed to be paged in.
;
; }doc

  dw np_fetch_,store_,two_,np_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header sp_fetch_,'SP@'

  ld hl,0x0000
  add hl,sp
  jp push_hl

; ----------------------------------------------
  _code_header sp_store_,'SP!'

; doc{
;
; sp!  ( a -- )
;
; Store _a_ into the stack pointer.
;
; }doc

  pop hl
  ld sp,hl
  _jp_next

; ----------------------------------------------
  _constant_header rp_,'RP'

  dw return_stack_pointer

; ----------------------------------------------
  _code_header rp_fetch_,'RP@'

  ld hl,(return_stack_pointer)
  jp push_hl

; ----------------------------------------------
  _code_header rp_store_,'RP!'

; doc{
;
; rp!  ( a -- )
;
; Store _a_ into the return stack pointer.
;
; }doc

  pop hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
if 1 ; fig_exit?
  _code_header semicolon_s_,';S'
else
  _code_header exit_,'EXIT'
  semicolon_s_ equ exit_
endif


; doc{
;
; ;s  ( -- )  \ fig-Forth
;
; Return execution to the calling definition.  Unnest one level.
;
; It is used to stop interpretation of a screen. It is also the
; run-time word compiled at the end of a colon-definition which
; returns execution to the calling procedure.
;
; }doc

; XXX TODO combine this `;s` with `exit`?

  ld hl,(return_stack_pointer)
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header pick_,'PICK'

  pop hl
  add hl,hl
  add hl,sp
  jp fetch.hl

; ----------------------------------------------
  _code_alias_header unloop_,'UNLOOP',,two_r_drop_

; doc{
;
; unloop  ( -- ) ( R: x1 x2 -- )  \ ANS Forth, C
;
; x1 = loop index
; x2 = loop limit
;
; Discard the loop-control parameters for the current nesting
; level. An `unloop` is required for each nesting level before
; the definition may be exited with `exit`. An ambiguous
; condition exists if the loop-control parameters are
; unavailable.
;
; }doc

; ----------------------------------------------
  _code_header exhaust_,'EXHAUST'

; doc{
;
; exhaust  ( -- ) ( R: n1 n2 -- n2 n2 )
;
; n1 = loop limit
; n2 = loop index
;
; Force termination of a do-loop at the next opportunity by
; setting the loop limit equal to the current value of the
; index. The index itself remains unchanged, and execution
; proceeds normally until `loop` or `+loop` is encountered.
;
; Note: This is the equivalent of fig-Forth's `leave`.
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header question_exhaust_,'?EXHAUST'

; doc{
;
; ?exhaust  ( f -- ) ( R: n1 n2 -- n1 n2 | n2 n2 )
;
; n1 = loop limit
; n2 = loop index
; 
; If _f_ is not false, force termination of a do-loop at the
; next opportunity by setting the loop limit equal to the
; current value of the index. The index itself remains
; unchanged, and execution proceeds normally until `loop` or
; `+loop` is encountered.
;
; }doc

  pop hl
  ld h,a
  or l
  jp nz,exhaust_pfa
  _jp_next

; ----------------------------------------------
  _code_header to_r_,'>R'

; doc{
;
; >r  ( x -- ) ( R: -- x )
;
; }doc

  pop de
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header from_r_,'R>'

; doc{
;
; r>  ( -- x ) ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  _jp_next

; ----------------------------------------------
  _code_header two_r_drop_,'2RDROP'

; doc{
;
; 2rdrop  ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header r_drop_,'RDROP'

; doc{
;
; rdrop  ( R: x -- )
;
; }doc

  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  _jp_next

; ----------------------------------------------
  _code_header two_to_r_,'2>R'

; doc{
;
; 2>r  ( -- x1 x2 ) ( R: x1 x2 -- )
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.into_hl_pointer

; ----------------------------------------------
  _code_header two_from_r_,'2R>'

; 2r>  ( -- x1 x2 ) ( R: x1 x2 -- )

  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_pfa

; ----------------------------------------------
  _code_header two_r_fetch_,'2R@'

  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; ----------------------------------------------
  _code_header r_fetch_,'R@'

  ld hl,(return_stack_pointer)
  jp fetch.hl

; ----------------------------------------------
  _code_header zero_equals_,'0='

  pop hl
  ld a,l
  or h
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_not_equals_,'0<>'

  pop hl
  ld a,l
  or h
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header zero_less_than_,'0<'

  pop hl
zero_less_.hl: ; XXX entry not used yet
  if size_optimization
    add hl,hl ; 11t, 1 byte
  else
    ; [Idea from Ace Forth.]
    rl h ; 8t, 2 bytes
  endif
true_if_cy:
  jp c,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header zero_greater_than_,'0>'

  ; [Code from DZX-Forth.]

  pop de
  ld hl,0
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header plus_,'+'

  pop de
  pop hl
  add hl,de
  jp push_hl

; ----------------------------------------------
  _code_header d_plus_,'D+'

  ; [Code from Abersoft Forth.]

                ;  t  B
                ;  -- --
  ld hl,0x0006  ;  10 03
  add hl,sp     ;  11 01
  ld e,(hl)     ;  07 01
  ld (hl),c     ;  07 01
  inc hl        ;  06 01
  ld d,(hl)     ;  07 01
  ld (hl),b     ;  07 01
  pop bc        ;  10 01
  pop hl        ;  10 01
  add hl,de     ;  11 01
  ex de,hl      ;  04 01
  pop hl        ;  10 01
  adc hl,bc     ;  15 01
  pop bc        ;  10 01
  jp push_hlde  ;  10 03
                ;  11    ; push de
                ;  11    ; push hl
                ; --- --
                ; 157 19 TOTALS

if 0

; [Code from fig-Forth 1.1g.]
 
  ; XXX FIXME
  ;
  ; This code fails.  The calculation `0 0 0 1 d+` should leave
  ; `0 1` on the stack, but it leaves `0 65535`.
   
              ;                           t  B
              ;                           -- --
  exx         ; save ip                   04 01
  pop bc      ; (bc)<--d2h                10 01
  pop hl      ; (hl)<--d2l                10 01
  pop af      ; (af)<--d1h                10 01
  pop de      ; (de)<--d1l                10 01
  push  af    ; (s1)<--d1h                11 01
  add hl,de   ; (hl)<--d2l+d1l=d3l        11 01
  ex  de,hl   ; (de)<--d3l                04 01
  pop hl      ; (hl)<--d1h                10 01
  adc hl,bc   ; (hl)<--d1h+d2h+carry=d3h  15 02
  push  de    ; (s2)<--d3l                11 01
  push  hl    ; (s1)<--d3h                11 01
  exx         ; restore ip                04 01
  jp_next     ;                           08 02
              ;                          --- --
              ;                          134 15 TOTALS
endif

; ----------------------------------------------
  _code_header negate_,'NEGATE'

  pop de
  ld hl,0x0000
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header dnegate_,'DNEGATE'

  pop hl
  pop de
  sub a
  sub e
  ld e,a
  ld a,0x00
  sbc a,d
  ld d,a
  ld a,0x00
  sbc a,l
  ld l,a
  ld a,0x00
  sbc a,h
  ld h,a
  jp push_hlde

; ----------------------------------------------
  _code_header nip_,'NIP'

  pop hl
  pop de
  jp push_hl

; ----------------------------------------------
  _code_header tuck_,'TUCK'

  pop hl
  pop de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header over_,'OVER'

  pop de
  pop hl
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header drop_,'DROP'

  pop hl
  _jp_next

; ----------------------------------------------
  _code_header swap_,'SWAP'

  pop hl
  ex (sp),hl
  jp push_hl

; ----------------------------------------------
  _code_header dup_,'DUP'

  pop hl
  push hl
  jp push_hl

; ----------------------------------------------
  _code_header two_dup_,'2DUP'

  pop hl
  pop de
  push de
  push hl
  jp push_hlde

; ----------------------------------------------
  _code_header plus_store_,'+!'

  pop hl ; variable address
  pop de ; number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header off_,'OFF'

  pop hl
  ld (hl),0
  inc hl
  ld (hl),0
  _jp_next

; ----------------------------------------------
  _code_header on_,'ON'

  pop hl
if true=1
  ld (hl),1
  inc hl
  ld (hl),0
else
  ld (hl),0xFF
  inc hl
  ld (hl),0xFF
endif
  _jp_next

; ----------------------------------------------
  _code_header toggle_,'TOGGLE'

; doc{
;
; toggle  ( a b -- )  \ fig-Forth
;
; Complement the contents of _a_ by the bit pattern _b_.
;
; }doc

  pop de ; e = bit pattern
  pop hl ; address
  ld a,(hl)
  xor e
  ld (hl),a
  _jp_next

; ----------------------------------------------
  _code_header fetch_,'@'

  pop hl
fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  _jp_next

; ----------------------------------------------
  _code_header c_fetch_,'C@'

  pop hl
  ld l,(hl)
  ld h,0x00
  jp push_hl

; ----------------------------------------------
  _code_header two_fetch_,'2@'

  pop hl ; address
two_fetch.hl:
  ld e,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld d,(hl)     ; 07t  1 ; de = low part
  inc hl        ; 06t  1
  ld a,(hl)     ; 07t  1
  inc hl        ; 06t  1
  ld h,(hl)     ; 07t  1
  ld l,a        ; 04t  1 ; hl = high part
  ex de,hl      ; 04t  1
  jp push_hlde ; 10t  3
                ; 11t  0 push de
                ; 11t  0 push hl
                ; 86t 12 TOTAL

; ----------------------------------------------
  _code_header two_store_,'2!'

  pop hl
two_store.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  if size_optimization
    jp store.into_hl_pointer
  else
    pop de
    ld (hl),e
    inc hl
    ld (hl),d
    _jp_next
  endif

; ----------------------------------------------
  _code_header store_,'!'

  pop hl
store.into_hl_pointer:
  pop de
store.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  _jp_next

; ----------------------------------------------
  _code_header c_store_,'C!'

  pop hl
  pop de
  ld (hl),e
  _jp_next

; ----------------------------------------------
  _colon_header colon_,':',immediate

  dw question_exec_
  dw store_csp_
  dw header_,right_bracket_
  dw paren_semicolon_code_
do_colon:
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl ; save the updated IP
  inc de ; de=pfa
  ld c,e
  ld b,d ; bc=pfa
do_colon_end: ; XXX TMP for debugging
  _jp_next

; ----------------------------------------------
  _colon_header noname_,':NONAME',immediate

  ; [Code from the Afera library.]

  ; XXX TODO move to the disk? problem: do_colon

  dw question_exec_
  dw smudge_  ; deactivate the effect of the next `smudge` in `;`
  dw here_ ; cfa
  dw store_csp_
  dw lit_,do_colon,comma_ ; create the code field
  dw right_bracket_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_,';',immediate

  dw question_csp_
  dw compile_,semicolon_s_
  dw smudge_
  dw left_bracket_
  dw semicolon_s_

; ----------------------------------------------
  _header noop_,'NOOP'

; doc{
;
; noop  ( -- )
;
; }doc

  dw next ; code field

; ----------------------------------------------
  _colon_header constant_,'CONSTANT'

  dw create_,comma_
  dw paren_semicolon_code_
do_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp fetch.hl

; ----------------------------------------------
  _colon_header variable_,'VARIABLE'

; doc{
;
; variable ( "name" -- )  \ ANS Forth
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve one cell of data
; space.
;
;    _name_ is referred to as a variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the reserved cell. A program is
;    responsible for initializing the contents of the reserved
;    cell.
;
; }doc

  dw create_,cell_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header user_,'USER'

  ; XXX TODO -- Use only one byte for storage,
  ; but defining `cconstant` only for this does not seem a good idea.

  dw constant_
  dw paren_semicolon_code_
do_user:
;  _z80_border_wait 5 ; XXX INFORMER
  inc de      ; de=pfa
  ex de,hl
  ld e,(hl)
  ld d,0x00   ; de = index of the user variable
  ld hl,(user_variables_pointer)
  add hl,de   ; hl= address of the user variable
;  _z80_border_wait 6 ; XXX INFORMER
  jp push_hl

; ----------------------------------------------
  _constant_header msg_scr_,'MSG-SCR'

; doc{
;
; msg-scr  ( -- n )
;
; Constant: Screen where the error messages start.
;
; }doc

; Idea taken from lina ciforth.

  dw 0x0004

; ----------------------------------------------
  _constant_header zero_,'0'

  dw 0x0000

; ----------------------------------------------
  _constant_header one_,'1'

  dw 0x0001

; ----------------------------------------------
  _constant_header two_,'2'

  dw 0x0002

; ----------------------------------------------
  _code_header false_,'FALSE'

; doc{
;
; false  ( -- f )
;
; }doc

  ld hl,false
  jp push_hl

; ----------------------------------------------
  _code_header true_,'TRUE'

; doc{
;
; true  ( -- t )
;
; }doc

  ld hl,true
  jp push_hl

; ----------------------------------------------
  _constant_header b_l_,'BL'

; doc{
;
; bl  ( -- n )
;
; }doc

  dw space_char

; ----------------------------------------------
  _constant_header c_slash_l_,'C/L'

  dw characters_per_line

; ----------------------------------------------
  _constant_header l_slash_scr_,'L/SCR'

  dw lines_per_screen

; ----------------------------------------------
  _constant_header disk_buffer_,'DISK-BUFFER'

  dw disk_buffer

; ----------------------------------------------
  _constant_header b_slash_buf_,'B/BUF'

  dw data_bytes_per_buffer

; ----------------------------------------------
  _constant_header b_slash_scr_,'B/SCR'

  dw blocks_per_screen

; ----------------------------------------------
  _constant_header scr_slash_disk_,'SCR/DISK'

  dw screens_per_disk

; ----------------------------------------------
  _constant_header hash_vocs_,'#VOCS'

  dw max_search_order

; ----------------------------------------------
  _colon_header plus_origin_,'+ORIGIN'

; doc{
;
; +origin  ( n -- a )  \ fig-Forth
;
; Leave the memory address relative by _n_ to the origin
; parameter area.  _n_ is the minimum address unit, either byte
; or word.  This definition is used to access or modify the
; boot-up parameters at the origin area.
;
; }doc

  dw lit_,origin,plus_
  dw semicolon_s_

; ----------------------------------------------
  _user_variable_header sp0_,'SP0'

  db 0x00

; ----------------------------------------------
  _user_variable_header rp0_,'RP0'

  db 0x02

; ----------------------------------------------
  _user_variable_header width_,'WIDTH'

  ; XXX TODO normal variable

  db 0x06

; ----------------------------------------------
  _user_variable_header warning_,'WARNING'

  db 0x08

; ----------------------------------------------
  _variable_header dp_,'DP'

dictionary_pointer:
  dw dictionary_pointer_after_cold
dictionary_pointer_init_value:
  dw dictionary_pointer_after_cold

; ----------------------------------------------
  _variable_header voc_link_,'VOC-LINK'

  dw assembler_vocabulary_link ; link to the latest vocabulary defined

; ----------------------------------------------
  _user_variable_header blk_,'BLK'

  ; XXX TODO normal variable

  db 0x10

; ----------------------------------------------
  _user_variable_header to_in_,'>IN'

  ; XXX TODO normal variable

  db 0x12

; ----------------------------------------------
  _user_variable_header out_,'OUT'

  ; XXX TODO In Forth 83 it's a user variable too, but it's called `#out`.
  ; XXX TODO rename to `#emitted`
  db 0x14

; ----------------------------------------------
  _user_variable_header scr_,'SCR' ; XXX OLD -- used by `list`

  db 0x16

; ----------------------------------------------
  _user_variable_header context_,'CONTEXT'

  db 0x2A

; ----------------------------------------------
  _user_variable_header current_,'CURRENT'

  db 0x1C

; ----------------------------------------------
  _user_variable_header state_,'STATE'

  db 0x1E

; ----------------------------------------------
  _user_variable_header base_,'BASE'

  db 0x20

; ----------------------------------------------
  _user_variable_header dpl_,'DPL'

  db 0x22

; ----------------------------------------------
  _user_variable_header fld_,'FLD'

  db 0x24

; ----------------------------------------------
  _user_variable_header csp_,'CSP'

  db 0x26

; ----------------------------------------------
  _user_variable_header r_hash_,'R#'

  ; XXX OLD
  db 0x28

; ----------------------------------------------
  _user_variable_header hld_,'HLD'

  db 0x1A

; ----------------------------------------------
  _constant_header tib_,'TIB'

; doc{
;
; tib  ( -- ca )  \ ANS-Forth
;
; Address of the terminal input buffer.
;
; }doc

  dw terminal_input_buffer

; ----------------------------------------------
  _variable_header number_tib_,'#TIB'

  dw bytes_per_terminal_input_buffer

; ----------------------------------------------
  _colon_header recurse_,'RECURSE',immediate

; doc{
;
; recurse  ( -- )  \ ANS Forth
;
; }doc

  dw latest_,nfa_to_cfa_,compile_comma_
  dw semicolon_s_

; ----------------------------------------------
  _code_header one_plus_,'1+'

  pop hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_header two_plus_,'2+'

  pop hl
  inc hl
  inc hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cell_minus_,'CELL-',,two_minus_

; ----------------------------------------------
  _code_alias_header cell_plus_,'CELL+',,two_plus_

; ----------------------------------------------
  _code_header one_minus_,'1-'

  pop hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_minus_,'2-'

  pop hl
  dec hl
  dec hl
  jp push_hl

; ----------------------------------------------
  _code_header two_star_,'2*'

; doc{
;
; 2*  ( x1 -- x2 )  \ ANS Forth
;
; _x2_ is the result of shifting _x1_ one bit toward the
; most-significant bit, filling the vacated least-significant
; bit with zero.
;
; This is the same as `1 lshift`.
;
; }doc

  ; [Code from DZX-Forth. Documentation partly based on lina
  ; ciforth.]

  pop hl
  add hl,hl
  jp push_hl

; ----------------------------------------------
  _code_alias_header cells_,'CELLS',,two_star_

; ----------------------------------------------
  _constant_header cell_,'CELL'

  dw 0x0002

; ----------------------------------------------
  _code_header two_slash_,'2/'

; doc{
;
; 2/  ( x1 -- x2 )  \ ANS Forth
;
; _x2_ is the result of shifting _x1_ one bit toward the
; least-significant bit, leaving the most-significant bit
; unchanged.
;
; This is the same as `s>d 2 fm/mod swap drop`. It is not the same
; as `2 /`, nor is it the same as `1 rshift`.
;
; }doc

  ; [Code from Spectrum Forth-83. Documentation partly based on lina
  ; ciforth.]

  pop hl
  sra h
  rr l
  jp push_hl

; ----------------------------------------------
  _colon_header here_,'HERE'

  dw dp_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header allot_,'ALLOT'

  dw dp_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_comma_,'s,'

; doc{
; s,  ( ca len -- )
; }doc

  dw dup_,c_comma_,tuck_,here_,swap_,cmove_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comma_,','

  dw here_,store_,two_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header compile_comma_,'COMPILE,'

; doc{
;
; compile,  ( cfa -- )
;
; }doc

  dw question_comp_,comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_comma_,'C,'

  dw here_,c_store_,one_,allot_
  dw semicolon_s_

; ----------------------------------------------
  _code_header minus_,'-'

  pop de
  pop hl
  and a
  sbc hl,de
  jp push_hl

; ----------------------------------------------
  _code_header not_equals_,'<>'

  pop de
  pop hl
  call compare_de_hl_unsigned
false_if_z: ; XXX entry not used yet
  jp z,false_pfa
  jp true_pfa

; ----------------------------------------------
  _code_header equals_,'='

  pop de
  pop hl
  call compare_de_hl_unsigned
true_if_z: ; XXX entry not used yet
  jp z,true_pfa
  jp false_pfa

; ----------------------------------------------
  _code_header less_than_,'<'

  pop de
  pop hl
is_de_less_than_hl:
  call compare_de_hl_signed
  if size_optimization
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

; ----------------------------------------------
  _code_header u_greater_than_,'U>'

  pop hl
u_greater_than.hl:
  pop de
  jp u_less_than.de_hl

; ----------------------------------------------
  _code_header u_less_than_,'U<'

  pop de
  pop hl
u_less_than.de_hl:
  call compare_de_hl_unsigned
  if size_optimization
    jp true_if_cy
  else
    jp c,true_pfa
    jp false_pfa
  endif

; ----------------------------------------------
  _code_header greater_than_,'>'

  pop hl
  pop de
  jp is_de_less_than_hl

; ----------------------------------------------
  _code_header rot_,'ROT'

  pop de
  pop hl
  ex (sp),hl
  jp push_hlde

; ----------------------------------------------
  _colon_header space_,'SPACE'

  dw b_l_,emit_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_dup_,'?DUP'

  dw dup_
  dw zero_branch_,question_dup.end
  dw dup_
question_dup.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_alias_header lfa_to_nfa_,'LFA>NFA',,two_plus_

; ----------------------------------------------
  _colon_header trail_,'TRAIL'

; doc{
;
; trail ( -- nfa )
;
; Leave the name field address of the topmost word in the
; `context` vocabulary.
;
; }doc

  dw context_,fetch_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header latest_,'LATEST'

; doc{
;
; latest ( -- nfa )  \ ANS Forth
;
; Leave the name field address of the topmost word in the
; `current` vocabulary.
;
; }doc

  dw current_,fetch_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pfa_to_lfa_,'PFA>LFA'

  dw pfa_to_cfa_,cfa_to_nfa_

; ----------------------------------------------
  _code_alias_header pfa_to_cfa_,'PFA>CFA',,two_minus_

; ----------------------------------------------
  _code_alias_header cfa_to_pfa_,'CFA>PFA',,two_plus_

; ----------------------------------------------
  _colon_header pfa_to_nfa_,'PFA>NFA'

  dw pfa_to_cfa_,cfa_to_nfa_
  dw semicolon_s_

; ----------------------------------------------

; doc{
;
; cfa>nfa  ( cfa -- nfa )
;
; Warning: No check is done where cfa belongs to a definition
; created with `:noname`.
;
; }doc

; XXX FIXME -- make it return 0 if cfa has no name associated

  _code_header cfa_to_nfa_,'CFA>NFA'

  ld e,names_bank
  call bank.e ; page the memory bank
  pop de ; cfa
  push bc ; save Forth IP
  ld b,0
  ld hl, names_bank_address-4

cfa_to_nfa.begin_0:
  ; hl = address of the cfa pointer
  inc hl
cfa_to_nfa.begin_1:
  inc hl
  inc hl
  inc hl
  ld a,(hl) ; name field byte length
  and max_word_length_mask ; name length
  ld c,a ; name length
  inc c  ; plus the length byte
  add hl,bc ; point to the cfa pointer

  ld a,(hl) ; low byte of cfa
  cp e ; equal?
  jr nz,cfa_to_nfa.begin_0 ; not equal
  inc hl
  ld a,(hl) ; high byte of cfa
  cp d ; equal?
  jr nz,cfa_to_nfa.begin_1 ; not equal
  ; cfa found
  ld c,3
  add hl,bc ; nfa

  ld e,default_bank
  call bank.e ; page the default memory bank

  pop bc ; restore Forth IP
  jp push_hl

; ----------------------------------------------

  _code_alias_header cfap_to_lfa_,'CFAP>LFA',,two_plus_

; ----------------------------------------------

  _code_alias_header nfa_to_lfa_,'NFA>LFA',,two_minus_

; ----------------------------------------------
  _colon_header c_store_bank_,'C!BANK'

; doc{
;
; c!bank  ( b a n -- )
;
; Store _b_ into address _a_ of bank _n_.
;
; }doc

  ; XXX 11 bytes
  dw bank_,c_store_
  _default_bank
  dw semicolon_s_

  ; XXX TODO
  ; pop de
  ; c_store_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; ld e,default_bank
  ; call bank.e
  ; jp pushhl

; ----------------------------------------------
  _colon_header store_bank_,'!BANK'

; doc{
;
; !bank  ( x a n -- )
;
; Store _x_ into address _a_ of bank _n_.
;
; }doc

  ; XXX 11 bytes
  dw bank_,store_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_fetch_bank_,'C@BANK'

; doc{
;
; c@bank  ( a n -- b )
;
; Fetch the 8-bit content of address _a_ of the bank _n_.
;
; }doc

  ; XXX 11 bytes
  dw bank_,c_fetch_
  _default_bank
  dw semicolon_s_

  ; XXX 15 bytes
  ; pop de
  ; c_fetch_bank.e:
  ; call bank.e
  ; pop hl
  ; ld l,(hl)
  ; ld h,0
  ; ld e,default_bank
  ; call bank.e
  ; jp pushhl

; ----------------------------------------------
  _colon_header fetch_bank_,'@BANK'

; doc{
;
; @bank  ( a n -- x )
;
; Fetch the 16-bit content of address _a_ of bank _n_.
;
; }doc

  ; XXX 11 bytes
  dw bank_,fetch_
  _default_bank
  dw semicolon_s_

  ; XXX 17 bytes
  ; pop de
  ; fetch_bank.e
  ; call bank.e
  ; pop hl
  ; ld a,(hl)
  ; inc hl
  ; ld h,(hl)
  ; ld l,a
  ; ld e,default_bank
  ; call bank.e
  ; jp pushhl

; ----------------------------------------------
  _colon_header c_fetch_n_,'C@N'

; doc{
;
; c@n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw c_fetch_bank_
  dw semicolon_s_

  ; XXX 5 bytes
  ; ld e,names_bank
  ; jp c_fetch_bank.e

; ----------------------------------------------
  _colon_header fetch_n_,'@N'

; doc{
;
; @n  ( a -- x )
;
; Fetch from the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw fetch_bank_
  dw semicolon_s_

  ; XXX 5 bytes
  ; ld e,names_bank
  ; jp fetch_bank.e

; ----------------------------------------------
  _colon_header c_store_n_,'C!N'

; doc{
;
; c!n  ( c a -- )
;
; Store _c_ into the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw c_store_bank_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header store_n_,'!N'

; doc{
;
; !n  ( x a -- )
;
; Store _x_ into the _a_ address of the names bank.
;
; }doc

  ; XXX 7 bytes:
  _literal names_bank
  dw store_bank_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header nfa_to_cfa_,'NFA>CFA'

  _literal 4
  dw minus_,fetch_n_
  dw semicolon_s_

; ----------------------------------------------
; doc{
;
; nfa>string  ( nfa -- ca len )
;
; }doc

  _colon_header nfa_to_string_,'NFA>STRING'

  _names_bank
  dw count_
  _literal max_word_length_mask
  dw and_
  dw save_string_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header store_csp_,'!CSP'

  dw sp_fetch_,csp_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_error_,'?ERROR'

  dw swap_
  dw zero_branch_,question_error.no_error
  dw error_
  dw semicolon_s_

question_error.no_error:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header comp_question_,'COMP?'

  dw state_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_comp_,'?COMP'

  dw comp_question_,zero_equals_
  _question_error error.compilation_only
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exec_,'?EXEC'

  dw comp_question_
  _question_error error.execution_only
  dw semicolon_s_

; ----------------------------------------------
if 1
  ; XXX TODO -- remove when the security is removed
  _colon_header question_pairs_,'?PAIRS'

  dw not_equals_
  _question_error error.conditionals_not_paired
  dw semicolon_s_
endif

; ----------------------------------------------
  _colon_header question_csp_,'?CSP'

  dw sp_fetch_,csp_,fetch_,not_equals_
  _question_error error.definition_not_finished
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_loading_,'?LOADING'

  dw blk_,fetch_,zero_equals_
  _question_error error.loading_only
  dw semicolon_s_

; ----------------------------------------------
  _colon_header compile_,'COMPILE'

  dw question_comp_
  dw from_r_,dup_,two_plus_,to_r_,fetch_,compile_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header postpone_,'POSTPONE',immediate

; doc{
;
; postpone ( "name" -- )  \ ANS Forth, C I
;
; Skip leading space delimiters. Parse name delimited by a
; space. Find name. Append the compilation semantics of _name_ to
; the current definition.
;
; }doc

  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  dw dup_,question_defined_ ; error if not found
  dw zero_less_than_ ; non-immediate word?
  dw zero_branch_,postpone.end
  ; Non-immediate word.
  dw compile_,compile_ ; compile `compile`
postpone.end:
  dw compile_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header left_bracket_,'[',immediate

  dw state_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header right_bracket_,']'

  dw state_,on_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header smudge_,'SMUDGE'


; doc{
;
; smudge  ( -- )
;
; Toggle the "smudge bit" in a definitions' name field. This
; prevents an uncompleted definition from being found during
; dictionary searches, until compiling is completed without
; error.
;
; }doc

  dw latest_
  _literal smudge_mask
  ; XXX TODO factor `toggle-names'?
  _names_bank
  dw toggle_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hex_,'HEX'

  _literal 0x10
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header decimal_,'DECIMAL'

  _literal 0x0A
  dw base_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_semicolon_code_,'(;CODE)'

; doc{
;
; (;code)  ( -- )
;
; The run-time procedure compiled by `;code`. Rewrite the code
; field of the most recently defined word to point to the
; following machine code sequence.
;
; }doc

; : (;code)       --
;   r>        \ Pop the address of the next instruction off the return stack,
;             \ which is the starting address of the run-time code routine.
;   latest    \ Get the name field address of the word under construction.
;   nfa>cfa ! \ Find its code field address and store in it the address of
;             \ the code routine to be executed at run-time.
;   ;

  dw from_r_,latest_,nfa_to_cfa_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header semicolon_code_,';CODE',immediate

; XXX TODO -- documentation
; doc{
;
; ;code  ( -- )
;
; Stop compilation and terminate a new defining word by
; compiling the run-time routine `(;code)`.  Assemble the
; assembly mnemonics following.
;
; }doc

  dw question_csp_
  dw compile_,paren_semicolon_code_
  dw asm_
  dw left_bracket_,smudge_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header does_,'DOES>',immediate

  dw compile_,paren_semicolon_code_
  _literal 0xCD ; Z80 opcode for "call"
  dw c_comma_ ; compile it
  dw lit_,do_does,comma_ ; compile the routine address
  dw semicolon_s_

do_does:
  ; Save the IP in the return stack.
  ld hl,(return_stack_pointer)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  ; Pop the address of the run-time routine
  ; (put there bye `call do_does`) in IP.
  pop bc ; new Forth IP
  ; Push the pfa.
  inc de  ; de=pfa
  push de
  ; Execute the run-time routine.
  _jp_next

; ----------------------------------------------
  _code_header count_,'COUNT'

  ; Code from DZX-Forth.

  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; ----------------------------------------------
  _colon_header bounds_,'BOUNDS'

  dw over_,plus_,swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header type_,'TYPE'

  ; XXX TODO Rewrite in Z80, after the ROM routine.

  dw question_dup_
  dw zero_branch_,type.empty_string

  dw bounds_
  dw paren_do_
type.do:
  dw i_,c_fetch_,emit_
  dw paren_loop_,type.do ; loop
  dw semicolon_s_

type.empty_string:
  dw drop_
type.end:
  dw semicolon_s_

; ----------------------------------------------

  _code_header minus_trailing_,'-TRAILING'

  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
  ; de = address after the string
  ; hl = length of the string
minus_trailing.begin:
  ld a,l
  or h ; exhausted?
  jp z,push_hl
  dec de ; next char
  ld a,(de)
  cp ' ' ; space?
  jp nz,push_hl
  dec hl ; new length
  jp minus_trailing.begin ; repeat

; ----------------------------------------------
  _colon_header paren_dot_quote_,'(.")'

  dw r_fetch_,count_ ; ( ca len )
  dw dup_,one_plus_,from_r_,plus_,to_r_ ; skip the string after return
  dw type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_quote_,'."',immediate

  _literal '"'
  dw parse_ ; ( ca len )
  dw comp_question_
  dw zero_branch_,dot_quote.interpreting
  ; Compiling.
  dw compile_,paren_dot_quote_,s_comma_
  dw exit_
dot_quote.interpreting:
  dw type_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header span_,'SPAN'

; doc{
;
; span  ( -- a )  \ Forth-83
;
; The address of a variable containing the count of characters
; actually received and stored by the last execution of
; `expect`.
;
; }doc

  dw 0

; ----------------------------------------------
  _colon_header accept_,'ACCEPT'

; doc{
;
; accept  ( ca1 len1 -- len2 )  \ ANS Forth
;
; }doc

  ; XXX TODO -- not finished

  ; dw span_,off_
  ; dw question_dup_
  ; dw zero_branch_,accept.end

  ; dw swap_ ; ( len ca )
; accept.begin: ; ( len ca )
  ; dw key_,dup_ ; ( len ca c c )

  ; dw c_lit_
  ; db delete_char
  ; dw equals_ ; delete key?
  ; dw zero_branch_,accept.maybe_carriage_return
  ; ; Delete key ( len ca c )
  ; dw drop_
  ; dw dup_,i_,equals_ ; cursor at the start position?
  ; dw dup_ ; ( len ca f f )
  ; ; XXX TODO adapt this when true=-1
  ; dw from_r_,two_minus_,plus_,to_r_ ; update the index
  ; dw question_branch_,accept.loop ; nothing to delete
  ; ; dw b_l_,i_,c_store_ ; update the buffer ; XXX OLD
  ; dw c_lit_
  ; db backspace_char
  ; dw branch_,accept.emit

; accept.maybe_carriage_return: ; ( len ca c )
  ; dw dup_
  ; dw c_lit_
  ; db carriage_return_char
  ; dw equals_ ; carriage return?
  ; dw zero_branch_,accept.ordinary_key
  ; ; Carriage return ( len ca c )
  ; dw exhaust_
  ; dw drop_,b_l_
  ; dw branch_,accept.emit

; accept.ordinary_key: ; ( len ca c )
  ; dw dup_
; accept.store: ; ( len ca c c | len ca c 0 )
  ; dw i_,c_store_
; accept.emit: ; ( len ca c )
  ; dw emit_

  ; ; ( len ca )
  ; dw i_,over_,minus_,span_,store_ ; update `span`
  ; dw paren_loop_,accept.do
; accept.end:
  ; dw drop_
  ; dw span_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header expect_,'EXPECT'

; doc{
;
; expect  ( ca len -- )  \ Forth-83
;
; Transfer characters from the terminal to address _ca_, until a
; "return" or _len_ characters have been received.
;
; The transfer begins at addr proceeding towards higher
; addresses one byte per character until either a "return" is
; received or until _len_ characters have been transferred.

; No more than _len_ characters will be stored.  The "return" is
; not stored into memory.  No characters are received or
; transferred if _len_ is zero.  All characters actually
; received and stored into memory will be displayed, with the
; "return" displaying as a space.

; ; }doc

  dw span_,off_
  dw question_dup_
  dw zero_branch_,expect.end

  dw bounds_,tuck_ ; ( ca ca+len ca )
  dw paren_do_
expect.do: ; ( ca )
  dw xkey_,dup_ ; ( ca c c )

  _literal delete_char
  dw equals_ ; delete key?
  dw zero_branch_,expect.maybe_carriage_return
  ; Delete key ( ca c )
  dw drop_
  dw dup_,i_,equals_ ; cursor at the start position?
if true=(-1)
  ; XXX TODO simplify
  dw abs_
endif
  dw dup_ ; ( ca f f )
  dw from_r_,two_minus_,plus_,to_r_ ; update the index
  dw question_branch_,expect.loop ; nothing to delete
  ; dw b_l_,i_,c_store_ ; update the buffer ; XXX OLD
  _literal backspace_char
  dw branch_,expect.emit

expect.maybe_carriage_return: ; ( ca c )
  dw dup_
  _literal carriage_return_char
  dw equals_ ; carriage return?
  dw zero_branch_,expect.control_char
  ; Carriage return ( ca c )
  dw exhaust_
  dw drop_,b_l_
  dw branch_,expect.emit

expect.control_char: ; ( ca c )
  dw dup_,b_l_,less_than_ ; control char?
  dw zero_branch_,expect.ordinary_key
  ; Control char ( ca c )
  dw drop_
  dw branch_,expect.do

expect.ordinary_key: ; ( ca c )
  dw dup_
expect.store: ; ( ca c c | ca c 0 )
  dw i_,c_store_
expect.emit: ; ( ca c )
  dw emit_

expect.loop: ; ( ca )
  dw i_,over_,minus_,span_,store_ ; update `span`
  dw paren_loop_,expect.do
expect.end:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header query_,'QUERY'

; doc{
;
; query  ( -- )  \ fig-Forth
;
; XXX TODO description
;
; Make the user input device the input source. Receive input
; into the terminal input buffer, replacing any previous
; contents. Make the result, whose address is returned by `tib`,
; the input buffer. `>in` to zero.
;
; Input 80 characters of text (or until a "return") from the
; operators terminal. Text is positioned at the address
; contained in TIB with IN set to zero.
;
; Transfer characters from the terminal to address contained in
; returned by `tib`, until a "return" or the count contained in
; the `#tib` variable have been received. One or more nulls are
; added at the end of the text.
;
; }doc

  dw tib_,dup_
  dw number_tib_,fetch_
  dw two_dup_,blank_ ; clean the input buffer
  dw expect_
  dw span_,fetch_,plus_,stream_end_
  dw to_in_,off_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header x_,0,immediate

; doc{

; x  ( -- )

; This is pseudonym for the "null" or dictionary entry for a
; name of one character of ascii null. It is the execution
; procedure to terminate interpretation of a line of text from
; the terminal or within a disk buffer, as both buffers always
; have a null word at the end.
;
; In the fig-Forth model a null character is used to detect the
; end of the buffers.  Therefore the scanning words must treat
; the null character as a special unconditional delimiter, and
; do other tricks in order to simulate the null character found
; is a parsed null word.
;
; In Solo Forth the scanning words does not treat the null char
; apart; instead, an actual null word (a null character
; surrounded by spaces) is put after the buffers (disk buffers
; and `tib`). Therefore the null word is parsed normally as any
; other word. No need to treat the null character as a special
; delimiter. This new method is compatible with the original
; fig-Forth parsing words.

; }doc

  dw blk_,fetch_ ; input stream from disk?
  dw zero_branch_,x.exit ; if not, branch
  ; From disk.
  dw one_,blk_,plus_store_ ; next disk buffer
  dw to_in_,off_ ; clear `in`, preparing parsing of input text

  ; XXX WARNING -- The following check of the last block is
  ; specific for 2 blocks per screen; the generic slower check
  ; would be `blk @ b/scr 1- and`.

  dw blk_,fetch_,one_,and_ ; was it the last block of the screen?
  dw question_branch_,x.end ; if not, branch
  ; Last block of the screen.
  dw question_exec_ ; error if not executing
x.exit:

  ; The top item on the return stack is thrown away.  The interpreter
  ; will not continue to execute the `?stack` instruction that follows
  ; `execute` in `interpret`, but will return to the next higher level
  ; of nesting and execute the next word after `interpret` in the Forth
  ; loop.  This is when the familiar "ok" message is displayed on the
  ; terminal, prompting the operator for the next line of commands.

  dw r_drop_
;  dw lit_,7,border_ ; XXX INFORMER

x.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header fill_,'FILL'

  pop de ; e = char
fill.e:
  ld l,c
  ld h,b ; the Forth IP
  pop bc ; count
  ex (sp),hl ; save the Forth IP
fill.do:
  ld a,b
  or c
  _jump_z fill.end
  ld (hl),e
  inc hl
  dec bc
  jp fill.do
fill.end:
  pop bc ; restore the Forth IP
  _jp_next

; ----------------------------------------------
  _code_header erase_,'ERASE'

  ld e,0
  jp fill.e

; ----------------------------------------------
  _code_header blank_,'BLANK'

  ld e,space_char
  jp fill.e

; ----------------------------------------------
  _colon_header hold_,'HOLD'

  dw lit_,-1,hld_,plus_store_ ; decrement `hld`
  dw hld_,fetch_,c_store_ ; store character into `pad`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header pad_,'PAD'

  dw here_
  _literal 0x44
  dw plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header stream_,'STREAM'

; doc{
;
; stream  ( -- ca )
;
; ca = current parsing position in the stream source
;
; }doc

  dw blk_,fetch_,question_dup_ ; from disk?
  dw zero_branch_,stream.terminal
  dw block_ ; from disk
  dw branch_,stream.end
stream.terminal:
  dw tib_ ; from terminal
stream.end:
  dw to_in_,fetch_,plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parsed_,'PARSED'

; doc{
;
; parsed  ( len -- )
;
; Add the given _len_ plus 1 to `>in`.
;
; }word

  dw one_plus_,to_in_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parse_,'PARSE'

; doc{
;
; parse  ( c "text<c>" -- ca len )  \ ANS Forth
;
; Parse _text_ delimited by the delimiter char _c_.
;
; ca = address of the parsed string, within the input buffer
; len = length of the parsed string
;
; If the parse area was empty, the resulting string has a zero length.
;
; }doc

  dw stream_,swap_,scan_,dup_,parsed_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header parse_name_,'PARSE-NAME'

; doc{
;
; parse-name  ( "name"  -- ca len )
;
; }word

  dw stream_,dup_,to_r_ ; ( ca1 )
  dw b_l_,skip_ ; ( ca2 )
  dw dup_,from_r_,minus_,to_in_,plus_store_
  ; XXX TODO factor of `parse`?:
  dw b_l_,scan_ ; ( ca len )
  dw dup_,parsed_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header word_,'WORD'

; doc{
;
; word  ( c "<c...>text<c>" -- ca )  \ ANS Forth
;
; c = delimiter char
;
; Skip leading _c_ delimiters from the input stream.  Parse the
; next text characters from the input stream, until a delimiter
; _c_ is found, storing the packed character string beginning at
; _ca_, as a counted string (the character count in the first
; byte), and with one blank at the end.
;
; }doc

  dw stream_ ; ( c a1 )
  dw dup_,to_r_
  dw over_,skip_ ; ( c a2 )
if  0
  dw hex_
  _echo 'In word after skip:' ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
  dw key_,drop_ ; XXX INFORMER
endif
  dw dup_,from_r_,minus_,to_in_,plus_store_
  ; XXX TODO factor of `parse`:
  dw swap_,scan_ ; ( a2 len )
if  0
  dw hex_
  _echo 'In word after scan:' ; XXX INFORMER
  dw cr_,two_dup_,type_ ; XXX INFORMER
  dw cr_,dot_s_,cr_ ; XXX INFORMER
  dw key_,drop_ ; XXX INFORMER
endif
  dw dup_,one_plus_,to_in_,plus_store_

  dw here_
  _literal max_word_length+2
  dw blank_

  dw dup_,here_,c_store_ ; count byte
  dw here_,one_plus_ ; destination
  dw swap_ ; count
  dw cmove_ ; move the word
  dw here_

  if 0 ; XXX OLD
    ;dw space_ ; XXX INFORMER
    ;dw depth_,dot_ ; XXX INFORMER
    ;_echo 'blk ' ; XXX INFORMER
    ;dw blk_,fetch_,dot_ ; XXX INFORMER
    ;_echo 'in ' ; XXX INFORMER
    ;dw in_,fetch_,dot_ ; XXX INFORMER
    ; dw here_,count_,one_,ink_,type_,zero_,ink_,space_ ; XXX INFORMER
    ;dw key_,drop_ ; XXX INFORMER
  endif

  dw semicolon_s_
; ----------------------------------------------
  _colon_header paren_number_,'(NUMBER)'

; doc{
;
; (number)  ( d1 ca1 -- d2 ca2 )  \ fig-Forth
;
; Convert the ASCII text beginning at _ca1+l_ with regard to
; `base`. The new value is accumulated into double number _d1_,
; being left as _d2_.  _ca2_ is the address of the first
; unconvertable digit. Used by `number`.
;
; }doc

paren_number.begin: ; begin
  dw one_plus_ ; address of the next digit
  dw dup_,to_r_ ; save the address
  dw c_fetch_ ; get the digit
  ;dw dot_s_,key_,drop_; XXX INFORMER
  ;dw dup_,dup_,cr_,dot_,emit_; XXX INFORMER
  dw base_,fetch_,digit_ ; convert the digit
  dw zero_branch_,paren_number.end ; while
  dw swap_ ; get the high order part of d1 to the top.
  dw base_,fetch_,u_m_star_ ; multiply by base value
  dw drop_ ; drop the high order part of the product
  dw rot_ ; move the low order part of d1 to top of stack
  dw base_,fetch_,u_m_star_ ; multiply by base value
  dw d_plus_ ; accumulate result into d1
  dw dpl_,fetch_,one_plus_ ; is DPL other than -1?
  dw zero_branch_,paren_number.decimal_point_done
  ; DPL is not -1, a decimal point was encountered
  dw one_,dpl_,plus_store_ ; increment DPL, one more digit to right of decimal point
paren_number.decimal_point_done:
  dw from_r_ ; pop addr1+1 back to convert the next digit
  dw branch_,paren_number.begin ; repeat
paren_number.end:
  dw from_r_ ; address of the first non-convertable digit, a2.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header number_,'NUMBER'

; doc{
;
; number  ( ca  -- d )  \ fig-Forth
;
; Convert a counted character string left at _ca_, to a signed
; .double number, using the current numeric base. If a decimal
; point is encountered in the text, its position will be given
; in `dpl`, but no other effect occurs. If numeric conversion is
; not possible, an error message will be given.
;
; }doc

  ;dw cr_,dup_,count_,swap_,dot_,dot_ ; XXX INFORMER
  ;dw dup_,count_,type_ ; XXX INFORMER
  dw zero_,zero_,rot_ ; two zeros, initial value of the double number
  dw dup_,one_plus_,c_fetch_ ; get the first digit
  _literal '-'
  dw equals_ ; is it a minus sign?
  dw dup_,to_r_ ; save the flag
if true=(-1)
  dw abs_
endif
  dw plus_
  ; If the first digit is "-", the flag is 1,
  ; and addr+1 points to the second digit.
  ; If the first digit is not "-", the flag is
  ; 0.  addr+0 remains the same, pointing to
  ; the first digit.
  dw lit_,-1 ; initial value of `dpl`
number.begin:
  dw dpl_,store_
  dw paren_number_ ; convert one digit after another until an invalid char occurs
  dw dup_,c_fetch_ ; get the invalid digit
  ;dw dot_s_,key_,drop_; XXX INFORMER
  ;dw cr_,dup_,emit_; XXX INFORMER
  dw b_l_,equals_ ; is it a blank?
  dw question_branch_,number.a_blank
  ; The invalid digit is not a blank.
  dw dup_,c_fetch_ ; get the invalid digit again
  _literal '.'
  dw not_equals_ ; not a decimal point?
  _question_error error.not_understood ; error if not
  ; Decimal point found, set `dpl` to zero next time.
  dw zero_
  dw branch_,number.begin ; repeat
number.a_blank:
  dw drop_ ; discard address
  dw from_r_ ; pop the flag of "-" sign back
  dw zero_branch_,number.end
  ; The first digit is a "-" sign.
  dw dnegate_
number.end:
  dw semicolon_s_

; ----------------------------------------------
  _code_header upper_,'UPPER'

; doc{
;
; upper  ( c -- c' )
;
; }doc

  pop hl
  ld a,l
  call upper.a
  ld l,a
  jp push_hl

upper.a:
  ; Convert the ASCII char in the 'a' register to uppercase.
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20 ; toggle bit 5
  ret

; ----------------------------------------------
  _code_header uppers_,'UPPERS'

; doc{
;
; uppers  ( ca len -- )
;
; }doc

  pop de
  pop hl
uppers.do:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call upper.a
  ld (hl),a
  inc hl
  dec de
  jp uppers.do

; ----------------------------------------------
  _colon_header defined_question_,'DEFINED?'

; defined?  ( ca len -- wf )

  dw found_,nip_,zero_not_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header undefined_question_,'UNDEFINED?'

; doc{
;
; undefined?  ( ca len -- wf )
;
; }doc

  dw defined_question_,zero_equals_
  dw semicolon_s_

; ----------------------------------------------
  _code_header dollar_store_,'$!'

  ; [Code from DZX-Forth's `packed`.]

; doc{
;
; $!  ( ca1 len1 ca2 -- )
;
; Store the string _ca1 len1_ as a counted string at _ca2_.  The
; source and destination strings are permitted to overlap.
;
; An ambiguous condition exists if _len1_ is greater than 255 or
; the buffer at _ca2_ is less than _len1_+1 characters.
;
; }doc

  ; XXX TODO rename? `s!`, `packed`, `pack`, `uncount`...

  exx
  pop de      ; de=ca2
  pop bc      ; c=len1
  pop hl      ; hl=ca1
  push bc     ; len1
  push de     ; ca2
  inc  de
  call move_block
  pop hl      ; ca2
  pop de      ; e=len1
  ld (hl),e
  exx
  _jp_next

; ----------------------------------------------
  _colon_header find_,'FIND'

; doc{
;
; find  ( ca --- ca 0 | cfa 1 | cfa -1 )
;
; Find the definition named in the counted string at _ca_. If
; the definition is not found after searching all the
; vocabularies in the search order, return _ca_ and zero.  If
; the definition is found, return its _cfa_. If the definition
; is immediate, also return one (1); otherwise also return
; minus-one (-1).
;
; }doc

  ; : find  ( ca --- ca 0 | cfa 1 | cfa -1 )
  ;   #vocs 0 do
  ;     context i cells + @  ?dup
  ;     if  @ (find) ?dup if  unloop exit  then  then
  ;   loop  false  ;

  dw hash_vocs_,zero_,paren_do_
find.do:
  dw context_,i_,cells_,plus_,fetch_
  dw question_dup_ ; a vocabulary in the search order?
  dw zero_branch_,find.loop ; if not, next
  ; valid vocabulary in the search order
  dw fetch_,paren_find_,question_dup_ ; word found in the vocabulary?
  dw zero_branch_,find.loop ; if not, try the next vocabulary
  dw unloop_,exit_
find.loop:
  dw paren_loop_,find.do,false_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header find_dollar_,'FIND$'

  ; XXX TODO use an unused address above `pad` instead?
  ; XXX TODO rename to `word$`?
  ; XXX TODO use also in `word`?

  ds max_word_length+2

; ----------------------------------------------
  _colon_header found_,'FOUND'

; doc{
;
; found  ( ca len --- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX TODO factor

  dw find_dollar_
  _literal max_word_length+2
  dw erase_ ; make sure there will be a null at the end
  dw find_dollar_,dollar_store_
  dw find_dollar_,count_,uppers_
  dw find_dollar_,find_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_abort_,'(ABORT)'

  dw abort_
  dw semicolon_s_

; ----------------------------------------------
  _variable_header error_number_,'ERROR#'

  dw 0

; ----------------------------------------------
  _two_variable_header error_pos_,'ERROR-POS'

  dw 0,0

; ----------------------------------------------
  _colon_header error_to_line_,'ERROR>LINE'

; doc{
;
; error>line  ( n1 -- n2 )
;
; Convert an error number to its correspondent line offset. This
; is used in order to skip the first line of screens and use
; them as screen headers as usual.
;
; }doc

  dw dup_,one_plus_,one_,paren_do_
error_to_number.do
  dw i_
  _literal 16
  dw mod_,zero_equals_
if true=(-1)
  dw abs_
endif
  dw plus_
  dw paren_loop_,error_to_number.do
  dw semicolon_s_

; ----------------------------------------------
  _colon_header error_,'ERROR'

  dw dup_,error_number_,store_ ; save the error number
  dw warning_,fetch_,zero_less_than_ ; custom error routine?
  dw question_branch_,paren_abort_pfa ; if so, branch to it

error.message:
  dw here_,count_,type_ ; last parsed word ; XXX TODO adapt to `parse-word`
  dw paren_dot_quote_
  _string '? '
  dw message_
  dw sp0_,fetch_,sp_store_
  dw blk_,fetch_,question_dup_
  dw zero_branch_,error.end
  dw to_in_,fetch_
  dw swap_
  dw error_pos_,two_store_
error.end:
  dw quit_

; ----------------------------------------------
  _colon_header id_dot_,'ID.'

  dw nfa_to_string_,type_,space_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header header_,'HEADER'

; header  ( "name" -- )

  ; XXX TODO -- make sure `current` is searched? else duplicated
  ; definitions would not be remarked.
  ;
  ; the only secure method is:
  ;
  ;   get-order n>r also current @ context ! defined nr> set-order
  ;
  ; but that would make the compilation slower.
  ; i think it can be left to the programmer.

  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  dw abs_,star_,question_dup_ ; ( 0 | cfa cfa )
  dw zero_branch_,header.continue
  ; The word is not unique.
  dw cfa_to_nfa_

  dw id_dot_
  _message error.not_unique
header.continue:

    ; XXX TODO adapt to `parse-word`; now it works because
    ; `defined` still uses `word`, that leaves the string at
    ; `here`.

  dw here_,count_
  ; XXX TODO error if name is too long? (see lina)
  dw width_,fetch_,min_
  dw save_string_,tuck_ ; ( len ca len )
  _names_bank
  dw here_,comma_np_ ; store a pointer to the cfa
  dw latest_,comma_np_ ; link field
  ; Now `np` contains the address of the nfa.
  dw np_fetch_,dollar_store_ ; store the name
  dw np_fetch_,current_,fetch_,store_ ; update contents of `latest` in the current vocabulary
  dw smudge_ ; set the smudge bit and page the default bank
  dw one_plus_,np_,plus_store_ ; update the names pointer with the length+1
  dw here_,two_plus_,comma_ ; compile the pfa into code field
  dw semicolon_s_

; ----------------------------------------------
  _colon_header create_,'CREATE'

  dw header_,smudge_
  dw paren_semicolon_code_
do_create:
  inc de  ; de=pfa
  push de
  _jp_next

; ----------------------------------------------
  _colon_header code_,'CODE'

  dw header_,store_csp_,asm_
  dw semicolon_s_

; ----------------------------------------------
  _code_header compare_,'COMPARE'

  ; ANS Forth
  ; Adapted from DZX-Forth

  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  pop de      ; de = len2
  pop hl      ; hl = ca2
  ex (sp),hl  ; hl = len1 ; ( ca1 ca2 )
  ld a,d
  cp h
  jr nz,compare.lengths
  ld a,e
  cp l
compare.lengths:
  ; cy = string2 is longer than string1?
  jr c,compare.ready
  ex de,hl
compare.ready:
  ; de = length of the short string
  ; hl = length of the long string
  ld l,c
  ld h,b ; hl = Forth IP
  pop bc ; bc = ca2
  ex (sp),hl ; hl = ca1 ; save Forth IP
  push af ; save carry flag
compare.compare_strings: equ $+1 ; XXX not used
  call compare_strings_case_sensitive
  jr nz,compare.no_match

compare.match:
  ; The smaller string matches.
  pop af ; restore flags
  jr compare.end

compare.no_match:
  ; The smaller string does not match.
  pop bc ; useless carry flag

compare.end:
  pop bc ; restore Forth IP
  ld hl,1
  jp c,push_hl
  dec hl ; 0
  jp z,push_hl ; string1 equals string2
  dec hl ; -1
  jp push_hl

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ; [Code from DZX-Forth.]
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; ----------------------------------------------
  _code_header search_,'SEARCH'

  ; search  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  ; ANS Forth

  ; Adapted from DZX-Forth.
  ;
  ; XXX TODO do not use compare_strings_case_sensitive,
  ; because there will be no option to change it.
  ; Use shorter internal code instead.
  ; When case insensitive comparation is needed,
  ; `uppers` can be used.

  exx ; save Forth IP
  pop hl
  ld (search.string_2_len),hl
  ld a,l
  or h ; len2 is zero?
  pop bc ; ca2
  pop hl ; len1
  ld (search.string_1_len),hl
  ex de,hl ; de = len1
  pop hl ; ca1
  ld (search.string_1_addr),hl
  jp z,search.match ; if len2 is zero, match
  dec hl
  inc de
search.1:
  inc hl ; address of current char of string 1
  dec de ; remaining length of string 1
  ld a,e
  or d ; end of string 1?
  jp z,search.no_match
; XXX OLD -- already commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
search.string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings_case_sensitive
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.match:
  ld bc,true
search.end:
  push hl
  push de
  push bc
  exx ; restore Forth IP
  _jp_next

search.no_match:
  ld bc,false
search.string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
search.string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.end

; ----------------------------------------------
  _colon_header bracket_compile_,'[COMPILE]',immediate

  dw tick_,compile_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_literal_,'SLITERAL',immediate

  ; : sliteral  ( ca len -- )  compile slit s,  ; immediate

  dw compile_,s_lit_,s_comma_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header c_literal_,'CLITERAL',immediate

; doc{
;
; cliteral  ( b -- )  \ I
;
; If compiling, then compile the stack value _b_ as a 8-bit literal.
; `cliteral` does the same than `literal` but saves one byte of
; dictionary space.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,c_literal.end
    dw compile_,c_lit_,c_comma_
c_literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,c_lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header literal_,'LITERAL',immediate

; doc{
;
; literal  ( n -- )  \ fig-Forth, I
;
; If compiling, then compile the stack value _n_ as a 16-bit literal.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,literal.end
    dw compile_,lit_,comma_
literal.end:
  else ; XXX NEW
    dw question_comp_
    dw compile_,lit_,comma_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header two_literal_,'2LITERAL',immediate

; doc{
;
; 2literal  ( d -- )  \ I
;
; If compiling, then compile the stack value _d_ as a 32-bit literal.
;
; }doc

  ; XXX TODO -- `interpret` needs the old method of `literal`

  if 1 ; XXX OLD
    dw comp_question_
    dw zero_branch_,two_literal.end
    dw swap_,literal_,literal_
two_literal.end:
  else ; XXX NEW
    ; XXX TODO -- dlit
    dw question_comp_
    dw swap_,literal_,literal_
  endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header depth_,'DEPTH'

  dw sp_fetch_,sp0_,fetch_,minus_,lit_,-2,slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_stack_,'?STACK'

; doc{
;
; ?stack  ( -- )  \ fig-Forth
;
; Issue an error message if the stack is out of bounds.
;
; }doc

  dw sp_fetch_
  dw sp0_,fetch_
  dw swap_,less_than_
  _question_error error.stack_empty
  dw sp_fetch_
  dw lit_,data_stack_limit
  dw less_than_
  _question_error error.full_stack
  dw semicolon_s_

; ----------------------------------------------
  _colon_header interpret_,'INTERPRET'

; doc{
;
; interpret  ( -- )
;
; The outer text interpreter which sequentially executes or
; compiles text from the input stream (terminal or disk)
; depending on `state`. if the word name cannot be found after a
; search of the `context` search order it is converted to a
; number according to the current `base`.  That also failing, an
; error message echoing the name with a "?" will be given.
;
; }doc

interpret.begin:

  ; XXX TODO -- finish

  ; XXX TODO -- In order to change the behaviour of `literal`,
  ; `2literal` and `cliteral` (make them give an error in
  ; interpretation mode), `interpret` must be modified.

  dw question_stack_
  ; dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  dw defined_ ; ( ca 0 | cfa 1 | cfa -1 )
  ;dw cr_,dot_s_ ; XXX INFORMER
  ; _echo 'In interpret after defined ' ; XXX INFORMER
  ; dw hex_,dot_s_,decimal_,key_,drop_ ; XXX INFORMER
  dw question_dup_ ; found?
  ; dw lit_,4,border_,dot_s_,key_,drop_ ; XXX INFORMER
  dw zero_branch_,interpret.word_not_found

  ; Found ( cfa 1 | cfa -1 )
  ; Immediate word:     ( cfa  1 )
  ; Non-immediate word: ( cfa -1 )
  dw comp_question_
  ; ( cfa 1 state | cfa -1 state )
if true=1
  ; Compiling an immediate word:     ( cfa  1 1 )
  ; Compiling a non-immediate word:  ( cfa -1 1 )
  ; Executing an immediate word:     ( cfa  1 0 )
  ; Executing a non-immediate word:  ( cfa -1 0 )
  dw negate_
endif
  ; Compiling an immediate word:     ( cfa  1 -1 )
  ; Compiling a non-immediate word:  ( cfa -1 -1 )
  ; Executing an immediate word:     ( cfa  1  0 )
  ; Executing a non-immediate word:  ( cfa -1  0 )
  dw equals_ ; compiling a non-immediate word?
  dw zero_branch_,interpret.execute

  ; Compiling a non-immediate word  ( cfa )
  dw compile_comma_
  dw branch_,interpret.begin

interpret.execute:
  ; Executing or immediate ( cfa )
  ;_echo 'about to execute cfa ' ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
;  dw dup_,u_dot_,key_,drop_ ; XXX INFORMER
  dw execute_
  ;dw zero_,border_ ; XXX INFORMER
  dw branch_,interpret.begin

interpret.word_not_found:
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ; try to convert the text to a number
  ; ( ca )
  ;_echo 'about to convert to number ' ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  dw number_
  ;dw zero_,border_ ; XXX INFORMER
  dw dpl_,fetch_,one_plus_ ; is there a decimal point?
  dw zero_branch_,interpret.16bit_number
  ; decimal point detected, so it's a double, 32-bit, number
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw two_literal_
  dw branch_,interpret.begin

interpret.16bit_number:
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ; no decimal point, so it's a 16-bit number
  dw drop_ ; discard high order part of the double number
  ; XXX TODO use `c_literal` for 8-bit values.
  dw literal_
  dw branch_,interpret.begin

; ----------------------------------------------
  _colon_header immediate_,'IMMEDIATE'

  dw latest_
  _literal precedence_mask
  ; XXX TODO factor `toggle-names'?
  _names_bank
  dw toggle_
  _default_bank
  dw semicolon_s_

; ----------------------------------------------
  _colon_header vocabulary_,'VOCABULARY'

; doc{
;
; vocabulary  ( "name" -- )
;
; Create a vocabulary with the parsed "name" as its name. The
; run-time efect of `name` is to replace `context`, the top
; vocabulary in the search order.
;
; }doc

  dw create_
  dw zero_,comma_ ; space for the nfa of the latest word defined in the vocabulary
  dw here_ ; address of vocabulary link
  dw voc_link_,fetch_,comma_ ; compile the current content of `voc-link`
  dw voc_link_,store_ ; update `voc-link` with the link in this vocabulary

  dw paren_semicolon_code_

do_vocabulary:
  call do_does

  ; The next words are to be executed when the vocabulary is invoked.
  dw context_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header definitions_,'DEFINITIONS'

  dw context_,fetch_
  dw current_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_,'(',immediate

  _literal ')'
  ; XXX TODO use `skip`?
  dw parse_,two_drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header quit_,'QUIT'

  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw blk_,off_
  dw left_bracket_
quit.do:
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw rp0_,fetch_,rp_store_
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw cr_
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw query_
  ; XXX FIXME never reached before the crash
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  dw interpret_
  dw comp_question_
  dw question_branch_,quit.do
  dw paren_dot_quote_
  _string 'ok'
  dw branch_,quit.do

if show_version

; ----------------------------------------------
  _constant_header version_release_,'VERSION-RELEASE'

  ; XXX TMP for debugging

  dw version_release_variable

; ----------------------------------------------
  _colon_header dot_version_,'.VERSION'

  ; XXX TMP

  dw lit_,version_status_variable,fetch_,emit_
  _literal '-'
  dw emit_
  dw lit_,version_branch_variable,fetch_
  dw s_to_d_,less_hash_,hash_,hash_,hash_greater_,type_
  _literal '-'
  dw emit_
  dw lit_,version_release_variable,two_fetch_
  ; XXX TODO use `du.` when available (it's in the library disk)
  dw less_hash_,hash_s_,hash_greater_,type_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header greeting_,'GREETING'

; doc{
;
; greeting  ( -- )
;
; }doc

if show_version
  dw paren_dot_quote_
;  _string "Solo Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  _string "Solo Forth\rVersion "
  ; XXX TMP show the version and the free dictionary memory:
  dw dot_version_,cr_
;  _string "\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
else
  dw paren_dot_quote_
  _string "Solo Forth\r\x7F 2015 Marcos Cruz\r(programandala.net)\r"
  ; XXX TMP show the free memory, during development only
  dw unused_,u_dot_
  dw paren_dot_quote_
  _string "bytes free"
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abort_,'ABORT'


  dw sp0_,fetch_,sp_store_
boot:
  dw noop_ ; patched by `turnkey` ; XXX OLD
  dw quit_

; ----------------------------------------------
  _constant_header boot_,'BOOT'

  dw boot

; ----------------------------------------------
  _colon_header warm_,'WARM'

  ; dw sp0_,fetch_,sp_store_
  ; dw noop_ ; patched by `turnkey` ; XXX OLD
  ; dw quit_
  dw page_,abort_
  dw semicolon_s_

warm_start:

;  XXX TODO this works too
;  ld hl,abort_
;  ld ix,next ; restore IX
;  jp next2

  call common_start
  dw warm_ ; XXX FIXME -- this works
;  dw abort_ ; XXX FIXME -- this crashes the system, why?

; ----------------------------------------------
  _colon_header cold_,'COLD'

  ; Init the names pointer.
  dw lit_,names_pointer_init_value,fetch_
  dw lit_,names_pointer,store_
  
  ; Init the dictionary pointer.
  dw lit_,dictionary_pointer_init_value,fetch_
  dw lit_,dictionary_pointer,store_

  ; Init the disk buffers.
  dw empty_buffers_

  ; Init the circular string buffer.
  dw empty_csb_

  ; Init the user variables.
  dw lit_,default_user_variables_start ; from
  dw lit_,user_variables_pointer,fetch_ ; to
  _literal default_user_variables_end-default_user_variables_start ; length
  dw cmove_

  ; Restore the vocabularies to the default state.
  dw lit_,latest_nfa_in_root_voc.init_value,fetch_
  dw lit_,root_pfa,store_
  dw lit_,latest_nfa_in_forth_voc.init_value,fetch_
  dw lit_,forth_pfa,store_
  dw lit_,latest_nfa_in_assembler_voc.init_value,fetch_
  dw lit_,assembler_pfa,store_
  dw lit_,voc_link.init_value,fetch_
  dw lit_,voc_link_pfa,store_

  dw only_,forth_,definitions_  ; search order
  dw decimal_

  dw display_,colors0_,page_,greeting_

  dw abort_

cold_start:

  ; XXX TODO -- experimental
  ; ld hl,(sys_err_sp)
  ; ld e,(hl)
  ; inc hl
  ; ld d,(hl)
  ; ex de,hl
  ; ld (sys_err_sp.backup),hl

only_first_cold: ; XXX TMP -- temporary label
  call move_name_fields_to_memory_bank ; (only the first time)
if 0 ; latin1_charset_in_bank
  ld hl,charset_address-0x0100
  ld (sys_chars),hl
endif
  call common_start
  dw cold_

common_start:

  ; Common operations done by warm_start and cold_start.

  im 1 ; interrupt mode 1
  pop bc ; get the return address, that holds the cfa of `cold` or `warm`
  ld (system_stack_pointer),sp ; save the system stack pointer
  ld sp,(s0_init_value)
  xor a
  ld (iy+sys_df_sz_offset),a ; no lines at the bottom part of the screen
  ld ix,next ; restore IX
  _jp_next ; jump to the cfa pointed by the register pair BC

; ----------------------------------------------
  _code_header s_to_d_,'S>D'

; doc{
;
; s->d  ( n -- d )
;
; Sign extend a single number _n_ to form a double number _d_.
;
; }doc

; dup 0<

  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_hlde ; jump if positive
  dec hl
  jp push_hlde

; ----------------------------------------------
  _colon_header plus_minus_,'+-'

; doc{
;
; +-  ( n1 n2 -- n3 )  \ fig-Forth
;
; Apply the sign of n2 to n1, which is left as n3.
;
; }doc

  dw zero_less_than_
  dw zero_branch_,plus_minus.end
  dw negate_
plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_plus_minus_,'D+-'

; doc{
;
; d+-  ( d1 n -- d2 )  \ fig-Forth
;
; Apply the sign of _n_ to the double number _d1_, leaving it as
; _d2_.
;
; }doc

  dw zero_less_than_
  dw zero_branch_,d_plus_minus.end
  dw dnegate_
d_plus_minus.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header abs_,'ABS'

; doc{
;
; abs  ( n -- u )
;
; Leave the absolute value _u_ of a number _n_.
;
; }doc

  dw dup_,plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dabs_,'DABS'

; doc{
;
; dabs  ( d -- ud )
;
; Leave the absolute value _ud_ of a double number _d_.
;
; }doc

  dw dup_,d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _code_header umax_,'UMAX'

; doc{
;
; umax  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; [Code from DZX-Forth.]

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; ----------------------------------------------
  _code_header umin_,'UMIN'

; doc{
;
; umin  ( u1 u2 -- u1 | u2 )
;
; }doc

  ; [Code from DZX-Forth.]

  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; ----------------------------------------------
  _code_header min_,'MIN'

  ; [Code from DZX-Forth.]

  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; ----------------------------------------------
  _code_header max_,'MAX'

  ; [Code from DZX-Forth.]

  pop de
max.de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,push_hl
  ex de,hl
  jp push_hl

; ----------------------------------------------
  _colon_header m_star_,'M*'

; doc{
;
; m*  ( n1 n2 -- d )  \ fig-Forth
;
; A mixed magnitude math operation which leaves the double
; number signed product of two signed number.
;
; }doc

  dw two_dup_
  dw xor_,to_r_
  dw abs_
  dw swap_,abs_,u_m_star_
  dw from_r_,d_plus_minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_,'M/'

; doc{
;
; m/  ( d n1 -- n2 n3 )  \ fig-Forth
;
; A mixed magnitude math operator which leaves the signed
; remainder _n2_ and signed quotient _n3_ from a double number
; dividend and divisor _n1_.  The  remainder takes its sign from
; the dividend.
;
; }doc

  dw over_
  dw to_r_
  dw to_r_
  dw dabs_
  dw r_fetch_
  dw abs_
  dw u_slash_mod_
  dw from_r_
  dw r_fetch_
  dw xor_
  dw plus_minus_
  dw swap_
  dw from_r_
  dw plus_minus_
  dw swap_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_,'*'

  dw m_star_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_mod_,'/MOD'

; doc{
;
; /mod  ( n1 n2 -- rem quot )  \ fig-Forth
;
; Leave the remainder and signed quotient of _n1_/_n2_. The
; remainder has the sign of the dividend.
;
; }doc

  dw to_r_,s_to_d_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header slash_,'/'

  dw slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header mod_,'MOD'

  dw slash_mod_,drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_mod_,'*/MOD'

  dw to_r_,m_star_
  dw from_r_,m_slash_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header star_slash_,'*/'

  dw star_slash_mod_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header m_slash_mod_,'M/MOD'

  dw to_r_,zero_,r_fetch_
  dw u_slash_mod_
  dw from_r_,swap_
  dw to_r_,u_slash_mod_,from_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_line_,'(LINE)'

  dw to_r_
  dw c_slash_l_,b_slash_buf_,star_slash_mod_
  dw from_r_,b_slash_scr_,star_,plus_
  dw block_,plus_,c_slash_l_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_line_,'.LINE'

  dw paren_line_,minus_trailing_,type_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header message_,'MESSAGE'

; doc{
;
; message  ( n -- )
;
; }doc

  ; XXX TODO -- depending on `warning`:
  ;   0 : nothing
  ;   true : number
  ;   other : text

  dw warning_,fetch_
  dw zero_branch_,message.number_only
  dw error_to_line_,msg_scr_,dot_line_,space_
  dw semicolon_s_

message.number_only:
  dw paren_dot_quote_
  _string 'MSG # '
  ; XXX TODO force decimal base
  dw dot_
  dw semicolon_s_


; ----------------------------------------------
  _colon_header update_,'UPDATE'

; doc{
;
; update  ( -- )  \ ANS-Forth
;
; Mark the most recently referenced block (pointed to by `prev`) as
; altered. The block will subsequently be transferred automatically to
; disk should its buffer be required for storage of a different block.
;
; }doc

  ; XXX TODO move to the disk?

  dw disk_buffer_,fetch_
  dw lit_,0x8000,or_
  dw disk_buffer_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header updated_question_,'UPDATED?'

; doc{
;
; updated?  ( -- f )
;
; Is the current disk buffer marked as modified?
;
; }doc

  dw buffer_id_,zero_less_than_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header stream_end_,'STREAM-END'

; doc{
;
; stream-end  ( ca -- )
;
; Store the null word (a null character) at the given address,
; surrounded by spaces. This marks the end of a input stream.
;
; }doc

  dw s_lit_
  db 3,space_char,0,space_char ; string
  dw rot_,smove_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header empty_buffers_,'EMPTY-BUFFERS'

; doc{
;
; empty-buffers  ( -- )
; 
; Unassign all block buffers. Do not transfer the contents of
; any updated block to mass storage.
;
; }doc

  dw lit_,buffer_block_id_mask,disk_buffer_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_data_,'BUFFER-DATA'

; doc{
;
; buffer-data  ( -- a )
; 
; First data address of the disk buffer.
;
; }doc

  dw disk_buffer_,cell_plus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_id_,'BUFFER-ID'

; doc{
;
; buffer-id  ( -- x )
; 
; Id of the disk buffer.
;
; }doc

  dw disk_buffer_,fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header block_number_,'BLOCK-NUMBER'

; doc{
;
; block-number  ( x -- n )
; 
; Convert the disk buffer id _x_ to its associated block _n_,
; by removing the update bit.
;
; }doc

  _literal buffer_block_id_mask
  dw and_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_block_,'BUFFER-BLOCK'

; doc{
;
; buffer-block  ( -- n )
;
; Block number associated with the disk buffer.
;
; }doc

  dw buffer_id_,block_number_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_buffer_,'(BUFFER)'

; doc{
;
; (buffer)  ( n -- )
;
; If the contents of the disk buffer has been marked as updated,
; write its block to the disk. Assign the block number _n_ to
; the disk buffer.

; ----
; : (buffer)  ( n -- )
;   updated?  if    block-number write-buffer
;             else  drop
;             then  disk-buffer !  ;
; ----
 
; }doc

  dw updated_question_
  dw zero_branch_,free_buffer.not_updated
  dw block_number_,write_buffer_
  dw branch_,free_buffer.end
free_buffer.not_updated:
  dw drop_
free_buffer.end:
  dw disk_buffer_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header buffer_,'BUFFER'

; doc{
;
; buffer  ( n -- a )
;
; Assign the block buffer to block _n_.   If the contents of the
; buffer were marked as updated, it is written to the disk.  The
; block _n_ is not read from the disk.  The address _a_ left on
; stack is the first cell in the buffer for data storage.

; ----
; : buffer  ( n -- a )
;   dup buffer-block =  if    drop
;                       else  (buffer)
;                       then  buffer-data  ;
; ----

; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,buffer.not_equals
  ; The requested block is the one already in the buffer.
  dw drop_
  dw branch_,buffer.end
buffer.not_equals:
  dw paren_buffer_
buffer.end:  
  dw buffer_data_ ; first cell of data in the buffer
  dw semicolon_s_

; ----------------------------------------------
  _colon_header block_,'BLOCK'

; doc{
;
; block  ( n -- a )

; If the block _n_ is already in memory, leave the address _a_
; of the first cell in the disk buffer for data storage.
; 
; If the block _n_ is not already in memory, transfer it from
; disk to the buffer.  If the block occupying that buffer has
; been marked as updated, rewrite it to disk before block _n_ is
; read into the buffer.  Finally leave the address _a_ of the
; first cell in the disk buffer for data storage.

; ----
; : block ( n --- a )
;   dup buffer-block =
;   if    drop
;   else  save-buffers  dup read-buffer  disk-buffer !
;   then  buffer-data  ;
; ----

; }doc

  dw dup_,buffer_block_,equals_
  dw zero_branch_,block.not_equals
  dw drop_
  dw branch_,block.end
block.not_equals:
  dw save_buffers_,dup_,read_buffer_
  dw disk_buffer_,store_
block.end:
  dw buffer_data_
  dw semicolon_s_

; ----------------------------------------------
  _code_header flip_,'FLIP'

; doc{
;
; flip  ( n1 -- n2 )
;
;   Exchange the low and high bytes within n1.
;
; }doc

; [Name taken from eForth. It's called `><` or `cswap` in other
; Forth systems.]

  pop hl
  ld a,h
  ld h,l
  ld l,a
  jp push_hl

; ----------------------------------------------
  _colon_header block_to_sector_,'BLOCK>SECTOR'

; doc{

; block>sector  ( n1 -- n2 )

; Convert the disk block _n1_ to the disk sector _n2_, in the
; format required by G+DOS: The high byte of _n2_ is the track
; (0..79 for side 0; 128..207 for side 1); the low byte of _n2_
; is the sector (1..10).

; ----
; : block>sector  ( n1 -- n2 )
;   \ n2 (high byte) = track 0..79 for side 0, 128..207 for side 1
;   \    (low byte)  = sector 1..10
;   \ track0 = 0..79
;   \ track = 0..207
;   \ side = 0..1
;   dup 10 mod 1+    ( n1 sector )
;   swap dup 20 /    ( sector n1 track0 )
;   swap 10 / 1 and  ( sector track0 side )
;   128              ( sector track 128 )
;   \ * +          ( sector track ) \ XXX OLD for true=1
;   negate and or    ( sector track )  \ XXX NEW a bit faster, for true=-1
;   flip or  ;
; ----
;
; }doc

  dw dup_
  _literal 10
  dw mod_,one_plus_,swap_,dup_
  _literal 20
  dw slash_,swap_
  _literal 10
  dw slash_,one_,and_

if true=1 ; XXX OLD
  ; XXX TODO optimize with `7 lshift`?
  _literal 128
  dw star_,plus_
else
  dw negate_
  _literal 128
  dw and_,or_
endif
  
  dw flip_,or_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header read_block_,'READ-BLOCK'

; doc{
;
; read-block  ( a n -- )
;
; Read disk block _n_ to buffer _a_.
;
; }doc

  _literal 0x44 ; G+DOS command to read a disk sector
  dw transfer_block_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header read_buffer_,'READ-BUFFER'

; doc{
;
; read-buffer  ( n -- )
;
; Read disk block _n_ to the disk buffer.
;
; }doc

  dw buffer_data_,swap_,read_block_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header write_block_,'WRITE-BLOCK'

; doc{
;
; write-block  ( a n -- )
;
; Write buffer _a_ to disk block _n_.
;
; }doc

  _literal 0x45 ; G+DOS command to write a disk sector
  dw transfer_block_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header write_buffer_,'WRITE-BUFFER'

; doc{
;
; write-buffer  ( n -- )
;
; Write the disk buffer to disk block _n_.
;
; }doc

  dw buffer_data_,swap_,write_block_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header transfer_block_,'TRANSFER-BLOCK'

; doc{
;
; transfer-block  ( a n b -- )
;
; The disk read-write linkage.
;
; a = source or destination block buffer
; n = sequential number of the referenced disk block
; b = G+DOS command to read or write a sector
;
; }doc

  dw lit_,read_write_sector_command,c_store_
  dw block_to_sector_
  dw paren_transfer_block_
  dw semicolon_s_

paren_transfer_block_:
  ; Headerless word with the low level code of `R/W`.
  dw paren_transfer_block_pfa ; code field
  
  ; ( a sector -- )
  ; sector (high byte) = track 0..79, +128 if side 1
  ;        (low byte)   = sector 1..10
paren_transfer_block_pfa:
  pop de ; d = track 0..79, +128 if side 1
         ; e = sector 1..10
  pop ix ; address
  push bc ; save the Forth IP
  ld a,2 ; drive ; XXX TMP
  rst 8 ; G+DOS hook
read_write_sector_command:
  ; G+DOS command already patched:
  db 0x44 ; 0x44 = read ; 0x45 = write
  pop bc ; restore the Forth IP
  ld ix,next
  _jp_next

; ----------------------------------------------
  _colon_header save_buffers_,'SAVE-BUFFERS'

; doc{
;
; save-buffers  ( -- )  \ ANS Forth
;
; If the disk buffer has been modified, transfer its contents to
; disk and mark it as unmodified.
;
; ----
; : save-buffers ( -- )
;   updated? 0= ?exit \ exit if not updated
;   buffer-block dup write-buffer  disk-buffer !  ;
; ----
;
; }doc

  dw updated_question_,zero_equals_ ; not updated?
  dw question_exit_ ; exit if not updated
  ; Updated
  dw buffer_block_,dup_,write_buffer_
  dw disk_buffer_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header flush_,'FLUSH'

  ; XXX TODO -- move to the disk?

  dw save_buffers_,empty_buffers_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header paren_load_,'(LOAD)'

; doc{
;
; (load)  ( i*x u -- j*x )
;
; Store _u_ in `blk` (thus making block _u_ the input source and
; setting the input buffer to encompass its contents), set `>in`
; to zero, and interpret.  Other stack effects are due to the
; words loaded.
;
; An error is issued if _u_ is zero.
;
; ----
; : (load)  ( i*x u -- j*x )
;   dup 0= 9 ?error
;   b/scr * blk !  >in off  interpret  ;
; ----
;
; }doc

  dw dup_,zero_equals_
  _question_error error.loading_from_screen_0
  dw b_slash_scr_,star_,blk_,store_
  dw to_in_,off_,interpret_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header continued_,'CONTINUED'

; doc{
;
; continued  ( i*x u -- j*x )  \ Forth-79 (uncontrolled word
; definition from the Reference Word Set)
;
; Store _u_ in `blk` (thus making block _u_ the input source and
; setting the input buffer to encompass its contents), set `>in`
; to zero, and interpret.  Other stack effects are due to the
; words loaded.
;
; ----
; : continued  ( -- )
;   ?loading (load)  ;
; ----
;
; }doc

  dw question_loading_,paren_load_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header load_,'LOAD'

; doc{
;
; load  ( u -- )
;
; Save the current input-source specification. Store _u_ in
; `blk` (thus making block _u_ the input source and setting the
; input buffer to encompass its contents), set `>in` to zero,
; and interpret. When the parse area is exhausted, restore the
; prior input source specification. Other stack effects are due
; to the words loaded.
;
; An error is issued if _u_ is zero.
;
; ----
; : load  ( n -- )
;   blk @ >r  >in @ >r
;   (load)
;   r> >in !  r> blk !  ;
; ----
;
; }doc

  dw blk_,fetch_,to_r_
  dw to_in_,fetch_,to_r_
  dw paren_load_
  dw from_r_,to_in_,store_
  dw from_r_,blk_,store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header next_screen_,'-->',immediate

; doc{
;
; -->  ( -- )  \ "next-screen"
;
; Continue interpretation with the next disk screen.
;
; ----
; : -->  ( -- )
;   ?loading  >in off
;   b/scr blk @ over mod - blk +!  ; immediate
; ----
;
; }doc

  dw question_loading_
  dw to_in_,off_
  dw b_slash_scr_,blk_,fetch_,over_,mod_,minus_
  dw blk_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header defined_,'DEFINED'

; doc{
;
; defined  ( "name" -- ca 0 | cfa 1 | cfa -1 )
;
; }doc

  ; XXX TODO -- adapt to the new parsing method

if 1 ; XXX OLD

  dw b_l_,word_ ; ( ca2 )

else ; XXX NEW

  dw parse_name_  ; ( ca1 len1 )
  ;dw cr_,dot_s_,lit_,1,border_,key_,drop_ ; XXX INFORMER
  dw save_counted_string_ ; ( ca2 )
  ;dw cr_,dot_s_,lit_,2,border_,key_,drop_ ; XXX INFORMER

endif

  dw dup_,count_,uppers_  ; uppercase ( ca2 )
  ;dw cr_,dot_s_,lit_,3,border_,key_,drop_ ; XXX INFORMER
  dw find_
  ;dw cr_,dot_s_,lit_,4,border_,key_,drop_ ; XXX INFORMER

  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_defined_,'?DEFINED'

; doc{
;
; ?defined  ( f -- )
;
; }doc

  ; [Code from DZX-Forth.]

  dw zero_equals_
  _question_error error.not_found
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_defined_,'[DEFINED]',immediate

; doc{
;
; [defined]  ( "name" -- wf )
;
; }doc

  dw defined_,nip_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_undefined_,'[UNDEFINED]',immediate

; doc{
;
; [undefined]  ( "name" -- wf )
;
; }doc

  dw bracket_defined_,zero_equals_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header tick_,"'"

; doc{
;
; '  ( "name" -- cfa )
;
; }doc

  dw defined_,question_defined_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_tick_,"[']",immediate

; doc{
;
; [']  ( "name" -- cfa )
;
; }doc

  dw tick_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header begin_,'BEGIN',immediate

; doc{
;
; begin  ( compilation: -- a n )
;
; At compile time `begin` leaves the dictionary address on
; stack with an error checking number _n_.  It does not compile
; anything to the dictionary.
;
; }doc

  dw question_comp_ ; error if not compiling
  dw backward_mark_ ; address to compute the backward branch
if 1 ; fig_compiler_security
  dw one_ ; error checking number
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header then_,'THEN',immediate

  dw question_comp_ ; error if not compiling
if 1 ; fig_compiler_security
  dw two_,question_pairs_ ; check for nesting error
endif
  dw forward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  ; _colon_header question_do_,'?DO',immediate

  ; XXX TODO

  ; dw compile_,paren_question_do_
  ; dw branch_,do.common

; ----------------------------------------------
  _colon_header do_,'DO',immediate

  dw compile_,paren_do_
do.common:
  dw backward_mark_
if 1 ; fig_compiler_security
  _literal 3 ; error checking number
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header loop_,'LOOP',immediate

if 1 ; fig_compiler_security
  _literal 3 ; error checking number
  dw question_pairs_
endif
  dw compile_,paren_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header plus_loop_,'+LOOP',immediate

if 1 ; fig_compiler_security
  _literal 3 ; error checking number
  dw question_pairs_
endif
  dw compile_,paren_plus_loop_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header until_,'UNTIL',immediate

if 1 ; fig_compiler_security
  dw one_,question_pairs_
endif
  dw compile_,zero_branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header again_,'AGAIN',immediate

; doc{
;
; again  ( compilation: a n -- )
;
; End of an infinite loop.  Compile an unconditional jump
; instruction to branch backward to _a_.
;
; }doc

if 1 ; fig_compiler_security
  dw one_,question_pairs_ ; check n for error
endif
  dw compile_,branch_
  dw backward_resolve_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header repeat_,'REPEAT',immediate

; doc{
;
; repeat  ( compilation: a1 n1 a2 n2 -- )
;
; a1 = address of `begin` to branch to
; n1 = `begin` check number
; a2 = address of the branch of `while` to resolve
; n2 = `while` check number
;
; Compile `branch` to jump back to `begin`.  Resolve also  the
; branching offset required by `while`.
;
; }doc

  dw two_to_r_
  dw again_ ; unconditional branch back to `begin`
  dw two_from_r_
  ; dw two_minus_ ; restore 2 to be checked by `then` ; XXX OLD -- unnecessary
  ; XXX TODO why unncessary?
  dw then_ ; resolve the forward branching needed by `while`
  dw semicolon_s_

; ----------------------------------------------
  _colon_header if_,'IF',immediate

  dw compile_,zero_branch_
if.do:
  dw forward_mark_
if 1 ; fig_compiler_security
  dw two_ ; error checking number
endif
  dw semicolon_s_

; ----------------------------------------------
  _colon_header unless_,'UNLESS',immediate

  ; Equivalent to `0= if`, but faster.

  dw compile_,question_branch_
  dw branch_,if.do

  ; XXX TODO move to the disk:

; : unless  ( f -- )  postpone ?branch >mark 2  ; immediate
; \ Alternative: when compiler security is removed:
; : unless  ( f -- )  postpone ?branch >mark  ; immediate

; ----------------------------------------------
  _colon_header ahead_,'AHEAD',immediate

  dw compile_,branch_
  dw forward_mark_

; ----------------------------------------------
  _colon_header else_,'ELSE',immediate

  ; XXX FIXME Pasmo bug?
  ; The system crashes when conditional compilation
  ; is used here, in any combination. Very strange.

if 1 ; fig_compiler_security

  dw two_ ; error checking number
  dw question_pairs_
  dw compile_,branch_
  dw forward_mark_
  dw swap_
  dw two_ ; error checking number
  dw then_
  dw two_ ; error checking number
  dw semicolon_s_

else

  dw compile_,branch_
  dw forward_mark_
  dw then_
  dw semicolon_s_

endif

; ----------------------------------------------
  _colon_header while_,'WHILE',immediate

  dw if_
  ; dw two_plus_ ; leave 4 to be checked by `repeat` ; XXX OLD -- unnecessary
  ; XXX TODO 2015-08-13: why unnecessary? why fig-Forth does not use `swap`?
  dw semicolon_s_

; ----------------------------------------------
  _colon_header spaces_,'SPACES'

  dw b_l_,emits_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header emits_,'EMITS'

  ; emits  ( u c -- )

  ; XXX TODO use `?do` or `for` when available
  dw swap_,zero_,max_,question_dup_
  dw zero_branch_,emits_.end
  dw zero_
  dw paren_do_
emits_.do:
  dw dup_,emit_
  dw paren_loop_,emits_.do
emits_.end:
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header less_hash_,'<#'

  dw pad_
  dw hld_
  dw store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_greater_,'#>'

  dw drop_
  dw drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header sign_,'SIGN'

; doc{

; sign  ( n  d  ---  d ) \ fig-Forth

; Stores an ascii "-" sign just before a converted numeric
; output string in the text output buffer when _n_ is negative.
; _n_ is discarded but double number _d_ is maintained. Must be
; used between `<#` and `#>`.

; }doc

  ; XXX TODO convert to ANS Forth

  dw rot_,zero_less_than_
  dw zero_branch_,sign.end
  _literal '-'
  dw hold_
sign.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_,'#'

; doc{
;
; #  ( d1 -- d2 )
;
; Divide _d1_ by current base.  The remainder is converted to
; an ASCII character and appended to the output text string.
; The quotient _d2_ is left on stack.
;
; }doc


  dw base_,fetch_
  dw m_slash_mod_ ;  ( remainder dquotient )
  dw rot_ ; ( dquotient remainder )
  _literal 0x09
  dw over_,less_than_ ; remainder<9?
  dw zero_branch_,hash.digit
  ; remainder<9
  _literal 0x07
  dw plus_ ; make it an alphabet
hash.digit:
  ; Form the ASCII representation of a digit:
  ; "0" to "9" and "A" to "F" (or above).
  _literal '0'
  dw plus_
  dw hold_ ; put the digit into `pad` in a reversed order.
  dw semicolon_s_

; ----------------------------------------------
  _colon_header hash_s_,'#S'

; doc{
;
; #S  ( d1 -- d2 )
;
; }doc

hash_s.begin:
  dw hash_,two_dup_,or_
  dw question_branch_,hash_s.begin
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_r_,'D.R'

; doc{
;
; d.r  ( d n -- )
;
; Print a signed double number _d_ right justified in a field of
; _n_ characters.
;
; }doc

  dw to_r_ ; save n
  ; Save the high order part of d under d,
  ; to be used by `sign` to add a "-" sign to a negative number:
  dw swap_,over_
  dw dabs_ ; convert d to its absolute value
  ; Convert the absolute value to ASCII text with proper sign:
  dw less_hash_
  dw hash_s_
  dw sign_
  dw hash_greater_
  dw from_r_ ; retrieve n
  dw over_,minus_,spaces_ ; fill the output field with preceding blanks
  dw type_ ; type out the number
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_r_,'.R'

  dw to_r_,s_to_d_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header d_dot_,'D.'

; doc{
;
; d.  ( d -- )
;
; Print signed double integer _d_ according to current base,
; followed by only one blank.
;
; }doc

  dw zero_,d_dot_r_,space_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_,'.'

; doc{
;
; .  ( n -- )
;
; Print signed integer _n_ according to current base, followed
; by only one blank.
;
; }doc

  dw s_to_d_,d_dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_,'?'

  dw fetch_,dot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header u_dot_,'U.'

  dw zero_,d_dot_
  dw semicolon_s_

; ----------------------------------------------

if 1

  _colon_header dot_s_,'.S'

  ; XXX TMP -- only during the development, then remove
  ; It is already on the disk.

  dw depth_,dup_,s_to_d_,less_hash_
  _literal '>'
  dw hold_,hash_s_
  _literal '<'
  dw hold_,hash_greater_,type_,space_
  dw zero_branch_,dot_s.end

  dw sp_fetch_,two_minus_,sp0_,fetch_,two_minus_
  dw paren_do_
dot_s.do:
  dw i_,fetch_,u_dot_ ; XXX TMP `u.`
  dw lit_,-2
  dw paren_plus_loop_,dot_s.do
dot_s.end:
  dw semicolon_s_

endif

; ----------------------------------------------
  _code_header colors0_,'COLORS0'

; doc{
;
; colors0  ( -- )
; 
; Set the screen colors to the default values.
;
; }doc

  ; Set the colors and their masks.

  ld hl,(default_color_attribute)
  ; l = 128*flash + 64*bright + 8*paper + ink
  ; h = mask
  ld (sys_attr_p),hl ; permanent
  ld (sys_attr_t),hl ; temporary

  ; Set the system variable that holds the attributes of the
  ; lower part of the screen.  It is needed only because G+DOS
  ; by default changes the border color during disk operations,
  ; and at the end restores it with the value of this system
  ; variable.

  ld a,l
  ld (sys_bordcr),a ; lower screen colors

  ; Set the border color to the paper color.

  ; a = 128*flash + 64*bright + 8*paper + ink
  and a ; cy=0
  rra
  rra
  rra ; a = paper
  out(0xFE),a ; set the border color

  _jp_next

; ----------------------------------------------
  _code_header home_,'HOME'

; doc{
;
; home  ( -- )
;
; Reset the cursor position to the upper left corner (column 0,
; row 0).
;
; }doc

  ld hl,0x1821 ; 0x18 = 24 - row
               ; 0x21 = 33 - column
  ld (sys_s_posn),hl
  _jp_next

; ----------------------------------------------
  _code_header cls_,'CLS'


; doc{
;
; cls  ( -- )
;
; Clear the screen with the current colors and reset the cursor
; position to the upper left corner (column 0, row 0).
;
; }doc

; Note: The ROM routines that clear the screen are slow and do
; many unnecessary BASIC-related things. This code simply clears
; the screen.

; [The attributes part was improved after code by Dean Belfield
; <http://wordpress.animatez.co.uk/programming/assembly-language/z80/z80-library-routines/204-2/>.
; The idea for `ld (hl),l` was found in David Webb's _Advanced
; Spectrum Machine Language_ ]

  exx ; save the Forth IP
  ; Erase the bitmap.
  ld hl,sys_screen
  ld de,sys_screen+1
  ld bc,sys_screen_bitmap_size
  ld (hl),l ; l=0 because sys_screen=0x4000
  ldir
  ; Color with the permanent attributes.
  ld bc,sys_screen_attributes_size-1
  ld a,(sys_attr_p)
  ld (hl),a
  ldir
  ld (sys_coords),bc ; reset the graphic coordinates
  exx ; restore the Forth IP
  jp home_pfa ; continue at `home`

  ; The Z80 version above uses 26 bytes;
  ; the following Forth version uses 30 bytes:

  ; _colon_header cls_,'CLS'
  ; dw lit_,sys_screen,lit_,sys_screen_bitmap_size,erase
  ; dw lit_,sys_screen_attributes,lit_,sys_screen_attributes_size
  ; dw lit_,sys_attr_p,c_fetch_,fill_
  ; dw home_
  ; dw semicolon_s

; ----------------------------------------------
  _colon_header page_,'PAGE'

; doc{
;
; page  ( -- )  \ ANS Forth
;
; Move to another page for output.  On a terminal, `page` clears
; the screen and resets the cursor position to the upper left
; corner. On a printer, `page` performs a form feed.
;
; }doc

  ; XXX TODO printer support

  dw cls_
  dw semicolon_s_

; ----------------------------------------------
  _code_header bye_,'BYE'

  ld (iy+sys_df_sz_offset),0x02 ; restore lines of the lower screen

  ; XXX TODO -- experimental
; sys_err_sp.backup: equ $+1
;   ld hl,0
;   push hl
;   ld (sys_err_sp),sp

if 0 ; latin1_charset_in_bank
  ; Restore the default charset:
  ld hl,15360
  ld (sys_chars),hl
endif

if 0
  ; shows the STOP message, but halts
  ld sp,(sys_err_sp)
  pop bc ; remove old error return address
  ld bc,0x1303 ; BASIC entry point in ROM
  push bc ; push it so the next error will return to BASIC command line
endif

  im 1 ; interrupt mode 1, normal situation

system_stack_pointer: equ $+1
if 1
  ld sp,0 ; restore the system stack
else
  ; no difference when sp is not restored at the end
  ld hl,0 ; XXX TMP
endif

if 1

; The Complete Spectrum ROM Disassembly (p201) states:
; http://www.worldofspectrum.org/infoseekid.cgi?id=2000076
;
; For a successful return to BASIC, H'L' must on exit from the
; machine code contain the address in SCANNING of the 'end-calc'
; instruction, 2758 hex (10072 decimal).

  ; no difference
  ld hl,0x2758
  exx
endif

  ; Exit to BASIC:
bye.end ; XXX TMP for debugging
  rst 0x08
  db 0x08 ; "STOP" BASIC error
  ;db 0xFF ; "OK" BASIC error

; ----------------------------------------------
  _code_header two_drop_,'2DROP'

  pop hl
  pop hl
  _jp_next

; ----------------------------------------------
  _code_header two_swap_,'2SWAP'

  ; [Code from DZX-Forth.]

  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  jp push_hlde

; ----------------------------------------------
  _colon_header unused_,'UNUSED'

  ; XXX TMP
  dw zero_,here_,minus_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header where_,'WHERE'

  ; XXX TODO -- remove; already copied to the disk

  dw error_pos_,two_fetch_ ; XXX NEW
  dw dup_
  dw question_branch_,where.do_it
  dw two_drop_
  dw semicolon_s_

where.do_it:
  dw dup_,b_slash_scr_,slash_
  dw paren_dot_quote_
  _string 'Scr # '
  dw decimal_,dot_
  dw swap_,c_slash_l_,slash_mod_,c_slash_l_,star_
  dw rot_,block_,plus_
  dw c_slash_l_,cr_,type_,cr_
  dw here_,c_fetch_,minus_,spaces_
  _literal '^'
  dw emit_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header at_xy,'AT-XY'

; doc{

; at-xy ( col line -- )  \ ANS Forth

; Warning: The system will crash if the coordinates are out of screen.
; For the sake of speed, no check is done.  A wrapper secure word can
; be written if needed.

; }doc

; [Code adapted from Spectrum Forth-83.]

  dw dup_
  _literal 23
  dw not_equals_ ; not the last line?
  dw zero_branch_,at_pfa.last_line
  ; not the last line
  dw lit_,22,paren_emit_,paren_emit_,paren_emit_
  dw semicolon_s_ ; XXX TODO exit_

at_pfa.last_line:
  dw one_minus_,dup_,paren_emit_,paren_emit_,zero_,paren_emit_
  dw cr_
  dw dup_
  dw lit_,sys_df_cc ; address in display file of print position
  dw plus_store_
  _literal 33
  dw swap_
  dw minus_
  dw lit_,sys_s_posn ; 33 minus column number for print position
  dw c_store_
  dw semicolon_s_

; ----------------------------------------------
  _code_header border_,'BORDER'

  pop hl
  ld a,l
  out(0xFE),a

  ; The system variable that holds the attributes of the lower
  ; part of the screen, unnecessary in Solo Forth, must be
  ; updated.  The reason is G+DOS, after disk operations that
  ; make the border change, restores the border color with the
  ; value of this system variable.  We use the border color as
  ; paper and set a a contrast ink (black or white), to make
  ; sure the lower part of the screen is usable after returning
  ; to BASIC.

  ; XXX TODO move the contrast ink calculation to `bye` or
  ; simply remove it:

  cp 4 ; cy = dark color (0..3)?
  ld a,7 ; white ink
  jr c,border.end
  xor a ; black ink

border.end:
  ; Note: slower than shifting the register, but saves three bytes.
  add hl,hl
  add hl,hl
  add hl,hl ; l = paper (bits 3..5)
  or l ; combine with ink
  ld (sys_bordcr),a
  _jp_next

; ----------------------------------------------
  _code_header overwrite_,'OVERWRITE'

  ld a,over_char
  jp color

; ----------------------------------------------
  _code_header flash_,'FLASH'

  ld a,flash_char
  jp color

; ----------------------------------------------
  _code_header inverse_,'INVERSE'

  ld a,inverse_char
  jp color

; ----------------------------------------------
  _code_header bright_,'BRIGHT'

  ld a,bright_char
  jp color

; ----------------------------------------------
  _code_header paper_,'PAPER'

  ld a,paper_char
  jp color

; ----------------------------------------------
  _code_header ink_,'INK'

  ld a,ink_char

color:
  ; Set a color attribute (ink, paper, bright, flash, inverse or
  ; overwrite).
  ; Input:
  ;   a = attribute control char
  ;   (tos) = color attribute value
  rst 0x10
  pop hl
  ld a,l
  rst 0x10
  call rom_set_permanent_colors_0x1CAD
  _jp_next

; ----------------------------------------------
  _code_header emitted_,'EMITTED'

  ; [Code adapted and modified from the ZX Spectrum ROM routine
  ; S-SCRN$-S at 0x2535.]

; doc{
;
; emitted  ( col row -- n | 0 )
;
; Return the ordinal number _n_ (first is 1) of the character
; printed at the given screen coordinates, or 0 if no character
; can be recognized on that position of the screen.
;
; This word must be configured by `emitted-charset` and
; `#emitted-chars`, that set the address of the first character
; and the number of characters to compare with. By default the
; printable ASCII chars of the ROM charset are used.
;
; The result _n_ is the ordinal number (first is 1) of the
; recognized char in the specified charset. Example: with the
; default configuration, a recognized space char would return 1;
; a "!" char, 2; a "A", 34...
;
; This word is meant to be used with user defined graphics.
;
; }doc

  ; XXX TODO improve the result
  ;
  ; XXX TODO move to the disk
  ;
  ; XXX TODO rename?: `ocr`, `recognized`, `on-xy`, `xy-char`?
  ; The reasen is name clash with the fig-Forth `out` counter,
  ; that was going to be called `emitted` or `#emitted`.

  pop de ; row
  pop hl ; col
  push bc ; save the Forth IP
  ld b,l ; column
  ld c,e ; row
  ld hl,(emitted_charset_pfa) ; address of first printable char in the charset
  ld a,c  ; row
  rrca
  rrca
  rrca ; multiply by 0x20
  and  %11100000
  xor  b ; combine with column (0x00..0x1F)
  ld  e,a ; low byte of top row = 0x20 * (line mod 8) + column
  ld  a,c  ; row is copied to a again
  and  0x18
  xor  0x40
  ld  d,a ; high byte of top row = 64 + 8*int (line/8)
  ; de = screen address
  ld a,(hash_emitted_chars_pfa) ; number of chars in the charset
  ld b,a

emitted.do:
  push  bc  ; save the characters count
  push  de  ; save the screen pointer
  push  hl  ; save the character set pointer (bitmap start)
  ld  a,(de)  ; get first scan of screen character
  xor  (hl)  ; match with scan from character set
  jp z,emitted.match  ; jump if direct match found
  ; if inverse, a=0xFF
  inc  a  ; inverse? (if inverse, a=0)
  jp  nz,emitted.next_char  ; jump if inverse match not found
  ; inverse match
  dec  a  ; restore 0xFF
emitted.match:
  ld  c,a  ; inverse mask (0x00 or 0xFF)
  ld  b,0x07  ; count 7 more character rows
emitted.scans:
  inc  d  ; next screen scan (add 0x100)
  inc  hl  ; next bitmap address
  ld  a,(de)  ; screen scan
  xor  (hl)  ; will give 0x00 or 0xFF (inverse)
  xor  c  ; inverse mask to include the inverse status
  jp  nz,emitted.next_char  ; jump if no match
  djnz  emitted.scans  ; jump back till all scans done

  ; character match
  pop  bc  ; discard character set pointer
  pop  bc  ; discard screen pointer
  pop  bc  ; final count
  ld a,(hash_emitted_chars_pfa) ; number of chars in the charset
  sub  b ; ordinal number of the matched character (1 is the first)
  ld l,a
  jp emitted.end

emitted.next_char:
  pop  hl  ; restore character set pointer
  ld  de,0x0008  ; move it on 8 bytes
  add  hl,de  ; to the next character in the set
  pop  de  ; restore the screen pointer
  pop  bc  ; restore the counter
  djnz  emitted.do  ; loop back for the 96 characters
  ; no match
  ld l,b ; zero

emitted.end:
  pop bc ; restore the Forth IP
  ld h,0
  jp push_hl

; ----------------------------------------------
  _variable_header emitted_charset_,'EMITTED-CHARSET'

; doc{
;
; emitted-charset  ( -- a )
;
; Variable that holds the address of the first printable char in
; the charset used by `emitted`. By default it contains 0x3D00, the
; address of the space char in the ROM charset.
;
; }doc

  dw 0x3D00 ; address of the space in the ROM charset

; ----------------------------------------------
  _variable_header hash_emitted_chars_,'#EMITTED-CHARS'

; doc{
;
; #emitted-charset  ( -- a )
;
; Variable that holds the number of printable chars in the
; charset used by `emitted`. By default it contais 0x5F, the
; number of printable ASCII chars in the ROM charset.
;
; }doc

  dw 0x5F ; printable ASCII chars in the ROM charset

; ----------------------------------------------
  _code_header j_,'J'

; doc{
;
; j  ( -- x ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 ) \ ANS Forth
;
; Return a copy of the next-outer loop index.
;
; }doc

  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  jp fetch.hl

; ----------------------------------------------
  _colon_header two_constant_,'2CONSTANT'

  dw two_variable_
  dw paren_semicolon_code_
do_two_constant:
  inc de    ; de=pfa
  ex de,hl  ; hl=pfa
  jp two_fetch.hl

; ----------------------------------------------
  _colon_header two_variable_,'2VARIABLE'

; doc{
;
; 2variable ( "name" -- )  \ ANS Forth
;
; Parse _name_.  Create a definition for _name_ with the
; execution semantics defined below. Reserve two consecutive
; cells of data space.
;
;    _name_ is referred to as a two-variable.
;
;          name Execution: ( -- a )
;
;    _a_ is the address of the first (lowes address) cell of two
;    consecutive cells. A program is responsible for
;    initializing the contents.
;
; }doc

  dw create_
  dw lit_,cell*2,allot_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header u_dot_r_,'U.R'

  dw to_r_,zero_,from_r_,d_dot_r_
  dw semicolon_s_

; ----------------------------------------------
  _code_header two_over_,'2OVER'

; doc{
;
; 2over  ( d1 d2 -- d1 d2 d1 )
;
; }doc

  ld hl,4
  add hl,sp
  jp two_fetch.hl

if 1 ; fig_exit?

; ----------------------------------------------
  _colon_header exit_,'EXIT'

; doc{
;
; exit  ( -- ) ( R: a -- )  \ ANS Forth
;
; Return control to the calling definition, specified by the
; address on the return stack.
;
; Before executing `exit` within a do-loop, a program shall
; discard the loop-control parameters by executing `unloop`.
;
; }doc

; XXX TODO combine this `exit` with `;s`?

  dw r_drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_exit_,'?EXIT'

; doc{
;
; ?exit  ( f -- ) ( R: a | -- a | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by the address on the return stack.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; }doc

  dw question_branch_,exit_pfa
  dw semicolon_s_

else

; ----------------------------------------------
  _code_header question_exit_,'?EXIT'

; doc{
;
; ?exit  ( f -- ) ( R: a | -- a | )
;
; If _f_ is non-zero, return control to the calling definition,
; specified by the address on the return stack.
;
; `?exit` is not intended to be used within a do-loop. Use `if
; unloop exit then` instead.
;
; }doc

  pop hl
  ld h,a
  or l
  jp nz,exit_pfa
  _jp_next

endif

; ----------------------------------------------
  _colon_header char_,'CHAR'

  dw parse_name_,drop_,c_fetch_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header bracket_char_,'[CHAR]',immediate

  dw char_,literal_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header s_quote_,'S"',immediate

  ; : s"  ( compilation: "text<">" -- ) ( run-time:  -- ca len )
  ;  [char] " (s)  ; immediate

  _literal '"'
  dw paren_s_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_next_screen_,'?-->',immediate

  dw zero_branch_,question_next_screen.end
  dw next_screen_
question_next_screen.end:
  dw semicolon_s_

  ; XXX TODO a good place to use `??` instead of a branch:
;  dw question_question_,next_screen_
;  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_context_,".CONTEXT"

; XXX TMP for debuggging; already in the disk

; : .context  ( -- )  context #vocs 0 do
;                       dup @ ?dup if  pfa>nfa id.  then  cell+
;                     loop drop  ;

  dw context_,hash_vocs_,zero_,paren_do_
dot_context.do:
  dw dup_,fetch_,question_dup_
  dw zero_branch_,dot_context.end
  dw pfa_to_nfa_,id_dot_
dot_context.end:
  dw cell_plus_
  dw paren_loop_,dot_context.do
  dw drop_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header question_backslash_,'?\',immediate

; doc{
;
; ?\  ( f "ccc<eol> -- )
;
; If _f_ is not false, parse and discard the rest of the parse
; area. This word is used for conditional compilation.
;
; }doc

  dw zero_branch_,question_backslash.end
  dw backslash_
question_backslash.end:
  dw semicolon_s_

; ----------------------------------------------
  _colon_header backslash_,'\',immediate

; doc{
;
; \  ( -- )
; 
; Discard the rest of the parse area.
;
; }doc

  dw blk_,fetch_
  dw question_branch_,backslash.loading
  ; Interpreting
  dw span_,fetch_,to_in_,store_
  dw semicolon_s_

backslash.loading:
  ; Loading
  dw to_in_,fetch_,c_slash_l_,mod_
  dw c_slash_l_,swap_,minus_
  dw to_in_,plus_store_
  dw semicolon_s_

; ----------------------------------------------
  _colon_header dot_paren_,'.(',immediate

; doc{
;
; .(  ( 'text<paren>' -- )  \ immediate
;
; }doc

  _literal ')'
  dw parse_,type_
  dw semicolon_s_

latest_nfa_in_forth_voc: equ dot_paren_nfa

dictionary_pointer_after_cold:

; ==============================================================
; Name and link fields

move_name_fields_to_memory_bank:

  ; Move the name fields, assembled in ordinary memory, to the
  ; names bank. This routine is needed only once, therefore its
  ; call is patched with `noop` at the end; the routine itself
  ; will be overwritten by the Forth dictionary.

  ; The whole screen is used as intermediate buffer for copying
  ; the data.

  ld hl,names_bank_address ; origin
  ld de,sys_screen ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the data to the screen
  ld e,names_bank
  call bank.e
  ld hl,sys_screen ; origin
  ld de,names_bank_address ; destination
  ld bc,sys_screen_size ; count
  ldir ; copy the name fields to the bank
if 0 ; latin1_charset_in_bank
  ld hl,sys_screen+sys_screen_size-charset_size ; origin
  ld de,charset_address ; destination
  ld bc,charset_size ; count
  ldir ; copy the charset to the bank
endif
  ld e,default_bank
  call bank.e

  ; Erase the default bank (not necessary) ; XXX OLD
  ; ld hl,names_bank_address ; the first byte is 0
  ; ld de,names_bank_address+1
  ; ld bc,sys_screen
  ; ldir

  ; Remove the call to this routine:
  ld hl,only_first_cold ; address of the call to this routine
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  inc hl
  ld (hl),0 ; nop
  ret

  org names_bank_address

  db 0 ; fake length byte, needed by the algorithm used in `cfa>nfa`

if 0 ; latin1_charset_in_bank

  org names_bank_address+sys_screen_size-charset_size

  incbin solo_forth.charset.bin

endif

; ==============================================================
; End

end cold_entry

; ==============================================================
; Debug tools

  ;dw lit_,2,border_,key_,drop_,lit_,7,border_ ; XXX INFORMER
  ;dw lit_,0,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,1,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,2,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,4,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,5,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,6,border_,key_,drop_ ; XXX INFORMER
  ;dw lit_,7,border_,key_,drop_ ; XXX INFORMER

  ;dw two_dup_,two_,ink_,type_,zero_,ink_ ; XXX INFORMER

; ==============================================================
; Development notes
;
; 2015-06-25:
;
; Number  Times compiled (not including error numbers)
; 0       20
; 1       11
; 2       11
; 3       6

; vim: ft=z80
